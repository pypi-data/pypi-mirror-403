apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: eksclusters.pythonic.crossplane.io
spec:
  compositeTypeRef:
    apiVersion: pythonic.crossplane.io/v1alpha1
    kind: EksCluster
  mode: Pipeline
  pipeline:

  - step: render-templates
    functionRef:
      name: function-pythonic
    input:
      apiVersion: pythonic.fn.crossplane.io/v1alpha1
      kind: Composite
      composite: |
        class Composite(BaseComposite):
          def compose(self):
            v = self.resources.VPC('ec2.aws.crossplane.io/v1beta1', 'VPC')
            v.spec.forProvider(
              region = self.spec.cluster.region,
              enableDnsHostNames = True,
              enableDnsSupport = True,
              cidrBlock = '10.0.0.0/16',
              tags = self.tags(Name=self.spec.cluster.name))
            self.status.vpcId = v.status.atProvider.vpcId

            publicTableId, publicSubnetIds = self.compose_network(
              True, '10.0.0.0/20', '10.0.16.0/20', '10.0.32.0/20',
            )
            g = self.resources.InternetGateway('ec2.aws.crossplane.io/v1beta1', 'InternetGateway')
            g.spec.forProvider(
              region = self.spec.cluster.region,
              vpcId = self.status.vpcId,
              tags = self.tags(Name=self.spec.cluster.name))
            self.resources.RoutePublic('ec2.aws.crossplane.io/v1alpha1', 'Route').spec.forProvider(
              region = self.spec.cluster.region,
              routeTableId = publicTableId,
              destinationCIDRBlock = '0.0.0.0/0',
              gatewayId = g.status.atProvider.internetGatewayId)

            privateTableId, privateSubnetIds = self.compose_network(
              False, '10.0.64.0/18', '10.0.128.0/18', '10.0.192.0/18',
            )
            a = self.resources.Address('ec2.aws.crossplane.io/v1beta1', 'Address')
            a.spec.forProvider(
              region = self.spec.cluster.region,
              tags = self.tags(Name=self.spec.cluster.name))
            g = self.resources.NATGateway('ec2.aws.crossplane.io/v1beta1', 'NATGateway')
            g.spec.forProvider(
              region = self.spec.cluster.region,
              allocationId = a.status.atProvider.allocationId,
              subnetId = publicSubnetIds[0],
              tags = self.tags(Name=self.spec.cluster.name))
            self.resources.RoutePrivate('ec2.aws.crossplane.io/v1alpha1', 'Route').spec.forProvider(
              region = self.spec.cluster.region,
              routeTableId = privateTableId,
              destinationCIDRBlock = '0.0.0.0/0',
              natGatewayId = g.status.atProvider.natGatewayId)

            c = self.resources.Cluster('eks.aws.crossplane.io/v1beta1', 'Cluster')
            c.externalName = self.spec.cluster.name
            c.spec.forProvider(
              region = self.spec.cluster.region,
              roleArn = self.compose_cluster_role(),
              version = self.spec.cluster.version,
              resourcesVpcConfig = Map(
                subnetIds = List(*publicSubnetIds, *privateSubnetIds),
              ),
              tags = self.mtags())

          def compose_network(self, public, *subnets):
            access = 'public' if public else 'private'
            subnetIds = List()
            associations = List()
            for ix, subnet in enumerate(subnets):
              zone = chr(ord('a') + ix)
              s = self.resources[f"Subnet{access.capitalize()}{zone.capitalize()}"](
                'ec2.aws.crossplane.io/v1beta1', 'Subnet'
              )
              s.spec.forProvider(
                region = self.spec.cluster.region,
                vpcId = self.status.vpcId,
                availabilityZone = f"{self.spec.cluster.region}{zone}",
                cidrBlock = subnet,
                mapPublicIPOnLaunch = public,
                tags = self.tags(
                  f"Name = {self.spec.cluster.name}-{access}-{zone}",
                  f"kubernetes.io/cluster/{self.spec.cluster.name} = owned",
                  f"topology.kubernetes.io/zone = {self.spec.cluster.region}{zone}",
                  f"kubernetes.io/role/{'elb' if public else 'internal-elb'} = 1",
                ))
              subnetIds[ix] = s.status.atProvider.subnetId
              associations[ix].subnetId = s.status.atProvider.subnetId
            t = self.resources[f"RouteTable{access.capitalize()}"](
              'ec2.aws.crossplane.io/v1beta1', 'RouteTable'
            )
            t.spec.forProvider(
              region = self.spec.cluster.region,
              vpcId = self.status.vpcId,
              associations = associations,
              ignoreRoutes = True,
              tags = self.tags(Name=f"{self.spec.cluster.name}-{access}"))
            return t.status.atProvider.routeTableId, subnetIds

          def compose_cluster_role(self):
            name = f"{self.spec.cluster.name}-cluster"
            d = Map(Version = '2012-10-17')
            s = d.Statement[0]
            s.Effect = 'Allow'
            s.Principal.Service = 'eks.amazonaws.com'
            s.Action = 'sts:AssumeRole'
            r = self.resources.RoleCluster('iam.aws.crossplane.io/v1beta1', 'Role')
            r.externalName = name
            r.spec.forProvider.assumeRolePolicyDocument = format(d, 'json')
            r.spec.forProvider.tags = self.tags()
            for policy in ('ClusterPolicy', 'VPCResourceController'):
              self.resources[f"Rpa{policy}"](
                'iam.aws.crossplane.io/v1beta1', 'RolePolicyAttachment'
              ).spec.forProvider(
                roleName = r.status.atProvider.roleID and name,
                policyArn = f"arn:aws:iam::aws:policy/AmazonEKS{policy}")
            return r.status.atProvider.arn

          def tags(self, *args, **kwargs):
            tags = []
            for arg in args:
              arg = arg.split('=', 1)
              tags.append({'key': arg[0].strip(), 'value': arg[1].lstrip()})
            tags.extend([{'key': k, 'value': v} for k,v in kwargs.items()])
            if self.spec.tags:
              tags.extend([{'key': k, 'value': v} for k,v in self.spec.tags])
            return tags

          def mtags(self, *args, **kwargs):
            return {tag['key']: tag['value'] for tag in self.tags(*args, **kwargs)}
