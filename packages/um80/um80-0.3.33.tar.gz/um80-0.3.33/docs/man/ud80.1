.TH UD80 1 "November 2025" "um80 0.3.3" "User Commands"
.SH NAME
ud80 \- 8080/Z80 disassembler for CP/M .COM files
.SH SYNOPSIS
.B ud80
[\fB\-v\fR]
[\fB\-z\fR]
[\fB\-o\fR \fIoutput.mac\fR]
[\fB\-e\fR \fIaddress\fR[\fB,\fR\fIlabel\fR]]...
[\fB\-l\fR \fIaddress\fR[\fB,\fR\fIlabel\fR]]...
[\fB\-d\fR \fIstart\-end\fR]...
[\fB\-t\fR \fIstart\-end\fR]...
[\fB\-dc\fR \fIstart\-end\fR]...
[\fB\-da\fR \fIstart\-end\fR[\fB,\fR\fIlength\fR]]...
[\fB\-\-org\fR \fIaddress\fR]
.I input.com
.SH DESCRIPTION
.B ud80
is a disassembler for 8080 and Z80 binary files, designed to produce output
compatible with the
.BR um80 (1)
assembler. It converts CP/M .COM executable files (or raw binary files) back
into assembly source code that can be modified and reassembled.
.PP
The disassembler performs flow analysis starting from entry points to distinguish
code from data. Unvisited bytes are output as DB directives. The output is
designed to reassemble to an identical binary with um80.
.SH OPTIONS
.TP
.B \-v\fR, \fB\-\-version
Display version information and exit.
.TP
.BR \-z ", " \-\-z80
Enable Z80 mode. In this mode:
.RS
.IP \(bu 2
Z80 extended instructions are decoded (CB, DD, ED, FD prefixes)
.IP \(bu 2
Undocumented Z80 instructions are recognized
.IP \(bu 2
Zilog mnemonics are used in the output
.RE
.IP
Without this flag, only 8080 instructions are decoded using Intel mnemonics.
.TP
.BI \-o " output.mac"
Specify the output file name. Default is the input file name with a .mac extension.
.TP
.BI \-e " address" "\fR[\fB,\fIlabel\fR]"
Add an entry point at the specified hexadecimal address. Flow analysis will
trace execution from this address. Can be specified multiple times.
.IP
Optionally, specify a label name after a comma (e.g., \fB\-e 297a,ends\fR).
The label will be used in the output instead of an auto-generated one.
.IP
By default, the disassembler starts at the origin address (typically 0100h for
CP/M programs). Use \-e to add additional entry points for code that isn't
reached by normal flow (interrupt handlers, jump tables, etc.).
.TP
.BI \-l " address" "\fR[\fB,\fIlabel\fR]"
Add a label at the specified address without tracing it as code. Can be
specified multiple times.
.IP
Optionally, specify a label name after a comma (e.g., \fB\-l 4406,buffer\fR).
If no label name is given, an auto-generated label (L\fIxxxx\fR) is used.
.IP
Use this for data labels or for code that you want to label but not trace
(e.g., when you know it's already reached by other means).
.TP
.BI \-d " start\-end"
Force a range of addresses to be treated as data, not code. Both \fIstart\fR
and \fIend\fR are hexadecimal addresses. The range is inclusive.
Can be specified multiple times.
.IP
Use this for embedded data tables that might otherwise be incorrectly
disassembled as instructions.
.TP
.BI \-t " start\-end"
Mark a range of addresses as an address table. The range will be output as
DW (define word) directives with labels where possible, instead of individual
DB bytes. Both \fIstart\fR and \fIend\fR are hexadecimal addresses.
Can be specified multiple times.
.IP
Use this for jump tables or dispatch tables containing 16-bit addresses.
The table entries will be output as:
.RS
.nf
DW      L1234
DW      L5678
\&...
.fi
.RE
.TP
.BI \-dc " start\-end"
Mark a range as containing high-bit terminated strings. These are strings where
the last character has bit 7 set (OR 80H). Common in keyword tables.
Both \fIstart\fR and \fIend\fR are hexadecimal addresses.
Can be specified multiple times.
.IP
The output uses the DC directive which sets the high bit on the last character:
.RS
.nf
DC      'ABC'
.fi
.RE
.IP
Note: Each \-dc marks one string region. Token bytes or other data between
strings should not be included in the range.
.TP
.BI \-da " start\-end" "\fR[,\fIlength\fR]"
Mark a range as containing ASCII strings. Without a length parameter, strings
end at a null byte (00H) or any non-printable character. With a length, strings
are fixed-length. Both \fIstart\fR and \fIend\fR are hexadecimal addresses.
Can be specified multiple times.
.IP
Examples:
.RS
.nf
\-da 0200\-02FF          # Strings end at null or non-printable
\-da 0200\-02FF,8        # Fixed 8-character strings
.fi
.RE
.IP
Output format: \fBDB 'HELLO'\fR
.br
Any null terminator is output as a separate \fBDB 00H\fR directive.
.TP
.BI \-\-org " address"
Set the origin address (where the binary is loaded in memory). Default is 0100h,
the standard CP/M transient program area. The address is in hexadecimal.
.SH FLOW ANALYSIS
.B ud80
performs recursive descent disassembly starting from entry points:
.IP 1. 3
Begin at each entry point
.IP 2.
Decode instructions, following sequential execution
.IP 3.
When encountering branches (JMP, JNZ, CALL, etc.), queue branch targets
.IP 4.
Stop tracing at unconditional jumps, returns, and halts
.IP 5.
Continue until all reachable code is traced
.PP
.B Post-jump gap detection:
After an unconditional jump (JMP, RET, HLT), the bytes immediately following
are typically data, not code. The disassembler automatically detects these
"post-jump gaps" and marks them as data, preventing false code traces that
might otherwise occur if stale addresses happen to point into these regions.
.PP
.B Automatic jump table detection:
The disassembler automatically detects address tables (jump/dispatch tables)
using two methods:
.IP \(bu 2
.B Post-entry tables:
After the initial JMP at an entry point, if the following bytes form a
sequence of valid addresses (3 or more consecutive 16-bit values pointing
within the code range), they are treated as an address table.
.IP \(bu 2
.B Dispatch pattern detection:
Code sequences like "LXI H,addr / DAD B" indicate a table lookup. The
disassembler recognizes this pattern and marks the referenced address as
a table base.
.PP
Automatically detected tables are output as DW directives with labels,
making the disassembly more readable.
.PP
This approach correctly identifies code vs. data in most cases, but may miss
code only reached through computed jumps or interrupt vectors.
.SH OUTPUT FORMAT
The output is a valid
.BR um80 (1)
source file:
.PP
.RS
.nf
; Disassembly of program.com
; Generated by ud80

        ORG     0100H

L0100:  JMP     L0150       ; Jump to main
L0103:  DB      0,0,0       ; Data bytes
        ...
L0150:  MVI     A,0         ; Main entry
        ...
        END
.fi
.RE
.PP
Features of the output:
.IP \(bu 2
Labels are generated for all branch targets (L\fIxxxx\fR format)
.IP \(bu 2
Unreachable bytes are output as DB directives
.IP \(bu 2
String-like data is shown as DB with ASCII strings where possible
.PP
.B Note:
The END directive is output without an entry point label. In CP/M, execution
always begins at the load address (typically 0100H), so the entry point is
implicit. The first linked module determines where execution starts. An
END with an explicit label would only be useful for non-CP/M targets (such as
ROM-based systems) where a startup JMP would be inserted at the load address.
.SH 8080 vs Z80 MODE
.SS 8080 Mode (default)
Uses Intel 8080 mnemonics:
.IP \(bu 2
MOV, MVI, LXI for data movement
.IP \(bu 2
ADD, ADC, SUB, SBB for arithmetic
.IP \(bu 2
ANA, XRA, ORA for logic
.IP \(bu 2
JMP, JNZ, JZ, CALL, RET for control flow
.IP \(bu 2
Registers: A, B, C, D, E, H, L, M, SP, PSW
.SS Z80 Mode (\-z)
Uses Zilog Z80 mnemonics:
.IP \(bu 2
LD for most data movement
.IP \(bu 2
ADD, ADC, SUB, SBC for arithmetic
.IP \(bu 2
AND, XOR, OR for logic
.IP \(bu 2
JP, JR, CALL, RET, DJNZ for control flow
.IP \(bu 2
Additional registers: IX, IY, I, R
.IP \(bu 2
Extended instructions: LDIR, CPIR, bit operations, etc.
.PP
Z80 mode also decodes the CB, DD, ED, and FD prefix instructions, including
undocumented opcodes for the IXH, IXL, IYH, IYL registers.
.SH EXAMPLES
.TP
Basic disassembly:
.B ud80 program.com
.TP
Z80 mode:
.B ud80 \-z program.com
.TP
Custom output file:
.B ud80 \-o source.mac program.com
.TP
Add entry point:
.B ud80 \-e 0200 program.com
.TP
Multiple entry points:
.B ud80 \-e 0200 \-e 0300 \-e 0400 program.com
.TP
Force data range:
.B ud80 \-d 0500\-05FF program.com
.TP
Mark jump table (output as DW):
.B ud80 \-t 0103\-0120 program.com
.TP
Non-CP/M binary at 0000h:
.B ud80 \-\-org 0000 bios.bin
.TP
Combine options:
.B ud80 \-z \-e 0200 \-d 0300\-03FF \-t 0103\-0120 \-o source.mac game.com
.SH ROUND-TRIP VERIFICATION
To verify disassembly quality, reassemble and compare:
.PP
.RS
.nf
ud80 program.com
um80 program.mac
ul80 program.rel
cmp program.com program.new
.fi
.RE
.PP
If the files match, the disassembly is accurate.
.SH TIPS
.SS Finding Entry Points
.IP \(bu 2
Look for interrupt vectors at fixed addresses (RST handlers, etc.)
.IP \(bu 2
Search for jump table patterns
.IP \(bu 2
Examine call targets that flow analysis missed
.SS Identifying Data
.IP \(bu 2
Strings of ASCII characters
.IP \(bu 2
Tables of addresses (pairs of bytes)
.IP \(bu 2
Sequences that don't decode as valid instructions
.IP \(bu 2
Areas following unconditional jumps that aren't targeted by branches
.SS Iterative Refinement
.IP 1. 3
Run initial disassembly
.IP 2.
Examine output for incorrectly decoded data
.IP 3.
Add \-d flags for data regions
.IP 4.
Add \-e flags for missed code
.IP 5.
Re-disassemble and verify
.SH EXIT STATUS
.TP
.B 0
Disassembly successful.
.TP
.B 1
Error occurred (file not found, invalid address, etc.).
.SH FILES
.TP
.I input.com
Input binary file (CP/M executable or raw binary).
.TP
.I output.mac
Output assembly source file.
.SH LIMITATIONS
.IP \(bu 2
Self-modifying code cannot be correctly disassembled.
.IP \(bu 2
Computed jumps (JP (HL), etc.) don't contribute to flow analysis.
.IP \(bu 2
Overlay areas or banked memory cannot be handled automatically.
.IP \(bu 2
CP/M system calls are not annotated (would require additional analysis).
.SH SEE ALSO
.BR um80 (1),
.BR ul80 (1),
.BR ulib80 (1),
.BR ucref80 (1)
.SH HISTORY
.B ud80
was created as a companion tool for the um80 assembler toolchain. Unlike the
other tools which are implementations of Microsoft originals, ud80 is a new
tool designed to complement the toolchain by enabling disassembly of existing
CP/M programs.
.SH AUTHOR
um80 project contributors.
