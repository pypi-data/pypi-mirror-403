{#- Template Jinja2 para generar routers de FastAPI -#}
{#- Este template genera endpoints CRUD completos para cada tabla -#}
{#- Confia en los manejadores globales de excepciones para el manejo de errores -#}
{{ imports|join('\n') }}

{% set router_name = model.tablename + "_router" %}
{% set pk_path_params = "/{" + (model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | list | zip(model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='type') | map('replace', 'datetime', 'str') | map('replace', 'time', 'str') | map('replace', 'date', 'str') | list) | map('join', ':') | join('}/{')) + "}" %}
{% import "macros.j2" as macros %}
{% set zip = zip %}

logger = Alphi.get_logger_by_name("tai-api")

{{ router_name }} = APIRouter(
    prefix="/{{ model.tablename | replace('_', '-') }}",
    tags=["{{ model.name }}"]
)

@{{ router_name }}.get("",
    response_model=APIResponse[List[{{ model.name }}Read]],
    response_description="Lista de registros de {{ model.tablename }} obtenido exitosamente",
    operation_id="{{ model.tablename }}_find_many",
    summary="Busca varios registros en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Lista de registros de {{ model.tablename }} obtenido exitosamente",
            "content": {
                "application/json": {
                    "schema": {
                        "$ref": "#/components/schemas/APIResponse_List_{{ model.name }}Read__"
                    }
                }
            },
            "links": {{ macros.generate_find_many_links(model) | indent(12) }}
        },
        422: {
            "description": "Error de validación en parámetros",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "El límite no puede ser negativo",
                                "field": "limit",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_find_many(
    {{ macros.generate_pagination_parameters() | indent(4) }}
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {{ macros.generate_includes_parameter() }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[List[{{ model.name }}Read]]:
    """
    ## Resumen
    Obtiene una lista de `{{ model.tablename }}s` con filtros opcionales y soporte para paginación.
    
    Este endpoint permite realizar búsquedas flexibles aplicando filtros opcionales
    por cualquiera de los campos disponibles, con soporte completo para paginación
    mediante los parámetros limit y offset.

    ## Resultado
    En `APIResponse.data`, retorna un listado de objetos donde cada uno representa un registro de la tabla `{{ model.tablename }}` que incluye todos sus atributos

    ## Datos
    Para cada registro en `data` se incluye:
    {% for column in model.columns %}
    - **{{ column.name }}** ({{ column.type }}{% if column.nullable %}, opcional{% endif %}): {{ column.description }}
    {% endfor %}
    
    ## Parámetros de Filtrado
    
    Todos los parámetros de filtrado son opcionales y se pueden combinar:
    {{ macros.generate_query_args(model) | indent(4) }}
    
    ## Parámetros de Paginación
    
    - **limit**: Número máximo de registros a retornar. Solo admite valores positivos. Si no se especifica, retorna todos los registros que coincidan con los filtros.
    - **order_by**: Lista de nombres de columnas para ordenar los resultados.⚠️ **IMPORTANTE**: los nombres de columnas deben existir, si no serán omitidas.
    - **order**: Dirección de ordenamiento: 'ASC' para ascendente (por defecto), 'DESC' para descendente. Solo aplica si order_by está definido.
    - **offset**: Número de registros a omitir desde el inicio. Solo admite valores positivos. Si no se especifica, inicia desde el primer registro.
    
    ## Consulta combinada (recomendado para pocos registros)
    ⚠️ **IMPORTANTE**: Usa siempre el parámetro `includes` para cargar relaciones en una sola consulta y evitar múltiples llamadas al API.
    
    ⚠️ **WARNING**: Si la relación incluida tiene muchos registros relacionados, la respuesta puede ser muy grande y lenta. Mejor consultar su endpoint directamente con filtros.
    
    El parametro `includes` permite cargar relaciones asociadas a los registros.
    {% if model.relations %}

    ### Relaciones disponibles
    {% for relation in model.relations %}
    - **{{ relation.name }}**: {% if relation.direction == 'one-to-many' %}lista de {{ relation.target }} relacionados{% else %}{{ relation.target }} relacionado{% endif %} ({{ relation.direction }})

        {% if relation.description %}
        - **descripción**: {{ relation.description | indent(10) }}
        {% endif %}
    {% endfor %}
    
    ### Ejemplos básicos:
    #### Solo datos básicos
    `{{model.tablename }} = GET /{{model.tablename }}`
    
    {% for relation in model.relations %}
    #### Incluir {{ relation.name }}
    `{{model.tablename }} = GET /{{model.tablename }}?includes={{ relation.name }}`
    
    {% endfor %}
    {% if model.relations|length > 1 %}
    #### Múltiples relaciones en una sola consulta
    `{{model.tablename }} = GET /{{model.tablename }}?{% for relation in model.relations[:2] %}includes={{ relation.name }}{{ "&" if not loop.last }}{% endfor %}`
    
    {% endif %}
    #### Relaciones anidadas
    {% for relation in model.relations %}
    Puedes incluir los datos de {{ relation.name }} y además incluir sus propias relaciones  
    `{{ model.tablename }} = GET /{{ model.tablename }}?includes={{ relation.name }}.{nested_relation}`  
    {% endfor %}
    {% endif %}
    """
    {% if with_keycloak %}
    rls = [
        RLS(
            target_model=sqlalchemy_table_mapper.get(table),
            target_column=col_name,
            values=values
        ) for table, conditions in (token.rls or {}).items()
        for col_name, values in conditions.items()
        if sqlalchemy_table_mapper.get(table) is not None
    ]
    {% endif %}

    result = await api.{{ model.tablename }}.find_many(
        limit=limit,
        offset=offset,
        order_by=order_by,
        order=order,
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
        includes=includes,
        {% if with_keycloak %}        rls=rls or None{% endif %}
        
    )
    
    # Obtener el total para metadatos de paginación si es necesario
    total = None
    if limit is not None or offset is not None:
        try:
            total = await api.{{ model.tablename }}.count(
                {{ macros.asing_parameters(model).rstrip('\n') | indent(16) }}
            )
        except Exception as e:
            logger.warning(f"No se pudo obtener el total de registros: {str(e)}")
    
    return PaginatedResponse.success_paginated(
        data=result,
        total=total,
        limit=limit,
        offset=offset,
        message=f"{{ model.name }}s obtenidos exitosamente"
    )

@{{ router_name }}.get("/count", 
    response_model=APIResponse[int],
    response_description="Número de registros de {{ model.tablename }} según los filtros aplicados",
    operation_id="{{ model.tablename }}_count",
    summary="Cuenta registros en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Conteo realizado exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 42,
                        "message": "Conteo realizado exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_count(
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[int]:
    """
    Cuenta el número de {{ model.name }}s que coinciden con los filtros.
    """
    result = await api.{{ model.tablename }}.count(
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
    )
    
    return APIResponse.success(
        data=result,
        message="Conteo realizado exitosamente"
    )

@{{ router_name }}.get("/exists", 
    response_model=APIResponse[bool],
    operation_id="{{ model.tablename }}_exists",
    summary="Verifica existencia en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Verificación realizada exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": True,
                        "message": "Verificación realizada exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_exists(
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[bool]:
    """
    Verifica si existe al menos un {{ model.tablename }} que coincida con los filtros.
    """
    result = await api.{{ model.tablename }}.exists(
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
    )
    
    return APIResponse.success(
        data=result,
        message="Verificación realizada exitosamente"
    )

@{{ router_name }}.get("/{field}/sum",
    response_model=APIResponse[Union[int, float]],
    operation_id="{{ model.tablename }}_sum_field",
    summary="Suma un campo numérico específico en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Suma calculada exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 12500.75,
                        "message": "Suma de 'campo' calculada exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Campo inválido o no numérico",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "El campo especificado no es válido para suma",
                                "field": "field",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_sum_field(
    field: str = Path(..., description="Nombre del campo numérico a sumar"),
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[Union[int, float]]:
    """
    ## Resumen
    Calcula la suma de un campo numérico específico que coincida con los filtros.
    
    Este endpoint permite sumar los valores de un campo numérico en todos los registros
    que cumplan con los criterios de filtrado especificados.

    ## Parámetros
    
    - **field** (path): Nombre del campo numérico a sumar. Debe ser un campo de tipo numérico (int, float, decimal, etc.)
    
    ## Filtros Opcionales
    
    Todos los filtros de búsqueda estándar están disponibles:
    {{ macros.generate_query_args(model) | indent(4) }}
    
    ## Resultado
    
    Retorna directamente el valor de la suma en `data`. Si no hay registros que coincidan, retorna `null`.
    
    ## Ejemplos
    
    ```
    # Sumar campo sin filtros
    GET /{{ model.tablename }}/edad/sum
    
    # Sumar campo con filtros
    GET /{{ model.tablename }}/salario/sum?nombre=Juan
    ```
    """
    result = await api.{{ model.tablename }}.sum(
        agg_fields=[field],
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
    )
    
    # Verificar si la operación fue exitosa
    if not result.success:
        # Construir mensaje de error completo con todos los errores y warnings
        error_parts = []
        if result.errors:
            error_parts.extend(result.errors)
        if result.warnings:
            error_parts.extend(result.warnings)
        
        error_message = " | ".join(error_parts) if error_parts else "No se pudo calcular la suma"
        raise ValidationException(error_message, field)
    
    # Extraer el valor directo del diccionario retornado por el DAO
    sum_key = f"sum_{field}"
    value = result.data.get(sum_key) if result.data else None
    
    return APIResponse.success(
        data=value,
        message=f"Suma de '{field}' calculada exitosamente",
        meta={"warnings": result.warnings} if result.warnings else None
    )

@{{ router_name }}.get("/{field}/mean",
    response_model=APIResponse[float],
    operation_id="{{ model.tablename }}_mean_field",
    summary="Calcula la media de un campo numérico específico en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Media calculada exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 32.45,
                        "message": "Media de 'campo' calculada exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Campo inválido o no numérico",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "El campo especificado no es válido para media",
                                "field": "field",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_mean_field(
    field: str = Path(..., description="Nombre del campo numérico para calcular la media"),
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[float]:
    """
    ## Resumen
    Calcula la media (promedio) de un campo numérico específico que coincida con los filtros.
    
    Este endpoint permite calcular el promedio de los valores de un campo numérico en todos
    los registros que cumplan con los criterios de filtrado especificados.

    ## Parámetros
    
    - **field** (path): Nombre del campo numérico para calcular la media. Debe ser un campo de tipo numérico (int, float, decimal, etc.)
    
    ## Filtros Opcionales
    
    Todos los filtros de búsqueda estándar están disponibles:
    {{ macros.generate_query_args(model) | indent(4) }}
    
    ## Resultado
    
    Retorna directamente el valor de la media en `data`. Si no hay registros que coincidan, retorna `null`.
    
    ## Ejemplos
    
    ```
    # Calcular media de campo sin filtros
    GET /{{ model.tablename }}/edad/mean
    
    # Calcular media de campo con filtros
    GET /{{ model.tablename }}/salario/mean?departamento=ventas
    ```
    """
    result = await api.{{ model.tablename }}.mean(
        agg_fields=[field],
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
    )
    
    # Verificar si la operación fue exitosa
    if not result.success:
        # Construir mensaje de error completo con todos los errores y warnings
        error_parts = []
        if result.errors:
            error_parts.extend(result.errors)
        if result.warnings:
            error_parts.extend(result.warnings)
        
        error_message = " | ".join(error_parts) if error_parts else "No se pudo calcular la media"
        raise ValidationException(error_message, field)
    
    # Extraer el valor directo del diccionario retornado por el DAO
    mean_key = f"mean_{field}"
    value = result.data.get(mean_key) if result.data else None
    
    return APIResponse.success(
        data=value,
        message=f"Media de '{field}' calculada exitosamente",
        meta={"warnings": result.warnings} if result.warnings else None
    )

@{{ router_name }}.get("/{field}/max",
    response_model=APIResponse[Optional[Union[int, float, str]]],
    operation_id="{{ model.tablename }}_max_field",
    summary="Encuentra el valor máximo de un campo específico en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Valor máximo encontrado exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 99999.99,
                        "message": "Máximo de 'campo' encontrado exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Campo inválido",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "El campo especificado no es válido para máximo",
                                "field": "field",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_max_field(
    field: str = Path(..., description="Nombre del campo para encontrar el valor máximo"),
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[Optional[Union[int, float, str]]]:
    """
    ## Resumen
    Encuentra el valor máximo de un campo específico que coincida con los filtros.
    
    Este endpoint permite encontrar el valor máximo de un campo numérico o de fecha/hora
    en todos los registros que cumplan con los criterios de filtrado especificados.

    ## Parámetros
    
    - **field** (path): Nombre del campo para encontrar el máximo. Puede ser numérico (int, float, decimal) o temporal (date, datetime, timestamp)
    
    ## Filtros Opcionales
    
    Todos los filtros de búsqueda estándar están disponibles:
    {{ macros.generate_query_args(model) | indent(4) }}
    
    ## Resultado
    
    Retorna directamente el valor máximo en `data`. Si no hay registros que coincidan, retorna `null`.
    Para campos de fecha/hora, el valor se retorna en formato ISO 8601.
    
    ## Ejemplos
    
    ```
    # Encontrar valor máximo sin filtros
    GET /{{ model.tablename }}/salario/max
    
    # Encontrar fecha más reciente con filtros
    GET /{{ model.tablename }}/fecha_creacion/max?activo=true
    ```
    """
    result = await api.{{ model.tablename }}.max(
        agg_fields=[field],
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
    )
    
    # Verificar si la operación fue exitosa
    if not result.success:
        # Construir mensaje de error completo con todos los errores y warnings
        error_parts = []
        if result.errors:
            error_parts.extend(result.errors)
        if result.warnings:
            error_parts.extend(result.warnings)
        
        error_message = " | ".join(error_parts) if error_parts else "No se pudo encontrar el máximo"
        raise ValidationException(error_message, field)
    
    # Extraer el valor directo del diccionario retornado por el DAO
    max_key = f"max_{field}"
    value = result.data.get(max_key) if result.data else None
    
    return APIResponse.success(
        data=value,
        message=f"Máximo de '{field}' encontrado exitosamente",
        meta={"warnings": result.warnings} if result.warnings else None
    )

@{{ router_name }}.get("/{field}/min",
    response_model=APIResponse[Optional[Union[int, float, str]]],
    operation_id="{{ model.tablename }}_min_field",
    summary="Encuentra el valor mínimo de un campo específico en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Valor mínimo encontrado exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 100.00,
                        "message": "Mínimo de 'campo' encontrado exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Campo inválido",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "El campo especificado no es válido para mínimo",
                                "field": "field",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_min_field(
    field: str = Path(..., description="Nombre del campo para encontrar el valor mínimo"),
    {{ macros.generate_query_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[Optional[Union[int, float, str]]]:
    """
    ## Resumen
    Encuentra el valor mínimo de un campo específico que coincida con los filtros.
    
    Este endpoint permite encontrar el valor mínimo de un campo numérico o de fecha/hora
    en todos los registros que cumplan con los criterios de filtrado especificados.

    ## Parámetros
    
    - **field** (path): Nombre del campo para encontrar el mínimo. Puede ser numérico (int, float, decimal) o temporal (date, datetime, timestamp)
    
    ## Filtros Opcionales
    
    Todos los filtros de búsqueda estándar están disponibles:
    {{ macros.generate_query_args(model) | indent(4) }}
    
    ## Resultado
    
    Retorna directamente el valor mínimo en `data`. Si no hay registros que coincidan, retorna `null`.
    Para campos de fecha/hora, el valor se retorna en formato ISO 8601.
    
    ## Ejemplos
    
    ```
    # Encontrar valor mínimo sin filtros
    GET /{{ model.tablename }}/edad/min
    
    # Encontrar fecha más antigua con filtros
    GET /{{ model.tablename }}/fecha_registro/min?ciudad=Madrid
    ```
    """
    result = await api.{{ model.tablename }}.min(
        agg_fields=[field],
        {{ macros.asing_parameters(model).rstrip('\n') | indent(8) }}
    )
    
    # Verificar si la operación fue exitosa
    if not result.success:
        # Construir mensaje de error completo con todos los errores y warnings
        error_parts = []
        if result.errors:
            error_parts.extend(result.errors)
        if result.warnings:
            error_parts.extend(result.warnings)
        
        error_message = " | ".join(error_parts) if error_parts else "No se pudo encontrar el mínimo"
        raise ValidationException(error_message, field)
    
    # Extraer el valor directo del diccionario retornado por el DAO
    min_key = f"min_{field}"
    value = result.data.get(min_key) if result.data else None
    
    return APIResponse.success(
        data=value,
        message=f"Mínimo de '{field}' encontrado exitosamente",
        meta={"warnings": result.warnings} if result.warnings else None
    )

@{{ router_name }}.post("/agg",
    response_model=APIResponse[Dict[str, Optional[Union[int, float, str]]]],
    operation_id="{{ model.tablename }}_aggregate",
    summary="Realiza múltiples agregaciones en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Agregaciones calculadas exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": {
                            "sum_edad": 450,
                            "sum_salario": 150000.50,
                            "mean_edad": 30.5,
                            "max_fecha_nacimiento": "2000-01-15T00:00:00",
                            "min_fecha_nacimiento": "1970-05-20T00:00:00"
                        },
                        "message": "Agregaciones calculadas exitosamente",
                        "meta": {
                            "total_operations": 4,
                            "valid_operations": 4,
                            "total_expressions": 5,
                            "warnings": []
                        }
                    }
                }
            }
        },
        422: {
            "description": "Error de validación en operaciones o filtros",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "Operación 'median' no soportada. Operaciones válidas: ['sum', 'mean', 'max', 'min']",
                                "field": "operations",
                                "details": None
                            }
                        ]
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "INTERNAL_SERVER_ERROR",
                                "message": "Ha ocurrido un error inesperado",
                                "field": None,
                                "details": None
                            }
                        ]
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_aggregate(
    payload: Dict[str, Any] = Body(..., 
        example={
            "operations": {
                "sum": [
                    "precio",
                    "precio*cantidad",
                    {"expr": "ingreso-coste", "as": "ganancia"}
                ],
                "mean": ["cantidad"],
                "max": ["fecha_creacion"],
                "min": ["fecha_creacion"]
            },
            "filters": {
                "activo": True,
                "email": "%@gmail.com"
            }
        }
    ),
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[Dict[str, Optional[Union[int, float, str]]]]:
    """
    ## Resumen
    Realiza múltiples operaciones de agregación en una sola consulta sobre la tabla {{ model.tablename }}.
    
    Este endpoint permite combinar diferentes operaciones de agregación (sum, mean, max, min, count) 
    sobre múltiples campos en una única petición, con soporte completo para:
    - **Campos simples**: Agregaciones directas sobre columnas de la tabla
    - **Expresiones aritméticas**: Cálculos antes de agregar (e.g., `precio*cantidad`)
    - **Aliases personalizados**: Nombres descriptivos para los resultados
    - **Filtros avanzados**: Combinación de múltiples criterios de búsqueda

    ## Cuerpo de la Petición
    
    El body debe incluir:
    
    ### operations (requerido)
    Diccionario donde cada clave es una operación y el valor es una lista de campos o expresiones.
    
    Cada elemento de la lista puede ser:
    
    #### 1. Campo simple (string)
    ```json
    "sum": ["precio", "cantidad"]
    ```
    
    #### 2. Expresión aritmética (string)
    Operadores soportados: `+`, `-`, `*`, `/`, `%`, `(`, `)`
    ```json
    "sum": ["precio*cantidad", "(ingreso-costo)/cantidad"]
    ```
    
    #### 3. Expresión con alias personalizado (objeto)
    ```json
    "sum": [
        {"expr": "ingreso-costo", "as": "ganancia"},
        {"expr": "precio*cantidad", "as": "valor_total"}
    ]
    ```
    
    #### Operaciones disponibles:
    - **sum**: Suma de valores numéricos (campos o expresiones)
    - **mean**: Promedio de valores numéricos (campos o expresiones)
    - **max**: Valor máximo (numérico o fechas, solo campos simples)
    - **min**: Valor mínimo (numérico o fechas, solo campos simples)
    - **count**: Conteo de registros (cualquier campo)
    
    ⚠️ **IMPORTANTE**: Las expresiones aritméticas solo están disponibles para operaciones numéricas (sum, mean). 
    Para max/min de fechas, use campos simples.
    
    ### filters (opcional)
    Diccionario con filtros a aplicar. Las claves deben ser nombres de campos válidos:
    {{ macros.generate_query_args(model) | indent(4) }}
    
    Los filtros con prefijo `in_` permiten buscar múltiples valores (OR lógico).
    Los filtros `min_` y `max_` permiten rangos para campos numéricos o de fecha.
    Los filtros de texto soportan LIKE con el carácter `%`.
    
    ## Resultado
    
    Retorna un diccionario en `data` donde cada clave tiene el formato:
    - `{operación}_{campo}`: Para campos simples (e.g., `sum_precio`)
    - `{operación}_{alias}`: Para expresiones con alias (e.g., `sum_ganancia`)
    - `{operación}_{expresión_sanitizada}`: Para expresiones sin alias (e.g., `sum_precio_cantidad`)
    
    Valores retornados:
    - **sum**: Suma total (float o int)
    - **mean**: Media aritmética (float)
    - **max/min**: Valor máximo/mínimo (numeric → float, datetime → ISO 8601 string)
    - **count**: Cantidad de registros (int, nunca null, mínimo 0)
    
    El campo `meta` incluye:
    - **total_operations**: Número total de operaciones solicitadas
    - **valid_operations**: Número de operaciones procesadas exitosamente
    - **total_expressions**: Número total de expresiones SQL generadas
    - **warnings**: Lista de advertencias (campos no válidos, tipos incompatibles)
    - **operations_summary**: Detalle de cada operación con fields y labels
    
    ## Seguridad y Validaciones
    
    ✅ **Validaciones automáticas**:
    - Los campos deben existir en el modelo {{ model.name }}
    - Los campos numéricos son válidos para: sum, mean, max, min, count
    - Los campos de fecha son válidos para: max, min, count
    - Expresiones aritméticas solo permiten campos numéricos
    - Longitud máxima de expresiones: 200 caracteres
    - Máximo de tokens por expresión: 50
    - Profundidad máxima de paréntesis: 5 niveles
    
    ⚠️ **Comportamiento con campos inválidos**:
    - Si un campo no existe → se genera un error y se omite
    - Si un campo no es válido para su operación → se genera un warning y se omite
    - Si NO hay campos válidos → el endpoint retorna un error 422
    - Si hay AL MENOS un campo válido → el endpoint retorna éxito con warnings
    
    ## Ejemplos
    
    ### Ejemplo 1: Campos simples
    ```json
    POST /{{ model.tablename }}/agg
    {
      "operations": {
        "sum": ["precio", "cantidad"],
        "mean": ["precio"],
        "count": ["id"]
      }
    }
    ```
    **Respuesta:**
    ```json
    {
      "status": "success",
      "data": {
        "sum_precio": 15000.50,
        "sum_cantidad": 450,
        "mean_precio": 125.42,
        "count_id": 120
      },
      "meta": {
        "total_operations": 3,
        "valid_operations": 3,
        "total_expressions": 4,
        "warnings": []
      }
    }
    ```
    
    ### Ejemplo 2: Expresiones aritméticas sin alias
    ```json
    POST /{{ model.tablename }}/agg
    {
      "operations": {
        "sum": ["precio*cantidad", "total-descuento"],
        "mean": ["(ingreso-costo)/cantidad"]
      }
    }
    ```
    **Respuesta:**
    ```json
    {
      "status": "success",
      "data": {
        "sum_precio_cantidad": 125000.00,
        "sum_total_descuento": 98500.50,
        "mean_ingreso_costo_cantidad": 45.30
      }
    }
    ```
    
    ### Ejemplo 3: Expresiones con aliases personalizados
    ```json
    POST /{{ model.tablename }}/agg
    {
      "operations": {
        "sum": [
          {"expr": "ingreso-costo", "as": "ganancia"},
          {"expr": "precio*cantidad", "as": "valor_total"}
        ],
        "mean": [
          {"expr": "(ingreso-costo)/cantidad", "as": "margen_unitario"}
        ]
      },
      "filters": {
        "in_categoria": ["electronica", "hogar"],
        "min_fecha": "2024-01-01T00:00:00"
      }
    }
    ```
    **Respuesta:**
    ```json
    {
      "status": "success",
      "data": {
        "sum_ganancia": 45000.00,
        "sum_valor_total": 125000.00,
        "mean_margen_unitario": 12.50
      },
      "meta": {
        "total_operations": 2,
        "valid_operations": 2,
        "total_expressions": 3,
        "warnings": [],
        "operations_summary": {
          "sum": {
            "requested_fields": ["ingreso-costo", "precio*cantidad"],
            "valid_fields": ["ganancia", "valor_total"],
            "valid_count": 2
          },
          "mean": {
            "requested_fields": ["(ingreso-costo)/cantidad"],
            "valid_fields": ["margen_unitario"],
            "valid_count": 1
          }
        }
      }
    }
    ```
    
    ### Ejemplo 4: Combinación de campos simples, expresiones y filtros
    ```json
    POST /{{ model.tablename }}/agg
    {
      "operations": {
        "sum": [
          "precio",
          "cantidad",
          {"expr": "precio*cantidad", "as": "total_ventas"}
        ],
        "mean": ["precio"],
        "max": ["fecha_creacion"],
        "min": ["fecha_creacion"],
        "count": ["id"]
      },
      "filters": {
        "activo": true,
        "in_estado": ["completado", "enviado"],
        "email": "%@empresa.com",
        "min_fecha": "2024-01-01T00:00:00",
        "max_fecha": "2024-12-31T23:59:59"
      }
    }
    ```
    **Respuesta:**
    ```json
    {
      "status": "success",
      "data": {
        "sum_precio": 15000.50,
        "sum_cantidad": 450,
        "sum_total_ventas": 125000.00,
        "mean_precio": 125.42,
        "max_fecha_creacion": "2024-12-31T15:30:00",
        "min_fecha_creacion": "2024-01-05T08:15:00",
        "count_id": 120
      },
      "meta": {
        "total_operations": 5,
        "valid_operations": 5,
        "total_expressions": 7,
        "warnings": []
      }
    }
    ```
    
    ### Ejemplo 5: Manejo de campos inválidos
    ```json
    POST /{{ model.tablename }}/agg
    {
      "operations": {
        "sum": ["precio", "nombre", "cantidad"],
        "mean": ["descripcion", "precio"]
      }
    }
    ```
    **Respuesta:**
    ```json
    {
      "status": "success",
      "data": {
        "sum_precio": 15000.50,
        "sum_cantidad": 450,
        "mean_precio": 125.42
      },
      "meta": {
        "total_operations": 2,
        "valid_operations": 2,
        "total_expressions": 3,
        "warnings": [
          "Campo 'nombre' de tipo 'VARCHAR' no es válido para operación 'sum'",
          "Campo 'descripcion' de tipo 'TEXT' no es válido para operación 'mean'"
        ]
      }
    }
    ```
    """
    # Validar estructura del payload
    if not isinstance(payload, dict):
        raise ValidationException("El cuerpo de la petición debe ser un objeto JSON", "payload")
    
    operations = payload.get("operations", {})
    filters = payload.get("filters", {})
    
    # Validar que se proporcionaron operaciones
    if not operations:
        raise ValidationException("Se requiere al menos una operación en 'operations'", "operations")
    
    if not isinstance(operations, dict):
        raise ValidationException("'operations' debe ser un objeto con operaciones como claves", "operations")
    
    if not isinstance(filters, dict):
        filters = {}
    
    # Extraer los filtros y mapearlos a los parámetros del método agg()
    filter_params = {}
    {{ macros.extract_filter_params(model) | indent(4) }}
    
    # Llamar al método agg() del DAO
    result = await api.{{ model.tablename }}.agg(
        aggregations=operations,
        **filter_params
    )
    
    # Verificar si la operación fue exitosa
    if not result.success:
        # Si hay errores, lanzar excepción
        error_parts = []
        if result.errors:
            error_parts.extend(result.errors)
        if result.warnings:
            error_parts.extend(result.warnings)
        
        error_message = " | ".join(error_parts) if error_parts else "No se pudieron procesar las agregaciones"
        raise ValidationException(error_message, "operations")
    
    # Preparar metadata extendida
    meta = {
        "total_operations": result.metadata.get("total_operations", 0),
        "valid_operations": result.metadata.get("valid_operations", 0),
        "total_expressions": result.metadata.get("total_expressions", 0),
        "warnings": result.warnings,
        "operations_summary": result.metadata.get("operations_summary", {})
    }
    
    return APIResponse.success(
        data=result.data,
        message="Agregaciones calculadas exitosamente",
        meta=meta
    )

{% if not model.is_view %}


@{{ router_name }}.get("{{ pk_path_params }}", 
    response_model=APIResponse[{{ model.name }}Read],
    response_description="Registro único de {{ model.tablename }} obtenido exitosamente",
    operation_id="{{ model.tablename }}_find",
    summary="Busca un registro en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "Registro único de {{ model.tablename }} obtenido exitosamente",
            "content": {
                "application/json": {
                    "schema": {
                        "$ref": "#/components/schemas/APIResponse_{{ model.name }}Read_"
                    }
                }
            },
            "links": {{ macros.generate_find_links(model) | indent(12) }}
        },
        422: {
            "description": "Error de validación en parámetros",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "{{ model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | first }} debe ser mayor a 0",
                                "field": "{{ model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | first }}",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        404: {
            "description": "{{ model.name }} no encontrado",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "{{ model.name }} no encontrado",
                        "errors": [
                            {
                                "code": "RECORD_NOT_FOUND",
                                "message": "{{ model.name }} no encontrado",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_find(
    {{ macros.generate_path_parameters(model).rstrip('\n') | indent(4) }}
    {{ macros.generate_includes_parameter() }}
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('read', '{{ model.tablename }}')),{% endif %}

    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[{{ model.name }}Read]:
    """
    ## Resumen
    Obtiene un {{ model.name }} específico por su clave primaria.
    
    Este endpoint permite recuperar un registro individual de {{ model.name }}
    utilizando su identificador único (clave primaria). Opcionalmente puede
    incluir datos de relaciones asociadas.

    ## Resultado
    Si la consulta es exitosa, en `APIResponse.data`, retorna un objeto que representa un registro de la tabla `{{ model.tablename }}` que incluye todos sus atributos

    Si no se encuentra el registro, devuelve un error 404 `RECORD_NOT_FOUND`.

    ## Datos
    Para cada registro en `data` se incluye:
    {% for column in model.columns %}
    - **{{ column.name }}** ({{ column.type }}{% if column.nullable %}, opcional{% endif %}): {{ column.description }}
    {% endfor %}
    
    ## Parámetros de Identificación
    
    {% for column in model.columns if column.args.get('primary_key', False) %}
    - **{{ column.name }}**: {{ column.name }} del {{ model.name }} a buscar (tipo: {{ column.type }})
    {% endfor %}
    
    ## Consulta combinada (RECOMENDADO)
    ⚠️ **IMPORTANTE**: Usa siempre el parámetro `includes` para cargar relaciones en una sola consulta y evitar múltiples llamadas al API.
    
    El parametro `includes` permite cargar relaciones asociadas a los registros.
    {% if model.relations %}

    ### Relaciones disponibles (usar con parámetro 'includes'):
    {% for relation in model.relations %}
    - {{ relation.name }}: {% if relation.direction == 'one-to-many' %}Lista de {{ relation.target }} relacionados{% else %}{{ relation.target }} relacionado{% endif %} ({{ relation.direction }})
        {% if relation.description %}
        {{ relation.description | indent(10) }}
        {% endif %}
    {% endfor %}
    
    ### Uso del parámetro 'includes':
    Para cargar relaciones específicas, usa el parámetro 'includes' en la consulta:
    
    ### Ejemplos básicos:
    #### Solo datos básicos
    `{{model.tablename }} = GET /{{model.tablename }}{{ pk_path_params }}`
    
    {% for relation in model.relations %}
    #### Incluir {{ relation.name }}
    `{{model.tablename }} = GET /{{model.tablename }}{{ pk_path_params }}?includes={{ relation.name }}`
    
    {% endfor %}
    {% if model.relations|length > 1 %}
    #### Múltiples relaciones en una sola consulta
    `{{model.tablename }} = GET /{{model.tablename }}{{ pk_path_params }}?{% for relation in model.relations[:2] %}includes={{ relation.name }}{{ "&" if not loop.last }}{% endfor %}`
    
    {% endif %}
    #### Relaciones anidadas
    {% for relation in model.relations %}
    Puedes incluir los datos de {{ relation.name }} y además incluir sus propias relaciones  
    `{{ model.tablename }} = GET /{{ model.tablename }}{{ pk_path_params }}?includes={{ relation.name }}.{nested_relation}`
    {% endfor %}
    {% endif %}
    """
    # Validaciones básicas de entrada
    {% for column in model.columns if column.args.get('primary_key', False) and column.args.get('autoincrement', False) %}
    {% if column.type in ['int', 'BigInteger'] %}
    if {{ column.name }} <= 0:
        raise ValidationException("{{ column.name }} debe ser mayor a 0", "{{ column.name }}")
    {% endif %}
    {% endfor %}

    {% if with_keycloak %}
    rls = [
        RLS(
            target_model=sqlalchemy_table_mapper.get(table),
            target_column=col_name,
            values=values
        ) for table, conditions in (token.rls or {}).items()
        for col_name, values in conditions.items()
        if sqlalchemy_table_mapper.get(table) is not None
    ]
    {% endif %}
    
    result = await api.{{ model.tablename }}.find(
        {% for column in model.columns if column.args.get('primary_key', False) %}
        {{ column.name }}={{ column.name }},
        {% endfor %}
        includes=includes,
        {% if with_keycloak %}        rls=rls or None{% endif %}

    )
    
    if result is None:
        raise RecordNotFoundException("{{ model.name }}")
        
    return APIResponse.success(
        data=result,
        message="{{ model.name }} obtenido exitosamente"
    )

@{{ router_name }}.post("",
    response_model=APIResponse[{{ model.name }}Read],
    status_code=201,
    operation_id="{{ model.tablename }}_create",
    summary="Crea un registro en la tabla {{ model.tablename }}",
    responses={
        422: {
            "description": "Error de validación en los datos de entrada",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "El campo es requerido",
                                "field": "{{ model.columns | rejectattr('args.primary_key', 'equalto', True) | rejectattr('args.nullable', 'equalto', True) | map(attribute='name') | first | default('campo') }}",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        409: {
            "description": "Registro duplicado",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "El registro ya existe",
                        "errors": [
                            {
                                "code": "DUPLICATE_RECORD",
                                "message": "El registro ya existe",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Violación de clave foránea",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Violación de clave foránea",
                        "errors": [
                            {
                                "code": "FOREIGN_KEY_VIOLATION",
                                "message": "La referencia especificada no existe",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_create(
    {{ model.tablename }}: {{ model.name }}Create,
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('create', '{{ model.tablename }}')),{% endif %}
    
    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[{{ model.name }}Read]:
    """
    Crea un nuevo {{ model.name }}.
    """
    result = await api.{{ model.tablename }}.create({{ model.tablename }})
    
    return APIResponse.success(
        data=result,
        message="{{ model.name }} creado exitosamente"
    )

@{{ router_name }}.patch("{{ pk_path_params }}", 
    response_model=APIResponse[int],
    operation_id="{{ model.tablename }}_update",
    summary="Actualiza un registro en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "{{ model.name }} actualizado exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 1,
                        "message": "{{ model.name }} actualizado exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Error de validación en parámetros o datos",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "{{ model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | first }} debe ser mayor a 0",
                                "field": "{{ model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | first }}",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        404: {
            "description": "{{ model.name }} no encontrado",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "{{ model.name }} no encontrado",
                        "errors": [
                            {
                                "code": "RECORD_NOT_FOUND",
                                "message": "{{ model.name }} no encontrado",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Violación de clave foránea",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Violación de clave foránea",
                        "errors": [
                            {
                                "code": "FOREIGN_KEY_VIOLATION",
                                "message": "La referencia especificada no existe",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_update(
    {{ macros.generate_path_parameters(model).rstrip('\n') | indent(4) }}
    values: {{ model.name }}UpdateValues = Body(...),
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('update', '{{ model.tablename }}')),{% endif %}
    
    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[int]:
    """
    Actualiza un {{ model.name }} específico.
    """
    # Validaciones básicas de entrada
    {% for column in model.columns if column.args.get('primary_key', False) %}
    {% if column.type in ['int', 'BigInteger'] %}
    if {{ column.name }} <= 0:
        raise ValidationException("{{ column.name }} debe ser mayor a 0", "{{ column.name }}")
    {% endif %}
    {% endfor %}
    
    # Verificar que el registro existe antes de actualizar
    existing = await api.{{ model.tablename }}.find(
        {% for column in model.columns if column.args.get('primary_key', False) %}
        {{ column.name }}={{ column.name }},
        {% endfor %}
    )
    
    if existing is None:
        raise RecordNotFoundException("{{ model.name }}")
    
    result = await api.{{ model.tablename }}.update(
        {% for column in model.columns if column.args.get('primary_key', False) %}
        {{ column.name }}={{ column.name }},
        {% endfor %}
        updated_values=values
    )
    
    if result == 0:
        raise RecordNotFoundException("{{ model.name }}")
        
    return APIResponse.success(
        data=result,
        message="{{ model.name }} actualizado exitosamente"
    )

@{{ router_name }}.patch("", 
    response_model=APIResponse[int],
    operation_id="{{ model.tablename }}_update_many",
    summary="Actualiza múltiples registros en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "{{ model.name }}s actualizados exitosamente",
            "content": {
                "application/json": {
                    "examples": {
                        "records_updated": {
                            "summary": "Registros actualizados",
                            "value": {
                                "status": "success",
                                "data": 5,
                                "message": "5 {{ model.name }}s actualizados exitosamente",
                                "errors": None,
                                "meta": None
                            }
                        },
                        "no_records_found": {
                            "summary": "No se encontraron registros",
                            "value": {
                                "status": "success",
                                "data": 0,
                                "message": "No se encontraron registros que coincidan con los criterios",
                                "errors": None,
                                "meta": None
                            }
                        }
                    }
                }
            }
        },
        422: {
            "description": "Error de validación en los datos",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "Los criterios de búsqueda son requeridos",
                                "field": "filters",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_update_many(
    payload: {{ model.name }}Update,
    {% if with_keycloak %}    token: AccessToken = Depends(requires_permissions('update', '{{ model.tablename }}')),{% endif %}
    
    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[int]:
    """
    Actualiza múltiples {{ model.name }}s.
    """
    result = await api.{{ model.tablename }}.update_many(payload)
    
    message = f"{result} {{ model.name }}s actualizados exitosamente" if result > 0 else "No se encontraron registros que coincidan con los criterios"
    
    return APIResponse.success(
        data=result,
        message=message
    )

@{{ router_name }}.delete("{{ pk_path_params }}", 
    response_model=APIResponse[int],
    operation_id="{{ model.tablename }}_delete",
    summary="Elimina un registro en la tabla {{ model.tablename }}",
    responses={
        200: {
            "description": "{{ model.name }} eliminado exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "status": "success",
                        "data": 1,
                        "message": "{{ model.name }} eliminado exitosamente",
                        "errors": None,
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Error de validación en parámetros",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error de validación",
                        "errors": [
                            {
                                "code": "VALIDATION_ERROR",
                                "message": "{{ model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | first }} debe ser mayor a 0",
                                "field": "{{ model.columns | selectattr('args.primary_key', 'equalto', True) | map(attribute='name') | first }}",
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        404: {
            "description": "{{ model.name }} no encontrado",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "{{ model.name }} no encontrado",
                        "errors": [
                            {
                                "code": "RECORD_NOT_FOUND",
                                "message": "{{ model.name }} no encontrado",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        422: {
            "description": "Violación de clave foránea",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Violación de clave foránea",
                        "errors": [
                            {
                                "code": "FOREIGN_KEY_VIOLATION",
                                "message": "No se puede eliminar el registro porque está siendo referenciado",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        },
        500: {
            "description": "Error interno del servidor",
            "content": {
                "application/json": {
                    "example": {
                        "status": "error",
                        "data": None,
                        "message": "Error interno del servidor",
                        "errors": [
                            {
                                "code": "DATABASE_ERROR",
                                "message": "Error en la base de datos",
                                "field": None,
                                "details": None
                            }
                        ],
                        "meta": None
                    }
                }
            }
        }
    }
)
async def {{ model.tablename }}_delete(
    {{ macros.generate_path_parameters(model).rstrip('\n') | indent(4) }}
    {% if with_keycloak %}token: AccessToken = Depends(requires_permissions('delete', '{{ model.tablename }}')),{% endif %}
    
    api: {{ crud_class }} = Depends({{ crud_class }})
) -> APIResponse[int]:
    """
    Elimina un {{ model.name }} por su primary key.
    """
    # Validaciones básicas de entrada
    {% for column in model.columns if column.args.get('primary_key', False) %}
    {% if column.type in ['int', 'BigInteger'] %}
    if {{ column.name }} <= 0:
        raise ValidationException("{{ column.name }} debe ser mayor a 0", "{{ column.name }}")
    {% endif %}
    {% endfor %}
    
    # Verificar que el registro existe antes de eliminar
    existing = await api.{{ model.tablename }}.find(
        {% for column in model.columns if column.args.get('primary_key', False) %}
        {{ column.name }}={{ column.name }},
        {% endfor %}
    )
    
    if existing is None:
        raise RecordNotFoundException("{{ model.name }}")
    
    result = await api.{{ model.tablename }}.delete(
        {% for column in model.columns if column.args.get('primary_key', False) %}
        {{ column.name }}={{ column.name }},
        {% endfor %}
    )
    
    if result == 0:
        raise RecordNotFoundException("{{ model.name }}")
        
    return APIResponse.success(
        data=result,
        message="{{ model.name }} eliminado exitosamente"
    )
{% endif %}
