Metadata-Version: 2.4
Name: tai-api
Version: 0.2.20
Summary: FastAPI framework with TAI ecosystem integration
License: MIT
License-File: LICENSE
Keywords: fastapi,api,tai,web-framework
Author: MateoSaezMata
Author-email: msaez@triplealpha.in
Requires-Python: >=3.10,<4.0
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Framework :: FastAPI
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Topic :: Software Development :: Libraries :: Application Frameworks
Requires-Dist: asyncpg (>=0.30.0,<1.0)
Requires-Dist: fastapi[standard] (>=0.116.1,<1.0)
Requires-Dist: python-jose (>=3.5.0,<4.0)
Requires-Dist: tai-sql (>=0.3.59,<1.0)
Requires-Dist: uvicorn[standard] (>=0.30.0,<1.0)
Project-URL: Homepage, https://www.triplealpha.in/es/
Project-URL: Issues, https://github.com/triplealpha-innovation/tai-api/issues
Project-URL: Repository, https://github.com/triplealpha-innovation/tai-api
Description-Content-Type: text/markdown

# TAI-API

**TAI-API** es un framework Ã¡gil para el desarrollo de APIs REST basado en FastAPI, diseÃ±ado para acelerar la creaciÃ³n de APIs robustas y escalables mediante generaciÃ³n automÃ¡tica de cÃ³digo. Forma parte del ecosistema TAI (Triple Alpha Innovation) y se integra perfectamente con `tai-sql` para ofrecer una soluciÃ³n completa desde la base de datos hasta los endpoints.

## ğŸš€ CaracterÃ­sticas Principales

- **GeneraciÃ³n AutomÃ¡tica de Endpoints CRUD**: Crea endpoints completos automÃ¡ticamente a partir de tu esquema de base de datos
- **CLI Intuitivo**: Comandos simples para inicializar, generar y gestionar tu API
- **Soporte Multi-Schema**: Gestiona mÃºltiples esquemas de base de datos en un solo proyecto
- **AutenticaciÃ³n Integrada**: Soporte nativo para autenticaciÃ³n por base de datos o Keycloak
- **Operaciones Avanzadas**: Endpoints para agregaciones, conteos, existencia, y consultas complejas
- **Relaciones AutomÃ¡ticas**: Carga eager loading de relaciones con el parÃ¡metro `includes`
- **PaginaciÃ³n y Filtrado**: Soporte completo para paginaciÃ³n, ordenamiento y filtrado dinÃ¡mico
- **Model Context Protocol (MCP)**: ExposiciÃ³n de endpoints vÃ­a MCP para integraciÃ³n con herramientas AI
- **DocumentaciÃ³n OpenAPI**: DocumentaciÃ³n interactiva generada automÃ¡ticamente con Swagger UI
- **Type Safety**: ValidaciÃ³n de datos con Pydantic y tipado completo

## ğŸ“‹ Requisitos

- Python >= 3.10
- Poetry (para gestiÃ³n de dependencias)
- PostgreSQL (como base de datos)
- tai-sql >= 0.3.59

## ğŸ”§ InstalaciÃ³n

```bash
pip install tai-api
```

O con Poetry:

```bash
poetry add tai-api
```

## ğŸ¯ Inicio RÃ¡pido

### 1. Inicializar un Proyecto

```bash
tai-api init mi-proyecto --namespace api
```

Este comando:
- Crea la estructura de directorios del proyecto
- Configura Poetry y las dependencias necesarias
- Genera archivos de configuraciÃ³n
- Crea recursos Docker para desarrollo
- Establece el namespace de la aplicaciÃ³n (por defecto: `api`)

### 2. Configurar la Base de Datos

Primero, inicializa la configuraciÃ³n de `tai-sql`:

```bash
tai-sql init
```

Define tu esquema de base de datos y realiza la introspecciÃ³n:

```bash
tai-sql introspect --schema public
```

### 3. Generar la API

```bash
tai-api generate --schema public
```

Este comando genera automÃ¡ticamente:
- **Modelos Pydantic** para validaciÃ³n de datos
- **CRUD asÃ­ncrono** para operaciones de base de datos
- **Routers de FastAPI** con endpoints completos
- **Archivos de inicializaciÃ³n** con importaciones correctas
- **Diagramas ER** de la base de datos

### 4. Ejecutar en Modo Desarrollo

```bash
tai-api dev
```

Tu API estarÃ¡ disponible en `http://localhost:8000` con:
- DocumentaciÃ³n Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`
- OpenAPI Schema: `http://localhost:8000/openapi.json`

## ğŸ“š Comandos del CLI

### `tai-api init`

Inicializa un nuevo proyecto TAI-API.

```bash
tai-api init <nombre-proyecto> [OPTIONS]
```

**Argumentos:**
- `project`: Nombre del proyecto a crear

**Opciones:**
- `-n, --namespace`: Nombre del namespace/mÃ³dulo Python (por defecto: `api`)

**Ejemplo:**
```bash
tai-api init ecommerce-api --namespace backend
```

**Estructura Generada:**
```
ecommerce-api/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ __main__.py
â”‚   â”œâ”€â”€ __dev__.py
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ public/
â”‚   â”‚       â”œâ”€â”€ crud/
â”‚   â”‚       â””â”€â”€ models/
â”‚   â”œâ”€â”€ diagrams/
â”‚   â”œâ”€â”€ resources/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”‚   â”œâ”€â”€ handlers.py
â”‚   â”‚   â”œâ”€â”€ mcp.py
â”‚   â”‚   â””â”€â”€ responses.py
â”‚   â””â”€â”€ routers/
â”‚       â””â”€â”€ database/
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ dockerfile
â”‚   â””â”€â”€ entrypoint.sh
â””â”€â”€ pyproject.toml
```

---

### `tai-api generate`

**El comando mÃ¡s importante del CLI.** Genera todos los recursos de la API basÃ¡ndose en el esquema de base de datos.

```bash
tai-api generate [OPTIONS]
```

**Opciones:**
- `-s, --schema <nombre>`: Genera recursos para un esquema especÃ­fico
- `--all`: Genera recursos para todos los esquemas descubiertos

**Ejemplos:**
```bash
# Generar para el esquema por defecto
tai-api generate

# Generar para un esquema especÃ­fico
tai-api generate --schema public

# Generar para todos los esquemas
tai-api generate --all
```

#### Â¿QuÃ© Genera?

Para cada tabla en el esquema, el comando `generate` crea:

1. **Modelos Pydantic** (`database/{schema}/models/`)
   - DTOs para lectura (Read)
   - DTOs para creaciÃ³n (Create)
   - DTOs para actualizaciÃ³n (Update)
   
2. **CRUD AsÃ­ncrono** (`database/{schema}/crud/`)
   - Operaciones CRUD completas
   - MÃ©todos de agregaciÃ³n
   - Soporte para transacciones
   
3. **Routers de FastAPI** (`routers/database/{schema}/`)
   - Un archivo `router_{tabla}.py` por cada tabla
   - Un archivo `router_enums.py` con todos los enums
   - Archivo `__init__.py` con agregaciÃ³n de routers

4. **Diagramas ER** (`diagrams/`)
   - RepresentaciÃ³n visual del esquema

#### Tipos de Endpoints Generados

Para cada tabla, se generan automÃ¡ticamente los siguientes endpoints:

##### ğŸ” **Consulta y BÃºsqueda**

| Endpoint | MÃ©todo | DescripciÃ³n |
|----------|--------|-------------|
| `/{tabla}` | GET | Lista todos los registros con filtrado, paginaciÃ³n y ordenamiento |
| `/{tabla}/{id}` | GET | Obtiene un registro especÃ­fico por su clave primaria |
| `/{tabla}/count` | GET | Cuenta registros que coinciden con los filtros |
| `/{tabla}/exists` | GET | Verifica si existe al menos un registro con los filtros |

**Ejemplo de uso:**
```bash
# Listar usuarios con paginaciÃ³n
GET /usuario?limit=10&offset=0&order_by=created_at&order=DESC

# Buscar usuario por id
GET /usuario/123

# Contar usuarios activos
GET /usuario/count?active=true

# Verificar si existe un email
GET /usuario/exists?email=test@example.com
```

##### ğŸ“Š **Operaciones de AgregaciÃ³n**

| Endpoint | MÃ©todo | DescripciÃ³n |
|----------|--------|-------------|
| `/{tabla}/{campo}/sum` | GET | Suma todos los valores de un campo numÃ©rico |
| `/{tabla}/{campo}/mean` | GET | Calcula el promedio de un campo numÃ©rico |
| `/{tabla}/{campo}/max` | GET | Obtiene el valor mÃ¡ximo de un campo |
| `/{tabla}/{campo}/min` | GET | Obtiene el valor mÃ­nimo de un campo |
| `/{tabla}/agg` | POST | Realiza mÃºltiples agregaciones en una sola consulta |

**Ejemplo de uso:**
```bash
# Suma total de ventas
GET /venta/monto/sum

# Precio promedio de productos
GET /producto/precio/mean

# Agregaciones mÃºltiples
POST /venta/agg
{
  "aggregations": [
    {"field": "monto", "operation": "sum"},
    {"field": "monto", "operation": "mean"},
    {"field": "cantidad", "operation": "max"}
  ]
}
```

##### âœï¸ **CreaciÃ³n y ModificaciÃ³n**

| Endpoint | MÃ©todo | DescripciÃ³n |
|----------|--------|-------------|
| `/{tabla}` | POST | Crea un nuevo registro |
| `/{tabla}/{id}` | PATCH | Actualiza parcialmente un registro especÃ­fico |
| `/{tabla}` | PATCH | Actualiza mÃºltiples registros que coincidan con filtros |

**Ejemplo de uso:**
```bash
# Crear nuevo usuario
POST /usuario
{
  "nombre": "Juan PÃ©rez",
  "email": "juan@example.com",
  "active": true
}

# Actualizar usuario especÃ­fico
PATCH /usuario/123
{
  "nombre": "Juan P. Actualizado"
}

# Actualizar mÃºltiples usuarios
PATCH /usuario?active=false
{
  "estado": "inactivo"
}
```

##### ğŸ—‘ï¸ **EliminaciÃ³n**

| Endpoint | MÃ©todo | DescripciÃ³n |
|----------|--------|-------------|
| `/{tabla}/{id}` | DELETE | Elimina un registro especÃ­fico por su clave primaria |

**Ejemplo de uso:**
```bash
DELETE /usuario/123
```

##### ğŸ”— **Relaciones y Carga Eager**

Todos los endpoints de consulta soportan el parÃ¡metro `includes` para cargar relaciones asociadas en una sola consulta:

```bash
# Usuario con sus posts
GET /usuario/123?includes=posts

# Usuario con posts y comentarios de cada post
GET /usuario/123?includes=posts.comments

# MÃºltiples relaciones
GET /usuario/123?includes=posts,profile,roles
```

##### ğŸ“‹ **Enumeraciones**

Se genera un router especial `router_enums.py` con endpoints para obtener todos los valores de enumeraciones definidas:

```bash
# Listar todos los valores de un enum
GET /enums/estado-usuario

# Ejemplo de respuesta
{
  "status": "success",
  "data": ["active", "inactive", "pending", "blocked"],
  "message": "EnumeraciÃ³n obtenida exitosamente"
}
```

#### CaracterÃ­sticas de los Endpoints

Todos los endpoints generados incluyen:

- âœ… **ValidaciÃ³n automÃ¡tica** de datos con Pydantic
- âœ… **Manejo de errores** centralizado con respuestas consistentes
- âœ… **DocumentaciÃ³n OpenAPI** completa con ejemplos
- âœ… **Type hints** completos para autocompletado IDE
- âœ… **Logging** integrado con tai-alphi
- âœ… **Filtrado dinÃ¡mico** por cualquier campo
- âœ… **Ordenamiento** por mÃºltiples campos
- âœ… **PaginaciÃ³n** con limit/offset
- âœ… **Metadatos** de paginaciÃ³n en respuestas
- âœ… **Soporte CORS** configurable
- âœ… **CompresiÃ³n** de respuestas (gzip)

#### Estructura de Respuestas

Todos los endpoints siguen el formato estÃ¡ndar `APIResponse`:

```json
{
  "status": "success",
  "data": { /* datos del recurso */ },
  "message": "OperaciÃ³n exitosa",
  "errors": null,
  "meta": {
    "total": 100,
    "limit": 10,
    "offset": 0
  }
}
```

En caso de error:

```json
{
  "status": "error",
  "data": null,
  "message": "Error en la operaciÃ³n",
  "errors": [
    {
      "code": "VALIDATION_ERROR",
      "message": "El email es invÃ¡lido",
      "field": "email",
      "details": null
    }
  ],
  "meta": null
}
```

---

### `tai-api set-auth`

Configura el sistema de autenticaciÃ³n para la API.

```bash
tai-api set-auth
```

Este comando inicia un asistente interactivo que te guÃ­a a travÃ©s de las opciones de autenticaciÃ³n:

**Opciones de AutenticaciÃ³n:**

#### 1. **Database** - AutenticaciÃ³n basada en Base de Datos

Configura autenticaciÃ³n usando una tabla de usuarios en tu base de datos.

**El asistente solicita:**
- Tabla de usuarios
- Campo de username/email
- Campo de password (se hashea automÃ¡ticamente con bcrypt)
- OpciÃ³n de manejo de sesiones concurrentes
- Campo de session_id (si aplica)

**Genera:**
- Router de autenticaciÃ³n (`/auth`)
- Endpoints de login/logout
- GestiÃ³n de tokens JWT
- Dependencias de seguridad
- Middleware de autenticaciÃ³n

**Endpoints generados:**
```bash
POST /auth/login      # AutenticaciÃ³n
POST /auth/logout     # Cierre de sesiÃ³n
POST /auth/refresh    # Renovar token
GET  /auth/me         # Usuario actual
```

#### 2. **Keycloak** - AutenticaciÃ³n con Keycloak

Integra Keycloak como proveedor de identidad.

**El asistente solicita:**
- URL del servidor Keycloak
- Realm
- Client ID
- Client Secret
- ConfiguraciÃ³n de roles y permisos

**Genera:**
- IntegraciÃ³n completa con Keycloak
- ValidaciÃ³n de tokens
- Decoradores de permisos
- Mapeo de roles
- Row Level Security (RLS) basado en tokens

**Decorador de permisos:**
```python
@router.get("/users")
async def get_users(
    token: AccessToken = Depends(requires_permissions('read', 'users'))
):
    # Solo usuarios con permiso 'read' en recurso 'users'
    pass
```

**Ejemplo de uso:**
```bash
tai-api set-auth
# > Selecciona: 1 (Database) o 2 (Keycloak)
# > Sigue el asistente interactivo
```

---

### `tai-api dev`

Inicia el servidor de desarrollo con hot-reload.

```bash
tai-api dev [OPTIONS]
```

**Opciones:**
- `-w, --auth`: Ejecutar con autenticaciÃ³n habilitada

**Ejemplos:**
```bash
# Modo desarrollo sin autenticaciÃ³n
tai-api dev

# Modo desarrollo con autenticaciÃ³n
tai-api dev --auth
```

**CaracterÃ­sticas:**
- Hot-reload automÃ¡tico al detectar cambios
- Logs detallados en consola
- Servidor en `http://localhost:8000`
- DocumentaciÃ³n en `http://localhost:8000/docs`

---

### `tai-api set-mcp`

Configura el servidor para exponer endpoints vÃ­a Model Context Protocol (MCP).

```bash
tai-api set-mcp
```

**Â¿QuÃ© hace?**
- Instala la dependencia `fastapi-mcp`
- Configura el endpoint `/mcp`
- Actualiza la configuraciÃ³n del proyecto
- Regenera archivos principales

**Uso del endpoint MCP:**
```bash
GET /mcp
```

Expone los metadatos de la API en formato MCP para integraciÃ³n con herramientas de IA y automatizaciÃ³n.

---

## ğŸ—ï¸ Arquitectura del Proyecto

```
mi-proyecto/
â”œâ”€â”€ api/                          # Namespace principal
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ __main__.py               # Entry point con autenticaciÃ³n
â”‚   â”œâ”€â”€ __dev__.py                # Entry point para desarrollo
â”‚   â”‚
â”‚   â”œâ”€â”€ database/                 # Capa de datos
â”‚   â”‚   â””â”€â”€ public/               # Schema 'public'
â”‚   â”‚       â”œâ”€â”€ models/           # Modelos Pydantic
â”‚   â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â””â”€â”€ modelo_*.py
â”‚   â”‚       â””â”€â”€ crud/             # Operaciones CRUD
â”‚   â”‚           â””â”€â”€ asyn/
â”‚   â”‚               â””â”€â”€ __init__.py
â”‚   â”‚
â”‚   â”œâ”€â”€ routers/                  # Endpoints FastAPI
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ database/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ public/           # Routers del schema
â”‚   â”‚           â”œâ”€â”€ __init__.py
â”‚   â”‚           â”œâ”€â”€ router_tabla1.py
â”‚   â”‚           â”œâ”€â”€ router_tabla2.py
â”‚   â”‚           â””â”€â”€ router_enums.py
â”‚   â”‚
â”‚   â”œâ”€â”€ resources/                # Recursos compartidos
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ exceptions.py         # Excepciones personalizadas
â”‚   â”‚   â”œâ”€â”€ handlers.py           # Manejadores de errores
â”‚   â”‚   â”œâ”€â”€ responses.py          # Modelos de respuesta
â”‚   â”‚   â””â”€â”€ mcp.py                # ConfiguraciÃ³n MCP
â”‚   â”‚
â”‚   â””â”€â”€ diagrams/                 # Diagramas ER generados
â”‚
â”œâ”€â”€ docker/                       # Recursos Docker
â”‚   â”œâ”€â”€ dockerfile
â”‚   â””â”€â”€ entrypoint.sh
â”‚
â””â”€â”€ pyproject.toml                # ConfiguraciÃ³n Poetry
```

## ğŸ” AutenticaciÃ³n y Seguridad

### AutenticaciÃ³n Database

Cuando se configura autenticaciÃ³n por base de datos:

```python
# Endpoints protegidos automÃ¡ticamente
from api.auth import get_current_user

@router.get("/protected")
async def protected_route(
    current_user = Depends(get_current_user)
):
    return {"user": current_user.username}
```

### AutenticaciÃ³n Keycloak

Con Keycloak, se aplica Row Level Security (RLS) automÃ¡tico:

```python
from api.auth import requires_permissions

@router.get("/usuarios")
async def get_usuarios(
    token: AccessToken = Depends(requires_permissions('read', 'usuarios'))
):
    # RLS aplicado automÃ¡ticamente segÃºn token
    # Solo ve registros permitidos por sus permisos
    pass
```

## ğŸ¨ PersonalizaciÃ³n

### Modificar Endpoints Generados

Los routers generados son completamente editables. Puedes:

1. Agregar validaciones personalizadas
2. Modificar la lÃ³gica de negocio
3. AÃ±adir nuevos endpoints
4. Cambiar parÃ¡metros de bÃºsqueda

```python
# En router_usuario.py - puedes editar libremente
@usuario_router.post("/registro")
async def registro_personalizado(
    data: UsuarioCreate,
    api: PublicAsyncDBAPI = Depends(PublicAsyncDBAPI)
):
    # LÃ³gica personalizada
    # Validar email Ãºnico
    existe = await api.usuario.exists(email=data.email)
    if existe:
        raise ValidationException("Email ya registrado")
    
    # Crear usuario
    return await api.usuario.create(data)
```

### Agregar Middleware

```python
# En __main__.py
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### Configurar Base de Datos

La configuraciÃ³n de base de datos se gestiona a travÃ©s de `tai-sql`:

```bash
# Definir conexiÃ³n
tai-sql config set DATABASE_URL postgresql://user:pass@localhost/db

# Establecer schema por defecto
tai-sql set-default-schema public
```

## ğŸ§ª Testing

Ejemplo de test para endpoints generados:

```python
from fastapi.testclient import TestClient
from api import app

client = TestClient(app)

def test_get_usuarios():
    response = client.get("/usuario?limit=10")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "success"
    assert isinstance(data["data"], list)
    assert data["meta"]["limit"] == 10

def test_create_usuario():
    response = client.post("/usuario", json={
        "nombre": "Test User",
        "email": "test@example.com"
    })
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "success"
    assert data["data"]["email"] == "test@example.com"
```

## ğŸ“– IntegraciÃ³n con TAI-SQL

TAI-API se integra profundamente con TAI-SQL:

```bash
# 1. Inicializar tai-sql
tai-sql init

# 2. Definir esquema de BD
# Edita los archivos en schemas/

# 3. Aplicar migraciones
tai-sql migrate

# 4. IntrospecciÃ³n (opcional, para BD existente)
tai-sql introspect --schema public

# 5. Generar API
tai-api generate --schema public
```

## ğŸš¢ Despliegue

### Con Docker

```dockerfile
# Dockerfile generado automÃ¡ticamente
FROM python:3.11-slim

WORKDIR /app
COPY . .

RUN pip install poetry
RUN poetry install --no-dev

CMD ["poetry", "run", "uvicorn", "api:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Con Docker Compose

```yaml
version: '3.8'
services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    depends_on:
      - db
  
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
```

### ProducciÃ³n

```bash
# Instalar dependencias de producciÃ³n
poetry install --no-dev

# Ejecutar con Gunicorn + Uvicorn workers
gunicorn api:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 0.0.0.0:8000 \
  --access-logfile - \
  --error-logfile -
```

## ğŸ¤ ContribuciÃ³n

Las contribuciones son bienvenidas. Por favor:

1. Fork el repositorio
2. Crea una rama para tu feature (`git checkout -b feature/amazing-feature`)
3. Commit tus cambios (`git commit -m 'Add amazing feature'`)
4. Push a la rama (`git push origin feature/amazing-feature`)
5. Abre un Pull Request

## ğŸ“ Licencia

Este proyecto estÃ¡ bajo la Licencia MIT. Ver el archivo [LICENSE](LICENSE) para mÃ¡s detalles.

## ğŸ”— Enlaces

- **Homepage**: [Triple Alpha Innovation](https://www.triplealpha.in/es/)
- **Repositorio**: [GitHub - tai-api](https://github.com/triplealpha-innovation/tai-api)
- **Issues**: [GitHub Issues](https://github.com/triplealpha-innovation/tai-api/issues)
- **TAI-SQL**: [Repositorio tai-sql](https://github.com/triplealpha-innovation/tai-sql)

## ğŸ‘¥ Autores

- **MateoSaezMata** - [msaez@triplealpha.in](mailto:msaez@triplealpha.in)
- **CatuxaRama** - [crama@triplealpha.in](mailto:crama@triplealpha.in)

## ğŸ™ Agradecimientos

- FastAPI por el excelente framework
- El equipo de Triple Alpha Innovation
- La comunidad de cÃ³digo abierto

---

**Desarrollado con â¤ï¸ por Triple Alpha Innovation**
