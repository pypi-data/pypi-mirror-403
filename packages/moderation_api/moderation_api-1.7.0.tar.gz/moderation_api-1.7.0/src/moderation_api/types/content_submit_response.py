# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

from typing import Dict, List, Union, Optional
from typing_extensions import Literal, TypeAlias

from .._models import BaseModel

__all__ = [
    "ContentSubmitResponse",
    "Author",
    "AuthorBlock",
    "AuthorTrustLevel",
    "Content",
    "ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItem",
    "ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemText",
    "ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemImage",
    "ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemVideo",
    "ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemAudio",
    "Evaluation",
    "Insight",
    "InsightSentimentInsight",
    "InsightLanguageInsight",
    "Meta",
    "Policy",
    "PolicyClassifierOutput",
    "PolicyClassifierOutputLabel",
    "PolicyEntityMatcherOutput",
    "PolicyEntityMatcherOutputMatch",
    "Recommendation",
    "Error",
]


class AuthorBlock(BaseModel):
    """Block or suspension details, if applicable. Null if the author is enabled."""

    reason: Optional[str] = None
    """The moderators reason why the author was blocked or suspended."""

    until: Optional[float] = None
    """The timestamp until which they are blocked if the author is suspended."""


class AuthorTrustLevel(BaseModel):
    level: float
    """Author trust level (-1, 0, 1, 2, 3, or 4)"""

    manual: bool
    """True if the trust level was set manually by a moderator"""


class Author(BaseModel):
    """The author of the content if your account has authors enabled.

    Requires you to send authorId when submitting content.
    """

    id: str
    """Author ID in Moderation API"""

    block: Optional[AuthorBlock] = None
    """Block or suspension details, if applicable. Null if the author is enabled."""

    status: Literal["enabled", "suspended", "blocked"]
    """Current author status"""

    trust_level: AuthorTrustLevel

    external_id: Optional[str] = None
    """The author's ID from your system"""


class ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemText(BaseModel):
    """Text"""

    text: str
    """The content text"""

    type: Literal["text"]


class ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemImage(BaseModel):
    """Image"""

    type: Literal["image"]

    url: str
    """A public URL of the image content"""


class ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemVideo(BaseModel):
    """Video"""

    type: Literal["video"]

    url: str
    """A public URL of the video content"""


class ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemAudio(BaseModel):
    """Audio"""

    type: Literal["audio"]

    url: str
    """The URL of the audio content"""


ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItem: TypeAlias = Union[
    ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemText,
    ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemImage,
    ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemVideo,
    ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItemAudio,
]


class Content(BaseModel):
    """Potentially modified content."""

    id: str
    """The unique identifier for the content.

    Either the contentId provided by you or an autogenerated ID.
    """

    masked: bool
    """Whether any values have been masked."""

    modified: Union[
        str,
        Dict[str, object],
        Dict[str, ContentModifiedModifiedNestedObjectContentContentModifiedModifiedNestedObjectContentItem],
        None,
    ] = None
    """The modified content, if any."""


class Evaluation(BaseModel):
    """The evaluation of the content after running the channel policies."""

    flag_probability: float
    """The probability that the content should be flagged."""

    flagged: bool
    """Whether the content was flagged by any policy."""

    severity_score: float
    """The severity score of the content.

    A higher score indicates more severe content.
    """

    unicode_spoofed: Optional[bool] = None
    """Whether the content was flagged for Unicode spoofing."""


class InsightSentimentInsight(BaseModel):
    """Sentiment insight"""

    id: Literal["sentiment"]

    probability: float

    type: Literal["insight"]

    value: Optional[Literal["positive", "neutral", "negative"]] = None


class InsightLanguageInsight(BaseModel):
    """Language insight"""

    id: Literal["language"]

    probability: float

    type: Literal["insight"]

    value: Optional[str] = None


Insight: TypeAlias = Union[InsightSentimentInsight, InsightLanguageInsight]


class Meta(BaseModel):
    """Metadata about the moderation request"""

    channel_key: str
    """The unique key of the channel where the content was handled.

    Either the channel provided by you or automatically routed.
    """

    status: Literal["success", "partial_success"]

    timestamp: float

    usage: float

    processing_time: Optional[str] = None


class PolicyClassifierOutputLabel(BaseModel):
    id: str

    flagged: bool

    probability: float


class PolicyClassifierOutput(BaseModel):
    """Classifier policy."""

    id: str
    """The unique identifier for the classifier output."""

    flagged: bool

    probability: float

    type: Literal["classifier"]

    flagged_fields: Optional[List[str]] = None
    """The keys of the flagged fields if submitting an object."""

    labels: Optional[List[PolicyClassifierOutputLabel]] = None


class PolicyEntityMatcherOutputMatch(BaseModel):
    match: str

    probability: float

    span: List[int]


class PolicyEntityMatcherOutput(BaseModel):
    """Entity matcher policy."""

    id: str

    flagged: bool

    matches: List[PolicyEntityMatcherOutputMatch]

    probability: float

    type: Literal["entity_matcher"]

    flagged_fields: Optional[List[str]] = None


Policy: TypeAlias = Union[PolicyClassifierOutput, PolicyEntityMatcherOutput]


class Recommendation(BaseModel):
    """The recommendation for the content based on the evaluation."""

    action: Literal["review", "allow", "reject"]
    """The action to take based on the recommendation"""

    reason_codes: List[Literal["severity_reject", "severity_review", "author_block", "dry_run"]]
    """The reason code for the recommendation.

    Can be used to display a reason to the user.
    """


class Error(BaseModel):
    id: str

    message: str


class ContentSubmitResponse(BaseModel):
    author: Optional[Author] = None
    """The author of the content if your account has authors enabled.

    Requires you to send authorId when submitting content.
    """

    content: Content
    """Potentially modified content."""

    evaluation: Evaluation
    """The evaluation of the content after running the channel policies."""

    insights: List[Insight]
    """Results of all insights enabled in the channel."""

    meta: Meta
    """Metadata about the moderation request"""

    policies: List[Policy]
    """Results of all policies in the channel. Sorted by highest probability."""

    recommendation: Recommendation
    """The recommendation for the content based on the evaluation."""

    errors: Optional[List[Error]] = None
    """Policies that had errors"""
