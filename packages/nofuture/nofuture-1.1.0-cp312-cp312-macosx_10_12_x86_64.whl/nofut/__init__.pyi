# FILE: nofut.pyi
# stub file for autocompletion
from typing import TypeVar, Generic, Callable, Any, Iterator

T = TypeVar("T")
U = TypeVar("U")
E = TypeVar("E")

class MayBe(Generic[T]):
    def __init__(self, value: T | None): ...
    @staticmethod
    def just(value: T) -> "MayBe[T]": ...
    @staticmethod
    def nothing() -> "MayBe[T]": ...
    def is_just(self) -> bool: ...
    def is_nothing(self) -> bool: ...
    def unwrap(self) -> T: ...
    def expect(self, message: str) -> T: ...
    def to_option(self) -> T | None: ...
    def match(self, just: Callable[[T], U] | None = None, nothing: Callable[[], U] | None = None) -> U | None: ...
    def or_else(self, default: T) -> T: ...
    def map(self, fn: Callable[[T], U]) -> "MayBe[U]": ...
    def flat_map(self, fn: Callable[[T], "MayBe[U]"]) -> "MayBe[U]": ...
    def __or__(self, default: T) -> T: ...
    def __rshift__(self, fn: Callable[[T], "MayBe[U]"]) -> "MayBe[U]": ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __bool__(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __class_getitem__(cls, item: Any) -> type["MayBe[Any]"]: ...

class Result(Generic[T, E]):
    @staticmethod
    def ok(value: T) -> "Result[T, Any]": ...
    @staticmethod
    def err(message: str, code: str | None = None, details: Any | None = None) -> "Result[Any, str]": ...
    @staticmethod
    def from_dict(d: dict[str, Any]) -> "Result[Any, str]": ...
    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def unwrap(self) -> T: ...
    def expect(self, message: str) -> T: ...
    def to_option(self) -> T | None: ...
    def match(self, ok: Callable[[T], U] | None = None, err: Callable[[str, str | None, Any | None], U] | None = None) -> U | None: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_err(self) -> tuple[str, str | None, Any | None]: ...
    def map(self, fn: Callable[[T], U]) -> "Result[U, E]": ...
    def map_err(self, fn: Callable[[str, str | None, Any | None], tuple[str, str | None, Any | None]]) -> "Result[T, E]": ...
    def flat_map(self, fn: Callable[[T], "Result[U, E]"]) -> "Result[U, E]": ...
    def and_then(self, fn: Callable[[T], "Result[U, E]"]) -> "Result[U, E]": ...
    def to_dict(self) -> dict[str, Any]: ...
    def __or__(self, default: T) -> T: ...
    def __rshift__(self, fn: Callable[[T], "Result[U, E]"]) -> "Result[U, E]": ...
    def __bool__(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __class_getitem__(cls, item: Any) -> type["Result[Any, Any]"]: ...
