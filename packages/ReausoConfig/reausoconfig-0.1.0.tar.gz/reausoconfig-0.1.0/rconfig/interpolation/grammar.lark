// Expression grammar for ReausoConfig interpolation
// Supports: arithmetic, comparisons, booleans, string concat, list operations,
//           config references, environment variables, app resolvers, ternary, and coalesce

?start: expression

// Operator precedence (low to high):
// 1. ?: (ternary) - NEW
// 2. or
// 3. and
// 4. not
// 5. ?:, ?? (coalesce operators) - NEW
// 6. in, not in, ==, !=, <, >, <=, >=
// 7. + - (additive)
// 8. * / // % (multiplicative)
// 9. ** (power)
// 10. unary - +
// 11. | (pipe for filter)
// 12. [] (indexing/slicing), . (method calls)
// 13. atoms (literals, references, parentheses)

// Ternary operator (lowest precedence, right-associative)
// a ? b : c ? d : e = a ? b : (c ? d : e)
?expression: ternary_expr

?ternary_expr: or_expr
             | or_expr "?" ternary_expr ":" ternary_expr -> ternary

?or_expr: and_expr
        | or_expr "or" and_expr -> or_op

?and_expr: not_expr
         | and_expr "and" not_expr -> and_op

?not_expr: coalesce_expr
         | "not" not_expr -> not_op

// Coalesce operators (right-associative for chaining)
// ?: = Elvis (soft coalesce) - catches None and missing resolver/env
// ?? = Error (hard coalesce) - catches None and all exceptions
?coalesce_expr: comparison
              | comparison "?:" coalesce_expr -> elvis_coalesce
              | comparison "??" coalesce_expr -> error_coalesce

?comparison: pipe_expr
           | comparison "==" pipe_expr -> eq
           | comparison "!=" pipe_expr -> ne
           | comparison "<" pipe_expr -> lt
           | comparison ">" pipe_expr -> gt
           | comparison "<=" pipe_expr -> le
           | comparison ">=" pipe_expr -> ge
           | comparison "in" pipe_expr -> contains
           | comparison "not" "in" pipe_expr -> not_contains

?pipe_expr: add_expr
          | pipe_expr "|" "filter" "(" filter_condition ")" -> filter_op

// Filter condition: variable followed by comparison operator and value
// Supports: x > 5, x == "a", x != null, x < /threshold, etc.
filter_condition: FILTER_VAR "==" filter_value -> filter_eq
                | FILTER_VAR "!=" filter_value -> filter_ne
                | FILTER_VAR "<" filter_value -> filter_lt
                | FILTER_VAR ">" filter_value -> filter_gt
                | FILTER_VAR "<=" filter_value -> filter_le
                | FILTER_VAR ">=" filter_value -> filter_ge

// Values that can be compared against in filter condition
?filter_value: NUMBER -> number
             | ESCAPED_STRING -> string
             | "true" -> true
             | "false" -> false
             | "null" -> null
             | config_ref

?add_expr: mul_expr
         | add_expr "+" mul_expr -> add
         | add_expr "-" mul_expr -> sub

?mul_expr: pow_expr
         | mul_expr "*" pow_expr -> mul
         | mul_expr "/" pow_expr -> div
         | mul_expr "//" pow_expr -> floordiv
         | mul_expr "%" pow_expr -> mod

?pow_expr: unary_expr
         | unary_expr "**" pow_expr -> pow

?unary_expr: postfix_expr
           | "-" unary_expr -> neg
           | "+" unary_expr -> pos

?postfix_expr: atom
             | postfix_expr "[" expression "]" -> index
             | postfix_expr "[" slice "]" -> slice_op
             | postfix_expr "." "remove" "(" expression ")" -> remove_method

slice: expression ":" expression -> slice_both
     | expression ":"             -> slice_to_end
     | ":" expression             -> slice_from_start

?atom: NUMBER -> number
     | ESCAPED_STRING -> string
     | "true" -> true
     | "false" -> false
     | "null" -> null
     | list
     | config_ref
     | env_ref
     | app_resolver
     | builtin_func
     | "(" expression ")"

// List literal
list: "[" [expression ("," expression)*] "]"

// Built-in functions
builtin_func: "len" "(" expression ")" -> len_func

// Config path reference
config_ref: ABS_PATH -> abs_config_ref
          | PARENT_PATH -> parent_config_ref
          | REL_PATH -> rel_config_ref
          | SIMPLE_PATH -> simple_config_ref

// Environment variable reference
// Use coalesce operators for defaults: ${env:VAR ?: "default"} or ${env:VAR ?? "default"}
env_ref: "env" ":" ENV_NAME -> env_ref_required

// App resolver: app:path or app:path(args)
// Parentheses optional for no-arg resolvers
// Examples:
//   app:uuid                        (no parens, no args)
//   app:uuid()                      (explicit empty parens)
//   app:now("%Y-%m-%d")             (with args)
//   app:db:lookup("users", 42)      (namespaced with args)
//   app:db:cache:get("key", ttl=300)
app_resolver: "app" ":" resolver_path -> app_resolver_no_args
            | "app" ":" resolver_path "(" ")" -> app_resolver_no_args
            | "app" ":" resolver_path "(" resolver_args ")" -> app_resolver_with_args

// Resolver path: one or more colon-separated identifiers
resolver_path: RESOLVER_IDENT (":" RESOLVER_IDENT)*

// Resolver arguments (comma-separated, like function args)
resolver_args: resolver_arg ("," resolver_arg)*
resolver_arg: KW_ARG_NAME "=" expression -> resolver_kw_arg
            | expression -> resolver_pos_arg

// Identifier for resolver names (alphanumeric + underscore)
RESOLVER_IDENT: /[a-zA-Z_][a-zA-Z0-9_]*/

// Keyword argument name - higher priority than SIMPLE_PATH for keyword args
KW_ARG_NAME.2: /[a-zA-Z_][a-zA-Z0-9_]*(?==)/

// Path patterns
// Absolute: /model.layers[0].size
ABS_PATH: "/" PATH_CONTENT
// Parent-relative: ../sibling.value or ../../other.value (one or more ../)
PARENT_PATH: /(\.\.\/)+/ PATH_CONTENT
// Explicit relative: ./local.value
REL_PATH: "./" PATH_CONTENT
// Simple path (implicit relative): model.layers[0]
SIMPLE_PATH: PATH_CONTENT

// Path content: identifiers, dots, and bracket indices
// Note: Must not consume method names like .remove - use negative lookahead
PATH_CONTENT: /[a-zA-Z_][a-zA-Z0-9_]*(\.(?!remove\b)[a-zA-Z_][a-zA-Z0-9_]*|\[\d+\])*/

// Environment variable name (uppercase with underscores)
ENV_NAME: /[A-Za-z_][A-Za-z0-9_]*/

// Filter variable (single letter like x, y, etc.)
FILTER_VAR: /[a-z]/

// Terminals
NUMBER: SIGNED_NUMBER
SIGNED_NUMBER: /-?(\d+\.?\d*|\.\d+)([eE][+-]?\d+)?/

%import common.ESCAPED_STRING
%import common.WS
%ignore WS
