# Concepts and API guide

This page explains *how to think about* pbcgraph objects and what the main operations mean in practice.
For exact function/class signatures, see the **API Reference** section.

## Quotient graph vs infinite lift

A periodic graph in pbcgraph is stored as a **finite quotient graph** (internally a NetworkX `MultiDiGraph`):

- nodes are "templates" (e.g., sites, molecules, net vertices),
- directed edges represent connections between templates,
- each directed edge carries a translation vector \(t\in\mathbb{Z}^d\) telling you how the unit-cell index changes.

A lifted instance node is written as:

\[
(u, s),\quad u\in V_{quot},\; s\in \mathbb{Z}^d
\]

and an edge \(u\to v\) with translation \(t\) maps:

\[
(u, s) \to (v, s+t)
\]

This gives you a precise infinite graph semantics without materializing the infinite graph.

## Directed vs undirected

- `PeriodicDiGraph` stores directed quotient edges exactly as you add them.
- `PeriodicGraph` is undirected but is stored internally as *two* directed realizations per undirected edge:
    - `u -> v` with translation `tvec`
    - `v -> u` with translation `-tvec`

Both realizations share a single live attribute mapping.

### Important invariant (PeriodicGraph)

Removing an edge by `(u, v, key)` removes both directed realizations.
A single directed realization does not represent a valid undirected periodic edge by itself.

## Multi-edges and edge identity

pbcgraph distinguishes two container families:

- `PeriodicDiGraph` / `PeriodicGraph`: at most one edge per `(u, v, tvec)`.
  Here, the translation vector is treated as part of the edge identity.
- `PeriodicMultiDiGraph` / `PeriodicMultiGraph`: allow multiple edges per `(u, v, tvec)`.

In all cases, edges are addressed by `(u, v, key)`. Edge keys are intended to be integers.
If you explicitly provide a non-integer hashable key, it will be forwarded to the underlying NetworkX graph,
but pbcgraph only guarantees deterministic key generation and ordering for integer keys.

- If you do not provide a key, pbcgraph generates a deterministic fresh integer key.
- A `key` is shared between the two realizations of an undirected edge in `PeriodicGraph` / `PeriodicMultiGraph`.

## Attributes and version counters

pbcgraph tracks two counters:

- `structural_version`: increments on node/edge add/remove.
- `data_version`: increments on attribute updates *performed via pbcgraph APIs*.

`get_node_data()` / `get_edge_data()` return the underlying mutable mapping.
Direct mutation of that mapping is allowed but may not update `data_version` (treat as undefined behavior).

## Components, rank, and torsion

A **connected component** in the quotient graph corresponds to a periodic component in the infinite lift.
For directed containers in v0.1, pbcgraph uses **weak connectivity** (directions are ignored) when building
components.
Inside such a component, translations generated by cycles form a subgroup:

\[
L \subset \mathbb{Z}^d
\]

pbcgraph computes:

- `rank`: the rank of \(L\), i.e. the periodic dimension of the component (0D/1D/2D/3D inside a 3D lattice).
- `torsion_invariants`: torsion invariants from Smith Normal Form (SNF). Non-empty invariants indicate **multiple interpenetrating fragments** in the infinite lift.

### Instance keys (`inst_key`)

`PeriodicComponent.inst_key((u, shift))` returns a tuple of integers encoding the coset of the lifted instance in \(\mathbb{Z}^d/L\).
The numerical representation depends on a unimodular change of coordinates (see Theory), but the induced equivalence relation is exact:

- `same_fragment(a, b)` is True iff the lifted nodes lie in the same infinite-lift connected fragment.

## Quotient shortest paths

`shortest_path_quotient(G, source, target, connectivity=...)` runs BFS on the quotient graph:

- `connectivity='directed'`: successors only (default for `PeriodicDiGraph`)
- `connectivity='weak'`: successors âˆª predecessors (default behavior for undirected use-cases)

This is a quotient path; it does *not* compute an instance-aware shortest path in the infinite lift.
