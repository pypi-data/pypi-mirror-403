"""Lattice / subgroup utilities.

v0.1 needs Smith Normal Form (SNF) for a sublattice L subset Z^d generated by
translation vectors (cycle translations). We compute a unimodular transform
U (d x d) such that, in the new coordinates y = U * x, the sublattice has
diagonal generators.

Implementation notes:
    - We implement SNF with explicit row/column operations and track unimodular
      transforms U (left) and V (right).
    - Matrices are small in typical crystallography use cases, so a
      straightforward integer algorithm is appropriate.
"""

from __future__ import annotations

from dataclasses import dataclass
from fractions import Fraction
from typing import Iterable, List, Sequence, Tuple

from pbcgraph.core.types import TVec, validate_tvec


def _egcd(a: int, b: int) -> Tuple[int, int, int]:
    """Extended gcd.

    Returns:
        (g, x, y) such that x*a + y*b = g and g >= 0.
    """
    if b == 0:
        g = abs(a)
        if a == 0:
            return 0, 1, 0
        return g, 1 if a > 0 else -1, 0
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1
    while r != 0:
        q = old_r // r
        old_r, r = r, old_r - q * r
        old_s, s = s, old_s - q * s
        old_t, t = t, old_t - q * t
    g = old_r
    x, y = old_s, old_t
    if g < 0:
        g = -g
        x = -x
        y = -y
    return g, x, y


def _identity(n: int) -> List[List[int]]:
    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]


def _swap_rows(A: List[List[int]], i: int, j: int) -> None:
    A[i], A[j] = A[j], A[i]


def _swap_cols(A: List[List[int]], i: int, j: int) -> None:
    for r in range(len(A)):
        A[r][i], A[r][j] = A[r][j], A[r][i]


def _row_op_add(A: List[List[int]], src: int, dst: int, k: int) -> None:
    if k == 0:
        return
    row_src = A[src]
    row_dst = A[dst]
    for c in range(len(row_dst)):
        row_dst[c] += k * row_src[c]


def _col_op_add(A: List[List[int]], src: int, dst: int, k: int) -> None:
    if k == 0:
        return
    for r in range(len(A)):
        A[r][dst] += k * A[r][src]


def _row_op_mul(A: List[List[int]], i: int, k: int) -> None:
    if k == 1:
        return
    row = A[i]
    for c in range(len(row)):
        row[c] *= k


def _col_op_mul(A: List[List[int]], j: int, k: int) -> None:
    if k == 1:
        return
    for r in range(len(A)):
        A[r][j] *= k


def _combine_rows_gcd(
    A: List[List[int]], U: List[List[int]], i: int, p: int, col: int
) -> None:
    """Apply a 2x2 unimodular row transform on rows i and p to gcd
    in (i, col)."""
    a = A[i][col]
    b = A[p][col]
    if b == 0:
        return
    g, x, y = _egcd(a, b)  # x*a + y*b = g

    # Transformation:
    # new_i = x*row_i + y*row_p
    # new_p = (-b/g)*row_i + (a/g)*row_p
    u = -b // g
    v = a // g

    row_i = A[i][:]
    row_p = A[p][:]
    Ui = U[i][:]
    Up = U[p][:]

    A[i] = [x * row_i[c] + y * row_p[c] for c in range(len(row_i))]
    A[p] = [u * row_i[c] + v * row_p[c] for c in range(len(row_i))]

    U[i] = [x * Ui[c] + y * Up[c] for c in range(len(Ui))]
    U[p] = [u * Ui[c] + v * Up[c] for c in range(len(Ui))]


def _combine_cols_gcd(
    A: List[List[int]], V: List[List[int]], j: int, q: int, row: int
) -> None:
    """Apply a 2x2 unimodular column transform on cols j and q to gcd
    in (row, j)."""
    a = A[row][j]
    b = A[row][q]
    if b == 0:
        return
    g, x, y = _egcd(a, b)  # x*a + y*b = g
    u = -b // g
    v = a // g

    # Save columns.
    col_j = [A[r][j] for r in range(len(A))]
    col_q = [A[r][q] for r in range(len(A))]
    Vj = [V[r][j] for r in range(len(V))]
    Vq = [V[r][q] for r in range(len(V))]

    for r in range(len(A)):
        A[r][j] = x * col_j[r] + y * col_q[r]
        A[r][q] = u * col_j[r] + v * col_q[r]

    for r in range(len(V)):
        V[r][j] = x * Vj[r] + y * Vq[r]
        V[r][q] = u * Vj[r] + v * Vq[r]


def _find_nonzero(A: List[List[int]], i0: int, j0: int) -> Tuple[int, int]:
    """Find a nonzero entry in submatrix, preferring minimal abs value."""
    best = None
    best_pos = (-1, -1)
    for i in range(i0, len(A)):
        for j in range(j0, len(A[0])):
            v = A[i][j]
            if v == 0:
                continue
            av = abs(v)
            if best is None or av < best:
                best = av
                best_pos = (i, j)
    return best_pos


def smith_normal_form_with_transform(
    A0: List[List[int]]
) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]:
    """Compute SNF D and unimodular transforms U,V such that U*A0*V = D."""
    m = len(A0)
    n = len(A0[0]) if m else 0
    A = [row[:] for row in A0]
    U = _identity(m)
    V = _identity(n)

    i = 0
    j = 0
    while i < m and j < n:
        p, q = _find_nonzero(A, i, j)
        if p < 0:
            break

        if p != i:
            _swap_rows(A, p, i)
            _swap_rows(U, p, i)
        if q != j:
            _swap_cols(A, q, j)
            _swap_cols(V, q, j)

        # Main loop for this pivot.
        while True:
            # Ensure pivot divides its row/col by gcd-reducing
            # against all row/col entries.
            changed = True
            while changed:
                changed = False

                # Reduce pivot with column entries.
                for p2 in range(m):
                    if p2 == i:
                        continue
                    if A[p2][j] != 0:
                        old = abs(A[i][j])
                        _combine_rows_gcd(A, U, i, p2, j)
                        if abs(A[i][j]) != old:
                            changed = True

                # Reduce pivot with row entries.
                for q2 in range(n):
                    if q2 == j:
                        continue
                    if A[i][q2] != 0:
                        old = abs(A[i][j])
                        _combine_cols_gcd(A, V, j, q2, i)
                        if abs(A[i][j]) != old:
                            changed = True

            # Normalize sign.
            if A[i][j] < 0:
                _row_op_mul(A, i, -1)
                _row_op_mul(U, i, -1)

            d = A[i][j]
            if d == 0:
                break

            # Clear pivot column.
            for p2 in range(m):
                if p2 == i:
                    continue
                if A[p2][j] != 0:
                    qk = A[p2][j] // d
                    _row_op_add(A, i, p2, -qk)
                    _row_op_add(U, i, p2, -qk)

            # Clear pivot row.
            for q2 in range(n):
                if q2 == j:
                    continue
                if A[i][q2] != 0:
                    qk = A[i][q2] // d
                    _col_op_add(A, j, q2, -qk)
                    _col_op_add(V, j, q2, -qk)

            # Check divisibility in the remaining submatrix.
            off_i = -1
            off_j = -1
            for p2 in range(i + 1, m):
                for q2 in range(j + 1, n):
                    if A[p2][q2] % d != 0:
                        off_i = p2
                        off_j = q2
                        break
                if off_i != -1:
                    break

            if off_i == -1:
                break

            # Incorporate an offending entry into the pivot row/col
            # to reduce the pivot via gcd-reduction.
            _row_op_add(A, off_i, i, 1)
            _row_op_add(U, off_i, i, 1)
            _col_op_add(A, off_j, j, 1)
            _col_op_add(V, off_j, j, 1)
            # Continue loop to gcd-reduce again.

        i += 1
        j += 1

    # Final normalization: make diagonal nonnegative.
    for k in range(min(m, n)):
        if A[k][k] < 0:
            _row_op_mul(A, k, -1)
            _row_op_mul(U, k, -1)

    return A, U, V


@dataclass(frozen=True)
class SNFDecomposition:
    """Smith Normal Form decomposition for a sublattice `L` subset `Z^d`.

    Attributes:
        dim: Ambient lattice dimension `d`.
        rank: Rank of the sublattice `L` (number of non-zero diagonal entries).
        diag: Tuple of length `rank` with the (non-zero) SNF diagonal
            entries (invariant factors). Empty tuple if there are no
            generators.
        U: Unimodular change-of-basis matrix (left transform).
        U_inv: Inverse of `U` over the integers.
    """

    dim: int
    rank: int
    diag: Tuple[int, ...]
    U: Tuple[Tuple[int, ...], ...]
    U_inv: Tuple[Tuple[int, ...], ...]

    def apply_U(self, x: TVec) -> Tuple[int, ...]:
        """Compute y = U * x for a column vector x."""
        if len(x) != self.dim:
            raise ValueError('vector has wrong dimension')
        out: List[int] = []
        for i in range(self.dim):
            s = 0
            row = self.U[i]
            for j in range(self.dim):
                s += row[j] * x[j]
            out.append(int(s))
        return tuple(out)


def _to_tuple_matrix(A: List[List[int]]) -> Tuple[Tuple[int, ...], ...]:
    return tuple(tuple(int(v) for v in row) for row in A)


def _invert_unimodular_int_matrix(U: List[List[int]]) -> List[List[int]]:
    """Invert a unimodular integer matrix exactly.

    The input matrix is assumed to have determinant +/-1, so the inverse is
    an integer matrix.
    """
    n = len(U)
    if any(len(row) != n for row in U):
        raise ValueError('matrix must be square')

    # Augment with identity and perform Gauss-Jordan elimination over Q.
    A: List[List[Fraction]] = [
        [Fraction(int(U[i][j])) for j in range(n)]
        + [Fraction(1 if i == j else 0) for j in range(n)]
        for i in range(n)
    ]

    for col in range(n):
        pivot = None
        for r in range(col, n):
            if A[r][col] != 0:
                pivot = r
                break
        if pivot is None:
            raise ValueError('matrix is singular')
        if pivot != col:
            A[col], A[pivot] = A[pivot], A[col]

        piv = A[col][col]
        A[col] = [x / piv for x in A[col]]

        for r in range(n):
            if r == col:
                continue
            factor = A[r][col]
            if factor == 0:
                continue
            A[r] = [x - factor * y for x, y in zip(A[r], A[col])]

    inv: List[List[int]] = []
    for i in range(n):
        row_int: List[int] = []
        for j in range(n, 2 * n):
            f = A[i][j]
            if f.denominator != 1:
                raise ValueError('unimodular inverse is not integral')
            row_int.append(int(f.numerator))
        inv.append(row_int)
    return inv


def snf_decomposition(
    generators: Sequence[TVec], dim: int
) -> SNFDecomposition:
    """Compute SNF decomposition for the sublattice generated by `generators`.

    Args:
        generators: Translation vectors generating L (as a Z-span).
        dim: Ambient lattice dimension.

    Returns:
        SNFDecomposition with U, U_inv, diag, and rank.

    Notes:
        Generators are treated as columns of a matrix M (d x k).
    """
    if dim <= 0:
        raise ValueError('dim must be positive')
    for g in generators:
        validate_tvec(g, dim)

    if len(generators) == 0:
        U = _identity(dim)
        U_t = _to_tuple_matrix(U)
        return SNFDecomposition(dim=dim, rank=0, diag=(), U=U_t, U_inv=U_t)

    # Build M with columns = generators.
    k = len(generators)
    M = [[0 for _ in range(k)] for _ in range(dim)]
    for j, g in enumerate(generators):
        for i in range(dim):
            M[i][j] = int(g[i])

    D, U, _V = smith_normal_form_with_transform(M)

    # Extract diagonal (invariant factors) and rank.
    r = 0
    diag: List[int] = []
    for i in range(min(dim, k)):
        di = int(D[i][i])
        if di == 0:
            break
        r += 1
        diag.append(abs(di))

    # U is unimodular (det = +/-1), so its inverse is integral.
    U_inv = _invert_unimodular_int_matrix(U)

    return SNFDecomposition(
        dim=dim,
        rank=r,
        diag=tuple(diag),
        U=_to_tuple_matrix(U),
        U_inv=_to_tuple_matrix(U_inv),
    )


def smith_normal_form(
    generators: Iterable[TVec], dim: int
) -> Tuple[Tuple[int, ...], Tuple[Tuple[int, ...], ...]]:
    """Compute SNF torsion invariants and a basis transform.

    This is a small helper mirroring the original v0.1 skeleton signature.

    Args:
        generators: Translation generators for L.
        dim: Ambient dimension.

    Returns:
        A pair `(torsion_invariants, U)` where:
            - `torsion_invariants` is a tuple of diagonal entries > 1
              (torsion moduli),
            - `U` is the unimodular transform mapping x -> U*x
              used for reduction.
    """
    gens = list(generators)
    dec = snf_decomposition(gens, dim)
    torsion = tuple(di for di in dec.diag if di > 1)
    return torsion, dec.U
