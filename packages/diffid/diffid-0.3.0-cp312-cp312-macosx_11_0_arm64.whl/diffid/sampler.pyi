# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import datetime
import typing

import numpy
import numpy.typing

from diffid._diffid import NestedSamplesIterator, Problem, SamplesIterator

@typing.final
class DynamicNestedSampler:
    r"""
    Dynamic nested sampler binding exposing DNS configuration knobs.
    """
    def __new__(cls) -> DynamicNestedSampler: ...
    def with_live_points(self, live_points: builtins.int) -> DynamicNestedSampler: ...
    def with_expansion_factor(
        self, expansion_factor: builtins.float
    ) -> DynamicNestedSampler: ...
    def with_termination_tolerance(
        self, tolerance: builtins.float
    ) -> DynamicNestedSampler: ...
    def with_seed(self, seed: builtins.int) -> DynamicNestedSampler: ...
    def run(
        self,
        problem: Problem,
        initial: typing.Sequence[builtins.float] | None = None,
    ) -> NestedSamples: ...
    def init(
        self,
        initial: typing.Sequence[builtins.float],
        bounds: typing.Sequence[tuple[builtins.float, builtins.float]] | None = None,
    ) -> DynamicNestedSamplerState:
        r"""
        Initialize ask-tell sampling state.

        Returns a DynamicNestedSamplerState object that can be used for incremental
        sampling via the ask-tell interface.

        Parameters
        ----------
        initial : list[float]
            Initial point for the sampler
        bounds : list[tuple[float, float]], optional
            Parameter bounds as [(lower, upper), ...]. If None, unbounded.

        Returns
        -------
        DynamicNestedSamplerState
            State object for ask-tell sampling

        Examples
        --------
        >>> sampler = diffid.DynamicNestedSampler()
        >>> state = sampler.init(initial=[1.0, 2.0])
        >>> while True:
        ...     result = state.ask()
        ...     if isinstance(result, diffid.Done):
        ...         break
        ...     values = [evaluate(pt) for pt in result.points]
        ...     state.tell(values)
        """

@typing.final
class DynamicNestedSamplerState:
    r"""
    Ask-tell state for incremental Dynamic Nested Sampling.

    This state object allows step-by-step control over the sampling process.
    Use `ask()` to get points to evaluate, and `tell()` to provide results.

    Examples
    --------
    >>> sampler = diffid.DynamicNestedSampler()
    >>> state = sampler.init(initial=[1.0, 2.0])
    >>> while True:
    ...     result = state.ask()
    ...     if isinstance(result, diffid.Done):
    ...         print(f"Sampling complete: {result.result}")
    ...         break
    ...     values = [negative_log_likelihood(pt) for pt in result.points]
    ...     state.tell(values)
    """
    def ask(self) -> typing.Any:
        r"""
        Get the next action: evaluate points or sampling complete.

        Returns
        -------
        Evaluate | Done
            Either Evaluate(points) requiring function evaluations,
            or Done(result) indicating completion with NestedSamples.
        """
    def tell(self, results: typing.Sequence[builtins.float]) -> None:
        r"""
        Provide evaluation results for the requested points.

        Parameters
        ----------
        results : list[float]
            Negative log-likelihood values for each requested point.

        Raises
        ------
        TellError
            If called after sampling has terminated or if wrong number
            of results provided
        """
    def iterations(self) -> builtins.int:
        r"""
        Get the current iteration count.

        Returns
        -------
        int
            Number of iterations completed
        """
    def num_live_points(self) -> builtins.int:
        r"""
        Get the number of live points.

        Returns
        -------
        int
            Current number of live points in the sampler
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class MetropolisHastings:
    r"""
    Basic Metropolis-Hastings sampler binding mirroring the optimiser API.
    """
    def __new__(cls) -> MetropolisHastings: ...
    def with_num_chains(self, num_chains: builtins.int) -> MetropolisHastings: ...
    def with_iterations(self, iterations: builtins.int) -> MetropolisHastings: ...
    def with_step_size(self, step_size: builtins.float) -> MetropolisHastings: ...
    def with_seed(self, seed: builtins.int) -> MetropolisHastings: ...
    def run(
        self, problem: Problem, initial: typing.Sequence[builtins.float]
    ) -> Samples: ...
    def init(
        self,
        initial: typing.Sequence[builtins.float],
        bounds: typing.Sequence[tuple[builtins.float, builtins.float]] | None = None,
    ) -> MetropolisHastingsState:
        r"""
        Initialize ask-tell sampling state.

        Returns a MetropolisHastingsState object that can be used for incremental
        sampling via the ask-tell interface.

        Parameters
        ----------
        initial : list[float]
            Initial point for all chains
        bounds : list[tuple[float, float]], optional
            Parameter bounds as [(lower, upper), ...]. If None, unbounded.

        Returns
        -------
        MetropolisHastingsState
            State object for ask-tell sampling

        Examples
        --------
        >>> sampler = diffid.MetropolisHastings().with_num_chains(4)
        >>> state = sampler.init(initial=[1.0, 2.0])
        >>> while True:
        ...     result = state.ask()
        ...     if isinstance(result, diffid.Done):
        ...         break
        ...     values = [evaluate(pt) for pt in result.points]
        ...     state.tell(values)
        """

@typing.final
class MetropolisHastingsState:
    r"""
    Ask-tell state for incremental Metropolis-Hastings MCMC sampling.

    This state object allows step-by-step control over the sampling process.
    Use `ask()` to get proposal points to evaluate, and `tell()` to provide results.

    Examples
    --------
    >>> sampler = diffid.MetropolisHastings().with_num_chains(4)
    >>> state = sampler.init(initial=[1.0, 2.0])
    >>> while True:
    ...     result = state.ask()
    ...     if isinstance(result, diffid.Done):
    ...         print(f"Sampling complete: {result.result}")
    ...         break
    ...     values = [negative_log_likelihood(pt) for pt in result.points]
    ...     state.tell(values)
    """
    def ask(self) -> typing.Any:
        r"""
        Get the next action: evaluate proposal points or sampling complete.

        Returns
        -------
        Evaluate | Done
            Either Evaluate(points) requiring function evaluations,
            or Done(result) indicating completion with Samples.

        Notes
        -----
        Returns one proposal point per chain.
        """
    def tell(self, results: typing.Sequence[builtins.float]) -> None:
        r"""
        Provide evaluation results for the proposed points.

        Parameters
        ----------
        results : list[float]
            Negative log-likelihood values for each proposal point.
            Must match the number of chains.

        Raises
        ------
        TellError
            If called after sampling has terminated or if wrong number
            of results provided
        """
    def iterations(self) -> builtins.int:
        r"""
        Get the current iteration count.

        Returns
        -------
        int
            Number of iterations completed
        """
    def num_chains(self) -> builtins.int:
        r"""
        Get the number of chains being run.

        Returns
        -------
        int
            Number of parallel MCMC chains
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class NestedSamples:
    r"""
    Nested sampling results including evidence estimates.
    """
    @property
    def posterior(
        self,
    ) -> builtins.list[
        tuple[builtins.list[builtins.float], builtins.float, builtins.float]
    ]: ...
    @property
    def mean(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def draws(self) -> builtins.int: ...
    @property
    def log_evidence(self) -> builtins.float: ...
    @property
    def information(self) -> builtins.float: ...
    @property
    def time(self) -> datetime.timedelta: ...
    def to_samples(self) -> Samples: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str:
        r"""
        Return a human-readable summary of the nested samples.
        """
    def __len__(self) -> builtins.int:
        r"""
        Return the number of posterior samples.
        """
    def __iter__(self) -> NestedSamplesIterator:
        r"""
        Iterate over posterior samples.

        Yields tuples of (position, log_likelihood, log_weight).
        """
    def __getitem__(
        self, idx: builtins.int
    ) -> tuple[builtins.list[builtins.float], builtins.float, builtins.float]:
        r"""
        Get a specific posterior sample by index.

        Parameters
        ----------
        idx : int
            Sample index (0 to num_samples - 1)

        Returns
        -------
        tuple[list[float], float, float]
            Tuple of (position, log_likelihood, log_weight)
        """

@typing.final
class Samples:
    r"""
    Container for sampler draws and diagnostics.
    """
    @property
    def chains(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def samples(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def mean_x(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def acceptance_rate(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def draws(self) -> builtins.int: ...
    @property
    def time(self) -> datetime.timedelta: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str:
        r"""
        Return a human-readable summary of the samples.
        """
    def __len__(self) -> builtins.int:
        r"""
        Return the number of chains.
        """
    def __iter__(self) -> SamplesIterator:
        r"""
        Iterate over chains.

        Yields each chain as a list of samples.
        """
    def __getitem__(
        self, idx: builtins.int
    ) -> builtins.list[builtins.list[builtins.float]]:
        r"""
        Get a specific chain by index.

        Parameters
        ----------
        idx : int
            Chain index (0 to num_chains - 1)

        Returns
        -------
        list[list[float]]
            The requested chain
        """
