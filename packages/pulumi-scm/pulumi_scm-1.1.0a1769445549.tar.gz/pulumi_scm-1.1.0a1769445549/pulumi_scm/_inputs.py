# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AddressGroupDynamicArgs',
    'AddressGroupDynamicArgsDict',
    'AggregateInterfaceLayer2Args',
    'AggregateInterfaceLayer2ArgsDict',
    'AggregateInterfaceLayer2LacpArgs',
    'AggregateInterfaceLayer2LacpArgsDict',
    'AggregateInterfaceLayer3Args',
    'AggregateInterfaceLayer3ArgsDict',
    'AggregateInterfaceLayer3ArpArgs',
    'AggregateInterfaceLayer3ArpArgsDict',
    'AggregateInterfaceLayer3DdnsConfigArgs',
    'AggregateInterfaceLayer3DdnsConfigArgsDict',
    'AggregateInterfaceLayer3DhcpClientArgs',
    'AggregateInterfaceLayer3DhcpClientArgsDict',
    'AggregateInterfaceLayer3DhcpClientSendHostnameArgs',
    'AggregateInterfaceLayer3DhcpClientSendHostnameArgsDict',
    'AggregateInterfaceLayer3IpArgs',
    'AggregateInterfaceLayer3IpArgsDict',
    'AggregateInterfaceLayer3LacpArgs',
    'AggregateInterfaceLayer3LacpArgsDict',
    'AntiSpywareProfileMicaEngineSpywareEnabledArgs',
    'AntiSpywareProfileMicaEngineSpywareEnabledArgsDict',
    'AntiSpywareProfileRuleArgs',
    'AntiSpywareProfileRuleArgsDict',
    'AntiSpywareProfileRuleActionArgs',
    'AntiSpywareProfileRuleActionArgsDict',
    'AntiSpywareProfileRuleActionAlertArgs',
    'AntiSpywareProfileRuleActionAlertArgsDict',
    'AntiSpywareProfileRuleActionAllowArgs',
    'AntiSpywareProfileRuleActionAllowArgsDict',
    'AntiSpywareProfileRuleActionBlockIpArgs',
    'AntiSpywareProfileRuleActionBlockIpArgsDict',
    'AntiSpywareProfileRuleActionDropArgs',
    'AntiSpywareProfileRuleActionDropArgsDict',
    'AntiSpywareProfileRuleActionResetBothArgs',
    'AntiSpywareProfileRuleActionResetBothArgsDict',
    'AntiSpywareProfileRuleActionResetClientArgs',
    'AntiSpywareProfileRuleActionResetClientArgsDict',
    'AntiSpywareProfileRuleActionResetServerArgs',
    'AntiSpywareProfileRuleActionResetServerArgsDict',
    'AntiSpywareProfileThreatExceptionArgs',
    'AntiSpywareProfileThreatExceptionArgsDict',
    'AntiSpywareProfileThreatExceptionActionArgs',
    'AntiSpywareProfileThreatExceptionActionArgsDict',
    'AntiSpywareProfileThreatExceptionActionAlertArgs',
    'AntiSpywareProfileThreatExceptionActionAlertArgsDict',
    'AntiSpywareProfileThreatExceptionActionAllowArgs',
    'AntiSpywareProfileThreatExceptionActionAllowArgsDict',
    'AntiSpywareProfileThreatExceptionActionBlockIpArgs',
    'AntiSpywareProfileThreatExceptionActionBlockIpArgsDict',
    'AntiSpywareProfileThreatExceptionActionDefaultArgs',
    'AntiSpywareProfileThreatExceptionActionDefaultArgsDict',
    'AntiSpywareProfileThreatExceptionActionDropArgs',
    'AntiSpywareProfileThreatExceptionActionDropArgsDict',
    'AntiSpywareProfileThreatExceptionActionResetBothArgs',
    'AntiSpywareProfileThreatExceptionActionResetBothArgsDict',
    'AntiSpywareProfileThreatExceptionActionResetClientArgs',
    'AntiSpywareProfileThreatExceptionActionResetClientArgsDict',
    'AntiSpywareProfileThreatExceptionActionResetServerArgs',
    'AntiSpywareProfileThreatExceptionActionResetServerArgsDict',
    'AntiSpywareProfileThreatExceptionExemptIpArgs',
    'AntiSpywareProfileThreatExceptionExemptIpArgsDict',
    'AntiSpywareSignatureDefaultActionArgs',
    'AntiSpywareSignatureDefaultActionArgsDict',
    'AntiSpywareSignatureDefaultActionAlertArgs',
    'AntiSpywareSignatureDefaultActionAlertArgsDict',
    'AntiSpywareSignatureDefaultActionAllowArgs',
    'AntiSpywareSignatureDefaultActionAllowArgsDict',
    'AntiSpywareSignatureDefaultActionBlockIpArgs',
    'AntiSpywareSignatureDefaultActionBlockIpArgsDict',
    'AntiSpywareSignatureDefaultActionDropArgs',
    'AntiSpywareSignatureDefaultActionDropArgsDict',
    'AntiSpywareSignatureDefaultActionResetBothArgs',
    'AntiSpywareSignatureDefaultActionResetBothArgsDict',
    'AntiSpywareSignatureDefaultActionResetClientArgs',
    'AntiSpywareSignatureDefaultActionResetClientArgsDict',
    'AntiSpywareSignatureDefaultActionResetServerArgs',
    'AntiSpywareSignatureDefaultActionResetServerArgsDict',
    'AntiSpywareSignatureSignatureArgs',
    'AntiSpywareSignatureSignatureArgsDict',
    'AntiSpywareSignatureSignatureCombinationArgs',
    'AntiSpywareSignatureSignatureCombinationArgsDict',
    'AntiSpywareSignatureSignatureCombinationAndConditionArgs',
    'AntiSpywareSignatureSignatureCombinationAndConditionArgsDict',
    'AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgs',
    'AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgsDict',
    'AntiSpywareSignatureSignatureCombinationTimeAttributeArgs',
    'AntiSpywareSignatureSignatureCombinationTimeAttributeArgsDict',
    'AntiSpywareSignatureSignatureStandardArgs',
    'AntiSpywareSignatureSignatureStandardArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs',
    'AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict',
    'ApplicationDefaultArgs',
    'ApplicationDefaultArgsDict',
    'ApplicationDefaultIdentByIcmp6TypeArgs',
    'ApplicationDefaultIdentByIcmp6TypeArgsDict',
    'ApplicationDefaultIdentByIcmpTypeArgs',
    'ApplicationDefaultIdentByIcmpTypeArgsDict',
    'ApplicationFilterTaggingArgs',
    'ApplicationFilterTaggingArgsDict',
    'ApplicationSignatureArgs',
    'ApplicationSignatureArgsDict',
    'ApplicationSignatureAndConditionArgs',
    'ApplicationSignatureAndConditionArgsDict',
    'ApplicationSignatureAndConditionOrConditionArgs',
    'ApplicationSignatureAndConditionOrConditionArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorEqualToArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorEqualToArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorLessThanArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorLessThanArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgsDict',
    'ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgs',
    'ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgsDict',
    'AuthenticationProfileLockoutArgs',
    'AuthenticationProfileLockoutArgsDict',
    'AuthenticationProfileMethodArgs',
    'AuthenticationProfileMethodArgsDict',
    'AuthenticationProfileMethodCloudArgs',
    'AuthenticationProfileMethodCloudArgsDict',
    'AuthenticationProfileMethodKerberosArgs',
    'AuthenticationProfileMethodKerberosArgsDict',
    'AuthenticationProfileMethodLdapArgs',
    'AuthenticationProfileMethodLdapArgsDict',
    'AuthenticationProfileMethodLocalDatabaseArgs',
    'AuthenticationProfileMethodLocalDatabaseArgsDict',
    'AuthenticationProfileMethodRadiusArgs',
    'AuthenticationProfileMethodRadiusArgsDict',
    'AuthenticationProfileMethodSamlIdpArgs',
    'AuthenticationProfileMethodSamlIdpArgsDict',
    'AuthenticationProfileMethodTacplusArgs',
    'AuthenticationProfileMethodTacplusArgsDict',
    'AuthenticationProfileMultiFactorAuthArgs',
    'AuthenticationProfileMultiFactorAuthArgsDict',
    'AuthenticationProfileSingleSignOnArgs',
    'AuthenticationProfileSingleSignOnArgsDict',
    'AuthenticationSettingAuthenticationArgs',
    'AuthenticationSettingAuthenticationArgsDict',
    'AutoVpnClusterBranchArgs',
    'AutoVpnClusterBranchArgsDict',
    'AutoVpnClusterBranchInterfaceArgs',
    'AutoVpnClusterBranchInterfaceArgsDict',
    'AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgs',
    'AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgsDict',
    'AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgs',
    'AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgsDict',
    'AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs',
    'AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict',
    'AutoVpnClusterBranchPrivateInterfaceArgs',
    'AutoVpnClusterBranchPrivateInterfaceArgsDict',
    'AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgs',
    'AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgsDict',
    'AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs',
    'AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict',
    'AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs',
    'AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict',
    'AutoVpnClusterGatewayArgs',
    'AutoVpnClusterGatewayArgsDict',
    'AutoVpnClusterGatewayInterfaceArgs',
    'AutoVpnClusterGatewayInterfaceArgsDict',
    'AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgs',
    'AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgsDict',
    'AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgs',
    'AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgsDict',
    'AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs',
    'AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict',
    'AutoVpnClusterGatewayPrivateInterfaceArgs',
    'AutoVpnClusterGatewayPrivateInterfaceArgsDict',
    'AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgs',
    'AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgsDict',
    'AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs',
    'AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict',
    'AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs',
    'AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict',
    'AutoVpnSettingAsRangeArgs',
    'AutoVpnSettingAsRangeArgsDict',
    'BandwidthAllocationQosArgs',
    'BandwidthAllocationQosArgsDict',
    'BgpAddressFamilyProfileIpv4Args',
    'BgpAddressFamilyProfileIpv4ArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastArgs',
    'BgpAddressFamilyProfileIpv4MulticastArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastAddPathArgs',
    'BgpAddressFamilyProfileIpv4MulticastAddPathArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastAllowasInArgs',
    'BgpAddressFamilyProfileIpv4MulticastAllowasInArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgs',
    'BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgs',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgs',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgs',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgs',
    'BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastNextHopArgs',
    'BgpAddressFamilyProfileIpv4MulticastNextHopArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgs',
    'BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgs',
    'BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastOrfArgs',
    'BgpAddressFamilyProfileIpv4MulticastOrfArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgs',
    'BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgs',
    'BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgs',
    'BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityArgs',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgs',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgs',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgs',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgs',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgsDict',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgs',
    'BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastArgs',
    'BgpAddressFamilyProfileIpv4UnicastArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastAddPathArgs',
    'BgpAddressFamilyProfileIpv4UnicastAddPathArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastAllowasInArgs',
    'BgpAddressFamilyProfileIpv4UnicastAllowasInArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgs',
    'BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgs',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgs',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgs',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgs',
    'BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastNextHopArgs',
    'BgpAddressFamilyProfileIpv4UnicastNextHopArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgs',
    'BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgs',
    'BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastOrfArgs',
    'BgpAddressFamilyProfileIpv4UnicastOrfArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgs',
    'BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgs',
    'BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgs',
    'BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityArgs',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgs',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgs',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgs',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgs',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgsDict',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgs',
    'BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgsDict',
    'BgpFilteringProfileIpv4Args',
    'BgpFilteringProfileIpv4ArgsDict',
    'BgpFilteringProfileIpv4MulticastArgs',
    'BgpFilteringProfileIpv4MulticastArgsDict',
    'BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgs',
    'BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgsDict',
    'BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgs',
    'BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgsDict',
    'BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgs',
    'BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgsDict',
    'BgpFilteringProfileIpv4MulticastFilterListArgs',
    'BgpFilteringProfileIpv4MulticastFilterListArgsDict',
    'BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgs',
    'BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgsDict',
    'BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgs',
    'BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgsDict',
    'BgpFilteringProfileIpv4MulticastRouteMapsArgs',
    'BgpFilteringProfileIpv4MulticastRouteMapsArgsDict',
    'BgpFilteringProfileIpv4UnicastArgs',
    'BgpFilteringProfileIpv4UnicastArgsDict',
    'BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgs',
    'BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgsDict',
    'BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgs',
    'BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgsDict',
    'BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgs',
    'BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgsDict',
    'BgpFilteringProfileIpv4UnicastFilterListArgs',
    'BgpFilteringProfileIpv4UnicastFilterListArgsDict',
    'BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgs',
    'BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgsDict',
    'BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgs',
    'BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgsDict',
    'BgpFilteringProfileIpv4UnicastRouteMapsArgs',
    'BgpFilteringProfileIpv4UnicastRouteMapsArgsDict',
    'BgpRedistributionProfileIpv4Args',
    'BgpRedistributionProfileIpv4ArgsDict',
    'BgpRedistributionProfileIpv4UnicastArgs',
    'BgpRedistributionProfileIpv4UnicastArgsDict',
    'BgpRedistributionProfileIpv4UnicastConnectedArgs',
    'BgpRedistributionProfileIpv4UnicastConnectedArgsDict',
    'BgpRedistributionProfileIpv4UnicastOspfArgs',
    'BgpRedistributionProfileIpv4UnicastOspfArgsDict',
    'BgpRedistributionProfileIpv4UnicastStaticArgs',
    'BgpRedistributionProfileIpv4UnicastStaticArgsDict',
    'BgpRouteMapRedistributionBgpArgs',
    'BgpRouteMapRedistributionBgpArgsDict',
    'BgpRouteMapRedistributionBgpOspfArgs',
    'BgpRouteMapRedistributionBgpOspfArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Args',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4ArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapSetArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapSetArgsDict',
    'BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgs',
    'BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgsDict',
    'BgpRouteMapRedistributionBgpRibArgs',
    'BgpRouteMapRedistributionBgpRibArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapArgs',
    'BgpRouteMapRedistributionBgpRibRouteMapArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchArgs',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Args',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4ArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgs',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgs',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgs',
    'BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgsDict',
    'BgpRouteMapRedistributionBgpRibRouteMapSetArgs',
    'BgpRouteMapRedistributionBgpRibRouteMapSetArgsDict',
    'BgpRouteMapRedistributionConnectedStaticArgs',
    'BgpRouteMapRedistributionConnectedStaticArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Args',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4ArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4Args',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4ArgsDict',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgs',
    'BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Args',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4ArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgsDict',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgs',
    'BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibArgs',
    'BgpRouteMapRedistributionConnectedStaticRibArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapArgs',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgs',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Args',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4ArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgs',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgs',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgsDict',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgs',
    'BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgsDict',
    'BgpRouteMapRedistributionOspfArgs',
    'BgpRouteMapRedistributionOspfArgsDict',
    'BgpRouteMapRedistributionOspfBgpArgs',
    'BgpRouteMapRedistributionOspfBgpArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapMatchArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4Args',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4ArgsDict',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgs',
    'BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgsDict',
    'BgpRouteMapRedistributionOspfRibArgs',
    'BgpRouteMapRedistributionOspfRibArgsDict',
    'BgpRouteMapRedistributionOspfRibRouteMapArgs',
    'BgpRouteMapRedistributionOspfRibRouteMapArgsDict',
    'BgpRouteMapRedistributionOspfRibRouteMapMatchArgs',
    'BgpRouteMapRedistributionOspfRibRouteMapMatchArgsDict',
    'BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgs',
    'BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgsDict',
    'BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgs',
    'BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgsDict',
    'BgpRouteMapRedistributionOspfRibRouteMapSetArgs',
    'BgpRouteMapRedistributionOspfRibRouteMapSetArgsDict',
    'BgpRouteMapRouteMapArgs',
    'BgpRouteMapRouteMapArgsDict',
    'BgpRouteMapRouteMapMatchArgs',
    'BgpRouteMapRouteMapMatchArgsDict',
    'BgpRouteMapRouteMapMatchIpv4Args',
    'BgpRouteMapRouteMapMatchIpv4ArgsDict',
    'BgpRouteMapRouteMapMatchIpv4AddressArgs',
    'BgpRouteMapRouteMapMatchIpv4AddressArgsDict',
    'BgpRouteMapRouteMapMatchIpv4NextHopArgs',
    'BgpRouteMapRouteMapMatchIpv4NextHopArgsDict',
    'BgpRouteMapRouteMapMatchIpv4RouteSourceArgs',
    'BgpRouteMapRouteMapMatchIpv4RouteSourceArgsDict',
    'BgpRouteMapRouteMapSetArgs',
    'BgpRouteMapRouteMapSetArgsDict',
    'BgpRouteMapRouteMapSetAggregatorArgs',
    'BgpRouteMapRouteMapSetAggregatorArgsDict',
    'BgpRouteMapRouteMapSetIpv4Args',
    'BgpRouteMapRouteMapSetIpv4ArgsDict',
    'BgpRouteMapRouteMapSetMetricArgs',
    'BgpRouteMapRouteMapSetMetricArgsDict',
    'BgpRoutingRoutingPreferenceArgs',
    'BgpRoutingRoutingPreferenceArgsDict',
    'BgpRoutingRoutingPreferenceDefaultArgs',
    'BgpRoutingRoutingPreferenceDefaultArgsDict',
    'BgpRoutingRoutingPreferenceHotPotatoRoutingArgs',
    'BgpRoutingRoutingPreferenceHotPotatoRoutingArgsDict',
    'CertificateProfileCaCertificateArgs',
    'CertificateProfileCaCertificateArgsDict',
    'CertificateProfileUsernameFieldArgs',
    'CertificateProfileUsernameFieldArgsDict',
    'ContentIdSettingContentIdArgs',
    'ContentIdSettingContentIdArgsDict',
    'ContentIdSettingContentIdApplicationArgs',
    'ContentIdSettingContentIdApplicationArgsDict',
    'DecryptionProfileSslForwardProxyArgs',
    'DecryptionProfileSslForwardProxyArgsDict',
    'DecryptionProfileSslInboundProxyArgs',
    'DecryptionProfileSslInboundProxyArgsDict',
    'DecryptionProfileSslNoProxyArgs',
    'DecryptionProfileSslNoProxyArgsDict',
    'DecryptionProfileSslProtocolSettingsArgs',
    'DecryptionProfileSslProtocolSettingsArgsDict',
    'DecryptionRuleTypeArgs',
    'DecryptionRuleTypeArgsDict',
    'DecryptionRuleTypeSslForwardProxyArgs',
    'DecryptionRuleTypeSslForwardProxyArgsDict',
    'DecryptionRuleTypeSslInboundInspectionArgs',
    'DecryptionRuleTypeSslInboundInspectionArgsDict',
    'DeviceRedistributionCollectorRedistributionCollectorArgs',
    'DeviceRedistributionCollectorRedistributionCollectorArgsDict',
    'DhcpInterfaceRelayArgs',
    'DhcpInterfaceRelayArgsDict',
    'DhcpInterfaceRelayIpArgs',
    'DhcpInterfaceRelayIpArgsDict',
    'DhcpInterfaceServerArgs',
    'DhcpInterfaceServerArgsDict',
    'DhcpInterfaceServerOptionArgs',
    'DhcpInterfaceServerOptionArgsDict',
    'DhcpInterfaceServerOptionDnsArgs',
    'DhcpInterfaceServerOptionDnsArgsDict',
    'DhcpInterfaceServerOptionInheritanceArgs',
    'DhcpInterfaceServerOptionInheritanceArgsDict',
    'DhcpInterfaceServerOptionLeaseArgs',
    'DhcpInterfaceServerOptionLeaseArgsDict',
    'DhcpInterfaceServerOptionLeaseUnlimitedArgs',
    'DhcpInterfaceServerOptionLeaseUnlimitedArgsDict',
    'DhcpInterfaceServerOptionNisArgs',
    'DhcpInterfaceServerOptionNisArgsDict',
    'DhcpInterfaceServerOptionNtpArgs',
    'DhcpInterfaceServerOptionNtpArgsDict',
    'DhcpInterfaceServerOptionUserDefinedArgs',
    'DhcpInterfaceServerOptionUserDefinedArgsDict',
    'DhcpInterfaceServerOptionWinsArgs',
    'DhcpInterfaceServerOptionWinsArgsDict',
    'DhcpInterfaceServerReservedArgs',
    'DhcpInterfaceServerReservedArgsDict',
    'DnsProxyCacheArgs',
    'DnsProxyCacheArgsDict',
    'DnsProxyCacheMaxTtlArgs',
    'DnsProxyCacheMaxTtlArgsDict',
    'DnsProxyDefaultArgs',
    'DnsProxyDefaultArgsDict',
    'DnsProxyDefaultInheritanceArgs',
    'DnsProxyDefaultInheritanceArgsDict',
    'DnsProxyDomainServerArgs',
    'DnsProxyDomainServerArgsDict',
    'DnsProxyStaticEntryArgs',
    'DnsProxyStaticEntryArgsDict',
    'DnsProxyTcpQueriesArgs',
    'DnsProxyTcpQueriesArgsDict',
    'DnsProxyUdpQueriesArgs',
    'DnsProxyUdpQueriesArgsDict',
    'DnsProxyUdpQueriesRetriesArgs',
    'DnsProxyUdpQueriesRetriesArgsDict',
    'DnsSecurityProfileBotnetDomainsArgs',
    'DnsSecurityProfileBotnetDomainsArgsDict',
    'DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgs',
    'DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgsDict',
    'DnsSecurityProfileBotnetDomainsListArgs',
    'DnsSecurityProfileBotnetDomainsListArgsDict',
    'DnsSecurityProfileBotnetDomainsListActionArgs',
    'DnsSecurityProfileBotnetDomainsListActionArgsDict',
    'DnsSecurityProfileBotnetDomainsListActionAlertArgs',
    'DnsSecurityProfileBotnetDomainsListActionAlertArgsDict',
    'DnsSecurityProfileBotnetDomainsListActionAllowArgs',
    'DnsSecurityProfileBotnetDomainsListActionAllowArgsDict',
    'DnsSecurityProfileBotnetDomainsListActionBlockArgs',
    'DnsSecurityProfileBotnetDomainsListActionBlockArgsDict',
    'DnsSecurityProfileBotnetDomainsListActionSinkholeArgs',
    'DnsSecurityProfileBotnetDomainsListActionSinkholeArgsDict',
    'DnsSecurityProfileBotnetDomainsSinkholeArgs',
    'DnsSecurityProfileBotnetDomainsSinkholeArgsDict',
    'DnsSecurityProfileBotnetDomainsWhitelistArgs',
    'DnsSecurityProfileBotnetDomainsWhitelistArgsDict',
    'DosProtectionProfileFloodArgs',
    'DosProtectionProfileFloodArgsDict',
    'DosProtectionProfileFloodIcmpArgs',
    'DosProtectionProfileFloodIcmpArgsDict',
    'DosProtectionProfileFloodIcmpRedArgs',
    'DosProtectionProfileFloodIcmpRedArgsDict',
    'DosProtectionProfileFloodIcmpRedBlockArgs',
    'DosProtectionProfileFloodIcmpRedBlockArgsDict',
    'DosProtectionProfileFloodIcmpv6Args',
    'DosProtectionProfileFloodIcmpv6ArgsDict',
    'DosProtectionProfileFloodIcmpv6RedArgs',
    'DosProtectionProfileFloodIcmpv6RedArgsDict',
    'DosProtectionProfileFloodIcmpv6RedBlockArgs',
    'DosProtectionProfileFloodIcmpv6RedBlockArgsDict',
    'DosProtectionProfileFloodOtherIpArgs',
    'DosProtectionProfileFloodOtherIpArgsDict',
    'DosProtectionProfileFloodOtherIpRedArgs',
    'DosProtectionProfileFloodOtherIpRedArgsDict',
    'DosProtectionProfileFloodOtherIpRedBlockArgs',
    'DosProtectionProfileFloodOtherIpRedBlockArgsDict',
    'DosProtectionProfileFloodTcpSynArgs',
    'DosProtectionProfileFloodTcpSynArgsDict',
    'DosProtectionProfileFloodTcpSynRedArgs',
    'DosProtectionProfileFloodTcpSynRedArgsDict',
    'DosProtectionProfileFloodTcpSynRedBlockArgs',
    'DosProtectionProfileFloodTcpSynRedBlockArgsDict',
    'DosProtectionProfileFloodTcpSynSynCookiesArgs',
    'DosProtectionProfileFloodTcpSynSynCookiesArgsDict',
    'DosProtectionProfileFloodTcpSynSynCookiesBlockArgs',
    'DosProtectionProfileFloodTcpSynSynCookiesBlockArgsDict',
    'DosProtectionProfileFloodUdpArgs',
    'DosProtectionProfileFloodUdpArgsDict',
    'DosProtectionProfileFloodUdpRedArgs',
    'DosProtectionProfileFloodUdpRedArgsDict',
    'DosProtectionProfileFloodUdpRedBlockArgs',
    'DosProtectionProfileFloodUdpRedBlockArgsDict',
    'DosProtectionProfileResourceArgs',
    'DosProtectionProfileResourceArgsDict',
    'DosProtectionProfileResourceSessionsArgs',
    'DosProtectionProfileResourceSessionsArgsDict',
    'DosProtectionRuleActionArgs',
    'DosProtectionRuleActionArgsDict',
    'DosProtectionRuleActionAllowArgs',
    'DosProtectionRuleActionAllowArgsDict',
    'DosProtectionRuleActionDenyArgs',
    'DosProtectionRuleActionDenyArgsDict',
    'DosProtectionRuleActionProtectArgs',
    'DosProtectionRuleActionProtectArgsDict',
    'DosProtectionRuleProtectionArgs',
    'DosProtectionRuleProtectionArgsDict',
    'DosProtectionRuleProtectionAggregateArgs',
    'DosProtectionRuleProtectionAggregateArgsDict',
    'DosProtectionRuleProtectionClassifiedArgs',
    'DosProtectionRuleProtectionClassifiedArgsDict',
    'DosProtectionRuleProtectionClassifiedClassificationCriteriaArgs',
    'DosProtectionRuleProtectionClassifiedClassificationCriteriaArgsDict',
    'EthernetInterfaceLayer2Args',
    'EthernetInterfaceLayer2ArgsDict',
    'EthernetInterfaceLayer2LldpArgs',
    'EthernetInterfaceLayer2LldpArgsDict',
    'EthernetInterfaceLayer3Args',
    'EthernetInterfaceLayer3ArgsDict',
    'EthernetInterfaceLayer3ArpArgs',
    'EthernetInterfaceLayer3ArpArgsDict',
    'EthernetInterfaceLayer3DdnsConfigArgs',
    'EthernetInterfaceLayer3DdnsConfigArgsDict',
    'EthernetInterfaceLayer3DhcpClientArgs',
    'EthernetInterfaceLayer3DhcpClientArgsDict',
    'EthernetInterfaceLayer3DhcpClientSendHostnameArgs',
    'EthernetInterfaceLayer3DhcpClientSendHostnameArgsDict',
    'EthernetInterfaceLayer3IpArgs',
    'EthernetInterfaceLayer3IpArgsDict',
    'EthernetInterfaceLayer3PppoeArgs',
    'EthernetInterfaceLayer3PppoeArgsDict',
    'EthernetInterfaceLayer3PppoePassiveArgs',
    'EthernetInterfaceLayer3PppoePassiveArgsDict',
    'EthernetInterfaceLayer3PppoeStaticAddressArgs',
    'EthernetInterfaceLayer3PppoeStaticAddressArgsDict',
    'EthernetInterfacePoeArgs',
    'EthernetInterfacePoeArgsDict',
    'EthernetInterfaceTapArgs',
    'EthernetInterfaceTapArgsDict',
    'ExternalDynamicListTypeArgs',
    'ExternalDynamicListTypeArgsDict',
    'ExternalDynamicListTypeDomainArgs',
    'ExternalDynamicListTypeDomainArgsDict',
    'ExternalDynamicListTypeDomainAuthArgs',
    'ExternalDynamicListTypeDomainAuthArgsDict',
    'ExternalDynamicListTypeDomainRecurringArgs',
    'ExternalDynamicListTypeDomainRecurringArgsDict',
    'ExternalDynamicListTypeDomainRecurringDailyArgs',
    'ExternalDynamicListTypeDomainRecurringDailyArgsDict',
    'ExternalDynamicListTypeDomainRecurringFiveMinuteArgs',
    'ExternalDynamicListTypeDomainRecurringFiveMinuteArgsDict',
    'ExternalDynamicListTypeDomainRecurringHourlyArgs',
    'ExternalDynamicListTypeDomainRecurringHourlyArgsDict',
    'ExternalDynamicListTypeDomainRecurringMonthlyArgs',
    'ExternalDynamicListTypeDomainRecurringMonthlyArgsDict',
    'ExternalDynamicListTypeDomainRecurringWeeklyArgs',
    'ExternalDynamicListTypeDomainRecurringWeeklyArgsDict',
    'ExternalDynamicListTypeImeiArgs',
    'ExternalDynamicListTypeImeiArgsDict',
    'ExternalDynamicListTypeImeiAuthArgs',
    'ExternalDynamicListTypeImeiAuthArgsDict',
    'ExternalDynamicListTypeImeiRecurringArgs',
    'ExternalDynamicListTypeImeiRecurringArgsDict',
    'ExternalDynamicListTypeImeiRecurringDailyArgs',
    'ExternalDynamicListTypeImeiRecurringDailyArgsDict',
    'ExternalDynamicListTypeImeiRecurringFiveMinuteArgs',
    'ExternalDynamicListTypeImeiRecurringFiveMinuteArgsDict',
    'ExternalDynamicListTypeImeiRecurringHourlyArgs',
    'ExternalDynamicListTypeImeiRecurringHourlyArgsDict',
    'ExternalDynamicListTypeImeiRecurringMonthlyArgs',
    'ExternalDynamicListTypeImeiRecurringMonthlyArgsDict',
    'ExternalDynamicListTypeImeiRecurringWeeklyArgs',
    'ExternalDynamicListTypeImeiRecurringWeeklyArgsDict',
    'ExternalDynamicListTypeImsiArgs',
    'ExternalDynamicListTypeImsiArgsDict',
    'ExternalDynamicListTypeImsiAuthArgs',
    'ExternalDynamicListTypeImsiAuthArgsDict',
    'ExternalDynamicListTypeImsiRecurringArgs',
    'ExternalDynamicListTypeImsiRecurringArgsDict',
    'ExternalDynamicListTypeImsiRecurringDailyArgs',
    'ExternalDynamicListTypeImsiRecurringDailyArgsDict',
    'ExternalDynamicListTypeImsiRecurringFiveMinuteArgs',
    'ExternalDynamicListTypeImsiRecurringFiveMinuteArgsDict',
    'ExternalDynamicListTypeImsiRecurringHourlyArgs',
    'ExternalDynamicListTypeImsiRecurringHourlyArgsDict',
    'ExternalDynamicListTypeImsiRecurringMonthlyArgs',
    'ExternalDynamicListTypeImsiRecurringMonthlyArgsDict',
    'ExternalDynamicListTypeImsiRecurringWeeklyArgs',
    'ExternalDynamicListTypeImsiRecurringWeeklyArgsDict',
    'ExternalDynamicListTypeIpArgs',
    'ExternalDynamicListTypeIpArgsDict',
    'ExternalDynamicListTypeIpAuthArgs',
    'ExternalDynamicListTypeIpAuthArgsDict',
    'ExternalDynamicListTypeIpRecurringArgs',
    'ExternalDynamicListTypeIpRecurringArgsDict',
    'ExternalDynamicListTypeIpRecurringDailyArgs',
    'ExternalDynamicListTypeIpRecurringDailyArgsDict',
    'ExternalDynamicListTypeIpRecurringFiveMinuteArgs',
    'ExternalDynamicListTypeIpRecurringFiveMinuteArgsDict',
    'ExternalDynamicListTypeIpRecurringHourlyArgs',
    'ExternalDynamicListTypeIpRecurringHourlyArgsDict',
    'ExternalDynamicListTypeIpRecurringMonthlyArgs',
    'ExternalDynamicListTypeIpRecurringMonthlyArgsDict',
    'ExternalDynamicListTypeIpRecurringWeeklyArgs',
    'ExternalDynamicListTypeIpRecurringWeeklyArgsDict',
    'ExternalDynamicListTypePredefinedIpArgs',
    'ExternalDynamicListTypePredefinedIpArgsDict',
    'ExternalDynamicListTypePredefinedUrlArgs',
    'ExternalDynamicListTypePredefinedUrlArgsDict',
    'ExternalDynamicListTypeUrlArgs',
    'ExternalDynamicListTypeUrlArgsDict',
    'ExternalDynamicListTypeUrlAuthArgs',
    'ExternalDynamicListTypeUrlAuthArgsDict',
    'ExternalDynamicListTypeUrlRecurringArgs',
    'ExternalDynamicListTypeUrlRecurringArgsDict',
    'ExternalDynamicListTypeUrlRecurringDailyArgs',
    'ExternalDynamicListTypeUrlRecurringDailyArgsDict',
    'ExternalDynamicListTypeUrlRecurringFiveMinuteArgs',
    'ExternalDynamicListTypeUrlRecurringFiveMinuteArgsDict',
    'ExternalDynamicListTypeUrlRecurringHourlyArgs',
    'ExternalDynamicListTypeUrlRecurringHourlyArgsDict',
    'ExternalDynamicListTypeUrlRecurringMonthlyArgs',
    'ExternalDynamicListTypeUrlRecurringMonthlyArgsDict',
    'ExternalDynamicListTypeUrlRecurringWeeklyArgs',
    'ExternalDynamicListTypeUrlRecurringWeeklyArgsDict',
    'FileBlockingProfileRuleArgs',
    'FileBlockingProfileRuleArgsDict',
    'GeneralSettingGeneralArgs',
    'GeneralSettingGeneralArgsDict',
    'GeneralSettingGeneralGeoLocationArgs',
    'GeneralSettingGeneralGeoLocationArgsDict',
    'GeneralSettingGeneralSettingArgs',
    'GeneralSettingGeneralSettingArgsDict',
    'GeneralSettingGeneralSettingManagementArgs',
    'GeneralSettingGeneralSettingManagementArgsDict',
    'HipObjectAntiMalwareArgs',
    'HipObjectAntiMalwareArgsDict',
    'HipObjectAntiMalwareCriteriaArgs',
    'HipObjectAntiMalwareCriteriaArgsDict',
    'HipObjectAntiMalwareCriteriaLastScanTimeArgs',
    'HipObjectAntiMalwareCriteriaLastScanTimeArgsDict',
    'HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgs',
    'HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgsDict',
    'HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgs',
    'HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgsDict',
    'HipObjectAntiMalwareCriteriaLastScanTimeWithinArgs',
    'HipObjectAntiMalwareCriteriaLastScanTimeWithinArgsDict',
    'HipObjectAntiMalwareCriteriaProductVersionArgs',
    'HipObjectAntiMalwareCriteriaProductVersionArgsDict',
    'HipObjectAntiMalwareCriteriaProductVersionNotWithinArgs',
    'HipObjectAntiMalwareCriteriaProductVersionNotWithinArgsDict',
    'HipObjectAntiMalwareCriteriaProductVersionWithinArgs',
    'HipObjectAntiMalwareCriteriaProductVersionWithinArgsDict',
    'HipObjectAntiMalwareCriteriaVirdefVersionArgs',
    'HipObjectAntiMalwareCriteriaVirdefVersionArgsDict',
    'HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgs',
    'HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgsDict',
    'HipObjectAntiMalwareCriteriaVirdefVersionWithinArgs',
    'HipObjectAntiMalwareCriteriaVirdefVersionWithinArgsDict',
    'HipObjectAntiMalwareVendorArgs',
    'HipObjectAntiMalwareVendorArgsDict',
    'HipObjectCertificateArgs',
    'HipObjectCertificateArgsDict',
    'HipObjectCertificateCriteriaArgs',
    'HipObjectCertificateCriteriaArgsDict',
    'HipObjectCertificateCriteriaCertificateAttributeArgs',
    'HipObjectCertificateCriteriaCertificateAttributeArgsDict',
    'HipObjectCustomChecksArgs',
    'HipObjectCustomChecksArgsDict',
    'HipObjectCustomChecksCriteriaArgs',
    'HipObjectCustomChecksCriteriaArgsDict',
    'HipObjectCustomChecksCriteriaPlistArgs',
    'HipObjectCustomChecksCriteriaPlistArgsDict',
    'HipObjectCustomChecksCriteriaPlistKeyArgs',
    'HipObjectCustomChecksCriteriaPlistKeyArgsDict',
    'HipObjectCustomChecksCriteriaProcessListArgs',
    'HipObjectCustomChecksCriteriaProcessListArgsDict',
    'HipObjectCustomChecksCriteriaRegistryKeyArgs',
    'HipObjectCustomChecksCriteriaRegistryKeyArgsDict',
    'HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgs',
    'HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgsDict',
    'HipObjectDataLossPreventionArgs',
    'HipObjectDataLossPreventionArgsDict',
    'HipObjectDataLossPreventionCriteriaArgs',
    'HipObjectDataLossPreventionCriteriaArgsDict',
    'HipObjectDataLossPreventionVendorArgs',
    'HipObjectDataLossPreventionVendorArgsDict',
    'HipObjectDiskBackupArgs',
    'HipObjectDiskBackupArgsDict',
    'HipObjectDiskBackupCriteriaArgs',
    'HipObjectDiskBackupCriteriaArgsDict',
    'HipObjectDiskBackupCriteriaLastBackupTimeArgs',
    'HipObjectDiskBackupCriteriaLastBackupTimeArgsDict',
    'HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgs',
    'HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgsDict',
    'HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgs',
    'HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgsDict',
    'HipObjectDiskBackupCriteriaLastBackupTimeWithinArgs',
    'HipObjectDiskBackupCriteriaLastBackupTimeWithinArgsDict',
    'HipObjectDiskBackupVendorArgs',
    'HipObjectDiskBackupVendorArgsDict',
    'HipObjectDiskEncryptionArgs',
    'HipObjectDiskEncryptionArgsDict',
    'HipObjectDiskEncryptionCriteriaArgs',
    'HipObjectDiskEncryptionCriteriaArgsDict',
    'HipObjectDiskEncryptionCriteriaEncryptedLocationArgs',
    'HipObjectDiskEncryptionCriteriaEncryptedLocationArgsDict',
    'HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgs',
    'HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgsDict',
    'HipObjectDiskEncryptionVendorArgs',
    'HipObjectDiskEncryptionVendorArgsDict',
    'HipObjectFirewallArgs',
    'HipObjectFirewallArgsDict',
    'HipObjectFirewallCriteriaArgs',
    'HipObjectFirewallCriteriaArgsDict',
    'HipObjectFirewallVendorArgs',
    'HipObjectFirewallVendorArgsDict',
    'HipObjectHostInfoArgs',
    'HipObjectHostInfoArgsDict',
    'HipObjectHostInfoCriteriaArgs',
    'HipObjectHostInfoCriteriaArgsDict',
    'HipObjectHostInfoCriteriaClientVersionArgs',
    'HipObjectHostInfoCriteriaClientVersionArgsDict',
    'HipObjectHostInfoCriteriaDomainArgs',
    'HipObjectHostInfoCriteriaDomainArgsDict',
    'HipObjectHostInfoCriteriaHostIdArgs',
    'HipObjectHostInfoCriteriaHostIdArgsDict',
    'HipObjectHostInfoCriteriaHostNameArgs',
    'HipObjectHostInfoCriteriaHostNameArgsDict',
    'HipObjectHostInfoCriteriaOsArgs',
    'HipObjectHostInfoCriteriaOsArgsDict',
    'HipObjectHostInfoCriteriaOsContainsArgs',
    'HipObjectHostInfoCriteriaOsContainsArgsDict',
    'HipObjectHostInfoCriteriaSerialNumberArgs',
    'HipObjectHostInfoCriteriaSerialNumberArgsDict',
    'HipObjectMobileDeviceArgs',
    'HipObjectMobileDeviceArgsDict',
    'HipObjectMobileDeviceCriteriaArgs',
    'HipObjectMobileDeviceCriteriaArgsDict',
    'HipObjectMobileDeviceCriteriaApplicationsArgs',
    'HipObjectMobileDeviceCriteriaApplicationsArgsDict',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgs',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgsDict',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgs',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgsDict',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgs',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgsDict',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgs',
    'HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgsDict',
    'HipObjectMobileDeviceCriteriaApplicationsIncludeArgs',
    'HipObjectMobileDeviceCriteriaApplicationsIncludeArgsDict',
    'HipObjectMobileDeviceCriteriaImeiArgs',
    'HipObjectMobileDeviceCriteriaImeiArgsDict',
    'HipObjectMobileDeviceCriteriaLastCheckinTimeArgs',
    'HipObjectMobileDeviceCriteriaLastCheckinTimeArgsDict',
    'HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgs',
    'HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgsDict',
    'HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgs',
    'HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgsDict',
    'HipObjectMobileDeviceCriteriaModelArgs',
    'HipObjectMobileDeviceCriteriaModelArgsDict',
    'HipObjectMobileDeviceCriteriaPhoneNumberArgs',
    'HipObjectMobileDeviceCriteriaPhoneNumberArgsDict',
    'HipObjectMobileDeviceCriteriaTagArgs',
    'HipObjectMobileDeviceCriteriaTagArgsDict',
    'HipObjectNetworkInfoArgs',
    'HipObjectNetworkInfoArgsDict',
    'HipObjectNetworkInfoCriteriaArgs',
    'HipObjectNetworkInfoCriteriaArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkArgs',
    'HipObjectNetworkInfoCriteriaNetworkArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsMobileArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsMobileArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsNotArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsNotArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsUnknownArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsUnknownArgsDict',
    'HipObjectNetworkInfoCriteriaNetworkIsWifiArgs',
    'HipObjectNetworkInfoCriteriaNetworkIsWifiArgsDict',
    'HipObjectPatchManagementArgs',
    'HipObjectPatchManagementArgsDict',
    'HipObjectPatchManagementCriteriaArgs',
    'HipObjectPatchManagementCriteriaArgsDict',
    'HipObjectPatchManagementCriteriaMissingPatchesArgs',
    'HipObjectPatchManagementCriteriaMissingPatchesArgsDict',
    'HipObjectPatchManagementCriteriaMissingPatchesSeverityArgs',
    'HipObjectPatchManagementCriteriaMissingPatchesSeverityArgsDict',
    'HipObjectPatchManagementVendorArgs',
    'HipObjectPatchManagementVendorArgsDict',
    'HttpHeaderProfileHttpHeaderInsertionArgs',
    'HttpHeaderProfileHttpHeaderInsertionArgsDict',
    'HttpHeaderProfileHttpHeaderInsertionTypeArgs',
    'HttpHeaderProfileHttpHeaderInsertionTypeArgsDict',
    'HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgs',
    'HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgsDict',
    'HttpServerProfileFormatArgs',
    'HttpServerProfileFormatArgsDict',
    'HttpServerProfileFormatAuthArgs',
    'HttpServerProfileFormatAuthArgsDict',
    'HttpServerProfileFormatAuthHeaderArgs',
    'HttpServerProfileFormatAuthHeaderArgsDict',
    'HttpServerProfileFormatAuthParamArgs',
    'HttpServerProfileFormatAuthParamArgsDict',
    'HttpServerProfileFormatConfigArgs',
    'HttpServerProfileFormatConfigArgsDict',
    'HttpServerProfileFormatConfigHeaderArgs',
    'HttpServerProfileFormatConfigHeaderArgsDict',
    'HttpServerProfileFormatConfigParamArgs',
    'HttpServerProfileFormatConfigParamArgsDict',
    'HttpServerProfileFormatCorrelationArgs',
    'HttpServerProfileFormatCorrelationArgsDict',
    'HttpServerProfileFormatCorrelationHeaderArgs',
    'HttpServerProfileFormatCorrelationHeaderArgsDict',
    'HttpServerProfileFormatCorrelationParamArgs',
    'HttpServerProfileFormatCorrelationParamArgsDict',
    'HttpServerProfileFormatDataArgs',
    'HttpServerProfileFormatDataArgsDict',
    'HttpServerProfileFormatDataHeaderArgs',
    'HttpServerProfileFormatDataHeaderArgsDict',
    'HttpServerProfileFormatDataParamArgs',
    'HttpServerProfileFormatDataParamArgsDict',
    'HttpServerProfileFormatDecryptionArgs',
    'HttpServerProfileFormatDecryptionArgsDict',
    'HttpServerProfileFormatDecryptionHeaderArgs',
    'HttpServerProfileFormatDecryptionHeaderArgsDict',
    'HttpServerProfileFormatDecryptionParamArgs',
    'HttpServerProfileFormatDecryptionParamArgsDict',
    'HttpServerProfileFormatGlobalprotectArgs',
    'HttpServerProfileFormatGlobalprotectArgsDict',
    'HttpServerProfileFormatGlobalprotectHeaderArgs',
    'HttpServerProfileFormatGlobalprotectHeaderArgsDict',
    'HttpServerProfileFormatGlobalprotectParamArgs',
    'HttpServerProfileFormatGlobalprotectParamArgsDict',
    'HttpServerProfileFormatGtpArgs',
    'HttpServerProfileFormatGtpArgsDict',
    'HttpServerProfileFormatGtpHeaderArgs',
    'HttpServerProfileFormatGtpHeaderArgsDict',
    'HttpServerProfileFormatGtpParamArgs',
    'HttpServerProfileFormatGtpParamArgsDict',
    'HttpServerProfileFormatHipMatchArgs',
    'HttpServerProfileFormatHipMatchArgsDict',
    'HttpServerProfileFormatHipMatchHeaderArgs',
    'HttpServerProfileFormatHipMatchHeaderArgsDict',
    'HttpServerProfileFormatHipMatchParamArgs',
    'HttpServerProfileFormatHipMatchParamArgsDict',
    'HttpServerProfileFormatIptagArgs',
    'HttpServerProfileFormatIptagArgsDict',
    'HttpServerProfileFormatIptagHeaderArgs',
    'HttpServerProfileFormatIptagHeaderArgsDict',
    'HttpServerProfileFormatIptagParamArgs',
    'HttpServerProfileFormatIptagParamArgsDict',
    'HttpServerProfileFormatSctpArgs',
    'HttpServerProfileFormatSctpArgsDict',
    'HttpServerProfileFormatSctpHeaderArgs',
    'HttpServerProfileFormatSctpHeaderArgsDict',
    'HttpServerProfileFormatSctpParamArgs',
    'HttpServerProfileFormatSctpParamArgsDict',
    'HttpServerProfileFormatSystemArgs',
    'HttpServerProfileFormatSystemArgsDict',
    'HttpServerProfileFormatSystemHeaderArgs',
    'HttpServerProfileFormatSystemHeaderArgsDict',
    'HttpServerProfileFormatSystemParamArgs',
    'HttpServerProfileFormatSystemParamArgsDict',
    'HttpServerProfileFormatThreatArgs',
    'HttpServerProfileFormatThreatArgsDict',
    'HttpServerProfileFormatThreatHeaderArgs',
    'HttpServerProfileFormatThreatHeaderArgsDict',
    'HttpServerProfileFormatThreatParamArgs',
    'HttpServerProfileFormatThreatParamArgsDict',
    'HttpServerProfileFormatTrafficArgs',
    'HttpServerProfileFormatTrafficArgsDict',
    'HttpServerProfileFormatTrafficHeaderArgs',
    'HttpServerProfileFormatTrafficHeaderArgsDict',
    'HttpServerProfileFormatTrafficParamArgs',
    'HttpServerProfileFormatTrafficParamArgsDict',
    'HttpServerProfileFormatTunnelArgs',
    'HttpServerProfileFormatTunnelArgsDict',
    'HttpServerProfileFormatTunnelHeaderArgs',
    'HttpServerProfileFormatTunnelHeaderArgsDict',
    'HttpServerProfileFormatTunnelParamArgs',
    'HttpServerProfileFormatTunnelParamArgsDict',
    'HttpServerProfileFormatUrlArgs',
    'HttpServerProfileFormatUrlArgsDict',
    'HttpServerProfileFormatUrlHeaderArgs',
    'HttpServerProfileFormatUrlHeaderArgsDict',
    'HttpServerProfileFormatUrlParamArgs',
    'HttpServerProfileFormatUrlParamArgsDict',
    'HttpServerProfileFormatUseridArgs',
    'HttpServerProfileFormatUseridArgsDict',
    'HttpServerProfileFormatUseridHeaderArgs',
    'HttpServerProfileFormatUseridHeaderArgsDict',
    'HttpServerProfileFormatUseridParamArgs',
    'HttpServerProfileFormatUseridParamArgsDict',
    'HttpServerProfileFormatWildfireArgs',
    'HttpServerProfileFormatWildfireArgsDict',
    'HttpServerProfileFormatWildfireHeaderArgs',
    'HttpServerProfileFormatWildfireHeaderArgsDict',
    'HttpServerProfileFormatWildfireParamArgs',
    'HttpServerProfileFormatWildfireParamArgsDict',
    'HttpServerProfileServerArgs',
    'HttpServerProfileServerArgsDict',
    'IkeCryptoProfileLifetimeArgs',
    'IkeCryptoProfileLifetimeArgsDict',
    'IkeGatewayAuthenticationArgs',
    'IkeGatewayAuthenticationArgsDict',
    'IkeGatewayAuthenticationCertificateArgs',
    'IkeGatewayAuthenticationCertificateArgsDict',
    'IkeGatewayAuthenticationCertificateLocalCertificateArgs',
    'IkeGatewayAuthenticationCertificateLocalCertificateArgsDict',
    'IkeGatewayAuthenticationPreSharedKeyArgs',
    'IkeGatewayAuthenticationPreSharedKeyArgsDict',
    'IkeGatewayLocalAddressArgs',
    'IkeGatewayLocalAddressArgsDict',
    'IkeGatewayLocalIdArgs',
    'IkeGatewayLocalIdArgsDict',
    'IkeGatewayPeerAddressArgs',
    'IkeGatewayPeerAddressArgsDict',
    'IkeGatewayPeerAddressDynamicArgs',
    'IkeGatewayPeerAddressDynamicArgsDict',
    'IkeGatewayPeerIdArgs',
    'IkeGatewayPeerIdArgsDict',
    'IkeGatewayProtocolArgs',
    'IkeGatewayProtocolArgsDict',
    'IkeGatewayProtocolCommonArgs',
    'IkeGatewayProtocolCommonArgsDict',
    'IkeGatewayProtocolCommonFragmentationArgs',
    'IkeGatewayProtocolCommonFragmentationArgsDict',
    'IkeGatewayProtocolCommonNatTraversalArgs',
    'IkeGatewayProtocolCommonNatTraversalArgsDict',
    'IkeGatewayProtocolIkev1Args',
    'IkeGatewayProtocolIkev1ArgsDict',
    'IkeGatewayProtocolIkev1DpdArgs',
    'IkeGatewayProtocolIkev1DpdArgsDict',
    'IkeGatewayProtocolIkev2Args',
    'IkeGatewayProtocolIkev2ArgsDict',
    'IkeGatewayProtocolIkev2DpdArgs',
    'IkeGatewayProtocolIkev2DpdArgsDict',
    'InterfaceManagementProfilePermittedIpArgs',
    'InterfaceManagementProfilePermittedIpArgsDict',
    'IpsecCryptoProfileAhArgs',
    'IpsecCryptoProfileAhArgsDict',
    'IpsecCryptoProfileEspArgs',
    'IpsecCryptoProfileEspArgsDict',
    'IpsecCryptoProfileLifesizeArgs',
    'IpsecCryptoProfileLifesizeArgsDict',
    'IpsecCryptoProfileLifetimeArgs',
    'IpsecCryptoProfileLifetimeArgsDict',
    'IpsecTunnelAutoKeyArgs',
    'IpsecTunnelAutoKeyArgsDict',
    'IpsecTunnelAutoKeyIkeGatewayArgs',
    'IpsecTunnelAutoKeyIkeGatewayArgsDict',
    'IpsecTunnelAutoKeyProxyIdArgs',
    'IpsecTunnelAutoKeyProxyIdArgsDict',
    'IpsecTunnelAutoKeyProxyIdProtocolArgs',
    'IpsecTunnelAutoKeyProxyIdProtocolArgsDict',
    'IpsecTunnelAutoKeyProxyIdProtocolTcpArgs',
    'IpsecTunnelAutoKeyProxyIdProtocolTcpArgsDict',
    'IpsecTunnelAutoKeyProxyIdProtocolUdpArgs',
    'IpsecTunnelAutoKeyProxyIdProtocolUdpArgsDict',
    'IpsecTunnelAutoKeyProxyIdV6Args',
    'IpsecTunnelAutoKeyProxyIdV6ArgsDict',
    'IpsecTunnelAutoKeyProxyIdV6ProtocolArgs',
    'IpsecTunnelAutoKeyProxyIdV6ProtocolArgsDict',
    'IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgs',
    'IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgsDict',
    'IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgs',
    'IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgsDict',
    'IpsecTunnelTunnelMonitorArgs',
    'IpsecTunnelTunnelMonitorArgsDict',
    'KerberosServerProfileServerArgs',
    'KerberosServerProfileServerArgsDict',
    'Layer3SubinterfaceArpArgs',
    'Layer3SubinterfaceArpArgsDict',
    'Layer3SubinterfaceDdnsConfigArgs',
    'Layer3SubinterfaceDdnsConfigArgsDict',
    'Layer3SubinterfaceDhcpClientArgs',
    'Layer3SubinterfaceDhcpClientArgsDict',
    'Layer3SubinterfaceDhcpClientSendHostnameArgs',
    'Layer3SubinterfaceDhcpClientSendHostnameArgsDict',
    'Layer3SubinterfaceIpArgs',
    'Layer3SubinterfaceIpArgsDict',
    'LdapServerProfileServerArgs',
    'LdapServerProfileServerArgsDict',
    'LldpProfileOptionTlvsArgs',
    'LldpProfileOptionTlvsArgsDict',
    'LldpProfileOptionTlvsManagementAddressArgs',
    'LldpProfileOptionTlvsManagementAddressArgsDict',
    'LldpProfileOptionTlvsManagementAddressIplistArgs',
    'LldpProfileOptionTlvsManagementAddressIplistArgsDict',
    'LogForwardingProfileMatchListArgs',
    'LogForwardingProfileMatchListArgsDict',
    'LogicalRouterVrfArgs',
    'LogicalRouterVrfArgsDict',
    'LogicalRouterVrfAdminDistsArgs',
    'LogicalRouterVrfAdminDistsArgsDict',
    'LogicalRouterVrfBgpArgs',
    'LogicalRouterVrfBgpArgsDict',
    'LogicalRouterVrfBgpAdvertiseNetworkArgs',
    'LogicalRouterVrfBgpAdvertiseNetworkArgsDict',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv4Args',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv4ArgsDict',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgs',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgsDict',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv6Args',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv6ArgsDict',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgs',
    'LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgsDict',
    'LogicalRouterVrfBgpAggregateArgs',
    'LogicalRouterVrfBgpAggregateArgsDict',
    'LogicalRouterVrfBgpAggregateRouteArgs',
    'LogicalRouterVrfBgpAggregateRouteArgsDict',
    'LogicalRouterVrfBgpAggregateRouteTypeArgs',
    'LogicalRouterVrfBgpAggregateRouteTypeArgsDict',
    'LogicalRouterVrfBgpAggregateRouteTypeIpv4Args',
    'LogicalRouterVrfBgpAggregateRouteTypeIpv4ArgsDict',
    'LogicalRouterVrfBgpAggregateRouteTypeIpv6Args',
    'LogicalRouterVrfBgpAggregateRouteTypeIpv6ArgsDict',
    'LogicalRouterVrfBgpGlobalBfdArgs',
    'LogicalRouterVrfBgpGlobalBfdArgsDict',
    'LogicalRouterVrfBgpGracefulRestartArgs',
    'LogicalRouterVrfBgpGracefulRestartArgsDict',
    'LogicalRouterVrfBgpMedArgs',
    'LogicalRouterVrfBgpMedArgsDict',
    'LogicalRouterVrfBgpPeerGroupArgs',
    'LogicalRouterVrfBgpPeerGroupArgsDict',
    'LogicalRouterVrfBgpPeerGroupAddressFamilyArgs',
    'LogicalRouterVrfBgpPeerGroupAddressFamilyArgsDict',
    'LogicalRouterVrfBgpPeerGroupConnectionOptionsArgs',
    'LogicalRouterVrfBgpPeerGroupConnectionOptionsArgsDict',
    'LogicalRouterVrfBgpPeerGroupFilteringProfileArgs',
    'LogicalRouterVrfBgpPeerGroupFilteringProfileArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerArgs',
    'LogicalRouterVrfBgpPeerGroupPeerArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerBfdArgs',
    'LogicalRouterVrfBgpPeerGroupPeerBfdArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgs',
    'LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgs',
    'LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgs',
    'LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgs',
    'LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerInheritArgs',
    'LogicalRouterVrfBgpPeerGroupPeerInheritArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerInheritNoArgs',
    'LogicalRouterVrfBgpPeerGroupPeerInheritNoArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgs',
    'LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgs',
    'LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerInheritYesArgs',
    'LogicalRouterVrfBgpPeerGroupPeerInheritYesArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgs',
    'LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgs',
    'LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgsDict',
    'LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgs',
    'LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgsDict',
    'LogicalRouterVrfBgpPeerGroupTypeArgs',
    'LogicalRouterVrfBgpPeerGroupTypeArgsDict',
    'LogicalRouterVrfBgpPeerGroupTypeEbgpArgs',
    'LogicalRouterVrfBgpPeerGroupTypeEbgpArgsDict',
    'LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgs',
    'LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgsDict',
    'LogicalRouterVrfBgpPeerGroupTypeIbgpArgs',
    'LogicalRouterVrfBgpPeerGroupTypeIbgpArgsDict',
    'LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgs',
    'LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgsDict',
    'LogicalRouterVrfBgpPolicyArgs',
    'LogicalRouterVrfBgpPolicyArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationArgs',
    'LogicalRouterVrfBgpPolicyAggregationArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyExportArgs',
    'LogicalRouterVrfBgpPolicyExportArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleArgs',
    'LogicalRouterVrfBgpPolicyExportRuleArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleActionDenyArgs',
    'LogicalRouterVrfBgpPolicyExportRuleActionDenyArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleMatchArgs',
    'LogicalRouterVrfBgpPolicyExportRuleMatchArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgs',
    'LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgs',
    'LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgs',
    'LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyImportArgs',
    'LogicalRouterVrfBgpPolicyImportArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleArgs',
    'LogicalRouterVrfBgpPolicyImportRuleArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleActionDenyArgs',
    'LogicalRouterVrfBgpPolicyImportRuleActionDenyArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleMatchArgs',
    'LogicalRouterVrfBgpPolicyImportRuleMatchArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgs',
    'LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgs',
    'LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgs',
    'LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgsDict',
    'LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgs',
    'LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgsDict',
    'LogicalRouterVrfBgpRedistRuleArgs',
    'LogicalRouterVrfBgpRedistRuleArgsDict',
    'LogicalRouterVrfBgpRedistributionProfileArgs',
    'LogicalRouterVrfBgpRedistributionProfileArgsDict',
    'LogicalRouterVrfBgpRedistributionProfileIpv4Args',
    'LogicalRouterVrfBgpRedistributionProfileIpv4ArgsDict',
    'LogicalRouterVrfBgpRedistributionProfileIpv6Args',
    'LogicalRouterVrfBgpRedistributionProfileIpv6ArgsDict',
    'LogicalRouterVrfEcmpArgs',
    'LogicalRouterVrfEcmpArgsDict',
    'LogicalRouterVrfEcmpAlgorithmArgs',
    'LogicalRouterVrfEcmpAlgorithmArgsDict',
    'LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgs',
    'LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgsDict',
    'LogicalRouterVrfEcmpAlgorithmIpHashArgs',
    'LogicalRouterVrfEcmpAlgorithmIpHashArgsDict',
    'LogicalRouterVrfEcmpAlgorithmIpModuloArgs',
    'LogicalRouterVrfEcmpAlgorithmIpModuloArgsDict',
    'LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgs',
    'LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgsDict',
    'LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgs',
    'LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgsDict',
    'LogicalRouterVrfMulticastArgs',
    'LogicalRouterVrfMulticastArgsDict',
    'LogicalRouterVrfMulticastIgmpArgs',
    'LogicalRouterVrfMulticastIgmpArgsDict',
    'LogicalRouterVrfMulticastIgmpDynamicArgs',
    'LogicalRouterVrfMulticastIgmpDynamicArgsDict',
    'LogicalRouterVrfMulticastIgmpDynamicInterfaceArgs',
    'LogicalRouterVrfMulticastIgmpDynamicInterfaceArgsDict',
    'LogicalRouterVrfMulticastIgmpStaticArgs',
    'LogicalRouterVrfMulticastIgmpStaticArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupArgs',
    'LogicalRouterVrfMulticastInterfaceGroupArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgs',
    'LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgs',
    'LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgs',
    'LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupIgmpArgs',
    'LogicalRouterVrfMulticastInterfaceGroupIgmpArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupPimArgs',
    'LogicalRouterVrfMulticastInterfaceGroupPimArgsDict',
    'LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgs',
    'LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgsDict',
    'LogicalRouterVrfMulticastMsdpArgs',
    'LogicalRouterVrfMulticastMsdpArgsDict',
    'LogicalRouterVrfMulticastMsdpOriginatorIdArgs',
    'LogicalRouterVrfMulticastMsdpOriginatorIdArgsDict',
    'LogicalRouterVrfMulticastMsdpPeerArgs',
    'LogicalRouterVrfMulticastMsdpPeerArgsDict',
    'LogicalRouterVrfMulticastMsdpPeerLocalAddressArgs',
    'LogicalRouterVrfMulticastMsdpPeerLocalAddressArgsDict',
    'LogicalRouterVrfMulticastMsdpPeerPeerAddressArgs',
    'LogicalRouterVrfMulticastMsdpPeerPeerAddressArgsDict',
    'LogicalRouterVrfMulticastPimArgs',
    'LogicalRouterVrfMulticastPimArgsDict',
    'LogicalRouterVrfMulticastPimInterfaceArgs',
    'LogicalRouterVrfMulticastPimInterfaceArgsDict',
    'LogicalRouterVrfMulticastPimRpArgs',
    'LogicalRouterVrfMulticastPimRpArgsDict',
    'LogicalRouterVrfMulticastPimRpExternalRpArgs',
    'LogicalRouterVrfMulticastPimRpExternalRpArgsDict',
    'LogicalRouterVrfMulticastPimRpLocalRpArgs',
    'LogicalRouterVrfMulticastPimRpLocalRpArgsDict',
    'LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgs',
    'LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgsDict',
    'LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgs',
    'LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgsDict',
    'LogicalRouterVrfMulticastPimSptThresholdArgs',
    'LogicalRouterVrfMulticastPimSptThresholdArgsDict',
    'LogicalRouterVrfMulticastPimSsmAddressSpaceArgs',
    'LogicalRouterVrfMulticastPimSsmAddressSpaceArgsDict',
    'LogicalRouterVrfMulticastRpArgs',
    'LogicalRouterVrfMulticastRpArgsDict',
    'LogicalRouterVrfMulticastRpExternalRpArgs',
    'LogicalRouterVrfMulticastRpExternalRpArgsDict',
    'LogicalRouterVrfMulticastRpLocalRpArgs',
    'LogicalRouterVrfMulticastRpLocalRpArgsDict',
    'LogicalRouterVrfMulticastRpLocalRpCandidateRpArgs',
    'LogicalRouterVrfMulticastRpLocalRpCandidateRpArgsDict',
    'LogicalRouterVrfMulticastRpLocalRpStaticRpArgs',
    'LogicalRouterVrfMulticastRpLocalRpStaticRpArgsDict',
    'LogicalRouterVrfMulticastSptThresholdArgs',
    'LogicalRouterVrfMulticastSptThresholdArgsDict',
    'LogicalRouterVrfMulticastSsmAddressSpaceArgs',
    'LogicalRouterVrfMulticastSsmAddressSpaceArgsDict',
    'LogicalRouterVrfMulticastStaticRouteArgs',
    'LogicalRouterVrfMulticastStaticRouteArgsDict',
    'LogicalRouterVrfMulticastStaticRouteNexthopArgs',
    'LogicalRouterVrfMulticastStaticRouteNexthopArgsDict',
    'LogicalRouterVrfOspfArgs',
    'LogicalRouterVrfOspfArgsDict',
    'LogicalRouterVrfOspfAreaArgs',
    'LogicalRouterVrfOspfAreaArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceArgs',
    'LogicalRouterVrfOspfAreaInterfaceArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceBfdArgs',
    'LogicalRouterVrfOspfAreaInterfaceBfdArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeArgs',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgs',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgs',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgs',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgs',
    'LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgsDict',
    'LogicalRouterVrfOspfAreaInterfaceVrTimingArgs',
    'LogicalRouterVrfOspfAreaInterfaceVrTimingArgsDict',
    'LogicalRouterVrfOspfAreaRangeArgs',
    'LogicalRouterVrfOspfAreaRangeArgsDict',
    'LogicalRouterVrfOspfAreaTypeArgs',
    'LogicalRouterVrfOspfAreaTypeArgsDict',
    'LogicalRouterVrfOspfAreaTypeNormalArgs',
    'LogicalRouterVrfOspfAreaTypeNormalArgsDict',
    'LogicalRouterVrfOspfAreaTypeNormalAbrArgs',
    'LogicalRouterVrfOspfAreaTypeNormalAbrArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaArgs',
    'LogicalRouterVrfOspfAreaTypeNssaArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaAbrArgs',
    'LogicalRouterVrfOspfAreaTypeNssaAbrArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgs',
    'LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgs',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgs',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgs',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgs',
    'LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgs',
    'LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgs',
    'LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgsDict',
    'LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgs',
    'LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgsDict',
    'LogicalRouterVrfOspfAreaTypeStubArgs',
    'LogicalRouterVrfOspfAreaTypeStubArgsDict',
    'LogicalRouterVrfOspfAreaTypeStubAbrArgs',
    'LogicalRouterVrfOspfAreaTypeStubAbrArgsDict',
    'LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgs',
    'LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgsDict',
    'LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgs',
    'LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgsDict',
    'LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgs',
    'LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgsDict',
    'LogicalRouterVrfOspfAreaVirtualLinkArgs',
    'LogicalRouterVrfOspfAreaVirtualLinkArgsDict',
    'LogicalRouterVrfOspfAreaVirtualLinkBfdArgs',
    'LogicalRouterVrfOspfAreaVirtualLinkBfdArgsDict',
    'LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgs',
    'LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgsDict',
    'LogicalRouterVrfOspfAreaVrRangeArgs',
    'LogicalRouterVrfOspfAreaVrRangeArgsDict',
    'LogicalRouterVrfOspfAreaVrRangeAdvertiseArgs',
    'LogicalRouterVrfOspfAreaVrRangeAdvertiseArgsDict',
    'LogicalRouterVrfOspfAreaVrRangeSuppressArgs',
    'LogicalRouterVrfOspfAreaVrRangeSuppressArgsDict',
    'LogicalRouterVrfOspfAuthProfileArgs',
    'LogicalRouterVrfOspfAuthProfileArgsDict',
    'LogicalRouterVrfOspfAuthProfileMd5Args',
    'LogicalRouterVrfOspfAuthProfileMd5ArgsDict',
    'LogicalRouterVrfOspfExportRuleArgs',
    'LogicalRouterVrfOspfExportRuleArgsDict',
    'LogicalRouterVrfOspfFloodPreventionArgs',
    'LogicalRouterVrfOspfFloodPreventionArgsDict',
    'LogicalRouterVrfOspfFloodPreventionHelloArgs',
    'LogicalRouterVrfOspfFloodPreventionHelloArgsDict',
    'LogicalRouterVrfOspfFloodPreventionLsaArgs',
    'LogicalRouterVrfOspfFloodPreventionLsaArgsDict',
    'LogicalRouterVrfOspfGlobalBfdArgs',
    'LogicalRouterVrfOspfGlobalBfdArgsDict',
    'LogicalRouterVrfOspfGracefulRestartArgs',
    'LogicalRouterVrfOspfGracefulRestartArgsDict',
    'LogicalRouterVrfOspfVrTimersArgs',
    'LogicalRouterVrfOspfVrTimersArgsDict',
    'LogicalRouterVrfOspfv3Args',
    'LogicalRouterVrfOspfv3ArgsDict',
    'LogicalRouterVrfOspfv3AreaArgs',
    'LogicalRouterVrfOspfv3AreaArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceBfdArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceBfdArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceNeighborArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceNeighborArgsDict',
    'LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgs',
    'LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgsDict',
    'LogicalRouterVrfOspfv3AreaRangeArgs',
    'LogicalRouterVrfOspfv3AreaRangeArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeArgs',
    'LogicalRouterVrfOspfv3AreaTypeArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNormalArgs',
    'LogicalRouterVrfOspfv3AreaTypeNormalArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNormalAbrArgs',
    'LogicalRouterVrfOspfv3AreaTypeNormalAbrArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgs',
    'LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeStubArgs',
    'LogicalRouterVrfOspfv3AreaTypeStubArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeStubAbrArgs',
    'LogicalRouterVrfOspfv3AreaTypeStubAbrArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgs',
    'LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgs',
    'LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgsDict',
    'LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgs',
    'LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgsDict',
    'LogicalRouterVrfOspfv3AreaVirtualLinkArgs',
    'LogicalRouterVrfOspfv3AreaVirtualLinkArgsDict',
    'LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgs',
    'LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgsDict',
    'LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgs',
    'LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgsDict',
    'LogicalRouterVrfOspfv3AreaVrRangeArgs',
    'LogicalRouterVrfOspfv3AreaVrRangeArgsDict',
    'LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgs',
    'LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgsDict',
    'LogicalRouterVrfOspfv3AreaVrRangeSuppressArgs',
    'LogicalRouterVrfOspfv3AreaVrRangeSuppressArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileArgs',
    'LogicalRouterVrfOspfv3AuthProfileArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileAhArgs',
    'LogicalRouterVrfOspfv3AuthProfileAhArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileAhMd5Args',
    'LogicalRouterVrfOspfv3AuthProfileAhMd5ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileAhSha1Args',
    'LogicalRouterVrfOspfv3AuthProfileAhSha1ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileAhSha256Args',
    'LogicalRouterVrfOspfv3AuthProfileAhSha256ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileAhSha384Args',
    'LogicalRouterVrfOspfv3AuthProfileAhSha384ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileAhSha512Args',
    'LogicalRouterVrfOspfv3AuthProfileAhSha512ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspArgs',
    'LogicalRouterVrfOspfv3AuthProfileEspArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgs',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5Args',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgs',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1Args',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256Args',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384Args',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512Args',
    'LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512ArgsDict',
    'LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgs',
    'LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgsDict',
    'LogicalRouterVrfOspfv3ExportRuleArgs',
    'LogicalRouterVrfOspfv3ExportRuleArgsDict',
    'LogicalRouterVrfOspfv3GlobalBfdArgs',
    'LogicalRouterVrfOspfv3GlobalBfdArgsDict',
    'LogicalRouterVrfOspfv3GracefulRestartArgs',
    'LogicalRouterVrfOspfv3GracefulRestartArgsDict',
    'LogicalRouterVrfOspfv3VrTimersArgs',
    'LogicalRouterVrfOspfv3VrTimersArgsDict',
    'LogicalRouterVrfRibFilterArgs',
    'LogicalRouterVrfRibFilterArgsDict',
    'LogicalRouterVrfRibFilterIpv4Args',
    'LogicalRouterVrfRibFilterIpv4ArgsDict',
    'LogicalRouterVrfRibFilterIpv4BgpArgs',
    'LogicalRouterVrfRibFilterIpv4BgpArgsDict',
    'LogicalRouterVrfRibFilterIpv4OspfArgs',
    'LogicalRouterVrfRibFilterIpv4OspfArgsDict',
    'LogicalRouterVrfRibFilterIpv4RipArgs',
    'LogicalRouterVrfRibFilterIpv4RipArgsDict',
    'LogicalRouterVrfRibFilterIpv4StaticArgs',
    'LogicalRouterVrfRibFilterIpv4StaticArgsDict',
    'LogicalRouterVrfRibFilterIpv6Args',
    'LogicalRouterVrfRibFilterIpv6ArgsDict',
    'LogicalRouterVrfRibFilterIpv6BgpArgs',
    'LogicalRouterVrfRibFilterIpv6BgpArgsDict',
    'LogicalRouterVrfRibFilterIpv6Ospfv3Args',
    'LogicalRouterVrfRibFilterIpv6Ospfv3ArgsDict',
    'LogicalRouterVrfRibFilterIpv6StaticArgs',
    'LogicalRouterVrfRibFilterIpv6StaticArgsDict',
    'LogicalRouterVrfRipArgs',
    'LogicalRouterVrfRipArgsDict',
    'LogicalRouterVrfRipGlobalBfdArgs',
    'LogicalRouterVrfRipGlobalBfdArgsDict',
    'LogicalRouterVrfRipGlobalInboundDistributeListArgs',
    'LogicalRouterVrfRipGlobalInboundDistributeListArgsDict',
    'LogicalRouterVrfRipGlobalOutboundDistributeListArgs',
    'LogicalRouterVrfRipGlobalOutboundDistributeListArgsDict',
    'LogicalRouterVrfRipInterfaceArgs',
    'LogicalRouterVrfRipInterfaceArgsDict',
    'LogicalRouterVrfRipInterfaceBfdArgs',
    'LogicalRouterVrfRipInterfaceBfdArgsDict',
    'LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgs',
    'LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgsDict',
    'LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgs',
    'LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgsDict',
    'LogicalRouterVrfRoutingTableArgs',
    'LogicalRouterVrfRoutingTableArgsDict',
    'LogicalRouterVrfRoutingTableIpArgs',
    'LogicalRouterVrfRoutingTableIpArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteBfdArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteBfdArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgs',
    'LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgs',
    'LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgsDict',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgs',
    'LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgsDict',
    'LogicalRouterVrfRoutingTableIpv6Args',
    'LogicalRouterVrfRoutingTableIpv6ArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgsDict',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgs',
    'LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgsDict',
    'LogicalRouterVrfVrAdminDistsArgs',
    'LogicalRouterVrfVrAdminDistsArgsDict',
    'LoopbackInterfaceIpArgs',
    'LoopbackInterfaceIpArgsDict',
    'LoopbackInterfaceIpv6Args',
    'LoopbackInterfaceIpv6ArgsDict',
    'LoopbackInterfaceIpv6AddressArgs',
    'LoopbackInterfaceIpv6AddressArgsDict',
    'LoopbackInterfaceIpv6AddressAnycastArgs',
    'LoopbackInterfaceIpv6AddressAnycastArgsDict',
    'LoopbackInterfaceIpv6AddressPrefixArgs',
    'LoopbackInterfaceIpv6AddressPrefixArgsDict',
    'ManagementInterfaceManagementInterfaceArgs',
    'ManagementInterfaceManagementInterfaceArgsDict',
    'ManagementInterfaceManagementInterfaceMgmtTypeArgs',
    'ManagementInterfaceManagementInterfaceMgmtTypeArgsDict',
    'ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgs',
    'ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgsDict',
    'ManagementInterfaceManagementInterfaceMgmtTypeStaticArgs',
    'ManagementInterfaceManagementInterfaceMgmtTypeStaticArgsDict',
    'ManagementInterfaceManagementInterfacePermittedIpArgs',
    'ManagementInterfaceManagementInterfacePermittedIpArgsDict',
    'ManagementInterfaceManagementInterfaceServiceArgs',
    'ManagementInterfaceManagementInterfaceServiceArgsDict',
    'MfaServerMfaVendorTypeArgs',
    'MfaServerMfaVendorTypeArgsDict',
    'MfaServerMfaVendorTypeDuoSecurityV2Args',
    'MfaServerMfaVendorTypeDuoSecurityV2ArgsDict',
    'MfaServerMfaVendorTypeOktaAdaptiveV1Args',
    'MfaServerMfaVendorTypeOktaAdaptiveV1ArgsDict',
    'MfaServerMfaVendorTypePingIdentityV1Args',
    'MfaServerMfaVendorTypePingIdentityV1ArgsDict',
    'MfaServerMfaVendorTypeRsaSecuridAccessV1Args',
    'MfaServerMfaVendorTypeRsaSecuridAccessV1ArgsDict',
    'MotdBannerSettingMotdAndBannerArgs',
    'MotdBannerSettingMotdAndBannerArgsDict',
    'NatRuleDestinationTranslationArgs',
    'NatRuleDestinationTranslationArgsDict',
    'NatRuleDestinationTranslationDnsRewriteArgs',
    'NatRuleDestinationTranslationDnsRewriteArgsDict',
    'NatRuleDynamicDestinationTranslationArgs',
    'NatRuleDynamicDestinationTranslationArgsDict',
    'NatRuleSourceTranslationArgs',
    'NatRuleSourceTranslationArgsDict',
    'NatRuleSourceTranslationDynamicIpArgs',
    'NatRuleSourceTranslationDynamicIpArgsDict',
    'NatRuleSourceTranslationDynamicIpAndPortArgs',
    'NatRuleSourceTranslationDynamicIpAndPortArgsDict',
    'NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgs',
    'NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgsDict',
    'NatRuleSourceTranslationDynamicIpFallbackArgs',
    'NatRuleSourceTranslationDynamicIpFallbackArgsDict',
    'NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgs',
    'NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgsDict',
    'NatRuleSourceTranslationStaticIpArgs',
    'NatRuleSourceTranslationStaticIpArgsDict',
    'OspfAuthProfileMd5Args',
    'OspfAuthProfileMd5ArgsDict',
    'PbfRuleActionArgs',
    'PbfRuleActionArgsDict',
    'PbfRuleActionDiscardArgs',
    'PbfRuleActionDiscardArgsDict',
    'PbfRuleActionForwardArgs',
    'PbfRuleActionForwardArgsDict',
    'PbfRuleActionForwardMonitorArgs',
    'PbfRuleActionForwardMonitorArgsDict',
    'PbfRuleActionForwardNexthopArgs',
    'PbfRuleActionForwardNexthopArgsDict',
    'PbfRuleActionNoPbfArgs',
    'PbfRuleActionNoPbfArgsDict',
    'PbfRuleEnforceSymmetricReturnArgs',
    'PbfRuleEnforceSymmetricReturnArgsDict',
    'PbfRuleEnforceSymmetricReturnNexthopAddressListArgs',
    'PbfRuleEnforceSymmetricReturnNexthopAddressListArgsDict',
    'PbfRuleFromArgs',
    'PbfRuleFromArgsDict',
    'QosPolicyRuleActionArgs',
    'QosPolicyRuleActionArgsDict',
    'QosPolicyRuleDscpTosArgs',
    'QosPolicyRuleDscpTosArgsDict',
    'QosPolicyRuleDscpTosCodepointArgs',
    'QosPolicyRuleDscpTosCodepointArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeArgs',
    'QosPolicyRuleDscpTosCodepointTypeArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeAfArgs',
    'QosPolicyRuleDscpTosCodepointTypeAfArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeCsArgs',
    'QosPolicyRuleDscpTosCodepointTypeCsArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeCustomArgs',
    'QosPolicyRuleDscpTosCodepointTypeCustomArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgs',
    'QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeEfArgs',
    'QosPolicyRuleDscpTosCodepointTypeEfArgsDict',
    'QosPolicyRuleDscpTosCodepointTypeTosArgs',
    'QosPolicyRuleDscpTosCodepointTypeTosArgsDict',
    'QosProfileAggregateBandwidthArgs',
    'QosProfileAggregateBandwidthArgsDict',
    'QosProfileClassBandwidthTypeArgs',
    'QosProfileClassBandwidthTypeArgsDict',
    'QosProfileClassBandwidthTypeMbpsArgs',
    'QosProfileClassBandwidthTypeMbpsArgsDict',
    'QosProfileClassBandwidthTypeMbpsClassArgs',
    'QosProfileClassBandwidthTypeMbpsClassArgsDict',
    'QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgs',
    'QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgsDict',
    'QosProfileClassBandwidthTypePercentageArgs',
    'QosProfileClassBandwidthTypePercentageArgsDict',
    'QosProfileClassBandwidthTypePercentageClassArgs',
    'QosProfileClassBandwidthTypePercentageClassArgsDict',
    'QosProfileClassBandwidthTypePercentageClassClassBandwidthArgs',
    'QosProfileClassBandwidthTypePercentageClassClassBandwidthArgsDict',
    'RadiusServerProfileProtocolArgs',
    'RadiusServerProfileProtocolArgsDict',
    'RadiusServerProfileProtocolChapArgs',
    'RadiusServerProfileProtocolChapArgsDict',
    'RadiusServerProfileProtocolEapTtlsWithPapArgs',
    'RadiusServerProfileProtocolEapTtlsWithPapArgsDict',
    'RadiusServerProfileProtocolPapArgs',
    'RadiusServerProfileProtocolPapArgsDict',
    'RadiusServerProfileProtocolPeapMschaPv2Args',
    'RadiusServerProfileProtocolPeapMschaPv2ArgsDict',
    'RadiusServerProfileProtocolPeapWithGtcArgs',
    'RadiusServerProfileProtocolPeapWithGtcArgsDict',
    'RadiusServerProfileServerArgs',
    'RadiusServerProfileServerArgsDict',
    'RegionGeoLocationArgs',
    'RegionGeoLocationArgsDict',
    'RemoteNetworkEcmpTunnelArgs',
    'RemoteNetworkEcmpTunnelArgsDict',
    'RemoteNetworkEcmpTunnelProtocolArgs',
    'RemoteNetworkEcmpTunnelProtocolArgsDict',
    'RemoteNetworkEcmpTunnelProtocolBgpArgs',
    'RemoteNetworkEcmpTunnelProtocolBgpArgsDict',
    'RemoteNetworkProtocolArgs',
    'RemoteNetworkProtocolArgsDict',
    'RemoteNetworkProtocolBgpArgs',
    'RemoteNetworkProtocolBgpArgsDict',
    'RemoteNetworkProtocolBgpPeerArgs',
    'RemoteNetworkProtocolBgpPeerArgsDict',
    'RouteAccessListTypeArgs',
    'RouteAccessListTypeArgsDict',
    'RouteAccessListTypeIpv4Args',
    'RouteAccessListTypeIpv4ArgsDict',
    'RouteAccessListTypeIpv4Ipv4EntryArgs',
    'RouteAccessListTypeIpv4Ipv4EntryArgsDict',
    'RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgs',
    'RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgsDict',
    'RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgs',
    'RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgsDict',
    'RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgs',
    'RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgsDict',
    'RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgs',
    'RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgsDict',
    'RouteCommunityListTypeArgs',
    'RouteCommunityListTypeArgsDict',
    'RouteCommunityListTypeExtendedArgs',
    'RouteCommunityListTypeExtendedArgsDict',
    'RouteCommunityListTypeExtendedExtendedEntryArgs',
    'RouteCommunityListTypeExtendedExtendedEntryArgsDict',
    'RouteCommunityListTypeLargeArgs',
    'RouteCommunityListTypeLargeArgsDict',
    'RouteCommunityListTypeLargeLargeEntryArgs',
    'RouteCommunityListTypeLargeLargeEntryArgsDict',
    'RouteCommunityListTypeRegularArgs',
    'RouteCommunityListTypeRegularArgsDict',
    'RouteCommunityListTypeRegularRegularEntryArgs',
    'RouteCommunityListTypeRegularRegularEntryArgsDict',
    'RoutePathAccessListAspathEntryArgs',
    'RoutePathAccessListAspathEntryArgsDict',
    'RoutePrefixListTypeArgs',
    'RoutePrefixListTypeArgsDict',
    'RoutePrefixListTypeIpv4Args',
    'RoutePrefixListTypeIpv4ArgsDict',
    'RoutePrefixListTypeIpv4Ipv4EntryArgs',
    'RoutePrefixListTypeIpv4Ipv4EntryArgsDict',
    'RoutePrefixListTypeIpv4Ipv4EntryPrefixArgs',
    'RoutePrefixListTypeIpv4Ipv4EntryPrefixArgsDict',
    'RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgs',
    'RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgsDict',
    'ScepProfileAlgorithmArgs',
    'ScepProfileAlgorithmArgsDict',
    'ScepProfileAlgorithmRsaArgs',
    'ScepProfileAlgorithmRsaArgsDict',
    'ScepProfileCertificateAttributesArgs',
    'ScepProfileCertificateAttributesArgsDict',
    'ScepProfileScepChallengeArgs',
    'ScepProfileScepChallengeArgsDict',
    'ScepProfileScepChallengeDynamicArgs',
    'ScepProfileScepChallengeDynamicArgsDict',
    'ScepProfileScepChallengeNoneArgs',
    'ScepProfileScepChallengeNoneArgsDict',
    'ScheduleScheduleTypeArgs',
    'ScheduleScheduleTypeArgsDict',
    'ScheduleScheduleTypeRecurringArgs',
    'ScheduleScheduleTypeRecurringArgsDict',
    'ScheduleScheduleTypeRecurringWeeklyArgs',
    'ScheduleScheduleTypeRecurringWeeklyArgsDict',
    'SdwanErrorCorrectionProfileModeArgs',
    'SdwanErrorCorrectionProfileModeArgsDict',
    'SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgs',
    'SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgsDict',
    'SdwanErrorCorrectionProfileModePacketDuplicationArgs',
    'SdwanErrorCorrectionProfileModePacketDuplicationArgsDict',
    'SdwanPathQualityProfileMetricArgs',
    'SdwanPathQualityProfileMetricArgsDict',
    'SdwanPathQualityProfileMetricJitterArgs',
    'SdwanPathQualityProfileMetricJitterArgsDict',
    'SdwanPathQualityProfileMetricLatencyArgs',
    'SdwanPathQualityProfileMetricLatencyArgsDict',
    'SdwanPathQualityProfileMetricPktLossArgs',
    'SdwanPathQualityProfileMetricPktLossArgsDict',
    'SdwanRuleActionArgs',
    'SdwanRuleActionArgsDict',
    'SdwanSaasQualityProfileMonitorModeArgs',
    'SdwanSaasQualityProfileMonitorModeArgsDict',
    'SdwanSaasQualityProfileMonitorModeAdaptiveArgs',
    'SdwanSaasQualityProfileMonitorModeAdaptiveArgsDict',
    'SdwanSaasQualityProfileMonitorModeHttpHttpsArgs',
    'SdwanSaasQualityProfileMonitorModeHttpHttpsArgsDict',
    'SdwanSaasQualityProfileMonitorModeStaticIpArgs',
    'SdwanSaasQualityProfileMonitorModeStaticIpArgsDict',
    'SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgs',
    'SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgsDict',
    'SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgs',
    'SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgsDict',
    'SdwanTrafficDistributionProfileLinkTagArgs',
    'SdwanTrafficDistributionProfileLinkTagArgsDict',
    'SecurityRuleAllowUrlCategoryArgs',
    'SecurityRuleAllowUrlCategoryArgsDict',
    'SecurityRuleAllowUrlCategoryFileControlArgs',
    'SecurityRuleAllowUrlCategoryFileControlArgsDict',
    'SecurityRuleAllowWebApplicationArgs',
    'SecurityRuleAllowWebApplicationArgsDict',
    'SecurityRuleAllowWebApplicationFileControlArgs',
    'SecurityRuleAllowWebApplicationFileControlArgsDict',
    'SecurityRuleAllowWebApplicationSaasEnterpriseControlArgs',
    'SecurityRuleAllowWebApplicationSaasEnterpriseControlArgsDict',
    'SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgs',
    'SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgsDict',
    'SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgs',
    'SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgsDict',
    'SecurityRuleAllowWebApplicationTenantControlArgs',
    'SecurityRuleAllowWebApplicationTenantControlArgsDict',
    'SecurityRuleDefaultProfileSettingsArgs',
    'SecurityRuleDefaultProfileSettingsArgsDict',
    'SecurityRuleDefaultProfileSettingsFileControlArgs',
    'SecurityRuleDefaultProfileSettingsFileControlArgsDict',
    'SecurityRuleLogSettingsArgs',
    'SecurityRuleLogSettingsArgsDict',
    'SecurityRuleProfileSettingArgs',
    'SecurityRuleProfileSettingArgsDict',
    'SecurityRuleSecuritySettingsArgs',
    'SecurityRuleSecuritySettingsArgsDict',
    'ServiceConnectionBgpPeerArgs',
    'ServiceConnectionBgpPeerArgsDict',
    'ServiceConnectionProtocolArgs',
    'ServiceConnectionProtocolArgsDict',
    'ServiceConnectionProtocolBgpArgs',
    'ServiceConnectionProtocolBgpArgsDict',
    'ServiceConnectionQosArgs',
    'ServiceConnectionQosArgsDict',
    'ServiceProtocolArgs',
    'ServiceProtocolArgsDict',
    'ServiceProtocolTcpArgs',
    'ServiceProtocolTcpArgsDict',
    'ServiceProtocolTcpOverrideArgs',
    'ServiceProtocolTcpOverrideArgsDict',
    'ServiceProtocolUdpArgs',
    'ServiceProtocolUdpArgsDict',
    'ServiceProtocolUdpOverrideArgs',
    'ServiceProtocolUdpOverrideArgsDict',
    'ServiceRouteRouteArgs',
    'ServiceRouteRouteArgsDict',
    'ServiceRouteRouteDestinationArgs',
    'ServiceRouteRouteDestinationArgsDict',
    'ServiceRouteRouteDestinationSourceArgs',
    'ServiceRouteRouteDestinationSourceArgsDict',
    'ServiceRouteRouteServiceArgs',
    'ServiceRouteRouteServiceArgsDict',
    'ServiceRouteRouteServiceSourceArgs',
    'ServiceRouteRouteServiceSourceArgsDict',
    'ServiceRouteRouteServiceSourceV6Args',
    'ServiceRouteRouteServiceSourceV6ArgsDict',
    'ServiceSettingServicesArgs',
    'ServiceSettingServicesArgsDict',
    'ServiceSettingServicesDnsSettingArgs',
    'ServiceSettingServicesDnsSettingArgsDict',
    'ServiceSettingServicesDnsSettingServersArgs',
    'ServiceSettingServicesDnsSettingServersArgsDict',
    'ServiceSettingServicesNtpServersArgs',
    'ServiceSettingServicesNtpServersArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerArgs',
    'ServiceSettingServicesNtpServersPrimaryNtpServerArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgs',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgs',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgs',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgs',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args',
    'ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerArgs',
    'ServiceSettingServicesNtpServersSecondaryNtpServerArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgs',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgs',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgs',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgs',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args',
    'ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict',
    'SessionSettingSessionSettingsArgs',
    'SessionSettingSessionSettingsArgsDict',
    'SessionSettingSessionSettingsConfigArgs',
    'SessionSettingSessionSettingsConfigArgsDict',
    'SessionSettingSessionSettingsIcmpv6RateLimitArgs',
    'SessionSettingSessionSettingsIcmpv6RateLimitArgsDict',
    'SessionSettingSessionSettingsJumboFrameArgs',
    'SessionSettingSessionSettingsJumboFrameArgsDict',
    'SessionSettingSessionSettingsNat64Args',
    'SessionSettingSessionSettingsNat64ArgsDict',
    'SessionSettingSessionSettingsNatArgs',
    'SessionSettingSessionSettingsNatArgsDict',
    'SessionTimeoutSessionTimeoutsArgs',
    'SessionTimeoutSessionTimeoutsArgsDict',
    'SiteMemberArgs',
    'SiteMemberArgsDict',
    'SiteQosArgs',
    'SiteQosArgsDict',
    'SyslogServerProfileFormatArgs',
    'SyslogServerProfileFormatArgsDict',
    'SyslogServerProfileFormatEscapingArgs',
    'SyslogServerProfileFormatEscapingArgsDict',
    'SyslogServerProfileServerArgs',
    'SyslogServerProfileServerArgsDict',
    'TacacsServerProfileServerArgs',
    'TacacsServerProfileServerArgsDict',
    'TcpSettingTcpArgs',
    'TcpSettingTcpArgsDict',
    'TlsServiceProfileProtocolSettingsArgs',
    'TlsServiceProfileProtocolSettingsArgsDict',
    'TrafficSteeringRuleActionArgs',
    'TrafficSteeringRuleActionArgsDict',
    'TrafficSteeringRuleActionForwardArgs',
    'TrafficSteeringRuleActionForwardArgsDict',
    'TrafficSteeringRuleActionForwardForwardArgs',
    'TrafficSteeringRuleActionForwardForwardArgsDict',
    'TrafficSteeringRuleActionForwardNoPbfArgs',
    'TrafficSteeringRuleActionForwardNoPbfArgsDict',
    'TunnelInterfaceIpArgs',
    'TunnelInterfaceIpArgsDict',
    'TunnelInterfaceIpv6Args',
    'TunnelInterfaceIpv6ArgsDict',
    'TunnelInterfaceIpv6AddressArgs',
    'TunnelInterfaceIpv6AddressArgsDict',
    'TunnelInterfaceIpv6AddressAnycastArgs',
    'TunnelInterfaceIpv6AddressAnycastArgsDict',
    'TunnelInterfaceIpv6AddressPrefixArgs',
    'TunnelInterfaceIpv6AddressPrefixArgsDict',
    'UpdateScheduleUpdateScheduleArgs',
    'UpdateScheduleUpdateScheduleArgsDict',
    'UpdateScheduleUpdateScheduleAntiVirusArgs',
    'UpdateScheduleUpdateScheduleAntiVirusArgsDict',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringArgs',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringArgsDict',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgs',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgsDict',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgs',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgsDict',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgs',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgsDict',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgs',
    'UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgsDict',
    'UpdateScheduleUpdateScheduleThreatsArgs',
    'UpdateScheduleUpdateScheduleThreatsArgsDict',
    'UpdateScheduleUpdateScheduleThreatsRecurringArgs',
    'UpdateScheduleUpdateScheduleThreatsRecurringArgsDict',
    'UpdateScheduleUpdateScheduleThreatsRecurringDailyArgs',
    'UpdateScheduleUpdateScheduleThreatsRecurringDailyArgsDict',
    'UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgs',
    'UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgsDict',
    'UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgs',
    'UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgsDict',
    'UpdateScheduleUpdateScheduleThreatsRecurringNoneArgs',
    'UpdateScheduleUpdateScheduleThreatsRecurringNoneArgsDict',
    'UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgs',
    'UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgsDict',
    'UpdateScheduleUpdateScheduleWildfireArgs',
    'UpdateScheduleUpdateScheduleWildfireArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringNoneArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringNoneArgsDict',
    'UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgs',
    'UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgsDict',
    'UrlAccessProfileCredentialEnforcementArgs',
    'UrlAccessProfileCredentialEnforcementArgsDict',
    'UrlAccessProfileCredentialEnforcementModeArgs',
    'UrlAccessProfileCredentialEnforcementModeArgsDict',
    'UrlAccessProfileCredentialEnforcementModeDisabledArgs',
    'UrlAccessProfileCredentialEnforcementModeDisabledArgsDict',
    'UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgs',
    'UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgsDict',
    'UrlAccessProfileCredentialEnforcementModeIpUserArgs',
    'UrlAccessProfileCredentialEnforcementModeIpUserArgsDict',
    'VlanInterfaceArpArgs',
    'VlanInterfaceArpArgsDict',
    'VlanInterfaceDdnsConfigArgs',
    'VlanInterfaceDdnsConfigArgsDict',
    'VlanInterfaceDhcpClientArgs',
    'VlanInterfaceDhcpClientArgsDict',
    'VlanInterfaceDhcpClientSendHostnameArgs',
    'VlanInterfaceDhcpClientSendHostnameArgsDict',
    'VlanInterfaceIpArgs',
    'VlanInterfaceIpArgsDict',
    'VpnSettingVpnArgs',
    'VpnSettingVpnArgsDict',
    'VpnSettingVpnIkev2Args',
    'VpnSettingVpnIkev2ArgsDict',
    'VulnerabilityProtectionProfileRuleArgs',
    'VulnerabilityProtectionProfileRuleArgsDict',
    'VulnerabilityProtectionProfileRuleActionArgs',
    'VulnerabilityProtectionProfileRuleActionArgsDict',
    'VulnerabilityProtectionProfileRuleActionAlertArgs',
    'VulnerabilityProtectionProfileRuleActionAlertArgsDict',
    'VulnerabilityProtectionProfileRuleActionAllowArgs',
    'VulnerabilityProtectionProfileRuleActionAllowArgsDict',
    'VulnerabilityProtectionProfileRuleActionBlockIpArgs',
    'VulnerabilityProtectionProfileRuleActionBlockIpArgsDict',
    'VulnerabilityProtectionProfileRuleActionDefaultArgs',
    'VulnerabilityProtectionProfileRuleActionDefaultArgsDict',
    'VulnerabilityProtectionProfileRuleActionDropArgs',
    'VulnerabilityProtectionProfileRuleActionDropArgsDict',
    'VulnerabilityProtectionProfileRuleActionResetBothArgs',
    'VulnerabilityProtectionProfileRuleActionResetBothArgsDict',
    'VulnerabilityProtectionProfileRuleActionResetClientArgs',
    'VulnerabilityProtectionProfileRuleActionResetClientArgsDict',
    'VulnerabilityProtectionProfileRuleActionResetServerArgs',
    'VulnerabilityProtectionProfileRuleActionResetServerArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionArgs',
    'VulnerabilityProtectionProfileThreatExceptionArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionAlertArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionAlertArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionAllowArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionAllowArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionDefaultArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionDefaultArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionDropArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionDropArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionResetBothArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionResetBothArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionResetClientArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionResetClientArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionActionResetServerArgs',
    'VulnerabilityProtectionProfileThreatExceptionActionResetServerArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionExemptIpArgs',
    'VulnerabilityProtectionProfileThreatExceptionExemptIpArgsDict',
    'VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgs',
    'VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgsDict',
    'VulnerabilityProtectionSignatureAffectedHostArgs',
    'VulnerabilityProtectionSignatureAffectedHostArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionArgs',
    'VulnerabilityProtectionSignatureDefaultActionArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionAlertArgs',
    'VulnerabilityProtectionSignatureDefaultActionAlertArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionAllowArgs',
    'VulnerabilityProtectionSignatureDefaultActionAllowArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionBlockIpArgs',
    'VulnerabilityProtectionSignatureDefaultActionBlockIpArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionDropArgs',
    'VulnerabilityProtectionSignatureDefaultActionDropArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionResetBothArgs',
    'VulnerabilityProtectionSignatureDefaultActionResetBothArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionResetClientArgs',
    'VulnerabilityProtectionSignatureDefaultActionResetClientArgsDict',
    'VulnerabilityProtectionSignatureDefaultActionResetServerArgs',
    'VulnerabilityProtectionSignatureDefaultActionResetServerArgsDict',
    'VulnerabilityProtectionSignatureSignatureArgs',
    'VulnerabilityProtectionSignatureSignatureArgsDict',
    'VulnerabilityProtectionSignatureSignatureCombinationArgs',
    'VulnerabilityProtectionSignatureSignatureCombinationArgsDict',
    'VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgs',
    'VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgsDict',
    'VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgs',
    'VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgsDict',
    'VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgs',
    'VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardArgs',
    'VulnerabilityProtectionSignatureSignatureStandardArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs',
    'VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict',
    'WildfireAntiVirusProfileMlavExceptionArgs',
    'WildfireAntiVirusProfileMlavExceptionArgsDict',
    'WildfireAntiVirusProfileRuleArgs',
    'WildfireAntiVirusProfileRuleArgsDict',
    'WildfireAntiVirusProfileThreatExceptionArgs',
    'WildfireAntiVirusProfileThreatExceptionArgsDict',
    'ZoneDeviceAclArgs',
    'ZoneDeviceAclArgsDict',
    'ZoneNetworkArgs',
    'ZoneNetworkArgsDict',
    'ZoneNetworkTunnelArgs',
    'ZoneNetworkTunnelArgsDict',
    'ZoneProtectionProfileFloodArgs',
    'ZoneProtectionProfileFloodArgsDict',
    'ZoneProtectionProfileFloodIcmpArgs',
    'ZoneProtectionProfileFloodIcmpArgsDict',
    'ZoneProtectionProfileFloodIcmpRedArgs',
    'ZoneProtectionProfileFloodIcmpRedArgsDict',
    'ZoneProtectionProfileFloodIcmpv6Args',
    'ZoneProtectionProfileFloodIcmpv6ArgsDict',
    'ZoneProtectionProfileFloodIcmpv6RedArgs',
    'ZoneProtectionProfileFloodIcmpv6RedArgsDict',
    'ZoneProtectionProfileFloodOtherIpArgs',
    'ZoneProtectionProfileFloodOtherIpArgsDict',
    'ZoneProtectionProfileFloodOtherIpRedArgs',
    'ZoneProtectionProfileFloodOtherIpRedArgsDict',
    'ZoneProtectionProfileFloodSctpInitArgs',
    'ZoneProtectionProfileFloodSctpInitArgsDict',
    'ZoneProtectionProfileFloodSctpInitRedArgs',
    'ZoneProtectionProfileFloodSctpInitRedArgsDict',
    'ZoneProtectionProfileFloodTcpSynArgs',
    'ZoneProtectionProfileFloodTcpSynArgsDict',
    'ZoneProtectionProfileFloodTcpSynRedArgs',
    'ZoneProtectionProfileFloodTcpSynRedArgsDict',
    'ZoneProtectionProfileFloodTcpSynSynCookiesArgs',
    'ZoneProtectionProfileFloodTcpSynSynCookiesArgsDict',
    'ZoneProtectionProfileFloodUdpArgs',
    'ZoneProtectionProfileFloodUdpArgsDict',
    'ZoneProtectionProfileFloodUdpRedArgs',
    'ZoneProtectionProfileFloodUdpRedArgsDict',
    'ZoneProtectionProfileIpv6Args',
    'ZoneProtectionProfileIpv6ArgsDict',
    'ZoneProtectionProfileIpv6FilterExtHdrArgs',
    'ZoneProtectionProfileIpv6FilterExtHdrArgsDict',
    'ZoneProtectionProfileIpv6IgnoreInvPktArgs',
    'ZoneProtectionProfileIpv6IgnoreInvPktArgsDict',
    'ZoneProtectionProfileL2SecGroupTagProtectionArgs',
    'ZoneProtectionProfileL2SecGroupTagProtectionArgsDict',
    'ZoneProtectionProfileL2SecGroupTagProtectionTagArgs',
    'ZoneProtectionProfileL2SecGroupTagProtectionTagArgsDict',
    'ZoneProtectionProfileNonIpProtocolArgs',
    'ZoneProtectionProfileNonIpProtocolArgsDict',
    'ZoneProtectionProfileNonIpProtocolProtocolArgs',
    'ZoneProtectionProfileNonIpProtocolProtocolArgsDict',
    'ZoneProtectionProfileScanArgs',
    'ZoneProtectionProfileScanArgsDict',
    'ZoneProtectionProfileScanActionArgs',
    'ZoneProtectionProfileScanActionArgsDict',
    'ZoneProtectionProfileScanActionAlertArgs',
    'ZoneProtectionProfileScanActionAlertArgsDict',
    'ZoneProtectionProfileScanActionAllowArgs',
    'ZoneProtectionProfileScanActionAllowArgsDict',
    'ZoneProtectionProfileScanActionBlockArgs',
    'ZoneProtectionProfileScanActionBlockArgsDict',
    'ZoneProtectionProfileScanActionBlockIpArgs',
    'ZoneProtectionProfileScanActionBlockIpArgsDict',
    'ZoneProtectionProfileScanWhiteListArgs',
    'ZoneProtectionProfileScanWhiteListArgsDict',
    'ZoneUserAclArgs',
    'ZoneUserAclArgsDict',
]

MYPY = False

if not MYPY:
    class AddressGroupDynamicArgsDict(TypedDict):
        filter: pulumi.Input[_builtins.str]
        """
        Tag based filter defining group membership
        """
elif False:
    AddressGroupDynamicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupDynamicArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] filter: Tag based filter defining group membership
        """
        pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> pulumi.Input[_builtins.str]:
        """
        Tag based filter defining group membership
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class AggregateInterfaceLayer2ArgsDict(TypedDict):
        lacp: NotRequired[pulumi.Input['AggregateInterfaceLayer2LacpArgsDict']]
        """
        Lacp
        """
        vlan_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        VLAN tag
        """
elif False:
    AggregateInterfaceLayer2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer2Args:
    def __init__(__self__, *,
                 lacp: Optional[pulumi.Input['AggregateInterfaceLayer2LacpArgs']] = None,
                 vlan_tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AggregateInterfaceLayer2LacpArgs'] lacp: Lacp
        :param pulumi.Input[_builtins.str] vlan_tag: VLAN tag
        """
        if lacp is not None:
            pulumi.set(__self__, "lacp", lacp)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def lacp(self) -> Optional[pulumi.Input['AggregateInterfaceLayer2LacpArgs']]:
        """
        Lacp
        """
        return pulumi.get(self, "lacp")

    @lacp.setter
    def lacp(self, value: Optional[pulumi.Input['AggregateInterfaceLayer2LacpArgs']]):
        pulumi.set(self, "lacp", value)

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VLAN tag
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class AggregateInterfaceLayer2LacpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable LACP?
        """
        fast_failover: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Fast failover
        """
        max_ports: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of physical ports bundled in the LAG
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode
        """
        system_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        LACP system priority in system ID
        """
        transmission_rate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transmission mode
        """
elif False:
    AggregateInterfaceLayer2LacpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer2LacpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 fast_failover: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_ports: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 system_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 transmission_rate: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable LACP?
        :param pulumi.Input[_builtins.bool] fast_failover: Fast failover
        :param pulumi.Input[_builtins.int] max_ports: Maximum number of physical ports bundled in the LAG
        :param pulumi.Input[_builtins.str] mode: Mode
        :param pulumi.Input[_builtins.int] system_priority: LACP system priority in system ID
        :param pulumi.Input[_builtins.str] transmission_rate: Transmission mode
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if fast_failover is not None:
            pulumi.set(__self__, "fast_failover", fast_failover)
        if max_ports is not None:
            pulumi.set(__self__, "max_ports", max_ports)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if system_priority is not None:
            pulumi.set(__self__, "system_priority", system_priority)
        if transmission_rate is not None:
            pulumi.set(__self__, "transmission_rate", transmission_rate)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable LACP?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="fastFailover")
    def fast_failover(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Fast failover
        """
        return pulumi.get(self, "fast_failover")

    @fast_failover.setter
    def fast_failover(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fast_failover", value)

    @_builtins.property
    @pulumi.getter(name="maxPorts")
    def max_ports(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of physical ports bundled in the LAG
        """
        return pulumi.get(self, "max_ports")

    @max_ports.setter
    def max_ports(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ports", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="systemPriority")
    def system_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        LACP system priority in system ID
        """
        return pulumi.get(self, "system_priority")

    @system_priority.setter
    def system_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "system_priority", value)

    @_builtins.property
    @pulumi.getter(name="transmissionRate")
    def transmission_rate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transmission mode
        """
        return pulumi.get(self, "transmission_rate")

    @transmission_rate.setter
    def transmission_rate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transmission_rate", value)


if not MYPY:
    class AggregateInterfaceLayer3ArgsDict(TypedDict):
        arps: NotRequired[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3ArpArgsDict']]]]
        """
        Aggregate Ethernet ARP configuration
        """
        ddns_config: NotRequired[pulumi.Input['AggregateInterfaceLayer3DdnsConfigArgsDict']]
        """
        Dynamic DNS configuration specific to the Aggregate Interface.
        """
        dhcp_client: NotRequired[pulumi.Input['AggregateInterfaceLayer3DhcpClientArgsDict']]
        """
        Aggregate Ethernet DHCP Client Object
        """
        interface_management_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface management profile
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3IpArgsDict']]]]
        """
        Aggregate Interface IP addresses

        >  **Note:** You must specify exactly one of `dhcp_client` and `ip`.
        """
        lacp: NotRequired[pulumi.Input['AggregateInterfaceLayer3LacpArgsDict']]
        """
        Lacp
        """
        mtu: NotRequired[pulumi.Input[_builtins.int]]
        """
        MTU
        """
elif False:
    AggregateInterfaceLayer3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3Args:
    def __init__(__self__, *,
                 arps: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3ArpArgs']]]] = None,
                 ddns_config: Optional[pulumi.Input['AggregateInterfaceLayer3DdnsConfigArgs']] = None,
                 dhcp_client: Optional[pulumi.Input['AggregateInterfaceLayer3DhcpClientArgs']] = None,
                 interface_management_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3IpArgs']]]] = None,
                 lacp: Optional[pulumi.Input['AggregateInterfaceLayer3LacpArgs']] = None,
                 mtu: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3ArpArgs']]] arps: Aggregate Ethernet ARP configuration
        :param pulumi.Input['AggregateInterfaceLayer3DdnsConfigArgs'] ddns_config: Dynamic DNS configuration specific to the Aggregate Interface.
        :param pulumi.Input['AggregateInterfaceLayer3DhcpClientArgs'] dhcp_client: Aggregate Ethernet DHCP Client Object
        :param pulumi.Input[_builtins.str] interface_management_profile: Interface management profile
        :param pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3IpArgs']]] ips: Aggregate Interface IP addresses
               
               >  **Note:** You must specify exactly one of `dhcp_client` and `ip`.
        :param pulumi.Input['AggregateInterfaceLayer3LacpArgs'] lacp: Lacp
        :param pulumi.Input[_builtins.int] mtu: MTU
        """
        if arps is not None:
            pulumi.set(__self__, "arps", arps)
        if ddns_config is not None:
            pulumi.set(__self__, "ddns_config", ddns_config)
        if dhcp_client is not None:
            pulumi.set(__self__, "dhcp_client", dhcp_client)
        if interface_management_profile is not None:
            pulumi.set(__self__, "interface_management_profile", interface_management_profile)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if lacp is not None:
            pulumi.set(__self__, "lacp", lacp)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)

    @_builtins.property
    @pulumi.getter
    def arps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3ArpArgs']]]]:
        """
        Aggregate Ethernet ARP configuration
        """
        return pulumi.get(self, "arps")

    @arps.setter
    def arps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3ArpArgs']]]]):
        pulumi.set(self, "arps", value)

    @_builtins.property
    @pulumi.getter(name="ddnsConfig")
    def ddns_config(self) -> Optional[pulumi.Input['AggregateInterfaceLayer3DdnsConfigArgs']]:
        """
        Dynamic DNS configuration specific to the Aggregate Interface.
        """
        return pulumi.get(self, "ddns_config")

    @ddns_config.setter
    def ddns_config(self, value: Optional[pulumi.Input['AggregateInterfaceLayer3DdnsConfigArgs']]):
        pulumi.set(self, "ddns_config", value)

    @_builtins.property
    @pulumi.getter(name="dhcpClient")
    def dhcp_client(self) -> Optional[pulumi.Input['AggregateInterfaceLayer3DhcpClientArgs']]:
        """
        Aggregate Ethernet DHCP Client Object
        """
        return pulumi.get(self, "dhcp_client")

    @dhcp_client.setter
    def dhcp_client(self, value: Optional[pulumi.Input['AggregateInterfaceLayer3DhcpClientArgs']]):
        pulumi.set(self, "dhcp_client", value)

    @_builtins.property
    @pulumi.getter(name="interfaceManagementProfile")
    def interface_management_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface management profile
        """
        return pulumi.get(self, "interface_management_profile")

    @interface_management_profile.setter
    def interface_management_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface_management_profile", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3IpArgs']]]]:
        """
        Aggregate Interface IP addresses

        >  **Note:** You must specify exactly one of `dhcp_client` and `ip`.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateInterfaceLayer3IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter
    def lacp(self) -> Optional[pulumi.Input['AggregateInterfaceLayer3LacpArgs']]:
        """
        Lacp
        """
        return pulumi.get(self, "lacp")

    @lacp.setter
    def lacp(self, value: Optional[pulumi.Input['AggregateInterfaceLayer3LacpArgs']]):
        pulumi.set(self, "lacp", value)

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        MTU
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mtu", value)


if not MYPY:
    class AggregateInterfaceLayer3ArpArgsDict(TypedDict):
        hw_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
elif False:
    AggregateInterfaceLayer3ArpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3ArpArgs:
    def __init__(__self__, *,
                 hw_address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hw_address: MAC address
        :param pulumi.Input[_builtins.str] name: IP address
        """
        if hw_address is not None:
            pulumi.set(__self__, "hw_address", hw_address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="hwAddress")
    def hw_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address
        """
        return pulumi.get(self, "hw_address")

    @hw_address.setter
    def hw_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hw_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AggregateInterfaceLayer3DdnsConfigArgsDict(TypedDict):
        ddns_cert_profile: pulumi.Input[_builtins.str]
        """
        Certificate profile
        """
        ddns_hostname: pulumi.Input[_builtins.str]
        """
        Ddns hostname
        """
        ddns_vendor: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_vendor_config: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DDNS?
        """
        ddns_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP to register (static only)
        """
        ddns_update_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Update interval (days)
        """
elif False:
    AggregateInterfaceLayer3DdnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3DdnsConfigArgs:
    def __init__(__self__, *,
                 ddns_cert_profile: pulumi.Input[_builtins.str],
                 ddns_hostname: pulumi.Input[_builtins.str],
                 ddns_vendor: pulumi.Input[_builtins.str],
                 ddns_vendor_config: pulumi.Input[_builtins.str],
                 ddns_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ddns_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ddns_update_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ddns_cert_profile: Certificate profile
        :param pulumi.Input[_builtins.str] ddns_hostname: Ddns hostname
        :param pulumi.Input[_builtins.str] ddns_vendor: DDNS vendor
        :param pulumi.Input[_builtins.str] ddns_vendor_config: DDNS vendor
        :param pulumi.Input[_builtins.bool] ddns_enabled: Enable DDNS?
        :param pulumi.Input[_builtins.str] ddns_ip: IP to register (static only)
        :param pulumi.Input[_builtins.int] ddns_update_interval: Update interval (days)
        """
        pulumi.set(__self__, "ddns_cert_profile", ddns_cert_profile)
        pulumi.set(__self__, "ddns_hostname", ddns_hostname)
        pulumi.set(__self__, "ddns_vendor", ddns_vendor)
        pulumi.set(__self__, "ddns_vendor_config", ddns_vendor_config)
        if ddns_enabled is not None:
            pulumi.set(__self__, "ddns_enabled", ddns_enabled)
        if ddns_ip is not None:
            pulumi.set(__self__, "ddns_ip", ddns_ip)
        if ddns_update_interval is not None:
            pulumi.set(__self__, "ddns_update_interval", ddns_update_interval)

    @_builtins.property
    @pulumi.getter(name="ddnsCertProfile")
    def ddns_cert_profile(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate profile
        """
        return pulumi.get(self, "ddns_cert_profile")

    @ddns_cert_profile.setter
    def ddns_cert_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_cert_profile", value)

    @_builtins.property
    @pulumi.getter(name="ddnsHostname")
    def ddns_hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Ddns hostname
        """
        return pulumi.get(self, "ddns_hostname")

    @ddns_hostname.setter
    def ddns_hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_hostname", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendor")
    def ddns_vendor(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor")

    @ddns_vendor.setter
    def ddns_vendor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendorConfig")
    def ddns_vendor_config(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor_config")

    @ddns_vendor_config.setter
    def ddns_vendor_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor_config", value)

    @_builtins.property
    @pulumi.getter(name="ddnsEnabled")
    def ddns_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DDNS?
        """
        return pulumi.get(self, "ddns_enabled")

    @ddns_enabled.setter
    def ddns_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ddns_enabled", value)

    @_builtins.property
    @pulumi.getter(name="ddnsIp")
    def ddns_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP to register (static only)
        """
        return pulumi.get(self, "ddns_ip")

    @ddns_ip.setter
    def ddns_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddns_ip", value)

    @_builtins.property
    @pulumi.getter(name="ddnsUpdateInterval")
    def ddns_update_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Update interval (days)
        """
        return pulumi.get(self, "ddns_update_interval")

    @ddns_update_interval.setter
    def ddns_update_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ddns_update_interval", value)


if not MYPY:
    class AggregateInterfaceLayer3DhcpClientArgsDict(TypedDict):
        create_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically create default route pointing to default gateway provided by server
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric of the default route created
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DHCP?
        """
        send_hostname: NotRequired[pulumi.Input['AggregateInterfaceLayer3DhcpClientSendHostnameArgsDict']]
        """
        Aggregate Ethernet DHCP Client Send hostname
        """
elif False:
    AggregateInterfaceLayer3DhcpClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3DhcpClientArgs:
    def __init__(__self__, *,
                 create_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_hostname: Optional[pulumi.Input['AggregateInterfaceLayer3DhcpClientSendHostnameArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] create_default_route: Automatically create default route pointing to default gateway provided by server
        :param pulumi.Input[_builtins.int] default_route_metric: Metric of the default route created
        :param pulumi.Input[_builtins.bool] enable: Enable DHCP?
        :param pulumi.Input['AggregateInterfaceLayer3DhcpClientSendHostnameArgs'] send_hostname: Aggregate Ethernet DHCP Client Send hostname
        """
        if create_default_route is not None:
            pulumi.set(__self__, "create_default_route", create_default_route)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if send_hostname is not None:
            pulumi.set(__self__, "send_hostname", send_hostname)

    @_builtins.property
    @pulumi.getter(name="createDefaultRoute")
    def create_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically create default route pointing to default gateway provided by server
        """
        return pulumi.get(self, "create_default_route")

    @create_default_route.setter
    def create_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_default_route", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric of the default route created
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DHCP?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="sendHostname")
    def send_hostname(self) -> Optional[pulumi.Input['AggregateInterfaceLayer3DhcpClientSendHostnameArgs']]:
        """
        Aggregate Ethernet DHCP Client Send hostname
        """
        return pulumi.get(self, "send_hostname")

    @send_hostname.setter
    def send_hostname(self, value: Optional[pulumi.Input['AggregateInterfaceLayer3DhcpClientSendHostnameArgs']]):
        pulumi.set(self, "send_hostname", value)


if not MYPY:
    class AggregateInterfaceLayer3DhcpClientSendHostnameArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set interface hostname
        """
elif False:
    AggregateInterfaceLayer3DhcpClientSendHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3DhcpClientSendHostnameArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] hostname: Set interface hostname
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set interface hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class AggregateInterfaceLayer3IpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Aggregate Interface IP addresses name
        """
elif False:
    AggregateInterfaceLayer3IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3IpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Aggregate Interface IP addresses name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Aggregate Interface IP addresses name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AggregateInterfaceLayer3LacpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable LACP?
        """
        fast_failover: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Fast failover
        """
        max_ports: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of physical ports bundled in the LAG
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode
        """
        system_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        LACP system priority in system ID
        """
        transmission_rate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transmission mode
        """
elif False:
    AggregateInterfaceLayer3LacpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateInterfaceLayer3LacpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 fast_failover: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_ports: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 system_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 transmission_rate: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable LACP?
        :param pulumi.Input[_builtins.bool] fast_failover: Fast failover
        :param pulumi.Input[_builtins.int] max_ports: Maximum number of physical ports bundled in the LAG
        :param pulumi.Input[_builtins.str] mode: Mode
        :param pulumi.Input[_builtins.int] system_priority: LACP system priority in system ID
        :param pulumi.Input[_builtins.str] transmission_rate: Transmission mode
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if fast_failover is not None:
            pulumi.set(__self__, "fast_failover", fast_failover)
        if max_ports is not None:
            pulumi.set(__self__, "max_ports", max_ports)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if system_priority is not None:
            pulumi.set(__self__, "system_priority", system_priority)
        if transmission_rate is not None:
            pulumi.set(__self__, "transmission_rate", transmission_rate)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable LACP?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="fastFailover")
    def fast_failover(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Fast failover
        """
        return pulumi.get(self, "fast_failover")

    @fast_failover.setter
    def fast_failover(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fast_failover", value)

    @_builtins.property
    @pulumi.getter(name="maxPorts")
    def max_ports(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of physical ports bundled in the LAG
        """
        return pulumi.get(self, "max_ports")

    @max_ports.setter
    def max_ports(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ports", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="systemPriority")
    def system_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        LACP system priority in system ID
        """
        return pulumi.get(self, "system_priority")

    @system_priority.setter
    def system_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "system_priority", value)

    @_builtins.property
    @pulumi.getter(name="transmissionRate")
    def transmission_rate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transmission mode
        """
        return pulumi.get(self, "transmission_rate")

    @transmission_rate.setter
    def transmission_rate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transmission_rate", value)


if not MYPY:
    class AntiSpywareProfileMicaEngineSpywareEnabledArgsDict(TypedDict):
        inline_policy_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inline policy action
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    AntiSpywareProfileMicaEngineSpywareEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileMicaEngineSpywareEnabledArgs:
    def __init__(__self__, *,
                 inline_policy_action: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inline_policy_action: Inline policy action
        :param pulumi.Input[_builtins.str] name: Name
        """
        if inline_policy_action is not None:
            pulumi.set(__self__, "inline_policy_action", inline_policy_action)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="inlinePolicyAction")
    def inline_policy_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inline policy action
        """
        return pulumi.get(self, "inline_policy_action")

    @inline_policy_action.setter
    def inline_policy_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inline_policy_action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AntiSpywareProfileRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionArgsDict']]
        """
        anti spyware profiles rules default action
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Category
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        packet_capture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Packet capture
        """
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Severity
        """
        threat_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threat name
        """
elif False:
    AntiSpywareProfileRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['AntiSpywareProfileRuleActionArgs']] = None,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 packet_capture: Optional[pulumi.Input[_builtins.str]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 threat_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AntiSpywareProfileRuleActionArgs'] action: anti spyware profiles rules default action
        :param pulumi.Input[_builtins.str] category: Category
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] packet_capture: Packet capture
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] severities: Severity
        :param pulumi.Input[_builtins.str] threat_name: Threat name
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packet_capture is not None:
            pulumi.set(__self__, "packet_capture", packet_capture)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if threat_name is not None:
            pulumi.set(__self__, "threat_name", threat_name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionArgs']]:
        """
        anti spyware profiles rules default action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Category
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="packetCapture")
    def packet_capture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Packet capture
        """
        return pulumi.get(self, "packet_capture")

    @packet_capture.setter
    def packet_capture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packet_capture", value)

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Severity
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "severities", value)

    @_builtins.property
    @pulumi.getter(name="threatName")
    def threat_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threat name
        """
        return pulumi.get(self, "threat_name")

    @threat_name.setter
    def threat_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threat_name", value)


if not MYPY:
    class AntiSpywareProfileRuleActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        block_ip: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionBlockIpArgsDict']]
        """
        anti spyware profiles rules action block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        drop: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionDropArgsDict']]
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_both: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionResetBothArgsDict']]
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_client: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionResetClientArgsDict']]
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_server: NotRequired[pulumi.Input['AntiSpywareProfileRuleActionResetServerArgsDict']]
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
elif False:
    AntiSpywareProfileRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['AntiSpywareProfileRuleActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['AntiSpywareProfileRuleActionAllowArgs']] = None,
                 block_ip: Optional[pulumi.Input['AntiSpywareProfileRuleActionBlockIpArgs']] = None,
                 drop: Optional[pulumi.Input['AntiSpywareProfileRuleActionDropArgs']] = None,
                 reset_both: Optional[pulumi.Input['AntiSpywareProfileRuleActionResetBothArgs']] = None,
                 reset_client: Optional[pulumi.Input['AntiSpywareProfileRuleActionResetClientArgs']] = None,
                 reset_server: Optional[pulumi.Input['AntiSpywareProfileRuleActionResetServerArgs']] = None):
        """
        :param pulumi.Input['AntiSpywareProfileRuleActionAlertArgs'] alert: Alert
        :param pulumi.Input['AntiSpywareProfileRuleActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileRuleActionBlockIpArgs'] block_ip: anti spyware profiles rules action block ip
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileRuleActionDropArgs'] drop: Drop
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileRuleActionResetBothArgs'] reset_both: Reset both
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileRuleActionResetClientArgs'] reset_client: Reset client
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileRuleActionResetServerArgs'] reset_server: Reset server
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if reset_both is not None:
            pulumi.set(__self__, "reset_both", reset_both)
        if reset_client is not None:
            pulumi.set(__self__, "reset_client", reset_client)
        if reset_server is not None:
            pulumi.set(__self__, "reset_server", reset_server)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionBlockIpArgs']]:
        """
        anti spyware profiles rules action block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)

    @_builtins.property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionDropArgs']]:
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionDropArgs']]):
        pulumi.set(self, "drop", value)

    @_builtins.property
    @pulumi.getter(name="resetBoth")
    def reset_both(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionResetBothArgs']]:
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_both")

    @reset_both.setter
    def reset_both(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionResetBothArgs']]):
        pulumi.set(self, "reset_both", value)

    @_builtins.property
    @pulumi.getter(name="resetClient")
    def reset_client(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionResetClientArgs']]:
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_client")

    @reset_client.setter
    def reset_client(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionResetClientArgs']]):
        pulumi.set(self, "reset_client", value)

    @_builtins.property
    @pulumi.getter(name="resetServer")
    def reset_server(self) -> Optional[pulumi.Input['AntiSpywareProfileRuleActionResetServerArgs']]:
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_server")

    @reset_server.setter
    def reset_server(self, value: Optional[pulumi.Input['AntiSpywareProfileRuleActionResetServerArgs']]):
        pulumi.set(self, "reset_server", value)


if not MYPY:
    class AntiSpywareProfileRuleActionAlertArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileRuleActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileRuleActionAllowArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileRuleActionBlockIpArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    AntiSpywareProfileRuleActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class AntiSpywareProfileRuleActionDropArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileRuleActionDropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionDropArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileRuleActionResetBothArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileRuleActionResetBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionResetBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileRuleActionResetClientArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileRuleActionResetClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionResetClientArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileRuleActionResetServerArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileRuleActionResetServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileRuleActionResetServerArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionArgsDict']]
        """
        anti spyware profiles threat exception default action
        """
        exempt_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareProfileThreatExceptionExemptIpArgsDict']]]]
        """
        Exempt ip
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes
        """
        packet_capture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Packet capture
        """
elif False:
    AntiSpywareProfileThreatExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionArgs']] = None,
                 exempt_ips: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareProfileThreatExceptionExemptIpArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 packet_capture: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionArgs'] action: anti spyware profiles threat exception default action
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareProfileThreatExceptionExemptIpArgs']]] exempt_ips: Exempt ip
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] notes: Notes
        :param pulumi.Input[_builtins.str] packet_capture: Packet capture
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if exempt_ips is not None:
            pulumi.set(__self__, "exempt_ips", exempt_ips)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if packet_capture is not None:
            pulumi.set(__self__, "packet_capture", packet_capture)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionArgs']]:
        """
        anti spyware profiles threat exception default action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="exemptIps")
    def exempt_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareProfileThreatExceptionExemptIpArgs']]]]:
        """
        Exempt ip
        """
        return pulumi.get(self, "exempt_ips")

    @exempt_ips.setter
    def exempt_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareProfileThreatExceptionExemptIpArgs']]]]):
        pulumi.set(self, "exempt_ips", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="packetCapture")
    def packet_capture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Packet capture
        """
        return pulumi.get(self, "packet_capture")

    @packet_capture.setter
    def packet_capture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packet_capture", value)


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        block_ip: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionBlockIpArgsDict']]
        """
        anti spyware profiles threat exception action block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        default: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionDefaultArgsDict']]
        """
        Default

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        drop: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionDropArgsDict']]
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_both: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetBothArgsDict']]
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_client: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetClientArgsDict']]
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_server: NotRequired[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetServerArgsDict']]
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
elif False:
    AntiSpywareProfileThreatExceptionActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionAllowArgs']] = None,
                 block_ip: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionBlockIpArgs']] = None,
                 default: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionDefaultArgs']] = None,
                 drop: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionDropArgs']] = None,
                 reset_both: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetBothArgs']] = None,
                 reset_client: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetClientArgs']] = None,
                 reset_server: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetServerArgs']] = None):
        """
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionAlertArgs'] alert: Alert
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionBlockIpArgs'] block_ip: anti spyware profiles threat exception action block ip
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionDefaultArgs'] default: Default
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionDropArgs'] drop: Drop
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionResetBothArgs'] reset_both: Reset both
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionResetClientArgs'] reset_client: Reset client
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareProfileThreatExceptionActionResetServerArgs'] reset_server: Reset server
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if reset_both is not None:
            pulumi.set(__self__, "reset_both", reset_both)
        if reset_client is not None:
            pulumi.set(__self__, "reset_client", reset_client)
        if reset_server is not None:
            pulumi.set(__self__, "reset_server", reset_server)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionBlockIpArgs']]:
        """
        anti spyware profiles threat exception action block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionDefaultArgs']]:
        """
        Default

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionDefaultArgs']]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionDropArgs']]:
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionDropArgs']]):
        pulumi.set(self, "drop", value)

    @_builtins.property
    @pulumi.getter(name="resetBoth")
    def reset_both(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetBothArgs']]:
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_both")

    @reset_both.setter
    def reset_both(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetBothArgs']]):
        pulumi.set(self, "reset_both", value)

    @_builtins.property
    @pulumi.getter(name="resetClient")
    def reset_client(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetClientArgs']]:
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_client")

    @reset_client.setter
    def reset_client(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetClientArgs']]):
        pulumi.set(self, "reset_client", value)

    @_builtins.property
    @pulumi.getter(name="resetServer")
    def reset_server(self) -> Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetServerArgs']]:
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_server")

    @reset_server.setter
    def reset_server(self, value: Optional[pulumi.Input['AntiSpywareProfileThreatExceptionActionResetServerArgs']]):
        pulumi.set(self, "reset_server", value)


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionAlertArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionAllowArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionBlockIpArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    AntiSpywareProfileThreatExceptionActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionDefaultArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionDefaultArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionDropArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionDropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionDropArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionResetBothArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionResetBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionResetBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionResetClientArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionResetClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionResetClientArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionActionResetServerArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareProfileThreatExceptionActionResetServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionActionResetServerArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareProfileThreatExceptionExemptIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
elif False:
    AntiSpywareProfileThreatExceptionExemptIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareProfileThreatExceptionExemptIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AntiSpywareSignatureDefaultActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        block_ip: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionBlockIpArgsDict']]
        """
        anti spyware signature block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        drop: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionDropArgsDict']]
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_both: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionResetBothArgsDict']]
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_client: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionResetClientArgsDict']]
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_server: NotRequired[pulumi.Input['AntiSpywareSignatureDefaultActionResetServerArgsDict']]
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
elif False:
    AntiSpywareSignatureDefaultActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionAllowArgs']] = None,
                 block_ip: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionBlockIpArgs']] = None,
                 drop: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionDropArgs']] = None,
                 reset_both: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetBothArgs']] = None,
                 reset_client: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetClientArgs']] = None,
                 reset_server: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetServerArgs']] = None):
        """
        :param pulumi.Input['AntiSpywareSignatureDefaultActionAlertArgs'] alert: Alert
        :param pulumi.Input['AntiSpywareSignatureDefaultActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareSignatureDefaultActionBlockIpArgs'] block_ip: anti spyware signature block ip
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareSignatureDefaultActionDropArgs'] drop: Drop
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareSignatureDefaultActionResetBothArgs'] reset_both: Reset both
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareSignatureDefaultActionResetClientArgs'] reset_client: Reset client
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['AntiSpywareSignatureDefaultActionResetServerArgs'] reset_server: Reset server
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if reset_both is not None:
            pulumi.set(__self__, "reset_both", reset_both)
        if reset_client is not None:
            pulumi.set(__self__, "reset_client", reset_client)
        if reset_server is not None:
            pulumi.set(__self__, "reset_server", reset_server)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionBlockIpArgs']]:
        """
        anti spyware signature block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)

    @_builtins.property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionDropArgs']]:
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionDropArgs']]):
        pulumi.set(self, "drop", value)

    @_builtins.property
    @pulumi.getter(name="resetBoth")
    def reset_both(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetBothArgs']]:
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_both")

    @reset_both.setter
    def reset_both(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetBothArgs']]):
        pulumi.set(self, "reset_both", value)

    @_builtins.property
    @pulumi.getter(name="resetClient")
    def reset_client(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetClientArgs']]:
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_client")

    @reset_client.setter
    def reset_client(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetClientArgs']]):
        pulumi.set(self, "reset_client", value)

    @_builtins.property
    @pulumi.getter(name="resetServer")
    def reset_server(self) -> Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetServerArgs']]:
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_server")

    @reset_server.setter
    def reset_server(self, value: Optional[pulumi.Input['AntiSpywareSignatureDefaultActionResetServerArgs']]):
        pulumi.set(self, "reset_server", value)


if not MYPY:
    class AntiSpywareSignatureDefaultActionAlertArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareSignatureDefaultActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareSignatureDefaultActionAllowArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareSignatureDefaultActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareSignatureDefaultActionBlockIpArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    AntiSpywareSignatureDefaultActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class AntiSpywareSignatureDefaultActionDropArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareSignatureDefaultActionDropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionDropArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareSignatureDefaultActionResetBothArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareSignatureDefaultActionResetBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionResetBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareSignatureDefaultActionResetClientArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareSignatureDefaultActionResetClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionResetClientArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareSignatureDefaultActionResetServerArgsDict(TypedDict):
        pass
elif False:
    AntiSpywareSignatureDefaultActionResetServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureDefaultActionResetServerArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AntiSpywareSignatureSignatureArgsDict(TypedDict):
        combination: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureCombinationArgsDict']]
        """
        anti spyware signature combination
        """
        standards: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardArgsDict']]]]
        """
        Standard

        >  **Note:** You must specify exactly one of `combination` and `standard`.
        """
elif False:
    AntiSpywareSignatureSignatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureArgs:
    def __init__(__self__, *,
                 combination: Optional[pulumi.Input['AntiSpywareSignatureSignatureCombinationArgs']] = None,
                 standards: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardArgs']]]] = None):
        """
        :param pulumi.Input['AntiSpywareSignatureSignatureCombinationArgs'] combination: anti spyware signature combination
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardArgs']]] standards: Standard
               
               >  **Note:** You must specify exactly one of `combination` and `standard`.
        """
        if combination is not None:
            pulumi.set(__self__, "combination", combination)
        if standards is not None:
            pulumi.set(__self__, "standards", standards)

    @_builtins.property
    @pulumi.getter
    def combination(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureCombinationArgs']]:
        """
        anti spyware signature combination
        """
        return pulumi.get(self, "combination")

    @combination.setter
    def combination(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureCombinationArgs']]):
        pulumi.set(self, "combination", value)

    @_builtins.property
    @pulumi.getter
    def standards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardArgs']]]]:
        """
        Standard

        >  **Note:** You must specify exactly one of `combination` and `standard`.
        """
        return pulumi.get(self, "standards")

    @standards.setter
    def standards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardArgs']]]]):
        pulumi.set(self, "standards", value)


if not MYPY:
    class AntiSpywareSignatureSignatureCombinationArgsDict(TypedDict):
        and_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionArgsDict']]]]
        """
        And condition
        """
        order_free: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Order free
        """
        time_attribute: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureCombinationTimeAttributeArgsDict']]
        """
        anti spyware time attribute
        """
elif False:
    AntiSpywareSignatureSignatureCombinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureCombinationArgs:
    def __init__(__self__, *,
                 and_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionArgs']]]] = None,
                 order_free: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_attribute: Optional[pulumi.Input['AntiSpywareSignatureSignatureCombinationTimeAttributeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionArgs']]] and_conditions: And condition
        :param pulumi.Input[_builtins.bool] order_free: Order free
        :param pulumi.Input['AntiSpywareSignatureSignatureCombinationTimeAttributeArgs'] time_attribute: anti spyware time attribute
        """
        if and_conditions is not None:
            pulumi.set(__self__, "and_conditions", and_conditions)
        if order_free is not None:
            pulumi.set(__self__, "order_free", order_free)
        if time_attribute is not None:
            pulumi.set(__self__, "time_attribute", time_attribute)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionArgs']]]]:
        """
        And condition
        """
        return pulumi.get(self, "and_conditions")

    @and_conditions.setter
    def and_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionArgs']]]]):
        pulumi.set(self, "and_conditions", value)

    @_builtins.property
    @pulumi.getter(name="orderFree")
    def order_free(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Order free
        """
        return pulumi.get(self, "order_free")

    @order_free.setter
    def order_free(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order_free", value)

    @_builtins.property
    @pulumi.getter(name="timeAttribute")
    def time_attribute(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureCombinationTimeAttributeArgs']]:
        """
        anti spyware time attribute
        """
        return pulumi.get(self, "time_attribute")

    @time_attribute.setter
    def time_attribute(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureCombinationTimeAttributeArgs']]):
        pulumi.set(self, "time_attribute", value)


if not MYPY:
    class AntiSpywareSignatureSignatureCombinationAndConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        or_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgsDict']]]]
        """
        Or condition
        """
elif False:
    AntiSpywareSignatureSignatureCombinationAndConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureCombinationAndConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 or_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgs']]] or_conditions: Or condition
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if or_conditions is not None:
            pulumi.set(__self__, "or_conditions", or_conditions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgs']]]]:
        """
        Or condition
        """
        return pulumi.get(self, "or_conditions")

    @or_conditions.setter
    def or_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgs']]]]):
        pulumi.set(self, "or_conditions", value)


if not MYPY:
    class AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        threat_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threat id
        """
elif False:
    AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureCombinationAndConditionOrConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 threat_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] threat_id: Threat id
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if threat_id is not None:
            pulumi.set(__self__, "threat_id", threat_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="threatId")
    def threat_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threat id
        """
        return pulumi.get(self, "threat_id")

    @threat_id.setter
    def threat_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threat_id", value)


if not MYPY:
    class AntiSpywareSignatureSignatureCombinationTimeAttributeArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    AntiSpywareSignatureSignatureCombinationTimeAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureCombinationTimeAttributeArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Interval
        :param pulumi.Input[_builtins.int] threshold: Threshold
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        and_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionArgsDict']]]]
        """
        And condition
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment
        """
        order_free: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Order free
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope
        """
elif False:
    AntiSpywareSignatureSignatureStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 and_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionArgs']]]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 order_free: Optional[pulumi.Input[_builtins.bool]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionArgs']]] and_conditions: And condition
        :param pulumi.Input[_builtins.str] comment: Comment
        :param pulumi.Input[_builtins.bool] order_free: Order free
        :param pulumi.Input[_builtins.str] scope: Scope
        """
        pulumi.set(__self__, "name", name)
        if and_conditions is not None:
            pulumi.set(__self__, "and_conditions", and_conditions)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if order_free is not None:
            pulumi.set(__self__, "order_free", order_free)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionArgs']]]]:
        """
        And condition
        """
        return pulumi.get(self, "and_conditions")

    @and_conditions.setter
    def and_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionArgs']]]]):
        pulumi.set(self, "and_conditions", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="orderFree")
    def order_free(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Order free
        """
        return pulumi.get(self, "order_free")

    @order_free.setter
    def order_free(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order_free", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        or_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgsDict']]]]
        """
        Or condition
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 or_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgs']]] or_conditions: Or condition
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if or_conditions is not None:
            pulumi.set(__self__, "or_conditions", or_conditions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgs']]]]:
        """
        Or condition
        """
        return pulumi.get(self, "or_conditions")

    @or_conditions.setter
    def or_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgs']]]]):
        pulumi.set(self, "or_conditions", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        operator: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict']]
        """
        Operator
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgs'] operator: Operator
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgs']]:
        """
        Operator
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgs']]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict(TypedDict):
        equal_to: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict']]
        """
        Equal to
        """
        greater_than: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict']]
        """
        Greater than
        """
        less_than: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict']]
        """
        Less than
        """
        pattern_match: NotRequired[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict']]
        """
        Pattern match
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorArgs:
    def __init__(__self__, *,
                 equal_to: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs']] = None,
                 greater_than: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs']] = None,
                 less_than: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs']] = None,
                 pattern_match: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs']] = None):
        """
        :param pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs'] equal_to: Equal to
        :param pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs'] greater_than: Greater than
        :param pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs'] less_than: Less than
        :param pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs'] pattern_match: Pattern match
        """
        if equal_to is not None:
            pulumi.set(__self__, "equal_to", equal_to)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if pattern_match is not None:
            pulumi.set(__self__, "pattern_match", pattern_match)

    @_builtins.property
    @pulumi.getter(name="equalTo")
    def equal_to(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs']]:
        """
        Equal to
        """
        return pulumi.get(self, "equal_to")

    @equal_to.setter
    def equal_to(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs']]):
        pulumi.set(self, "equal_to", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs']]:
        """
        Greater than
        """
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs']]):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs']]:
        """
        Less than
        """
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs']]):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter(name="patternMatch")
    def pattern_match(self) -> Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs']]:
        """
        Pattern match
        """
        return pulumi.get(self, "pattern_match")

    @pattern_match.setter
    def pattern_match(self, value: Optional[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs']]):
        pulumi.set(self, "pattern_match", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Negate
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict']]]]
        """
        Qualifier
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.bool] negate: Negate
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]] qualifiers: Qualifier
        :param pulumi.Input[_builtins.int] value: Value
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Negate
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict']]]]
        """
        Qualifier
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]] qualifiers: Qualifier
        :param pulumi.Input[_builtins.int] value: Value
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict']]]]
        """
        Qualifier
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]] qualifiers: Qualifier
        :param pulumi.Input[_builtins.int] value: Value
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Negate
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        Pattern
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict']]]]
        """
        Qualifier
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.bool] negate: Negate
        :param pulumi.Input[_builtins.str] pattern: Pattern
        :param pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]] qualifiers: Qualifier
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Negate
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)


if not MYPY:
    class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntiSpywareSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationDefaultArgsDict(TypedDict):
        ident_by_icmp6_type: NotRequired[pulumi.Input['ApplicationDefaultIdentByIcmp6TypeArgsDict']]
        """
        Ident by icmp6 type
        """
        ident_by_icmp_type: NotRequired[pulumi.Input['ApplicationDefaultIdentByIcmpTypeArgsDict']]
        """
        Ident by icmp type

        >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
        ident_by_ip_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ident by ip protocol

        >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Port

        >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
elif False:
    ApplicationDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationDefaultArgs:
    def __init__(__self__, *,
                 ident_by_icmp6_type: Optional[pulumi.Input['ApplicationDefaultIdentByIcmp6TypeArgs']] = None,
                 ident_by_icmp_type: Optional[pulumi.Input['ApplicationDefaultIdentByIcmpTypeArgs']] = None,
                 ident_by_ip_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ApplicationDefaultIdentByIcmp6TypeArgs'] ident_by_icmp6_type: Ident by icmp6 type
        :param pulumi.Input['ApplicationDefaultIdentByIcmpTypeArgs'] ident_by_icmp_type: Ident by icmp type
               
               >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        :param pulumi.Input[_builtins.str] ident_by_ip_protocol: Ident by ip protocol
               
               >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ports: Port
               
               >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
        if ident_by_icmp6_type is not None:
            pulumi.set(__self__, "ident_by_icmp6_type", ident_by_icmp6_type)
        if ident_by_icmp_type is not None:
            pulumi.set(__self__, "ident_by_icmp_type", ident_by_icmp_type)
        if ident_by_ip_protocol is not None:
            pulumi.set(__self__, "ident_by_ip_protocol", ident_by_ip_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter(name="identByIcmp6Type")
    def ident_by_icmp6_type(self) -> Optional[pulumi.Input['ApplicationDefaultIdentByIcmp6TypeArgs']]:
        """
        Ident by icmp6 type
        """
        return pulumi.get(self, "ident_by_icmp6_type")

    @ident_by_icmp6_type.setter
    def ident_by_icmp6_type(self, value: Optional[pulumi.Input['ApplicationDefaultIdentByIcmp6TypeArgs']]):
        pulumi.set(self, "ident_by_icmp6_type", value)

    @_builtins.property
    @pulumi.getter(name="identByIcmpType")
    def ident_by_icmp_type(self) -> Optional[pulumi.Input['ApplicationDefaultIdentByIcmpTypeArgs']]:
        """
        Ident by icmp type

        >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
        return pulumi.get(self, "ident_by_icmp_type")

    @ident_by_icmp_type.setter
    def ident_by_icmp_type(self, value: Optional[pulumi.Input['ApplicationDefaultIdentByIcmpTypeArgs']]):
        pulumi.set(self, "ident_by_icmp_type", value)

    @_builtins.property
    @pulumi.getter(name="identByIpProtocol")
    def ident_by_ip_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ident by ip protocol

        >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
        return pulumi.get(self, "ident_by_ip_protocol")

    @ident_by_ip_protocol.setter
    def ident_by_ip_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ident_by_ip_protocol", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Port

        >  **Note:** You must specify exactly one of `ident_by_icmp6_type`, `ident_by_icmp_type`, `ident_by_ip_protocol`, and `port`.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class ApplicationDefaultIdentByIcmp6TypeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type
        """
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Code
        """
elif False:
    ApplicationDefaultIdentByIcmp6TypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationDefaultIdentByIcmp6TypeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type
        :param pulumi.Input[_builtins.str] code: Code
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Code
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class ApplicationDefaultIdentByIcmpTypeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type
        """
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Code
        """
elif False:
    ApplicationDefaultIdentByIcmpTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationDefaultIdentByIcmpTypeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type
        :param pulumi.Input[_builtins.str] code: Code
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Code
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class ApplicationFilterTaggingArgsDict(TypedDict):
        no_tag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        No tag
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tag

        >  **Note:** You must specify exactly one of `no_tag` and `tag`.
        """
elif False:
    ApplicationFilterTaggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationFilterTaggingArgs:
    def __init__(__self__, *,
                 no_tag: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] no_tag: No tag
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Tag
               
               >  **Note:** You must specify exactly one of `no_tag` and `tag`.
        """
        if no_tag is not None:
            pulumi.set(__self__, "no_tag", no_tag)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="noTag")
    def no_tag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        No tag
        """
        return pulumi.get(self, "no_tag")

    @no_tag.setter
    def no_tag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_tag", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tag

        >  **Note:** You must specify exactly one of `no_tag` and `tag`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ApplicationSignatureArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        and_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionArgsDict']]]]
        """
        And condition
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment
        """
        order_free: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Order free
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope
        """
elif False:
    ApplicationSignatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 and_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionArgs']]]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 order_free: Optional[pulumi.Input[_builtins.bool]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Alphanumeric string [ 0-9a-zA-Z._-]
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionArgs']]] and_conditions: And condition
        :param pulumi.Input[_builtins.str] comment: Comment
        :param pulumi.Input[_builtins.bool] order_free: Order free
        :param pulumi.Input[_builtins.str] scope: Scope
        """
        pulumi.set(__self__, "name", name)
        if and_conditions is not None:
            pulumi.set(__self__, "and_conditions", and_conditions)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if order_free is not None:
            pulumi.set(__self__, "order_free", order_free)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionArgs']]]]:
        """
        And condition
        """
        return pulumi.get(self, "and_conditions")

    @and_conditions.setter
    def and_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionArgs']]]]):
        pulumi.set(self, "and_conditions", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="orderFree")
    def order_free(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Order free
        """
        return pulumi.get(self, "order_free")

    @order_free.setter
    def order_free(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order_free", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ApplicationSignatureAndConditionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        or_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionArgsDict']]]]
        """
        Or condition
        """
elif False:
    ApplicationSignatureAndConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 or_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Alphanumeric string [ 0-9a-zA-Z._-]
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionArgs']]] or_conditions: Or condition
        """
        pulumi.set(__self__, "name", name)
        if or_conditions is not None:
            pulumi.set(__self__, "or_conditions", or_conditions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionArgs']]]]:
        """
        Or condition
        """
        return pulumi.get(self, "or_conditions")

    @or_conditions.setter
    def or_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionArgs']]]]):
        pulumi.set(self, "or_conditions", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        operator: pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorArgsDict']
        """
        Operator
        """
elif False:
    ApplicationSignatureAndConditionOrConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operator: pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorArgs']):
        """
        :param pulumi.Input[_builtins.str] name: Alphanumeric string [ 0-9a-zA-Z._-]
        :param pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorArgs'] operator: Operator
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorArgs']:
        """
        Operator
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorArgs']):
        pulumi.set(self, "operator", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorArgsDict(TypedDict):
        equal_to: NotRequired[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorEqualToArgsDict']]
        """
        Equal to
        """
        greater_than: NotRequired[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgsDict']]
        """
        Greater than

        >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
        less_than: NotRequired[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanArgsDict']]
        """
        Less than

        >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
        pattern_match: NotRequired[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgsDict']]
        """
        Pattern match

        >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorArgs:
    def __init__(__self__, *,
                 equal_to: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorEqualToArgs']] = None,
                 greater_than: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgs']] = None,
                 less_than: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanArgs']] = None,
                 pattern_match: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgs']] = None):
        """
        :param pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorEqualToArgs'] equal_to: Equal to
        :param pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgs'] greater_than: Greater than
               
               >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        :param pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanArgs'] less_than: Less than
               
               >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        :param pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgs'] pattern_match: Pattern match
               
               >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
        if equal_to is not None:
            pulumi.set(__self__, "equal_to", equal_to)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if pattern_match is not None:
            pulumi.set(__self__, "pattern_match", pattern_match)

    @_builtins.property
    @pulumi.getter(name="equalTo")
    def equal_to(self) -> Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorEqualToArgs']]:
        """
        Equal to
        """
        return pulumi.get(self, "equal_to")

    @equal_to.setter
    def equal_to(self, value: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorEqualToArgs']]):
        pulumi.set(self, "equal_to", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgs']]:
        """
        Greater than

        >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgs']]):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanArgs']]:
        """
        Less than

        >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanArgs']]):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter(name="patternMatch")
    def pattern_match(self) -> Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgs']]:
        """
        Pattern match

        >  **Note:** You must specify exactly one of `equal_to`, `greater_than`, `less_than`, and `pattern_match`.
        """
        return pulumi.get(self, "pattern_match")

    @pattern_match.setter
    def pattern_match(self, value: Optional[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgs']]):
        pulumi.set(self, "pattern_match", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorEqualToArgsDict(TypedDict):
        context: pulumi.Input[_builtins.str]
        """
        Context
        """
        value: pulumi.Input[_builtins.str]
        """
        Value
        """
        mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        4-byte hex value
        """
        position: NotRequired[pulumi.Input[_builtins.str]]
        """
        Position
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorEqualToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorEqualToArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 mask: Optional[pulumi.Input[_builtins.str]] = None,
                 position: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.str] value: Value
        :param pulumi.Input[_builtins.str] mask: 4-byte hex value
        :param pulumi.Input[_builtins.str] position: Position
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "value", value)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter
    def context(self) -> pulumi.Input[_builtins.str]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        4-byte hex value
        """
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mask", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Position
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgsDict(TypedDict):
        context: pulumi.Input[_builtins.str]
        """
        Context
        """
        value: pulumi.Input[_builtins.int]
        """
        Value
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgsDict']]]]
        """
        Qualifier
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorGreaterThanArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int],
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.int] value: Value
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgs']]] qualifiers: Qualifier
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "value", value)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)

    @_builtins.property
    @pulumi.getter
    def context(self) -> pulumi.Input[_builtins.str]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        value: pulumi.Input[_builtins.str]
        """
        Value
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorGreaterThanQualifierArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Alphanumeric string [ 0-9a-zA-Z._-]
        :param pulumi.Input[_builtins.str] value: Value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorLessThanArgsDict(TypedDict):
        context: pulumi.Input[_builtins.str]
        """
        Context
        """
        value: pulumi.Input[_builtins.int]
        """
        Value
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgsDict']]]]
        """
        Qualifier
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorLessThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorLessThanArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int],
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.int] value: Value
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgs']]] qualifiers: Qualifier
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "value", value)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)

    @_builtins.property
    @pulumi.getter
    def context(self) -> pulumi.Input[_builtins.str]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        value: pulumi.Input[_builtins.str]
        """
        Value
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorLessThanQualifierArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Alphanumeric string [ 0-9a-zA-Z._-]
        :param pulumi.Input[_builtins.str] value: Value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgsDict(TypedDict):
        context: pulumi.Input[_builtins.str]
        """
        Context
        """
        pattern: pulumi.Input[_builtins.str]
        """
        Pattern
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgsDict']]]]
        """
        Qualifier
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorPatternMatchArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[_builtins.str],
                 pattern: pulumi.Input[_builtins.str],
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.str] pattern: Pattern
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgs']]] qualifiers: Qualifier
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "pattern", pattern)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)

    @_builtins.property
    @pulumi.getter
    def context(self) -> pulumi.Input[_builtins.str]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        """
        Pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]]:
        """
        Qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)


if not MYPY:
    class ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        value: pulumi.Input[_builtins.str]
        """
        Value
        """
elif False:
    ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSignatureAndConditionOrConditionOperatorPatternMatchQualifierArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Alphanumeric string [ 0-9a-zA-Z._-]
        :param pulumi.Input[_builtins.str] value: Value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Alphanumeric string [ 0-9a-zA-Z._-]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AuthenticationProfileLockoutArgsDict(TypedDict):
        failed_attempts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lockout object - failed_attempts of authentication profile
        """
        lockout_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lockout object - lockout-time of authentication profile
        """
elif False:
    AuthenticationProfileLockoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileLockoutArgs:
    def __init__(__self__, *,
                 failed_attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 lockout_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] failed_attempts: Lockout object - failed_attempts of authentication profile
        :param pulumi.Input[_builtins.int] lockout_time: Lockout object - lockout-time of authentication profile
        """
        if failed_attempts is not None:
            pulumi.set(__self__, "failed_attempts", failed_attempts)
        if lockout_time is not None:
            pulumi.set(__self__, "lockout_time", lockout_time)

    @_builtins.property
    @pulumi.getter(name="failedAttempts")
    def failed_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lockout object - failed_attempts of authentication profile
        """
        return pulumi.get(self, "failed_attempts")

    @failed_attempts.setter
    def failed_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failed_attempts", value)

    @_builtins.property
    @pulumi.getter(name="lockoutTime")
    def lockout_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lockout object - lockout-time of authentication profile
        """
        return pulumi.get(self, "lockout_time")

    @lockout_time.setter
    def lockout_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lockout_time", value)


if not MYPY:
    class AuthenticationProfileMethodArgsDict(TypedDict):
        cloud: NotRequired[pulumi.Input['AuthenticationProfileMethodCloudArgsDict']]
        """
        Cloud
        """
        kerberos: NotRequired[pulumi.Input['AuthenticationProfileMethodKerberosArgsDict']]
        """
        Kerberos

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        ldap: NotRequired[pulumi.Input['AuthenticationProfileMethodLdapArgsDict']]
        """
        Ldap

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        local_database: NotRequired[pulumi.Input['AuthenticationProfileMethodLocalDatabaseArgsDict']]
        """
        Local database

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        radius: NotRequired[pulumi.Input['AuthenticationProfileMethodRadiusArgsDict']]
        """
        Radius

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        saml_idp: NotRequired[pulumi.Input['AuthenticationProfileMethodSamlIdpArgsDict']]
        """
        Saml idp

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        tacplus: NotRequired[pulumi.Input['AuthenticationProfileMethodTacplusArgsDict']]
        """
        Tacplus

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
elif False:
    AuthenticationProfileMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodArgs:
    def __init__(__self__, *,
                 cloud: Optional[pulumi.Input['AuthenticationProfileMethodCloudArgs']] = None,
                 kerberos: Optional[pulumi.Input['AuthenticationProfileMethodKerberosArgs']] = None,
                 ldap: Optional[pulumi.Input['AuthenticationProfileMethodLdapArgs']] = None,
                 local_database: Optional[pulumi.Input['AuthenticationProfileMethodLocalDatabaseArgs']] = None,
                 radius: Optional[pulumi.Input['AuthenticationProfileMethodRadiusArgs']] = None,
                 saml_idp: Optional[pulumi.Input['AuthenticationProfileMethodSamlIdpArgs']] = None,
                 tacplus: Optional[pulumi.Input['AuthenticationProfileMethodTacplusArgs']] = None):
        """
        :param pulumi.Input['AuthenticationProfileMethodCloudArgs'] cloud: Cloud
        :param pulumi.Input['AuthenticationProfileMethodKerberosArgs'] kerberos: Kerberos
               
               >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        :param pulumi.Input['AuthenticationProfileMethodLdapArgs'] ldap: Ldap
               
               >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        :param pulumi.Input['AuthenticationProfileMethodLocalDatabaseArgs'] local_database: Local database
               
               >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        :param pulumi.Input['AuthenticationProfileMethodRadiusArgs'] radius: Radius
               
               >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        :param pulumi.Input['AuthenticationProfileMethodSamlIdpArgs'] saml_idp: Saml idp
               
               >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        :param pulumi.Input['AuthenticationProfileMethodTacplusArgs'] tacplus: Tacplus
               
               >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if kerberos is not None:
            pulumi.set(__self__, "kerberos", kerberos)
        if ldap is not None:
            pulumi.set(__self__, "ldap", ldap)
        if local_database is not None:
            pulumi.set(__self__, "local_database", local_database)
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if saml_idp is not None:
            pulumi.set(__self__, "saml_idp", saml_idp)
        if tacplus is not None:
            pulumi.set(__self__, "tacplus", tacplus)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[pulumi.Input['AuthenticationProfileMethodCloudArgs']]:
        """
        Cloud
        """
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[pulumi.Input['AuthenticationProfileMethodCloudArgs']]):
        pulumi.set(self, "cloud", value)

    @_builtins.property
    @pulumi.getter
    def kerberos(self) -> Optional[pulumi.Input['AuthenticationProfileMethodKerberosArgs']]:
        """
        Kerberos

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        return pulumi.get(self, "kerberos")

    @kerberos.setter
    def kerberos(self, value: Optional[pulumi.Input['AuthenticationProfileMethodKerberosArgs']]):
        pulumi.set(self, "kerberos", value)

    @_builtins.property
    @pulumi.getter
    def ldap(self) -> Optional[pulumi.Input['AuthenticationProfileMethodLdapArgs']]:
        """
        Ldap

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        return pulumi.get(self, "ldap")

    @ldap.setter
    def ldap(self, value: Optional[pulumi.Input['AuthenticationProfileMethodLdapArgs']]):
        pulumi.set(self, "ldap", value)

    @_builtins.property
    @pulumi.getter(name="localDatabase")
    def local_database(self) -> Optional[pulumi.Input['AuthenticationProfileMethodLocalDatabaseArgs']]:
        """
        Local database

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        return pulumi.get(self, "local_database")

    @local_database.setter
    def local_database(self, value: Optional[pulumi.Input['AuthenticationProfileMethodLocalDatabaseArgs']]):
        pulumi.set(self, "local_database", value)

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional[pulumi.Input['AuthenticationProfileMethodRadiusArgs']]:
        """
        Radius

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        return pulumi.get(self, "radius")

    @radius.setter
    def radius(self, value: Optional[pulumi.Input['AuthenticationProfileMethodRadiusArgs']]):
        pulumi.set(self, "radius", value)

    @_builtins.property
    @pulumi.getter(name="samlIdp")
    def saml_idp(self) -> Optional[pulumi.Input['AuthenticationProfileMethodSamlIdpArgs']]:
        """
        Saml idp

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        return pulumi.get(self, "saml_idp")

    @saml_idp.setter
    def saml_idp(self, value: Optional[pulumi.Input['AuthenticationProfileMethodSamlIdpArgs']]):
        pulumi.set(self, "saml_idp", value)

    @_builtins.property
    @pulumi.getter
    def tacplus(self) -> Optional[pulumi.Input['AuthenticationProfileMethodTacplusArgs']]:
        """
        Tacplus

        >  **Note:** You must specify exactly one of `cloud`, `kerberos`, `ldap`, `local_database`, `radius`, `saml_idp`, and `tacplus`.
        """
        return pulumi.get(self, "tacplus")

    @tacplus.setter
    def tacplus(self, value: Optional[pulumi.Input['AuthenticationProfileMethodTacplusArgs']]):
        pulumi.set(self, "tacplus", value)


if not MYPY:
    class AuthenticationProfileMethodCloudArgsDict(TypedDict):
        profile_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenant profile name
        """
elif False:
    AuthenticationProfileMethodCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodCloudArgs:
    def __init__(__self__, *,
                 profile_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile_name: The tenant profile name
        """
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenant profile name
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_name", value)


if not MYPY:
    class AuthenticationProfileMethodKerberosArgsDict(TypedDict):
        realm: NotRequired[pulumi.Input[_builtins.str]]
        """
        method kerberos object realm of authentication profile
        """
        server_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        method kerberos object server profile of authentication profile
        """
elif False:
    AuthenticationProfileMethodKerberosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodKerberosArgs:
    def __init__(__self__, *,
                 realm: Optional[pulumi.Input[_builtins.str]] = None,
                 server_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] realm: method kerberos object realm of authentication profile
        :param pulumi.Input[_builtins.str] server_profile: method kerberos object server profile of authentication profile
        """
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if server_profile is not None:
            pulumi.set(__self__, "server_profile", server_profile)

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        method kerberos object realm of authentication profile
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realm", value)

    @_builtins.property
    @pulumi.getter(name="serverProfile")
    def server_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        method kerberos object server profile of authentication profile
        """
        return pulumi.get(self, "server_profile")

    @server_profile.setter
    def server_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_profile", value)


if not MYPY:
    class AuthenticationProfileMethodLdapArgsDict(TypedDict):
        login_attribute: NotRequired[pulumi.Input[_builtins.str]]
        """
        Login attribute
        """
        passwd_exp_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Passwd exp days
        """
        server_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Server profile
        """
elif False:
    AuthenticationProfileMethodLdapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodLdapArgs:
    def __init__(__self__, *,
                 login_attribute: Optional[pulumi.Input[_builtins.str]] = None,
                 passwd_exp_days: Optional[pulumi.Input[_builtins.int]] = None,
                 server_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] login_attribute: Login attribute
        :param pulumi.Input[_builtins.int] passwd_exp_days: Passwd exp days
        :param pulumi.Input[_builtins.str] server_profile: Server profile
        """
        if login_attribute is not None:
            pulumi.set(__self__, "login_attribute", login_attribute)
        if passwd_exp_days is not None:
            pulumi.set(__self__, "passwd_exp_days", passwd_exp_days)
        if server_profile is not None:
            pulumi.set(__self__, "server_profile", server_profile)

    @_builtins.property
    @pulumi.getter(name="loginAttribute")
    def login_attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Login attribute
        """
        return pulumi.get(self, "login_attribute")

    @login_attribute.setter
    def login_attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_attribute", value)

    @_builtins.property
    @pulumi.getter(name="passwdExpDays")
    def passwd_exp_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Passwd exp days
        """
        return pulumi.get(self, "passwd_exp_days")

    @passwd_exp_days.setter
    def passwd_exp_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "passwd_exp_days", value)

    @_builtins.property
    @pulumi.getter(name="serverProfile")
    def server_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Server profile
        """
        return pulumi.get(self, "server_profile")

    @server_profile.setter
    def server_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_profile", value)


if not MYPY:
    class AuthenticationProfileMethodLocalDatabaseArgsDict(TypedDict):
        pass
elif False:
    AuthenticationProfileMethodLocalDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodLocalDatabaseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AuthenticationProfileMethodRadiusArgsDict(TypedDict):
        checkgroup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        method radius object check group of authentication profile
        """
        server_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        method radius object server profile of authentication profile
        """
elif False:
    AuthenticationProfileMethodRadiusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodRadiusArgs:
    def __init__(__self__, *,
                 checkgroup: Optional[pulumi.Input[_builtins.bool]] = None,
                 server_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] checkgroup: method radius object check group of authentication profile
        :param pulumi.Input[_builtins.str] server_profile: method radius object server profile of authentication profile
        """
        if checkgroup is not None:
            pulumi.set(__self__, "checkgroup", checkgroup)
        if server_profile is not None:
            pulumi.set(__self__, "server_profile", server_profile)

    @_builtins.property
    @pulumi.getter
    def checkgroup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        method radius object check group of authentication profile
        """
        return pulumi.get(self, "checkgroup")

    @checkgroup.setter
    def checkgroup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "checkgroup", value)

    @_builtins.property
    @pulumi.getter(name="serverProfile")
    def server_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        method radius object server profile of authentication profile
        """
        return pulumi.get(self, "server_profile")

    @server_profile.setter
    def server_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_profile", value)


if not MYPY:
    class AuthenticationProfileMethodSamlIdpArgsDict(TypedDict):
        attribute_name_usergroup: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute name usergroup
        """
        attribute_name_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute name username
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        method object saml idp certificate profile of authentication profile
        """
        enable_single_logout: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable single logout
        """
        request_signing_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Request signing certificate
        """
        server_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        method object saml idp server profile of authentication profile
        """
elif False:
    AuthenticationProfileMethodSamlIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodSamlIdpArgs:
    def __init__(__self__, *,
                 attribute_name_usergroup: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_name_username: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_single_logout: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_signing_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 server_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_name_usergroup: Attribute name usergroup
        :param pulumi.Input[_builtins.str] attribute_name_username: Attribute name username
        :param pulumi.Input[_builtins.str] certificate_profile: method object saml idp certificate profile of authentication profile
        :param pulumi.Input[_builtins.bool] enable_single_logout: Enable single logout
        :param pulumi.Input[_builtins.str] request_signing_certificate: Request signing certificate
        :param pulumi.Input[_builtins.str] server_profile: method object saml idp server profile of authentication profile
        """
        if attribute_name_usergroup is not None:
            pulumi.set(__self__, "attribute_name_usergroup", attribute_name_usergroup)
        if attribute_name_username is not None:
            pulumi.set(__self__, "attribute_name_username", attribute_name_username)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if enable_single_logout is not None:
            pulumi.set(__self__, "enable_single_logout", enable_single_logout)
        if request_signing_certificate is not None:
            pulumi.set(__self__, "request_signing_certificate", request_signing_certificate)
        if server_profile is not None:
            pulumi.set(__self__, "server_profile", server_profile)

    @_builtins.property
    @pulumi.getter(name="attributeNameUsergroup")
    def attribute_name_usergroup(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute name usergroup
        """
        return pulumi.get(self, "attribute_name_usergroup")

    @attribute_name_usergroup.setter
    def attribute_name_usergroup(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name_usergroup", value)

    @_builtins.property
    @pulumi.getter(name="attributeNameUsername")
    def attribute_name_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute name username
        """
        return pulumi.get(self, "attribute_name_username")

    @attribute_name_username.setter
    def attribute_name_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name_username", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        method object saml idp certificate profile of authentication profile
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter(name="enableSingleLogout")
    def enable_single_logout(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable single logout
        """
        return pulumi.get(self, "enable_single_logout")

    @enable_single_logout.setter
    def enable_single_logout(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_single_logout", value)

    @_builtins.property
    @pulumi.getter(name="requestSigningCertificate")
    def request_signing_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Request signing certificate
        """
        return pulumi.get(self, "request_signing_certificate")

    @request_signing_certificate.setter
    def request_signing_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_signing_certificate", value)

    @_builtins.property
    @pulumi.getter(name="serverProfile")
    def server_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        method object saml idp server profile of authentication profile
        """
        return pulumi.get(self, "server_profile")

    @server_profile.setter
    def server_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_profile", value)


if not MYPY:
    class AuthenticationProfileMethodTacplusArgsDict(TypedDict):
        checkgroup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        method tacplus object check group of authentication profile
        """
        server_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        method tacplus object check group of authentication profile
        """
elif False:
    AuthenticationProfileMethodTacplusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMethodTacplusArgs:
    def __init__(__self__, *,
                 checkgroup: Optional[pulumi.Input[_builtins.bool]] = None,
                 server_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] checkgroup: method tacplus object check group of authentication profile
        :param pulumi.Input[_builtins.str] server_profile: method tacplus object check group of authentication profile
        """
        if checkgroup is not None:
            pulumi.set(__self__, "checkgroup", checkgroup)
        if server_profile is not None:
            pulumi.set(__self__, "server_profile", server_profile)

    @_builtins.property
    @pulumi.getter
    def checkgroup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        method tacplus object check group of authentication profile
        """
        return pulumi.get(self, "checkgroup")

    @checkgroup.setter
    def checkgroup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "checkgroup", value)

    @_builtins.property
    @pulumi.getter(name="serverProfile")
    def server_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        method tacplus object check group of authentication profile
        """
        return pulumi.get(self, "server_profile")

    @server_profile.setter
    def server_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_profile", value)


if not MYPY:
    class AuthenticationProfileMultiFactorAuthArgsDict(TypedDict):
        factors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Factors
        """
        mfa_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mfa enable
        """
elif False:
    AuthenticationProfileMultiFactorAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileMultiFactorAuthArgs:
    def __init__(__self__, *,
                 factors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 mfa_enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] factors: Factors
        :param pulumi.Input[_builtins.bool] mfa_enable: Mfa enable
        """
        if factors is not None:
            pulumi.set(__self__, "factors", factors)
        if mfa_enable is not None:
            pulumi.set(__self__, "mfa_enable", mfa_enable)

    @_builtins.property
    @pulumi.getter
    def factors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Factors
        """
        return pulumi.get(self, "factors")

    @factors.setter
    def factors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "factors", value)

    @_builtins.property
    @pulumi.getter(name="mfaEnable")
    def mfa_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mfa enable
        """
        return pulumi.get(self, "mfa_enable")

    @mfa_enable.setter
    def mfa_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mfa_enable", value)


if not MYPY:
    class AuthenticationProfileSingleSignOnArgsDict(TypedDict):
        kerberos_keytab: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kerberos keytab
        """
        realm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Realm
        """
elif False:
    AuthenticationProfileSingleSignOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationProfileSingleSignOnArgs:
    def __init__(__self__, *,
                 kerberos_keytab: Optional[pulumi.Input[_builtins.str]] = None,
                 realm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kerberos_keytab: Kerberos keytab
        :param pulumi.Input[_builtins.str] realm: Realm
        """
        if kerberos_keytab is not None:
            pulumi.set(__self__, "kerberos_keytab", kerberos_keytab)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @_builtins.property
    @pulumi.getter(name="kerberosKeytab")
    def kerberos_keytab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kerberos keytab
        """
        return pulumi.get(self, "kerberos_keytab")

    @kerberos_keytab.setter
    def kerberos_keytab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kerberos_keytab", value)

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Realm
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realm", value)


if not MYPY:
    class AuthenticationSettingAuthenticationArgsDict(TypedDict):
        accounting_server_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Accounting server profile
        """
        authentication_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication profile
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate profile
        """
elif False:
    AuthenticationSettingAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationSettingAuthenticationArgs:
    def __init__(__self__, *,
                 accounting_server_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 authentication_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] accounting_server_profile: Accounting server profile
        :param pulumi.Input[_builtins.str] authentication_profile: Authentication profile
        :param pulumi.Input[_builtins.str] certificate_profile: Certificate profile
        """
        if accounting_server_profile is not None:
            pulumi.set(__self__, "accounting_server_profile", accounting_server_profile)
        if authentication_profile is not None:
            pulumi.set(__self__, "authentication_profile", authentication_profile)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)

    @_builtins.property
    @pulumi.getter(name="accountingServerProfile")
    def accounting_server_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Accounting server profile
        """
        return pulumi.get(self, "accounting_server_profile")

    @accounting_server_profile.setter
    def accounting_server_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "accounting_server_profile", value)

    @_builtins.property
    @pulumi.getter(name="authenticationProfile")
    def authentication_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication profile
        """
        return pulumi.get(self, "authentication_profile")

    @authentication_profile.setter
    def authentication_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_profile", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate profile
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)


if not MYPY:
    class AutoVpnClusterBranchArgsDict(TypedDict):
        bgp_redistribution_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP redistribution profile
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchInterfaceArgsDict']]]]
        """
        Interfaces
        """
        logical_router: NotRequired[pulumi.Input[_builtins.str]]
        """
        Router
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Branch firewall serial number
        """
        private_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceArgsDict']]]]
        """
        Private interfaces
        """
        site: NotRequired[pulumi.Input[_builtins.str]]
        """
        Site name
        """
elif False:
    AutoVpnClusterBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchArgs:
    def __init__(__self__, *,
                 bgp_redistribution_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchInterfaceArgs']]]] = None,
                 logical_router: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceArgs']]]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bgp_redistribution_profile: BGP redistribution profile
        :param pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchInterfaceArgs']]] interfaces: Interfaces
        :param pulumi.Input[_builtins.str] logical_router: Router
        :param pulumi.Input[_builtins.str] name: Branch firewall serial number
        :param pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceArgs']]] private_interfaces: Private interfaces
        :param pulumi.Input[_builtins.str] site: Site name
        """
        if bgp_redistribution_profile is not None:
            pulumi.set(__self__, "bgp_redistribution_profile", bgp_redistribution_profile)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if logical_router is not None:
            pulumi.set(__self__, "logical_router", logical_router)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_interfaces is not None:
            pulumi.set(__self__, "private_interfaces", private_interfaces)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @_builtins.property
    @pulumi.getter(name="bgpRedistributionProfile")
    def bgp_redistribution_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP redistribution profile
        """
        return pulumi.get(self, "bgp_redistribution_profile")

    @bgp_redistribution_profile.setter
    def bgp_redistribution_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bgp_redistribution_profile", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchInterfaceArgs']]]]:
        """
        Interfaces
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter(name="logicalRouter")
    def logical_router(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Router
        """
        return pulumi.get(self, "logical_router")

    @logical_router.setter
    def logical_router(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_router", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Branch firewall serial number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateInterfaces")
    def private_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceArgs']]]]:
        """
        Private interfaces
        """
        return pulumi.get(self, "private_interfaces")

    @private_interfaces.setter
    def private_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceArgs']]]]):
        pulumi.set(self, "private_interfaces", value)

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Site name
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "site", value)


if not MYPY:
    class AutoVpnClusterBranchInterfaceArgsDict(TypedDict):
        dhcp_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        DHCP IP
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ethernet interface
        """
        sdwan_link_settings: NotRequired[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgsDict']]
        """
        Sdwan link settings
        """
elif False:
    AutoVpnClusterBranchInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchInterfaceArgs:
    def __init__(__self__, *,
                 dhcp_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_link_settings: Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] dhcp_ip: DHCP IP
        :param pulumi.Input[_builtins.str] name: Ethernet interface
        :param pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgs'] sdwan_link_settings: Sdwan link settings
        """
        if dhcp_ip is not None:
            pulumi.set(__self__, "dhcp_ip", dhcp_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sdwan_link_settings is not None:
            pulumi.set(__self__, "sdwan_link_settings", sdwan_link_settings)

    @_builtins.property
    @pulumi.getter(name="dhcpIp")
    def dhcp_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DHCP IP
        """
        return pulumi.get(self, "dhcp_ip")

    @dhcp_ip.setter
    def dhcp_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dhcp_ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ethernet interface
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sdwanLinkSettings")
    def sdwan_link_settings(self) -> Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgs']]:
        """
        Sdwan link settings
        """
        return pulumi.get(self, "sdwan_link_settings")

    @sdwan_link_settings.setter
    def sdwan_link_settings(self, value: Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgs']]):
        pulumi.set(self, "sdwan_link_settings", value)


if not MYPY:
    class AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgsDict(TypedDict):
        sdwan_gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop gateway
        """
        sdwan_interface_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        SD-WAN interface profile
        """
        upstream_nat: NotRequired[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgsDict']]
        """
        Upstream nat
        """
elif False:
    AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchInterfaceSdwanLinkSettingsArgs:
    def __init__(__self__, *,
                 sdwan_gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_interface_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_nat: Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] sdwan_gateway: Next hop gateway
        :param pulumi.Input[_builtins.str] sdwan_interface_profile: SD-WAN interface profile
        :param pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgs'] upstream_nat: Upstream nat
        """
        if sdwan_gateway is not None:
            pulumi.set(__self__, "sdwan_gateway", sdwan_gateway)
        if sdwan_interface_profile is not None:
            pulumi.set(__self__, "sdwan_interface_profile", sdwan_interface_profile)
        if upstream_nat is not None:
            pulumi.set(__self__, "upstream_nat", upstream_nat)

    @_builtins.property
    @pulumi.getter(name="sdwanGateway")
    def sdwan_gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop gateway
        """
        return pulumi.get(self, "sdwan_gateway")

    @sdwan_gateway.setter
    def sdwan_gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_gateway", value)

    @_builtins.property
    @pulumi.getter(name="sdwanInterfaceProfile")
    def sdwan_interface_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SD-WAN interface profile
        """
        return pulumi.get(self, "sdwan_interface_profile")

    @sdwan_interface_profile.setter
    def sdwan_interface_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_interface_profile", value)

    @_builtins.property
    @pulumi.getter(name="upstreamNat")
    def upstream_nat(self) -> Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgs']]:
        """
        Upstream nat
        """
        return pulumi.get(self, "upstream_nat")

    @upstream_nat.setter
    def upstream_nat(self, value: Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgs']]):
        pulumi.set(self, "upstream_nat", value)


if not MYPY:
    class AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Upstream NAT?
        """
        static_ip: NotRequired[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict']]
        """
        Static ip
        """
elif False:
    AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 static_ip: Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Upstream NAT?
        :param pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs'] static_ip: Static ip
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Upstream NAT?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]:
        """
        Static ip
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input['AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]):
        pulumi.set(self, "static_ip", value)


if not MYPY:
    class AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        FQDN
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
elif False:
    AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: FQDN
        :param pulumi.Input[_builtins.str] ip_address: IP address
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        FQDN
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class AutoVpnClusterBranchPrivateInterfaceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ethernet interface
        """
        sdwan_link_settings: NotRequired[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgsDict']]
        """
        Sdwan link settings
        """
elif False:
    AutoVpnClusterBranchPrivateInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchPrivateInterfaceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_link_settings: Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Ethernet interface
        :param pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgs'] sdwan_link_settings: Sdwan link settings
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sdwan_link_settings is not None:
            pulumi.set(__self__, "sdwan_link_settings", sdwan_link_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ethernet interface
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sdwanLinkSettings")
    def sdwan_link_settings(self) -> Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgs']]:
        """
        Sdwan link settings
        """
        return pulumi.get(self, "sdwan_link_settings")

    @sdwan_link_settings.setter
    def sdwan_link_settings(self, value: Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgs']]):
        pulumi.set(self, "sdwan_link_settings", value)


if not MYPY:
    class AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgsDict(TypedDict):
        sdwan_gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop gateway
        """
        sdwan_interface_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        SD-WAN interface profile
        """
        upstream_nat: NotRequired[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict']]
        """
        Upstream nat
        """
elif False:
    AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsArgs:
    def __init__(__self__, *,
                 sdwan_gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_interface_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_nat: Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] sdwan_gateway: Next hop gateway
        :param pulumi.Input[_builtins.str] sdwan_interface_profile: SD-WAN interface profile
        :param pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs'] upstream_nat: Upstream nat
        """
        if sdwan_gateway is not None:
            pulumi.set(__self__, "sdwan_gateway", sdwan_gateway)
        if sdwan_interface_profile is not None:
            pulumi.set(__self__, "sdwan_interface_profile", sdwan_interface_profile)
        if upstream_nat is not None:
            pulumi.set(__self__, "upstream_nat", upstream_nat)

    @_builtins.property
    @pulumi.getter(name="sdwanGateway")
    def sdwan_gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop gateway
        """
        return pulumi.get(self, "sdwan_gateway")

    @sdwan_gateway.setter
    def sdwan_gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_gateway", value)

    @_builtins.property
    @pulumi.getter(name="sdwanInterfaceProfile")
    def sdwan_interface_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SD-WAN interface profile
        """
        return pulumi.get(self, "sdwan_interface_profile")

    @sdwan_interface_profile.setter
    def sdwan_interface_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_interface_profile", value)

    @_builtins.property
    @pulumi.getter(name="upstreamNat")
    def upstream_nat(self) -> Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs']]:
        """
        Upstream nat
        """
        return pulumi.get(self, "upstream_nat")

    @upstream_nat.setter
    def upstream_nat(self, value: Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs']]):
        pulumi.set(self, "upstream_nat", value)


if not MYPY:
    class AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Upstream NAT?
        """
        static_ip: NotRequired[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict']]
        """
        Static ip
        """
elif False:
    AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 static_ip: Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Upstream NAT?
        :param pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs'] static_ip: Static ip
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Upstream NAT?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]:
        """
        Static ip
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input['AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]):
        pulumi.set(self, "static_ip", value)


if not MYPY:
    class AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        FQDN
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
elif False:
    AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterBranchPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: FQDN
        :param pulumi.Input[_builtins.str] ip_address: IP address
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        FQDN
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class AutoVpnClusterGatewayArgsDict(TypedDict):
        allow_dia_vpn_failover: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow DIA to VPN failover on branch device for the hub?
        """
        bgp_redistribution_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP redistribution file
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayInterfaceArgsDict']]]]
        """
        Interfaces
        """
        logical_router: NotRequired[pulumi.Input[_builtins.str]]
        """
        Router
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hub firewall serial number
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        Priority
        """
        private_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceArgsDict']]]]
        """
        Private interfaces
        """
        site: NotRequired[pulumi.Input[_builtins.str]]
        """
        Site name
        """
elif False:
    AutoVpnClusterGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayArgs:
    def __init__(__self__, *,
                 allow_dia_vpn_failover: Optional[pulumi.Input[_builtins.bool]] = None,
                 bgp_redistribution_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayInterfaceArgs']]]] = None,
                 logical_router: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None,
                 private_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceArgs']]]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_dia_vpn_failover: Allow DIA to VPN failover on branch device for the hub?
        :param pulumi.Input[_builtins.str] bgp_redistribution_profile: BGP redistribution file
        :param pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayInterfaceArgs']]] interfaces: Interfaces
        :param pulumi.Input[_builtins.str] logical_router: Router
        :param pulumi.Input[_builtins.str] name: Hub firewall serial number
        :param pulumi.Input[_builtins.str] priority: Priority
        :param pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceArgs']]] private_interfaces: Private interfaces
        :param pulumi.Input[_builtins.str] site: Site name
        """
        if allow_dia_vpn_failover is not None:
            pulumi.set(__self__, "allow_dia_vpn_failover", allow_dia_vpn_failover)
        if bgp_redistribution_profile is not None:
            pulumi.set(__self__, "bgp_redistribution_profile", bgp_redistribution_profile)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if logical_router is not None:
            pulumi.set(__self__, "logical_router", logical_router)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if private_interfaces is not None:
            pulumi.set(__self__, "private_interfaces", private_interfaces)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @_builtins.property
    @pulumi.getter(name="allowDiaVpnFailover")
    def allow_dia_vpn_failover(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow DIA to VPN failover on branch device for the hub?
        """
        return pulumi.get(self, "allow_dia_vpn_failover")

    @allow_dia_vpn_failover.setter
    def allow_dia_vpn_failover(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_dia_vpn_failover", value)

    @_builtins.property
    @pulumi.getter(name="bgpRedistributionProfile")
    def bgp_redistribution_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP redistribution file
        """
        return pulumi.get(self, "bgp_redistribution_profile")

    @bgp_redistribution_profile.setter
    def bgp_redistribution_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bgp_redistribution_profile", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayInterfaceArgs']]]]:
        """
        Interfaces
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter(name="logicalRouter")
    def logical_router(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Router
        """
        return pulumi.get(self, "logical_router")

    @logical_router.setter
    def logical_router(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_router", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hub firewall serial number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="privateInterfaces")
    def private_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceArgs']]]]:
        """
        Private interfaces
        """
        return pulumi.get(self, "private_interfaces")

    @private_interfaces.setter
    def private_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceArgs']]]]):
        pulumi.set(self, "private_interfaces", value)

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Site name
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "site", value)


if not MYPY:
    class AutoVpnClusterGatewayInterfaceArgsDict(TypedDict):
        dhcp_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        DHCP IP
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ethernet interface
        """
        sdwan_link_settings: NotRequired[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgsDict']]
        """
        Sdwan link settings
        """
elif False:
    AutoVpnClusterGatewayInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayInterfaceArgs:
    def __init__(__self__, *,
                 dhcp_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_link_settings: Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] dhcp_ip: DHCP IP
        :param pulumi.Input[_builtins.str] name: Ethernet interface
        :param pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgs'] sdwan_link_settings: Sdwan link settings
        """
        if dhcp_ip is not None:
            pulumi.set(__self__, "dhcp_ip", dhcp_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sdwan_link_settings is not None:
            pulumi.set(__self__, "sdwan_link_settings", sdwan_link_settings)

    @_builtins.property
    @pulumi.getter(name="dhcpIp")
    def dhcp_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DHCP IP
        """
        return pulumi.get(self, "dhcp_ip")

    @dhcp_ip.setter
    def dhcp_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dhcp_ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ethernet interface
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sdwanLinkSettings")
    def sdwan_link_settings(self) -> Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgs']]:
        """
        Sdwan link settings
        """
        return pulumi.get(self, "sdwan_link_settings")

    @sdwan_link_settings.setter
    def sdwan_link_settings(self, value: Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgs']]):
        pulumi.set(self, "sdwan_link_settings", value)


if not MYPY:
    class AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgsDict(TypedDict):
        sdwan_gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop gateway
        """
        sdwan_interface_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        SD-WAN interface profile
        """
        upstream_nat: NotRequired[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgsDict']]
        """
        Upstream nat
        """
elif False:
    AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayInterfaceSdwanLinkSettingsArgs:
    def __init__(__self__, *,
                 sdwan_gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_interface_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_nat: Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] sdwan_gateway: Next hop gateway
        :param pulumi.Input[_builtins.str] sdwan_interface_profile: SD-WAN interface profile
        :param pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgs'] upstream_nat: Upstream nat
        """
        if sdwan_gateway is not None:
            pulumi.set(__self__, "sdwan_gateway", sdwan_gateway)
        if sdwan_interface_profile is not None:
            pulumi.set(__self__, "sdwan_interface_profile", sdwan_interface_profile)
        if upstream_nat is not None:
            pulumi.set(__self__, "upstream_nat", upstream_nat)

    @_builtins.property
    @pulumi.getter(name="sdwanGateway")
    def sdwan_gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop gateway
        """
        return pulumi.get(self, "sdwan_gateway")

    @sdwan_gateway.setter
    def sdwan_gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_gateway", value)

    @_builtins.property
    @pulumi.getter(name="sdwanInterfaceProfile")
    def sdwan_interface_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SD-WAN interface profile
        """
        return pulumi.get(self, "sdwan_interface_profile")

    @sdwan_interface_profile.setter
    def sdwan_interface_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_interface_profile", value)

    @_builtins.property
    @pulumi.getter(name="upstreamNat")
    def upstream_nat(self) -> Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgs']]:
        """
        Upstream nat
        """
        return pulumi.get(self, "upstream_nat")

    @upstream_nat.setter
    def upstream_nat(self, value: Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgs']]):
        pulumi.set(self, "upstream_nat", value)


if not MYPY:
    class AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Upstream NAT?
        """
        static_ip: NotRequired[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict']]
        """
        Static ip
        """
elif False:
    AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 static_ip: Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Upstream NAT?
        :param pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs'] static_ip: Static ip
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Upstream NAT?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]:
        """
        Static ip
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input['AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]):
        pulumi.set(self, "static_ip", value)


if not MYPY:
    class AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        FQDN
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
elif False:
    AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: FQDN
        :param pulumi.Input[_builtins.str] ip_address: IP address
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        FQDN
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class AutoVpnClusterGatewayPrivateInterfaceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ethernet interface
        """
        sdwan_link_settings: NotRequired[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgsDict']]
        """
        Sdwan link settings
        """
elif False:
    AutoVpnClusterGatewayPrivateInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayPrivateInterfaceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_link_settings: Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Ethernet interface
        :param pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgs'] sdwan_link_settings: Sdwan link settings
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sdwan_link_settings is not None:
            pulumi.set(__self__, "sdwan_link_settings", sdwan_link_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ethernet interface
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sdwanLinkSettings")
    def sdwan_link_settings(self) -> Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgs']]:
        """
        Sdwan link settings
        """
        return pulumi.get(self, "sdwan_link_settings")

    @sdwan_link_settings.setter
    def sdwan_link_settings(self, value: Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgs']]):
        pulumi.set(self, "sdwan_link_settings", value)


if not MYPY:
    class AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgsDict(TypedDict):
        sdwan_gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop gateway
        """
        sdwan_interface_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        SD-WAN interface profile
        """
        upstream_nat: NotRequired[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict']]
        """
        Upstream nat
        """
elif False:
    AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsArgs:
    def __init__(__self__, *,
                 sdwan_gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 sdwan_interface_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_nat: Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] sdwan_gateway: Next hop gateway
        :param pulumi.Input[_builtins.str] sdwan_interface_profile: SD-WAN interface profile
        :param pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs'] upstream_nat: Upstream nat
        """
        if sdwan_gateway is not None:
            pulumi.set(__self__, "sdwan_gateway", sdwan_gateway)
        if sdwan_interface_profile is not None:
            pulumi.set(__self__, "sdwan_interface_profile", sdwan_interface_profile)
        if upstream_nat is not None:
            pulumi.set(__self__, "upstream_nat", upstream_nat)

    @_builtins.property
    @pulumi.getter(name="sdwanGateway")
    def sdwan_gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop gateway
        """
        return pulumi.get(self, "sdwan_gateway")

    @sdwan_gateway.setter
    def sdwan_gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_gateway", value)

    @_builtins.property
    @pulumi.getter(name="sdwanInterfaceProfile")
    def sdwan_interface_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SD-WAN interface profile
        """
        return pulumi.get(self, "sdwan_interface_profile")

    @sdwan_interface_profile.setter
    def sdwan_interface_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_interface_profile", value)

    @_builtins.property
    @pulumi.getter(name="upstreamNat")
    def upstream_nat(self) -> Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs']]:
        """
        Upstream nat
        """
        return pulumi.get(self, "upstream_nat")

    @upstream_nat.setter
    def upstream_nat(self, value: Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs']]):
        pulumi.set(self, "upstream_nat", value)


if not MYPY:
    class AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Upstream NAT?
        """
        static_ip: NotRequired[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict']]
        """
        Static ip
        """
elif False:
    AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 static_ip: Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Upstream NAT?
        :param pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs'] static_ip: Static ip
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Upstream NAT?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]:
        """
        Static ip
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input['AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs']]):
        pulumi.set(self, "static_ip", value)


if not MYPY:
    class AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        FQDN
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
elif False:
    AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnClusterGatewayPrivateInterfaceSdwanLinkSettingsUpstreamNatStaticIpArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: FQDN
        :param pulumi.Input[_builtins.str] ip_address: IP address
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        FQDN
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class AutoVpnSettingAsRangeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.int]]
        """
        End
        """
        start: NotRequired[pulumi.Input[_builtins.int]]
        """
        Start
        """
elif False:
    AutoVpnSettingAsRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoVpnSettingAsRangeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.int]] = None,
                 start: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] end: End
        :param pulumi.Input[_builtins.int] start: Start
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        End
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Start
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class BandwidthAllocationQosArgsDict(TypedDict):
        customized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Customized
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled
        """
        guaranteed_ratio: NotRequired[pulumi.Input[_builtins.float]]
        """
        Guaranteed ratio
        """
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    BandwidthAllocationQosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthAllocationQosArgs:
    def __init__(__self__, *,
                 customized: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 guaranteed_ratio: Optional[pulumi.Input[_builtins.float]] = None,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] customized: Customized
        :param pulumi.Input[_builtins.bool] enabled: Enabled
        :param pulumi.Input[_builtins.float] guaranteed_ratio: Guaranteed ratio
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if customized is not None:
            pulumi.set(__self__, "customized", customized)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if guaranteed_ratio is not None:
            pulumi.set(__self__, "guaranteed_ratio", guaranteed_ratio)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def customized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Customized
        """
        return pulumi.get(self, "customized")

    @customized.setter
    def customized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "customized", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="guaranteedRatio")
    def guaranteed_ratio(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Guaranteed ratio
        """
        return pulumi.get(self, "guaranteed_ratio")

    @guaranteed_ratio.setter
    def guaranteed_ratio(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "guaranteed_ratio", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4ArgsDict(TypedDict):
        multicast: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastArgsDict']]
        """
        Multicast
        """
        unicast: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastArgsDict']]
        """
        Unicast
        """
elif False:
    BgpAddressFamilyProfileIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4Args:
    def __init__(__self__, *,
                 multicast: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastArgs']] = None,
                 unicast: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastArgs'] multicast: Multicast
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastArgs'] unicast: Unicast
        """
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastArgs']]:
        """
        Multicast
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastArgs']]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastArgs']]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastArgsDict(TypedDict):
        add_path: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAddPathArgsDict']]
        """
        Add path
        """
        allowas_in: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInArgsDict']]
        """
        Allowas in
        """
        as_override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override ASNs in outbound updates if AS-Path equals Remote-AS?
        """
        default_originate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Originate default route?
        """
        default_originate_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default originate route map
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable?
        """
        maximum_prefix: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgsDict']]
        """
        Maximum prefix
        """
        next_hop: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopArgsDict']]
        """
        Next hop
        """
        orf: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastOrfArgsDict']]
        """
        Orf
        """
        remove_private_as: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgsDict']]
        """
        Remove private a s
        """
        route_reflector_client: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Route reflector client?
        """
        send_community: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityArgsDict']]
        """
        Send community
        """
        soft_reconfig_with_stored_info: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Soft reconfiguration of peer with stored routes?
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastArgs:
    def __init__(__self__, *,
                 add_path: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAddPathArgs']] = None,
                 allowas_in: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInArgs']] = None,
                 as_override: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_originate: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_originate_map: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 maximum_prefix: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopArgs']] = None,
                 orf: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastOrfArgs']] = None,
                 remove_private_as: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgs']] = None,
                 route_reflector_client: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_community: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityArgs']] = None,
                 soft_reconfig_with_stored_info: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAddPathArgs'] add_path: Add path
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInArgs'] allowas_in: Allowas in
        :param pulumi.Input[_builtins.bool] as_override: Override ASNs in outbound updates if AS-Path equals Remote-AS?
        :param pulumi.Input[_builtins.bool] default_originate: Originate default route?
        :param pulumi.Input[_builtins.str] default_originate_map: Default originate route map
        :param pulumi.Input[_builtins.bool] enable: Enable?
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgs'] maximum_prefix: Maximum prefix
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopArgs'] next_hop: Next hop
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastOrfArgs'] orf: Orf
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgs'] remove_private_as: Remove private a s
        :param pulumi.Input[_builtins.bool] route_reflector_client: Route reflector client?
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityArgs'] send_community: Send community
        :param pulumi.Input[_builtins.bool] soft_reconfig_with_stored_info: Soft reconfiguration of peer with stored routes?
        """
        if add_path is not None:
            pulumi.set(__self__, "add_path", add_path)
        if allowas_in is not None:
            pulumi.set(__self__, "allowas_in", allowas_in)
        if as_override is not None:
            pulumi.set(__self__, "as_override", as_override)
        if default_originate is not None:
            pulumi.set(__self__, "default_originate", default_originate)
        if default_originate_map is not None:
            pulumi.set(__self__, "default_originate_map", default_originate_map)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if maximum_prefix is not None:
            pulumi.set(__self__, "maximum_prefix", maximum_prefix)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if orf is not None:
            pulumi.set(__self__, "orf", orf)
        if remove_private_as is not None:
            pulumi.set(__self__, "remove_private_as", remove_private_as)
        if route_reflector_client is not None:
            pulumi.set(__self__, "route_reflector_client", route_reflector_client)
        if send_community is not None:
            pulumi.set(__self__, "send_community", send_community)
        if soft_reconfig_with_stored_info is not None:
            pulumi.set(__self__, "soft_reconfig_with_stored_info", soft_reconfig_with_stored_info)

    @_builtins.property
    @pulumi.getter(name="addPath")
    def add_path(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAddPathArgs']]:
        """
        Add path
        """
        return pulumi.get(self, "add_path")

    @add_path.setter
    def add_path(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAddPathArgs']]):
        pulumi.set(self, "add_path", value)

    @_builtins.property
    @pulumi.getter(name="allowasIn")
    def allowas_in(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInArgs']]:
        """
        Allowas in
        """
        return pulumi.get(self, "allowas_in")

    @allowas_in.setter
    def allowas_in(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInArgs']]):
        pulumi.set(self, "allowas_in", value)

    @_builtins.property
    @pulumi.getter(name="asOverride")
    def as_override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override ASNs in outbound updates if AS-Path equals Remote-AS?
        """
        return pulumi.get(self, "as_override")

    @as_override.setter
    def as_override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_override", value)

    @_builtins.property
    @pulumi.getter(name="defaultOriginate")
    def default_originate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Originate default route?
        """
        return pulumi.get(self, "default_originate")

    @default_originate.setter
    def default_originate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_originate", value)

    @_builtins.property
    @pulumi.getter(name="defaultOriginateMap")
    def default_originate_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default originate route map
        """
        return pulumi.get(self, "default_originate_map")

    @default_originate_map.setter
    def default_originate_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_originate_map", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maximumPrefix")
    def maximum_prefix(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgs']]:
        """
        Maximum prefix
        """
        return pulumi.get(self, "maximum_prefix")

    @maximum_prefix.setter
    def maximum_prefix(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgs']]):
        pulumi.set(self, "maximum_prefix", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopArgs']]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter
    def orf(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastOrfArgs']]:
        """
        Orf
        """
        return pulumi.get(self, "orf")

    @orf.setter
    def orf(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastOrfArgs']]):
        pulumi.set(self, "orf", value)

    @_builtins.property
    @pulumi.getter(name="removePrivateAs")
    def remove_private_as(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgs']]:
        """
        Remove private a s
        """
        return pulumi.get(self, "remove_private_as")

    @remove_private_as.setter
    def remove_private_as(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgs']]):
        pulumi.set(self, "remove_private_as", value)

    @_builtins.property
    @pulumi.getter(name="routeReflectorClient")
    def route_reflector_client(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Route reflector client?
        """
        return pulumi.get(self, "route_reflector_client")

    @route_reflector_client.setter
    def route_reflector_client(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_reflector_client", value)

    @_builtins.property
    @pulumi.getter(name="sendCommunity")
    def send_community(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityArgs']]:
        """
        Send community
        """
        return pulumi.get(self, "send_community")

    @send_community.setter
    def send_community(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityArgs']]):
        pulumi.set(self, "send_community", value)

    @_builtins.property
    @pulumi.getter(name="softReconfigWithStoredInfo")
    def soft_reconfig_with_stored_info(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Soft reconfiguration of peer with stored routes?
        """
        return pulumi.get(self, "soft_reconfig_with_stored_info")

    @soft_reconfig_with_stored_info.setter
    def soft_reconfig_with_stored_info(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "soft_reconfig_with_stored_info", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastAddPathArgsDict(TypedDict):
        tx_all_paths: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Advertise all paths to peer?
        """
        tx_bestpath_per_as: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tx bestpath per a s
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastAddPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastAddPathArgs:
    def __init__(__self__, *,
                 tx_all_paths: Optional[pulumi.Input[_builtins.bool]] = None,
                 tx_bestpath_per_as: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] tx_all_paths: Advertise all paths to peer?
        :param pulumi.Input[_builtins.bool] tx_bestpath_per_as: Tx bestpath per a s
        """
        if tx_all_paths is not None:
            pulumi.set(__self__, "tx_all_paths", tx_all_paths)
        if tx_bestpath_per_as is not None:
            pulumi.set(__self__, "tx_bestpath_per_as", tx_bestpath_per_as)

    @_builtins.property
    @pulumi.getter(name="txAllPaths")
    def tx_all_paths(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Advertise all paths to peer?
        """
        return pulumi.get(self, "tx_all_paths")

    @tx_all_paths.setter
    def tx_all_paths(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tx_all_paths", value)

    @_builtins.property
    @pulumi.getter(name="txBestpathPerAs")
    def tx_bestpath_per_as(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tx bestpath per a s
        """
        return pulumi.get(self, "tx_bestpath_per_as")

    @tx_bestpath_per_as.setter
    def tx_bestpath_per_as(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tx_bestpath_per_as", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastAllowasInArgsDict(TypedDict):
        occurrence: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of times the firewalls own AS can be in an AS_PATH
        """
        origin: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgsDict']]
        """
        Origin

        >  **Note:** You must specify exactly one of `occurrence` and `origin`.
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastAllowasInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastAllowasInArgs:
    def __init__(__self__, *,
                 occurrence: Optional[pulumi.Input[_builtins.int]] = None,
                 origin: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] occurrence: Number of times the firewalls own AS can be in an AS_PATH
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgs'] origin: Origin
               
               >  **Note:** You must specify exactly one of `occurrence` and `origin`.
        """
        if occurrence is not None:
            pulumi.set(__self__, "occurrence", occurrence)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)

    @_builtins.property
    @pulumi.getter
    def occurrence(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of times the firewalls own AS can be in an AS_PATH
        """
        return pulumi.get(self, "occurrence")

    @occurrence.setter
    def occurrence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "occurrence", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgs']]:
        """
        Origin

        >  **Note:** You must specify exactly one of `occurrence` and `origin`.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgs']]):
        pulumi.set(self, "origin", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastAllowasInOriginArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgsDict']]
        """
        Action
        """
        num_prefixes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of prefixes
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold percentage of the maximum number of prefixes
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgs']] = None,
                 num_prefixes: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgs'] action: Action
        :param pulumi.Input[_builtins.int] num_prefixes: Maximum number of prefixes
        :param pulumi.Input[_builtins.int] threshold: Threshold percentage of the maximum number of prefixes
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if num_prefixes is not None:
            pulumi.set(__self__, "num_prefixes", num_prefixes)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgs']]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="numPrefixes")
    def num_prefixes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of prefixes
        """
        return pulumi.get(self, "num_prefixes")

    @num_prefixes.setter
    def num_prefixes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold percentage of the maximum number of prefixes
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgsDict(TypedDict):
        restart: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgsDict']]
        """
        Restart
        """
        warning_only: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgsDict']]
        """
        Warning only

        >  **Note:** You must specify exactly one of `restart` and `warning_only`.
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionArgs:
    def __init__(__self__, *,
                 restart: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgs']] = None,
                 warning_only: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgs'] restart: Restart
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgs'] warning_only: Warning only
               
               >  **Note:** You must specify exactly one of `restart` and `warning_only`.
        """
        if restart is not None:
            pulumi.set(__self__, "restart", restart)
        if warning_only is not None:
            pulumi.set(__self__, "warning_only", warning_only)

    @_builtins.property
    @pulumi.getter
    def restart(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgs']]:
        """
        Restart
        """
        return pulumi.get(self, "restart")

    @restart.setter
    def restart(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgs']]):
        pulumi.set(self, "restart", value)

    @_builtins.property
    @pulumi.getter(name="warningOnly")
    def warning_only(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgs']]:
        """
        Warning only

        >  **Note:** You must specify exactly one of `restart` and `warning_only`.
        """
        return pulumi.get(self, "warning_only")

    @warning_only.setter
    def warning_only(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgs']]):
        pulumi.set(self, "warning_only", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Restart interval
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionRestartArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Restart interval
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Restart interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastMaximumPrefixActionWarningOnlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastNextHopArgsDict(TypedDict):
        self: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgsDict']]
        """
        Self
        """
        self_force: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgsDict']]
        """
        Self force

        >  **Note:** You must specify exactly one of `self` and `self_force`.
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastNextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastNextHopArgs:
    def __init__(__self__, *,
                 self: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgs']] = None,
                 self_force: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgs'] self: Self
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgs'] self_force: Self force
               
               >  **Note:** You must specify exactly one of `self` and `self_force`.
        """
        if self is not None:
            pulumi.set(__self__, "self", self)
        if self_force is not None:
            pulumi.set(__self__, "self_force", self_force)

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgs']]:
        """
        Self
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgs']]):
        pulumi.set(self, "self", value)

    @_builtins.property
    @pulumi.getter(name="selfForce")
    def self_force(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgs']]:
        """
        Self force

        >  **Note:** You must specify exactly one of `self` and `self_force`.
        """
        return pulumi.get(self, "self_force")

    @self_force.setter
    def self_force(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgs']]):
        pulumi.set(self, "self_force", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastNextHopSelfArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastNextHopSelfForceArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastOrfArgsDict(TypedDict):
        orf_prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        ORF prefix list
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastOrfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastOrfArgs:
    def __init__(__self__, *,
                 orf_prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] orf_prefix_list: ORF prefix list
        """
        if orf_prefix_list is not None:
            pulumi.set(__self__, "orf_prefix_list", orf_prefix_list)

    @_builtins.property
    @pulumi.getter(name="orfPrefixList")
    def orf_prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ORF prefix list
        """
        return pulumi.get(self, "orf_prefix_list")

    @orf_prefix_list.setter
    def orf_prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "orf_prefix_list", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgsDict']]
        """
        All
        """
        replace_as: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgsDict']]
        """
        Replace a s
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgs']] = None,
                 replace_as: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgs'] all: All
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgs'] replace_as: Replace a s
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if replace_as is not None:
            pulumi.set(__self__, "replace_as", replace_as)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgs']]:
        """
        All
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="replaceAs")
    def replace_as(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgs']]:
        """
        Replace a s
        """
        return pulumi.get(self, "replace_as")

    @replace_as.setter
    def replace_as(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgs']]):
        pulumi.set(self, "replace_as", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastRemovePrivateAsReplaceAsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastSendCommunityArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgsDict']]
        """
        All
        """
        both: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgsDict']]
        """
        Both

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        extended: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgsDict']]
        """
        Extended

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        large: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgsDict']]
        """
        Large

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        standard: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgsDict']]
        """
        Standard

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
elif False:
    BgpAddressFamilyProfileIpv4MulticastSendCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastSendCommunityArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgs']] = None,
                 both: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgs']] = None,
                 extended: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgs']] = None,
                 large: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgs']] = None,
                 standard: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgs'] all: All
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgs'] both: Both
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgs'] extended: Extended
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgs'] large: Large
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        :param pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgs'] standard: Standard
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if both is not None:
            pulumi.set(__self__, "both", both)
        if extended is not None:
            pulumi.set(__self__, "extended", extended)
        if large is not None:
            pulumi.set(__self__, "large", large)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgs']]:
        """
        All
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def both(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgs']]:
        """
        Both

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "both")

    @both.setter
    def both(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgs']]):
        pulumi.set(self, "both", value)

    @_builtins.property
    @pulumi.getter
    def extended(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgs']]:
        """
        Extended

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "extended")

    @extended.setter
    def extended(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgs']]):
        pulumi.set(self, "extended", value)

    @_builtins.property
    @pulumi.getter
    def large(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgs']]:
        """
        Large

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "large")

    @large.setter
    def large(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgs']]):
        pulumi.set(self, "large", value)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgs']]:
        """
        Standard

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgs']]):
        pulumi.set(self, "standard", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastSendCommunityAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastSendCommunityBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastSendCommunityExtendedArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastSendCommunityLargeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4MulticastSendCommunityStandardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastArgsDict(TypedDict):
        add_path: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAddPathArgsDict']]
        """
        Add path
        """
        allowas_in: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInArgsDict']]
        """
        Allowas in
        """
        as_override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override ASNs in outbound updates if AS-Path equals Remote-AS?
        """
        default_originate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Originate default route?
        """
        default_originate_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default originate route map
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable?
        """
        maximum_prefix: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgsDict']]
        """
        Maximum prefix
        """
        next_hop: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopArgsDict']]
        """
        Next hop
        """
        orf: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastOrfArgsDict']]
        """
        Orf
        """
        remove_private_as: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgsDict']]
        """
        Remove private a s
        """
        route_reflector_client: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Route reflector client?
        """
        send_community: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityArgsDict']]
        """
        Send community
        """
        soft_reconfig_with_stored_info: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Soft reconfiguration of peer with stored routes?
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastArgs:
    def __init__(__self__, *,
                 add_path: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAddPathArgs']] = None,
                 allowas_in: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInArgs']] = None,
                 as_override: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_originate: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_originate_map: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 maximum_prefix: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopArgs']] = None,
                 orf: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastOrfArgs']] = None,
                 remove_private_as: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgs']] = None,
                 route_reflector_client: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_community: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityArgs']] = None,
                 soft_reconfig_with_stored_info: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAddPathArgs'] add_path: Add path
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInArgs'] allowas_in: Allowas in
        :param pulumi.Input[_builtins.bool] as_override: Override ASNs in outbound updates if AS-Path equals Remote-AS?
        :param pulumi.Input[_builtins.bool] default_originate: Originate default route?
        :param pulumi.Input[_builtins.str] default_originate_map: Default originate route map
        :param pulumi.Input[_builtins.bool] enable: Enable?
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgs'] maximum_prefix: Maximum prefix
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopArgs'] next_hop: Next hop
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastOrfArgs'] orf: Orf
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgs'] remove_private_as: Remove private a s
        :param pulumi.Input[_builtins.bool] route_reflector_client: Route reflector client?
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityArgs'] send_community: Send community
        :param pulumi.Input[_builtins.bool] soft_reconfig_with_stored_info: Soft reconfiguration of peer with stored routes?
        """
        if add_path is not None:
            pulumi.set(__self__, "add_path", add_path)
        if allowas_in is not None:
            pulumi.set(__self__, "allowas_in", allowas_in)
        if as_override is not None:
            pulumi.set(__self__, "as_override", as_override)
        if default_originate is not None:
            pulumi.set(__self__, "default_originate", default_originate)
        if default_originate_map is not None:
            pulumi.set(__self__, "default_originate_map", default_originate_map)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if maximum_prefix is not None:
            pulumi.set(__self__, "maximum_prefix", maximum_prefix)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if orf is not None:
            pulumi.set(__self__, "orf", orf)
        if remove_private_as is not None:
            pulumi.set(__self__, "remove_private_as", remove_private_as)
        if route_reflector_client is not None:
            pulumi.set(__self__, "route_reflector_client", route_reflector_client)
        if send_community is not None:
            pulumi.set(__self__, "send_community", send_community)
        if soft_reconfig_with_stored_info is not None:
            pulumi.set(__self__, "soft_reconfig_with_stored_info", soft_reconfig_with_stored_info)

    @_builtins.property
    @pulumi.getter(name="addPath")
    def add_path(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAddPathArgs']]:
        """
        Add path
        """
        return pulumi.get(self, "add_path")

    @add_path.setter
    def add_path(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAddPathArgs']]):
        pulumi.set(self, "add_path", value)

    @_builtins.property
    @pulumi.getter(name="allowasIn")
    def allowas_in(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInArgs']]:
        """
        Allowas in
        """
        return pulumi.get(self, "allowas_in")

    @allowas_in.setter
    def allowas_in(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInArgs']]):
        pulumi.set(self, "allowas_in", value)

    @_builtins.property
    @pulumi.getter(name="asOverride")
    def as_override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override ASNs in outbound updates if AS-Path equals Remote-AS?
        """
        return pulumi.get(self, "as_override")

    @as_override.setter
    def as_override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_override", value)

    @_builtins.property
    @pulumi.getter(name="defaultOriginate")
    def default_originate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Originate default route?
        """
        return pulumi.get(self, "default_originate")

    @default_originate.setter
    def default_originate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_originate", value)

    @_builtins.property
    @pulumi.getter(name="defaultOriginateMap")
    def default_originate_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default originate route map
        """
        return pulumi.get(self, "default_originate_map")

    @default_originate_map.setter
    def default_originate_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_originate_map", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maximumPrefix")
    def maximum_prefix(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgs']]:
        """
        Maximum prefix
        """
        return pulumi.get(self, "maximum_prefix")

    @maximum_prefix.setter
    def maximum_prefix(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgs']]):
        pulumi.set(self, "maximum_prefix", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopArgs']]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter
    def orf(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastOrfArgs']]:
        """
        Orf
        """
        return pulumi.get(self, "orf")

    @orf.setter
    def orf(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastOrfArgs']]):
        pulumi.set(self, "orf", value)

    @_builtins.property
    @pulumi.getter(name="removePrivateAs")
    def remove_private_as(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgs']]:
        """
        Remove private a s
        """
        return pulumi.get(self, "remove_private_as")

    @remove_private_as.setter
    def remove_private_as(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgs']]):
        pulumi.set(self, "remove_private_as", value)

    @_builtins.property
    @pulumi.getter(name="routeReflectorClient")
    def route_reflector_client(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Route reflector client?
        """
        return pulumi.get(self, "route_reflector_client")

    @route_reflector_client.setter
    def route_reflector_client(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_reflector_client", value)

    @_builtins.property
    @pulumi.getter(name="sendCommunity")
    def send_community(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityArgs']]:
        """
        Send community
        """
        return pulumi.get(self, "send_community")

    @send_community.setter
    def send_community(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityArgs']]):
        pulumi.set(self, "send_community", value)

    @_builtins.property
    @pulumi.getter(name="softReconfigWithStoredInfo")
    def soft_reconfig_with_stored_info(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Soft reconfiguration of peer with stored routes?
        """
        return pulumi.get(self, "soft_reconfig_with_stored_info")

    @soft_reconfig_with_stored_info.setter
    def soft_reconfig_with_stored_info(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "soft_reconfig_with_stored_info", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastAddPathArgsDict(TypedDict):
        tx_all_paths: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Advertise all paths to peer?
        """
        tx_bestpath_per_as: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tx bestpath per a s
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastAddPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastAddPathArgs:
    def __init__(__self__, *,
                 tx_all_paths: Optional[pulumi.Input[_builtins.bool]] = None,
                 tx_bestpath_per_as: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] tx_all_paths: Advertise all paths to peer?
        :param pulumi.Input[_builtins.bool] tx_bestpath_per_as: Tx bestpath per a s
        """
        if tx_all_paths is not None:
            pulumi.set(__self__, "tx_all_paths", tx_all_paths)
        if tx_bestpath_per_as is not None:
            pulumi.set(__self__, "tx_bestpath_per_as", tx_bestpath_per_as)

    @_builtins.property
    @pulumi.getter(name="txAllPaths")
    def tx_all_paths(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Advertise all paths to peer?
        """
        return pulumi.get(self, "tx_all_paths")

    @tx_all_paths.setter
    def tx_all_paths(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tx_all_paths", value)

    @_builtins.property
    @pulumi.getter(name="txBestpathPerAs")
    def tx_bestpath_per_as(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tx bestpath per a s
        """
        return pulumi.get(self, "tx_bestpath_per_as")

    @tx_bestpath_per_as.setter
    def tx_bestpath_per_as(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tx_bestpath_per_as", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastAllowasInArgsDict(TypedDict):
        occurrence: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of times the firewalls own AS can be in an AS_PATH
        """
        origin: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgsDict']]
        """
        Origin

        >  **Note:** You must specify exactly one of `occurrence` and `origin`.
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastAllowasInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastAllowasInArgs:
    def __init__(__self__, *,
                 occurrence: Optional[pulumi.Input[_builtins.int]] = None,
                 origin: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] occurrence: Number of times the firewalls own AS can be in an AS_PATH
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgs'] origin: Origin
               
               >  **Note:** You must specify exactly one of `occurrence` and `origin`.
        """
        if occurrence is not None:
            pulumi.set(__self__, "occurrence", occurrence)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)

    @_builtins.property
    @pulumi.getter
    def occurrence(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of times the firewalls own AS can be in an AS_PATH
        """
        return pulumi.get(self, "occurrence")

    @occurrence.setter
    def occurrence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "occurrence", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgs']]:
        """
        Origin

        >  **Note:** You must specify exactly one of `occurrence` and `origin`.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgs']]):
        pulumi.set(self, "origin", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastAllowasInOriginArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgsDict']]
        """
        Action
        """
        num_prefixes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of prefixes
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold percentage of the maximum number of prefixes
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgs']] = None,
                 num_prefixes: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgs'] action: Action
        :param pulumi.Input[_builtins.int] num_prefixes: Maximum number of prefixes
        :param pulumi.Input[_builtins.int] threshold: Threshold percentage of the maximum number of prefixes
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if num_prefixes is not None:
            pulumi.set(__self__, "num_prefixes", num_prefixes)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgs']]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="numPrefixes")
    def num_prefixes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of prefixes
        """
        return pulumi.get(self, "num_prefixes")

    @num_prefixes.setter
    def num_prefixes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold percentage of the maximum number of prefixes
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgsDict(TypedDict):
        restart: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgsDict']]
        """
        Restart
        """
        warning_only: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgsDict']]
        """
        Warning only

        >  **Note:** You must specify exactly one of `restart` and `warning_only`.
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionArgs:
    def __init__(__self__, *,
                 restart: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgs']] = None,
                 warning_only: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgs'] restart: Restart
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgs'] warning_only: Warning only
               
               >  **Note:** You must specify exactly one of `restart` and `warning_only`.
        """
        if restart is not None:
            pulumi.set(__self__, "restart", restart)
        if warning_only is not None:
            pulumi.set(__self__, "warning_only", warning_only)

    @_builtins.property
    @pulumi.getter
    def restart(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgs']]:
        """
        Restart
        """
        return pulumi.get(self, "restart")

    @restart.setter
    def restart(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgs']]):
        pulumi.set(self, "restart", value)

    @_builtins.property
    @pulumi.getter(name="warningOnly")
    def warning_only(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgs']]:
        """
        Warning only

        >  **Note:** You must specify exactly one of `restart` and `warning_only`.
        """
        return pulumi.get(self, "warning_only")

    @warning_only.setter
    def warning_only(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgs']]):
        pulumi.set(self, "warning_only", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Restart interval
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionRestartArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Restart interval
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Restart interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastMaximumPrefixActionWarningOnlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastNextHopArgsDict(TypedDict):
        self: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgsDict']]
        """
        Self
        """
        self_force: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgsDict']]
        """
        Self force

        >  **Note:** You must specify exactly one of `self` and `self_force`.
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastNextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastNextHopArgs:
    def __init__(__self__, *,
                 self: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgs']] = None,
                 self_force: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgs'] self: Self
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgs'] self_force: Self force
               
               >  **Note:** You must specify exactly one of `self` and `self_force`.
        """
        if self is not None:
            pulumi.set(__self__, "self", self)
        if self_force is not None:
            pulumi.set(__self__, "self_force", self_force)

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgs']]:
        """
        Self
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgs']]):
        pulumi.set(self, "self", value)

    @_builtins.property
    @pulumi.getter(name="selfForce")
    def self_force(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgs']]:
        """
        Self force

        >  **Note:** You must specify exactly one of `self` and `self_force`.
        """
        return pulumi.get(self, "self_force")

    @self_force.setter
    def self_force(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgs']]):
        pulumi.set(self, "self_force", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastNextHopSelfArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastNextHopSelfForceArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastOrfArgsDict(TypedDict):
        orf_prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        ORF prefix list
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastOrfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastOrfArgs:
    def __init__(__self__, *,
                 orf_prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] orf_prefix_list: ORF prefix list
        """
        if orf_prefix_list is not None:
            pulumi.set(__self__, "orf_prefix_list", orf_prefix_list)

    @_builtins.property
    @pulumi.getter(name="orfPrefixList")
    def orf_prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ORF prefix list
        """
        return pulumi.get(self, "orf_prefix_list")

    @orf_prefix_list.setter
    def orf_prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "orf_prefix_list", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgsDict']]
        """
        All
        """
        replace_as: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgsDict']]
        """
        Replace a s
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgs']] = None,
                 replace_as: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgs'] all: All
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgs'] replace_as: Replace a s
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if replace_as is not None:
            pulumi.set(__self__, "replace_as", replace_as)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgs']]:
        """
        All
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="replaceAs")
    def replace_as(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgs']]:
        """
        Replace a s
        """
        return pulumi.get(self, "replace_as")

    @replace_as.setter
    def replace_as(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgs']]):
        pulumi.set(self, "replace_as", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastRemovePrivateAsReplaceAsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastSendCommunityArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgsDict']]
        """
        All
        """
        both: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgsDict']]
        """
        Both

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        extended: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgsDict']]
        """
        Extended

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        large: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgsDict']]
        """
        Large

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        standard: NotRequired[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgsDict']]
        """
        Standard

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
elif False:
    BgpAddressFamilyProfileIpv4UnicastSendCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastSendCommunityArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgs']] = None,
                 both: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgs']] = None,
                 extended: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgs']] = None,
                 large: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgs']] = None,
                 standard: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgs']] = None):
        """
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgs'] all: All
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgs'] both: Both
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgs'] extended: Extended
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgs'] large: Large
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        :param pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgs'] standard: Standard
               
               >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if both is not None:
            pulumi.set(__self__, "both", both)
        if extended is not None:
            pulumi.set(__self__, "extended", extended)
        if large is not None:
            pulumi.set(__self__, "large", large)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgs']]:
        """
        All
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def both(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgs']]:
        """
        Both

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "both")

    @both.setter
    def both(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgs']]):
        pulumi.set(self, "both", value)

    @_builtins.property
    @pulumi.getter
    def extended(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgs']]:
        """
        Extended

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "extended")

    @extended.setter
    def extended(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgs']]):
        pulumi.set(self, "extended", value)

    @_builtins.property
    @pulumi.getter
    def large(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgs']]:
        """
        Large

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "large")

    @large.setter
    def large(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgs']]):
        pulumi.set(self, "large", value)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgs']]:
        """
        Standard

        >  **Note:** You must specify exactly one of `all`, `both`, `extended`, `large`, and `standard`.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input['BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgs']]):
        pulumi.set(self, "standard", value)


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastSendCommunityAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastSendCommunityBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastSendCommunityExtendedArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastSendCommunityLargeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgsDict(TypedDict):
        pass
elif False:
    BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpAddressFamilyProfileIpv4UnicastSendCommunityStandardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpFilteringProfileIpv4ArgsDict(TypedDict):
        multicast: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastArgsDict']]
        """
        Multicast
        """
        unicast: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastArgsDict']]
        """
        Unicast
        """
elif False:
    BgpFilteringProfileIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4Args:
    def __init__(__self__, *,
                 multicast: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastArgs']] = None,
                 unicast: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastArgs']] = None):
        """
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastArgs'] multicast: Multicast
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastArgs'] unicast: Unicast
        """
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastArgs']]:
        """
        Multicast
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastArgs']]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastArgs']]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastArgsDict(TypedDict):
        conditional_advertisement: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgsDict']]
        """
        Conditional advertisement
        """
        filter_list: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastFilterListArgsDict']]
        """
        Filter list
        """
        inbound_network_filters: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgsDict']]
        """
        Inbound network filters
        """
        inherit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Inherit from unicast
        """
        outbound_network_filters: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgsDict']]
        """
        Outbound network filters
        """
        route_maps: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastRouteMapsArgsDict']]
        """
        Route maps
        """
        unsuppress_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unsuppress map
        """
elif False:
    BgpFilteringProfileIpv4MulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastArgs:
    def __init__(__self__, *,
                 conditional_advertisement: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgs']] = None,
                 filter_list: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastFilterListArgs']] = None,
                 inbound_network_filters: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgs']] = None,
                 inherit: Optional[pulumi.Input[_builtins.bool]] = None,
                 outbound_network_filters: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgs']] = None,
                 route_maps: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastRouteMapsArgs']] = None,
                 unsuppress_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgs'] conditional_advertisement: Conditional advertisement
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastFilterListArgs'] filter_list: Filter list
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgs'] inbound_network_filters: Inbound network filters
        :param pulumi.Input[_builtins.bool] inherit: Inherit from unicast
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgs'] outbound_network_filters: Outbound network filters
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastRouteMapsArgs'] route_maps: Route maps
        :param pulumi.Input[_builtins.str] unsuppress_map: Unsuppress map
        """
        if conditional_advertisement is not None:
            pulumi.set(__self__, "conditional_advertisement", conditional_advertisement)
        if filter_list is not None:
            pulumi.set(__self__, "filter_list", filter_list)
        if inbound_network_filters is not None:
            pulumi.set(__self__, "inbound_network_filters", inbound_network_filters)
        if inherit is not None:
            pulumi.set(__self__, "inherit", inherit)
        if outbound_network_filters is not None:
            pulumi.set(__self__, "outbound_network_filters", outbound_network_filters)
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)
        if unsuppress_map is not None:
            pulumi.set(__self__, "unsuppress_map", unsuppress_map)

    @_builtins.property
    @pulumi.getter(name="conditionalAdvertisement")
    def conditional_advertisement(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgs']]:
        """
        Conditional advertisement
        """
        return pulumi.get(self, "conditional_advertisement")

    @conditional_advertisement.setter
    def conditional_advertisement(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgs']]):
        pulumi.set(self, "conditional_advertisement", value)

    @_builtins.property
    @pulumi.getter(name="filterList")
    def filter_list(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastFilterListArgs']]:
        """
        Filter list
        """
        return pulumi.get(self, "filter_list")

    @filter_list.setter
    def filter_list(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastFilterListArgs']]):
        pulumi.set(self, "filter_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundNetworkFilters")
    def inbound_network_filters(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgs']]:
        """
        Inbound network filters
        """
        return pulumi.get(self, "inbound_network_filters")

    @inbound_network_filters.setter
    def inbound_network_filters(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgs']]):
        pulumi.set(self, "inbound_network_filters", value)

    @_builtins.property
    @pulumi.getter
    def inherit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Inherit from unicast
        """
        return pulumi.get(self, "inherit")

    @inherit.setter
    def inherit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "inherit", value)

    @_builtins.property
    @pulumi.getter(name="outboundNetworkFilters")
    def outbound_network_filters(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgs']]:
        """
        Outbound network filters
        """
        return pulumi.get(self, "outbound_network_filters")

    @outbound_network_filters.setter
    def outbound_network_filters(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgs']]):
        pulumi.set(self, "outbound_network_filters", value)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastRouteMapsArgs']]:
        """
        Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastRouteMapsArgs']]):
        pulumi.set(self, "route_maps", value)

    @_builtins.property
    @pulumi.getter(name="unsuppressMap")
    def unsuppress_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unsuppress map
        """
        return pulumi.get(self, "unsuppress_map")

    @unsuppress_map.setter
    def unsuppress_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unsuppress_map", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgsDict(TypedDict):
        exist: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgsDict']]
        """
        Exist
        """
        non_exist: NotRequired[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgsDict']]
        """
        Non exist
        """
elif False:
    BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastConditionalAdvertisementArgs:
    def __init__(__self__, *,
                 exist: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgs']] = None,
                 non_exist: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgs']] = None):
        """
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgs'] exist: Exist
        :param pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgs'] non_exist: Non exist
        """
        if exist is not None:
            pulumi.set(__self__, "exist", exist)
        if non_exist is not None:
            pulumi.set(__self__, "non_exist", non_exist)

    @_builtins.property
    @pulumi.getter
    def exist(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgs']]:
        """
        Exist
        """
        return pulumi.get(self, "exist")

    @exist.setter
    def exist(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgs']]):
        pulumi.set(self, "exist", value)

    @_builtins.property
    @pulumi.getter(name="nonExist")
    def non_exist(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgs']]:
        """
        Non exist
        """
        return pulumi.get(self, "non_exist")

    @non_exist.setter
    def non_exist(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgs']]):
        pulumi.set(self, "non_exist", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgsDict(TypedDict):
        advertise_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advertise map
        """
        exist_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Exist map
        """
elif False:
    BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastConditionalAdvertisementExistArgs:
    def __init__(__self__, *,
                 advertise_map: Optional[pulumi.Input[_builtins.str]] = None,
                 exist_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertise_map: Advertise map
        :param pulumi.Input[_builtins.str] exist_map: Exist map
        """
        if advertise_map is not None:
            pulumi.set(__self__, "advertise_map", advertise_map)
        if exist_map is not None:
            pulumi.set(__self__, "exist_map", exist_map)

    @_builtins.property
    @pulumi.getter(name="advertiseMap")
    def advertise_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advertise map
        """
        return pulumi.get(self, "advertise_map")

    @advertise_map.setter
    def advertise_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertise_map", value)

    @_builtins.property
    @pulumi.getter(name="existMap")
    def exist_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Exist map
        """
        return pulumi.get(self, "exist_map")

    @exist_map.setter
    def exist_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exist_map", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgsDict(TypedDict):
        advertise_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advertise map
        """
        non_exist_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Non exist map
        """
elif False:
    BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastConditionalAdvertisementNonExistArgs:
    def __init__(__self__, *,
                 advertise_map: Optional[pulumi.Input[_builtins.str]] = None,
                 non_exist_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertise_map: Advertise map
        :param pulumi.Input[_builtins.str] non_exist_map: Non exist map
        """
        if advertise_map is not None:
            pulumi.set(__self__, "advertise_map", advertise_map)
        if non_exist_map is not None:
            pulumi.set(__self__, "non_exist_map", non_exist_map)

    @_builtins.property
    @pulumi.getter(name="advertiseMap")
    def advertise_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advertise map
        """
        return pulumi.get(self, "advertise_map")

    @advertise_map.setter
    def advertise_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertise_map", value)

    @_builtins.property
    @pulumi.getter(name="nonExistMap")
    def non_exist_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Non exist map
        """
        return pulumi.get(self, "non_exist_map")

    @non_exist_map.setter
    def non_exist_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "non_exist_map", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastFilterListArgsDict(TypedDict):
        inbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound
        """
        outbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound
        """
elif False:
    BgpFilteringProfileIpv4MulticastFilterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastFilterListArgs:
    def __init__(__self__, *,
                 inbound: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inbound: Inbound
        :param pulumi.Input[_builtins.str] outbound: Outbound
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @_builtins.property
    @pulumi.getter
    def inbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound
        """
        return pulumi.get(self, "inbound")

    @inbound.setter
    def inbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgsDict(TypedDict):
        distribute_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Distribute list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastInboundNetworkFiltersArgs:
    def __init__(__self__, *,
                 distribute_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] distribute_list: Distribute list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if distribute_list is not None:
            pulumi.set(__self__, "distribute_list", distribute_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="distributeList")
    def distribute_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Distribute list
        """
        return pulumi.get(self, "distribute_list")

    @distribute_list.setter
    def distribute_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgsDict(TypedDict):
        distribute_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Distribute list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastOutboundNetworkFiltersArgs:
    def __init__(__self__, *,
                 distribute_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] distribute_list: Distribute list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if distribute_list is not None:
            pulumi.set(__self__, "distribute_list", distribute_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="distributeList")
    def distribute_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Distribute list
        """
        return pulumi.get(self, "distribute_list")

    @distribute_list.setter
    def distribute_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpFilteringProfileIpv4MulticastRouteMapsArgsDict(TypedDict):
        inbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound
        """
        outbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound
        """
elif False:
    BgpFilteringProfileIpv4MulticastRouteMapsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4MulticastRouteMapsArgs:
    def __init__(__self__, *,
                 inbound: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inbound: Inbound
        :param pulumi.Input[_builtins.str] outbound: Outbound
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @_builtins.property
    @pulumi.getter
    def inbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound
        """
        return pulumi.get(self, "inbound")

    @inbound.setter
    def inbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastArgsDict(TypedDict):
        conditional_advertisement: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgsDict']]
        """
        Conditional advertisement
        """
        filter_list: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastFilterListArgsDict']]
        """
        Filter list
        """
        inbound_network_filters: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgsDict']]
        """
        Inbound network filters
        """
        outbound_network_filters: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgsDict']]
        """
        Outbound network filters
        """
        route_maps: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastRouteMapsArgsDict']]
        """
        Route maps
        """
        unsuppress_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unsuppress map
        """
elif False:
    BgpFilteringProfileIpv4UnicastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastArgs:
    def __init__(__self__, *,
                 conditional_advertisement: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgs']] = None,
                 filter_list: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastFilterListArgs']] = None,
                 inbound_network_filters: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgs']] = None,
                 outbound_network_filters: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgs']] = None,
                 route_maps: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastRouteMapsArgs']] = None,
                 unsuppress_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgs'] conditional_advertisement: Conditional advertisement
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastFilterListArgs'] filter_list: Filter list
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgs'] inbound_network_filters: Inbound network filters
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgs'] outbound_network_filters: Outbound network filters
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastRouteMapsArgs'] route_maps: Route maps
        :param pulumi.Input[_builtins.str] unsuppress_map: Unsuppress map
        """
        if conditional_advertisement is not None:
            pulumi.set(__self__, "conditional_advertisement", conditional_advertisement)
        if filter_list is not None:
            pulumi.set(__self__, "filter_list", filter_list)
        if inbound_network_filters is not None:
            pulumi.set(__self__, "inbound_network_filters", inbound_network_filters)
        if outbound_network_filters is not None:
            pulumi.set(__self__, "outbound_network_filters", outbound_network_filters)
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)
        if unsuppress_map is not None:
            pulumi.set(__self__, "unsuppress_map", unsuppress_map)

    @_builtins.property
    @pulumi.getter(name="conditionalAdvertisement")
    def conditional_advertisement(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgs']]:
        """
        Conditional advertisement
        """
        return pulumi.get(self, "conditional_advertisement")

    @conditional_advertisement.setter
    def conditional_advertisement(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgs']]):
        pulumi.set(self, "conditional_advertisement", value)

    @_builtins.property
    @pulumi.getter(name="filterList")
    def filter_list(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastFilterListArgs']]:
        """
        Filter list
        """
        return pulumi.get(self, "filter_list")

    @filter_list.setter
    def filter_list(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastFilterListArgs']]):
        pulumi.set(self, "filter_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundNetworkFilters")
    def inbound_network_filters(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgs']]:
        """
        Inbound network filters
        """
        return pulumi.get(self, "inbound_network_filters")

    @inbound_network_filters.setter
    def inbound_network_filters(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgs']]):
        pulumi.set(self, "inbound_network_filters", value)

    @_builtins.property
    @pulumi.getter(name="outboundNetworkFilters")
    def outbound_network_filters(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgs']]:
        """
        Outbound network filters
        """
        return pulumi.get(self, "outbound_network_filters")

    @outbound_network_filters.setter
    def outbound_network_filters(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgs']]):
        pulumi.set(self, "outbound_network_filters", value)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastRouteMapsArgs']]:
        """
        Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastRouteMapsArgs']]):
        pulumi.set(self, "route_maps", value)

    @_builtins.property
    @pulumi.getter(name="unsuppressMap")
    def unsuppress_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unsuppress map
        """
        return pulumi.get(self, "unsuppress_map")

    @unsuppress_map.setter
    def unsuppress_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unsuppress_map", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgsDict(TypedDict):
        exist: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgsDict']]
        """
        Exist
        """
        non_exist: NotRequired[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgsDict']]
        """
        Non exist
        """
elif False:
    BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastConditionalAdvertisementArgs:
    def __init__(__self__, *,
                 exist: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgs']] = None,
                 non_exist: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgs']] = None):
        """
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgs'] exist: Exist
        :param pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgs'] non_exist: Non exist
        """
        if exist is not None:
            pulumi.set(__self__, "exist", exist)
        if non_exist is not None:
            pulumi.set(__self__, "non_exist", non_exist)

    @_builtins.property
    @pulumi.getter
    def exist(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgs']]:
        """
        Exist
        """
        return pulumi.get(self, "exist")

    @exist.setter
    def exist(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgs']]):
        pulumi.set(self, "exist", value)

    @_builtins.property
    @pulumi.getter(name="nonExist")
    def non_exist(self) -> Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgs']]:
        """
        Non exist
        """
        return pulumi.get(self, "non_exist")

    @non_exist.setter
    def non_exist(self, value: Optional[pulumi.Input['BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgs']]):
        pulumi.set(self, "non_exist", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgsDict(TypedDict):
        advertise_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advertise map
        """
        exist_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Exist map
        """
elif False:
    BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastConditionalAdvertisementExistArgs:
    def __init__(__self__, *,
                 advertise_map: Optional[pulumi.Input[_builtins.str]] = None,
                 exist_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertise_map: Advertise map
        :param pulumi.Input[_builtins.str] exist_map: Exist map
        """
        if advertise_map is not None:
            pulumi.set(__self__, "advertise_map", advertise_map)
        if exist_map is not None:
            pulumi.set(__self__, "exist_map", exist_map)

    @_builtins.property
    @pulumi.getter(name="advertiseMap")
    def advertise_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advertise map
        """
        return pulumi.get(self, "advertise_map")

    @advertise_map.setter
    def advertise_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertise_map", value)

    @_builtins.property
    @pulumi.getter(name="existMap")
    def exist_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Exist map
        """
        return pulumi.get(self, "exist_map")

    @exist_map.setter
    def exist_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exist_map", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgsDict(TypedDict):
        advertise_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Advertise map
        """
        non_exist_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Non exist map
        """
elif False:
    BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastConditionalAdvertisementNonExistArgs:
    def __init__(__self__, *,
                 advertise_map: Optional[pulumi.Input[_builtins.str]] = None,
                 non_exist_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertise_map: Advertise map
        :param pulumi.Input[_builtins.str] non_exist_map: Non exist map
        """
        if advertise_map is not None:
            pulumi.set(__self__, "advertise_map", advertise_map)
        if non_exist_map is not None:
            pulumi.set(__self__, "non_exist_map", non_exist_map)

    @_builtins.property
    @pulumi.getter(name="advertiseMap")
    def advertise_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Advertise map
        """
        return pulumi.get(self, "advertise_map")

    @advertise_map.setter
    def advertise_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertise_map", value)

    @_builtins.property
    @pulumi.getter(name="nonExistMap")
    def non_exist_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Non exist map
        """
        return pulumi.get(self, "non_exist_map")

    @non_exist_map.setter
    def non_exist_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "non_exist_map", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastFilterListArgsDict(TypedDict):
        inbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound
        """
        outbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound
        """
elif False:
    BgpFilteringProfileIpv4UnicastFilterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastFilterListArgs:
    def __init__(__self__, *,
                 inbound: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inbound: Inbound
        :param pulumi.Input[_builtins.str] outbound: Outbound
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @_builtins.property
    @pulumi.getter
    def inbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound
        """
        return pulumi.get(self, "inbound")

    @inbound.setter
    def inbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgsDict(TypedDict):
        distribute_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Distribute list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastInboundNetworkFiltersArgs:
    def __init__(__self__, *,
                 distribute_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] distribute_list: Distribute list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if distribute_list is not None:
            pulumi.set(__self__, "distribute_list", distribute_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="distributeList")
    def distribute_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Distribute list
        """
        return pulumi.get(self, "distribute_list")

    @distribute_list.setter
    def distribute_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgsDict(TypedDict):
        distribute_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Distribute list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastOutboundNetworkFiltersArgs:
    def __init__(__self__, *,
                 distribute_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] distribute_list: Distribute list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if distribute_list is not None:
            pulumi.set(__self__, "distribute_list", distribute_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="distributeList")
    def distribute_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Distribute list
        """
        return pulumi.get(self, "distribute_list")

    @distribute_list.setter
    def distribute_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpFilteringProfileIpv4UnicastRouteMapsArgsDict(TypedDict):
        inbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound
        """
        outbound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound
        """
elif False:
    BgpFilteringProfileIpv4UnicastRouteMapsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpFilteringProfileIpv4UnicastRouteMapsArgs:
    def __init__(__self__, *,
                 inbound: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inbound: Inbound
        :param pulumi.Input[_builtins.str] outbound: Outbound
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @_builtins.property
    @pulumi.getter
    def inbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound
        """
        return pulumi.get(self, "inbound")

    @inbound.setter
    def inbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound", value)


if not MYPY:
    class BgpRedistributionProfileIpv4ArgsDict(TypedDict):
        unicast: NotRequired[pulumi.Input['BgpRedistributionProfileIpv4UnicastArgsDict']]
        """
        Unicast
        """
elif False:
    BgpRedistributionProfileIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRedistributionProfileIpv4Args:
    def __init__(__self__, *,
                 unicast: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastArgs']] = None):
        """
        :param pulumi.Input['BgpRedistributionProfileIpv4UnicastArgs'] unicast: Unicast
        """
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastArgs']]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastArgs']]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class BgpRedistributionProfileIpv4UnicastArgsDict(TypedDict):
        connected: NotRequired[pulumi.Input['BgpRedistributionProfileIpv4UnicastConnectedArgsDict']]
        """
        Connected
        """
        ospf: NotRequired[pulumi.Input['BgpRedistributionProfileIpv4UnicastOspfArgsDict']]
        """
        Ospf
        """
        static: NotRequired[pulumi.Input['BgpRedistributionProfileIpv4UnicastStaticArgsDict']]
        """
        Static
        """
elif False:
    BgpRedistributionProfileIpv4UnicastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRedistributionProfileIpv4UnicastArgs:
    def __init__(__self__, *,
                 connected: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastConnectedArgs']] = None,
                 ospf: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastOspfArgs']] = None,
                 static: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastStaticArgs']] = None):
        """
        :param pulumi.Input['BgpRedistributionProfileIpv4UnicastConnectedArgs'] connected: Connected
        :param pulumi.Input['BgpRedistributionProfileIpv4UnicastOspfArgs'] ospf: Ospf
        :param pulumi.Input['BgpRedistributionProfileIpv4UnicastStaticArgs'] static: Static
        """
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if ospf is not None:
            pulumi.set(__self__, "ospf", ospf)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @_builtins.property
    @pulumi.getter
    def connected(self) -> Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastConnectedArgs']]:
        """
        Connected
        """
        return pulumi.get(self, "connected")

    @connected.setter
    def connected(self, value: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastConnectedArgs']]):
        pulumi.set(self, "connected", value)

    @_builtins.property
    @pulumi.getter
    def ospf(self) -> Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastOspfArgs']]:
        """
        Ospf
        """
        return pulumi.get(self, "ospf")

    @ospf.setter
    def ospf(self, value: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastOspfArgs']]):
        pulumi.set(self, "ospf", value)

    @_builtins.property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastStaticArgs']]:
        """
        Static
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input['BgpRedistributionProfileIpv4UnicastStaticArgs']]):
        pulumi.set(self, "static", value)


if not MYPY:
    class BgpRedistributionProfileIpv4UnicastConnectedArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable connected route redistribution?
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route metric
        """
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    BgpRedistributionProfileIpv4UnicastConnectedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRedistributionProfileIpv4UnicastConnectedArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable connected route redistribution?
        :param pulumi.Input[_builtins.int] metric: Route metric
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable connected route redistribution?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class BgpRedistributionProfileIpv4UnicastOspfArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable OSPF route redistribution?
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route metric
        """
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    BgpRedistributionProfileIpv4UnicastOspfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRedistributionProfileIpv4UnicastOspfArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable OSPF route redistribution?
        :param pulumi.Input[_builtins.int] metric: Route metric
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable OSPF route redistribution?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class BgpRedistributionProfileIpv4UnicastStaticArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable static route redistribution?
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route metric
        """
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    BgpRedistributionProfileIpv4UnicastStaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRedistributionProfileIpv4UnicastStaticArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable static route redistribution?
        :param pulumi.Input[_builtins.int] metric: Route metric
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable static route redistribution?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpArgsDict(TypedDict):
        ospf: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfArgsDict']]
        """
        Ospf
        """
        rib: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibArgsDict']]
        """
        BGP Root RIB

        >  **Note:** You must specify exactly one of `ospf` and `rib`.
        """
elif False:
    BgpRouteMapRedistributionBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpArgs:
    def __init__(__self__, *,
                 ospf: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfArgs']] = None,
                 rib: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfArgs'] ospf: Ospf
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibArgs'] rib: BGP Root RIB
               
               >  **Note:** You must specify exactly one of `ospf` and `rib`.
        """
        if ospf is not None:
            pulumi.set(__self__, "ospf", ospf)
        if rib is not None:
            pulumi.set(__self__, "rib", rib)

    @_builtins.property
    @pulumi.getter
    def ospf(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfArgs']]:
        """
        Ospf
        """
        return pulumi.get(self, "ospf")

    @ospf.setter
    def ospf(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfArgs']]):
        pulumi.set(self, "ospf", value)

    @_builtins.property
    @pulumi.getter
    def rib(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibArgs']]:
        """
        BGP Root RIB

        >  **Note:** You must specify exactly one of `ospf` and `rib`.
        """
        return pulumi.get(self, "rib")

    @rib.setter
    def rib(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibArgs']]):
        pulumi.set(self, "rib", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapArgsDict']]]]
        """
        BGP Root OSPF Route maps
        """
elif False:
    BgpRouteMapRedistributionBgpOspfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapArgs']]] route_maps: BGP Root OSPF Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapArgs']]]]:
        """
        BGP Root OSPF Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root OSPF Route maps Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetArgsDict']]
        """
        BGP Root OSPF Set
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: BGP Root OSPF Route maps Action
        :param pulumi.Input[_builtins.str] description: BGP Root OSPF Route maps Description
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: BGP Root OSPF Route maps Sequence number
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetArgs'] set: BGP Root OSPF Set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root OSPF Route maps Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetArgs']]:
        """
        BGP Root OSPF Set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapMatchArgsDict(TypedDict):
        as_path_access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match AS path access list
        """
        extended_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        EBGP Root OSPF Route maps match xtended community
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match Interface
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4ArgsDict']]
        """
        BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object
        """
        large_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match Large community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root OSPF Route maps match Local preference
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root OSPF Route maps match Metric
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match Origin
        """
        peer: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match Peer
        """
        regular_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match Regular community
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root OSPF Route maps match Tag
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapMatchArgs:
    def __init__(__self__, *,
                 as_path_access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 extended_community: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Args']] = None,
                 large_community: Optional[pulumi.Input[_builtins.str]] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 peer: Optional[pulumi.Input[_builtins.str]] = None,
                 regular_community: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] as_path_access_list: BGP Root OSPF Route maps match AS path access list
        :param pulumi.Input[_builtins.str] extended_community: EBGP Root OSPF Route maps match xtended community
        :param pulumi.Input[_builtins.str] interface: BGP Root OSPF Route maps match Interface
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Args'] ipv4: BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object
        :param pulumi.Input[_builtins.str] large_community: BGP Root OSPF Route maps match Large community
        :param pulumi.Input[_builtins.int] local_preference: BGP Root OSPF Route maps match Local preference
        :param pulumi.Input[_builtins.int] metric: BGP Root OSPF Route maps match Metric
        :param pulumi.Input[_builtins.str] origin: BGP Root OSPF Route maps match Origin
        :param pulumi.Input[_builtins.str] peer: BGP Root OSPF Route maps match Peer
        :param pulumi.Input[_builtins.str] regular_community: BGP Root OSPF Route maps match Regular community
        :param pulumi.Input[_builtins.int] tag: BGP Root OSPF Route maps match Tag
        """
        if as_path_access_list is not None:
            pulumi.set(__self__, "as_path_access_list", as_path_access_list)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if large_community is not None:
            pulumi.set(__self__, "large_community", large_community)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if regular_community is not None:
            pulumi.set(__self__, "regular_community", regular_community)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="asPathAccessList")
    def as_path_access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match AS path access list
        """
        return pulumi.get(self, "as_path_access_list")

    @as_path_access_list.setter
    def as_path_access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "as_path_access_list", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        EBGP Root OSPF Route maps match xtended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Args']]:
        """
        BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="largeCommunity")
    def large_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match Large community
        """
        return pulumi.get(self, "large_community")

    @large_community.setter
    def large_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "large_community", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root OSPF Route maps match Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root OSPF Route maps match Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match Peer
        """
        return pulumi.get(self, "peer")

    @peer.setter
    def peer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer", value)

    @_builtins.property
    @pulumi.getter(name="regularCommunity")
    def regular_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match Regular community
        """
        return pulumi.get(self, "regular_community")

    @regular_community.setter
    def regular_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regular_community", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root OSPF Route maps match Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgsDict']]
        """
        BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object address
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgsDict']]
        """
        BGP Root OSPF Route maps match  bgp-route-map-redistributions ipv4 object next*hop
        """
        route_source: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgsDict']]
        """
        BGP Root OSPF Route maps ipv4 bgp-route-map-redistributions ipv4 object route*source
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgs']] = None,
                 route_source: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgs'] address: BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object address
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgs'] next_hop: BGP Root OSPF Route maps match  bgp-route-map-redistributions ipv4 object next*hop
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgs'] route_source: BGP Root OSPF Route maps ipv4 bgp-route-map-redistributions ipv4 object route*source
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if route_source is not None:
            pulumi.set(__self__, "route_source", route_source)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgs']]:
        """
        BGP Root OSPF Route maps match bgp-route-map-redistributions ipv4 object address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgs']]:
        """
        BGP Root OSPF Route maps match  bgp-route-map-redistributions ipv4 object next*hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter(name="routeSource")
    def route_source(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgs']]:
        """
        BGP Root OSPF Route maps ipv4 bgp-route-map-redistributions ipv4 object route*source
        """
        return pulumi.get(self, "route_source")

    @route_source.setter
    def route_source(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgs']]):
        pulumi.set(self, "route_source", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match ipv4 Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps match ipv4 Prefix list
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4AddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: BGP Root OSPF Route maps match ipv4 Access list
        :param pulumi.Input[_builtins.str] prefix_list: BGP Root OSPF Route maps match ipv4 Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match ipv4 Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps match ipv4 Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps ipv4 next_vr hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps ipv4 next hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4NextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: BGP Root OSPF Route maps ipv4 next_vr hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: BGP Root OSPF Route maps ipv4 next hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps ipv4 next_vr hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps ipv4 next hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps ipv4 route source Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps ipv4 route source Prefix list
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapMatchIpv4RouteSourceArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: BGP Root OSPF Route maps ipv4 route source Access list
        :param pulumi.Input[_builtins.str] prefix_list: BGP Root OSPF Route maps ipv4 route source Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps ipv4 route source Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps ipv4 route source Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapSetArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgsDict']]
        """
        Metric
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps set Metric type
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root OSPF Route maps set Tag
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapSetArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgs']] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgs'] metric: Metric
        :param pulumi.Input[_builtins.str] metric_type: BGP Root OSPF Route maps set Metric type
        :param pulumi.Input[_builtins.int] tag: BGP Root OSPF Route maps set Tag
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgs']]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps set Metric type
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root OSPF Route maps set Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root OSPF Route maps set Metric action
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root OSPF Route maps set Metric value
        """
elif False:
    BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpOspfRouteMapSetMetricArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: BGP Root OSPF Route maps set Metric action
        :param pulumi.Input[_builtins.int] value: BGP Root OSPF Route maps set Metric value
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root OSPF Route maps set Metric action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root OSPF Route maps set Metric value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapArgsDict']]]]
        """
        BGP Root RIB Route maps
        """
elif False:
    BgpRouteMapRedistributionBgpRibArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapArgs']]] route_maps: BGP Root RIB Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapArgs']]]]:
        """
        BGP Root RIB Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchArgsDict']]
        """
        match attribute for BG Rib route map
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root RIB Route maps Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapSetArgsDict']]
        """
        Set attributes for BGP route map
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: BGP Root RIB Route maps Action
        :param pulumi.Input[_builtins.str] description: BGP Root RIB Route maps Description
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchArgs'] match: match attribute for BG Rib route map
        :param pulumi.Input[_builtins.int] name: BGP Root RIB Route maps Sequence number
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapSetArgs'] set: Set attributes for BGP route map
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchArgs']]:
        """
        match attribute for BG Rib route map
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root RIB Route maps Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapSetArgs']]:
        """
        Set attributes for BGP route map
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapMatchArgsDict(TypedDict):
        as_path_access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match AS path access list
        """
        extended_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match Extended community
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match Interface
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4ArgsDict']]
        """
        BGP Route Map Redistributions Root BGP rib Route Map IPv4
        """
        large_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match Large community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root RIB Route maps match Local preference
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root RIB Route maps match Metric
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match Origin
        """
        peer: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match Peer
        """
        regular_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match Regular community
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP Root RIB Route maps match Tag
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapMatchArgs:
    def __init__(__self__, *,
                 as_path_access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 extended_community: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Args']] = None,
                 large_community: Optional[pulumi.Input[_builtins.str]] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 peer: Optional[pulumi.Input[_builtins.str]] = None,
                 regular_community: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] as_path_access_list: BGP Root RIB Route maps match AS path access list
        :param pulumi.Input[_builtins.str] extended_community: BGP Root RIB Route maps match Extended community
        :param pulumi.Input[_builtins.str] interface: BGP Root RIB Route maps match Interface
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Args'] ipv4: BGP Route Map Redistributions Root BGP rib Route Map IPv4
        :param pulumi.Input[_builtins.str] large_community: BGP Root RIB Route maps match Large community
        :param pulumi.Input[_builtins.int] local_preference: BGP Root RIB Route maps match Local preference
        :param pulumi.Input[_builtins.int] metric: BGP Root RIB Route maps match Metric
        :param pulumi.Input[_builtins.str] origin: BGP Root RIB Route maps match Origin
        :param pulumi.Input[_builtins.str] peer: BGP Root RIB Route maps match Peer
        :param pulumi.Input[_builtins.str] regular_community: BGP Root RIB Route maps match Regular community
        :param pulumi.Input[_builtins.int] tag: BGP Root RIB Route maps match Tag
        """
        if as_path_access_list is not None:
            pulumi.set(__self__, "as_path_access_list", as_path_access_list)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if large_community is not None:
            pulumi.set(__self__, "large_community", large_community)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if regular_community is not None:
            pulumi.set(__self__, "regular_community", regular_community)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="asPathAccessList")
    def as_path_access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match AS path access list
        """
        return pulumi.get(self, "as_path_access_list")

    @as_path_access_list.setter
    def as_path_access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "as_path_access_list", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Args']]:
        """
        BGP Route Map Redistributions Root BGP rib Route Map IPv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="largeCommunity")
    def large_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match Large community
        """
        return pulumi.get(self, "large_community")

    @large_community.setter
    def large_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "large_community", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root RIB Route maps match Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root RIB Route maps match Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match Peer
        """
        return pulumi.get(self, "peer")

    @peer.setter
    def peer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer", value)

    @_builtins.property
    @pulumi.getter(name="regularCommunity")
    def regular_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match Regular community
        """
        return pulumi.get(self, "regular_community")

    @regular_community.setter
    def regular_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regular_community", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP Root RIB Route maps match Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgsDict']]
        """
        bgp-route-map-redistributions ipv4 rib object address
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgsDict']]
        """
        bgp-route-map-redistributions ipv4 rib object next*hop
        """
        route_source: NotRequired[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgsDict']]
        """
        Route source
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgs']] = None,
                 route_source: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgs'] address: bgp-route-map-redistributions ipv4 rib object address
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgs'] next_hop: bgp-route-map-redistributions ipv4 rib object next*hop
        :param pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgs'] route_source: Route source
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if route_source is not None:
            pulumi.set(__self__, "route_source", route_source)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgs']]:
        """
        bgp-route-map-redistributions ipv4 rib object address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgs']]:
        """
        bgp-route-map-redistributions ipv4 rib object next*hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter(name="routeSource")
    def route_source(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgs']]:
        """
        Route source
        """
        return pulumi.get(self, "route_source")

    @route_source.setter
    def route_source(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgs']]):
        pulumi.set(self, "route_source", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match ipv Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match ipv Prefix list
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4AddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: BGP Root RIB Route maps match ipv Access list
        :param pulumi.Input[_builtins.str] prefix_list: BGP Root RIB Route maps match ipv Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match ipv Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match ipv Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match ipv next hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match ipv next hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4NextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: BGP Root RIB Route maps match ipv next hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: BGP Root RIB Route maps match ipv next hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match ipv next hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match ipv next hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match ipv route source Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps match ipv route source Prefix list
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapMatchIpv4RouteSourceArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: BGP Root RIB Route maps match ipv route source Access list
        :param pulumi.Input[_builtins.str] prefix_list: BGP Root RIB Route maps match ipv route source Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match ipv route source Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps match ipv route source Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionBgpRibRouteMapSetArgsDict(TypedDict):
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP Root RIB Route maps set Source address
        """
elif False:
    BgpRouteMapRedistributionBgpRibRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionBgpRibRouteMapSetArgs:
    def __init__(__self__, *,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_address: BGP Root RIB Route maps set Source address
        """
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP Root RIB Route maps set Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpArgsDict']]
        """
        Connected Static Root BGP
        """
        ospf: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfArgsDict']]
        """
        Ospf

        >  **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
        """
        rib: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibArgsDict']]
        """
        Rib

        >  **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticArgs:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpArgs']] = None,
                 ospf: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfArgs']] = None,
                 rib: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpArgs'] bgp: Connected Static Root BGP
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfArgs'] ospf: Ospf
               
               >  **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibArgs'] rib: Rib
               
               >  **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if ospf is not None:
            pulumi.set(__self__, "ospf", ospf)
        if rib is not None:
            pulumi.set(__self__, "rib", rib)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpArgs']]:
        """
        Connected Static Root BGP
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpArgs']]):
        pulumi.set(self, "bgp", value)

    @_builtins.property
    @pulumi.getter
    def ospf(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfArgs']]:
        """
        Ospf

        >  **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
        """
        return pulumi.get(self, "ospf")

    @ospf.setter
    def ospf(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfArgs']]):
        pulumi.set(self, "ospf", value)

    @_builtins.property
    @pulumi.getter
    def rib(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibArgs']]:
        """
        Rib

        >  **Note:** You must specify exactly one of `bgp`, `ospf`, and `rib`.
        """
        return pulumi.get(self, "rib")

    @rib.setter
    def rib(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibArgs']]):
        pulumi.set(self, "rib", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgsDict']]]]
        """
        Connected Static BGP Route maps
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgs']]] route_maps: Connected Static BGP Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgs']]]]:
        """
        Connected Static BGP Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgsDict']]
        """
        Set
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Connected Static BGP Route maps Action
        :param pulumi.Input[_builtins.str] description: Connected Static BGP Route maps Description
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: Connected Static BGP Route maps Sequence number
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgs'] set: Set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgs']]:
        """
        Set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps match Interface
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4ArgsDict']]
        """
        bgp-route-map-redistributions connected-static ipv4
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps match Metric
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Args']] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Connected Static BGP Route maps match Interface
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Args'] ipv4: bgp-route-map-redistributions connected-static ipv4
        :param pulumi.Input[_builtins.int] metric: Connected Static BGP Route maps match Metric
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps match Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Args']]:
        """
        bgp-route-map-redistributions connected-static ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps match Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgsDict']]
        """
        Address
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgsDict']]
        """
        Next hop
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgs'] address: Address
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgs'] next_hop: Next hop
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgs']]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgs']]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgs']]):
        pulumi.set(self, "next_hop", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps match ip4 Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps match ip4  Prefix list
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4AddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Connected Static BGP Route maps match ip4 Access list
        :param pulumi.Input[_builtins.str] prefix_list: Connected Static BGP Route maps match ip4  Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps match ip4 Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps match ip4  Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps match ip4 next hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps match ip4 next hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapMatchIpv4NextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Connected Static BGP Route maps match ip4 next hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: Connected Static BGP Route maps match ip4 next hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps match ip4 next hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps match ip4 next hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgsDict(TypedDict):
        aggregator: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgsDict']]
        """
        bgp-route-map-redistributions connected*static aggregator
        """
        aspath_prepends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Connected Static BGP Route maps set AS numbers
        """
        atomic_aggregate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Connected Static BGP Route maps set Enable BGP atomic aggregate?
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4ArgsDict']]
        """
        Ipv4
        """
        large_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Connected Static  BGP Route maps set Large communities
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps set Local preference
        """
        metric: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgsDict']]
        """
        Metric
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps set Origin
        """
        originator_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps set Originator ID
        """
        regular_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Connected Static  BGP Route maps set Regular communities
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps set Tag
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps set Weight
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgs']] = None,
                 aspath_prepends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 atomic_aggregate: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4Args']] = None,
                 large_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgs']] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 originator_id: Optional[pulumi.Input[_builtins.str]] = None,
                 regular_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgs'] aggregator: bgp-route-map-redistributions connected*static aggregator
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] aspath_prepends: Connected Static BGP Route maps set AS numbers
        :param pulumi.Input[_builtins.bool] atomic_aggregate: Connected Static BGP Route maps set Enable BGP atomic aggregate?
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4Args'] ipv4: Ipv4
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] large_communities: Connected Static  BGP Route maps set Large communities
        :param pulumi.Input[_builtins.int] local_preference: Connected Static BGP Route maps set Local preference
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgs'] metric: Metric
        :param pulumi.Input[_builtins.str] origin: Connected Static BGP Route maps set Origin
        :param pulumi.Input[_builtins.str] originator_id: Connected Static BGP Route maps set Originator ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regular_communities: Connected Static  BGP Route maps set Regular communities
        :param pulumi.Input[_builtins.int] tag: Connected Static BGP Route maps set Tag
        :param pulumi.Input[_builtins.int] weight: Connected Static BGP Route maps set Weight
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if aspath_prepends is not None:
            pulumi.set(__self__, "aspath_prepends", aspath_prepends)
        if atomic_aggregate is not None:
            pulumi.set(__self__, "atomic_aggregate", atomic_aggregate)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if large_communities is not None:
            pulumi.set(__self__, "large_communities", large_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if originator_id is not None:
            pulumi.set(__self__, "originator_id", originator_id)
        if regular_communities is not None:
            pulumi.set(__self__, "regular_communities", regular_communities)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgs']]:
        """
        bgp-route-map-redistributions connected*static aggregator
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgs']]):
        pulumi.set(self, "aggregator", value)

    @_builtins.property
    @pulumi.getter(name="aspathPrepends")
    def aspath_prepends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Connected Static BGP Route maps set AS numbers
        """
        return pulumi.get(self, "aspath_prepends")

    @aspath_prepends.setter
    def aspath_prepends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "aspath_prepends", value)

    @_builtins.property
    @pulumi.getter(name="atomicAggregate")
    def atomic_aggregate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Connected Static BGP Route maps set Enable BGP atomic aggregate?
        """
        return pulumi.get(self, "atomic_aggregate")

    @atomic_aggregate.setter
    def atomic_aggregate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "atomic_aggregate", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="largeCommunities")
    def large_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Connected Static  BGP Route maps set Large communities
        """
        return pulumi.get(self, "large_communities")

    @large_communities.setter
    def large_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "large_communities", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps set Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgs']]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps set Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="originatorId")
    def originator_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps set Originator ID
        """
        return pulumi.get(self, "originator_id")

    @originator_id.setter
    def originator_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "originator_id", value)

    @_builtins.property
    @pulumi.getter(name="regularCommunities")
    def regular_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Connected Static  BGP Route maps set Regular communities
        """
        return pulumi.get(self, "regular_communities")

    @regular_communities.setter
    def regular_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regular_communities", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps set Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps set Weight
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgsDict(TypedDict):
        as_: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps set Aggregator AS
        """
        router_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps set Router ID
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetAggregatorArgs:
    def __init__(__self__, *,
                 as_: Optional[pulumi.Input[_builtins.int]] = None,
                 router_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] as_: Connected Static BGP Route maps set Aggregator AS
        :param pulumi.Input[_builtins.str] router_id: Connected Static BGP Route maps set Router ID
        """
        if as_ is not None:
            pulumi.set(__self__, "as_", as_)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="as")
    def as_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps set Aggregator AS
        """
        return pulumi.get(self, "as_")

    @as_.setter
    def as_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "as_", value)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps set Router ID
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "router_id", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4ArgsDict(TypedDict):
        next_hop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps set Next ipv4 hop
        """
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps set ipv4 Source address
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetIpv4Args:
    def __init__(__self__, *,
                 next_hop: Optional[pulumi.Input[_builtins.str]] = None,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] next_hop: Connected Static BGP Route maps set Next ipv4 hop
        :param pulumi.Input[_builtins.str] source_address: Connected Static BGP Route maps set ipv4 Source address
        """
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps set Next ipv4 hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps set ipv4 Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Route maps set Metric action
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Route maps set Metric value
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticBgpRouteMapSetMetricArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Connected Static BGP Route maps set Metric action
        :param pulumi.Input[_builtins.int] value: Connected Static BGP Route maps set Metric value
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Route maps set Metric action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Route maps set Metric value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgsDict']]]]
        """
        Connected Static  BGP OSPF Route maps
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgs']]] route_maps: Connected Static  BGP OSPF Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgs']]]]:
        """
        Connected Static  BGP OSPF Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP OSPF Route map Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgsDict']]
        """
        Connected Static Root OSPF Set
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Connected Static BGP OSPF Route map Action
        :param pulumi.Input[_builtins.str] description: Connected Static BGP OSPF Route map Description
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: Connected Static BGP OSPF Route map Sequence number
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgs'] set: Connected Static Root OSPF Set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP OSPF Route map Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgs']]:
        """
        Connected Static Root OSPF Set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map Interface
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4ArgsDict']]
        """
        bgp-route-map-redistributions connected-static match ipv4
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP OSPF Route map Metric
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Args']] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Connected Static BGP OSPF Route map Interface
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Args'] ipv4: bgp-route-map-redistributions connected-static match ipv4
        :param pulumi.Input[_builtins.int] metric: Connected Static BGP OSPF Route map Metric
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Args']]:
        """
        bgp-route-map-redistributions connected-static match ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP OSPF Route map Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgsDict']]
        """
        Connected Static Root OSPF Address
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgsDict']]
        """
        Next hop
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgs'] address: Connected Static Root OSPF Address
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgs'] next_hop: Next hop
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgs']]:
        """
        Connected Static Root OSPF Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgs']]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgs']]):
        pulumi.set(self, "next_hop", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map ipv4 Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map ipv4 Prefix list
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4AddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Connected Static BGP OSPF Route map ipv4 Access list
        :param pulumi.Input[_builtins.str] prefix_list: Connected Static BGP OSPF Route map ipv4 Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map ipv4 Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map ipv4 Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map ipv4 next hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map ipv4 next hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapMatchIpv4NextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Connected Static BGP OSPF Route map ipv4 next hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: Connected Static BGP OSPF Route map ipv4 next hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map ipv4 next hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map ipv4 next hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgsDict']]
        """
        Metric
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map set Metric type
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP OSPF Route map set Tag
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgs']] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgs'] metric: Metric
        :param pulumi.Input[_builtins.str] metric_type: Connected Static BGP OSPF Route map set Metric type
        :param pulumi.Input[_builtins.int] tag: Connected Static BGP OSPF Route map set Tag
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgs']]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map set Metric type
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP OSPF Route map set Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP OSPF Route map set Metric action
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP OSPF Route map set Metric value
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticOspfRouteMapSetMetricArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Connected Static BGP OSPF Route map set Metric action
        :param pulumi.Input[_builtins.int] value: Connected Static BGP OSPF Route map set Metric value
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP OSPF Route map set Metric action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP OSPF Route map set Metric value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapArgsDict']]]]
        """
        Connected Static BGP Rib Route maps
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapArgs']]] route_maps: Connected Static BGP Rib Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapArgs']]]]:
        """
        Connected Static BGP Rib Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Rib Route maps Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgsDict']]
        """
        Connected Static Root RIB set
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Connected Static BGP Rib Route maps Action
        :param pulumi.Input[_builtins.str] description: Connected Static BGP Rib Route maps Description
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: Connected Static BGP Rib Route maps Sequence number
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgs'] set: Connected Static Root RIB set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Rib Route maps Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgs']]:
        """
        Connected Static Root RIB set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps Interface
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4ArgsDict']]
        """
        Ipv4
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Connected Static BGP Rib Route maps Metric
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Args']] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Connected Static BGP Rib Route maps Interface
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Args'] ipv4: Ipv4
        :param pulumi.Input[_builtins.int] metric: Connected Static BGP Rib Route maps Metric
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Connected Static BGP Rib Route maps Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgsDict']]
        """
        Connected Static BGP Rib Route maps ipv4 address
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgsDict']]
        """
        Next hop
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgs'] address: Connected Static BGP Rib Route maps ipv4 address
        :param pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgs'] next_hop: Next hop
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgs']]:
        """
        Connected Static BGP Rib Route maps ipv4 address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgs']]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgs']]):
        pulumi.set(self, "next_hop", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps ipv4 Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps ipv4 Prefix list
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4AddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Connected Static BGP Rib Route maps ipv4 Access list
        :param pulumi.Input[_builtins.str] prefix_list: Connected Static BGP Rib Route maps ipv4 Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps ipv4 Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps ipv4 Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps ipv4 nect hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route maps ipv4 next hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibRouteMapMatchIpv4NextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Connected Static BGP Rib Route maps ipv4 nect hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: Connected Static BGP Rib Route maps ipv4 next hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps ipv4 nect hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route maps ipv4 next hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgsDict(TypedDict):
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connected Static BGP Rib Route Map Distribution Source address
        """
elif False:
    BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionConnectedStaticRibRouteMapSetArgs:
    def __init__(__self__, *,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_address: Connected Static BGP Rib Route Map Distribution Source address
        """
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connected Static BGP Rib Route Map Distribution Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpArgsDict']]
        """
        OSPF Root BGP
        """
        rib: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfRibArgsDict']]
        """
        Rib

        >  **Note:** You must specify exactly one of `bgp` and `rib`.
        """
elif False:
    BgpRouteMapRedistributionOspfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfArgs:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpArgs']] = None,
                 rib: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpArgs'] bgp: OSPF Root BGP
        :param pulumi.Input['BgpRouteMapRedistributionOspfRibArgs'] rib: Rib
               
               >  **Note:** You must specify exactly one of `bgp` and `rib`.
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if rib is not None:
            pulumi.set(__self__, "rib", rib)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpArgs']]:
        """
        OSPF Root BGP
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpArgs']]):
        pulumi.set(self, "bgp", value)

    @_builtins.property
    @pulumi.getter
    def rib(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibArgs']]:
        """
        Rib

        >  **Note:** You must specify exactly one of `bgp` and `rib`.
        """
        return pulumi.get(self, "rib")

    @rib.setter
    def rib(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibArgs']]):
        pulumi.set(self, "rib", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapArgsDict']]]]
        """
        OSPF BGP Route maps
        """
elif False:
    BgpRouteMapRedistributionOspfBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapArgs']]] route_maps: OSPF BGP Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapArgs']]]]:
        """
        OSPF BGP Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetArgsDict']]
        """
        OSPF Root Set
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: OSPF BGP Route maps Action
        :param pulumi.Input[_builtins.str] description: OSPF BGP Route maps Description
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: OSPF BGP Route maps Sequence number
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetArgs'] set: OSPF Root Set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetArgs']]:
        """
        OSPF Root Set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapMatchArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgsDict']]
        """
        bgp-route-map-redistributions ospf address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps Interface
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps Metric
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgsDict']]
        """
        bgp-route-map-redistributions ospf next*hop
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps Tag
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapMatchArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgs']] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgs']] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgs'] address: bgp-route-map-redistributions ospf address
        :param pulumi.Input[_builtins.str] interface: OSPF BGP Route maps Interface
        :param pulumi.Input[_builtins.int] metric: OSPF BGP Route maps Metric
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgs'] next_hop: bgp-route-map-redistributions ospf next*hop
        :param pulumi.Input[_builtins.int] tag: OSPF BGP Route maps Tag
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgs']]:
        """
        bgp-route-map-redistributions ospf address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgs']]:
        """
        bgp-route-map-redistributions ospf next*hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps match Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps match Prefix list
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapMatchAddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: OSPF BGP Route maps match Access list
        :param pulumi.Input[_builtins.str] prefix_list: OSPF BGP Route maps match Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps match Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps match Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps next_hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps next_hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapMatchNextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: OSPF BGP Route maps next_hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: OSPF BGP Route maps next_hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps next_hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps next_hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapSetArgsDict(TypedDict):
        aggregator: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgsDict']]
        """
        bgp-route-map-redistributions set aggregator
        """
        aspath_prepends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        OSPF BGP Route maps set AS numbers
        """
        atomic_aggregate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        OSPF BGP Route maps set Enable BGP atomic aggregate?
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4ArgsDict']]
        """
        Ipv4
        """
        large_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        OSPF BGP Route maps set Large communities
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps set Local preference
        """
        metric: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgsDict']]
        """
        Metric
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps set Origin
        """
        originator_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps set Originator ID
        """
        regular_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        OSPF BGP Route maps set Regular communities
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps set Tag
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps set Weight
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapSetArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgs']] = None,
                 aspath_prepends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 atomic_aggregate: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4Args']] = None,
                 large_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgs']] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 originator_id: Optional[pulumi.Input[_builtins.str]] = None,
                 regular_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgs'] aggregator: bgp-route-map-redistributions set aggregator
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] aspath_prepends: OSPF BGP Route maps set AS numbers
        :param pulumi.Input[_builtins.bool] atomic_aggregate: OSPF BGP Route maps set Enable BGP atomic aggregate?
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4Args'] ipv4: Ipv4
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] large_communities: OSPF BGP Route maps set Large communities
        :param pulumi.Input[_builtins.int] local_preference: OSPF BGP Route maps set Local preference
        :param pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgs'] metric: Metric
        :param pulumi.Input[_builtins.str] origin: OSPF BGP Route maps set Origin
        :param pulumi.Input[_builtins.str] originator_id: OSPF BGP Route maps set Originator ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regular_communities: OSPF BGP Route maps set Regular communities
        :param pulumi.Input[_builtins.int] tag: OSPF BGP Route maps set Tag
        :param pulumi.Input[_builtins.int] weight: OSPF BGP Route maps set Weight
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if aspath_prepends is not None:
            pulumi.set(__self__, "aspath_prepends", aspath_prepends)
        if atomic_aggregate is not None:
            pulumi.set(__self__, "atomic_aggregate", atomic_aggregate)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if large_communities is not None:
            pulumi.set(__self__, "large_communities", large_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if originator_id is not None:
            pulumi.set(__self__, "originator_id", originator_id)
        if regular_communities is not None:
            pulumi.set(__self__, "regular_communities", regular_communities)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgs']]:
        """
        bgp-route-map-redistributions set aggregator
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgs']]):
        pulumi.set(self, "aggregator", value)

    @_builtins.property
    @pulumi.getter(name="aspathPrepends")
    def aspath_prepends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        OSPF BGP Route maps set AS numbers
        """
        return pulumi.get(self, "aspath_prepends")

    @aspath_prepends.setter
    def aspath_prepends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "aspath_prepends", value)

    @_builtins.property
    @pulumi.getter(name="atomicAggregate")
    def atomic_aggregate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        OSPF BGP Route maps set Enable BGP atomic aggregate?
        """
        return pulumi.get(self, "atomic_aggregate")

    @atomic_aggregate.setter
    def atomic_aggregate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "atomic_aggregate", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="largeCommunities")
    def large_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        OSPF BGP Route maps set Large communities
        """
        return pulumi.get(self, "large_communities")

    @large_communities.setter
    def large_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "large_communities", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps set Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgs']]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps set Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="originatorId")
    def originator_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps set Originator ID
        """
        return pulumi.get(self, "originator_id")

    @originator_id.setter
    def originator_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "originator_id", value)

    @_builtins.property
    @pulumi.getter(name="regularCommunities")
    def regular_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        OSPF BGP Route maps set Regular communities
        """
        return pulumi.get(self, "regular_communities")

    @regular_communities.setter
    def regular_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regular_communities", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps set Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps set Weight
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgsDict(TypedDict):
        as_: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps set Aggregator AS
        """
        router_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps set Router ID
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapSetAggregatorArgs:
    def __init__(__self__, *,
                 as_: Optional[pulumi.Input[_builtins.int]] = None,
                 router_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] as_: OSPF BGP Route maps set Aggregator AS
        :param pulumi.Input[_builtins.str] router_id: OSPF BGP Route maps set Router ID
        """
        if as_ is not None:
            pulumi.set(__self__, "as_", as_)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="as")
    def as_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps set Aggregator AS
        """
        return pulumi.get(self, "as_")

    @as_.setter
    def as_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "as_", value)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps set Router ID
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "router_id", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4ArgsDict(TypedDict):
        next_hop: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps set ipv4 Next hop
        """
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps set ipv4 Source address
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapSetIpv4Args:
    def __init__(__self__, *,
                 next_hop: Optional[pulumi.Input[_builtins.str]] = None,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] next_hop: OSPF BGP Route maps set ipv4 Next hop
        :param pulumi.Input[_builtins.str] source_address: OSPF BGP Route maps set ipv4 Source address
        """
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps set ipv4 Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps set ipv4 Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF BGP Route maps set Metric action
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF BGP Route maps set Metric value
        """
elif False:
    BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfBgpRouteMapSetMetricArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: OSPF BGP Route maps set Metric action
        :param pulumi.Input[_builtins.int] value: OSPF BGP Route maps set Metric value
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF BGP Route maps set Metric action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF BGP Route maps set Metric value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfRibArgsDict(TypedDict):
        route_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapArgsDict']]]]
        """
        OSPF RIB Route maps set Route maps
        """
elif False:
    BgpRouteMapRedistributionOspfRibArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfRibArgs:
    def __init__(__self__, *,
                 route_maps: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapArgs']]] route_maps: OSPF RIB Route maps set Route maps
        """
        if route_maps is not None:
            pulumi.set(__self__, "route_maps", route_maps)

    @_builtins.property
    @pulumi.getter(name="routeMaps")
    def route_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapArgs']]]]:
        """
        OSPF RIB Route maps set Route maps
        """
        return pulumi.get(self, "route_maps")

    @route_maps.setter
    def route_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapArgs']]]]):
        pulumi.set(self, "route_maps", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfRibRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF RIB Route mapsSequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapSetArgsDict']]
        """
        OSPF RIB Route maps set
        """
elif False:
    BgpRouteMapRedistributionOspfRibRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfRibRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: OSPF RIB Route maps Action
        :param pulumi.Input[_builtins.str] description: OSPF RIB Route maps Description
        :param pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: OSPF RIB Route mapsSequence number
        :param pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapSetArgs'] set: OSPF RIB Route maps set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF RIB Route mapsSequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapSetArgs']]:
        """
        OSPF RIB Route maps set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfRibRouteMapMatchArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgsDict']]
        """
        OSPF RIB Route maps address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps Interface
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF RIB Route maps Metric
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgsDict']]
        """
        OSPF RIB Route maps next*hop
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        OSPF RIB Route maps tag
        """
elif False:
    BgpRouteMapRedistributionOspfRibRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfRibRouteMapMatchArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgs']] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgs']] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgs'] address: OSPF RIB Route maps address
        :param pulumi.Input[_builtins.str] interface: OSPF RIB Route maps Interface
        :param pulumi.Input[_builtins.int] metric: OSPF RIB Route maps Metric
        :param pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgs'] next_hop: OSPF RIB Route maps next*hop
        :param pulumi.Input[_builtins.int] tag: OSPF RIB Route maps tag
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgs']]:
        """
        OSPF RIB Route maps address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF RIB Route maps Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgs']]:
        """
        OSPF RIB Route maps next*hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        OSPF RIB Route maps tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps address Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps address Prefix list
        """
elif False:
    BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfRibRouteMapMatchAddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: OSPF RIB Route maps address Access list
        :param pulumi.Input[_builtins.str] prefix_list: OSPF RIB Route maps address Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps address Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps address Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps next_hop Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps next_hop Prefix list
        """
elif False:
    BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfRibRouteMapMatchNextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: OSPF RIB Route maps next_hop Access list
        :param pulumi.Input[_builtins.str] prefix_list: OSPF RIB Route maps next_hop Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps next_hop Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps next_hop Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRedistributionOspfRibRouteMapSetArgsDict(TypedDict):
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        OSPF RIB Route maps set Source address
        """
elif False:
    BgpRouteMapRedistributionOspfRibRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRedistributionOspfRibRouteMapSetArgs:
    def __init__(__self__, *,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_address: OSPF RIB Route maps set Source address
        """
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OSPF RIB Route maps set Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class BgpRouteMapRouteMapArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        match: NotRequired[pulumi.Input['BgpRouteMapRouteMapMatchArgsDict']]
        """
        Match
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
        set: NotRequired[pulumi.Input['BgpRouteMapRouteMapSetArgsDict']]
        """
        Set
        """
elif False:
    BgpRouteMapRouteMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['BgpRouteMapRouteMapMatchArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 set: Optional[pulumi.Input['BgpRouteMapRouteMapSetArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input['BgpRouteMapRouteMapMatchArgs'] match: Match
        :param pulumi.Input[_builtins.int] name: Sequence number
        :param pulumi.Input['BgpRouteMapRouteMapSetArgs'] set: Set
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapSetArgs']]:
        """
        Set
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapSetArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class BgpRouteMapRouteMapMatchArgsDict(TypedDict):
        as_path_access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        AS path access list
        """
        extended_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        Extended community
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRouteMapMatchIpv4ArgsDict']]
        """
        bgp-route-maps ipv4 object
        """
        large_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        Large community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local preference
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin
        """
        peer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer
        """
        regular_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regular community
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Tag
        """
elif False:
    BgpRouteMapRouteMapMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapMatchArgs:
    def __init__(__self__, *,
                 as_path_access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 extended_community: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4Args']] = None,
                 large_community: Optional[pulumi.Input[_builtins.str]] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 peer: Optional[pulumi.Input[_builtins.str]] = None,
                 regular_community: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] as_path_access_list: AS path access list
        :param pulumi.Input[_builtins.str] extended_community: Extended community
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input['BgpRouteMapRouteMapMatchIpv4Args'] ipv4: bgp-route-maps ipv4 object
        :param pulumi.Input[_builtins.str] large_community: Large community
        :param pulumi.Input[_builtins.int] local_preference: Local preference
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] origin: Origin
        :param pulumi.Input[_builtins.str] peer: Peer
        :param pulumi.Input[_builtins.str] regular_community: Regular community
        :param pulumi.Input[_builtins.int] tag: Tag
        """
        if as_path_access_list is not None:
            pulumi.set(__self__, "as_path_access_list", as_path_access_list)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if large_community is not None:
            pulumi.set(__self__, "large_community", large_community)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if regular_community is not None:
            pulumi.set(__self__, "regular_community", regular_community)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="asPathAccessList")
    def as_path_access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AS path access list
        """
        return pulumi.get(self, "as_path_access_list")

    @as_path_access_list.setter
    def as_path_access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "as_path_access_list", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4Args']]:
        """
        bgp-route-maps ipv4 object
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="largeCommunity")
    def large_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Large community
        """
        return pulumi.get(self, "large_community")

    @large_community.setter
    def large_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "large_community", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer
        """
        return pulumi.get(self, "peer")

    @peer.setter
    def peer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer", value)

    @_builtins.property
    @pulumi.getter(name="regularCommunity")
    def regular_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regular community
        """
        return pulumi.get(self, "regular_community")

    @regular_community.setter
    def regular_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regular_community", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BgpRouteMapRouteMapMatchIpv4ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input['BgpRouteMapRouteMapMatchIpv4AddressArgsDict']]
        """
        Address
        """
        next_hop: NotRequired[pulumi.Input['BgpRouteMapRouteMapMatchIpv4NextHopArgsDict']]
        """
        Next hop
        """
        route_source: NotRequired[pulumi.Input['BgpRouteMapRouteMapMatchIpv4RouteSourceArgsDict']]
        """
        Route source
        """
elif False:
    BgpRouteMapRouteMapMatchIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapMatchIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4AddressArgs']] = None,
                 next_hop: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4NextHopArgs']] = None,
                 route_source: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4RouteSourceArgs']] = None):
        """
        :param pulumi.Input['BgpRouteMapRouteMapMatchIpv4AddressArgs'] address: Address
        :param pulumi.Input['BgpRouteMapRouteMapMatchIpv4NextHopArgs'] next_hop: Next hop
        :param pulumi.Input['BgpRouteMapRouteMapMatchIpv4RouteSourceArgs'] route_source: Route source
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if route_source is not None:
            pulumi.set(__self__, "route_source", route_source)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4AddressArgs']]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4AddressArgs']]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4NextHopArgs']]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4NextHopArgs']]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter(name="routeSource")
    def route_source(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4RouteSourceArgs']]:
        """
        Route source
        """
        return pulumi.get(self, "route_source")

    @route_source.setter
    def route_source(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapMatchIpv4RouteSourceArgs']]):
        pulumi.set(self, "route_source", value)


if not MYPY:
    class BgpRouteMapRouteMapMatchIpv4AddressArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpRouteMapRouteMapMatchIpv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapMatchIpv4AddressArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRouteMapMatchIpv4NextHopArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpRouteMapRouteMapMatchIpv4NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapMatchIpv4NextHopArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRouteMapMatchIpv4RouteSourceArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
        prefix_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix list
        """
elif False:
    BgpRouteMapRouteMapMatchIpv4RouteSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapMatchIpv4RouteSourceArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        :param pulumi.Input[_builtins.str] prefix_list: Prefix list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix list
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BgpRouteMapRouteMapSetArgsDict(TypedDict):
        aggregator: NotRequired[pulumi.Input['BgpRouteMapRouteMapSetAggregatorArgsDict']]
        """
        bgp-route-maps aggregator
        """
        aspath_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Aspath exclude
        """
        aspath_prepends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Aspath prepend
        """
        atomic_aggregate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable BGP atomic aggregate?
        """
        ipv4: NotRequired[pulumi.Input['BgpRouteMapRouteMapSetIpv4ArgsDict']]
        """
        Ipv4
        """
        large_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Large community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local preference
        """
        metric: NotRequired[pulumi.Input['BgpRouteMapRouteMapSetMetricArgsDict']]
        """
        Metric
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin
        """
        originator_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Originator ID
        """
        overwrite_large_community: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Overwrite large community?
        """
        overwrite_regular_community: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Overwrite regular community?
        """
        regular_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Regular community
        """
        remove_large_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove large community name
        """
        remove_regular_community: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regular community name
        """
        tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Tag
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight
        """
elif False:
    BgpRouteMapRouteMapSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapSetArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input['BgpRouteMapRouteMapSetAggregatorArgs']] = None,
                 aspath_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 aspath_prepends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 atomic_aggregate: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv4: Optional[pulumi.Input['BgpRouteMapRouteMapSetIpv4Args']] = None,
                 large_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input['BgpRouteMapRouteMapSetMetricArgs']] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 originator_id: Optional[pulumi.Input[_builtins.str]] = None,
                 overwrite_large_community: Optional[pulumi.Input[_builtins.bool]] = None,
                 overwrite_regular_community: Optional[pulumi.Input[_builtins.bool]] = None,
                 regular_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_large_community: Optional[pulumi.Input[_builtins.str]] = None,
                 remove_regular_community: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['BgpRouteMapRouteMapSetAggregatorArgs'] aggregator: bgp-route-maps aggregator
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] aspath_excludes: Aspath exclude
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] aspath_prepends: Aspath prepend
        :param pulumi.Input[_builtins.bool] atomic_aggregate: Enable BGP atomic aggregate?
        :param pulumi.Input['BgpRouteMapRouteMapSetIpv4Args'] ipv4: Ipv4
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] large_communities: Large community
        :param pulumi.Input[_builtins.int] local_preference: Local preference
        :param pulumi.Input['BgpRouteMapRouteMapSetMetricArgs'] metric: Metric
        :param pulumi.Input[_builtins.str] origin: Origin
        :param pulumi.Input[_builtins.str] originator_id: Originator ID
        :param pulumi.Input[_builtins.bool] overwrite_large_community: Overwrite large community?
        :param pulumi.Input[_builtins.bool] overwrite_regular_community: Overwrite regular community?
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regular_communities: Regular community
        :param pulumi.Input[_builtins.str] remove_large_community: Remove large community name
        :param pulumi.Input[_builtins.str] remove_regular_community: Remove regular community name
        :param pulumi.Input[_builtins.int] tag: Tag
        :param pulumi.Input[_builtins.int] weight: Weight
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if aspath_excludes is not None:
            pulumi.set(__self__, "aspath_excludes", aspath_excludes)
        if aspath_prepends is not None:
            pulumi.set(__self__, "aspath_prepends", aspath_prepends)
        if atomic_aggregate is not None:
            pulumi.set(__self__, "atomic_aggregate", atomic_aggregate)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if large_communities is not None:
            pulumi.set(__self__, "large_communities", large_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if originator_id is not None:
            pulumi.set(__self__, "originator_id", originator_id)
        if overwrite_large_community is not None:
            pulumi.set(__self__, "overwrite_large_community", overwrite_large_community)
        if overwrite_regular_community is not None:
            pulumi.set(__self__, "overwrite_regular_community", overwrite_regular_community)
        if regular_communities is not None:
            pulumi.set(__self__, "regular_communities", regular_communities)
        if remove_large_community is not None:
            pulumi.set(__self__, "remove_large_community", remove_large_community)
        if remove_regular_community is not None:
            pulumi.set(__self__, "remove_regular_community", remove_regular_community)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapSetAggregatorArgs']]:
        """
        bgp-route-maps aggregator
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapSetAggregatorArgs']]):
        pulumi.set(self, "aggregator", value)

    @_builtins.property
    @pulumi.getter(name="aspathExcludes")
    def aspath_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Aspath exclude
        """
        return pulumi.get(self, "aspath_excludes")

    @aspath_excludes.setter
    def aspath_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "aspath_excludes", value)

    @_builtins.property
    @pulumi.getter(name="aspathPrepends")
    def aspath_prepends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Aspath prepend
        """
        return pulumi.get(self, "aspath_prepends")

    @aspath_prepends.setter
    def aspath_prepends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "aspath_prepends", value)

    @_builtins.property
    @pulumi.getter(name="atomicAggregate")
    def atomic_aggregate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable BGP atomic aggregate?
        """
        return pulumi.get(self, "atomic_aggregate")

    @atomic_aggregate.setter
    def atomic_aggregate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "atomic_aggregate", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapSetIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapSetIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="largeCommunities")
    def large_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Large community
        """
        return pulumi.get(self, "large_communities")

    @large_communities.setter
    def large_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "large_communities", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['BgpRouteMapRouteMapSetMetricArgs']]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['BgpRouteMapRouteMapSetMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="originatorId")
    def originator_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Originator ID
        """
        return pulumi.get(self, "originator_id")

    @originator_id.setter
    def originator_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "originator_id", value)

    @_builtins.property
    @pulumi.getter(name="overwriteLargeCommunity")
    def overwrite_large_community(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Overwrite large community?
        """
        return pulumi.get(self, "overwrite_large_community")

    @overwrite_large_community.setter
    def overwrite_large_community(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_large_community", value)

    @_builtins.property
    @pulumi.getter(name="overwriteRegularCommunity")
    def overwrite_regular_community(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Overwrite regular community?
        """
        return pulumi.get(self, "overwrite_regular_community")

    @overwrite_regular_community.setter
    def overwrite_regular_community(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_regular_community", value)

    @_builtins.property
    @pulumi.getter(name="regularCommunities")
    def regular_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Regular community
        """
        return pulumi.get(self, "regular_communities")

    @regular_communities.setter
    def regular_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regular_communities", value)

    @_builtins.property
    @pulumi.getter(name="removeLargeCommunity")
    def remove_large_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove large community name
        """
        return pulumi.get(self, "remove_large_community")

    @remove_large_community.setter
    def remove_large_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_large_community", value)

    @_builtins.property
    @pulumi.getter(name="removeRegularCommunity")
    def remove_regular_community(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regular community name
        """
        return pulumi.get(self, "remove_regular_community")

    @remove_regular_community.setter
    def remove_regular_community(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regular_community", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class BgpRouteMapRouteMapSetAggregatorArgsDict(TypedDict):
        as_: NotRequired[pulumi.Input[_builtins.int]]
        """
        Aggregator AS
        """
        router_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Router ID
        """
elif False:
    BgpRouteMapRouteMapSetAggregatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapSetAggregatorArgs:
    def __init__(__self__, *,
                 as_: Optional[pulumi.Input[_builtins.int]] = None,
                 router_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] as_: Aggregator AS
        :param pulumi.Input[_builtins.str] router_id: Router ID
        """
        if as_ is not None:
            pulumi.set(__self__, "as_", as_)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="as")
    def as_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Aggregator AS
        """
        return pulumi.get(self, "as_")

    @as_.setter
    def as_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "as_", value)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Router ID
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "router_id", value)


if not MYPY:
    class BgpRouteMapRouteMapSetIpv4ArgsDict(TypedDict):
        next_hop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop
        """
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source address
        """
elif False:
    BgpRouteMapRouteMapSetIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapSetIpv4Args:
    def __init__(__self__, *,
                 next_hop: Optional[pulumi.Input[_builtins.str]] = None,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] next_hop: Next hop
        :param pulumi.Input[_builtins.str] source_address: Source address
        """
        if next_hop is not None:
            pulumi.set(__self__, "next_hop", next_hop)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class BgpRouteMapRouteMapSetMetricArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric action
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric value
        """
elif False:
    BgpRouteMapRouteMapSetMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRouteMapRouteMapSetMetricArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Metric action
        :param pulumi.Input[_builtins.int] value: Metric value
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BgpRoutingRoutingPreferenceArgsDict(TypedDict):
        default: NotRequired[pulumi.Input['BgpRoutingRoutingPreferenceDefaultArgsDict']]
        """
        Default
        """
        hot_potato_routing: NotRequired[pulumi.Input['BgpRoutingRoutingPreferenceHotPotatoRoutingArgsDict']]
        """
        Hot potato routing

        >  **Note:** You must specify exactly one of `default` and `hot_potato_routing`.
        """
elif False:
    BgpRoutingRoutingPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRoutingRoutingPreferenceArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input['BgpRoutingRoutingPreferenceDefaultArgs']] = None,
                 hot_potato_routing: Optional[pulumi.Input['BgpRoutingRoutingPreferenceHotPotatoRoutingArgs']] = None):
        """
        :param pulumi.Input['BgpRoutingRoutingPreferenceDefaultArgs'] default: Default
        :param pulumi.Input['BgpRoutingRoutingPreferenceHotPotatoRoutingArgs'] hot_potato_routing: Hot potato routing
               
               >  **Note:** You must specify exactly one of `default` and `hot_potato_routing`.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if hot_potato_routing is not None:
            pulumi.set(__self__, "hot_potato_routing", hot_potato_routing)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input['BgpRoutingRoutingPreferenceDefaultArgs']]:
        """
        Default
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input['BgpRoutingRoutingPreferenceDefaultArgs']]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter(name="hotPotatoRouting")
    def hot_potato_routing(self) -> Optional[pulumi.Input['BgpRoutingRoutingPreferenceHotPotatoRoutingArgs']]:
        """
        Hot potato routing

        >  **Note:** You must specify exactly one of `default` and `hot_potato_routing`.
        """
        return pulumi.get(self, "hot_potato_routing")

    @hot_potato_routing.setter
    def hot_potato_routing(self, value: Optional[pulumi.Input['BgpRoutingRoutingPreferenceHotPotatoRoutingArgs']]):
        pulumi.set(self, "hot_potato_routing", value)


if not MYPY:
    class BgpRoutingRoutingPreferenceDefaultArgsDict(TypedDict):
        pass
elif False:
    BgpRoutingRoutingPreferenceDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRoutingRoutingPreferenceDefaultArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BgpRoutingRoutingPreferenceHotPotatoRoutingArgsDict(TypedDict):
        pass
elif False:
    BgpRoutingRoutingPreferenceHotPotatoRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpRoutingRoutingPreferenceHotPotatoRoutingArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CertificateProfileCaCertificateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        CA certificate name
        """
        default_ocsp_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default OCSP URL
        """
        ocsp_verify_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCSP verify certificate
        """
        template_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template name/OID
        """
elif False:
    CertificateProfileCaCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateProfileCaCertificateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 default_ocsp_url: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_verify_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 template_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: CA certificate name
        :param pulumi.Input[_builtins.str] default_ocsp_url: Default OCSP URL
        :param pulumi.Input[_builtins.str] ocsp_verify_cert: OCSP verify certificate
        :param pulumi.Input[_builtins.str] template_name: Template name/OID
        """
        pulumi.set(__self__, "name", name)
        if default_ocsp_url is not None:
            pulumi.set(__self__, "default_ocsp_url", default_ocsp_url)
        if ocsp_verify_cert is not None:
            pulumi.set(__self__, "ocsp_verify_cert", ocsp_verify_cert)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        CA certificate name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="defaultOcspUrl")
    def default_ocsp_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default OCSP URL
        """
        return pulumi.get(self, "default_ocsp_url")

    @default_ocsp_url.setter
    def default_ocsp_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_ocsp_url", value)

    @_builtins.property
    @pulumi.getter(name="ocspVerifyCert")
    def ocsp_verify_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCSP verify certificate
        """
        return pulumi.get(self, "ocsp_verify_cert")

    @ocsp_verify_cert.setter
    def ocsp_verify_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ocsp_verify_cert", value)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template name/OID
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_name", value)


if not MYPY:
    class CertificateProfileUsernameFieldArgsDict(TypedDict):
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        Common name
        """
        subject_alt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address
        """
elif False:
    CertificateProfileUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateProfileUsernameFieldArgs:
    def __init__(__self__, *,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_alt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subject: Common name
        :param pulumi.Input[_builtins.str] subject_alt: Email address
        """
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_alt is not None:
            pulumi.set(__self__, "subject_alt", subject_alt)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Common name
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlt")
    def subject_alt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address
        """
        return pulumi.get(self, "subject_alt")

    @subject_alt.setter
    def subject_alt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject_alt", value)


if not MYPY:
    class ContentIdSettingContentIdArgsDict(TypedDict):
        allow_forward_decrypted_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow forward decrypted content
        """
        allow_http_range: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow http range
        """
        application: NotRequired[pulumi.Input['ContentIdSettingContentIdApplicationArgsDict']]
        """
        Application
        """
        extended_capture_segment: NotRequired[pulumi.Input[_builtins.int]]
        """
        Extended capture segment
        """
        strip_x_fwd_for: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strip x fwd for
        """
        tcp_bypass_exceed_queue: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tcp bypass exceed queue
        """
        udp_bypass_exceed_queue: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Udp bypass exceed queue
        """
        x_forwarded_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        X forwarded for
        """
elif False:
    ContentIdSettingContentIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContentIdSettingContentIdArgs:
    def __init__(__self__, *,
                 allow_forward_decrypted_content: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_http_range: Optional[pulumi.Input[_builtins.bool]] = None,
                 application: Optional[pulumi.Input['ContentIdSettingContentIdApplicationArgs']] = None,
                 extended_capture_segment: Optional[pulumi.Input[_builtins.int]] = None,
                 strip_x_fwd_for: Optional[pulumi.Input[_builtins.bool]] = None,
                 tcp_bypass_exceed_queue: Optional[pulumi.Input[_builtins.bool]] = None,
                 udp_bypass_exceed_queue: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_forward_decrypted_content: Allow forward decrypted content
        :param pulumi.Input[_builtins.bool] allow_http_range: Allow http range
        :param pulumi.Input['ContentIdSettingContentIdApplicationArgs'] application: Application
        :param pulumi.Input[_builtins.int] extended_capture_segment: Extended capture segment
        :param pulumi.Input[_builtins.bool] strip_x_fwd_for: Strip x fwd for
        :param pulumi.Input[_builtins.bool] tcp_bypass_exceed_queue: Tcp bypass exceed queue
        :param pulumi.Input[_builtins.bool] udp_bypass_exceed_queue: Udp bypass exceed queue
        :param pulumi.Input[_builtins.str] x_forwarded_for: X forwarded for
        """
        if allow_forward_decrypted_content is not None:
            pulumi.set(__self__, "allow_forward_decrypted_content", allow_forward_decrypted_content)
        if allow_http_range is not None:
            pulumi.set(__self__, "allow_http_range", allow_http_range)
        if application is not None:
            pulumi.set(__self__, "application", application)
        if extended_capture_segment is not None:
            pulumi.set(__self__, "extended_capture_segment", extended_capture_segment)
        if strip_x_fwd_for is not None:
            pulumi.set(__self__, "strip_x_fwd_for", strip_x_fwd_for)
        if tcp_bypass_exceed_queue is not None:
            pulumi.set(__self__, "tcp_bypass_exceed_queue", tcp_bypass_exceed_queue)
        if udp_bypass_exceed_queue is not None:
            pulumi.set(__self__, "udp_bypass_exceed_queue", udp_bypass_exceed_queue)
        if x_forwarded_for is not None:
            pulumi.set(__self__, "x_forwarded_for", x_forwarded_for)

    @_builtins.property
    @pulumi.getter(name="allowForwardDecryptedContent")
    def allow_forward_decrypted_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow forward decrypted content
        """
        return pulumi.get(self, "allow_forward_decrypted_content")

    @allow_forward_decrypted_content.setter
    def allow_forward_decrypted_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_forward_decrypted_content", value)

    @_builtins.property
    @pulumi.getter(name="allowHttpRange")
    def allow_http_range(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow http range
        """
        return pulumi.get(self, "allow_http_range")

    @allow_http_range.setter
    def allow_http_range(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_http_range", value)

    @_builtins.property
    @pulumi.getter
    def application(self) -> Optional[pulumi.Input['ContentIdSettingContentIdApplicationArgs']]:
        """
        Application
        """
        return pulumi.get(self, "application")

    @application.setter
    def application(self, value: Optional[pulumi.Input['ContentIdSettingContentIdApplicationArgs']]):
        pulumi.set(self, "application", value)

    @_builtins.property
    @pulumi.getter(name="extendedCaptureSegment")
    def extended_capture_segment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Extended capture segment
        """
        return pulumi.get(self, "extended_capture_segment")

    @extended_capture_segment.setter
    def extended_capture_segment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "extended_capture_segment", value)

    @_builtins.property
    @pulumi.getter(name="stripXFwdFor")
    def strip_x_fwd_for(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strip x fwd for
        """
        return pulumi.get(self, "strip_x_fwd_for")

    @strip_x_fwd_for.setter
    def strip_x_fwd_for(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strip_x_fwd_for", value)

    @_builtins.property
    @pulumi.getter(name="tcpBypassExceedQueue")
    def tcp_bypass_exceed_queue(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tcp bypass exceed queue
        """
        return pulumi.get(self, "tcp_bypass_exceed_queue")

    @tcp_bypass_exceed_queue.setter
    def tcp_bypass_exceed_queue(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tcp_bypass_exceed_queue", value)

    @_builtins.property
    @pulumi.getter(name="udpBypassExceedQueue")
    def udp_bypass_exceed_queue(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Udp bypass exceed queue
        """
        return pulumi.get(self, "udp_bypass_exceed_queue")

    @udp_bypass_exceed_queue.setter
    def udp_bypass_exceed_queue(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "udp_bypass_exceed_queue", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedFor")
    def x_forwarded_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        X forwarded for
        """
        return pulumi.get(self, "x_forwarded_for")

    @x_forwarded_for.setter
    def x_forwarded_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for", value)


if not MYPY:
    class ContentIdSettingContentIdApplicationArgsDict(TypedDict):
        bypass_exceed_queue: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Bypass exceed queue
        """
elif False:
    ContentIdSettingContentIdApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContentIdSettingContentIdApplicationArgs:
    def __init__(__self__, *,
                 bypass_exceed_queue: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] bypass_exceed_queue: Bypass exceed queue
        """
        if bypass_exceed_queue is not None:
            pulumi.set(__self__, "bypass_exceed_queue", bypass_exceed_queue)

    @_builtins.property
    @pulumi.getter(name="bypassExceedQueue")
    def bypass_exceed_queue(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Bypass exceed queue
        """
        return pulumi.get(self, "bypass_exceed_queue")

    @bypass_exceed_queue.setter
    def bypass_exceed_queue(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bypass_exceed_queue", value)


if not MYPY:
    class DecryptionProfileSslForwardProxyArgsDict(TypedDict):
        auto_include_altname: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auto include altname
        """
        block_client_cert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block client cert
        """
        block_expired_certificate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block expired certificate
        """
        block_timeout_cert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block timeout cert
        """
        block_tls13_downgrade_no_resource: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block tls13 downgrade no resource
        """
        block_unknown_cert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block unknown cert
        """
        block_unsupported_cipher: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block unsupported cipher
        """
        block_unsupported_version: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block unsupported version
        """
        block_untrusted_issuer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block untrusted issuer
        """
        restrict_cert_exts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Restrict cert exts
        """
        strip_alpn: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strip alpn
        """
elif False:
    DecryptionProfileSslForwardProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionProfileSslForwardProxyArgs:
    def __init__(__self__, *,
                 auto_include_altname: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_client_cert: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_expired_certificate: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_timeout_cert: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_tls13_downgrade_no_resource: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_unknown_cert: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_unsupported_cipher: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_unsupported_version: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_untrusted_issuer: Optional[pulumi.Input[_builtins.bool]] = None,
                 restrict_cert_exts: Optional[pulumi.Input[_builtins.bool]] = None,
                 strip_alpn: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_include_altname: Auto include altname
        :param pulumi.Input[_builtins.bool] block_client_cert: Block client cert
        :param pulumi.Input[_builtins.bool] block_expired_certificate: Block expired certificate
        :param pulumi.Input[_builtins.bool] block_timeout_cert: Block timeout cert
        :param pulumi.Input[_builtins.bool] block_tls13_downgrade_no_resource: Block tls13 downgrade no resource
        :param pulumi.Input[_builtins.bool] block_unknown_cert: Block unknown cert
        :param pulumi.Input[_builtins.bool] block_unsupported_cipher: Block unsupported cipher
        :param pulumi.Input[_builtins.bool] block_unsupported_version: Block unsupported version
        :param pulumi.Input[_builtins.bool] block_untrusted_issuer: Block untrusted issuer
        :param pulumi.Input[_builtins.bool] restrict_cert_exts: Restrict cert exts
        :param pulumi.Input[_builtins.bool] strip_alpn: Strip alpn
        """
        if auto_include_altname is not None:
            pulumi.set(__self__, "auto_include_altname", auto_include_altname)
        if block_client_cert is not None:
            pulumi.set(__self__, "block_client_cert", block_client_cert)
        if block_expired_certificate is not None:
            pulumi.set(__self__, "block_expired_certificate", block_expired_certificate)
        if block_timeout_cert is not None:
            pulumi.set(__self__, "block_timeout_cert", block_timeout_cert)
        if block_tls13_downgrade_no_resource is not None:
            pulumi.set(__self__, "block_tls13_downgrade_no_resource", block_tls13_downgrade_no_resource)
        if block_unknown_cert is not None:
            pulumi.set(__self__, "block_unknown_cert", block_unknown_cert)
        if block_unsupported_cipher is not None:
            pulumi.set(__self__, "block_unsupported_cipher", block_unsupported_cipher)
        if block_unsupported_version is not None:
            pulumi.set(__self__, "block_unsupported_version", block_unsupported_version)
        if block_untrusted_issuer is not None:
            pulumi.set(__self__, "block_untrusted_issuer", block_untrusted_issuer)
        if restrict_cert_exts is not None:
            pulumi.set(__self__, "restrict_cert_exts", restrict_cert_exts)
        if strip_alpn is not None:
            pulumi.set(__self__, "strip_alpn", strip_alpn)

    @_builtins.property
    @pulumi.getter(name="autoIncludeAltname")
    def auto_include_altname(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auto include altname
        """
        return pulumi.get(self, "auto_include_altname")

    @auto_include_altname.setter
    def auto_include_altname(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_include_altname", value)

    @_builtins.property
    @pulumi.getter(name="blockClientCert")
    def block_client_cert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block client cert
        """
        return pulumi.get(self, "block_client_cert")

    @block_client_cert.setter
    def block_client_cert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="blockExpiredCertificate")
    def block_expired_certificate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block expired certificate
        """
        return pulumi.get(self, "block_expired_certificate")

    @block_expired_certificate.setter
    def block_expired_certificate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_expired_certificate", value)

    @_builtins.property
    @pulumi.getter(name="blockTimeoutCert")
    def block_timeout_cert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block timeout cert
        """
        return pulumi.get(self, "block_timeout_cert")

    @block_timeout_cert.setter
    def block_timeout_cert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_timeout_cert", value)

    @_builtins.property
    @pulumi.getter(name="blockTls13DowngradeNoResource")
    def block_tls13_downgrade_no_resource(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block tls13 downgrade no resource
        """
        return pulumi.get(self, "block_tls13_downgrade_no_resource")

    @block_tls13_downgrade_no_resource.setter
    def block_tls13_downgrade_no_resource(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_tls13_downgrade_no_resource", value)

    @_builtins.property
    @pulumi.getter(name="blockUnknownCert")
    def block_unknown_cert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block unknown cert
        """
        return pulumi.get(self, "block_unknown_cert")

    @block_unknown_cert.setter
    def block_unknown_cert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_unknown_cert", value)

    @_builtins.property
    @pulumi.getter(name="blockUnsupportedCipher")
    def block_unsupported_cipher(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block unsupported cipher
        """
        return pulumi.get(self, "block_unsupported_cipher")

    @block_unsupported_cipher.setter
    def block_unsupported_cipher(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_unsupported_cipher", value)

    @_builtins.property
    @pulumi.getter(name="blockUnsupportedVersion")
    def block_unsupported_version(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block unsupported version
        """
        return pulumi.get(self, "block_unsupported_version")

    @block_unsupported_version.setter
    def block_unsupported_version(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_unsupported_version", value)

    @_builtins.property
    @pulumi.getter(name="blockUntrustedIssuer")
    def block_untrusted_issuer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block untrusted issuer
        """
        return pulumi.get(self, "block_untrusted_issuer")

    @block_untrusted_issuer.setter
    def block_untrusted_issuer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_untrusted_issuer", value)

    @_builtins.property
    @pulumi.getter(name="restrictCertExts")
    def restrict_cert_exts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Restrict cert exts
        """
        return pulumi.get(self, "restrict_cert_exts")

    @restrict_cert_exts.setter
    def restrict_cert_exts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "restrict_cert_exts", value)

    @_builtins.property
    @pulumi.getter(name="stripAlpn")
    def strip_alpn(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strip alpn
        """
        return pulumi.get(self, "strip_alpn")

    @strip_alpn.setter
    def strip_alpn(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strip_alpn", value)


if not MYPY:
    class DecryptionProfileSslInboundProxyArgsDict(TypedDict):
        block_if_hsm_unavailable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block if hsm unavailable
        """
        block_if_no_resource: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block if no resource
        """
        block_unsupported_cipher: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block unsupported cipher
        """
        block_unsupported_version: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block unsupported version
        """
elif False:
    DecryptionProfileSslInboundProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionProfileSslInboundProxyArgs:
    def __init__(__self__, *,
                 block_if_hsm_unavailable: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_if_no_resource: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_unsupported_cipher: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_unsupported_version: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_if_hsm_unavailable: Block if hsm unavailable
        :param pulumi.Input[_builtins.bool] block_if_no_resource: Block if no resource
        :param pulumi.Input[_builtins.bool] block_unsupported_cipher: Block unsupported cipher
        :param pulumi.Input[_builtins.bool] block_unsupported_version: Block unsupported version
        """
        if block_if_hsm_unavailable is not None:
            pulumi.set(__self__, "block_if_hsm_unavailable", block_if_hsm_unavailable)
        if block_if_no_resource is not None:
            pulumi.set(__self__, "block_if_no_resource", block_if_no_resource)
        if block_unsupported_cipher is not None:
            pulumi.set(__self__, "block_unsupported_cipher", block_unsupported_cipher)
        if block_unsupported_version is not None:
            pulumi.set(__self__, "block_unsupported_version", block_unsupported_version)

    @_builtins.property
    @pulumi.getter(name="blockIfHsmUnavailable")
    def block_if_hsm_unavailable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block if hsm unavailable
        """
        return pulumi.get(self, "block_if_hsm_unavailable")

    @block_if_hsm_unavailable.setter
    def block_if_hsm_unavailable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_if_hsm_unavailable", value)

    @_builtins.property
    @pulumi.getter(name="blockIfNoResource")
    def block_if_no_resource(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block if no resource
        """
        return pulumi.get(self, "block_if_no_resource")

    @block_if_no_resource.setter
    def block_if_no_resource(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_if_no_resource", value)

    @_builtins.property
    @pulumi.getter(name="blockUnsupportedCipher")
    def block_unsupported_cipher(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block unsupported cipher
        """
        return pulumi.get(self, "block_unsupported_cipher")

    @block_unsupported_cipher.setter
    def block_unsupported_cipher(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_unsupported_cipher", value)

    @_builtins.property
    @pulumi.getter(name="blockUnsupportedVersion")
    def block_unsupported_version(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block unsupported version
        """
        return pulumi.get(self, "block_unsupported_version")

    @block_unsupported_version.setter
    def block_unsupported_version(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_unsupported_version", value)


if not MYPY:
    class DecryptionProfileSslNoProxyArgsDict(TypedDict):
        block_expired_certificate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block expired certificate
        """
        block_untrusted_issuer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block untrusted issuer
        """
elif False:
    DecryptionProfileSslNoProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionProfileSslNoProxyArgs:
    def __init__(__self__, *,
                 block_expired_certificate: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_untrusted_issuer: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_expired_certificate: Block expired certificate
        :param pulumi.Input[_builtins.bool] block_untrusted_issuer: Block untrusted issuer
        """
        if block_expired_certificate is not None:
            pulumi.set(__self__, "block_expired_certificate", block_expired_certificate)
        if block_untrusted_issuer is not None:
            pulumi.set(__self__, "block_untrusted_issuer", block_untrusted_issuer)

    @_builtins.property
    @pulumi.getter(name="blockExpiredCertificate")
    def block_expired_certificate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block expired certificate
        """
        return pulumi.get(self, "block_expired_certificate")

    @block_expired_certificate.setter
    def block_expired_certificate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_expired_certificate", value)

    @_builtins.property
    @pulumi.getter(name="blockUntrustedIssuer")
    def block_untrusted_issuer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block untrusted issuer
        """
        return pulumi.get(self, "block_untrusted_issuer")

    @block_untrusted_issuer.setter
    def block_untrusted_issuer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_untrusted_issuer", value)


if not MYPY:
    class DecryptionProfileSslProtocolSettingsArgsDict(TypedDict):
        auth_algo_md5: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auth algo md5
        """
        auth_algo_sha1: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auth algo sha1
        """
        auth_algo_sha256: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auth algo sha256
        """
        auth_algo_sha384: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Auth algo sha384
        """
        enc_algo3des: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo3des
        """
        enc_algo_aes128_cbc: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo aes128 cbc
        """
        enc_algo_aes128_gcm: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo aes128 gcm
        """
        enc_algo_aes256_cbc: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo aes256 cbc
        """
        enc_algo_aes256_gcm: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo aes256 gcm
        """
        enc_algo_chacha20_poly1305: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo chacha20 poly1305
        """
        enc_algo_rc4: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enc algo rc4
        """
        keyxchg_algo_dhe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Keyxchg algo dhe
        """
        keyxchg_algo_ecdhe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Keyxchg algo ecdhe
        """
        keyxchg_algo_rsa: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Keyxchg algo rsa
        """
        max_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max version
        """
        min_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Min version
        """
elif False:
    DecryptionProfileSslProtocolSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionProfileSslProtocolSettingsArgs:
    def __init__(__self__, *,
                 auth_algo_md5: Optional[pulumi.Input[_builtins.bool]] = None,
                 auth_algo_sha1: Optional[pulumi.Input[_builtins.bool]] = None,
                 auth_algo_sha256: Optional[pulumi.Input[_builtins.bool]] = None,
                 auth_algo_sha384: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo3des: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes128_cbc: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes128_gcm: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes256_cbc: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes256_gcm: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_chacha20_poly1305: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_rc4: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyxchg_algo_dhe: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyxchg_algo_ecdhe: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyxchg_algo_rsa: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_version: Optional[pulumi.Input[_builtins.str]] = None,
                 min_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] auth_algo_md5: Auth algo md5
        :param pulumi.Input[_builtins.bool] auth_algo_sha1: Auth algo sha1
        :param pulumi.Input[_builtins.bool] auth_algo_sha256: Auth algo sha256
        :param pulumi.Input[_builtins.bool] auth_algo_sha384: Auth algo sha384
        :param pulumi.Input[_builtins.bool] enc_algo3des: Enc algo3des
        :param pulumi.Input[_builtins.bool] enc_algo_aes128_cbc: Enc algo aes128 cbc
        :param pulumi.Input[_builtins.bool] enc_algo_aes128_gcm: Enc algo aes128 gcm
        :param pulumi.Input[_builtins.bool] enc_algo_aes256_cbc: Enc algo aes256 cbc
        :param pulumi.Input[_builtins.bool] enc_algo_aes256_gcm: Enc algo aes256 gcm
        :param pulumi.Input[_builtins.bool] enc_algo_chacha20_poly1305: Enc algo chacha20 poly1305
        :param pulumi.Input[_builtins.bool] enc_algo_rc4: Enc algo rc4
        :param pulumi.Input[_builtins.bool] keyxchg_algo_dhe: Keyxchg algo dhe
        :param pulumi.Input[_builtins.bool] keyxchg_algo_ecdhe: Keyxchg algo ecdhe
        :param pulumi.Input[_builtins.bool] keyxchg_algo_rsa: Keyxchg algo rsa
        :param pulumi.Input[_builtins.str] max_version: Max version
        :param pulumi.Input[_builtins.str] min_version: Min version
        """
        if auth_algo_md5 is not None:
            pulumi.set(__self__, "auth_algo_md5", auth_algo_md5)
        if auth_algo_sha1 is not None:
            pulumi.set(__self__, "auth_algo_sha1", auth_algo_sha1)
        if auth_algo_sha256 is not None:
            pulumi.set(__self__, "auth_algo_sha256", auth_algo_sha256)
        if auth_algo_sha384 is not None:
            pulumi.set(__self__, "auth_algo_sha384", auth_algo_sha384)
        if enc_algo3des is not None:
            pulumi.set(__self__, "enc_algo3des", enc_algo3des)
        if enc_algo_aes128_cbc is not None:
            pulumi.set(__self__, "enc_algo_aes128_cbc", enc_algo_aes128_cbc)
        if enc_algo_aes128_gcm is not None:
            pulumi.set(__self__, "enc_algo_aes128_gcm", enc_algo_aes128_gcm)
        if enc_algo_aes256_cbc is not None:
            pulumi.set(__self__, "enc_algo_aes256_cbc", enc_algo_aes256_cbc)
        if enc_algo_aes256_gcm is not None:
            pulumi.set(__self__, "enc_algo_aes256_gcm", enc_algo_aes256_gcm)
        if enc_algo_chacha20_poly1305 is not None:
            pulumi.set(__self__, "enc_algo_chacha20_poly1305", enc_algo_chacha20_poly1305)
        if enc_algo_rc4 is not None:
            pulumi.set(__self__, "enc_algo_rc4", enc_algo_rc4)
        if keyxchg_algo_dhe is not None:
            pulumi.set(__self__, "keyxchg_algo_dhe", keyxchg_algo_dhe)
        if keyxchg_algo_ecdhe is not None:
            pulumi.set(__self__, "keyxchg_algo_ecdhe", keyxchg_algo_ecdhe)
        if keyxchg_algo_rsa is not None:
            pulumi.set(__self__, "keyxchg_algo_rsa", keyxchg_algo_rsa)
        if max_version is not None:
            pulumi.set(__self__, "max_version", max_version)
        if min_version is not None:
            pulumi.set(__self__, "min_version", min_version)

    @_builtins.property
    @pulumi.getter(name="authAlgoMd5")
    def auth_algo_md5(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auth algo md5
        """
        return pulumi.get(self, "auth_algo_md5")

    @auth_algo_md5.setter
    def auth_algo_md5(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_md5", value)

    @_builtins.property
    @pulumi.getter(name="authAlgoSha1")
    def auth_algo_sha1(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auth algo sha1
        """
        return pulumi.get(self, "auth_algo_sha1")

    @auth_algo_sha1.setter
    def auth_algo_sha1(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_sha1", value)

    @_builtins.property
    @pulumi.getter(name="authAlgoSha256")
    def auth_algo_sha256(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auth algo sha256
        """
        return pulumi.get(self, "auth_algo_sha256")

    @auth_algo_sha256.setter
    def auth_algo_sha256(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_sha256", value)

    @_builtins.property
    @pulumi.getter(name="authAlgoSha384")
    def auth_algo_sha384(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Auth algo sha384
        """
        return pulumi.get(self, "auth_algo_sha384")

    @auth_algo_sha384.setter
    def auth_algo_sha384(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_sha384", value)

    @_builtins.property
    @pulumi.getter(name="encAlgo3des")
    def enc_algo3des(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo3des
        """
        return pulumi.get(self, "enc_algo3des")

    @enc_algo3des.setter
    def enc_algo3des(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo3des", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes128Cbc")
    def enc_algo_aes128_cbc(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo aes128 cbc
        """
        return pulumi.get(self, "enc_algo_aes128_cbc")

    @enc_algo_aes128_cbc.setter
    def enc_algo_aes128_cbc(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes128_cbc", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes128Gcm")
    def enc_algo_aes128_gcm(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo aes128 gcm
        """
        return pulumi.get(self, "enc_algo_aes128_gcm")

    @enc_algo_aes128_gcm.setter
    def enc_algo_aes128_gcm(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes128_gcm", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes256Cbc")
    def enc_algo_aes256_cbc(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo aes256 cbc
        """
        return pulumi.get(self, "enc_algo_aes256_cbc")

    @enc_algo_aes256_cbc.setter
    def enc_algo_aes256_cbc(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes256_cbc", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes256Gcm")
    def enc_algo_aes256_gcm(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo aes256 gcm
        """
        return pulumi.get(self, "enc_algo_aes256_gcm")

    @enc_algo_aes256_gcm.setter
    def enc_algo_aes256_gcm(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes256_gcm", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoChacha20Poly1305")
    def enc_algo_chacha20_poly1305(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo chacha20 poly1305
        """
        return pulumi.get(self, "enc_algo_chacha20_poly1305")

    @enc_algo_chacha20_poly1305.setter
    def enc_algo_chacha20_poly1305(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_chacha20_poly1305", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoRc4")
    def enc_algo_rc4(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enc algo rc4
        """
        return pulumi.get(self, "enc_algo_rc4")

    @enc_algo_rc4.setter
    def enc_algo_rc4(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_rc4", value)

    @_builtins.property
    @pulumi.getter(name="keyxchgAlgoDhe")
    def keyxchg_algo_dhe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Keyxchg algo dhe
        """
        return pulumi.get(self, "keyxchg_algo_dhe")

    @keyxchg_algo_dhe.setter
    def keyxchg_algo_dhe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keyxchg_algo_dhe", value)

    @_builtins.property
    @pulumi.getter(name="keyxchgAlgoEcdhe")
    def keyxchg_algo_ecdhe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Keyxchg algo ecdhe
        """
        return pulumi.get(self, "keyxchg_algo_ecdhe")

    @keyxchg_algo_ecdhe.setter
    def keyxchg_algo_ecdhe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keyxchg_algo_ecdhe", value)

    @_builtins.property
    @pulumi.getter(name="keyxchgAlgoRsa")
    def keyxchg_algo_rsa(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Keyxchg algo rsa
        """
        return pulumi.get(self, "keyxchg_algo_rsa")

    @keyxchg_algo_rsa.setter
    def keyxchg_algo_rsa(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keyxchg_algo_rsa", value)

    @_builtins.property
    @pulumi.getter(name="maxVersion")
    def max_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max version
        """
        return pulumi.get(self, "max_version")

    @max_version.setter
    def max_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_version", value)

    @_builtins.property
    @pulumi.getter(name="minVersion")
    def min_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Min version
        """
        return pulumi.get(self, "min_version")

    @min_version.setter
    def min_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_version", value)


if not MYPY:
    class DecryptionRuleTypeArgsDict(TypedDict):
        ssl_forward_proxy: NotRequired[pulumi.Input['DecryptionRuleTypeSslForwardProxyArgsDict']]
        """
        Ssl forward proxy
        """
        ssl_inbound_inspection: NotRequired[pulumi.Input['DecryptionRuleTypeSslInboundInspectionArgsDict']]
        """
        add the certificate name for SSL inbound inspection

        >  **Note:** You must specify exactly one of `ssl_forward_proxy` and `ssl_inbound_inspection`.
        """
elif False:
    DecryptionRuleTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionRuleTypeArgs:
    def __init__(__self__, *,
                 ssl_forward_proxy: Optional[pulumi.Input['DecryptionRuleTypeSslForwardProxyArgs']] = None,
                 ssl_inbound_inspection: Optional[pulumi.Input['DecryptionRuleTypeSslInboundInspectionArgs']] = None):
        """
        :param pulumi.Input['DecryptionRuleTypeSslForwardProxyArgs'] ssl_forward_proxy: Ssl forward proxy
        :param pulumi.Input['DecryptionRuleTypeSslInboundInspectionArgs'] ssl_inbound_inspection: add the certificate name for SSL inbound inspection
               
               >  **Note:** You must specify exactly one of `ssl_forward_proxy` and `ssl_inbound_inspection`.
        """
        if ssl_forward_proxy is not None:
            pulumi.set(__self__, "ssl_forward_proxy", ssl_forward_proxy)
        if ssl_inbound_inspection is not None:
            pulumi.set(__self__, "ssl_inbound_inspection", ssl_inbound_inspection)

    @_builtins.property
    @pulumi.getter(name="sslForwardProxy")
    def ssl_forward_proxy(self) -> Optional[pulumi.Input['DecryptionRuleTypeSslForwardProxyArgs']]:
        """
        Ssl forward proxy
        """
        return pulumi.get(self, "ssl_forward_proxy")

    @ssl_forward_proxy.setter
    def ssl_forward_proxy(self, value: Optional[pulumi.Input['DecryptionRuleTypeSslForwardProxyArgs']]):
        pulumi.set(self, "ssl_forward_proxy", value)

    @_builtins.property
    @pulumi.getter(name="sslInboundInspection")
    def ssl_inbound_inspection(self) -> Optional[pulumi.Input['DecryptionRuleTypeSslInboundInspectionArgs']]:
        """
        add the certificate name for SSL inbound inspection

        >  **Note:** You must specify exactly one of `ssl_forward_proxy` and `ssl_inbound_inspection`.
        """
        return pulumi.get(self, "ssl_inbound_inspection")

    @ssl_inbound_inspection.setter
    def ssl_inbound_inspection(self, value: Optional[pulumi.Input['DecryptionRuleTypeSslInboundInspectionArgs']]):
        pulumi.set(self, "ssl_inbound_inspection", value)


if not MYPY:
    class DecryptionRuleTypeSslForwardProxyArgsDict(TypedDict):
        pass
elif False:
    DecryptionRuleTypeSslForwardProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionRuleTypeSslForwardProxyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DecryptionRuleTypeSslInboundInspectionArgsDict(TypedDict):
        certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of certificate names for SSL inbound inspection
        """
elif False:
    DecryptionRuleTypeSslInboundInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DecryptionRuleTypeSslInboundInspectionArgs:
    def __init__(__self__, *,
                 certificates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] certificates: List of certificate names for SSL inbound inspection
        """
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)

    @_builtins.property
    @pulumi.getter
    def certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of certificate names for SSL inbound inspection
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "certificates", value)


if not MYPY:
    class DeviceRedistributionCollectorRedistributionCollectorArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-ID collector interface
        """
elif False:
    DeviceRedistributionCollectorRedistributionCollectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceRedistributionCollectorRedistributionCollectorArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: User-ID collector interface
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-ID collector interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)


if not MYPY:
    class DhcpInterfaceRelayArgsDict(TypedDict):
        ip: pulumi.Input['DhcpInterfaceRelayIpArgsDict']
        """
        Ip
        """
elif False:
    DhcpInterfaceRelayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceRelayArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input['DhcpInterfaceRelayIpArgs']):
        """
        :param pulumi.Input['DhcpInterfaceRelayIpArgs'] ip: Ip
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input['DhcpInterfaceRelayIpArgs']:
        """
        Ip
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input['DhcpInterfaceRelayIpArgs']):
        pulumi.set(self, "ip", value)


if not MYPY:
    class DhcpInterfaceRelayIpArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enabled?
        """
        servers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Server
        """
elif False:
    DhcpInterfaceRelayIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceRelayIpArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 servers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enabled?
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] servers: Server
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Server
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class DhcpInterfaceServerArgsDict(TypedDict):
        ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IP address pools
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        DHCP server mode
        """
        option: NotRequired[pulumi.Input['DhcpInterfaceServerOptionArgsDict']]
        """
        Option
        """
        probe_ip: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Ping IP before allocating?
        """
        reserveds: NotRequired[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerReservedArgsDict']]]]
        """
        List of IP reservations
        """
elif False:
    DhcpInterfaceServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerArgs:
    def __init__(__self__, *,
                 ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 option: Optional[pulumi.Input['DhcpInterfaceServerOptionArgs']] = None,
                 probe_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 reserveds: Optional[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerReservedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_pools: List of IP address pools
        :param pulumi.Input[_builtins.str] mode: DHCP server mode
        :param pulumi.Input['DhcpInterfaceServerOptionArgs'] option: Option
        :param pulumi.Input[_builtins.bool] probe_ip: Ping IP before allocating?
        :param pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerReservedArgs']]] reserveds: List of IP reservations
        """
        if ip_pools is not None:
            pulumi.set(__self__, "ip_pools", ip_pools)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if option is not None:
            pulumi.set(__self__, "option", option)
        if probe_ip is not None:
            pulumi.set(__self__, "probe_ip", probe_ip)
        if reserveds is not None:
            pulumi.set(__self__, "reserveds", reserveds)

    @_builtins.property
    @pulumi.getter(name="ipPools")
    def ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IP address pools
        """
        return pulumi.get(self, "ip_pools")

    @ip_pools.setter
    def ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_pools", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DHCP server mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionArgs']]:
        """
        Option
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionArgs']]):
        pulumi.set(self, "option", value)

    @_builtins.property
    @pulumi.getter(name="probeIp")
    def probe_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Ping IP before allocating?
        """
        return pulumi.get(self, "probe_ip")

    @probe_ip.setter
    def probe_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "probe_ip", value)

    @_builtins.property
    @pulumi.getter
    def reserveds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerReservedArgs']]]]:
        """
        List of IP reservations
        """
        return pulumi.get(self, "reserveds")

    @reserveds.setter
    def reserveds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerReservedArgs']]]]):
        pulumi.set(self, "reserveds", value)


if not MYPY:
    class DhcpInterfaceServerOptionArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input['DhcpInterfaceServerOptionDnsArgsDict']]
        """
        Dns
        """
        dns_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS suffix
        """
        gateway: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default gateway
        """
        inheritance: NotRequired[pulumi.Input['DhcpInterfaceServerOptionInheritanceArgsDict']]
        """
        Inheritance
        """
        lease: NotRequired[pulumi.Input['DhcpInterfaceServerOptionLeaseArgsDict']]
        """
        Lease
        """
        nis: NotRequired[pulumi.Input['DhcpInterfaceServerOptionNisArgsDict']]
        """
        Nis
        """
        ntp: NotRequired[pulumi.Input['DhcpInterfaceServerOptionNtpArgsDict']]
        """
        Ntp
        """
        pop3_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        POP3 server
        """
        smtp_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        SMTP server
        """
        subnet_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet mask
        """
        user_defineds: NotRequired[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerOptionUserDefinedArgsDict']]]]
        """
        Custom DHCP options
        """
        wins: NotRequired[pulumi.Input['DhcpInterfaceServerOptionWinsArgsDict']]
        """
        Wins
        """
elif False:
    DhcpInterfaceServerOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input['DhcpInterfaceServerOptionDnsArgs']] = None,
                 dns_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway: Optional[pulumi.Input[_builtins.str]] = None,
                 inheritance: Optional[pulumi.Input['DhcpInterfaceServerOptionInheritanceArgs']] = None,
                 lease: Optional[pulumi.Input['DhcpInterfaceServerOptionLeaseArgs']] = None,
                 nis: Optional[pulumi.Input['DhcpInterfaceServerOptionNisArgs']] = None,
                 ntp: Optional[pulumi.Input['DhcpInterfaceServerOptionNtpArgs']] = None,
                 pop3_server: Optional[pulumi.Input[_builtins.str]] = None,
                 smtp_server: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_mask: Optional[pulumi.Input[_builtins.str]] = None,
                 user_defineds: Optional[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerOptionUserDefinedArgs']]]] = None,
                 wins: Optional[pulumi.Input['DhcpInterfaceServerOptionWinsArgs']] = None):
        """
        :param pulumi.Input['DhcpInterfaceServerOptionDnsArgs'] dns: Dns
        :param pulumi.Input[_builtins.str] dns_suffix: DNS suffix
        :param pulumi.Input[_builtins.str] gateway: Default gateway
        :param pulumi.Input['DhcpInterfaceServerOptionInheritanceArgs'] inheritance: Inheritance
        :param pulumi.Input['DhcpInterfaceServerOptionLeaseArgs'] lease: Lease
        :param pulumi.Input['DhcpInterfaceServerOptionNisArgs'] nis: Nis
        :param pulumi.Input['DhcpInterfaceServerOptionNtpArgs'] ntp: Ntp
        :param pulumi.Input[_builtins.str] pop3_server: POP3 server
        :param pulumi.Input[_builtins.str] smtp_server: SMTP server
        :param pulumi.Input[_builtins.str] subnet_mask: Subnet mask
        :param pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerOptionUserDefinedArgs']]] user_defineds: Custom DHCP options
        :param pulumi.Input['DhcpInterfaceServerOptionWinsArgs'] wins: Wins
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if inheritance is not None:
            pulumi.set(__self__, "inheritance", inheritance)
        if lease is not None:
            pulumi.set(__self__, "lease", lease)
        if nis is not None:
            pulumi.set(__self__, "nis", nis)
        if ntp is not None:
            pulumi.set(__self__, "ntp", ntp)
        if pop3_server is not None:
            pulumi.set(__self__, "pop3_server", pop3_server)
        if smtp_server is not None:
            pulumi.set(__self__, "smtp_server", smtp_server)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if user_defineds is not None:
            pulumi.set(__self__, "user_defineds", user_defineds)
        if wins is not None:
            pulumi.set(__self__, "wins", wins)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionDnsArgs']]:
        """
        Dns
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionDnsArgs']]):
        pulumi.set(self, "dns", value)

    @_builtins.property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @dns_suffix.setter
    def dns_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_suffix", value)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default gateway
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def inheritance(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionInheritanceArgs']]:
        """
        Inheritance
        """
        return pulumi.get(self, "inheritance")

    @inheritance.setter
    def inheritance(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionInheritanceArgs']]):
        pulumi.set(self, "inheritance", value)

    @_builtins.property
    @pulumi.getter
    def lease(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionLeaseArgs']]:
        """
        Lease
        """
        return pulumi.get(self, "lease")

    @lease.setter
    def lease(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionLeaseArgs']]):
        pulumi.set(self, "lease", value)

    @_builtins.property
    @pulumi.getter
    def nis(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionNisArgs']]:
        """
        Nis
        """
        return pulumi.get(self, "nis")

    @nis.setter
    def nis(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionNisArgs']]):
        pulumi.set(self, "nis", value)

    @_builtins.property
    @pulumi.getter
    def ntp(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionNtpArgs']]:
        """
        Ntp
        """
        return pulumi.get(self, "ntp")

    @ntp.setter
    def ntp(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionNtpArgs']]):
        pulumi.set(self, "ntp", value)

    @_builtins.property
    @pulumi.getter(name="pop3Server")
    def pop3_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        POP3 server
        """
        return pulumi.get(self, "pop3_server")

    @pop3_server.setter
    def pop3_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pop3_server", value)

    @_builtins.property
    @pulumi.getter(name="smtpServer")
    def smtp_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SMTP server
        """
        return pulumi.get(self, "smtp_server")

    @smtp_server.setter
    def smtp_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "smtp_server", value)

    @_builtins.property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet mask
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_mask", value)

    @_builtins.property
    @pulumi.getter(name="userDefineds")
    def user_defineds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerOptionUserDefinedArgs']]]]:
        """
        Custom DHCP options
        """
        return pulumi.get(self, "user_defineds")

    @user_defineds.setter
    def user_defineds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DhcpInterfaceServerOptionUserDefinedArgs']]]]):
        pulumi.set(self, "user_defineds", value)

    @_builtins.property
    @pulumi.getter
    def wins(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionWinsArgs']]:
        """
        Wins
        """
        return pulumi.get(self, "wins")

    @wins.setter
    def wins(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionWinsArgs']]):
        pulumi.set(self, "wins", value)


if not MYPY:
    class DhcpInterfaceServerOptionDnsArgsDict(TypedDict):
        primary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary DNS server
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary DNS server
        """
elif False:
    DhcpInterfaceServerOptionDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionDnsArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] primary: Primary DNS server
        :param pulumi.Input[_builtins.str] secondary: Secondary DNS server
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary DNS server
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DhcpInterfaceServerOptionInheritanceArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface from which to inherit lease options
        """
elif False:
    DhcpInterfaceServerOptionInheritanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionInheritanceArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Interface from which to inherit lease options
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface from which to inherit lease options
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class DhcpInterfaceServerOptionLeaseArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        DHCP lease timeout (minutes)
        """
        unlimited: NotRequired[pulumi.Input['DhcpInterfaceServerOptionLeaseUnlimitedArgsDict']]
        """
        Unlimited

        >  **Note:** You must specify exactly one of `timeout` and `unlimited`.
        """
elif False:
    DhcpInterfaceServerOptionLeaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionLeaseArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 unlimited: Optional[pulumi.Input['DhcpInterfaceServerOptionLeaseUnlimitedArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] timeout: DHCP lease timeout (minutes)
        :param pulumi.Input['DhcpInterfaceServerOptionLeaseUnlimitedArgs'] unlimited: Unlimited
               
               >  **Note:** You must specify exactly one of `timeout` and `unlimited`.
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unlimited is not None:
            pulumi.set(__self__, "unlimited", unlimited)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        DHCP lease timeout (minutes)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def unlimited(self) -> Optional[pulumi.Input['DhcpInterfaceServerOptionLeaseUnlimitedArgs']]:
        """
        Unlimited

        >  **Note:** You must specify exactly one of `timeout` and `unlimited`.
        """
        return pulumi.get(self, "unlimited")

    @unlimited.setter
    def unlimited(self, value: Optional[pulumi.Input['DhcpInterfaceServerOptionLeaseUnlimitedArgs']]):
        pulumi.set(self, "unlimited", value)


if not MYPY:
    class DhcpInterfaceServerOptionLeaseUnlimitedArgsDict(TypedDict):
        pass
elif False:
    DhcpInterfaceServerOptionLeaseUnlimitedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionLeaseUnlimitedArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DhcpInterfaceServerOptionNisArgsDict(TypedDict):
        primary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary NIS server
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary NIS server
        """
elif False:
    DhcpInterfaceServerOptionNisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionNisArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] primary: Primary NIS server
        :param pulumi.Input[_builtins.str] secondary: Secondary NIS server
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary NIS server
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary NIS server
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DhcpInterfaceServerOptionNtpArgsDict(TypedDict):
        primary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary NTP server
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary NTP server
        """
elif False:
    DhcpInterfaceServerOptionNtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionNtpArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] primary: Primary NTP server
        :param pulumi.Input[_builtins.str] secondary: Secondary NTP server
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary NTP server
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary NTP server
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DhcpInterfaceServerOptionUserDefinedArgsDict(TypedDict):
        inherited: pulumi.Input[_builtins.bool]
        """
        Inherited from DHCP server inheritance source?
        """
        name: pulumi.Input[_builtins.str]
        """
        Option name
        """
        asciis: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Ascii
        """
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Option code
        """
        hexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Hex
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Ip
        """
elif False:
    DhcpInterfaceServerOptionUserDefinedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionUserDefinedArgs:
    def __init__(__self__, *,
                 inherited: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str],
                 asciis: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 hexes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] inherited: Inherited from DHCP server inheritance source?
        :param pulumi.Input[_builtins.str] name: Option name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] asciis: Ascii
        :param pulumi.Input[_builtins.int] code: Option code
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] hexes: Hex
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: Ip
        """
        pulumi.set(__self__, "inherited", inherited)
        pulumi.set(__self__, "name", name)
        if asciis is not None:
            pulumi.set(__self__, "asciis", asciis)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if hexes is not None:
            pulumi.set(__self__, "hexes", hexes)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @_builtins.property
    @pulumi.getter
    def inherited(self) -> pulumi.Input[_builtins.bool]:
        """
        Inherited from DHCP server inheritance source?
        """
        return pulumi.get(self, "inherited")

    @inherited.setter
    def inherited(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "inherited", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Option name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def asciis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Ascii
        """
        return pulumi.get(self, "asciis")

    @asciis.setter
    def asciis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "asciis", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Option code
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def hexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Hex
        """
        return pulumi.get(self, "hexes")

    @hexes.setter
    def hexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "hexes", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Ip
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ips", value)


if not MYPY:
    class DhcpInterfaceServerOptionWinsArgsDict(TypedDict):
        primary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary WINS server
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary WINS server
        """
elif False:
    DhcpInterfaceServerOptionWinsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerOptionWinsArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] primary: Primary WINS server
        :param pulumi.Input[_builtins.str] secondary: Secondary WINS server
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary WINS server
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary WINS server
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DhcpInterfaceServerReservedArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reservation description
        """
        mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved MAC address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved IP address
        """
elif False:
    DhcpInterfaceServerReservedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DhcpInterfaceServerReservedArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 mac: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Reservation description
        :param pulumi.Input[_builtins.str] mac: Reserved MAC address
        :param pulumi.Input[_builtins.str] name: Reserved IP address
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reservation description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved MAC address
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DnsProxyCacheArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Turn on caching for this DNS object
        """
        cache_edns: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Cache EDNS UDP response
        """
        max_ttl: NotRequired[pulumi.Input['DnsProxyCacheMaxTtlArgsDict']]
        """
        Max ttl
        """
elif False:
    DnsProxyCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyCacheArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 cache_edns: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_ttl: Optional[pulumi.Input['DnsProxyCacheMaxTtlArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Turn on caching for this DNS object
        :param pulumi.Input[_builtins.bool] cache_edns: Cache EDNS UDP response
        :param pulumi.Input['DnsProxyCacheMaxTtlArgs'] max_ttl: Max ttl
        """
        pulumi.set(__self__, "enabled", enabled)
        if cache_edns is not None:
            pulumi.set(__self__, "cache_edns", cache_edns)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Turn on caching for this DNS object
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="cacheEdns")
    def cache_edns(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Cache EDNS UDP response
        """
        return pulumi.get(self, "cache_edns")

    @cache_edns.setter
    def cache_edns(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cache_edns", value)

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[pulumi.Input['DnsProxyCacheMaxTtlArgs']]:
        """
        Max ttl
        """
        return pulumi.get(self, "max_ttl")

    @max_ttl.setter
    def max_ttl(self, value: Optional[pulumi.Input['DnsProxyCacheMaxTtlArgs']]):
        pulumi.set(self, "max_ttl", value)


if not MYPY:
    class DnsProxyCacheMaxTtlArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable max ttl for this DNS object
        """
        time_to_live: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in seconds after which entry is cleared
        """
elif False:
    DnsProxyCacheMaxTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyCacheMaxTtlArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 time_to_live: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable max ttl for this DNS object
        :param pulumi.Input[_builtins.int] time_to_live: Time in seconds after which entry is cleared
        """
        pulumi.set(__self__, "enabled", enabled)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable max ttl for this DNS object
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in seconds after which entry is cleared
        """
        return pulumi.get(self, "time_to_live")

    @time_to_live.setter
    def time_to_live(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "time_to_live", value)


if not MYPY:
    class DnsProxyDefaultArgsDict(TypedDict):
        primary: pulumi.Input[_builtins.str]
        """
        Primary DNS Name server IP address
        """
        inheritance: NotRequired[pulumi.Input['DnsProxyDefaultInheritanceArgsDict']]
        """
        Inheritance
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary DNS Name server IP address
        """
elif False:
    DnsProxyDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyDefaultArgs:
    def __init__(__self__, *,
                 primary: pulumi.Input[_builtins.str],
                 inheritance: Optional[pulumi.Input['DnsProxyDefaultInheritanceArgs']] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] primary: Primary DNS Name server IP address
        :param pulumi.Input['DnsProxyDefaultInheritanceArgs'] inheritance: Inheritance
        :param pulumi.Input[_builtins.str] secondary: Secondary DNS Name server IP address
        """
        pulumi.set(__self__, "primary", primary)
        if inheritance is not None:
            pulumi.set(__self__, "inheritance", inheritance)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input[_builtins.str]:
        """
        Primary DNS Name server IP address
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def inheritance(self) -> Optional[pulumi.Input['DnsProxyDefaultInheritanceArgs']]:
        """
        Inheritance
        """
        return pulumi.get(self, "inheritance")

    @inheritance.setter
    def inheritance(self, value: Optional[pulumi.Input['DnsProxyDefaultInheritanceArgs']]):
        pulumi.set(self, "inheritance", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary DNS Name server IP address
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DnsProxyDefaultInheritanceArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dynamic interface
        """
elif False:
    DnsProxyDefaultInheritanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyDefaultInheritanceArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Dynamic interface
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dynamic interface
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class DnsProxyDomainServerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Proxy rule name
        """
        primary: pulumi.Input[_builtins.str]
        """
        Primary DNS server IP address
        """
        cacheable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable caching for this DNS proxy rule?
        """
        domain_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Domain names(s) that will be matched
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary DNS server IP address
        """
elif False:
    DnsProxyDomainServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyDomainServerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 primary: pulumi.Input[_builtins.str],
                 cacheable: Optional[pulumi.Input[_builtins.bool]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Proxy rule name
        :param pulumi.Input[_builtins.str] primary: Primary DNS server IP address
        :param pulumi.Input[_builtins.bool] cacheable: Enable caching for this DNS proxy rule?
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domain_names: Domain names(s) that will be matched
        :param pulumi.Input[_builtins.str] secondary: Secondary DNS server IP address
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        if cacheable is not None:
            pulumi.set(__self__, "cacheable", cacheable)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Proxy rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input[_builtins.str]:
        """
        Primary DNS server IP address
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def cacheable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable caching for this DNS proxy rule?
        """
        return pulumi.get(self, "cacheable")

    @cacheable.setter
    def cacheable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cacheable", value)

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Domain names(s) that will be matched
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domain_names", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary DNS server IP address
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DnsProxyStaticEntryArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Address
        """
        domain: pulumi.Input[_builtins.str]
        """
        Fully qualified domain name
        """
        name: pulumi.Input[_builtins.str]
        """
        Static entry name
        """
elif False:
    DnsProxyStaticEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyStaticEntryArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 domain: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: Address
        :param pulumi.Input[_builtins.str] domain: Fully qualified domain name
        :param pulumi.Input[_builtins.str] name: Static entry name
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Address
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        Fully qualified domain name
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Static entry name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DnsProxyTcpQueriesArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Turn on forwarding of TCP DNS queries?
        """
        max_pending_requests: NotRequired[pulumi.Input[_builtins.int]]
        """
        Upper limit on number of concurrent TCP DNS requests
        """
elif False:
    DnsProxyTcpQueriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyTcpQueriesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 max_pending_requests: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Turn on forwarding of TCP DNS queries?
        :param pulumi.Input[_builtins.int] max_pending_requests: Upper limit on number of concurrent TCP DNS requests
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Turn on forwarding of TCP DNS queries?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Upper limit on number of concurrent TCP DNS requests
        """
        return pulumi.get(self, "max_pending_requests")

    @max_pending_requests.setter
    def max_pending_requests(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pending_requests", value)


if not MYPY:
    class DnsProxyUdpQueriesArgsDict(TypedDict):
        retries: NotRequired[pulumi.Input['DnsProxyUdpQueriesRetriesArgsDict']]
        """
        Retries
        """
elif False:
    DnsProxyUdpQueriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyUdpQueriesArgs:
    def __init__(__self__, *,
                 retries: Optional[pulumi.Input['DnsProxyUdpQueriesRetriesArgs']] = None):
        """
        :param pulumi.Input['DnsProxyUdpQueriesRetriesArgs'] retries: Retries
        """
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input['DnsProxyUdpQueriesRetriesArgs']]:
        """
        Retries
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input['DnsProxyUdpQueriesRetriesArgs']]):
        pulumi.set(self, "retries", value)


if not MYPY:
    class DnsProxyUdpQueriesRetriesArgsDict(TypedDict):
        attempts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of retries before trying next name server
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in seconds for another request to be sent
        """
elif False:
    DnsProxyUdpQueriesRetriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsProxyUdpQueriesRetriesArgs:
    def __init__(__self__, *,
                 attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] attempts: Maximum number of retries before trying next name server
        :param pulumi.Input[_builtins.int] interval: Time in seconds for another request to be sent
        """
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of retries before trying next name server
        """
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "attempts", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in seconds for another request to be sent
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class DnsSecurityProfileBotnetDomainsArgsDict(TypedDict):
        dns_security_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgsDict']]]]
        """
        DNS categories
        """
        lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsListArgsDict']]]]
        """
        Dynamic lists of DNS domains
        """
        sinkhole: NotRequired[pulumi.Input['DnsSecurityProfileBotnetDomainsSinkholeArgsDict']]
        """
        DNS sinkhole settings
        """
        whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsWhitelistArgsDict']]]]
        """
        DNS security overrides
        """
elif False:
    DnsSecurityProfileBotnetDomainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsArgs:
    def __init__(__self__, *,
                 dns_security_categories: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgs']]]] = None,
                 lists: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsListArgs']]]] = None,
                 sinkhole: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsSinkholeArgs']] = None,
                 whitelists: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsWhitelistArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgs']]] dns_security_categories: DNS categories
        :param pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsListArgs']]] lists: Dynamic lists of DNS domains
        :param pulumi.Input['DnsSecurityProfileBotnetDomainsSinkholeArgs'] sinkhole: DNS sinkhole settings
        :param pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsWhitelistArgs']]] whitelists: DNS security overrides
        """
        if dns_security_categories is not None:
            pulumi.set(__self__, "dns_security_categories", dns_security_categories)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)
        if sinkhole is not None:
            pulumi.set(__self__, "sinkhole", sinkhole)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @_builtins.property
    @pulumi.getter(name="dnsSecurityCategories")
    def dns_security_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgs']]]]:
        """
        DNS categories
        """
        return pulumi.get(self, "dns_security_categories")

    @dns_security_categories.setter
    def dns_security_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgs']]]]):
        pulumi.set(self, "dns_security_categories", value)

    @_builtins.property
    @pulumi.getter
    def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsListArgs']]]]:
        """
        Dynamic lists of DNS domains
        """
        return pulumi.get(self, "lists")

    @lists.setter
    def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsListArgs']]]]):
        pulumi.set(self, "lists", value)

    @_builtins.property
    @pulumi.getter
    def sinkhole(self) -> Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsSinkholeArgs']]:
        """
        DNS sinkhole settings
        """
        return pulumi.get(self, "sinkhole")

    @sinkhole.setter
    def sinkhole(self, value: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsSinkholeArgs']]):
        pulumi.set(self, "sinkhole", value)

    @_builtins.property
    @pulumi.getter
    def whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsWhitelistArgs']]]]:
        """
        DNS security overrides
        """
        return pulumi.get(self, "whitelists")

    @whitelists.setter
    def whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSecurityProfileBotnetDomainsWhitelistArgs']]]]):
        pulumi.set(self, "whitelists", value)


if not MYPY:
    class DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log level
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        packet_capture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Packet capture
        """
elif False:
    DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsDnsSecurityCategoryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 log_level: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 packet_capture: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.str] log_level: Log level
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] packet_capture: Packet capture
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packet_capture is not None:
            pulumi.set(__self__, "packet_capture", packet_capture)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log level
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_level", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="packetCapture")
    def packet_capture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Packet capture
        """
        return pulumi.get(self, "packet_capture")

    @packet_capture.setter
    def packet_capture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packet_capture", value)


if not MYPY:
    class DnsSecurityProfileBotnetDomainsListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        action: NotRequired[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionArgsDict']]
        """
        Action
        """
        packet_capture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Packet capture
        """
elif False:
    DnsSecurityProfileBotnetDomainsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionArgs']] = None,
                 packet_capture: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['DnsSecurityProfileBotnetDomainsListActionArgs'] action: Action
        :param pulumi.Input[_builtins.str] packet_capture: Packet capture
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if packet_capture is not None:
            pulumi.set(__self__, "packet_capture", packet_capture)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionArgs']]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="packetCapture")
    def packet_capture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Packet capture
        """
        return pulumi.get(self, "packet_capture")

    @packet_capture.setter
    def packet_capture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packet_capture", value)


if not MYPY:
    class DnsSecurityProfileBotnetDomainsListActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
        block: NotRequired[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionBlockArgsDict']]
        """
        Block

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
        sinkhole: NotRequired[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionSinkholeArgsDict']]
        """
        Sinkhole

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
elif False:
    DnsSecurityProfileBotnetDomainsListActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsListActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionBlockArgs']] = None,
                 sinkhole: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionSinkholeArgs']] = None):
        """
        :param pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAlertArgs'] alert: Alert
        :param pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        :param pulumi.Input['DnsSecurityProfileBotnetDomainsListActionBlockArgs'] block: Block
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        :param pulumi.Input['DnsSecurityProfileBotnetDomainsListActionSinkholeArgs'] sinkhole: Sinkhole
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if sinkhole is not None:
            pulumi.set(__self__, "sinkhole", sinkhole)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionBlockArgs']]:
        """
        Block

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def sinkhole(self) -> Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionSinkholeArgs']]:
        """
        Sinkhole

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block`, and `sinkhole`.
        """
        return pulumi.get(self, "sinkhole")

    @sinkhole.setter
    def sinkhole(self, value: Optional[pulumi.Input['DnsSecurityProfileBotnetDomainsListActionSinkholeArgs']]):
        pulumi.set(self, "sinkhole", value)


if not MYPY:
    class DnsSecurityProfileBotnetDomainsListActionAlertArgsDict(TypedDict):
        pass
elif False:
    DnsSecurityProfileBotnetDomainsListActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsListActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DnsSecurityProfileBotnetDomainsListActionAllowArgsDict(TypedDict):
        pass
elif False:
    DnsSecurityProfileBotnetDomainsListActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsListActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DnsSecurityProfileBotnetDomainsListActionBlockArgsDict(TypedDict):
        pass
elif False:
    DnsSecurityProfileBotnetDomainsListActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsListActionBlockArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DnsSecurityProfileBotnetDomainsListActionSinkholeArgsDict(TypedDict):
        pass
elif False:
    DnsSecurityProfileBotnetDomainsListActionSinkholeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsListActionSinkholeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DnsSecurityProfileBotnetDomainsSinkholeArgsDict(TypedDict):
        ipv4_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv4 address
        """
        ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6 address
        """
elif False:
    DnsSecurityProfileBotnetDomainsSinkholeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsSinkholeArgs:
    def __init__(__self__, *,
                 ipv4_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4_address: Ipv4 address
        :param pulumi.Input[_builtins.str] ipv6_address: Ipv6 address
        """
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv4 address
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4_address", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6 address
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address", value)


if not MYPY:
    class DnsSecurityProfileBotnetDomainsWhitelistArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        DNS domain or FQDN to be whitelisted
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
elif False:
    DnsSecurityProfileBotnetDomainsWhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSecurityProfileBotnetDomainsWhitelistArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: DNS domain or FQDN to be whitelisted
        :param pulumi.Input[_builtins.str] description: Description
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        DNS domain or FQDN to be whitelisted
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DosProtectionProfileFloodArgsDict(TypedDict):
        icmp: NotRequired[pulumi.Input['DosProtectionProfileFloodIcmpArgsDict']]
        """
        Icmp
        """
        icmpv6: NotRequired[pulumi.Input['DosProtectionProfileFloodIcmpv6ArgsDict']]
        """
        Icmpv6
        """
        other_ip: NotRequired[pulumi.Input['DosProtectionProfileFloodOtherIpArgsDict']]
        """
        Other ip
        """
        tcp_syn: NotRequired[pulumi.Input['DosProtectionProfileFloodTcpSynArgsDict']]
        """
        Tcp syn
        """
        udp: NotRequired[pulumi.Input['DosProtectionProfileFloodUdpArgsDict']]
        """
        Udp
        """
elif False:
    DosProtectionProfileFloodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodArgs:
    def __init__(__self__, *,
                 icmp: Optional[pulumi.Input['DosProtectionProfileFloodIcmpArgs']] = None,
                 icmpv6: Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6Args']] = None,
                 other_ip: Optional[pulumi.Input['DosProtectionProfileFloodOtherIpArgs']] = None,
                 tcp_syn: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynArgs']] = None,
                 udp: Optional[pulumi.Input['DosProtectionProfileFloodUdpArgs']] = None):
        """
        :param pulumi.Input['DosProtectionProfileFloodIcmpArgs'] icmp: Icmp
        :param pulumi.Input['DosProtectionProfileFloodIcmpv6Args'] icmpv6: Icmpv6
        :param pulumi.Input['DosProtectionProfileFloodOtherIpArgs'] other_ip: Other ip
        :param pulumi.Input['DosProtectionProfileFloodTcpSynArgs'] tcp_syn: Tcp syn
        :param pulumi.Input['DosProtectionProfileFloodUdpArgs'] udp: Udp
        """
        if icmp is not None:
            pulumi.set(__self__, "icmp", icmp)
        if icmpv6 is not None:
            pulumi.set(__self__, "icmpv6", icmpv6)
        if other_ip is not None:
            pulumi.set(__self__, "other_ip", other_ip)
        if tcp_syn is not None:
            pulumi.set(__self__, "tcp_syn", tcp_syn)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def icmp(self) -> Optional[pulumi.Input['DosProtectionProfileFloodIcmpArgs']]:
        """
        Icmp
        """
        return pulumi.get(self, "icmp")

    @icmp.setter
    def icmp(self, value: Optional[pulumi.Input['DosProtectionProfileFloodIcmpArgs']]):
        pulumi.set(self, "icmp", value)

    @_builtins.property
    @pulumi.getter
    def icmpv6(self) -> Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6Args']]:
        """
        Icmpv6
        """
        return pulumi.get(self, "icmpv6")

    @icmpv6.setter
    def icmpv6(self, value: Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6Args']]):
        pulumi.set(self, "icmpv6", value)

    @_builtins.property
    @pulumi.getter(name="otherIp")
    def other_ip(self) -> Optional[pulumi.Input['DosProtectionProfileFloodOtherIpArgs']]:
        """
        Other ip
        """
        return pulumi.get(self, "other_ip")

    @other_ip.setter
    def other_ip(self, value: Optional[pulumi.Input['DosProtectionProfileFloodOtherIpArgs']]):
        pulumi.set(self, "other_ip", value)

    @_builtins.property
    @pulumi.getter(name="tcpSyn")
    def tcp_syn(self) -> Optional[pulumi.Input['DosProtectionProfileFloodTcpSynArgs']]:
        """
        Tcp syn
        """
        return pulumi.get(self, "tcp_syn")

    @tcp_syn.setter
    def tcp_syn(self, value: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynArgs']]):
        pulumi.set(self, "tcp_syn", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['DosProtectionProfileFloodUdpArgs']]:
        """
        Udp
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['DosProtectionProfileFloodUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class DosProtectionProfileFloodIcmpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        red: NotRequired[pulumi.Input['DosProtectionProfileFloodIcmpRedArgsDict']]
        """
        Red
        """
elif False:
    DosProtectionProfileFloodIcmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodIcmpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['DosProtectionProfileFloodIcmpRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['DosProtectionProfileFloodIcmpRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['DosProtectionProfileFloodIcmpRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['DosProtectionProfileFloodIcmpRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class DosProtectionProfileFloodIcmpRedArgsDict(TypedDict):
        activate_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Activate rate
        """
        alarm_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rate
        """
        block: NotRequired[pulumi.Input['DosProtectionProfileFloodIcmpRedBlockArgsDict']]
        """
        Block
        """
        maximal_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximal rate
        """
elif False:
    DosProtectionProfileFloodIcmpRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodIcmpRedArgs:
    def __init__(__self__, *,
                 activate_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 block: Optional[pulumi.Input['DosProtectionProfileFloodIcmpRedBlockArgs']] = None,
                 maximal_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input['DosProtectionProfileFloodIcmpRedBlockArgs'] block: Block
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        if activate_rate is not None:
            pulumi.set(__self__, "activate_rate", activate_rate)
        if alarm_rate is not None:
            pulumi.set(__self__, "alarm_rate", alarm_rate)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if maximal_rate is not None:
            pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DosProtectionProfileFloodIcmpRedBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DosProtectionProfileFloodIcmpRedBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class DosProtectionProfileFloodIcmpRedBlockArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
elif False:
    DosProtectionProfileFloodIcmpRedBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodIcmpRedBlockArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DosProtectionProfileFloodIcmpv6ArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        red: NotRequired[pulumi.Input['DosProtectionProfileFloodIcmpv6RedArgsDict']]
        """
        Red
        """
elif False:
    DosProtectionProfileFloodIcmpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodIcmpv6Args:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6RedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['DosProtectionProfileFloodIcmpv6RedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6RedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6RedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class DosProtectionProfileFloodIcmpv6RedArgsDict(TypedDict):
        activate_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Activate rate
        """
        alarm_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rate
        """
        block: NotRequired[pulumi.Input['DosProtectionProfileFloodIcmpv6RedBlockArgsDict']]
        """
        Block
        """
        maximal_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximal rate
        """
elif False:
    DosProtectionProfileFloodIcmpv6RedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodIcmpv6RedArgs:
    def __init__(__self__, *,
                 activate_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 block: Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6RedBlockArgs']] = None,
                 maximal_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input['DosProtectionProfileFloodIcmpv6RedBlockArgs'] block: Block
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        if activate_rate is not None:
            pulumi.set(__self__, "activate_rate", activate_rate)
        if alarm_rate is not None:
            pulumi.set(__self__, "alarm_rate", alarm_rate)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if maximal_rate is not None:
            pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6RedBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DosProtectionProfileFloodIcmpv6RedBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class DosProtectionProfileFloodIcmpv6RedBlockArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
elif False:
    DosProtectionProfileFloodIcmpv6RedBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodIcmpv6RedBlockArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DosProtectionProfileFloodOtherIpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        red: NotRequired[pulumi.Input['DosProtectionProfileFloodOtherIpRedArgsDict']]
        """
        Red
        """
elif False:
    DosProtectionProfileFloodOtherIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodOtherIpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['DosProtectionProfileFloodOtherIpRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['DosProtectionProfileFloodOtherIpRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['DosProtectionProfileFloodOtherIpRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['DosProtectionProfileFloodOtherIpRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class DosProtectionProfileFloodOtherIpRedArgsDict(TypedDict):
        activate_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Activate rate
        """
        alarm_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rate
        """
        block: NotRequired[pulumi.Input['DosProtectionProfileFloodOtherIpRedBlockArgsDict']]
        """
        Block
        """
        maximal_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximal rate
        """
elif False:
    DosProtectionProfileFloodOtherIpRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodOtherIpRedArgs:
    def __init__(__self__, *,
                 activate_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 block: Optional[pulumi.Input['DosProtectionProfileFloodOtherIpRedBlockArgs']] = None,
                 maximal_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input['DosProtectionProfileFloodOtherIpRedBlockArgs'] block: Block
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        if activate_rate is not None:
            pulumi.set(__self__, "activate_rate", activate_rate)
        if alarm_rate is not None:
            pulumi.set(__self__, "alarm_rate", alarm_rate)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if maximal_rate is not None:
            pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DosProtectionProfileFloodOtherIpRedBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DosProtectionProfileFloodOtherIpRedBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class DosProtectionProfileFloodOtherIpRedBlockArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
elif False:
    DosProtectionProfileFloodOtherIpRedBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodOtherIpRedBlockArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DosProtectionProfileFloodTcpSynArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        red: NotRequired[pulumi.Input['DosProtectionProfileFloodTcpSynRedArgsDict']]
        """
        Red
        """
        syn_cookies: NotRequired[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesArgsDict']]
        """
        Syn cookies
        """
elif False:
    DosProtectionProfileFloodTcpSynArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodTcpSynArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynRedArgs']] = None,
                 syn_cookies: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['DosProtectionProfileFloodTcpSynRedArgs'] red: Red
        :param pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesArgs'] syn_cookies: Syn cookies
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)
        if syn_cookies is not None:
            pulumi.set(__self__, "syn_cookies", syn_cookies)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['DosProtectionProfileFloodTcpSynRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynRedArgs']]):
        pulumi.set(self, "red", value)

    @_builtins.property
    @pulumi.getter(name="synCookies")
    def syn_cookies(self) -> Optional[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesArgs']]:
        """
        Syn cookies
        """
        return pulumi.get(self, "syn_cookies")

    @syn_cookies.setter
    def syn_cookies(self, value: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesArgs']]):
        pulumi.set(self, "syn_cookies", value)


if not MYPY:
    class DosProtectionProfileFloodTcpSynRedArgsDict(TypedDict):
        activate_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Activate rate
        """
        alarm_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rate
        """
        block: NotRequired[pulumi.Input['DosProtectionProfileFloodTcpSynRedBlockArgsDict']]
        """
        Block
        """
        maximal_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximal rate
        """
elif False:
    DosProtectionProfileFloodTcpSynRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodTcpSynRedArgs:
    def __init__(__self__, *,
                 activate_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 block: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynRedBlockArgs']] = None,
                 maximal_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input['DosProtectionProfileFloodTcpSynRedBlockArgs'] block: Block
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        if activate_rate is not None:
            pulumi.set(__self__, "activate_rate", activate_rate)
        if alarm_rate is not None:
            pulumi.set(__self__, "alarm_rate", alarm_rate)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if maximal_rate is not None:
            pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DosProtectionProfileFloodTcpSynRedBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynRedBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class DosProtectionProfileFloodTcpSynRedBlockArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
elif False:
    DosProtectionProfileFloodTcpSynRedBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodTcpSynRedBlockArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DosProtectionProfileFloodTcpSynSynCookiesArgsDict(TypedDict):
        activate_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Activate rate
        """
        alarm_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rate
        """
        block: NotRequired[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesBlockArgsDict']]
        """
        Block
        """
        maximal_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximal rate
        """
elif False:
    DosProtectionProfileFloodTcpSynSynCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodTcpSynSynCookiesArgs:
    def __init__(__self__, *,
                 activate_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 block: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesBlockArgs']] = None,
                 maximal_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesBlockArgs'] block: Block
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        if activate_rate is not None:
            pulumi.set(__self__, "activate_rate", activate_rate)
        if alarm_rate is not None:
            pulumi.set(__self__, "alarm_rate", alarm_rate)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if maximal_rate is not None:
            pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DosProtectionProfileFloodTcpSynSynCookiesBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class DosProtectionProfileFloodTcpSynSynCookiesBlockArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
elif False:
    DosProtectionProfileFloodTcpSynSynCookiesBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodTcpSynSynCookiesBlockArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DosProtectionProfileFloodUdpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        red: NotRequired[pulumi.Input['DosProtectionProfileFloodUdpRedArgsDict']]
        """
        Red
        """
elif False:
    DosProtectionProfileFloodUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodUdpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['DosProtectionProfileFloodUdpRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['DosProtectionProfileFloodUdpRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['DosProtectionProfileFloodUdpRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['DosProtectionProfileFloodUdpRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class DosProtectionProfileFloodUdpRedArgsDict(TypedDict):
        activate_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Activate rate
        """
        alarm_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm rate
        """
        block: NotRequired[pulumi.Input['DosProtectionProfileFloodUdpRedBlockArgsDict']]
        """
        Block
        """
        maximal_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximal rate
        """
elif False:
    DosProtectionProfileFloodUdpRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodUdpRedArgs:
    def __init__(__self__, *,
                 activate_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 block: Optional[pulumi.Input['DosProtectionProfileFloodUdpRedBlockArgs']] = None,
                 maximal_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input['DosProtectionProfileFloodUdpRedBlockArgs'] block: Block
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        if activate_rate is not None:
            pulumi.set(__self__, "activate_rate", activate_rate)
        if alarm_rate is not None:
            pulumi.set(__self__, "alarm_rate", alarm_rate)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if maximal_rate is not None:
            pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['DosProtectionProfileFloodUdpRedBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['DosProtectionProfileFloodUdpRedBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class DosProtectionProfileFloodUdpRedBlockArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
elif False:
    DosProtectionProfileFloodUdpRedBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileFloodUdpRedBlockArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DosProtectionProfileResourceArgsDict(TypedDict):
        sessions: NotRequired[pulumi.Input['DosProtectionProfileResourceSessionsArgsDict']]
        """
        Sessions
        """
elif False:
    DosProtectionProfileResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileResourceArgs:
    def __init__(__self__, *,
                 sessions: Optional[pulumi.Input['DosProtectionProfileResourceSessionsArgs']] = None):
        """
        :param pulumi.Input['DosProtectionProfileResourceSessionsArgs'] sessions: Sessions
        """
        if sessions is not None:
            pulumi.set(__self__, "sessions", sessions)

    @_builtins.property
    @pulumi.getter
    def sessions(self) -> Optional[pulumi.Input['DosProtectionProfileResourceSessionsArgs']]:
        """
        Sessions
        """
        return pulumi.get(self, "sessions")

    @sessions.setter
    def sessions(self, value: Optional[pulumi.Input['DosProtectionProfileResourceSessionsArgs']]):
        pulumi.set(self, "sessions", value)


if not MYPY:
    class DosProtectionProfileResourceSessionsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled
        """
        max_concurrent_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max concurrent limit
        """
elif False:
    DosProtectionProfileResourceSessionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionProfileResourceSessionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_concurrent_limit: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enabled
        :param pulumi.Input[_builtins.int] max_concurrent_limit: Max concurrent limit
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_concurrent_limit is not None:
            pulumi.set(__self__, "max_concurrent_limit", max_concurrent_limit)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentLimit")
    def max_concurrent_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max concurrent limit
        """
        return pulumi.get(self, "max_concurrent_limit")

    @max_concurrent_limit.setter
    def max_concurrent_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_concurrent_limit", value)


if not MYPY:
    class DosProtectionRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['DosProtectionRuleActionAllowArgsDict']]
        """
        Allow
        """
        deny: NotRequired[pulumi.Input['DosProtectionRuleActionDenyArgsDict']]
        """
        Deny

        >  **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
        """
        protect: NotRequired[pulumi.Input['DosProtectionRuleActionProtectArgsDict']]
        """
        Protect

        >  **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
        """
elif False:
    DosProtectionRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['DosProtectionRuleActionAllowArgs']] = None,
                 deny: Optional[pulumi.Input['DosProtectionRuleActionDenyArgs']] = None,
                 protect: Optional[pulumi.Input['DosProtectionRuleActionProtectArgs']] = None):
        """
        :param pulumi.Input['DosProtectionRuleActionAllowArgs'] allow: Allow
        :param pulumi.Input['DosProtectionRuleActionDenyArgs'] deny: Deny
               
               >  **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
        :param pulumi.Input['DosProtectionRuleActionProtectArgs'] protect: Protect
               
               >  **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if deny is not None:
            pulumi.set(__self__, "deny", deny)
        if protect is not None:
            pulumi.set(__self__, "protect", protect)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['DosProtectionRuleActionAllowArgs']]:
        """
        Allow
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['DosProtectionRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def deny(self) -> Optional[pulumi.Input['DosProtectionRuleActionDenyArgs']]:
        """
        Deny

        >  **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
        """
        return pulumi.get(self, "deny")

    @deny.setter
    def deny(self, value: Optional[pulumi.Input['DosProtectionRuleActionDenyArgs']]):
        pulumi.set(self, "deny", value)

    @_builtins.property
    @pulumi.getter
    def protect(self) -> Optional[pulumi.Input['DosProtectionRuleActionProtectArgs']]:
        """
        Protect

        >  **Note:** You must specify exactly one of `allow`, `deny`, and `protect`.
        """
        return pulumi.get(self, "protect")

    @protect.setter
    def protect(self, value: Optional[pulumi.Input['DosProtectionRuleActionProtectArgs']]):
        pulumi.set(self, "protect", value)


if not MYPY:
    class DosProtectionRuleActionAllowArgsDict(TypedDict):
        pass
elif False:
    DosProtectionRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DosProtectionRuleActionDenyArgsDict(TypedDict):
        pass
elif False:
    DosProtectionRuleActionDenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleActionDenyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DosProtectionRuleActionProtectArgsDict(TypedDict):
        pass
elif False:
    DosProtectionRuleActionProtectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleActionProtectArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DosProtectionRuleProtectionArgsDict(TypedDict):
        aggregate: NotRequired[pulumi.Input['DosProtectionRuleProtectionAggregateArgsDict']]
        """
        Aggregate
        """
        classified: NotRequired[pulumi.Input['DosProtectionRuleProtectionClassifiedArgsDict']]
        """
        Classified

        >  **Note:** You must specify exactly one of `aggregate` and `classified`.
        """
elif False:
    DosProtectionRuleProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleProtectionArgs:
    def __init__(__self__, *,
                 aggregate: Optional[pulumi.Input['DosProtectionRuleProtectionAggregateArgs']] = None,
                 classified: Optional[pulumi.Input['DosProtectionRuleProtectionClassifiedArgs']] = None):
        """
        :param pulumi.Input['DosProtectionRuleProtectionAggregateArgs'] aggregate: Aggregate
        :param pulumi.Input['DosProtectionRuleProtectionClassifiedArgs'] classified: Classified
               
               >  **Note:** You must specify exactly one of `aggregate` and `classified`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if classified is not None:
            pulumi.set(__self__, "classified", classified)

    @_builtins.property
    @pulumi.getter
    def aggregate(self) -> Optional[pulumi.Input['DosProtectionRuleProtectionAggregateArgs']]:
        """
        Aggregate
        """
        return pulumi.get(self, "aggregate")

    @aggregate.setter
    def aggregate(self, value: Optional[pulumi.Input['DosProtectionRuleProtectionAggregateArgs']]):
        pulumi.set(self, "aggregate", value)

    @_builtins.property
    @pulumi.getter
    def classified(self) -> Optional[pulumi.Input['DosProtectionRuleProtectionClassifiedArgs']]:
        """
        Classified

        >  **Note:** You must specify exactly one of `aggregate` and `classified`.
        """
        return pulumi.get(self, "classified")

    @classified.setter
    def classified(self, value: Optional[pulumi.Input['DosProtectionRuleProtectionClassifiedArgs']]):
        pulumi.set(self, "classified", value)


if not MYPY:
    class DosProtectionRuleProtectionAggregateArgsDict(TypedDict):
        profile: pulumi.Input[_builtins.str]
        """
        Aggregate DoS protection profile
        """
elif False:
    DosProtectionRuleProtectionAggregateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleProtectionAggregateArgs:
    def __init__(__self__, *,
                 profile: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] profile: Aggregate DoS protection profile
        """
        pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> pulumi.Input[_builtins.str]:
        """
        Aggregate DoS protection profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class DosProtectionRuleProtectionClassifiedArgsDict(TypedDict):
        profile: pulumi.Input[_builtins.str]
        """
        Classified DoS protection profile
        """
        classification_criteria: NotRequired[pulumi.Input['DosProtectionRuleProtectionClassifiedClassificationCriteriaArgsDict']]
        """
        Classification criteria
        """
elif False:
    DosProtectionRuleProtectionClassifiedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleProtectionClassifiedArgs:
    def __init__(__self__, *,
                 profile: pulumi.Input[_builtins.str],
                 classification_criteria: Optional[pulumi.Input['DosProtectionRuleProtectionClassifiedClassificationCriteriaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Classified DoS protection profile
        :param pulumi.Input['DosProtectionRuleProtectionClassifiedClassificationCriteriaArgs'] classification_criteria: Classification criteria
        """
        pulumi.set(__self__, "profile", profile)
        if classification_criteria is not None:
            pulumi.set(__self__, "classification_criteria", classification_criteria)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> pulumi.Input[_builtins.str]:
        """
        Classified DoS protection profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile", value)

    @_builtins.property
    @pulumi.getter(name="classificationCriteria")
    def classification_criteria(self) -> Optional[pulumi.Input['DosProtectionRuleProtectionClassifiedClassificationCriteriaArgs']]:
        """
        Classification criteria
        """
        return pulumi.get(self, "classification_criteria")

    @classification_criteria.setter
    def classification_criteria(self, value: Optional[pulumi.Input['DosProtectionRuleProtectionClassifiedClassificationCriteriaArgs']]):
        pulumi.set(self, "classification_criteria", value)


if not MYPY:
    class DosProtectionRuleProtectionClassifiedClassificationCriteriaArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
elif False:
    DosProtectionRuleProtectionClassifiedClassificationCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DosProtectionRuleProtectionClassifiedClassificationCriteriaArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)


if not MYPY:
    class EthernetInterfaceLayer2ArgsDict(TypedDict):
        lldp: NotRequired[pulumi.Input['EthernetInterfaceLayer2LldpArgsDict']]
        """
        LLDP Settings
        """
        vlan_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Assign interface to VLAN tag
        """
elif False:
    EthernetInterfaceLayer2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer2Args:
    def __init__(__self__, *,
                 lldp: Optional[pulumi.Input['EthernetInterfaceLayer2LldpArgs']] = None,
                 vlan_tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['EthernetInterfaceLayer2LldpArgs'] lldp: LLDP Settings
        :param pulumi.Input[_builtins.str] vlan_tag: Assign interface to VLAN tag
        """
        if lldp is not None:
            pulumi.set(__self__, "lldp", lldp)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @_builtins.property
    @pulumi.getter
    def lldp(self) -> Optional[pulumi.Input['EthernetInterfaceLayer2LldpArgs']]:
        """
        LLDP Settings
        """
        return pulumi.get(self, "lldp")

    @lldp.setter
    def lldp(self, value: Optional[pulumi.Input['EthernetInterfaceLayer2LldpArgs']]):
        pulumi.set(self, "lldp", value)

    @_builtins.property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Assign interface to VLAN tag
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class EthernetInterfaceLayer2LldpArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Enable LLDP on Interface
        """
elif False:
    EthernetInterfaceLayer2LldpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer2LldpArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable LLDP on Interface
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable LLDP on Interface
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class EthernetInterfaceLayer3ArgsDict(TypedDict):
        arps: NotRequired[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3ArpArgsDict']]]]
        """
        Ethernet Interfaces ARP configuration
        """
        ddns_config: NotRequired[pulumi.Input['EthernetInterfaceLayer3DdnsConfigArgsDict']]
        """
        Dynamic DNS configuration specific to the Ethernet Interfaces.
        """
        dhcp_client: NotRequired[pulumi.Input['EthernetInterfaceLayer3DhcpClientArgsDict']]
        """
        Ethernet Interfaces DHCP Client Object
        """
        interface_management_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface management profile
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3IpArgsDict']]]]
        """
        Ethernet Interface IP addresses

        >  **Note:** You must specify exactly one of `dhcp_client`, `ip`, and `pppoe`.
        """
        mtu: NotRequired[pulumi.Input[_builtins.int]]
        """
        MTU
        """
        pppoe: NotRequired[pulumi.Input['EthernetInterfaceLayer3PppoeArgsDict']]
        """
        Pppoe

        >  **Note:** You must specify exactly one of `dhcp_client`, `ip`, and `pppoe`.
        """
elif False:
    EthernetInterfaceLayer3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3Args:
    def __init__(__self__, *,
                 arps: Optional[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3ArpArgs']]]] = None,
                 ddns_config: Optional[pulumi.Input['EthernetInterfaceLayer3DdnsConfigArgs']] = None,
                 dhcp_client: Optional[pulumi.Input['EthernetInterfaceLayer3DhcpClientArgs']] = None,
                 interface_management_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3IpArgs']]]] = None,
                 mtu: Optional[pulumi.Input[_builtins.int]] = None,
                 pppoe: Optional[pulumi.Input['EthernetInterfaceLayer3PppoeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3ArpArgs']]] arps: Ethernet Interfaces ARP configuration
        :param pulumi.Input['EthernetInterfaceLayer3DdnsConfigArgs'] ddns_config: Dynamic DNS configuration specific to the Ethernet Interfaces.
        :param pulumi.Input['EthernetInterfaceLayer3DhcpClientArgs'] dhcp_client: Ethernet Interfaces DHCP Client Object
        :param pulumi.Input[_builtins.str] interface_management_profile: Interface management profile
        :param pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3IpArgs']]] ips: Ethernet Interface IP addresses
               
               >  **Note:** You must specify exactly one of `dhcp_client`, `ip`, and `pppoe`.
        :param pulumi.Input[_builtins.int] mtu: MTU
        :param pulumi.Input['EthernetInterfaceLayer3PppoeArgs'] pppoe: Pppoe
               
               >  **Note:** You must specify exactly one of `dhcp_client`, `ip`, and `pppoe`.
        """
        if arps is not None:
            pulumi.set(__self__, "arps", arps)
        if ddns_config is not None:
            pulumi.set(__self__, "ddns_config", ddns_config)
        if dhcp_client is not None:
            pulumi.set(__self__, "dhcp_client", dhcp_client)
        if interface_management_profile is not None:
            pulumi.set(__self__, "interface_management_profile", interface_management_profile)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if pppoe is not None:
            pulumi.set(__self__, "pppoe", pppoe)

    @_builtins.property
    @pulumi.getter
    def arps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3ArpArgs']]]]:
        """
        Ethernet Interfaces ARP configuration
        """
        return pulumi.get(self, "arps")

    @arps.setter
    def arps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3ArpArgs']]]]):
        pulumi.set(self, "arps", value)

    @_builtins.property
    @pulumi.getter(name="ddnsConfig")
    def ddns_config(self) -> Optional[pulumi.Input['EthernetInterfaceLayer3DdnsConfigArgs']]:
        """
        Dynamic DNS configuration specific to the Ethernet Interfaces.
        """
        return pulumi.get(self, "ddns_config")

    @ddns_config.setter
    def ddns_config(self, value: Optional[pulumi.Input['EthernetInterfaceLayer3DdnsConfigArgs']]):
        pulumi.set(self, "ddns_config", value)

    @_builtins.property
    @pulumi.getter(name="dhcpClient")
    def dhcp_client(self) -> Optional[pulumi.Input['EthernetInterfaceLayer3DhcpClientArgs']]:
        """
        Ethernet Interfaces DHCP Client Object
        """
        return pulumi.get(self, "dhcp_client")

    @dhcp_client.setter
    def dhcp_client(self, value: Optional[pulumi.Input['EthernetInterfaceLayer3DhcpClientArgs']]):
        pulumi.set(self, "dhcp_client", value)

    @_builtins.property
    @pulumi.getter(name="interfaceManagementProfile")
    def interface_management_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface management profile
        """
        return pulumi.get(self, "interface_management_profile")

    @interface_management_profile.setter
    def interface_management_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface_management_profile", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3IpArgs']]]]:
        """
        Ethernet Interface IP addresses

        >  **Note:** You must specify exactly one of `dhcp_client`, `ip`, and `pppoe`.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EthernetInterfaceLayer3IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        MTU
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mtu", value)

    @_builtins.property
    @pulumi.getter
    def pppoe(self) -> Optional[pulumi.Input['EthernetInterfaceLayer3PppoeArgs']]:
        """
        Pppoe

        >  **Note:** You must specify exactly one of `dhcp_client`, `ip`, and `pppoe`.
        """
        return pulumi.get(self, "pppoe")

    @pppoe.setter
    def pppoe(self, value: Optional[pulumi.Input['EthernetInterfaceLayer3PppoeArgs']]):
        pulumi.set(self, "pppoe", value)


if not MYPY:
    class EthernetInterfaceLayer3ArpArgsDict(TypedDict):
        hw_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
elif False:
    EthernetInterfaceLayer3ArpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3ArpArgs:
    def __init__(__self__, *,
                 hw_address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hw_address: MAC address
        :param pulumi.Input[_builtins.str] name: IP address
        """
        if hw_address is not None:
            pulumi.set(__self__, "hw_address", hw_address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="hwAddress")
    def hw_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address
        """
        return pulumi.get(self, "hw_address")

    @hw_address.setter
    def hw_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hw_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class EthernetInterfaceLayer3DdnsConfigArgsDict(TypedDict):
        ddns_cert_profile: pulumi.Input[_builtins.str]
        """
        Certificate profile
        """
        ddns_hostname: pulumi.Input[_builtins.str]
        """
        Ddns hostname
        """
        ddns_vendor: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_vendor_config: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DDNS?
        """
        ddns_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP to register (static only)
        """
        ddns_update_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Update interval (days)
        """
elif False:
    EthernetInterfaceLayer3DdnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3DdnsConfigArgs:
    def __init__(__self__, *,
                 ddns_cert_profile: pulumi.Input[_builtins.str],
                 ddns_hostname: pulumi.Input[_builtins.str],
                 ddns_vendor: pulumi.Input[_builtins.str],
                 ddns_vendor_config: pulumi.Input[_builtins.str],
                 ddns_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ddns_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ddns_update_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ddns_cert_profile: Certificate profile
        :param pulumi.Input[_builtins.str] ddns_hostname: Ddns hostname
        :param pulumi.Input[_builtins.str] ddns_vendor: DDNS vendor
        :param pulumi.Input[_builtins.str] ddns_vendor_config: DDNS vendor
        :param pulumi.Input[_builtins.bool] ddns_enabled: Enable DDNS?
        :param pulumi.Input[_builtins.str] ddns_ip: IP to register (static only)
        :param pulumi.Input[_builtins.int] ddns_update_interval: Update interval (days)
        """
        pulumi.set(__self__, "ddns_cert_profile", ddns_cert_profile)
        pulumi.set(__self__, "ddns_hostname", ddns_hostname)
        pulumi.set(__self__, "ddns_vendor", ddns_vendor)
        pulumi.set(__self__, "ddns_vendor_config", ddns_vendor_config)
        if ddns_enabled is not None:
            pulumi.set(__self__, "ddns_enabled", ddns_enabled)
        if ddns_ip is not None:
            pulumi.set(__self__, "ddns_ip", ddns_ip)
        if ddns_update_interval is not None:
            pulumi.set(__self__, "ddns_update_interval", ddns_update_interval)

    @_builtins.property
    @pulumi.getter(name="ddnsCertProfile")
    def ddns_cert_profile(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate profile
        """
        return pulumi.get(self, "ddns_cert_profile")

    @ddns_cert_profile.setter
    def ddns_cert_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_cert_profile", value)

    @_builtins.property
    @pulumi.getter(name="ddnsHostname")
    def ddns_hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Ddns hostname
        """
        return pulumi.get(self, "ddns_hostname")

    @ddns_hostname.setter
    def ddns_hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_hostname", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendor")
    def ddns_vendor(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor")

    @ddns_vendor.setter
    def ddns_vendor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendorConfig")
    def ddns_vendor_config(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor_config")

    @ddns_vendor_config.setter
    def ddns_vendor_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor_config", value)

    @_builtins.property
    @pulumi.getter(name="ddnsEnabled")
    def ddns_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DDNS?
        """
        return pulumi.get(self, "ddns_enabled")

    @ddns_enabled.setter
    def ddns_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ddns_enabled", value)

    @_builtins.property
    @pulumi.getter(name="ddnsIp")
    def ddns_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP to register (static only)
        """
        return pulumi.get(self, "ddns_ip")

    @ddns_ip.setter
    def ddns_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddns_ip", value)

    @_builtins.property
    @pulumi.getter(name="ddnsUpdateInterval")
    def ddns_update_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Update interval (days)
        """
        return pulumi.get(self, "ddns_update_interval")

    @ddns_update_interval.setter
    def ddns_update_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ddns_update_interval", value)


if not MYPY:
    class EthernetInterfaceLayer3DhcpClientArgsDict(TypedDict):
        create_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically create default route pointing to default gateway provided by server
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric of the default route created
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DHCP?
        """
        send_hostname: NotRequired[pulumi.Input['EthernetInterfaceLayer3DhcpClientSendHostnameArgsDict']]
        """
        Ethernet Interfaces DHCP ClientSend hostname
        """
elif False:
    EthernetInterfaceLayer3DhcpClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3DhcpClientArgs:
    def __init__(__self__, *,
                 create_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_hostname: Optional[pulumi.Input['EthernetInterfaceLayer3DhcpClientSendHostnameArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] create_default_route: Automatically create default route pointing to default gateway provided by server
        :param pulumi.Input[_builtins.int] default_route_metric: Metric of the default route created
        :param pulumi.Input[_builtins.bool] enable: Enable DHCP?
        :param pulumi.Input['EthernetInterfaceLayer3DhcpClientSendHostnameArgs'] send_hostname: Ethernet Interfaces DHCP ClientSend hostname
        """
        if create_default_route is not None:
            pulumi.set(__self__, "create_default_route", create_default_route)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if send_hostname is not None:
            pulumi.set(__self__, "send_hostname", send_hostname)

    @_builtins.property
    @pulumi.getter(name="createDefaultRoute")
    def create_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically create default route pointing to default gateway provided by server
        """
        return pulumi.get(self, "create_default_route")

    @create_default_route.setter
    def create_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_default_route", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric of the default route created
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DHCP?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="sendHostname")
    def send_hostname(self) -> Optional[pulumi.Input['EthernetInterfaceLayer3DhcpClientSendHostnameArgs']]:
        """
        Ethernet Interfaces DHCP ClientSend hostname
        """
        return pulumi.get(self, "send_hostname")

    @send_hostname.setter
    def send_hostname(self, value: Optional[pulumi.Input['EthernetInterfaceLayer3DhcpClientSendHostnameArgs']]):
        pulumi.set(self, "send_hostname", value)


if not MYPY:
    class EthernetInterfaceLayer3DhcpClientSendHostnameArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set interface hostname
        """
elif False:
    EthernetInterfaceLayer3DhcpClientSendHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3DhcpClientSendHostnameArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] hostname: Set interface hostname
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set interface hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class EthernetInterfaceLayer3IpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Ethernet Interface IP addresses name
        """
elif False:
    EthernetInterfaceLayer3IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3IpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Ethernet Interface IP addresses name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Ethernet Interface IP addresses name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class EthernetInterfaceLayer3PppoeArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password
        """
        username: pulumi.Input[_builtins.str]
        """
        Username
        """
        access_concentrator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access concentrator
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication protocol
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric of the default route created
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        passive: NotRequired[pulumi.Input['EthernetInterfaceLayer3PppoePassiveArgsDict']]
        """
        Passive
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service
        """
        static_address: NotRequired[pulumi.Input['EthernetInterfaceLayer3PppoeStaticAddressArgsDict']]
        """
        Static address
        """
elif False:
    EthernetInterfaceLayer3PppoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3PppoeArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 access_concentrator: Optional[pulumi.Input[_builtins.str]] = None,
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 passive: Optional[pulumi.Input['EthernetInterfaceLayer3PppoePassiveArgs']] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 static_address: Optional[pulumi.Input['EthernetInterfaceLayer3PppoeStaticAddressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password
        :param pulumi.Input[_builtins.str] username: Username
        :param pulumi.Input[_builtins.str] access_concentrator: Access concentrator
        :param pulumi.Input[_builtins.str] authentication: Authentication protocol
        :param pulumi.Input[_builtins.int] default_route_metric: Metric of the default route created
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['EthernetInterfaceLayer3PppoePassiveArgs'] passive: Passive
        :param pulumi.Input[_builtins.str] service: Service
        :param pulumi.Input['EthernetInterfaceLayer3PppoeStaticAddressArgs'] static_address: Static address
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if access_concentrator is not None:
            pulumi.set(__self__, "access_concentrator", access_concentrator)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if static_address is not None:
            pulumi.set(__self__, "static_address", static_address)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="accessConcentrator")
    def access_concentrator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access concentrator
        """
        return pulumi.get(self, "access_concentrator")

    @access_concentrator.setter
    def access_concentrator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_concentrator", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication protocol
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric of the default route created
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input['EthernetInterfaceLayer3PppoePassiveArgs']]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input['EthernetInterfaceLayer3PppoePassiveArgs']]):
        pulumi.set(self, "passive", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="staticAddress")
    def static_address(self) -> Optional[pulumi.Input['EthernetInterfaceLayer3PppoeStaticAddressArgs']]:
        """
        Static address
        """
        return pulumi.get(self, "static_address")

    @static_address.setter
    def static_address(self, value: Optional[pulumi.Input['EthernetInterfaceLayer3PppoeStaticAddressArgs']]):
        pulumi.set(self, "static_address", value)


if not MYPY:
    class EthernetInterfaceLayer3PppoePassiveArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Passive Mode enabled
        """
elif False:
    EthernetInterfaceLayer3PppoePassiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3PppoePassiveArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enable: Passive Mode enabled
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Passive Mode enabled
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class EthernetInterfaceLayer3PppoeStaticAddressArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        Static IP address
        """
elif False:
    EthernetInterfaceLayer3PppoeStaticAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceLayer3PppoeStaticAddressArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: Static IP address
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        Static IP address
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class EthernetInterfacePoeArgsDict(TypedDict):
        poe_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled PoE?
        """
        poe_rsvd_pwr: NotRequired[pulumi.Input[_builtins.int]]
        """
        PoE reserved power
        """
elif False:
    EthernetInterfacePoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfacePoeArgs:
    def __init__(__self__, *,
                 poe_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 poe_rsvd_pwr: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] poe_enabled: Enabled PoE?
        :param pulumi.Input[_builtins.int] poe_rsvd_pwr: PoE reserved power
        """
        if poe_enabled is not None:
            pulumi.set(__self__, "poe_enabled", poe_enabled)
        if poe_rsvd_pwr is not None:
            pulumi.set(__self__, "poe_rsvd_pwr", poe_rsvd_pwr)

    @_builtins.property
    @pulumi.getter(name="poeEnabled")
    def poe_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled PoE?
        """
        return pulumi.get(self, "poe_enabled")

    @poe_enabled.setter
    def poe_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "poe_enabled", value)

    @_builtins.property
    @pulumi.getter(name="poeRsvdPwr")
    def poe_rsvd_pwr(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        PoE reserved power
        """
        return pulumi.get(self, "poe_rsvd_pwr")

    @poe_rsvd_pwr.setter
    def poe_rsvd_pwr(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "poe_rsvd_pwr", value)


if not MYPY:
    class EthernetInterfaceTapArgsDict(TypedDict):
        pass
elif False:
    EthernetInterfaceTapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EthernetInterfaceTapArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainArgsDict']]
        """
        Domain settings for Custom Domain type
        """
        imei: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiArgsDict']]
        """
        IMEI Configuration settings

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        imsi: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiArgsDict']]
        """
        IMSI Config for Custom IMSI type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        ip: NotRequired[pulumi.Input['ExternalDynamicListTypeIpArgsDict']]
        """
        IP settings for Custom IP type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        predefined_ip: NotRequired[pulumi.Input['ExternalDynamicListTypePredefinedIpArgsDict']]
        """
        Predefined IP settings for EDL type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        predefined_url: NotRequired[pulumi.Input['ExternalDynamicListTypePredefinedUrlArgsDict']]
        """
        Predefined URL settings for EDL type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        url: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlArgsDict']]
        """
        URL settings for Custom URL type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
elif False:
    ExternalDynamicListTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input['ExternalDynamicListTypeDomainArgs']] = None,
                 imei: Optional[pulumi.Input['ExternalDynamicListTypeImeiArgs']] = None,
                 imsi: Optional[pulumi.Input['ExternalDynamicListTypeImsiArgs']] = None,
                 ip: Optional[pulumi.Input['ExternalDynamicListTypeIpArgs']] = None,
                 predefined_ip: Optional[pulumi.Input['ExternalDynamicListTypePredefinedIpArgs']] = None,
                 predefined_url: Optional[pulumi.Input['ExternalDynamicListTypePredefinedUrlArgs']] = None,
                 url: Optional[pulumi.Input['ExternalDynamicListTypeUrlArgs']] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeDomainArgs'] domain: Domain settings for Custom Domain type
        :param pulumi.Input['ExternalDynamicListTypeImeiArgs'] imei: IMEI Configuration settings
               
               >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        :param pulumi.Input['ExternalDynamicListTypeImsiArgs'] imsi: IMSI Config for Custom IMSI type
               
               >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        :param pulumi.Input['ExternalDynamicListTypeIpArgs'] ip: IP settings for Custom IP type
               
               >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        :param pulumi.Input['ExternalDynamicListTypePredefinedIpArgs'] predefined_ip: Predefined IP settings for EDL type
               
               >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        :param pulumi.Input['ExternalDynamicListTypePredefinedUrlArgs'] predefined_url: Predefined URL settings for EDL type
               
               >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        :param pulumi.Input['ExternalDynamicListTypeUrlArgs'] url: URL settings for Custom URL type
               
               >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if imei is not None:
            pulumi.set(__self__, "imei", imei)
        if imsi is not None:
            pulumi.set(__self__, "imsi", imsi)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if predefined_ip is not None:
            pulumi.set(__self__, "predefined_ip", predefined_ip)
        if predefined_url is not None:
            pulumi.set(__self__, "predefined_url", predefined_url)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainArgs']]:
        """
        Domain settings for Custom Domain type
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainArgs']]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def imei(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiArgs']]:
        """
        IMEI Configuration settings

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        return pulumi.get(self, "imei")

    @imei.setter
    def imei(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiArgs']]):
        pulumi.set(self, "imei", value)

    @_builtins.property
    @pulumi.getter
    def imsi(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiArgs']]:
        """
        IMSI Config for Custom IMSI type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        return pulumi.get(self, "imsi")

    @imsi.setter
    def imsi(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiArgs']]):
        pulumi.set(self, "imsi", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpArgs']]:
        """
        IP settings for Custom IP type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="predefinedIp")
    def predefined_ip(self) -> Optional[pulumi.Input['ExternalDynamicListTypePredefinedIpArgs']]:
        """
        Predefined IP settings for EDL type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        return pulumi.get(self, "predefined_ip")

    @predefined_ip.setter
    def predefined_ip(self, value: Optional[pulumi.Input['ExternalDynamicListTypePredefinedIpArgs']]):
        pulumi.set(self, "predefined_ip", value)

    @_builtins.property
    @pulumi.getter(name="predefinedUrl")
    def predefined_url(self) -> Optional[pulumi.Input['ExternalDynamicListTypePredefinedUrlArgs']]:
        """
        Predefined URL settings for EDL type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        return pulumi.get(self, "predefined_url")

    @predefined_url.setter
    def predefined_url(self, value: Optional[pulumi.Input['ExternalDynamicListTypePredefinedUrlArgs']]):
        pulumi.set(self, "predefined_url", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlArgs']]:
        """
        URL settings for Custom URL type

        >  **Note:** You must specify exactly one of `domain`, `imei`, `imsi`, `ip`, `predefined_ip`, `predefined_url`, and `url`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlArgs']]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ExternalDynamicListTypeDomainArgsDict(TypedDict):
        recurring: pulumi.Input['ExternalDynamicListTypeDomainRecurringArgsDict']
        """
        Update Schedule for Custom Domain type
        """
        url: pulumi.Input[_builtins.str]
        """
        External URL for Custom Domain type
        """
        auth: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainAuthArgsDict']]
        """
        Authentication settings for Custom Domain type
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile for authenticating client certificates
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Domain Exception List for Custom Domain type
        """
        expand_domain: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable/Disable expand domain
        """
elif False:
    ExternalDynamicListTypeDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['ExternalDynamicListTypeDomainRecurringArgs'],
                 url: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ExternalDynamicListTypeDomainAuthArgs']] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expand_domain: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeDomainRecurringArgs'] recurring: Update Schedule for Custom Domain type
        :param pulumi.Input[_builtins.str] url: External URL for Custom Domain type
        :param pulumi.Input['ExternalDynamicListTypeDomainAuthArgs'] auth: Authentication settings for Custom Domain type
        :param pulumi.Input[_builtins.str] certificate_profile: Profile for authenticating client certificates
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: Domain Exception List for Custom Domain type
        :param pulumi.Input[_builtins.bool] expand_domain: Enable/Disable expand domain
        """
        pulumi.set(__self__, "recurring", recurring)
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)
        if expand_domain is not None:
            pulumi.set(__self__, "expand_domain", expand_domain)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['ExternalDynamicListTypeDomainRecurringArgs']:
        """
        Update Schedule for Custom Domain type
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['ExternalDynamicListTypeDomainRecurringArgs']):
        pulumi.set(self, "recurring", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        External URL for Custom Domain type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainAuthArgs']]:
        """
        Authentication settings for Custom Domain type
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile for authenticating client certificates
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Domain Exception List for Custom Domain type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)

    @_builtins.property
    @pulumi.getter(name="expandDomain")
    def expand_domain(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable/Disable expand domain
        """
        return pulumi.get(self, "expand_domain")

    @expand_domain.setter
    def expand_domain(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expand_domain", value)


if not MYPY:
    class ExternalDynamicListTypeDomainAuthArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for Custom Domain authentication
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for Custom Domain authentication
        """
elif False:
    ExternalDynamicListTypeDomainAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for Custom Domain authentication
        :param pulumi.Input[_builtins.str] username: Username for Custom Domain authentication
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for Custom Domain authentication
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for Custom Domain authentication
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ExternalDynamicListTypeDomainRecurringArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainRecurringDailyArgsDict']]
        """
        Daily settings for Domain recurring
        """
        five_minute: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainRecurringFiveMinuteArgsDict']]
        """
        Five minute settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        hourly: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainRecurringHourlyArgsDict']]
        """
        Hourly settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        monthly: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainRecurringMonthlyArgsDict']]
        """
        Monthly settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        weekly: NotRequired[pulumi.Input['ExternalDynamicListTypeDomainRecurringWeeklyArgsDict']]
        """
        Weekly settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
elif False:
    ExternalDynamicListTypeDomainRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainRecurringArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringDailyArgs']] = None,
                 five_minute: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringFiveMinuteArgs']] = None,
                 hourly: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringHourlyArgs']] = None,
                 monthly: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringMonthlyArgs']] = None,
                 weekly: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeDomainRecurringDailyArgs'] daily: Daily settings for Domain recurring
        :param pulumi.Input['ExternalDynamicListTypeDomainRecurringFiveMinuteArgs'] five_minute: Five minute settings for Domain recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeDomainRecurringHourlyArgs'] hourly: Hourly settings for Domain recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeDomainRecurringMonthlyArgs'] monthly: Monthly settings for Domain recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeDomainRecurringWeeklyArgs'] weekly: Weekly settings for Domain recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if five_minute is not None:
            pulumi.set(__self__, "five_minute", five_minute)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringDailyArgs']]:
        """
        Daily settings for Domain recurring
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="fiveMinute")
    def five_minute(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringFiveMinuteArgs']]:
        """
        Five minute settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "five_minute")

    @five_minute.setter
    def five_minute(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringFiveMinuteArgs']]):
        pulumi.set(self, "five_minute", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringHourlyArgs']]:
        """
        Hourly settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringMonthlyArgs']]:
        """
        Monthly settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringMonthlyArgs']]):
        pulumi.set(self, "monthly", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringWeeklyArgs']]:
        """
        Weekly settings for Domain recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeDomainRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class ExternalDynamicListTypeDomainRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Daily Time specification hh (e.g. 20) for Domain
        """
elif False:
    ExternalDynamicListTypeDomainRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Daily Time specification hh (e.g. 20) for Domain
        """
        pulumi.set(__self__, "at", at)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Daily Time specification hh (e.g. 20) for Domain
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)


if not MYPY:
    class ExternalDynamicListTypeDomainRecurringFiveMinuteArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeDomainRecurringFiveMinuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainRecurringFiveMinuteArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeDomainRecurringHourlyArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeDomainRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainRecurringHourlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeDomainRecurringMonthlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Monthly Time specification hh (e.g. 20) for domain
        """
        day_of_month: pulumi.Input[_builtins.int]
        """
        Day setting for monthly Domain updates
        """
elif False:
    ExternalDynamicListTypeDomainRecurringMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainRecurringMonthlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_month: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] at: Monthly Time specification hh (e.g. 20) for domain
        :param pulumi.Input[_builtins.int] day_of_month: Day setting for monthly Domain updates
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_month", day_of_month)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Monthly Time specification hh (e.g. 20) for domain
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[_builtins.int]:
        """
        Day setting for monthly Domain updates
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day_of_month", value)


if not MYPY:
    class ExternalDynamicListTypeDomainRecurringWeeklyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Weekly Time specification hh (e.g. 20) for Domain
        """
        day_of_week: pulumi.Input[_builtins.str]
        """
        Day of week
        """
elif False:
    ExternalDynamicListTypeDomainRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeDomainRecurringWeeklyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_week: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Weekly Time specification hh (e.g. 20) for Domain
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Weekly Time specification hh (e.g. 20) for Domain
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class ExternalDynamicListTypeImeiArgsDict(TypedDict):
        recurring: pulumi.Input['ExternalDynamicListTypeImeiRecurringArgsDict']
        """
        Recurring interval for IMEI updates
        """
        url: pulumi.Input[_builtins.str]
        """
        IMEI URL for Custom IMEI type
        """
        auth: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiAuthArgsDict']]
        """
        IMEI Auth Cnfig for Custom IMEI type
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        IMEI Certificate Profile for Custom IMEI type
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        IMEI Description for Custom IMEI type
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IMEI Exception List for Custom IMEI type
        """
elif False:
    ExternalDynamicListTypeImeiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['ExternalDynamicListTypeImeiRecurringArgs'],
                 url: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ExternalDynamicListTypeImeiAuthArgs']] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeImeiRecurringArgs'] recurring: Recurring interval for IMEI updates
        :param pulumi.Input[_builtins.str] url: IMEI URL for Custom IMEI type
        :param pulumi.Input['ExternalDynamicListTypeImeiAuthArgs'] auth: IMEI Auth Cnfig for Custom IMEI type
        :param pulumi.Input[_builtins.str] certificate_profile: IMEI Certificate Profile for Custom IMEI type
        :param pulumi.Input[_builtins.str] description: IMEI Description for Custom IMEI type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: IMEI Exception List for Custom IMEI type
        """
        pulumi.set(__self__, "recurring", recurring)
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['ExternalDynamicListTypeImeiRecurringArgs']:
        """
        Recurring interval for IMEI updates
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['ExternalDynamicListTypeImeiRecurringArgs']):
        pulumi.set(self, "recurring", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        IMEI URL for Custom IMEI type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiAuthArgs']]:
        """
        IMEI Auth Cnfig for Custom IMEI type
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IMEI Certificate Profile for Custom IMEI type
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IMEI Description for Custom IMEI type
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IMEI Exception List for Custom IMEI type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)


if not MYPY:
    class ExternalDynamicListTypeImeiAuthArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        IMEI Auth Password for Custom IMEI type
        """
        username: pulumi.Input[_builtins.str]
        """
        IMEI Auth username for Custom IMEI type
        """
elif False:
    ExternalDynamicListTypeImeiAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: IMEI Auth Password for Custom IMEI type
        :param pulumi.Input[_builtins.str] username: IMEI Auth username for Custom IMEI type
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        IMEI Auth Password for Custom IMEI type
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        IMEI Auth username for Custom IMEI type
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ExternalDynamicListTypeImeiRecurringArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiRecurringDailyArgsDict']]
        """
        Daily interval settings for IMEI updates
        """
        five_minute: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiRecurringFiveMinuteArgsDict']]
        """
        Five-minute interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        hourly: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiRecurringHourlyArgsDict']]
        """
        Hourly interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        monthly: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiRecurringMonthlyArgsDict']]
        """
        Monthly interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        weekly: NotRequired[pulumi.Input['ExternalDynamicListTypeImeiRecurringWeeklyArgsDict']]
        """
        Weekly interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
elif False:
    ExternalDynamicListTypeImeiRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiRecurringArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringDailyArgs']] = None,
                 five_minute: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringFiveMinuteArgs']] = None,
                 hourly: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringHourlyArgs']] = None,
                 monthly: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringMonthlyArgs']] = None,
                 weekly: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeImeiRecurringDailyArgs'] daily: Daily interval settings for IMEI updates
        :param pulumi.Input['ExternalDynamicListTypeImeiRecurringFiveMinuteArgs'] five_minute: Five-minute interval settings for IMEI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeImeiRecurringHourlyArgs'] hourly: Hourly interval settings for IMEI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeImeiRecurringMonthlyArgs'] monthly: Monthly interval settings for IMEI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeImeiRecurringWeeklyArgs'] weekly: Weekly interval settings for IMEI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if five_minute is not None:
            pulumi.set(__self__, "five_minute", five_minute)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringDailyArgs']]:
        """
        Daily interval settings for IMEI updates
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="fiveMinute")
    def five_minute(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringFiveMinuteArgs']]:
        """
        Five-minute interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "five_minute")

    @five_minute.setter
    def five_minute(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringFiveMinuteArgs']]):
        pulumi.set(self, "five_minute", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringHourlyArgs']]:
        """
        Hourly interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringMonthlyArgs']]:
        """
        Monthly interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringMonthlyArgs']]):
        pulumi.set(self, "monthly", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringWeeklyArgs']]:
        """
        Weekly interval settings for IMEI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImeiRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class ExternalDynamicListTypeImeiRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Daily Time specification hh (e.g. 20) for IMEI
        """
elif False:
    ExternalDynamicListTypeImeiRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Daily Time specification hh (e.g. 20) for IMEI
        """
        pulumi.set(__self__, "at", at)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Daily Time specification hh (e.g. 20) for IMEI
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)


if not MYPY:
    class ExternalDynamicListTypeImeiRecurringFiveMinuteArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeImeiRecurringFiveMinuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiRecurringFiveMinuteArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeImeiRecurringHourlyArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeImeiRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiRecurringHourlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeImeiRecurringMonthlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Monthly Time specification hh (e.g. 20) for IMEI
        """
        day_of_month: pulumi.Input[_builtins.int]
        """
        Day of month for IMEI updates
        """
elif False:
    ExternalDynamicListTypeImeiRecurringMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiRecurringMonthlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_month: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] at: Monthly Time specification hh (e.g. 20) for IMEI
        :param pulumi.Input[_builtins.int] day_of_month: Day of month for IMEI updates
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_month", day_of_month)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Monthly Time specification hh (e.g. 20) for IMEI
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[_builtins.int]:
        """
        Day of month for IMEI updates
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day_of_month", value)


if not MYPY:
    class ExternalDynamicListTypeImeiRecurringWeeklyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Weekly Time specification hh (e.g. 20) for IMEI
        """
        day_of_week: pulumi.Input[_builtins.str]
        """
        Day of week
        """
elif False:
    ExternalDynamicListTypeImeiRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImeiRecurringWeeklyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_week: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Weekly Time specification hh (e.g. 20) for IMEI
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Weekly Time specification hh (e.g. 20) for IMEI
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class ExternalDynamicListTypeImsiArgsDict(TypedDict):
        recurring: pulumi.Input['ExternalDynamicListTypeImsiRecurringArgsDict']
        """
        IMSI Recuring Config for Custom IMSI type
        """
        url: pulumi.Input[_builtins.str]
        """
        IMSI URL for Custom IMSI type
        """
        auth: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiAuthArgsDict']]
        """
        IMSI Auth Config for Custom IMSI type
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        IMSI Certificate Profile for Custom IMSI type
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        IMSI Description for Custom IMSI type
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IMSI Exception List for Custom IMSI type
        """
elif False:
    ExternalDynamicListTypeImsiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['ExternalDynamicListTypeImsiRecurringArgs'],
                 url: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ExternalDynamicListTypeImsiAuthArgs']] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeImsiRecurringArgs'] recurring: IMSI Recuring Config for Custom IMSI type
        :param pulumi.Input[_builtins.str] url: IMSI URL for Custom IMSI type
        :param pulumi.Input['ExternalDynamicListTypeImsiAuthArgs'] auth: IMSI Auth Config for Custom IMSI type
        :param pulumi.Input[_builtins.str] certificate_profile: IMSI Certificate Profile for Custom IMSI type
        :param pulumi.Input[_builtins.str] description: IMSI Description for Custom IMSI type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: IMSI Exception List for Custom IMSI type
        """
        pulumi.set(__self__, "recurring", recurring)
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['ExternalDynamicListTypeImsiRecurringArgs']:
        """
        IMSI Recuring Config for Custom IMSI type
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['ExternalDynamicListTypeImsiRecurringArgs']):
        pulumi.set(self, "recurring", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        IMSI URL for Custom IMSI type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiAuthArgs']]:
        """
        IMSI Auth Config for Custom IMSI type
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IMSI Certificate Profile for Custom IMSI type
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IMSI Description for Custom IMSI type
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IMSI Exception List for Custom IMSI type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)


if not MYPY:
    class ExternalDynamicListTypeImsiAuthArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        IMSI Auth Password for Custom IMSI type
        """
        username: pulumi.Input[_builtins.str]
        """
        IMSI Auth Username for Custom IMSI type
        """
elif False:
    ExternalDynamicListTypeImsiAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: IMSI Auth Password for Custom IMSI type
        :param pulumi.Input[_builtins.str] username: IMSI Auth Username for Custom IMSI type
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        IMSI Auth Password for Custom IMSI type
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        IMSI Auth Username for Custom IMSI type
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ExternalDynamicListTypeImsiRecurringArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiRecurringDailyArgsDict']]
        """
        Daily interval settings for IMSI updates
        """
        five_minute: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiRecurringFiveMinuteArgsDict']]
        """
        Five-minute interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        hourly: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiRecurringHourlyArgsDict']]
        """
        Hourly interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        monthly: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiRecurringMonthlyArgsDict']]
        """
        Monthly interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        weekly: NotRequired[pulumi.Input['ExternalDynamicListTypeImsiRecurringWeeklyArgsDict']]
        """
        Weekly interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
elif False:
    ExternalDynamicListTypeImsiRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiRecurringArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringDailyArgs']] = None,
                 five_minute: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringFiveMinuteArgs']] = None,
                 hourly: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringHourlyArgs']] = None,
                 monthly: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringMonthlyArgs']] = None,
                 weekly: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeImsiRecurringDailyArgs'] daily: Daily interval settings for IMSI updates
        :param pulumi.Input['ExternalDynamicListTypeImsiRecurringFiveMinuteArgs'] five_minute: Five-minute interval settings for IMSI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeImsiRecurringHourlyArgs'] hourly: Hourly interval settings for IMSI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeImsiRecurringMonthlyArgs'] monthly: Monthly interval settings for IMSI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeImsiRecurringWeeklyArgs'] weekly: Weekly interval settings for IMSI updates
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if five_minute is not None:
            pulumi.set(__self__, "five_minute", five_minute)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringDailyArgs']]:
        """
        Daily interval settings for IMSI updates
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="fiveMinute")
    def five_minute(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringFiveMinuteArgs']]:
        """
        Five-minute interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "five_minute")

    @five_minute.setter
    def five_minute(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringFiveMinuteArgs']]):
        pulumi.set(self, "five_minute", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringHourlyArgs']]:
        """
        Hourly interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringMonthlyArgs']]:
        """
        Monthly interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringMonthlyArgs']]):
        pulumi.set(self, "monthly", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringWeeklyArgs']]:
        """
        Weekly interval settings for IMSI updates

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeImsiRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class ExternalDynamicListTypeImsiRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Daily Time specification hh (e.g. 20) for IMSI
        """
elif False:
    ExternalDynamicListTypeImsiRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Daily Time specification hh (e.g. 20) for IMSI
        """
        pulumi.set(__self__, "at", at)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Daily Time specification hh (e.g. 20) for IMSI
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)


if not MYPY:
    class ExternalDynamicListTypeImsiRecurringFiveMinuteArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeImsiRecurringFiveMinuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiRecurringFiveMinuteArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeImsiRecurringHourlyArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeImsiRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiRecurringHourlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeImsiRecurringMonthlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Monthly Time specification hh (e.g. 20) for IMSI
        """
        day_of_month: pulumi.Input[_builtins.int]
        """
        Day of the month for monthly IMSI updates
        """
elif False:
    ExternalDynamicListTypeImsiRecurringMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiRecurringMonthlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_month: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] at: Monthly Time specification hh (e.g. 20) for IMSI
        :param pulumi.Input[_builtins.int] day_of_month: Day of the month for monthly IMSI updates
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_month", day_of_month)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Monthly Time specification hh (e.g. 20) for IMSI
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[_builtins.int]:
        """
        Day of the month for monthly IMSI updates
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day_of_month", value)


if not MYPY:
    class ExternalDynamicListTypeImsiRecurringWeeklyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Weekly Time specification hh (e.g. 20) for IMSI
        """
        day_of_week: pulumi.Input[_builtins.str]
        """
        Day of week
        """
elif False:
    ExternalDynamicListTypeImsiRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeImsiRecurringWeeklyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_week: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Weekly Time specification hh (e.g. 20) for IMSI
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Weekly Time specification hh (e.g. 20) for IMSI
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class ExternalDynamicListTypeIpArgsDict(TypedDict):
        recurring: pulumi.Input['ExternalDynamicListTypeIpRecurringArgsDict']
        """
        Update Schedule for Custom IP type
        """
        url: pulumi.Input[_builtins.str]
        """
        External URL for Custom IP type
        """
        auth: NotRequired[pulumi.Input['ExternalDynamicListTypeIpAuthArgsDict']]
        """
        Authentication settings for Custom IP type
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile for authenticating client certificates
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP Exception List for Custom IP type
        """
elif False:
    ExternalDynamicListTypeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['ExternalDynamicListTypeIpRecurringArgs'],
                 url: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ExternalDynamicListTypeIpAuthArgs']] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeIpRecurringArgs'] recurring: Update Schedule for Custom IP type
        :param pulumi.Input[_builtins.str] url: External URL for Custom IP type
        :param pulumi.Input['ExternalDynamicListTypeIpAuthArgs'] auth: Authentication settings for Custom IP type
        :param pulumi.Input[_builtins.str] certificate_profile: Profile for authenticating client certificates
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: IP Exception List for Custom IP type
        """
        pulumi.set(__self__, "recurring", recurring)
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['ExternalDynamicListTypeIpRecurringArgs']:
        """
        Update Schedule for Custom IP type
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['ExternalDynamicListTypeIpRecurringArgs']):
        pulumi.set(self, "recurring", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        External URL for Custom IP type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpAuthArgs']]:
        """
        Authentication settings for Custom IP type
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile for authenticating client certificates
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP Exception List for Custom IP type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)


if not MYPY:
    class ExternalDynamicListTypeIpAuthArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for Custom IP authentication
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for Custom IP authentication
        """
elif False:
    ExternalDynamicListTypeIpAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for Custom IP authentication
        :param pulumi.Input[_builtins.str] username: Username for Custom IP authentication
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for Custom IP authentication
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for Custom IP authentication
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ExternalDynamicListTypeIpRecurringArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input['ExternalDynamicListTypeIpRecurringDailyArgsDict']]
        """
        Daily settings for IP recurring
        """
        five_minute: NotRequired[pulumi.Input['ExternalDynamicListTypeIpRecurringFiveMinuteArgsDict']]
        """
        Five minute settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        hourly: NotRequired[pulumi.Input['ExternalDynamicListTypeIpRecurringHourlyArgsDict']]
        """
        Hourly settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        monthly: NotRequired[pulumi.Input['ExternalDynamicListTypeIpRecurringMonthlyArgsDict']]
        """
        Monthly settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        weekly: NotRequired[pulumi.Input['ExternalDynamicListTypeIpRecurringWeeklyArgsDict']]
        """
        Weekly settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
elif False:
    ExternalDynamicListTypeIpRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpRecurringArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringDailyArgs']] = None,
                 five_minute: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringFiveMinuteArgs']] = None,
                 hourly: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringHourlyArgs']] = None,
                 monthly: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringMonthlyArgs']] = None,
                 weekly: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeIpRecurringDailyArgs'] daily: Daily settings for IP recurring
        :param pulumi.Input['ExternalDynamicListTypeIpRecurringFiveMinuteArgs'] five_minute: Five minute settings for IP recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeIpRecurringHourlyArgs'] hourly: Hourly settings for IP recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeIpRecurringMonthlyArgs'] monthly: Monthly settings for IP recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeIpRecurringWeeklyArgs'] weekly: Weekly settings for IP recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if five_minute is not None:
            pulumi.set(__self__, "five_minute", five_minute)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringDailyArgs']]:
        """
        Daily settings for IP recurring
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="fiveMinute")
    def five_minute(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringFiveMinuteArgs']]:
        """
        Five minute settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "five_minute")

    @five_minute.setter
    def five_minute(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringFiveMinuteArgs']]):
        pulumi.set(self, "five_minute", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringHourlyArgs']]:
        """
        Hourly settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringMonthlyArgs']]:
        """
        Monthly settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringMonthlyArgs']]):
        pulumi.set(self, "monthly", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringWeeklyArgs']]:
        """
        Weekly settings for IP recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeIpRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class ExternalDynamicListTypeIpRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Daily Time specification hh (e.g. 20) for IP
        """
elif False:
    ExternalDynamicListTypeIpRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Daily Time specification hh (e.g. 20) for IP
        """
        pulumi.set(__self__, "at", at)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Daily Time specification hh (e.g. 20) for IP
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)


if not MYPY:
    class ExternalDynamicListTypeIpRecurringFiveMinuteArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeIpRecurringFiveMinuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpRecurringFiveMinuteArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeIpRecurringHourlyArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeIpRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpRecurringHourlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeIpRecurringMonthlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Monthly Time specification hh (e.g. 20) for IP
        """
        day_of_month: pulumi.Input[_builtins.int]
        """
        Day setting for monthly IP updates
        """
elif False:
    ExternalDynamicListTypeIpRecurringMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpRecurringMonthlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_month: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] at: Monthly Time specification hh (e.g. 20) for IP
        :param pulumi.Input[_builtins.int] day_of_month: Day setting for monthly IP updates
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_month", day_of_month)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Monthly Time specification hh (e.g. 20) for IP
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[_builtins.int]:
        """
        Day setting for monthly IP updates
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day_of_month", value)


if not MYPY:
    class ExternalDynamicListTypeIpRecurringWeeklyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Weekly Time specification hh (e.g. 20) for IP
        """
        day_of_week: pulumi.Input[_builtins.str]
        """
        Day of week
        """
elif False:
    ExternalDynamicListTypeIpRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeIpRecurringWeeklyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_week: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Weekly Time specification hh (e.g. 20) for IP
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Weekly Time specification hh (e.g. 20) for IP
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class ExternalDynamicListTypePredefinedIpArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        URL source for Predefined IP type
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP Exception List for Predefined IP type
        """
elif False:
    ExternalDynamicListTypePredefinedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypePredefinedIpArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: URL source for Predefined IP type
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: IP Exception List for Predefined IP type
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        URL source for Predefined IP type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP Exception List for Predefined IP type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)


if not MYPY:
    class ExternalDynamicListTypePredefinedUrlArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        URL source for Predefined URL type
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        URL Exception List for Predefined URL type
        """
elif False:
    ExternalDynamicListTypePredefinedUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypePredefinedUrlArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: URL source for Predefined URL type
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: URL Exception List for Predefined URL type
        """
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        URL source for Predefined URL type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        URL Exception List for Predefined URL type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)


if not MYPY:
    class ExternalDynamicListTypeUrlArgsDict(TypedDict):
        recurring: pulumi.Input['ExternalDynamicListTypeUrlRecurringArgsDict']
        """
        Update Schedule for Custom URL type
        """
        url: pulumi.Input[_builtins.str]
        """
        External URL for Custom URL type
        """
        auth: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlAuthArgsDict']]
        """
        Authentication settings for Custom URL type
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile for authenticating client certificates
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        exception_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        URL Exception List for Custom URL type
        """
elif False:
    ExternalDynamicListTypeUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['ExternalDynamicListTypeUrlRecurringArgs'],
                 url: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['ExternalDynamicListTypeUrlAuthArgs']] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeUrlRecurringArgs'] recurring: Update Schedule for Custom URL type
        :param pulumi.Input[_builtins.str] url: External URL for Custom URL type
        :param pulumi.Input['ExternalDynamicListTypeUrlAuthArgs'] auth: Authentication settings for Custom URL type
        :param pulumi.Input[_builtins.str] certificate_profile: Profile for authenticating client certificates
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exception_lists: URL Exception List for Custom URL type
        """
        pulumi.set(__self__, "recurring", recurring)
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exception_lists is not None:
            pulumi.set(__self__, "exception_lists", exception_lists)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['ExternalDynamicListTypeUrlRecurringArgs']:
        """
        Update Schedule for Custom URL type
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['ExternalDynamicListTypeUrlRecurringArgs']):
        pulumi.set(self, "recurring", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        External URL for Custom URL type
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlAuthArgs']]:
        """
        Authentication settings for Custom URL type
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile for authenticating client certificates
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="exceptionLists")
    def exception_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        URL Exception List for Custom URL type
        """
        return pulumi.get(self, "exception_lists")

    @exception_lists.setter
    def exception_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exception_lists", value)


if not MYPY:
    class ExternalDynamicListTypeUrlAuthArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for Custom URL authentication
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for Custom URL authentication
        """
elif False:
    ExternalDynamicListTypeUrlAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for Custom URL authentication
        :param pulumi.Input[_builtins.str] username: Username for Custom URL authentication
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for Custom URL authentication
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for Custom URL authentication
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ExternalDynamicListTypeUrlRecurringArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlRecurringDailyArgsDict']]
        """
        Daily settings for URL recurring
        """
        five_minute: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlRecurringFiveMinuteArgsDict']]
        """
        Five minute settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        hourly: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlRecurringHourlyArgsDict']]
        """
        Hourly settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        monthly: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlRecurringMonthlyArgsDict']]
        """
        Monthly settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        weekly: NotRequired[pulumi.Input['ExternalDynamicListTypeUrlRecurringWeeklyArgsDict']]
        """
        Weekly settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
elif False:
    ExternalDynamicListTypeUrlRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlRecurringArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringDailyArgs']] = None,
                 five_minute: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringFiveMinuteArgs']] = None,
                 hourly: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringHourlyArgs']] = None,
                 monthly: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringMonthlyArgs']] = None,
                 weekly: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input['ExternalDynamicListTypeUrlRecurringDailyArgs'] daily: Daily settings for URL recurring
        :param pulumi.Input['ExternalDynamicListTypeUrlRecurringFiveMinuteArgs'] five_minute: Five minute settings for URL recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeUrlRecurringHourlyArgs'] hourly: Hourly settings for URL recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeUrlRecurringMonthlyArgs'] monthly: Monthly settings for URL recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        :param pulumi.Input['ExternalDynamicListTypeUrlRecurringWeeklyArgs'] weekly: Weekly settings for URL recurring
               
               >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if five_minute is not None:
            pulumi.set(__self__, "five_minute", five_minute)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringDailyArgs']]:
        """
        Daily settings for URL recurring
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="fiveMinute")
    def five_minute(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringFiveMinuteArgs']]:
        """
        Five minute settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "five_minute")

    @five_minute.setter
    def five_minute(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringFiveMinuteArgs']]):
        pulumi.set(self, "five_minute", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringHourlyArgs']]:
        """
        Hourly settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringMonthlyArgs']]:
        """
        Monthly settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringMonthlyArgs']]):
        pulumi.set(self, "monthly", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringWeeklyArgs']]:
        """
        Weekly settings for URL recurring

        >  **Note:** You must specify exactly one of `daily`, `five_minute`, `hourly`, `monthly`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['ExternalDynamicListTypeUrlRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class ExternalDynamicListTypeUrlRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Daily Time specification hh (e.g. 20) for URL
        """
elif False:
    ExternalDynamicListTypeUrlRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Daily Time specification hh (e.g. 20) for URL
        """
        pulumi.set(__self__, "at", at)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Daily Time specification hh (e.g. 20) for URL
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)


if not MYPY:
    class ExternalDynamicListTypeUrlRecurringFiveMinuteArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeUrlRecurringFiveMinuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlRecurringFiveMinuteArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeUrlRecurringHourlyArgsDict(TypedDict):
        pass
elif False:
    ExternalDynamicListTypeUrlRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlRecurringHourlyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ExternalDynamicListTypeUrlRecurringMonthlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Monthly Time specification hh (e.g. 20) for URL
        """
        day_of_month: pulumi.Input[_builtins.int]
        """
        Day setting for monthly URL updates
        """
elif False:
    ExternalDynamicListTypeUrlRecurringMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlRecurringMonthlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_month: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] at: Monthly Time specification hh (e.g. 20) for URL
        :param pulumi.Input[_builtins.int] day_of_month: Day setting for monthly URL updates
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_month", day_of_month)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Monthly Time specification hh (e.g. 20) for URL
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[_builtins.int]:
        """
        Day setting for monthly URL updates
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day_of_month", value)


if not MYPY:
    class ExternalDynamicListTypeUrlRecurringWeeklyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        Weekly Time specification hh (e.g. 20) for URL
        """
        day_of_week: pulumi.Input[_builtins.str]
        """
        Day of week
        """
elif False:
    ExternalDynamicListTypeUrlRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDynamicListTypeUrlRecurringWeeklyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_week: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] at: Weekly Time specification hh (e.g. 20) for URL
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        Weekly Time specification hh (e.g. 20) for URL
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class FileBlockingProfileRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to take when the rule match criteria is met
        """
        applications: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The application transferring the files (App-ID naming)
        """
        direction: pulumi.Input[_builtins.str]
        """
        The direction of the file transfer
        """
        file_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The file type
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the file blocking rule
        """
elif False:
    FileBlockingProfileRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileBlockingProfileRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 applications: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 direction: pulumi.Input[_builtins.str],
                 file_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: The action to take when the rule match criteria is met
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] applications: The application transferring the files (App-ID naming)
        :param pulumi.Input[_builtins.str] direction: The direction of the file transfer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] file_types: The file type
        :param pulumi.Input[_builtins.str] name: The name of the file blocking rule
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "file_types", file_types)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take when the rule match criteria is met
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The application transferring the files (App-ID naming)
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "applications", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> pulumi.Input[_builtins.str]:
        """
        The direction of the file transfer
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The file type
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "file_types", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the file blocking rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GeneralSettingGeneralArgsDict(TypedDict):
        ack_login_banner: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Force admins to acknowledge login banner
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS domain
        """
        geo_location: NotRequired[pulumi.Input['GeneralSettingGeneralGeoLocationArgsDict']]
        """
        Geographic coordinates
        """
        locale: NotRequired[pulumi.Input[_builtins.str]]
        """
        Locale
        """
        login_banner: NotRequired[pulumi.Input[_builtins.str]]
        """
        Logon banner
        """
        setting: NotRequired[pulumi.Input['GeneralSettingGeneralSettingArgsDict']]
        """
        Setting
        """
        ssl_tls_service_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSL/TLS service profile
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timezone
        """
elif False:
    GeneralSettingGeneralArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneralSettingGeneralArgs:
    def __init__(__self__, *,
                 ack_login_banner: Optional[pulumi.Input[_builtins.bool]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 geo_location: Optional[pulumi.Input['GeneralSettingGeneralGeoLocationArgs']] = None,
                 locale: Optional[pulumi.Input[_builtins.str]] = None,
                 login_banner: Optional[pulumi.Input[_builtins.str]] = None,
                 setting: Optional[pulumi.Input['GeneralSettingGeneralSettingArgs']] = None,
                 ssl_tls_service_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] ack_login_banner: Force admins to acknowledge login banner
        :param pulumi.Input[_builtins.str] domain: DNS domain
        :param pulumi.Input['GeneralSettingGeneralGeoLocationArgs'] geo_location: Geographic coordinates
        :param pulumi.Input[_builtins.str] locale: Locale
        :param pulumi.Input[_builtins.str] login_banner: Logon banner
        :param pulumi.Input['GeneralSettingGeneralSettingArgs'] setting: Setting
        :param pulumi.Input[_builtins.str] ssl_tls_service_profile: SSL/TLS service profile
        :param pulumi.Input[_builtins.str] timezone: Timezone
        """
        if ack_login_banner is not None:
            pulumi.set(__self__, "ack_login_banner", ack_login_banner)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if geo_location is not None:
            pulumi.set(__self__, "geo_location", geo_location)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if login_banner is not None:
            pulumi.set(__self__, "login_banner", login_banner)
        if setting is not None:
            pulumi.set(__self__, "setting", setting)
        if ssl_tls_service_profile is not None:
            pulumi.set(__self__, "ssl_tls_service_profile", ssl_tls_service_profile)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="ackLoginBanner")
    def ack_login_banner(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Force admins to acknowledge login banner
        """
        return pulumi.get(self, "ack_login_banner")

    @ack_login_banner.setter
    def ack_login_banner(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ack_login_banner", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS domain
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional[pulumi.Input['GeneralSettingGeneralGeoLocationArgs']]:
        """
        Geographic coordinates
        """
        return pulumi.get(self, "geo_location")

    @geo_location.setter
    def geo_location(self, value: Optional[pulumi.Input['GeneralSettingGeneralGeoLocationArgs']]):
        pulumi.set(self, "geo_location", value)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Locale
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locale", value)

    @_builtins.property
    @pulumi.getter(name="loginBanner")
    def login_banner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Logon banner
        """
        return pulumi.get(self, "login_banner")

    @login_banner.setter
    def login_banner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_banner", value)

    @_builtins.property
    @pulumi.getter
    def setting(self) -> Optional[pulumi.Input['GeneralSettingGeneralSettingArgs']]:
        """
        Setting
        """
        return pulumi.get(self, "setting")

    @setting.setter
    def setting(self, value: Optional[pulumi.Input['GeneralSettingGeneralSettingArgs']]):
        pulumi.set(self, "setting", value)

    @_builtins.property
    @pulumi.getter(name="sslTlsServiceProfile")
    def ssl_tls_service_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSL/TLS service profile
        """
        return pulumi.get(self, "ssl_tls_service_profile")

    @ssl_tls_service_profile.setter
    def ssl_tls_service_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_tls_service_profile", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timezone
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class GeneralSettingGeneralGeoLocationArgsDict(TypedDict):
        latitude: pulumi.Input[_builtins.str]
        """
        Latitude
        """
        longitude: pulumi.Input[_builtins.str]
        """
        Longitude
        """
elif False:
    GeneralSettingGeneralGeoLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneralSettingGeneralGeoLocationArgs:
    def __init__(__self__, *,
                 latitude: pulumi.Input[_builtins.str],
                 longitude: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] latitude: Latitude
        :param pulumi.Input[_builtins.str] longitude: Longitude
        """
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[_builtins.str]:
        """
        Latitude
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[_builtins.str]:
        """
        Longitude
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class GeneralSettingGeneralSettingArgsDict(TypedDict):
        auto_mac_detect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use hypervisor assigned MAC addresses
        """
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Fail open
        """
        management: NotRequired[pulumi.Input['GeneralSettingGeneralSettingManagementArgsDict']]
        """
        Management
        """
        tunnel_acceleration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tunnel acceleration
        """
elif False:
    GeneralSettingGeneralSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneralSettingGeneralSettingArgs:
    def __init__(__self__, *,
                 auto_mac_detect: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 management: Optional[pulumi.Input['GeneralSettingGeneralSettingManagementArgs']] = None,
                 tunnel_acceleration: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_mac_detect: Use hypervisor assigned MAC addresses
        :param pulumi.Input[_builtins.bool] fail_open: Fail open
        :param pulumi.Input['GeneralSettingGeneralSettingManagementArgs'] management: Management
        :param pulumi.Input[_builtins.bool] tunnel_acceleration: Tunnel acceleration
        """
        if auto_mac_detect is not None:
            pulumi.set(__self__, "auto_mac_detect", auto_mac_detect)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if tunnel_acceleration is not None:
            pulumi.set(__self__, "tunnel_acceleration", tunnel_acceleration)

    @_builtins.property
    @pulumi.getter(name="autoMacDetect")
    def auto_mac_detect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use hypervisor assigned MAC addresses
        """
        return pulumi.get(self, "auto_mac_detect")

    @auto_mac_detect.setter
    def auto_mac_detect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_mac_detect", value)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Fail open
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter
    def management(self) -> Optional[pulumi.Input['GeneralSettingGeneralSettingManagementArgs']]:
        """
        Management
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: Optional[pulumi.Input['GeneralSettingGeneralSettingManagementArgs']]):
        pulumi.set(self, "management", value)

    @_builtins.property
    @pulumi.getter(name="tunnelAcceleration")
    def tunnel_acceleration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tunnel acceleration
        """
        return pulumi.get(self, "tunnel_acceleration")

    @tunnel_acceleration.setter
    def tunnel_acceleration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tunnel_acceleration", value)


if not MYPY:
    class GeneralSettingGeneralSettingManagementArgsDict(TypedDict):
        auto_acquire_commit_lock: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically acquire commit lock
        """
        enable_certificate_expiration_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Certificate expiration check
        """
elif False:
    GeneralSettingGeneralSettingManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneralSettingGeneralSettingManagementArgs:
    def __init__(__self__, *,
                 auto_acquire_commit_lock: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_certificate_expiration_check: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_acquire_commit_lock: Automatically acquire commit lock
        :param pulumi.Input[_builtins.bool] enable_certificate_expiration_check: Certificate expiration check
        """
        if auto_acquire_commit_lock is not None:
            pulumi.set(__self__, "auto_acquire_commit_lock", auto_acquire_commit_lock)
        if enable_certificate_expiration_check is not None:
            pulumi.set(__self__, "enable_certificate_expiration_check", enable_certificate_expiration_check)

    @_builtins.property
    @pulumi.getter(name="autoAcquireCommitLock")
    def auto_acquire_commit_lock(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically acquire commit lock
        """
        return pulumi.get(self, "auto_acquire_commit_lock")

    @auto_acquire_commit_lock.setter
    def auto_acquire_commit_lock(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_acquire_commit_lock", value)

    @_builtins.property
    @pulumi.getter(name="enableCertificateExpirationCheck")
    def enable_certificate_expiration_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Certificate expiration check
        """
        return pulumi.get(self, "enable_certificate_expiration_check")

    @enable_certificate_expiration_check.setter
    def enable_certificate_expiration_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_certificate_expiration_check", value)


if not MYPY:
    class HipObjectAntiMalwareArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaArgsDict']]
        """
        Criteria
        """
        exclude_vendor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exclude vendor
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectAntiMalwareVendorArgsDict']]]]
        """
        Vendor name
        """
elif False:
    HipObjectAntiMalwareArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaArgs']] = None,
                 exclude_vendor: Optional[pulumi.Input[_builtins.bool]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectAntiMalwareVendorArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectAntiMalwareCriteriaArgs'] criteria: Criteria
        :param pulumi.Input[_builtins.bool] exclude_vendor: Exclude vendor
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectAntiMalwareVendorArgs']]] vendors: Vendor name
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if exclude_vendor is not None:
            pulumi.set(__self__, "exclude_vendor", exclude_vendor)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter(name="excludeVendor")
    def exclude_vendor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exclude vendor
        """
        return pulumi.get(self, "exclude_vendor")

    @exclude_vendor.setter
    def exclude_vendor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_vendor", value)

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectAntiMalwareVendorArgs']]]]:
        """
        Vendor name
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectAntiMalwareVendorArgs']]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaArgsDict(TypedDict):
        is_installed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is Installed
        """
        last_scan_time: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeArgsDict']]
        """
        Last scan time
        """
        product_version: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionArgsDict']]
        """
        Product version
        """
        real_time_protection: NotRequired[pulumi.Input[_builtins.str]]
        """
        real time protection
        """
        virdef_version: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionArgsDict']]
        """
        Virdef version
        """
elif False:
    HipObjectAntiMalwareCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaArgs:
    def __init__(__self__, *,
                 is_installed: Optional[pulumi.Input[_builtins.bool]] = None,
                 last_scan_time: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeArgs']] = None,
                 product_version: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionArgs']] = None,
                 real_time_protection: Optional[pulumi.Input[_builtins.str]] = None,
                 virdef_version: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] is_installed: Is Installed
        :param pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeArgs'] last_scan_time: Last scan time
        :param pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionArgs'] product_version: Product version
        :param pulumi.Input[_builtins.str] real_time_protection: real time protection
        :param pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionArgs'] virdef_version: Virdef version
        """
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)
        if last_scan_time is not None:
            pulumi.set(__self__, "last_scan_time", last_scan_time)
        if product_version is not None:
            pulumi.set(__self__, "product_version", product_version)
        if real_time_protection is not None:
            pulumi.set(__self__, "real_time_protection", real_time_protection)
        if virdef_version is not None:
            pulumi.set(__self__, "virdef_version", virdef_version)

    @_builtins.property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is Installed
        """
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_installed", value)

    @_builtins.property
    @pulumi.getter(name="lastScanTime")
    def last_scan_time(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeArgs']]:
        """
        Last scan time
        """
        return pulumi.get(self, "last_scan_time")

    @last_scan_time.setter
    def last_scan_time(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeArgs']]):
        pulumi.set(self, "last_scan_time", value)

    @_builtins.property
    @pulumi.getter(name="productVersion")
    def product_version(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionArgs']]:
        """
        Product version
        """
        return pulumi.get(self, "product_version")

    @product_version.setter
    def product_version(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionArgs']]):
        pulumi.set(self, "product_version", value)

    @_builtins.property
    @pulumi.getter(name="realTimeProtection")
    def real_time_protection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        real time protection
        """
        return pulumi.get(self, "real_time_protection")

    @real_time_protection.setter
    def real_time_protection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "real_time_protection", value)

    @_builtins.property
    @pulumi.getter(name="virdefVersion")
    def virdef_version(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionArgs']]:
        """
        Virdef version
        """
        return pulumi.get(self, "virdef_version")

    @virdef_version.setter
    def virdef_version(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionArgs']]):
        pulumi.set(self, "virdef_version", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaLastScanTimeArgsDict(TypedDict):
        not_available: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgsDict']]
        """
        Not available
        """
        not_within: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgsDict']]
        """
        Not within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        within: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeWithinArgsDict']]
        """
        Within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
elif False:
    HipObjectAntiMalwareCriteriaLastScanTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaLastScanTimeArgs:
    def __init__(__self__, *,
                 not_available: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgs']] = None,
                 not_within: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgs']] = None,
                 within: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeWithinArgs']] = None):
        """
        :param pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgs'] not_available: Not available
        :param pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgs'] not_within: Not within
               
               >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        :param pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeWithinArgs'] within: Within
               
               >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        if not_available is not None:
            pulumi.set(__self__, "not_available", not_available)
        if not_within is not None:
            pulumi.set(__self__, "not_within", not_within)
        if within is not None:
            pulumi.set(__self__, "within", within)

    @_builtins.property
    @pulumi.getter(name="notAvailable")
    def not_available(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgs']]:
        """
        Not available
        """
        return pulumi.get(self, "not_available")

    @not_available.setter
    def not_available(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgs']]):
        pulumi.set(self, "not_available", value)

    @_builtins.property
    @pulumi.getter(name="notWithin")
    def not_within(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgs']]:
        """
        Not within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        return pulumi.get(self, "not_within")

    @not_within.setter
    def not_within(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgs']]):
        pulumi.set(self, "not_within", value)

    @_builtins.property
    @pulumi.getter
    def within(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeWithinArgs']]:
        """
        Within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        return pulumi.get(self, "within")

    @within.setter
    def within(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaLastScanTimeWithinArgs']]):
        pulumi.set(self, "within", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgsDict(TypedDict):
        pass
elif False:
    HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaLastScanTimeNotAvailableArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in days
        """
        hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
elif False:
    HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaLastScanTimeNotWithinArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 hours: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        :param pulumi.Input[_builtins.int] hours: specify time in hours
               
               >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaLastScanTimeWithinArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in days
        """
        hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
elif False:
    HipObjectAntiMalwareCriteriaLastScanTimeWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaLastScanTimeWithinArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 hours: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        :param pulumi.Input[_builtins.int] hours: specify time in hours
               
               >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaProductVersionArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        greater_equal: NotRequired[pulumi.Input[_builtins.str]]
        """
        Greater equal

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        greater_than: NotRequired[pulumi.Input[_builtins.str]]
        """
        Greater than

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        less_equal: NotRequired[pulumi.Input[_builtins.str]]
        """
        Less equal

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        less_than: NotRequired[pulumi.Input[_builtins.str]]
        """
        Less than

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        not_within: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionNotWithinArgsDict']]
        """
        Not within

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        within: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionWithinArgsDict']]
        """
        Within

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
elif False:
    HipObjectAntiMalwareCriteriaProductVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaProductVersionArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 greater_equal: Optional[pulumi.Input[_builtins.str]] = None,
                 greater_than: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None,
                 less_equal: Optional[pulumi.Input[_builtins.str]] = None,
                 less_than: Optional[pulumi.Input[_builtins.str]] = None,
                 not_within: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionNotWithinArgs']] = None,
                 within: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionWithinArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] greater_equal: Greater equal
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input[_builtins.str] greater_than: Greater than
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input[_builtins.str] less_equal: Less equal
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input[_builtins.str] less_than: Less than
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionNotWithinArgs'] not_within: Not within
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        :param pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionWithinArgs'] within: Within
               
               >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if greater_equal is not None:
            pulumi.set(__self__, "greater_equal", greater_equal)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)
        if less_equal is not None:
            pulumi.set(__self__, "less_equal", less_equal)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if not_within is not None:
            pulumi.set(__self__, "not_within", not_within)
        if within is not None:
            pulumi.set(__self__, "within", within)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="greaterEqual")
    def greater_equal(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Greater equal

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "greater_equal")

    @greater_equal.setter
    def greater_equal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "greater_equal", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Greater than

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)

    @_builtins.property
    @pulumi.getter(name="lessEqual")
    def less_equal(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Less equal

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "less_equal")

    @less_equal.setter
    def less_equal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "less_equal", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Less than

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter(name="notWithin")
    def not_within(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionNotWithinArgs']]:
        """
        Not within

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "not_within")

    @not_within.setter
    def not_within(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionNotWithinArgs']]):
        pulumi.set(self, "not_within", value)

    @_builtins.property
    @pulumi.getter
    def within(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionWithinArgs']]:
        """
        Within

        >  **Note:** You must specify exactly one of `contains`, `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, `less_than`, `not_within`, and `within`.
        """
        return pulumi.get(self, "within")

    @within.setter
    def within(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaProductVersionWithinArgs']]):
        pulumi.set(self, "within", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaProductVersionNotWithinArgsDict(TypedDict):
        versions: pulumi.Input[_builtins.int]
        """
        versions range
        """
elif False:
    HipObjectAntiMalwareCriteriaProductVersionNotWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaProductVersionNotWithinArgs:
    def __init__(__self__, *,
                 versions: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] versions: versions range
        """
        pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> pulumi.Input[_builtins.int]:
        """
        versions range
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaProductVersionWithinArgsDict(TypedDict):
        versions: pulumi.Input[_builtins.int]
        """
        versions range
        """
elif False:
    HipObjectAntiMalwareCriteriaProductVersionWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaProductVersionWithinArgs:
    def __init__(__self__, *,
                 versions: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] versions: versions range
        """
        pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> pulumi.Input[_builtins.int]:
        """
        versions range
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaVirdefVersionArgsDict(TypedDict):
        not_within: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgsDict']]
        """
        Not within
        """
        within: NotRequired[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionWithinArgsDict']]
        """
        Within

        >  **Note:** You must specify exactly one of `not_within` and `within`.
        """
elif False:
    HipObjectAntiMalwareCriteriaVirdefVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaVirdefVersionArgs:
    def __init__(__self__, *,
                 not_within: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgs']] = None,
                 within: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionWithinArgs']] = None):
        """
        :param pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgs'] not_within: Not within
        :param pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionWithinArgs'] within: Within
               
               >  **Note:** You must specify exactly one of `not_within` and `within`.
        """
        if not_within is not None:
            pulumi.set(__self__, "not_within", not_within)
        if within is not None:
            pulumi.set(__self__, "within", within)

    @_builtins.property
    @pulumi.getter(name="notWithin")
    def not_within(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgs']]:
        """
        Not within
        """
        return pulumi.get(self, "not_within")

    @not_within.setter
    def not_within(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgs']]):
        pulumi.set(self, "not_within", value)

    @_builtins.property
    @pulumi.getter
    def within(self) -> Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionWithinArgs']]:
        """
        Within

        >  **Note:** You must specify exactly one of `not_within` and `within`.
        """
        return pulumi.get(self, "within")

    @within.setter
    def within(self, value: Optional[pulumi.Input['HipObjectAntiMalwareCriteriaVirdefVersionWithinArgs']]):
        pulumi.set(self, "within", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in days
        """
        versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify versions range

        >  **Note:** You must specify exactly one of `days` and `versions`.
        """
elif False:
    HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaVirdefVersionNotWithinArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 versions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        :param pulumi.Input[_builtins.int] versions: specify versions range
               
               >  **Note:** You must specify exactly one of `days` and `versions`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify versions range

        >  **Note:** You must specify exactly one of `days` and `versions`.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class HipObjectAntiMalwareCriteriaVirdefVersionWithinArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in days
        """
        versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify versions range

        >  **Note:** You must specify exactly one of `days` and `versions`.
        """
elif False:
    HipObjectAntiMalwareCriteriaVirdefVersionWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareCriteriaVirdefVersionWithinArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 versions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        :param pulumi.Input[_builtins.int] versions: specify versions range
               
               >  **Note:** You must specify exactly one of `days` and `versions`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify versions range

        >  **Note:** You must specify exactly one of `days` and `versions`.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class HipObjectAntiMalwareVendorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Product
        """
elif False:
    HipObjectAntiMalwareVendorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectAntiMalwareVendorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Product
        """
        pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Product
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class HipObjectCertificateArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectCertificateCriteriaArgsDict']]
        """
        Criteria
        """
elif False:
    HipObjectCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCertificateArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectCertificateCriteriaArgs']] = None):
        """
        :param pulumi.Input['HipObjectCertificateCriteriaArgs'] criteria: Criteria
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectCertificateCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectCertificateCriteriaArgs']]):
        pulumi.set(self, "criteria", value)


if not MYPY:
    class HipObjectCertificateCriteriaArgsDict(TypedDict):
        certificate_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectCertificateCriteriaCertificateAttributeArgsDict']]]]
        """
        Certificate attributes
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile for authenticating client certificates
        """
elif False:
    HipObjectCertificateCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCertificateCriteriaArgs:
    def __init__(__self__, *,
                 certificate_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCertificateCriteriaCertificateAttributeArgs']]]] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectCertificateCriteriaCertificateAttributeArgs']]] certificate_attributes: Certificate attributes
        :param pulumi.Input[_builtins.str] certificate_profile: Profile for authenticating client certificates
        """
        if certificate_attributes is not None:
            pulumi.set(__self__, "certificate_attributes", certificate_attributes)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)

    @_builtins.property
    @pulumi.getter(name="certificateAttributes")
    def certificate_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCertificateCriteriaCertificateAttributeArgs']]]]:
        """
        Certificate attributes
        """
        return pulumi.get(self, "certificate_attributes")

    @certificate_attributes.setter
    def certificate_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCertificateCriteriaCertificateAttributeArgs']]]]):
        pulumi.set(self, "certificate_attributes", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile for authenticating client certificates
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)


if not MYPY:
    class HipObjectCertificateCriteriaCertificateAttributeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Attribute Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key value
        """
elif False:
    HipObjectCertificateCriteriaCertificateAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCertificateCriteriaCertificateAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Attribute Name
        :param pulumi.Input[_builtins.str] value: Key value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Attribute Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HipObjectCustomChecksArgsDict(TypedDict):
        criteria: pulumi.Input['HipObjectCustomChecksCriteriaArgsDict']
        """
        Criteria
        """
elif False:
    HipObjectCustomChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input['HipObjectCustomChecksCriteriaArgs']):
        """
        :param pulumi.Input['HipObjectCustomChecksCriteriaArgs'] criteria: Criteria
        """
        pulumi.set(__self__, "criteria", criteria)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> pulumi.Input['HipObjectCustomChecksCriteriaArgs']:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input['HipObjectCustomChecksCriteriaArgs']):
        pulumi.set(self, "criteria", value)


if not MYPY:
    class HipObjectCustomChecksCriteriaArgsDict(TypedDict):
        plists: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistArgsDict']]]]
        """
        Plist
        """
        process_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaProcessListArgsDict']]]]
        """
        Process list
        """
        registry_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyArgsDict']]]]
        """
        Registry key
        """
elif False:
    HipObjectCustomChecksCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksCriteriaArgs:
    def __init__(__self__, *,
                 plists: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistArgs']]]] = None,
                 process_lists: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaProcessListArgs']]]] = None,
                 registry_keys: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistArgs']]] plists: Plist
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaProcessListArgs']]] process_lists: Process list
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyArgs']]] registry_keys: Registry key
        """
        if plists is not None:
            pulumi.set(__self__, "plists", plists)
        if process_lists is not None:
            pulumi.set(__self__, "process_lists", process_lists)
        if registry_keys is not None:
            pulumi.set(__self__, "registry_keys", registry_keys)

    @_builtins.property
    @pulumi.getter
    def plists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistArgs']]]]:
        """
        Plist
        """
        return pulumi.get(self, "plists")

    @plists.setter
    def plists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistArgs']]]]):
        pulumi.set(self, "plists", value)

    @_builtins.property
    @pulumi.getter(name="processLists")
    def process_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaProcessListArgs']]]]:
        """
        Process list
        """
        return pulumi.get(self, "process_lists")

    @process_lists.setter
    def process_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaProcessListArgs']]]]):
        pulumi.set(self, "process_lists", value)

    @_builtins.property
    @pulumi.getter(name="registryKeys")
    def registry_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyArgs']]]]:
        """
        Registry key
        """
        return pulumi.get(self, "registry_keys")

    @registry_keys.setter
    def registry_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyArgs']]]]):
        pulumi.set(self, "registry_keys", value)


if not MYPY:
    class HipObjectCustomChecksCriteriaPlistArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Preference list
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistKeyArgsDict']]]]
        """
        Key
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Plist does not exist
        """
elif False:
    HipObjectCustomChecksCriteriaPlistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksCriteriaPlistArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistKeyArgs']]]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Preference list
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistKeyArgs']]] keys: Key
        :param pulumi.Input[_builtins.bool] negate: Plist does not exist
        """
        pulumi.set(__self__, "name", name)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Preference list
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistKeyArgs']]]]:
        """
        Key
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaPlistKeyArgs']]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Plist does not exist
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class HipObjectCustomChecksCriteriaPlistKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Key name
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Value does not exist or match specified value data
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key value
        """
elif False:
    HipObjectCustomChecksCriteriaPlistKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksCriteriaPlistKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key name
        :param pulumi.Input[_builtins.bool] negate: Value does not exist or match specified value data
        :param pulumi.Input[_builtins.str] value: Key value
        """
        pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Key name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Value does not exist or match specified value data
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HipObjectCustomChecksCriteriaProcessListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Process Name
        """
        running: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Running
        """
elif False:
    HipObjectCustomChecksCriteriaProcessListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksCriteriaProcessListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 running: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Process Name
        :param pulumi.Input[_builtins.bool] running: Running
        """
        pulumi.set(__self__, "name", name)
        if running is not None:
            pulumi.set(__self__, "running", running)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Process Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def running(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Running
        """
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "running", value)


if not MYPY:
    class HipObjectCustomChecksCriteriaRegistryKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Registry key
        """
        default_value_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Registry key default value data
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Key does not exist or match specified value data
        """
        registry_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgsDict']]]]
        """
        Registry value
        """
elif False:
    HipObjectCustomChecksCriteriaRegistryKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksCriteriaRegistryKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 default_value_data: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 registry_values: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Registry key
        :param pulumi.Input[_builtins.str] default_value_data: Registry key default value data
        :param pulumi.Input[_builtins.bool] negate: Key does not exist or match specified value data
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgs']]] registry_values: Registry value
        """
        pulumi.set(__self__, "name", name)
        if default_value_data is not None:
            pulumi.set(__self__, "default_value_data", default_value_data)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if registry_values is not None:
            pulumi.set(__self__, "registry_values", registry_values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Registry key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="defaultValueData")
    def default_value_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Registry key default value data
        """
        return pulumi.get(self, "default_value_data")

    @default_value_data.setter
    def default_value_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value_data", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Key does not exist or match specified value data
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="registryValues")
    def registry_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgs']]]]:
        """
        Registry value
        """
        return pulumi.get(self, "registry_values")

    @registry_values.setter
    def registry_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgs']]]]):
        pulumi.set(self, "registry_values", value)


if not MYPY:
    class HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Registry value name
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Value does not exist or match specified value data
        """
        value_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Registry value data
        """
elif False:
    HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectCustomChecksCriteriaRegistryKeyRegistryValueArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 value_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Registry value name
        :param pulumi.Input[_builtins.bool] negate: Value does not exist or match specified value data
        :param pulumi.Input[_builtins.str] value_data: Registry value data
        """
        pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_data is not None:
            pulumi.set(__self__, "value_data", value_data)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Registry value name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Value does not exist or match specified value data
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="valueData")
    def value_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Registry value data
        """
        return pulumi.get(self, "value_data")

    @value_data.setter
    def value_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_data", value)


if not MYPY:
    class HipObjectDataLossPreventionArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectDataLossPreventionCriteriaArgsDict']]
        """
        Criteria
        """
        exclude_vendor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exclude vendor
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectDataLossPreventionVendorArgsDict']]]]
        """
        Vendor name
        """
elif False:
    HipObjectDataLossPreventionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDataLossPreventionArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectDataLossPreventionCriteriaArgs']] = None,
                 exclude_vendor: Optional[pulumi.Input[_builtins.bool]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDataLossPreventionVendorArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectDataLossPreventionCriteriaArgs'] criteria: Criteria
        :param pulumi.Input[_builtins.bool] exclude_vendor: Exclude vendor
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectDataLossPreventionVendorArgs']]] vendors: Vendor name
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if exclude_vendor is not None:
            pulumi.set(__self__, "exclude_vendor", exclude_vendor)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectDataLossPreventionCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectDataLossPreventionCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter(name="excludeVendor")
    def exclude_vendor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exclude vendor
        """
        return pulumi.get(self, "exclude_vendor")

    @exclude_vendor.setter
    def exclude_vendor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_vendor", value)

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDataLossPreventionVendorArgs']]]]:
        """
        Vendor name
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDataLossPreventionVendorArgs']]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class HipObjectDataLossPreventionCriteriaArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        is enabled
        """
        is_installed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is Installed
        """
elif False:
    HipObjectDataLossPreventionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDataLossPreventionCriteriaArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.str]] = None,
                 is_installed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] is_enabled: is enabled
        :param pulumi.Input[_builtins.bool] is_installed: Is Installed
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        is enabled
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is Installed
        """
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_installed", value)


if not MYPY:
    class HipObjectDataLossPreventionVendorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Product name
        """
elif False:
    HipObjectDataLossPreventionVendorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDataLossPreventionVendorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Product name
        """
        pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Product name
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class HipObjectDiskBackupArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectDiskBackupCriteriaArgsDict']]
        """
        Criteria
        """
        exclude_vendor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exclude vendor
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskBackupVendorArgsDict']]]]
        """
        Vendor name
        """
elif False:
    HipObjectDiskBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectDiskBackupCriteriaArgs']] = None,
                 exclude_vendor: Optional[pulumi.Input[_builtins.bool]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskBackupVendorArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectDiskBackupCriteriaArgs'] criteria: Criteria
        :param pulumi.Input[_builtins.bool] exclude_vendor: Exclude vendor
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectDiskBackupVendorArgs']]] vendors: Vendor name
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if exclude_vendor is not None:
            pulumi.set(__self__, "exclude_vendor", exclude_vendor)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectDiskBackupCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectDiskBackupCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter(name="excludeVendor")
    def exclude_vendor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exclude vendor
        """
        return pulumi.get(self, "exclude_vendor")

    @exclude_vendor.setter
    def exclude_vendor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_vendor", value)

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskBackupVendorArgs']]]]:
        """
        Vendor name
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskBackupVendorArgs']]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class HipObjectDiskBackupCriteriaArgsDict(TypedDict):
        is_installed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is Installed
        """
        last_backup_time: NotRequired[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeArgsDict']]
        """
        Last backup time
        """
elif False:
    HipObjectDiskBackupCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupCriteriaArgs:
    def __init__(__self__, *,
                 is_installed: Optional[pulumi.Input[_builtins.bool]] = None,
                 last_backup_time: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] is_installed: Is Installed
        :param pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeArgs'] last_backup_time: Last backup time
        """
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)
        if last_backup_time is not None:
            pulumi.set(__self__, "last_backup_time", last_backup_time)

    @_builtins.property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is Installed
        """
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_installed", value)

    @_builtins.property
    @pulumi.getter(name="lastBackupTime")
    def last_backup_time(self) -> Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeArgs']]:
        """
        Last backup time
        """
        return pulumi.get(self, "last_backup_time")

    @last_backup_time.setter
    def last_backup_time(self, value: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeArgs']]):
        pulumi.set(self, "last_backup_time", value)


if not MYPY:
    class HipObjectDiskBackupCriteriaLastBackupTimeArgsDict(TypedDict):
        not_available: NotRequired[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgsDict']]
        """
        Not available
        """
        not_within: NotRequired[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgsDict']]
        """
        Not within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        within: NotRequired[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeWithinArgsDict']]
        """
        Within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
elif False:
    HipObjectDiskBackupCriteriaLastBackupTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupCriteriaLastBackupTimeArgs:
    def __init__(__self__, *,
                 not_available: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgs']] = None,
                 not_within: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgs']] = None,
                 within: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeWithinArgs']] = None):
        """
        :param pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgs'] not_available: Not available
        :param pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgs'] not_within: Not within
               
               >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        :param pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeWithinArgs'] within: Within
               
               >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        if not_available is not None:
            pulumi.set(__self__, "not_available", not_available)
        if not_within is not None:
            pulumi.set(__self__, "not_within", not_within)
        if within is not None:
            pulumi.set(__self__, "within", within)

    @_builtins.property
    @pulumi.getter(name="notAvailable")
    def not_available(self) -> Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgs']]:
        """
        Not available
        """
        return pulumi.get(self, "not_available")

    @not_available.setter
    def not_available(self, value: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgs']]):
        pulumi.set(self, "not_available", value)

    @_builtins.property
    @pulumi.getter(name="notWithin")
    def not_within(self) -> Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgs']]:
        """
        Not within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        return pulumi.get(self, "not_within")

    @not_within.setter
    def not_within(self, value: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgs']]):
        pulumi.set(self, "not_within", value)

    @_builtins.property
    @pulumi.getter
    def within(self) -> Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeWithinArgs']]:
        """
        Within

        >  **Note:** You must specify exactly one of `not_available`, `not_within`, and `within`.
        """
        return pulumi.get(self, "within")

    @within.setter
    def within(self, value: Optional[pulumi.Input['HipObjectDiskBackupCriteriaLastBackupTimeWithinArgs']]):
        pulumi.set(self, "within", value)


if not MYPY:
    class HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgsDict(TypedDict):
        pass
elif False:
    HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupCriteriaLastBackupTimeNotAvailableArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in days
        """
        hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
elif False:
    HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupCriteriaLastBackupTimeNotWithinArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 hours: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        :param pulumi.Input[_builtins.int] hours: specify time in hours
               
               >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)


if not MYPY:
    class HipObjectDiskBackupCriteriaLastBackupTimeWithinArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in days
        """
        hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
elif False:
    HipObjectDiskBackupCriteriaLastBackupTimeWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupCriteriaLastBackupTimeWithinArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 hours: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        :param pulumi.Input[_builtins.int] hours: specify time in hours
               
               >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify time in hours

        >  **Note:** You must specify exactly one of `days` and `hours`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)


if not MYPY:
    class HipObjectDiskBackupVendorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Product
        """
elif False:
    HipObjectDiskBackupVendorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskBackupVendorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Product
        """
        pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Product
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class HipObjectDiskEncryptionArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectDiskEncryptionCriteriaArgsDict']]
        """
        Encryption locations
        """
        exclude_vendor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exclude vendor
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionVendorArgsDict']]]]
        """
        Vendor name
        """
elif False:
    HipObjectDiskEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskEncryptionArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectDiskEncryptionCriteriaArgs']] = None,
                 exclude_vendor: Optional[pulumi.Input[_builtins.bool]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionVendorArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectDiskEncryptionCriteriaArgs'] criteria: Encryption locations
        :param pulumi.Input[_builtins.bool] exclude_vendor: Exclude vendor
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionVendorArgs']]] vendors: Vendor name
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if exclude_vendor is not None:
            pulumi.set(__self__, "exclude_vendor", exclude_vendor)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectDiskEncryptionCriteriaArgs']]:
        """
        Encryption locations
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectDiskEncryptionCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter(name="excludeVendor")
    def exclude_vendor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exclude vendor
        """
        return pulumi.get(self, "exclude_vendor")

    @exclude_vendor.setter
    def exclude_vendor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_vendor", value)

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionVendorArgs']]]]:
        """
        Vendor name
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionVendorArgs']]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class HipObjectDiskEncryptionCriteriaArgsDict(TypedDict):
        encrypted_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationArgsDict']]]]
        """
        Encrypted locations
        """
        is_installed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is Installed
        """
elif False:
    HipObjectDiskEncryptionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskEncryptionCriteriaArgs:
    def __init__(__self__, *,
                 encrypted_locations: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationArgs']]]] = None,
                 is_installed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationArgs']]] encrypted_locations: Encrypted locations
        :param pulumi.Input[_builtins.bool] is_installed: Is Installed
        """
        if encrypted_locations is not None:
            pulumi.set(__self__, "encrypted_locations", encrypted_locations)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)

    @_builtins.property
    @pulumi.getter(name="encryptedLocations")
    def encrypted_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationArgs']]]]:
        """
        Encrypted locations
        """
        return pulumi.get(self, "encrypted_locations")

    @encrypted_locations.setter
    def encrypted_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationArgs']]]]):
        pulumi.set(self, "encrypted_locations", value)

    @_builtins.property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is Installed
        """
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_installed", value)


if not MYPY:
    class HipObjectDiskEncryptionCriteriaEncryptedLocationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Encryption location
        """
        encryption_state: NotRequired[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgsDict']]
        """
        Encryption state
        """
elif False:
    HipObjectDiskEncryptionCriteriaEncryptedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskEncryptionCriteriaEncryptedLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 encryption_state: Optional[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Encryption location
        :param pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgs'] encryption_state: Encryption state
        """
        pulumi.set(__self__, "name", name)
        if encryption_state is not None:
            pulumi.set(__self__, "encryption_state", encryption_state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Encryption location
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="encryptionState")
    def encryption_state(self) -> Optional[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgs']]:
        """
        Encryption state
        """
        return pulumi.get(self, "encryption_state")

    @encryption_state.setter
    def encryption_state(self, value: Optional[pulumi.Input['HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgs']]):
        pulumi.set(self, "encryption_state", value)


if not MYPY:
    class HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgsDict(TypedDict):
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `is` and `is_not`.
        """
elif False:
    HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskEncryptionCriteriaEncryptedLocationEncryptionStateArgs:
    def __init__(__self__, *,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] is_: Is
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `is` and `is_not`.
        """
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `is` and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectDiskEncryptionVendorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Product
        """
elif False:
    HipObjectDiskEncryptionVendorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectDiskEncryptionVendorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Product
        """
        pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Product
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class HipObjectFirewallArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectFirewallCriteriaArgsDict']]
        """
        Criteria
        """
        exclude_vendor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exclude vendor
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectFirewallVendorArgsDict']]]]
        """
        Vendor name
        """
elif False:
    HipObjectFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectFirewallArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectFirewallCriteriaArgs']] = None,
                 exclude_vendor: Optional[pulumi.Input[_builtins.bool]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectFirewallVendorArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectFirewallCriteriaArgs'] criteria: Criteria
        :param pulumi.Input[_builtins.bool] exclude_vendor: Exclude vendor
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectFirewallVendorArgs']]] vendors: Vendor name
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if exclude_vendor is not None:
            pulumi.set(__self__, "exclude_vendor", exclude_vendor)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectFirewallCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectFirewallCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter(name="excludeVendor")
    def exclude_vendor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exclude vendor
        """
        return pulumi.get(self, "exclude_vendor")

    @exclude_vendor.setter
    def exclude_vendor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_vendor", value)

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectFirewallVendorArgs']]]]:
        """
        Vendor name
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectFirewallVendorArgs']]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class HipObjectFirewallCriteriaArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        is enabled
        """
        is_installed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is Installed
        """
elif False:
    HipObjectFirewallCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectFirewallCriteriaArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.str]] = None,
                 is_installed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] is_enabled: is enabled
        :param pulumi.Input[_builtins.bool] is_installed: Is Installed
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        is enabled
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is Installed
        """
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_installed", value)


if not MYPY:
    class HipObjectFirewallVendorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Product
        """
elif False:
    HipObjectFirewallVendorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectFirewallVendorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Product
        """
        pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Product
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class HipObjectHostInfoArgsDict(TypedDict):
        criteria: pulumi.Input['HipObjectHostInfoCriteriaArgsDict']
        """
        Criteria
        """
elif False:
    HipObjectHostInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input['HipObjectHostInfoCriteriaArgs']):
        """
        :param pulumi.Input['HipObjectHostInfoCriteriaArgs'] criteria: Criteria
        """
        pulumi.set(__self__, "criteria", criteria)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> pulumi.Input['HipObjectHostInfoCriteriaArgs']:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input['HipObjectHostInfoCriteriaArgs']):
        pulumi.set(self, "criteria", value)


if not MYPY:
    class HipObjectHostInfoCriteriaArgsDict(TypedDict):
        client_version: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaClientVersionArgsDict']]
        """
        Client version
        """
        domain: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaDomainArgsDict']]
        """
        Domain
        """
        host_id: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaHostIdArgsDict']]
        """
        Host id
        """
        host_name: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaHostNameArgsDict']]
        """
        Host name
        """
        managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If device is managed
        """
        os: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaOsArgsDict']]
        """
        Os
        """
        serial_number: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaSerialNumberArgsDict']]
        """
        Serial number
        """
elif False:
    HipObjectHostInfoCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaArgs:
    def __init__(__self__, *,
                 client_version: Optional[pulumi.Input['HipObjectHostInfoCriteriaClientVersionArgs']] = None,
                 domain: Optional[pulumi.Input['HipObjectHostInfoCriteriaDomainArgs']] = None,
                 host_id: Optional[pulumi.Input['HipObjectHostInfoCriteriaHostIdArgs']] = None,
                 host_name: Optional[pulumi.Input['HipObjectHostInfoCriteriaHostNameArgs']] = None,
                 managed: Optional[pulumi.Input[_builtins.bool]] = None,
                 os: Optional[pulumi.Input['HipObjectHostInfoCriteriaOsArgs']] = None,
                 serial_number: Optional[pulumi.Input['HipObjectHostInfoCriteriaSerialNumberArgs']] = None):
        """
        :param pulumi.Input['HipObjectHostInfoCriteriaClientVersionArgs'] client_version: Client version
        :param pulumi.Input['HipObjectHostInfoCriteriaDomainArgs'] domain: Domain
        :param pulumi.Input['HipObjectHostInfoCriteriaHostIdArgs'] host_id: Host id
        :param pulumi.Input['HipObjectHostInfoCriteriaHostNameArgs'] host_name: Host name
        :param pulumi.Input[_builtins.bool] managed: If device is managed
        :param pulumi.Input['HipObjectHostInfoCriteriaOsArgs'] os: Os
        :param pulumi.Input['HipObjectHostInfoCriteriaSerialNumberArgs'] serial_number: Serial number
        """
        if client_version is not None:
            pulumi.set(__self__, "client_version", client_version)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @_builtins.property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaClientVersionArgs']]:
        """
        Client version
        """
        return pulumi.get(self, "client_version")

    @client_version.setter
    def client_version(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaClientVersionArgs']]):
        pulumi.set(self, "client_version", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaDomainArgs']]:
        """
        Domain
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaDomainArgs']]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaHostIdArgs']]:
        """
        Host id
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaHostIdArgs']]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaHostNameArgs']]:
        """
        Host name
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaHostNameArgs']]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If device is managed
        """
        return pulumi.get(self, "managed")

    @managed.setter
    def managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "managed", value)

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaOsArgs']]:
        """
        Os
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaOsArgs']]):
        pulumi.set(self, "os", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaSerialNumberArgs']]:
        """
        Serial number
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaSerialNumberArgs']]):
        pulumi.set(self, "serial_number", value)


if not MYPY:
    class HipObjectHostInfoCriteriaClientVersionArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectHostInfoCriteriaClientVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaClientVersionArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectHostInfoCriteriaDomainArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectHostInfoCriteriaDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaDomainArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectHostInfoCriteriaHostIdArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectHostInfoCriteriaHostIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaHostIdArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectHostInfoCriteriaHostNameArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectHostInfoCriteriaHostNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaHostNameArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectHostInfoCriteriaOsArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input['HipObjectHostInfoCriteriaOsContainsArgsDict']]
        """
        Contains
        """
elif False:
    HipObjectHostInfoCriteriaOsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaOsArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input['HipObjectHostInfoCriteriaOsContainsArgs']] = None):
        """
        :param pulumi.Input['HipObjectHostInfoCriteriaOsContainsArgs'] contains: Contains
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input['HipObjectHostInfoCriteriaOsContainsArgs']]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input['HipObjectHostInfoCriteriaOsContainsArgs']]):
        pulumi.set(self, "contains", value)


if not MYPY:
    class HipObjectHostInfoCriteriaOsContainsArgsDict(TypedDict):
        apple: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apple
        """
        google: NotRequired[pulumi.Input[_builtins.str]]
        """
        Google
        """
        linux: NotRequired[pulumi.Input[_builtins.str]]
        """
        Linux
        """
        microsoft: NotRequired[pulumi.Input[_builtins.str]]
        """
        Microsoft
        """
        other: NotRequired[pulumi.Input[_builtins.str]]
        """
        Other
        """
elif False:
    HipObjectHostInfoCriteriaOsContainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaOsContainsArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input[_builtins.str]] = None,
                 google: Optional[pulumi.Input[_builtins.str]] = None,
                 linux: Optional[pulumi.Input[_builtins.str]] = None,
                 microsoft: Optional[pulumi.Input[_builtins.str]] = None,
                 other: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apple: Apple
        :param pulumi.Input[_builtins.str] google: Google
        :param pulumi.Input[_builtins.str] linux: Linux
        :param pulumi.Input[_builtins.str] microsoft: Microsoft
        :param pulumi.Input[_builtins.str] other: Other
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if linux is not None:
            pulumi.set(__self__, "linux", linux)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if other is not None:
            pulumi.set(__self__, "other", other)

    @_builtins.property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apple
        """
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apple", value)

    @_builtins.property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Google
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "google", value)

    @_builtins.property
    @pulumi.getter
    def linux(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Linux
        """
        return pulumi.get(self, "linux")

    @linux.setter
    def linux(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "linux", value)

    @_builtins.property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Microsoft
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "microsoft", value)

    @_builtins.property
    @pulumi.getter
    def other(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Other
        """
        return pulumi.get(self, "other")

    @other.setter
    def other(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "other", value)


if not MYPY:
    class HipObjectHostInfoCriteriaSerialNumberArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectHostInfoCriteriaSerialNumberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectHostInfoCriteriaSerialNumberArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectMobileDeviceArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaArgsDict']]
        """
        Criteria
        """
elif False:
    HipObjectMobileDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaArgs']] = None):
        """
        :param pulumi.Input['HipObjectMobileDeviceCriteriaArgs'] criteria: Criteria
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaArgs']]):
        pulumi.set(self, "criteria", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaArgsDict(TypedDict):
        applications: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsArgsDict']]
        """
        Applications
        """
        disk_encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If device's disk is encrypted
        """
        imei: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaImeiArgsDict']]
        """
        Imei
        """
        jailbroken: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If device is by rooted/jailbroken
        """
        last_checkin_time: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeArgsDict']]
        """
        Last checkin time
        """
        model: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaModelArgsDict']]
        """
        Model
        """
        passcode_set: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If device's passcode is present
        """
        phone_number: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaPhoneNumberArgsDict']]
        """
        Phone number
        """
        tag: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaTagArgsDict']]
        """
        Tag
        """
elif False:
    HipObjectMobileDeviceCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaArgs:
    def __init__(__self__, *,
                 applications: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsArgs']] = None,
                 disk_encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 imei: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaImeiArgs']] = None,
                 jailbroken: Optional[pulumi.Input[_builtins.bool]] = None,
                 last_checkin_time: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeArgs']] = None,
                 model: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaModelArgs']] = None,
                 passcode_set: Optional[pulumi.Input[_builtins.bool]] = None,
                 phone_number: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaPhoneNumberArgs']] = None,
                 tag: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaTagArgs']] = None):
        """
        :param pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsArgs'] applications: Applications
        :param pulumi.Input[_builtins.bool] disk_encrypted: If device's disk is encrypted
        :param pulumi.Input['HipObjectMobileDeviceCriteriaImeiArgs'] imei: Imei
        :param pulumi.Input[_builtins.bool] jailbroken: If device is by rooted/jailbroken
        :param pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeArgs'] last_checkin_time: Last checkin time
        :param pulumi.Input['HipObjectMobileDeviceCriteriaModelArgs'] model: Model
        :param pulumi.Input[_builtins.bool] passcode_set: If device's passcode is present
        :param pulumi.Input['HipObjectMobileDeviceCriteriaPhoneNumberArgs'] phone_number: Phone number
        :param pulumi.Input['HipObjectMobileDeviceCriteriaTagArgs'] tag: Tag
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if disk_encrypted is not None:
            pulumi.set(__self__, "disk_encrypted", disk_encrypted)
        if imei is not None:
            pulumi.set(__self__, "imei", imei)
        if jailbroken is not None:
            pulumi.set(__self__, "jailbroken", jailbroken)
        if last_checkin_time is not None:
            pulumi.set(__self__, "last_checkin_time", last_checkin_time)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if passcode_set is not None:
            pulumi.set(__self__, "passcode_set", passcode_set)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsArgs']]:
        """
        Applications
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsArgs']]):
        pulumi.set(self, "applications", value)

    @_builtins.property
    @pulumi.getter(name="diskEncrypted")
    def disk_encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If device's disk is encrypted
        """
        return pulumi.get(self, "disk_encrypted")

    @disk_encrypted.setter
    def disk_encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disk_encrypted", value)

    @_builtins.property
    @pulumi.getter
    def imei(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaImeiArgs']]:
        """
        Imei
        """
        return pulumi.get(self, "imei")

    @imei.setter
    def imei(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaImeiArgs']]):
        pulumi.set(self, "imei", value)

    @_builtins.property
    @pulumi.getter
    def jailbroken(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If device is by rooted/jailbroken
        """
        return pulumi.get(self, "jailbroken")

    @jailbroken.setter
    def jailbroken(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "jailbroken", value)

    @_builtins.property
    @pulumi.getter(name="lastCheckinTime")
    def last_checkin_time(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeArgs']]:
        """
        Last checkin time
        """
        return pulumi.get(self, "last_checkin_time")

    @last_checkin_time.setter
    def last_checkin_time(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeArgs']]):
        pulumi.set(self, "last_checkin_time", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaModelArgs']]:
        """
        Model
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaModelArgs']]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="passcodeSet")
    def passcode_set(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If device's passcode is present
        """
        return pulumi.get(self, "passcode_set")

    @passcode_set.setter
    def passcode_set(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passcode_set", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaPhoneNumberArgs']]:
        """
        Phone number
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaPhoneNumberArgs']]):
        pulumi.set(self, "phone_number", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaTagArgs']]:
        """
        Tag
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaApplicationsArgsDict(TypedDict):
        has_malware: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgsDict']]
        """
        Has malware
        """
        has_unmanaged_app: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Has apps that are not managed
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsIncludeArgsDict']]]]
        """
        Includes
        """
elif False:
    HipObjectMobileDeviceCriteriaApplicationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaApplicationsArgs:
    def __init__(__self__, *,
                 has_malware: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgs']] = None,
                 has_unmanaged_app: Optional[pulumi.Input[_builtins.bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsIncludeArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgs'] has_malware: Has malware
        :param pulumi.Input[_builtins.bool] has_unmanaged_app: Has apps that are not managed
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsIncludeArgs']]] includes: Includes
        """
        if has_malware is not None:
            pulumi.set(__self__, "has_malware", has_malware)
        if has_unmanaged_app is not None:
            pulumi.set(__self__, "has_unmanaged_app", has_unmanaged_app)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter(name="hasMalware")
    def has_malware(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgs']]:
        """
        Has malware
        """
        return pulumi.get(self, "has_malware")

    @has_malware.setter
    def has_malware(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgs']]):
        pulumi.set(self, "has_malware", value)

    @_builtins.property
    @pulumi.getter(name="hasUnmanagedApp")
    def has_unmanaged_app(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Has apps that are not managed
        """
        return pulumi.get(self, "has_unmanaged_app")

    @has_unmanaged_app.setter
    def has_unmanaged_app(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "has_unmanaged_app", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsIncludeArgs']]]]:
        """
        Includes
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsIncludeArgs']]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgsDict(TypedDict):
        no: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgsDict']]
        """
        No
        """
        yes: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgsDict']]
        """
        Yes

        >  **Note:** You must specify exactly one of `no` and `yes`.
        """
elif False:
    HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaApplicationsHasMalwareArgs:
    def __init__(__self__, *,
                 no: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgs']] = None,
                 yes: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgs']] = None):
        """
        :param pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgs'] no: No
        :param pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgs'] yes: Yes
               
               >  **Note:** You must specify exactly one of `no` and `yes`.
        """
        if no is not None:
            pulumi.set(__self__, "no", no)
        if yes is not None:
            pulumi.set(__self__, "yes", yes)

    @_builtins.property
    @pulumi.getter
    def no(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgs']]:
        """
        No
        """
        return pulumi.get(self, "no")

    @no.setter
    def no(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgs']]):
        pulumi.set(self, "no", value)

    @_builtins.property
    @pulumi.getter
    def yes(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgs']]:
        """
        Yes

        >  **Note:** You must specify exactly one of `no` and `yes`.
        """
        return pulumi.get(self, "yes")

    @yes.setter
    def yes(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgs']]):
        pulumi.set(self, "yes", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgsDict(TypedDict):
        pass
elif False:
    HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaApplicationsHasMalwareNoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgsDict']]]]
        """
        Excludes
        """
elif False:
    HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgs']]] excludes: Excludes
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgs']]]]:
        """
        Excludes
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgs']]]]):
        pulumi.set(self, "excludes", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        application hash
        """
        package: NotRequired[pulumi.Input[_builtins.str]]
        """
        application package name
        """
elif False:
    HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaApplicationsHasMalwareYesExcludeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hash: Optional[pulumi.Input[_builtins.str]] = None,
                 package: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] hash: application hash
        :param pulumi.Input[_builtins.str] package: application package name
        """
        pulumi.set(__self__, "name", name)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if package is not None:
            pulumi.set(__self__, "package", package)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application hash
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hash", value)

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application package name
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaApplicationsIncludeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        application hash
        """
        package: NotRequired[pulumi.Input[_builtins.str]]
        """
        application package name
        """
elif False:
    HipObjectMobileDeviceCriteriaApplicationsIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaApplicationsIncludeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hash: Optional[pulumi.Input[_builtins.str]] = None,
                 package: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] hash: application hash
        :param pulumi.Input[_builtins.str] package: application package name
        """
        pulumi.set(__self__, "name", name)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if package is not None:
            pulumi.set(__self__, "package", package)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application hash
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hash", value)

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        application package name
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaImeiArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectMobileDeviceCriteriaImeiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaImeiArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaLastCheckinTimeArgsDict(TypedDict):
        not_within: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgsDict']]
        """
        Not within
        """
        within: NotRequired[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgsDict']]
        """
        Within

        >  **Note:** You must specify exactly one of `not_within` and `within`.
        """
elif False:
    HipObjectMobileDeviceCriteriaLastCheckinTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaLastCheckinTimeArgs:
    def __init__(__self__, *,
                 not_within: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgs']] = None,
                 within: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgs']] = None):
        """
        :param pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgs'] not_within: Not within
        :param pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgs'] within: Within
               
               >  **Note:** You must specify exactly one of `not_within` and `within`.
        """
        if not_within is not None:
            pulumi.set(__self__, "not_within", not_within)
        if within is not None:
            pulumi.set(__self__, "within", within)

    @_builtins.property
    @pulumi.getter(name="notWithin")
    def not_within(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgs']]:
        """
        Not within
        """
        return pulumi.get(self, "not_within")

    @not_within.setter
    def not_within(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgs']]):
        pulumi.set(self, "not_within", value)

    @_builtins.property
    @pulumi.getter
    def within(self) -> Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgs']]:
        """
        Within

        >  **Note:** You must specify exactly one of `not_within` and `within`.
        """
        return pulumi.get(self, "within")

    @within.setter
    def within(self, value: Optional[pulumi.Input['HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgs']]):
        pulumi.set(self, "within", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgsDict(TypedDict):
        days: pulumi.Input[_builtins.int]
        """
        specify time in days
        """
elif False:
    HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaLastCheckinTimeNotWithinArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        """
        pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[_builtins.int]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgsDict(TypedDict):
        days: pulumi.Input[_builtins.int]
        """
        specify time in days
        """
elif False:
    HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaLastCheckinTimeWithinArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] days: specify time in days
        """
        pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[_builtins.int]:
        """
        specify time in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaModelArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectMobileDeviceCriteriaModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaModelArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaPhoneNumberArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectMobileDeviceCriteriaPhoneNumberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaPhoneNumberArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectMobileDeviceCriteriaTagArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains
        """
        is_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.str]]
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
elif False:
    HipObjectMobileDeviceCriteriaTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectMobileDeviceCriteriaTagArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 is_: Optional[pulumi.Input[_builtins.str]] = None,
                 is_not: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: Contains
        :param pulumi.Input[_builtins.str] is_: Is
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        :param pulumi.Input[_builtins.str] is_not: Is not
               
               >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `contains`, `is`, and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectNetworkInfoArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaArgsDict']]
        """
        Criteria
        """
elif False:
    HipObjectNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaArgs']] = None):
        """
        :param pulumi.Input['HipObjectNetworkInfoCriteriaArgs'] criteria: Criteria
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaArgs']]):
        pulumi.set(self, "criteria", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaArgsDict(TypedDict):
        network: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkArgsDict']]
        """
        Network
        """
elif False:
    HipObjectNetworkInfoCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkArgs']] = None):
        """
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkArgs'] network: Network
        """
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkArgs']]:
        """
        Network
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkArgs']]):
        pulumi.set(self, "network", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkArgsDict(TypedDict):
        is_: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsArgsDict']]
        """
        Is
        """
        is_not: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotArgsDict']]
        """
        Is not

        >  **Note:** You must specify exactly one of `is` and `is_not`.
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkArgs:
    def __init__(__self__, *,
                 is_: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsArgs']] = None,
                 is_not: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotArgs']] = None):
        """
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsArgs'] is_: Is
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotArgs'] is_not: Is not
               
               >  **Note:** You must specify exactly one of `is` and `is_not`.
        """
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsArgs']]:
        """
        Is
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsArgs']]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotArgs']]:
        """
        Is not

        >  **Note:** You must specify exactly one of `is` and `is_not`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotArgs']]):
        pulumi.set(self, "is_not", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsArgsDict(TypedDict):
        mobile: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsMobileArgsDict']]
        """
        Mobile
        """
        unknown: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsUnknownArgsDict']]
        """
        Unknown

        >  **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
        """
        wifi: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsWifiArgsDict']]
        """
        Wifi

        >  **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsArgs:
    def __init__(__self__, *,
                 mobile: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsMobileArgs']] = None,
                 unknown: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsUnknownArgs']] = None,
                 wifi: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsWifiArgs']] = None):
        """
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsMobileArgs'] mobile: Mobile
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsUnknownArgs'] unknown: Unknown
               
               >  **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsWifiArgs'] wifi: Wifi
               
               >  **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
        """
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if wifi is not None:
            pulumi.set(__self__, "wifi", wifi)

    @_builtins.property
    @pulumi.getter
    def mobile(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsMobileArgs']]:
        """
        Mobile
        """
        return pulumi.get(self, "mobile")

    @mobile.setter
    def mobile(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsMobileArgs']]):
        pulumi.set(self, "mobile", value)

    @_builtins.property
    @pulumi.getter
    def unknown(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsUnknownArgs']]:
        """
        Unknown

        >  **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
        """
        return pulumi.get(self, "unknown")

    @unknown.setter
    def unknown(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsUnknownArgs']]):
        pulumi.set(self, "unknown", value)

    @_builtins.property
    @pulumi.getter
    def wifi(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsWifiArgs']]:
        """
        Wifi

        >  **Note:** You must specify exactly one of `mobile`, `unknown`, and `wifi`.
        """
        return pulumi.get(self, "wifi")

    @wifi.setter
    def wifi(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsWifiArgs']]):
        pulumi.set(self, "wifi", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsMobileArgsDict(TypedDict):
        carrier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Carrier
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsMobileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsMobileArgs:
    def __init__(__self__, *,
                 carrier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] carrier: Carrier
        """
        if carrier is not None:
            pulumi.set(__self__, "carrier", carrier)

    @_builtins.property
    @pulumi.getter
    def carrier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Carrier
        """
        return pulumi.get(self, "carrier")

    @carrier.setter
    def carrier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "carrier", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsNotArgsDict(TypedDict):
        ethernet: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgsDict']]
        """
        Ethernet
        """
        mobile: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgsDict']]
        """
        Mobile

        >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
        unknown: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgsDict']]
        """
        Unknown

        >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
        wifi: NotRequired[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgsDict']]
        """
        Wifi

        >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsNotArgs:
    def __init__(__self__, *,
                 ethernet: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgs']] = None,
                 mobile: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgs']] = None,
                 unknown: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgs']] = None,
                 wifi: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgs']] = None):
        """
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgs'] ethernet: Ethernet
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgs'] mobile: Mobile
               
               >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgs'] unknown: Unknown
               
               >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        :param pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgs'] wifi: Wifi
               
               >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
        if ethernet is not None:
            pulumi.set(__self__, "ethernet", ethernet)
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if wifi is not None:
            pulumi.set(__self__, "wifi", wifi)

    @_builtins.property
    @pulumi.getter
    def ethernet(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgs']]:
        """
        Ethernet
        """
        return pulumi.get(self, "ethernet")

    @ethernet.setter
    def ethernet(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgs']]):
        pulumi.set(self, "ethernet", value)

    @_builtins.property
    @pulumi.getter
    def mobile(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgs']]:
        """
        Mobile

        >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
        return pulumi.get(self, "mobile")

    @mobile.setter
    def mobile(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgs']]):
        pulumi.set(self, "mobile", value)

    @_builtins.property
    @pulumi.getter
    def unknown(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgs']]:
        """
        Unknown

        >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
        return pulumi.get(self, "unknown")

    @unknown.setter
    def unknown(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgs']]):
        pulumi.set(self, "unknown", value)

    @_builtins.property
    @pulumi.getter
    def wifi(self) -> Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgs']]:
        """
        Wifi

        >  **Note:** You must specify exactly one of `ethernet`, `mobile`, `unknown`, and `wifi`.
        """
        return pulumi.get(self, "wifi")

    @wifi.setter
    def wifi(self, value: Optional[pulumi.Input['HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgs']]):
        pulumi.set(self, "wifi", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgsDict(TypedDict):
        pass
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsNotEthernetArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgsDict(TypedDict):
        carrier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Carrier
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsNotMobileArgs:
    def __init__(__self__, *,
                 carrier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] carrier: Carrier
        """
        if carrier is not None:
            pulumi.set(__self__, "carrier", carrier)

    @_builtins.property
    @pulumi.getter
    def carrier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Carrier
        """
        return pulumi.get(self, "carrier")

    @carrier.setter
    def carrier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "carrier", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgsDict(TypedDict):
        pass
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsNotUnknownArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgsDict(TypedDict):
        ssid: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSID
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsNotWifiArgs:
    def __init__(__self__, *,
                 ssid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ssid: SSID
        """
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSID
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssid", value)


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsUnknownArgsDict(TypedDict):
        pass
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsUnknownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsUnknownArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class HipObjectNetworkInfoCriteriaNetworkIsWifiArgsDict(TypedDict):
        ssid: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSID
        """
elif False:
    HipObjectNetworkInfoCriteriaNetworkIsWifiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectNetworkInfoCriteriaNetworkIsWifiArgs:
    def __init__(__self__, *,
                 ssid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ssid: SSID
        """
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSID
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssid", value)


if not MYPY:
    class HipObjectPatchManagementArgsDict(TypedDict):
        criteria: NotRequired[pulumi.Input['HipObjectPatchManagementCriteriaArgsDict']]
        """
        Criteria
        """
        exclude_vendor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exclude vendor
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input['HipObjectPatchManagementVendorArgsDict']]]]
        """
        Vendor name
        """
elif False:
    HipObjectPatchManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectPatchManagementArgs:
    def __init__(__self__, *,
                 criteria: Optional[pulumi.Input['HipObjectPatchManagementCriteriaArgs']] = None,
                 exclude_vendor: Optional[pulumi.Input[_builtins.bool]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectPatchManagementVendorArgs']]]] = None):
        """
        :param pulumi.Input['HipObjectPatchManagementCriteriaArgs'] criteria: Criteria
        :param pulumi.Input[_builtins.bool] exclude_vendor: Exclude vendor
        :param pulumi.Input[Sequence[pulumi.Input['HipObjectPatchManagementVendorArgs']]] vendors: Vendor name
        """
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if exclude_vendor is not None:
            pulumi.set(__self__, "exclude_vendor", exclude_vendor)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['HipObjectPatchManagementCriteriaArgs']]:
        """
        Criteria
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['HipObjectPatchManagementCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter(name="excludeVendor")
    def exclude_vendor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exclude vendor
        """
        return pulumi.get(self, "exclude_vendor")

    @exclude_vendor.setter
    def exclude_vendor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_vendor", value)

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectPatchManagementVendorArgs']]]]:
        """
        Vendor name
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HipObjectPatchManagementVendorArgs']]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class HipObjectPatchManagementCriteriaArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        is enabled
        """
        is_installed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Is Installed
        """
        missing_patches: NotRequired[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesArgsDict']]
        """
        Missing patches
        """
elif False:
    HipObjectPatchManagementCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectPatchManagementCriteriaArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.str]] = None,
                 is_installed: Optional[pulumi.Input[_builtins.bool]] = None,
                 missing_patches: Optional[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] is_enabled: is enabled
        :param pulumi.Input[_builtins.bool] is_installed: Is Installed
        :param pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesArgs'] missing_patches: Missing patches
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)
        if missing_patches is not None:
            pulumi.set(__self__, "missing_patches", missing_patches)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        is enabled
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Is Installed
        """
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_installed", value)

    @_builtins.property
    @pulumi.getter(name="missingPatches")
    def missing_patches(self) -> Optional[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesArgs']]:
        """
        Missing patches
        """
        return pulumi.get(self, "missing_patches")

    @missing_patches.setter
    def missing_patches(self, value: Optional[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesArgs']]):
        pulumi.set(self, "missing_patches", value)


if not MYPY:
    class HipObjectPatchManagementCriteriaMissingPatchesArgsDict(TypedDict):
        check: pulumi.Input[_builtins.str]
        """
        Check
        """
        patches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Patches
        """
        severity: NotRequired[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesSeverityArgsDict']]
        """
        Severity
        """
elif False:
    HipObjectPatchManagementCriteriaMissingPatchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectPatchManagementCriteriaMissingPatchesArgs:
    def __init__(__self__, *,
                 check: pulumi.Input[_builtins.str],
                 patches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 severity: Optional[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesSeverityArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] check: Check
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] patches: Patches
        :param pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesSeverityArgs'] severity: Severity
        """
        pulumi.set(__self__, "check", check)
        if patches is not None:
            pulumi.set(__self__, "patches", patches)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def check(self) -> pulumi.Input[_builtins.str]:
        """
        Check
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "check", value)

    @_builtins.property
    @pulumi.getter
    def patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Patches
        """
        return pulumi.get(self, "patches")

    @patches.setter
    def patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "patches", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesSeverityArgs']]:
        """
        Severity
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input['HipObjectPatchManagementCriteriaMissingPatchesSeverityArgs']]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class HipObjectPatchManagementCriteriaMissingPatchesSeverityArgsDict(TypedDict):
        greater_equal: NotRequired[pulumi.Input[_builtins.int]]
        """
        Greater equal
        """
        greater_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Greater than

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        is_: NotRequired[pulumi.Input[_builtins.int]]
        """
        Is

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        is_not: NotRequired[pulumi.Input[_builtins.int]]
        """
        Is not

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        less_equal: NotRequired[pulumi.Input[_builtins.int]]
        """
        Less equal

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        less_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Less than

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
elif False:
    HipObjectPatchManagementCriteriaMissingPatchesSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectPatchManagementCriteriaMissingPatchesSeverityArgs:
    def __init__(__self__, *,
                 greater_equal: Optional[pulumi.Input[_builtins.int]] = None,
                 greater_than: Optional[pulumi.Input[_builtins.int]] = None,
                 is_: Optional[pulumi.Input[_builtins.int]] = None,
                 is_not: Optional[pulumi.Input[_builtins.int]] = None,
                 less_equal: Optional[pulumi.Input[_builtins.int]] = None,
                 less_than: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] greater_equal: Greater equal
        :param pulumi.Input[_builtins.int] greater_than: Greater than
               
               >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        :param pulumi.Input[_builtins.int] is_: Is
               
               >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        :param pulumi.Input[_builtins.int] is_not: Is not
               
               >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        :param pulumi.Input[_builtins.int] less_equal: Less equal
               
               >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        :param pulumi.Input[_builtins.int] less_than: Less than
               
               >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        if greater_equal is not None:
            pulumi.set(__self__, "greater_equal", greater_equal)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if is_ is not None:
            pulumi.set(__self__, "is_", is_)
        if is_not is not None:
            pulumi.set(__self__, "is_not", is_not)
        if less_equal is not None:
            pulumi.set(__self__, "less_equal", less_equal)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)

    @_builtins.property
    @pulumi.getter(name="greaterEqual")
    def greater_equal(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Greater equal
        """
        return pulumi.get(self, "greater_equal")

    @greater_equal.setter
    def greater_equal(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "greater_equal", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Greater than

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="is")
    def is_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Is

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        return pulumi.get(self, "is_")

    @is_.setter
    def is_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_", value)

    @_builtins.property
    @pulumi.getter(name="isNot")
    def is_not(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Is not

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        return pulumi.get(self, "is_not")

    @is_not.setter
    def is_not(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "is_not", value)

    @_builtins.property
    @pulumi.getter(name="lessEqual")
    def less_equal(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Less equal

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        return pulumi.get(self, "less_equal")

    @less_equal.setter
    def less_equal(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "less_equal", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Less than

        >  **Note:** You must specify exactly one of `greater_equal`, `greater_than`, `is`, `is_not`, `less_equal`, and `less_than`.
        """
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "less_than", value)


if not MYPY:
    class HipObjectPatchManagementVendorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Product name
        """
elif False:
    HipObjectPatchManagementVendorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HipObjectPatchManagementVendorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Product name
        """
        pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Product name
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class HttpHeaderProfileHttpHeaderInsertionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the HTTP header insertion rule
        """
        types: pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeArgsDict']]]
        """
        A list of HTTP header insertion definitions
        """
elif False:
    HttpHeaderProfileHttpHeaderInsertionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpHeaderProfileHttpHeaderInsertionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 types: pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeArgs']]]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the HTTP header insertion rule
        :param pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeArgs']]] types: A list of HTTP header insertion definitions
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the HTTP header insertion rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeArgs']]]:
        """
        A list of HTTP header insertion definitions
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeArgs']]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class HttpHeaderProfileHttpHeaderInsertionTypeArgsDict(TypedDict):
        domains: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of DNS domains
        """
        headers: pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgsDict']]]
        """
        Headers
        """
        name: pulumi.Input[_builtins.str]
        """
        The HTTP header insertion type
        """
elif False:
    HttpHeaderProfileHttpHeaderInsertionTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpHeaderProfileHttpHeaderInsertionTypeArgs:
    def __init__(__self__, *,
                 domains: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 headers: pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgs']]],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domains: A list of DNS domains
        :param pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The HTTP header insertion type
        """
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of DNS domains
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "domains", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgs']]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: pulumi.Input[Sequence[pulumi.Input['HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgs']]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The HTTP header insertion type
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgsDict(TypedDict):
        header: pulumi.Input[_builtins.str]
        """
        The HTTP header string
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the HTTP header
        """
        value: pulumi.Input[_builtins.str]
        """
        The value associated with the HTTP header
        """
        log: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log the use of this HTTP header insertion?
        """
elif False:
    HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpHeaderProfileHttpHeaderInsertionTypeHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 log: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] header: The HTTP header string
        :param pulumi.Input[_builtins.str] name: The name of the HTTP header
        :param pulumi.Input[_builtins.str] value: The value associated with the HTTP header
        :param pulumi.Input[_builtins.bool] log: Log the use of this HTTP header insertion?
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if log is not None:
            pulumi.set(__self__, "log", log)

    @_builtins.property
    @pulumi.getter
    def header(self) -> pulumi.Input[_builtins.str]:
        """
        The HTTP header string
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the HTTP header
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value associated with the HTTP header
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def log(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log the use of this HTTP header insertion?
        """
        return pulumi.get(self, "log")

    @log.setter
    def log(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log", value)


if not MYPY:
    class HttpServerProfileFormatArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['HttpServerProfileFormatAuthArgsDict']]
        """
        Auth
        """
        config: NotRequired[pulumi.Input['HttpServerProfileFormatConfigArgsDict']]
        """
        Config
        """
        correlation: NotRequired[pulumi.Input['HttpServerProfileFormatCorrelationArgsDict']]
        """
        Correlation
        """
        data: NotRequired[pulumi.Input['HttpServerProfileFormatDataArgsDict']]
        """
        Data
        """
        decryption: NotRequired[pulumi.Input['HttpServerProfileFormatDecryptionArgsDict']]
        """
        Decryption
        """
        globalprotect: NotRequired[pulumi.Input['HttpServerProfileFormatGlobalprotectArgsDict']]
        """
        Globalprotect
        """
        gtp: NotRequired[pulumi.Input['HttpServerProfileFormatGtpArgsDict']]
        """
        Gtp
        """
        hip_match: NotRequired[pulumi.Input['HttpServerProfileFormatHipMatchArgsDict']]
        """
        Hip match
        """
        iptag: NotRequired[pulumi.Input['HttpServerProfileFormatIptagArgsDict']]
        """
        Iptag
        """
        sctp: NotRequired[pulumi.Input['HttpServerProfileFormatSctpArgsDict']]
        """
        Sctp
        """
        system: NotRequired[pulumi.Input['HttpServerProfileFormatSystemArgsDict']]
        """
        System
        """
        threat: NotRequired[pulumi.Input['HttpServerProfileFormatThreatArgsDict']]
        """
        Threat
        """
        traffic: NotRequired[pulumi.Input['HttpServerProfileFormatTrafficArgsDict']]
        """
        Traffic
        """
        tunnel: NotRequired[pulumi.Input['HttpServerProfileFormatTunnelArgsDict']]
        """
        Tunnel
        """
        url: NotRequired[pulumi.Input['HttpServerProfileFormatUrlArgsDict']]
        """
        Url
        """
        userid: NotRequired[pulumi.Input['HttpServerProfileFormatUseridArgsDict']]
        """
        Userid
        """
        wildfire: NotRequired[pulumi.Input['HttpServerProfileFormatWildfireArgsDict']]
        """
        Wildfire
        """
elif False:
    HttpServerProfileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['HttpServerProfileFormatAuthArgs']] = None,
                 config: Optional[pulumi.Input['HttpServerProfileFormatConfigArgs']] = None,
                 correlation: Optional[pulumi.Input['HttpServerProfileFormatCorrelationArgs']] = None,
                 data: Optional[pulumi.Input['HttpServerProfileFormatDataArgs']] = None,
                 decryption: Optional[pulumi.Input['HttpServerProfileFormatDecryptionArgs']] = None,
                 globalprotect: Optional[pulumi.Input['HttpServerProfileFormatGlobalprotectArgs']] = None,
                 gtp: Optional[pulumi.Input['HttpServerProfileFormatGtpArgs']] = None,
                 hip_match: Optional[pulumi.Input['HttpServerProfileFormatHipMatchArgs']] = None,
                 iptag: Optional[pulumi.Input['HttpServerProfileFormatIptagArgs']] = None,
                 sctp: Optional[pulumi.Input['HttpServerProfileFormatSctpArgs']] = None,
                 system: Optional[pulumi.Input['HttpServerProfileFormatSystemArgs']] = None,
                 threat: Optional[pulumi.Input['HttpServerProfileFormatThreatArgs']] = None,
                 traffic: Optional[pulumi.Input['HttpServerProfileFormatTrafficArgs']] = None,
                 tunnel: Optional[pulumi.Input['HttpServerProfileFormatTunnelArgs']] = None,
                 url: Optional[pulumi.Input['HttpServerProfileFormatUrlArgs']] = None,
                 userid: Optional[pulumi.Input['HttpServerProfileFormatUseridArgs']] = None,
                 wildfire: Optional[pulumi.Input['HttpServerProfileFormatWildfireArgs']] = None):
        """
        :param pulumi.Input['HttpServerProfileFormatAuthArgs'] auth: Auth
        :param pulumi.Input['HttpServerProfileFormatConfigArgs'] config: Config
        :param pulumi.Input['HttpServerProfileFormatCorrelationArgs'] correlation: Correlation
        :param pulumi.Input['HttpServerProfileFormatDataArgs'] data: Data
        :param pulumi.Input['HttpServerProfileFormatDecryptionArgs'] decryption: Decryption
        :param pulumi.Input['HttpServerProfileFormatGlobalprotectArgs'] globalprotect: Globalprotect
        :param pulumi.Input['HttpServerProfileFormatGtpArgs'] gtp: Gtp
        :param pulumi.Input['HttpServerProfileFormatHipMatchArgs'] hip_match: Hip match
        :param pulumi.Input['HttpServerProfileFormatIptagArgs'] iptag: Iptag
        :param pulumi.Input['HttpServerProfileFormatSctpArgs'] sctp: Sctp
        :param pulumi.Input['HttpServerProfileFormatSystemArgs'] system: System
        :param pulumi.Input['HttpServerProfileFormatThreatArgs'] threat: Threat
        :param pulumi.Input['HttpServerProfileFormatTrafficArgs'] traffic: Traffic
        :param pulumi.Input['HttpServerProfileFormatTunnelArgs'] tunnel: Tunnel
        :param pulumi.Input['HttpServerProfileFormatUrlArgs'] url: Url
        :param pulumi.Input['HttpServerProfileFormatUseridArgs'] userid: Userid
        :param pulumi.Input['HttpServerProfileFormatWildfireArgs'] wildfire: Wildfire
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if correlation is not None:
            pulumi.set(__self__, "correlation", correlation)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if decryption is not None:
            pulumi.set(__self__, "decryption", decryption)
        if globalprotect is not None:
            pulumi.set(__self__, "globalprotect", globalprotect)
        if gtp is not None:
            pulumi.set(__self__, "gtp", gtp)
        if hip_match is not None:
            pulumi.set(__self__, "hip_match", hip_match)
        if iptag is not None:
            pulumi.set(__self__, "iptag", iptag)
        if sctp is not None:
            pulumi.set(__self__, "sctp", sctp)
        if system is not None:
            pulumi.set(__self__, "system", system)
        if threat is not None:
            pulumi.set(__self__, "threat", threat)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if userid is not None:
            pulumi.set(__self__, "userid", userid)
        if wildfire is not None:
            pulumi.set(__self__, "wildfire", wildfire)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['HttpServerProfileFormatAuthArgs']]:
        """
        Auth
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['HttpServerProfileFormatAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['HttpServerProfileFormatConfigArgs']]:
        """
        Config
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['HttpServerProfileFormatConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def correlation(self) -> Optional[pulumi.Input['HttpServerProfileFormatCorrelationArgs']]:
        """
        Correlation
        """
        return pulumi.get(self, "correlation")

    @correlation.setter
    def correlation(self, value: Optional[pulumi.Input['HttpServerProfileFormatCorrelationArgs']]):
        pulumi.set(self, "correlation", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input['HttpServerProfileFormatDataArgs']]:
        """
        Data
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input['HttpServerProfileFormatDataArgs']]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def decryption(self) -> Optional[pulumi.Input['HttpServerProfileFormatDecryptionArgs']]:
        """
        Decryption
        """
        return pulumi.get(self, "decryption")

    @decryption.setter
    def decryption(self, value: Optional[pulumi.Input['HttpServerProfileFormatDecryptionArgs']]):
        pulumi.set(self, "decryption", value)

    @_builtins.property
    @pulumi.getter
    def globalprotect(self) -> Optional[pulumi.Input['HttpServerProfileFormatGlobalprotectArgs']]:
        """
        Globalprotect
        """
        return pulumi.get(self, "globalprotect")

    @globalprotect.setter
    def globalprotect(self, value: Optional[pulumi.Input['HttpServerProfileFormatGlobalprotectArgs']]):
        pulumi.set(self, "globalprotect", value)

    @_builtins.property
    @pulumi.getter
    def gtp(self) -> Optional[pulumi.Input['HttpServerProfileFormatGtpArgs']]:
        """
        Gtp
        """
        return pulumi.get(self, "gtp")

    @gtp.setter
    def gtp(self, value: Optional[pulumi.Input['HttpServerProfileFormatGtpArgs']]):
        pulumi.set(self, "gtp", value)

    @_builtins.property
    @pulumi.getter(name="hipMatch")
    def hip_match(self) -> Optional[pulumi.Input['HttpServerProfileFormatHipMatchArgs']]:
        """
        Hip match
        """
        return pulumi.get(self, "hip_match")

    @hip_match.setter
    def hip_match(self, value: Optional[pulumi.Input['HttpServerProfileFormatHipMatchArgs']]):
        pulumi.set(self, "hip_match", value)

    @_builtins.property
    @pulumi.getter
    def iptag(self) -> Optional[pulumi.Input['HttpServerProfileFormatIptagArgs']]:
        """
        Iptag
        """
        return pulumi.get(self, "iptag")

    @iptag.setter
    def iptag(self, value: Optional[pulumi.Input['HttpServerProfileFormatIptagArgs']]):
        pulumi.set(self, "iptag", value)

    @_builtins.property
    @pulumi.getter
    def sctp(self) -> Optional[pulumi.Input['HttpServerProfileFormatSctpArgs']]:
        """
        Sctp
        """
        return pulumi.get(self, "sctp")

    @sctp.setter
    def sctp(self, value: Optional[pulumi.Input['HttpServerProfileFormatSctpArgs']]):
        pulumi.set(self, "sctp", value)

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[pulumi.Input['HttpServerProfileFormatSystemArgs']]:
        """
        System
        """
        return pulumi.get(self, "system")

    @system.setter
    def system(self, value: Optional[pulumi.Input['HttpServerProfileFormatSystemArgs']]):
        pulumi.set(self, "system", value)

    @_builtins.property
    @pulumi.getter
    def threat(self) -> Optional[pulumi.Input['HttpServerProfileFormatThreatArgs']]:
        """
        Threat
        """
        return pulumi.get(self, "threat")

    @threat.setter
    def threat(self, value: Optional[pulumi.Input['HttpServerProfileFormatThreatArgs']]):
        pulumi.set(self, "threat", value)

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input['HttpServerProfileFormatTrafficArgs']]:
        """
        Traffic
        """
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input['HttpServerProfileFormatTrafficArgs']]):
        pulumi.set(self, "traffic", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input['HttpServerProfileFormatTunnelArgs']]:
        """
        Tunnel
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input['HttpServerProfileFormatTunnelArgs']]):
        pulumi.set(self, "tunnel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input['HttpServerProfileFormatUrlArgs']]:
        """
        Url
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input['HttpServerProfileFormatUrlArgs']]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def userid(self) -> Optional[pulumi.Input['HttpServerProfileFormatUseridArgs']]:
        """
        Userid
        """
        return pulumi.get(self, "userid")

    @userid.setter
    def userid(self, value: Optional[pulumi.Input['HttpServerProfileFormatUseridArgs']]):
        pulumi.set(self, "userid", value)

    @_builtins.property
    @pulumi.getter
    def wildfire(self) -> Optional[pulumi.Input['HttpServerProfileFormatWildfireArgs']]:
        """
        Wildfire
        """
        return pulumi.get(self, "wildfire")

    @wildfire.setter
    def wildfire(self, value: Optional[pulumi.Input['HttpServerProfileFormatWildfireArgs']]):
        pulumi.set(self, "wildfire", value)


if not MYPY:
    class HttpServerProfileFormatAuthArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatAuthArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatAuthParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatAuthHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatAuthHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatAuthHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatAuthParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatAuthParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatAuthParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatConfigArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatConfigArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatConfigParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatConfigHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatConfigHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatConfigHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatConfigParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatConfigParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatConfigParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatCorrelationArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatCorrelationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatCorrelationArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatCorrelationParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatCorrelationHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatCorrelationHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatCorrelationHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatCorrelationParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatCorrelationParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatCorrelationParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatDataArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatDataArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDataParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatDataHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatDataHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatDataHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatDataParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatDataParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatDataParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatDecryptionArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatDecryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatDecryptionArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatDecryptionParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatDecryptionHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatDecryptionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatDecryptionHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatDecryptionParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatDecryptionParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatDecryptionParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatGlobalprotectArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatGlobalprotectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatGlobalprotectArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGlobalprotectParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatGlobalprotectHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatGlobalprotectHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatGlobalprotectHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatGlobalprotectParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatGlobalprotectParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatGlobalprotectParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatGtpArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatGtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatGtpArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatGtpParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatGtpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatGtpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatGtpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatGtpParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatGtpParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatGtpParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatHipMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatHipMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatHipMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatHipMatchParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatHipMatchHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatHipMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatHipMatchHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatHipMatchParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatHipMatchParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatHipMatchParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatIptagArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatIptagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatIptagArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatIptagParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatIptagHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatIptagHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatIptagHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatIptagParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatIptagParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatIptagParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatSctpArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatSctpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatSctpArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSctpParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatSctpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatSctpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatSctpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatSctpParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatSctpParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatSctpParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatSystemArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatSystemArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatSystemParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatSystemHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatSystemHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatSystemHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatSystemParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatSystemParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatSystemParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatThreatArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatThreatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatThreatArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatThreatParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatThreatHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatThreatHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatThreatHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatThreatParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatThreatParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatThreatParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatTrafficArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatTrafficArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatTrafficArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTrafficParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatTrafficHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatTrafficHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatTrafficHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatTrafficParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatTrafficParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatTrafficParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatTunnelArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatTunnelArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatTunnelParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatTunnelHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatTunnelHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatTunnelHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatTunnelParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatTunnelParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatTunnelParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatUrlArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatUrlArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUrlParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatUrlHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatUrlHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatUrlHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatUrlParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatUrlParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatUrlParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatUseridArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatUseridArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatUseridArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatUseridParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatUseridHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatUseridHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatUseridHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatUseridParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatUseridParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatUseridParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatWildfireArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireHeaderArgsDict']]]]
        """
        Headers
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the payload format
        """
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireParamArgsDict']]]]
        """
        Params
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log payload format.  The accepted log field values are as follows.
        """
        url_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL path of the HTTP server
        """
elif False:
    HttpServerProfileFormatWildfireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatWildfireArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireHeaderArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireParamArgs']]]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 url_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireHeaderArgs']]] headers: Headers
        :param pulumi.Input[_builtins.str] name: The name of the payload format
        :param pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireParamArgs']]] params: Params
        :param pulumi.Input[_builtins.str] payload: The log payload format.  The accepted log field values are as follows.
        :param pulumi.Input[_builtins.str] url_format: The URL path of the HTTP server
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if url_format is not None:
            pulumi.set(__self__, "url_format", url_format)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireHeaderArgs']]]]:
        """
        Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the payload format
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireParamArgs']]]]:
        """
        Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpServerProfileFormatWildfireParamArgs']]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log payload format.  The accepted log field values are as follows.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="urlFormat")
    def url_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL path of the HTTP server
        """
        return pulumi.get(self, "url_format")

    @url_format.setter
    def url_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_format", value)


if not MYPY:
    class HttpServerProfileFormatWildfireHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header value
        """
elif False:
    HttpServerProfileFormatWildfireHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatWildfireHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Header name
        :param pulumi.Input[_builtins.str] value: Header value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileFormatWildfireParamArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameter value
        """
elif False:
    HttpServerProfileFormatWildfireParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileFormatWildfireParamArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Parameter name
        :param pulumi.Input[_builtins.str] value: Parameter value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpServerProfileServerArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP server address
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP server certificate profile
        """
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP operation to perform
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP server name
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        HTTP server port
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP server protocol
        """
        tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP server TLS version
        """
elif False:
    HttpServerProfileServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpServerProfileServerArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: HTTP server address
        :param pulumi.Input[_builtins.str] certificate_profile: HTTP server certificate profile
        :param pulumi.Input[_builtins.str] http_method: HTTP operation to perform
        :param pulumi.Input[_builtins.str] name: HTTP server name
        :param pulumi.Input[_builtins.int] port: HTTP server port
        :param pulumi.Input[_builtins.str] protocol: HTTP server protocol
        :param pulumi.Input[_builtins.str] tls_version: HTTP server TLS version
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP server address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP server certificate profile
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP operation to perform
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP server name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        HTTP server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP server protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP server TLS version
        """
        return pulumi.get(self, "tls_version")

    @tls_version.setter
    def tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_version", value)


if not MYPY:
    class IkeCryptoProfileLifetimeArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in days
        """
        hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in hours

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in minutes

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in seconds

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
elif False:
    IkeCryptoProfileLifetimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeCryptoProfileLifetimeArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 hours: Optional[pulumi.Input[_builtins.int]] = None,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify lifetime in days
        :param pulumi.Input[_builtins.int] hours: specify lifetime in hours
               
               >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        :param pulumi.Input[_builtins.int] minutes: specify lifetime in minutes
               
               >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        :param pulumi.Input[_builtins.int] seconds: specify lifetime in seconds
               
               >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in hours

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in minutes

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in seconds

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class IkeGatewayAuthenticationArgsDict(TypedDict):
        certificate: NotRequired[pulumi.Input['IkeGatewayAuthenticationCertificateArgsDict']]
        """
        Certificate
        """
        pre_shared_key: NotRequired[pulumi.Input['IkeGatewayAuthenticationPreSharedKeyArgsDict']]
        """
        Pre shared key

        >  **Note:** You must specify exactly one of `certificate` and `pre_shared_key`.
        """
elif False:
    IkeGatewayAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayAuthenticationArgs:
    def __init__(__self__, *,
                 certificate: Optional[pulumi.Input['IkeGatewayAuthenticationCertificateArgs']] = None,
                 pre_shared_key: Optional[pulumi.Input['IkeGatewayAuthenticationPreSharedKeyArgs']] = None):
        """
        :param pulumi.Input['IkeGatewayAuthenticationCertificateArgs'] certificate: Certificate
        :param pulumi.Input['IkeGatewayAuthenticationPreSharedKeyArgs'] pre_shared_key: Pre shared key
               
               >  **Note:** You must specify exactly one of `certificate` and `pre_shared_key`.
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['IkeGatewayAuthenticationCertificateArgs']]:
        """
        Certificate
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['IkeGatewayAuthenticationCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[pulumi.Input['IkeGatewayAuthenticationPreSharedKeyArgs']]:
        """
        Pre shared key

        >  **Note:** You must specify exactly one of `certificate` and `pre_shared_key`.
        """
        return pulumi.get(self, "pre_shared_key")

    @pre_shared_key.setter
    def pre_shared_key(self, value: Optional[pulumi.Input['IkeGatewayAuthenticationPreSharedKeyArgs']]):
        pulumi.set(self, "pre_shared_key", value)


if not MYPY:
    class IkeGatewayAuthenticationCertificateArgsDict(TypedDict):
        allow_id_payload_mismatch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow id payload mismatch
        """
        certificate_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate profile
        """
        local_certificate: NotRequired[pulumi.Input['IkeGatewayAuthenticationCertificateLocalCertificateArgsDict']]
        """
        Local certificate
        """
        strict_validation_revocation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strict validation revocation
        """
        use_management_as_source: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use management as source
        """
elif False:
    IkeGatewayAuthenticationCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayAuthenticationCertificateArgs:
    def __init__(__self__, *,
                 allow_id_payload_mismatch: Optional[pulumi.Input[_builtins.bool]] = None,
                 certificate_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 local_certificate: Optional[pulumi.Input['IkeGatewayAuthenticationCertificateLocalCertificateArgs']] = None,
                 strict_validation_revocation: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_management_as_source: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_id_payload_mismatch: Allow id payload mismatch
        :param pulumi.Input[_builtins.str] certificate_profile: Certificate profile
        :param pulumi.Input['IkeGatewayAuthenticationCertificateLocalCertificateArgs'] local_certificate: Local certificate
        :param pulumi.Input[_builtins.bool] strict_validation_revocation: Strict validation revocation
        :param pulumi.Input[_builtins.bool] use_management_as_source: Use management as source
        """
        if allow_id_payload_mismatch is not None:
            pulumi.set(__self__, "allow_id_payload_mismatch", allow_id_payload_mismatch)
        if certificate_profile is not None:
            pulumi.set(__self__, "certificate_profile", certificate_profile)
        if local_certificate is not None:
            pulumi.set(__self__, "local_certificate", local_certificate)
        if strict_validation_revocation is not None:
            pulumi.set(__self__, "strict_validation_revocation", strict_validation_revocation)
        if use_management_as_source is not None:
            pulumi.set(__self__, "use_management_as_source", use_management_as_source)

    @_builtins.property
    @pulumi.getter(name="allowIdPayloadMismatch")
    def allow_id_payload_mismatch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow id payload mismatch
        """
        return pulumi.get(self, "allow_id_payload_mismatch")

    @allow_id_payload_mismatch.setter
    def allow_id_payload_mismatch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_id_payload_mismatch", value)

    @_builtins.property
    @pulumi.getter(name="certificateProfile")
    def certificate_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate profile
        """
        return pulumi.get(self, "certificate_profile")

    @certificate_profile.setter
    def certificate_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_profile", value)

    @_builtins.property
    @pulumi.getter(name="localCertificate")
    def local_certificate(self) -> Optional[pulumi.Input['IkeGatewayAuthenticationCertificateLocalCertificateArgs']]:
        """
        Local certificate
        """
        return pulumi.get(self, "local_certificate")

    @local_certificate.setter
    def local_certificate(self, value: Optional[pulumi.Input['IkeGatewayAuthenticationCertificateLocalCertificateArgs']]):
        pulumi.set(self, "local_certificate", value)

    @_builtins.property
    @pulumi.getter(name="strictValidationRevocation")
    def strict_validation_revocation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strict validation revocation
        """
        return pulumi.get(self, "strict_validation_revocation")

    @strict_validation_revocation.setter
    def strict_validation_revocation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strict_validation_revocation", value)

    @_builtins.property
    @pulumi.getter(name="useManagementAsSource")
    def use_management_as_source(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use management as source
        """
        return pulumi.get(self, "use_management_as_source")

    @use_management_as_source.setter
    def use_management_as_source(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_management_as_source", value)


if not MYPY:
    class IkeGatewayAuthenticationCertificateLocalCertificateArgsDict(TypedDict):
        local_certificate_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local certificate name
        """
elif False:
    IkeGatewayAuthenticationCertificateLocalCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayAuthenticationCertificateLocalCertificateArgs:
    def __init__(__self__, *,
                 local_certificate_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] local_certificate_name: Local certificate name
        """
        if local_certificate_name is not None:
            pulumi.set(__self__, "local_certificate_name", local_certificate_name)

    @_builtins.property
    @pulumi.getter(name="localCertificateName")
    def local_certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local certificate name
        """
        return pulumi.get(self, "local_certificate_name")

    @local_certificate_name.setter
    def local_certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_certificate_name", value)


if not MYPY:
    class IkeGatewayAuthenticationPreSharedKeyArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    IkeGatewayAuthenticationPreSharedKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayAuthenticationPreSharedKeyArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class IkeGatewayLocalAddressArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface variable or hardcoded vlan/loopback. vlan will be passed as default value
        """
elif False:
    IkeGatewayLocalAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayLocalAddressArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Interface variable or hardcoded vlan/loopback. vlan will be passed as default value
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface variable or hardcoded vlan/loopback. vlan will be passed as default value
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)


if not MYPY:
    class IkeGatewayLocalIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local ID string
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type
        """
elif False:
    IkeGatewayLocalIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayLocalIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Local ID string
        :param pulumi.Input[_builtins.str] type: Type
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local ID string
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IkeGatewayPeerAddressArgsDict(TypedDict):
        dynamic: NotRequired[pulumi.Input['IkeGatewayPeerAddressDynamicArgsDict']]
        """
        Dynamic
        """
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        peer gateway FQDN name

        >  **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        peer gateway has static IP address

        >  **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
        """
elif False:
    IkeGatewayPeerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayPeerAddressArgs:
    def __init__(__self__, *,
                 dynamic: Optional[pulumi.Input['IkeGatewayPeerAddressDynamicArgs']] = None,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['IkeGatewayPeerAddressDynamicArgs'] dynamic: Dynamic
        :param pulumi.Input[_builtins.str] fqdn: peer gateway FQDN name
               
               >  **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
        :param pulumi.Input[_builtins.str] ip: peer gateway has static IP address
               
               >  **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
        """
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input['IkeGatewayPeerAddressDynamicArgs']]:
        """
        Dynamic
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input['IkeGatewayPeerAddressDynamicArgs']]):
        pulumi.set(self, "dynamic", value)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        peer gateway FQDN name

        >  **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        peer gateway has static IP address

        >  **Note:** You must specify exactly one of `dynamic`, `fqdn`, and `ip`.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class IkeGatewayPeerAddressDynamicArgsDict(TypedDict):
        pass
elif False:
    IkeGatewayPeerAddressDynamicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayPeerAddressDynamicArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IkeGatewayPeerIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer ID string
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type
        """
elif False:
    IkeGatewayPeerIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayPeerIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Peer ID string
        :param pulumi.Input[_builtins.str] type: Type
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer ID string
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IkeGatewayProtocolArgsDict(TypedDict):
        ikev1: NotRequired[pulumi.Input['IkeGatewayProtocolIkev1ArgsDict']]
        """
        Ikev1
        """
        ikev2: NotRequired[pulumi.Input['IkeGatewayProtocolIkev2ArgsDict']]
        """
        Ikev2
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version
        """
elif False:
    IkeGatewayProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolArgs:
    def __init__(__self__, *,
                 ikev1: Optional[pulumi.Input['IkeGatewayProtocolIkev1Args']] = None,
                 ikev2: Optional[pulumi.Input['IkeGatewayProtocolIkev2Args']] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['IkeGatewayProtocolIkev1Args'] ikev1: Ikev1
        :param pulumi.Input['IkeGatewayProtocolIkev2Args'] ikev2: Ikev2
        :param pulumi.Input[_builtins.str] version: Version
        """
        if ikev1 is not None:
            pulumi.set(__self__, "ikev1", ikev1)
        if ikev2 is not None:
            pulumi.set(__self__, "ikev2", ikev2)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def ikev1(self) -> Optional[pulumi.Input['IkeGatewayProtocolIkev1Args']]:
        """
        Ikev1
        """
        return pulumi.get(self, "ikev1")

    @ikev1.setter
    def ikev1(self, value: Optional[pulumi.Input['IkeGatewayProtocolIkev1Args']]):
        pulumi.set(self, "ikev1", value)

    @_builtins.property
    @pulumi.getter
    def ikev2(self) -> Optional[pulumi.Input['IkeGatewayProtocolIkev2Args']]:
        """
        Ikev2
        """
        return pulumi.get(self, "ikev2")

    @ikev2.setter
    def ikev2(self, value: Optional[pulumi.Input['IkeGatewayProtocolIkev2Args']]):
        pulumi.set(self, "ikev2", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class IkeGatewayProtocolCommonArgsDict(TypedDict):
        fragmentation: NotRequired[pulumi.Input['IkeGatewayProtocolCommonFragmentationArgsDict']]
        """
        Fragmentation
        """
        nat_traversal: NotRequired[pulumi.Input['IkeGatewayProtocolCommonNatTraversalArgsDict']]
        """
        Enables NAT traversal for the IKE gateway.
        """
        passive_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passive mode
        """
elif False:
    IkeGatewayProtocolCommonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolCommonArgs:
    def __init__(__self__, *,
                 fragmentation: Optional[pulumi.Input['IkeGatewayProtocolCommonFragmentationArgs']] = None,
                 nat_traversal: Optional[pulumi.Input['IkeGatewayProtocolCommonNatTraversalArgs']] = None,
                 passive_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['IkeGatewayProtocolCommonFragmentationArgs'] fragmentation: Fragmentation
        :param pulumi.Input['IkeGatewayProtocolCommonNatTraversalArgs'] nat_traversal: Enables NAT traversal for the IKE gateway.
        :param pulumi.Input[_builtins.bool] passive_mode: Passive mode
        """
        if fragmentation is not None:
            pulumi.set(__self__, "fragmentation", fragmentation)
        if nat_traversal is not None:
            pulumi.set(__self__, "nat_traversal", nat_traversal)
        if passive_mode is not None:
            pulumi.set(__self__, "passive_mode", passive_mode)

    @_builtins.property
    @pulumi.getter
    def fragmentation(self) -> Optional[pulumi.Input['IkeGatewayProtocolCommonFragmentationArgs']]:
        """
        Fragmentation
        """
        return pulumi.get(self, "fragmentation")

    @fragmentation.setter
    def fragmentation(self, value: Optional[pulumi.Input['IkeGatewayProtocolCommonFragmentationArgs']]):
        pulumi.set(self, "fragmentation", value)

    @_builtins.property
    @pulumi.getter(name="natTraversal")
    def nat_traversal(self) -> Optional[pulumi.Input['IkeGatewayProtocolCommonNatTraversalArgs']]:
        """
        Enables NAT traversal for the IKE gateway.
        """
        return pulumi.get(self, "nat_traversal")

    @nat_traversal.setter
    def nat_traversal(self, value: Optional[pulumi.Input['IkeGatewayProtocolCommonNatTraversalArgs']]):
        pulumi.set(self, "nat_traversal", value)

    @_builtins.property
    @pulumi.getter(name="passiveMode")
    def passive_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passive mode
        """
        return pulumi.get(self, "passive_mode")

    @passive_mode.setter
    def passive_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passive_mode", value)


if not MYPY:
    class IkeGatewayProtocolCommonFragmentationArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
elif False:
    IkeGatewayProtocolCommonFragmentationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolCommonFragmentationArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class IkeGatewayProtocolCommonNatTraversalArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
elif False:
    IkeGatewayProtocolCommonNatTraversalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolCommonNatTraversalArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class IkeGatewayProtocolIkev1ArgsDict(TypedDict):
        dpd: NotRequired[pulumi.Input['IkeGatewayProtocolIkev1DpdArgsDict']]
        """
        Dpd
        """
        ike_crypto_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ike crypto profile
        """
elif False:
    IkeGatewayProtocolIkev1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolIkev1Args:
    def __init__(__self__, *,
                 dpd: Optional[pulumi.Input['IkeGatewayProtocolIkev1DpdArgs']] = None,
                 ike_crypto_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['IkeGatewayProtocolIkev1DpdArgs'] dpd: Dpd
        :param pulumi.Input[_builtins.str] ike_crypto_profile: Ike crypto profile
        """
        if dpd is not None:
            pulumi.set(__self__, "dpd", dpd)
        if ike_crypto_profile is not None:
            pulumi.set(__self__, "ike_crypto_profile", ike_crypto_profile)

    @_builtins.property
    @pulumi.getter
    def dpd(self) -> Optional[pulumi.Input['IkeGatewayProtocolIkev1DpdArgs']]:
        """
        Dpd
        """
        return pulumi.get(self, "dpd")

    @dpd.setter
    def dpd(self, value: Optional[pulumi.Input['IkeGatewayProtocolIkev1DpdArgs']]):
        pulumi.set(self, "dpd", value)

    @_builtins.property
    @pulumi.getter(name="ikeCryptoProfile")
    def ike_crypto_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ike crypto profile
        """
        return pulumi.get(self, "ike_crypto_profile")

    @ike_crypto_profile.setter
    def ike_crypto_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ike_crypto_profile", value)


if not MYPY:
    class IkeGatewayProtocolIkev1DpdArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
elif False:
    IkeGatewayProtocolIkev1DpdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolIkev1DpdArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class IkeGatewayProtocolIkev2ArgsDict(TypedDict):
        dpd: NotRequired[pulumi.Input['IkeGatewayProtocolIkev2DpdArgsDict']]
        """
        Dpd
        """
        ike_crypto_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ike crypto profile
        """
elif False:
    IkeGatewayProtocolIkev2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolIkev2Args:
    def __init__(__self__, *,
                 dpd: Optional[pulumi.Input['IkeGatewayProtocolIkev2DpdArgs']] = None,
                 ike_crypto_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['IkeGatewayProtocolIkev2DpdArgs'] dpd: Dpd
        :param pulumi.Input[_builtins.str] ike_crypto_profile: Ike crypto profile
        """
        if dpd is not None:
            pulumi.set(__self__, "dpd", dpd)
        if ike_crypto_profile is not None:
            pulumi.set(__self__, "ike_crypto_profile", ike_crypto_profile)

    @_builtins.property
    @pulumi.getter
    def dpd(self) -> Optional[pulumi.Input['IkeGatewayProtocolIkev2DpdArgs']]:
        """
        Dpd
        """
        return pulumi.get(self, "dpd")

    @dpd.setter
    def dpd(self, value: Optional[pulumi.Input['IkeGatewayProtocolIkev2DpdArgs']]):
        pulumi.set(self, "dpd", value)

    @_builtins.property
    @pulumi.getter(name="ikeCryptoProfile")
    def ike_crypto_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ike crypto profile
        """
        return pulumi.get(self, "ike_crypto_profile")

    @ike_crypto_profile.setter
    def ike_crypto_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ike_crypto_profile", value)


if not MYPY:
    class IkeGatewayProtocolIkev2DpdArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
elif False:
    IkeGatewayProtocolIkev2DpdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IkeGatewayProtocolIkev2DpdArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class InterfaceManagementProfilePermittedIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The allowed IP address or CIDR block.
        """
elif False:
    InterfaceManagementProfilePermittedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterfaceManagementProfilePermittedIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The allowed IP address or CIDR block.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The allowed IP address or CIDR block.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IpsecCryptoProfileAhArgsDict(TypedDict):
        authentications: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Authentication
        """
elif False:
    IpsecCryptoProfileAhArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecCryptoProfileAhArgs:
    def __init__(__self__, *,
                 authentications: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] authentications: Authentication
        """
        pulumi.set(__self__, "authentications", authentications)

    @_builtins.property
    @pulumi.getter
    def authentications(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentications")

    @authentications.setter
    def authentications(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "authentications", value)


if not MYPY:
    class IpsecCryptoProfileEspArgsDict(TypedDict):
        authentications: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Authentication algorithm
        """
        encryptions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Encryption algorithm
        """
elif False:
    IpsecCryptoProfileEspArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecCryptoProfileEspArgs:
    def __init__(__self__, *,
                 authentications: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 encryptions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] authentications: Authentication algorithm
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] encryptions: Encryption algorithm
        """
        pulumi.set(__self__, "authentications", authentications)
        pulumi.set(__self__, "encryptions", encryptions)

    @_builtins.property
    @pulumi.getter
    def authentications(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Authentication algorithm
        """
        return pulumi.get(self, "authentications")

    @authentications.setter
    def authentications(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "authentications", value)

    @_builtins.property
    @pulumi.getter
    def encryptions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Encryption algorithm
        """
        return pulumi.get(self, "encryptions")

    @encryptions.setter
    def encryptions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "encryptions", value)


if not MYPY:
    class IpsecCryptoProfileLifesizeArgsDict(TypedDict):
        gb: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifesize in gigabytes(GB)
        """
        kb: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifesize in kilobytes(KB)

        >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
        mb: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifesize in megabytes(MB)

        >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
        tb: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifesize in terabytes(TB)

        >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
elif False:
    IpsecCryptoProfileLifesizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecCryptoProfileLifesizeArgs:
    def __init__(__self__, *,
                 gb: Optional[pulumi.Input[_builtins.int]] = None,
                 kb: Optional[pulumi.Input[_builtins.int]] = None,
                 mb: Optional[pulumi.Input[_builtins.int]] = None,
                 tb: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] gb: specify lifesize in gigabytes(GB)
        :param pulumi.Input[_builtins.int] kb: specify lifesize in kilobytes(KB)
               
               >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        :param pulumi.Input[_builtins.int] mb: specify lifesize in megabytes(MB)
               
               >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        :param pulumi.Input[_builtins.int] tb: specify lifesize in terabytes(TB)
               
               >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
        if gb is not None:
            pulumi.set(__self__, "gb", gb)
        if kb is not None:
            pulumi.set(__self__, "kb", kb)
        if mb is not None:
            pulumi.set(__self__, "mb", mb)
        if tb is not None:
            pulumi.set(__self__, "tb", tb)

    @_builtins.property
    @pulumi.getter
    def gb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifesize in gigabytes(GB)
        """
        return pulumi.get(self, "gb")

    @gb.setter
    def gb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gb", value)

    @_builtins.property
    @pulumi.getter
    def kb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifesize in kilobytes(KB)

        >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
        return pulumi.get(self, "kb")

    @kb.setter
    def kb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kb", value)

    @_builtins.property
    @pulumi.getter
    def mb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifesize in megabytes(MB)

        >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
        return pulumi.get(self, "mb")

    @mb.setter
    def mb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mb", value)

    @_builtins.property
    @pulumi.getter
    def tb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifesize in terabytes(TB)

        >  **Note:** You must specify exactly one of `gb`, `kb`, `mb`, and `tb`.
        """
        return pulumi.get(self, "tb")

    @tb.setter
    def tb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tb", value)


if not MYPY:
    class IpsecCryptoProfileLifetimeArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in days
        """
        hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in hours

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in minutes

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        specify lifetime in seconds

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
elif False:
    IpsecCryptoProfileLifetimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecCryptoProfileLifetimeArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 hours: Optional[pulumi.Input[_builtins.int]] = None,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: specify lifetime in days
        :param pulumi.Input[_builtins.int] hours: specify lifetime in hours
               
               >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        :param pulumi.Input[_builtins.int] minutes: specify lifetime in minutes
               
               >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        :param pulumi.Input[_builtins.int] seconds: specify lifetime in seconds
               
               >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in days
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in hours

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in minutes

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        specify lifetime in seconds

        >  **Note:** You must specify exactly one of `days`, `hours`, `minutes`, and `seconds`.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class IpsecTunnelAutoKeyArgsDict(TypedDict):
        ike_gateways: pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyIkeGatewayArgsDict']]]
        """
        Ike gateway
        """
        ipsec_crypto_profile: pulumi.Input[_builtins.str]
        """
        Ipsec crypto profile
        """
        proxy_id_v6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ArgsDict']]]]
        """
        IPv6 type of proxy*id values
        """
        proxy_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdArgsDict']]]]
        """
        IPv4 type of proxy*id values
        """
elif False:
    IpsecTunnelAutoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyArgs:
    def __init__(__self__, *,
                 ike_gateways: pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyIkeGatewayArgs']]],
                 ipsec_crypto_profile: pulumi.Input[_builtins.str],
                 proxy_id_v6s: Optional[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6Args']]]] = None,
                 proxy_ids: Optional[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyIkeGatewayArgs']]] ike_gateways: Ike gateway
        :param pulumi.Input[_builtins.str] ipsec_crypto_profile: Ipsec crypto profile
        :param pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6Args']]] proxy_id_v6s: IPv6 type of proxy*id values
        :param pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdArgs']]] proxy_ids: IPv4 type of proxy*id values
        """
        pulumi.set(__self__, "ike_gateways", ike_gateways)
        pulumi.set(__self__, "ipsec_crypto_profile", ipsec_crypto_profile)
        if proxy_id_v6s is not None:
            pulumi.set(__self__, "proxy_id_v6s", proxy_id_v6s)
        if proxy_ids is not None:
            pulumi.set(__self__, "proxy_ids", proxy_ids)

    @_builtins.property
    @pulumi.getter(name="ikeGateways")
    def ike_gateways(self) -> pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyIkeGatewayArgs']]]:
        """
        Ike gateway
        """
        return pulumi.get(self, "ike_gateways")

    @ike_gateways.setter
    def ike_gateways(self, value: pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyIkeGatewayArgs']]]):
        pulumi.set(self, "ike_gateways", value)

    @_builtins.property
    @pulumi.getter(name="ipsecCryptoProfile")
    def ipsec_crypto_profile(self) -> pulumi.Input[_builtins.str]:
        """
        Ipsec crypto profile
        """
        return pulumi.get(self, "ipsec_crypto_profile")

    @ipsec_crypto_profile.setter
    def ipsec_crypto_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipsec_crypto_profile", value)

    @_builtins.property
    @pulumi.getter(name="proxyIdV6s")
    def proxy_id_v6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6Args']]]]:
        """
        IPv6 type of proxy*id values
        """
        return pulumi.get(self, "proxy_id_v6s")

    @proxy_id_v6s.setter
    def proxy_id_v6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6Args']]]]):
        pulumi.set(self, "proxy_id_v6s", value)

    @_builtins.property
    @pulumi.getter(name="proxyIds")
    def proxy_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdArgs']]]]:
        """
        IPv4 type of proxy*id values
        """
        return pulumi.get(self, "proxy_ids")

    @proxy_ids.setter
    def proxy_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpsecTunnelAutoKeyProxyIdArgs']]]]):
        pulumi.set(self, "proxy_ids", value)


if not MYPY:
    class IpsecTunnelAutoKeyIkeGatewayArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    IpsecTunnelAutoKeyIkeGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyIkeGatewayArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        local: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local
        """
        protocol: NotRequired[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolArgsDict']]
        """
        IPv4 type of proxy*id protocol values for TCP protocol
        """
        remote: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remote
        """
elif False:
    IpsecTunnelAutoKeyProxyIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 local: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolArgs']] = None,
                 remote: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] local: Local
        :param pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolArgs'] protocol: IPv4 type of proxy*id protocol values for TCP protocol
        :param pulumi.Input[_builtins.str] remote: Remote
        """
        pulumi.set(__self__, "name", name)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if remote is not None:
            pulumi.set(__self__, "remote", remote)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolArgs']]:
        """
        IPv4 type of proxy*id protocol values for TCP protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolArgs']]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def remote(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remote
        """
        return pulumi.get(self, "remote")

    @remote.setter
    def remote(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdProtocolArgsDict(TypedDict):
        number: NotRequired[pulumi.Input[_builtins.int]]
        """
        IP protocol number
        """
        tcp: NotRequired[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolTcpArgsDict']]
        """
        IPv4 type of proxy_id protocol values for TCP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        udp: NotRequired[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolUdpArgsDict']]
        """
        IPv6 type of proxy_id protocol values for UDP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
elif False:
    IpsecTunnelAutoKeyProxyIdProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdProtocolArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[_builtins.int]] = None,
                 tcp: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolTcpArgs']] = None,
                 udp: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolUdpArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] number: IP protocol number
        :param pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolTcpArgs'] tcp: IPv4 type of proxy_id protocol values for TCP protocol
               
               >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        :param pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolUdpArgs'] udp: IPv6 type of proxy_id protocol values for UDP protocol
               
               >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        IP protocol number
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolTcpArgs']]:
        """
        IPv4 type of proxy_id protocol values for TCP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolUdpArgs']]:
        """
        IPv6 type of proxy_id protocol values for UDP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdProtocolUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdProtocolTcpArgsDict(TypedDict):
        local_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local port
        """
        remote_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remote port
        """
elif False:
    IpsecTunnelAutoKeyProxyIdProtocolTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdProtocolTcpArgs:
    def __init__(__self__, *,
                 local_port: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] local_port: Local port
        :param pulumi.Input[_builtins.int] remote_port: Remote port
        """
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local port
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remote port
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remote_port", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdProtocolUdpArgsDict(TypedDict):
        local_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local port
        """
        remote_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remote port
        """
elif False:
    IpsecTunnelAutoKeyProxyIdProtocolUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdProtocolUdpArgs:
    def __init__(__self__, *,
                 local_port: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] local_port: Local port
        :param pulumi.Input[_builtins.int] remote_port: Remote port
        """
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local port
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remote port
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remote_port", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdV6ArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        local: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local
        """
        protocol: NotRequired[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolArgsDict']]
        """
        IPv6 type of proxy*id protocol values for protocol
        """
        remote: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remote
        """
elif False:
    IpsecTunnelAutoKeyProxyIdV6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdV6Args:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 local: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolArgs']] = None,
                 remote: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] local: Local
        :param pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolArgs'] protocol: IPv6 type of proxy*id protocol values for protocol
        :param pulumi.Input[_builtins.str] remote: Remote
        """
        pulumi.set(__self__, "name", name)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if remote is not None:
            pulumi.set(__self__, "remote", remote)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolArgs']]:
        """
        IPv6 type of proxy*id protocol values for protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolArgs']]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def remote(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remote
        """
        return pulumi.get(self, "remote")

    @remote.setter
    def remote(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdV6ProtocolArgsDict(TypedDict):
        number: NotRequired[pulumi.Input[_builtins.int]]
        """
        IP protocol number
        """
        tcp: NotRequired[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgsDict']]
        """
        IPv6 type of proxy_id protocol values for TCP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        udp: NotRequired[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgsDict']]
        """
        IPv6 type of proxy_id protocol values for UDP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
elif False:
    IpsecTunnelAutoKeyProxyIdV6ProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdV6ProtocolArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[_builtins.int]] = None,
                 tcp: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgs']] = None,
                 udp: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] number: IP protocol number
        :param pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgs'] tcp: IPv6 type of proxy_id protocol values for TCP protocol
               
               >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        :param pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgs'] udp: IPv6 type of proxy_id protocol values for UDP protocol
               
               >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        IP protocol number
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgs']]:
        """
        IPv6 type of proxy_id protocol values for TCP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgs']]:
        """
        IPv6 type of proxy_id protocol values for UDP protocol

        >  **Note:** You must specify exactly one of `number`, `tcp`, and `udp`.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgsDict(TypedDict):
        local_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local port
        """
        remote_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remote port
        """
elif False:
    IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdV6ProtocolTcpArgs:
    def __init__(__self__, *,
                 local_port: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] local_port: Local port
        :param pulumi.Input[_builtins.int] remote_port: Remote port
        """
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local port
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remote port
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remote_port", value)


if not MYPY:
    class IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgsDict(TypedDict):
        local_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local port
        """
        remote_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remote port
        """
elif False:
    IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelAutoKeyProxyIdV6ProtocolUdpArgs:
    def __init__(__self__, *,
                 local_port: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] local_port: Local port
        :param pulumi.Input[_builtins.int] remote_port: Remote port
        """
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local port
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_port", value)

    @_builtins.property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remote port
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remote_port", value)


if not MYPY:
    class IpsecTunnelTunnelMonitorArgsDict(TypedDict):
        destination_ip: pulumi.Input[_builtins.str]
        """
        Destination IP to send ICMP probe
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable tunnel monitoring on this tunnel
        """
        proxy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Which proxy-id (or proxy-id-v6) the monitoring traffic will use
        """
elif False:
    IpsecTunnelTunnelMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpsecTunnelTunnelMonitorArgs:
    def __init__(__self__, *,
                 destination_ip: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 proxy_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_ip: Destination IP to send ICMP probe
        :param pulumi.Input[_builtins.bool] enable: Enable tunnel monitoring on this tunnel
        :param pulumi.Input[_builtins.str] proxy_id: Which proxy-id (or proxy-id-v6) the monitoring traffic will use
        """
        pulumi.set(__self__, "destination_ip", destination_ip)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if proxy_id is not None:
            pulumi.set(__self__, "proxy_id", proxy_id)

    @_builtins.property
    @pulumi.getter(name="destinationIp")
    def destination_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Destination IP to send ICMP probe
        """
        return pulumi.get(self, "destination_ip")

    @destination_ip.setter
    def destination_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_ip", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable tunnel monitoring on this tunnel
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Which proxy-id (or proxy-id-v6) the monitoring traffic will use
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_id", value)


if not MYPY:
    class KerberosServerProfileServerArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        The Kerberos server IP address
        """
        name: pulumi.Input[_builtins.str]
        """
        The Kerberos server name
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Kerberos server port
        """
elif False:
    KerberosServerProfileServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KerberosServerProfileServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The Kerberos server IP address
        :param pulumi.Input[_builtins.str] name: The Kerberos server name
        :param pulumi.Input[_builtins.int] port: The Kerberos server port
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The Kerberos server IP address
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The Kerberos server name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Kerberos server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class Layer3SubinterfaceArpArgsDict(TypedDict):
        hw_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
elif False:
    Layer3SubinterfaceArpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Layer3SubinterfaceArpArgs:
    def __init__(__self__, *,
                 hw_address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hw_address: MAC address
        :param pulumi.Input[_builtins.str] name: IP address
        """
        if hw_address is not None:
            pulumi.set(__self__, "hw_address", hw_address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="hwAddress")
    def hw_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address
        """
        return pulumi.get(self, "hw_address")

    @hw_address.setter
    def hw_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hw_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class Layer3SubinterfaceDdnsConfigArgsDict(TypedDict):
        ddns_cert_profile: pulumi.Input[_builtins.str]
        """
        Certificate profile
        """
        ddns_hostname: pulumi.Input[_builtins.str]
        """
        Ddns hostname
        """
        ddns_vendor: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_vendor_config: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DDNS?
        """
        ddns_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP to register (static only)
        """
        ddns_update_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Update interval (days)
        """
elif False:
    Layer3SubinterfaceDdnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Layer3SubinterfaceDdnsConfigArgs:
    def __init__(__self__, *,
                 ddns_cert_profile: pulumi.Input[_builtins.str],
                 ddns_hostname: pulumi.Input[_builtins.str],
                 ddns_vendor: pulumi.Input[_builtins.str],
                 ddns_vendor_config: pulumi.Input[_builtins.str],
                 ddns_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ddns_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ddns_update_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ddns_cert_profile: Certificate profile
        :param pulumi.Input[_builtins.str] ddns_hostname: Ddns hostname
        :param pulumi.Input[_builtins.str] ddns_vendor: DDNS vendor
        :param pulumi.Input[_builtins.str] ddns_vendor_config: DDNS vendor
        :param pulumi.Input[_builtins.bool] ddns_enabled: Enable DDNS?
        :param pulumi.Input[_builtins.str] ddns_ip: IP to register (static only)
        :param pulumi.Input[_builtins.int] ddns_update_interval: Update interval (days)
        """
        pulumi.set(__self__, "ddns_cert_profile", ddns_cert_profile)
        pulumi.set(__self__, "ddns_hostname", ddns_hostname)
        pulumi.set(__self__, "ddns_vendor", ddns_vendor)
        pulumi.set(__self__, "ddns_vendor_config", ddns_vendor_config)
        if ddns_enabled is not None:
            pulumi.set(__self__, "ddns_enabled", ddns_enabled)
        if ddns_ip is not None:
            pulumi.set(__self__, "ddns_ip", ddns_ip)
        if ddns_update_interval is not None:
            pulumi.set(__self__, "ddns_update_interval", ddns_update_interval)

    @_builtins.property
    @pulumi.getter(name="ddnsCertProfile")
    def ddns_cert_profile(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate profile
        """
        return pulumi.get(self, "ddns_cert_profile")

    @ddns_cert_profile.setter
    def ddns_cert_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_cert_profile", value)

    @_builtins.property
    @pulumi.getter(name="ddnsHostname")
    def ddns_hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Ddns hostname
        """
        return pulumi.get(self, "ddns_hostname")

    @ddns_hostname.setter
    def ddns_hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_hostname", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendor")
    def ddns_vendor(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor")

    @ddns_vendor.setter
    def ddns_vendor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendorConfig")
    def ddns_vendor_config(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor_config")

    @ddns_vendor_config.setter
    def ddns_vendor_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor_config", value)

    @_builtins.property
    @pulumi.getter(name="ddnsEnabled")
    def ddns_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DDNS?
        """
        return pulumi.get(self, "ddns_enabled")

    @ddns_enabled.setter
    def ddns_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ddns_enabled", value)

    @_builtins.property
    @pulumi.getter(name="ddnsIp")
    def ddns_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP to register (static only)
        """
        return pulumi.get(self, "ddns_ip")

    @ddns_ip.setter
    def ddns_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddns_ip", value)

    @_builtins.property
    @pulumi.getter(name="ddnsUpdateInterval")
    def ddns_update_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Update interval (days)
        """
        return pulumi.get(self, "ddns_update_interval")

    @ddns_update_interval.setter
    def ddns_update_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ddns_update_interval", value)


if not MYPY:
    class Layer3SubinterfaceDhcpClientArgsDict(TypedDict):
        create_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically create default route pointing to default gateway provided by server
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric of the default route created
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DHCP?
        """
        send_hostname: NotRequired[pulumi.Input['Layer3SubinterfaceDhcpClientSendHostnameArgsDict']]
        """
        Layer3 sub interfaces DHCP Client Send hostname
        """
elif False:
    Layer3SubinterfaceDhcpClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Layer3SubinterfaceDhcpClientArgs:
    def __init__(__self__, *,
                 create_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_hostname: Optional[pulumi.Input['Layer3SubinterfaceDhcpClientSendHostnameArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] create_default_route: Automatically create default route pointing to default gateway provided by server
        :param pulumi.Input[_builtins.int] default_route_metric: Metric of the default route created
        :param pulumi.Input[_builtins.bool] enable: Enable DHCP?
        :param pulumi.Input['Layer3SubinterfaceDhcpClientSendHostnameArgs'] send_hostname: Layer3 sub interfaces DHCP Client Send hostname
        """
        if create_default_route is not None:
            pulumi.set(__self__, "create_default_route", create_default_route)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if send_hostname is not None:
            pulumi.set(__self__, "send_hostname", send_hostname)

    @_builtins.property
    @pulumi.getter(name="createDefaultRoute")
    def create_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically create default route pointing to default gateway provided by server
        """
        return pulumi.get(self, "create_default_route")

    @create_default_route.setter
    def create_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_default_route", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric of the default route created
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DHCP?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="sendHostname")
    def send_hostname(self) -> Optional[pulumi.Input['Layer3SubinterfaceDhcpClientSendHostnameArgs']]:
        """
        Layer3 sub interfaces DHCP Client Send hostname
        """
        return pulumi.get(self, "send_hostname")

    @send_hostname.setter
    def send_hostname(self, value: Optional[pulumi.Input['Layer3SubinterfaceDhcpClientSendHostnameArgs']]):
        pulumi.set(self, "send_hostname", value)


if not MYPY:
    class Layer3SubinterfaceDhcpClientSendHostnameArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set interface hostname
        """
elif False:
    Layer3SubinterfaceDhcpClientSendHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Layer3SubinterfaceDhcpClientSendHostnameArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] hostname: Set interface hostname
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set interface hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class Layer3SubinterfaceIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        L3 sub-interface IP address(es)
        """
elif False:
    Layer3SubinterfaceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Layer3SubinterfaceIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: L3 sub-interface IP address(es)
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        L3 sub-interface IP address(es)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LdapServerProfileServerArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LDAP server IP address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LDAP server name
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The LDAP server port
        """
elif False:
    LdapServerProfileServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LdapServerProfileServerArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The LDAP server IP address
        :param pulumi.Input[_builtins.str] name: The LDAP server name
        :param pulumi.Input[_builtins.int] port: The LDAP server port
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LDAP server IP address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LDAP server name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The LDAP server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class LldpProfileOptionTlvsArgsDict(TypedDict):
        management_address: NotRequired[pulumi.Input['LldpProfileOptionTlvsManagementAddressArgsDict']]
        """
        Management address
        """
        port_description: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Option TLV Port Description
        """
        system_capabilities: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Option TLV System Capabilities
        """
        system_description: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Option TLV System Description
        """
        system_name: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Option TLV System Name
        """
elif False:
    LldpProfileOptionTlvsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LldpProfileOptionTlvsArgs:
    def __init__(__self__, *,
                 management_address: Optional[pulumi.Input['LldpProfileOptionTlvsManagementAddressArgs']] = None,
                 port_description: Optional[pulumi.Input[_builtins.bool]] = None,
                 system_capabilities: Optional[pulumi.Input[_builtins.bool]] = None,
                 system_description: Optional[pulumi.Input[_builtins.bool]] = None,
                 system_name: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['LldpProfileOptionTlvsManagementAddressArgs'] management_address: Management address
        :param pulumi.Input[_builtins.bool] port_description: Option TLV Port Description
        :param pulumi.Input[_builtins.bool] system_capabilities: Option TLV System Capabilities
        :param pulumi.Input[_builtins.bool] system_description: Option TLV System Description
        :param pulumi.Input[_builtins.bool] system_name: Option TLV System Name
        """
        if management_address is not None:
            pulumi.set(__self__, "management_address", management_address)
        if port_description is not None:
            pulumi.set(__self__, "port_description", port_description)
        if system_capabilities is not None:
            pulumi.set(__self__, "system_capabilities", system_capabilities)
        if system_description is not None:
            pulumi.set(__self__, "system_description", system_description)
        if system_name is not None:
            pulumi.set(__self__, "system_name", system_name)

    @_builtins.property
    @pulumi.getter(name="managementAddress")
    def management_address(self) -> Optional[pulumi.Input['LldpProfileOptionTlvsManagementAddressArgs']]:
        """
        Management address
        """
        return pulumi.get(self, "management_address")

    @management_address.setter
    def management_address(self, value: Optional[pulumi.Input['LldpProfileOptionTlvsManagementAddressArgs']]):
        pulumi.set(self, "management_address", value)

    @_builtins.property
    @pulumi.getter(name="portDescription")
    def port_description(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Option TLV Port Description
        """
        return pulumi.get(self, "port_description")

    @port_description.setter
    def port_description(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_description", value)

    @_builtins.property
    @pulumi.getter(name="systemCapabilities")
    def system_capabilities(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Option TLV System Capabilities
        """
        return pulumi.get(self, "system_capabilities")

    @system_capabilities.setter
    def system_capabilities(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "system_capabilities", value)

    @_builtins.property
    @pulumi.getter(name="systemDescription")
    def system_description(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Option TLV System Description
        """
        return pulumi.get(self, "system_description")

    @system_description.setter
    def system_description(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "system_description", value)

    @_builtins.property
    @pulumi.getter(name="systemName")
    def system_name(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Option TLV System Name
        """
        return pulumi.get(self, "system_name")

    @system_name.setter
    def system_name(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "system_name", value)


if not MYPY:
    class LldpProfileOptionTlvsManagementAddressArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Management address enabled
        """
        iplists: NotRequired[pulumi.Input[Sequence[pulumi.Input['LldpProfileOptionTlvsManagementAddressIplistArgsDict']]]]
        """
        Iplist
        """
elif False:
    LldpProfileOptionTlvsManagementAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LldpProfileOptionTlvsManagementAddressArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 iplists: Optional[pulumi.Input[Sequence[pulumi.Input['LldpProfileOptionTlvsManagementAddressIplistArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Management address enabled
        :param pulumi.Input[Sequence[pulumi.Input['LldpProfileOptionTlvsManagementAddressIplistArgs']]] iplists: Iplist
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if iplists is not None:
            pulumi.set(__self__, "iplists", iplists)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Management address enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def iplists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LldpProfileOptionTlvsManagementAddressIplistArgs']]]]:
        """
        Iplist
        """
        return pulumi.get(self, "iplists")

    @iplists.setter
    def iplists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LldpProfileOptionTlvsManagementAddressIplistArgs']]]]):
        pulumi.set(self, "iplists", value)


if not MYPY:
    class LldpProfileOptionTlvsManagementAddressIplistArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 Address
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 Address
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    LldpProfileOptionTlvsManagementAddressIplistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LldpProfileOptionTlvsManagementAddressIplistArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.str] ipv4: IPv4 Address
        :param pulumi.Input[_builtins.str] ipv6: IPv6 Address
        :param pulumi.Input[_builtins.str] name: Name
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 Address
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 Address
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LogForwardingProfileMatchListArgsDict(TypedDict):
        filter: pulumi.Input[_builtins.str]
        """
        Filter match criteria
        """
        log_type: pulumi.Input[_builtins.str]
        """
        Log type
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the match profile
        """
        action_desc: NotRequired[pulumi.Input[_builtins.str]]
        """
        Match profile description
        """
        send_emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of email server profiles
        """
        send_https: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP server profiles
        """
        send_snmptraps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of SNMP server profiles
        """
        send_syslogs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of syslog server profiles
        """
elif False:
    LogForwardingProfileMatchListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogForwardingProfileMatchListArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[_builtins.str],
                 log_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 action_desc: Optional[pulumi.Input[_builtins.str]] = None,
                 send_emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 send_https: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 send_snmptraps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 send_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] filter: Filter match criteria
        :param pulumi.Input[_builtins.str] log_type: Log type
        :param pulumi.Input[_builtins.str] name: Name of the match profile
        :param pulumi.Input[_builtins.str] action_desc: Match profile description
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] send_emails: A list of email server profiles
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] send_https: A list of HTTP server profiles
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] send_snmptraps: A list of SNMP server profiles
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] send_syslogs: A list of syslog server profiles
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "log_type", log_type)
        pulumi.set(__self__, "name", name)
        if action_desc is not None:
            pulumi.set(__self__, "action_desc", action_desc)
        if send_emails is not None:
            pulumi.set(__self__, "send_emails", send_emails)
        if send_https is not None:
            pulumi.set(__self__, "send_https", send_https)
        if send_snmptraps is not None:
            pulumi.set(__self__, "send_snmptraps", send_snmptraps)
        if send_syslogs is not None:
            pulumi.set(__self__, "send_syslogs", send_syslogs)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> pulumi.Input[_builtins.str]:
        """
        Filter match criteria
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[_builtins.str]:
        """
        Log type
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the match profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="actionDesc")
    def action_desc(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Match profile description
        """
        return pulumi.get(self, "action_desc")

    @action_desc.setter
    def action_desc(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_desc", value)

    @_builtins.property
    @pulumi.getter(name="sendEmails")
    def send_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of email server profiles
        """
        return pulumi.get(self, "send_emails")

    @send_emails.setter
    def send_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "send_emails", value)

    @_builtins.property
    @pulumi.getter(name="sendHttps")
    def send_https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP server profiles
        """
        return pulumi.get(self, "send_https")

    @send_https.setter
    def send_https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "send_https", value)

    @_builtins.property
    @pulumi.getter(name="sendSnmptraps")
    def send_snmptraps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of SNMP server profiles
        """
        return pulumi.get(self, "send_snmptraps")

    @send_snmptraps.setter
    def send_snmptraps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "send_snmptraps", value)

    @_builtins.property
    @pulumi.getter(name="sendSyslogs")
    def send_syslogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of syslog server profiles
        """
        return pulumi.get(self, "send_syslogs")

    @send_syslogs.setter
    def send_syslogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "send_syslogs", value)


if not MYPY:
    class LogicalRouterVrfArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        admin_dists: NotRequired[pulumi.Input['LogicalRouterVrfAdminDistsArgsDict']]
        """
        Admin dists
        """
        bgp: NotRequired[pulumi.Input['LogicalRouterVrfBgpArgsDict']]
        """
        Bgp
        """
        ecmp: NotRequired[pulumi.Input['LogicalRouterVrfEcmpArgsDict']]
        """
        Ecmp
        """
        global_vrid: NotRequired[pulumi.Input[_builtins.int]]
        """
        Global vrid
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Interface
        """
        multicast: NotRequired[pulumi.Input['LogicalRouterVrfMulticastArgsDict']]
        """
        Multicast
        """
        ospf: NotRequired[pulumi.Input['LogicalRouterVrfOspfArgsDict']]
        """
        Ospf
        """
        ospfv3: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3ArgsDict']]
        """
        Ospfv3
        """
        rib_filter: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterArgsDict']]
        """
        Rib filter
        """
        rip: NotRequired[pulumi.Input['LogicalRouterVrfRipArgsDict']]
        """
        Rip
        """
        routing_table: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableArgsDict']]
        """
        Routing table
        """
        sdwan_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sdwan type
        """
        vr_admin_dists: NotRequired[pulumi.Input['LogicalRouterVrfVrAdminDistsArgsDict']]
        """
        Vr admin dists
        """
        zone_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Zone name
        """
elif False:
    LogicalRouterVrfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 admin_dists: Optional[pulumi.Input['LogicalRouterVrfAdminDistsArgs']] = None,
                 bgp: Optional[pulumi.Input['LogicalRouterVrfBgpArgs']] = None,
                 ecmp: Optional[pulumi.Input['LogicalRouterVrfEcmpArgs']] = None,
                 global_vrid: Optional[pulumi.Input[_builtins.int]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 multicast: Optional[pulumi.Input['LogicalRouterVrfMulticastArgs']] = None,
                 ospf: Optional[pulumi.Input['LogicalRouterVrfOspfArgs']] = None,
                 ospfv3: Optional[pulumi.Input['LogicalRouterVrfOspfv3Args']] = None,
                 rib_filter: Optional[pulumi.Input['LogicalRouterVrfRibFilterArgs']] = None,
                 rip: Optional[pulumi.Input['LogicalRouterVrfRipArgs']] = None,
                 routing_table: Optional[pulumi.Input['LogicalRouterVrfRoutingTableArgs']] = None,
                 sdwan_type: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_admin_dists: Optional[pulumi.Input['LogicalRouterVrfVrAdminDistsArgs']] = None,
                 zone_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfAdminDistsArgs'] admin_dists: Admin dists
        :param pulumi.Input['LogicalRouterVrfBgpArgs'] bgp: Bgp
        :param pulumi.Input['LogicalRouterVrfEcmpArgs'] ecmp: Ecmp
        :param pulumi.Input[_builtins.int] global_vrid: Global vrid
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interfaces: Interface
        :param pulumi.Input['LogicalRouterVrfMulticastArgs'] multicast: Multicast
        :param pulumi.Input['LogicalRouterVrfOspfArgs'] ospf: Ospf
        :param pulumi.Input['LogicalRouterVrfOspfv3Args'] ospfv3: Ospfv3
        :param pulumi.Input['LogicalRouterVrfRibFilterArgs'] rib_filter: Rib filter
        :param pulumi.Input['LogicalRouterVrfRipArgs'] rip: Rip
        :param pulumi.Input['LogicalRouterVrfRoutingTableArgs'] routing_table: Routing table
        :param pulumi.Input[_builtins.str] sdwan_type: Sdwan type
        :param pulumi.Input['LogicalRouterVrfVrAdminDistsArgs'] vr_admin_dists: Vr admin dists
        :param pulumi.Input[_builtins.str] zone_name: Zone name
        """
        pulumi.set(__self__, "name", name)
        if admin_dists is not None:
            pulumi.set(__self__, "admin_dists", admin_dists)
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if ecmp is not None:
            pulumi.set(__self__, "ecmp", ecmp)
        if global_vrid is not None:
            pulumi.set(__self__, "global_vrid", global_vrid)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if ospf is not None:
            pulumi.set(__self__, "ospf", ospf)
        if ospfv3 is not None:
            pulumi.set(__self__, "ospfv3", ospfv3)
        if rib_filter is not None:
            pulumi.set(__self__, "rib_filter", rib_filter)
        if rip is not None:
            pulumi.set(__self__, "rip", rip)
        if routing_table is not None:
            pulumi.set(__self__, "routing_table", routing_table)
        if sdwan_type is not None:
            pulumi.set(__self__, "sdwan_type", sdwan_type)
        if vr_admin_dists is not None:
            pulumi.set(__self__, "vr_admin_dists", vr_admin_dists)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="adminDists")
    def admin_dists(self) -> Optional[pulumi.Input['LogicalRouterVrfAdminDistsArgs']]:
        """
        Admin dists
        """
        return pulumi.get(self, "admin_dists")

    @admin_dists.setter
    def admin_dists(self, value: Optional[pulumi.Input['LogicalRouterVrfAdminDistsArgs']]):
        pulumi.set(self, "admin_dists", value)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpArgs']]:
        """
        Bgp
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpArgs']]):
        pulumi.set(self, "bgp", value)

    @_builtins.property
    @pulumi.getter
    def ecmp(self) -> Optional[pulumi.Input['LogicalRouterVrfEcmpArgs']]:
        """
        Ecmp
        """
        return pulumi.get(self, "ecmp")

    @ecmp.setter
    def ecmp(self, value: Optional[pulumi.Input['LogicalRouterVrfEcmpArgs']]):
        pulumi.set(self, "ecmp", value)

    @_builtins.property
    @pulumi.getter(name="globalVrid")
    def global_vrid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Global vrid
        """
        return pulumi.get(self, "global_vrid")

    @global_vrid.setter
    def global_vrid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "global_vrid", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastArgs']]:
        """
        Multicast
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter
    def ospf(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfArgs']]:
        """
        Ospf
        """
        return pulumi.get(self, "ospf")

    @ospf.setter
    def ospf(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfArgs']]):
        pulumi.set(self, "ospf", value)

    @_builtins.property
    @pulumi.getter
    def ospfv3(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3Args']]:
        """
        Ospfv3
        """
        return pulumi.get(self, "ospfv3")

    @ospfv3.setter
    def ospfv3(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3Args']]):
        pulumi.set(self, "ospfv3", value)

    @_builtins.property
    @pulumi.getter(name="ribFilter")
    def rib_filter(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterArgs']]:
        """
        Rib filter
        """
        return pulumi.get(self, "rib_filter")

    @rib_filter.setter
    def rib_filter(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterArgs']]):
        pulumi.set(self, "rib_filter", value)

    @_builtins.property
    @pulumi.getter
    def rip(self) -> Optional[pulumi.Input['LogicalRouterVrfRipArgs']]:
        """
        Rip
        """
        return pulumi.get(self, "rip")

    @rip.setter
    def rip(self, value: Optional[pulumi.Input['LogicalRouterVrfRipArgs']]):
        pulumi.set(self, "rip", value)

    @_builtins.property
    @pulumi.getter(name="routingTable")
    def routing_table(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableArgs']]:
        """
        Routing table
        """
        return pulumi.get(self, "routing_table")

    @routing_table.setter
    def routing_table(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableArgs']]):
        pulumi.set(self, "routing_table", value)

    @_builtins.property
    @pulumi.getter(name="sdwanType")
    def sdwan_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sdwan type
        """
        return pulumi.get(self, "sdwan_type")

    @sdwan_type.setter
    def sdwan_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sdwan_type", value)

    @_builtins.property
    @pulumi.getter(name="vrAdminDists")
    def vr_admin_dists(self) -> Optional[pulumi.Input['LogicalRouterVrfVrAdminDistsArgs']]:
        """
        Vr admin dists
        """
        return pulumi.get(self, "vr_admin_dists")

    @vr_admin_dists.setter
    def vr_admin_dists(self, value: Optional[pulumi.Input['LogicalRouterVrfVrAdminDistsArgs']]):
        pulumi.set(self, "vr_admin_dists", value)

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Zone name
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class LogicalRouterVrfAdminDistsArgsDict(TypedDict):
        bgp_external: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bgp external
        """
        bgp_internal: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bgp internal
        """
        bgp_local: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bgp local
        """
        ospf_ext: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospf ext
        """
        ospf_inter: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospf inter
        """
        ospf_intra: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospf intra
        """
        ospfv3_ext: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospfv3 ext
        """
        ospfv3_inter: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospfv3 inter
        """
        ospfv3_intra: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospfv3 intra
        """
        rip: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rip
        """
        static: NotRequired[pulumi.Input[_builtins.int]]
        """
        Static
        """
        static_ipv6: NotRequired[pulumi.Input[_builtins.int]]
        """
        Static ipv6
        """
elif False:
    LogicalRouterVrfAdminDistsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfAdminDistsArgs:
    def __init__(__self__, *,
                 bgp_external: Optional[pulumi.Input[_builtins.int]] = None,
                 bgp_internal: Optional[pulumi.Input[_builtins.int]] = None,
                 bgp_local: Optional[pulumi.Input[_builtins.int]] = None,
                 ospf_ext: Optional[pulumi.Input[_builtins.int]] = None,
                 ospf_inter: Optional[pulumi.Input[_builtins.int]] = None,
                 ospf_intra: Optional[pulumi.Input[_builtins.int]] = None,
                 ospfv3_ext: Optional[pulumi.Input[_builtins.int]] = None,
                 ospfv3_inter: Optional[pulumi.Input[_builtins.int]] = None,
                 ospfv3_intra: Optional[pulumi.Input[_builtins.int]] = None,
                 rip: Optional[pulumi.Input[_builtins.int]] = None,
                 static: Optional[pulumi.Input[_builtins.int]] = None,
                 static_ipv6: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] bgp_external: Bgp external
        :param pulumi.Input[_builtins.int] bgp_internal: Bgp internal
        :param pulumi.Input[_builtins.int] bgp_local: Bgp local
        :param pulumi.Input[_builtins.int] ospf_ext: Ospf ext
        :param pulumi.Input[_builtins.int] ospf_inter: Ospf inter
        :param pulumi.Input[_builtins.int] ospf_intra: Ospf intra
        :param pulumi.Input[_builtins.int] ospfv3_ext: Ospfv3 ext
        :param pulumi.Input[_builtins.int] ospfv3_inter: Ospfv3 inter
        :param pulumi.Input[_builtins.int] ospfv3_intra: Ospfv3 intra
        :param pulumi.Input[_builtins.int] rip: Rip
        :param pulumi.Input[_builtins.int] static: Static
        :param pulumi.Input[_builtins.int] static_ipv6: Static ipv6
        """
        if bgp_external is not None:
            pulumi.set(__self__, "bgp_external", bgp_external)
        if bgp_internal is not None:
            pulumi.set(__self__, "bgp_internal", bgp_internal)
        if bgp_local is not None:
            pulumi.set(__self__, "bgp_local", bgp_local)
        if ospf_ext is not None:
            pulumi.set(__self__, "ospf_ext", ospf_ext)
        if ospf_inter is not None:
            pulumi.set(__self__, "ospf_inter", ospf_inter)
        if ospf_intra is not None:
            pulumi.set(__self__, "ospf_intra", ospf_intra)
        if ospfv3_ext is not None:
            pulumi.set(__self__, "ospfv3_ext", ospfv3_ext)
        if ospfv3_inter is not None:
            pulumi.set(__self__, "ospfv3_inter", ospfv3_inter)
        if ospfv3_intra is not None:
            pulumi.set(__self__, "ospfv3_intra", ospfv3_intra)
        if rip is not None:
            pulumi.set(__self__, "rip", rip)
        if static is not None:
            pulumi.set(__self__, "static", static)
        if static_ipv6 is not None:
            pulumi.set(__self__, "static_ipv6", static_ipv6)

    @_builtins.property
    @pulumi.getter(name="bgpExternal")
    def bgp_external(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bgp external
        """
        return pulumi.get(self, "bgp_external")

    @bgp_external.setter
    def bgp_external(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bgp_external", value)

    @_builtins.property
    @pulumi.getter(name="bgpInternal")
    def bgp_internal(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bgp internal
        """
        return pulumi.get(self, "bgp_internal")

    @bgp_internal.setter
    def bgp_internal(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bgp_internal", value)

    @_builtins.property
    @pulumi.getter(name="bgpLocal")
    def bgp_local(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bgp local
        """
        return pulumi.get(self, "bgp_local")

    @bgp_local.setter
    def bgp_local(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bgp_local", value)

    @_builtins.property
    @pulumi.getter(name="ospfExt")
    def ospf_ext(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospf ext
        """
        return pulumi.get(self, "ospf_ext")

    @ospf_ext.setter
    def ospf_ext(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospf_ext", value)

    @_builtins.property
    @pulumi.getter(name="ospfInter")
    def ospf_inter(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospf inter
        """
        return pulumi.get(self, "ospf_inter")

    @ospf_inter.setter
    def ospf_inter(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospf_inter", value)

    @_builtins.property
    @pulumi.getter(name="ospfIntra")
    def ospf_intra(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospf intra
        """
        return pulumi.get(self, "ospf_intra")

    @ospf_intra.setter
    def ospf_intra(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospf_intra", value)

    @_builtins.property
    @pulumi.getter(name="ospfv3Ext")
    def ospfv3_ext(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospfv3 ext
        """
        return pulumi.get(self, "ospfv3_ext")

    @ospfv3_ext.setter
    def ospfv3_ext(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospfv3_ext", value)

    @_builtins.property
    @pulumi.getter(name="ospfv3Inter")
    def ospfv3_inter(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospfv3 inter
        """
        return pulumi.get(self, "ospfv3_inter")

    @ospfv3_inter.setter
    def ospfv3_inter(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospfv3_inter", value)

    @_builtins.property
    @pulumi.getter(name="ospfv3Intra")
    def ospfv3_intra(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospfv3 intra
        """
        return pulumi.get(self, "ospfv3_intra")

    @ospfv3_intra.setter
    def ospfv3_intra(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospfv3_intra", value)

    @_builtins.property
    @pulumi.getter
    def rip(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rip
        """
        return pulumi.get(self, "rip")

    @rip.setter
    def rip(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rip", value)

    @_builtins.property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Static
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "static", value)

    @_builtins.property
    @pulumi.getter(name="staticIpv6")
    def static_ipv6(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Static ipv6
        """
        return pulumi.get(self, "static_ipv6")

    @static_ipv6.setter
    def static_ipv6(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "static_ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpArgsDict(TypedDict):
        advertise_network: NotRequired[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkArgsDict']]
        """
        Advertise network
        """
        aggregate: NotRequired[pulumi.Input['LogicalRouterVrfBgpAggregateArgsDict']]
        """
        Aggregate
        """
        aggregate_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAggregateRouteArgsDict']]]]
        """
        Aggregate routes
        """
        allow_redist_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow redist default route
        """
        always_advertise_network_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Always advertise network route
        """
        as_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        As format
        """
        confederation_member_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        Confederation member as
        """
        default_local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Default local preference
        """
        ecmp_multi_as: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Ecmp multi as
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        enforce_first_as: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enforce first as
        """
        fast_external_failover: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Fast external failover
        """
        global_bfd: NotRequired[pulumi.Input['LogicalRouterVrfBgpGlobalBfdArgsDict']]
        """
        Global bfd
        """
        graceful_restart: NotRequired[pulumi.Input['LogicalRouterVrfBgpGracefulRestartArgsDict']]
        """
        Graceful restart
        """
        graceful_shutdown: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Graceful shutdown
        """
        install_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Install route
        """
        local_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local as
        """
        med: NotRequired[pulumi.Input['LogicalRouterVrfBgpMedArgsDict']]
        """
        Med
        """
        peer_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupArgsDict']]]]
        """
        Peer group
        """
        policy: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyArgsDict']]
        """
        Policy
        """
        redist_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpRedistRuleArgsDict']]]]
        """
        Redist rules
        """
        redistribution_profile: NotRequired[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileArgsDict']]
        """
        Redistribution profile
        """
        reject_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reject default route
        """
        router_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Router id
        """
elif False:
    LogicalRouterVrfBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpArgs:
    def __init__(__self__, *,
                 advertise_network: Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkArgs']] = None,
                 aggregate: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateArgs']] = None,
                 aggregate_routes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAggregateRouteArgs']]]] = None,
                 allow_redist_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 always_advertise_network_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 as_format: Optional[pulumi.Input[_builtins.str]] = None,
                 confederation_member_as: Optional[pulumi.Input[_builtins.str]] = None,
                 default_local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 ecmp_multi_as: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 enforce_first_as: Optional[pulumi.Input[_builtins.bool]] = None,
                 fast_external_failover: Optional[pulumi.Input[_builtins.bool]] = None,
                 global_bfd: Optional[pulumi.Input['LogicalRouterVrfBgpGlobalBfdArgs']] = None,
                 graceful_restart: Optional[pulumi.Input['LogicalRouterVrfBgpGracefulRestartArgs']] = None,
                 graceful_shutdown: Optional[pulumi.Input[_builtins.bool]] = None,
                 install_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_as: Optional[pulumi.Input[_builtins.str]] = None,
                 med: Optional[pulumi.Input['LogicalRouterVrfBgpMedArgs']] = None,
                 peer_groups: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupArgs']]]] = None,
                 policy: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyArgs']] = None,
                 redist_rules: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpRedistRuleArgs']]]] = None,
                 redistribution_profile: Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileArgs']] = None,
                 reject_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 router_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkArgs'] advertise_network: Advertise network
        :param pulumi.Input['LogicalRouterVrfBgpAggregateArgs'] aggregate: Aggregate
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAggregateRouteArgs']]] aggregate_routes: Aggregate routes
        :param pulumi.Input[_builtins.bool] allow_redist_default_route: Allow redist default route
        :param pulumi.Input[_builtins.bool] always_advertise_network_route: Always advertise network route
        :param pulumi.Input[_builtins.str] as_format: As format
        :param pulumi.Input[_builtins.str] confederation_member_as: Confederation member as
        :param pulumi.Input[_builtins.int] default_local_preference: Default local preference
        :param pulumi.Input[_builtins.bool] ecmp_multi_as: Ecmp multi as
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.bool] enforce_first_as: Enforce first as
        :param pulumi.Input[_builtins.bool] fast_external_failover: Fast external failover
        :param pulumi.Input['LogicalRouterVrfBgpGlobalBfdArgs'] global_bfd: Global bfd
        :param pulumi.Input['LogicalRouterVrfBgpGracefulRestartArgs'] graceful_restart: Graceful restart
        :param pulumi.Input[_builtins.bool] graceful_shutdown: Graceful shutdown
        :param pulumi.Input[_builtins.bool] install_route: Install route
        :param pulumi.Input[_builtins.str] local_as: Local as
        :param pulumi.Input['LogicalRouterVrfBgpMedArgs'] med: Med
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupArgs']]] peer_groups: Peer group
        :param pulumi.Input['LogicalRouterVrfBgpPolicyArgs'] policy: Policy
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpRedistRuleArgs']]] redist_rules: Redist rules
        :param pulumi.Input['LogicalRouterVrfBgpRedistributionProfileArgs'] redistribution_profile: Redistribution profile
        :param pulumi.Input[_builtins.bool] reject_default_route: Reject default route
        :param pulumi.Input[_builtins.str] router_id: Router id
        """
        if advertise_network is not None:
            pulumi.set(__self__, "advertise_network", advertise_network)
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if aggregate_routes is not None:
            pulumi.set(__self__, "aggregate_routes", aggregate_routes)
        if allow_redist_default_route is not None:
            pulumi.set(__self__, "allow_redist_default_route", allow_redist_default_route)
        if always_advertise_network_route is not None:
            pulumi.set(__self__, "always_advertise_network_route", always_advertise_network_route)
        if as_format is not None:
            pulumi.set(__self__, "as_format", as_format)
        if confederation_member_as is not None:
            pulumi.set(__self__, "confederation_member_as", confederation_member_as)
        if default_local_preference is not None:
            pulumi.set(__self__, "default_local_preference", default_local_preference)
        if ecmp_multi_as is not None:
            pulumi.set(__self__, "ecmp_multi_as", ecmp_multi_as)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if enforce_first_as is not None:
            pulumi.set(__self__, "enforce_first_as", enforce_first_as)
        if fast_external_failover is not None:
            pulumi.set(__self__, "fast_external_failover", fast_external_failover)
        if global_bfd is not None:
            pulumi.set(__self__, "global_bfd", global_bfd)
        if graceful_restart is not None:
            pulumi.set(__self__, "graceful_restart", graceful_restart)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if install_route is not None:
            pulumi.set(__self__, "install_route", install_route)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if peer_groups is not None:
            pulumi.set(__self__, "peer_groups", peer_groups)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if redist_rules is not None:
            pulumi.set(__self__, "redist_rules", redist_rules)
        if redistribution_profile is not None:
            pulumi.set(__self__, "redistribution_profile", redistribution_profile)
        if reject_default_route is not None:
            pulumi.set(__self__, "reject_default_route", reject_default_route)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="advertiseNetwork")
    def advertise_network(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkArgs']]:
        """
        Advertise network
        """
        return pulumi.get(self, "advertise_network")

    @advertise_network.setter
    def advertise_network(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkArgs']]):
        pulumi.set(self, "advertise_network", value)

    @_builtins.property
    @pulumi.getter
    def aggregate(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAggregateArgs']]:
        """
        Aggregate
        """
        return pulumi.get(self, "aggregate")

    @aggregate.setter
    def aggregate(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateArgs']]):
        pulumi.set(self, "aggregate", value)

    @_builtins.property
    @pulumi.getter(name="aggregateRoutes")
    def aggregate_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAggregateRouteArgs']]]]:
        """
        Aggregate routes
        """
        return pulumi.get(self, "aggregate_routes")

    @aggregate_routes.setter
    def aggregate_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAggregateRouteArgs']]]]):
        pulumi.set(self, "aggregate_routes", value)

    @_builtins.property
    @pulumi.getter(name="allowRedistDefaultRoute")
    def allow_redist_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow redist default route
        """
        return pulumi.get(self, "allow_redist_default_route")

    @allow_redist_default_route.setter
    def allow_redist_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_redist_default_route", value)

    @_builtins.property
    @pulumi.getter(name="alwaysAdvertiseNetworkRoute")
    def always_advertise_network_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Always advertise network route
        """
        return pulumi.get(self, "always_advertise_network_route")

    @always_advertise_network_route.setter
    def always_advertise_network_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "always_advertise_network_route", value)

    @_builtins.property
    @pulumi.getter(name="asFormat")
    def as_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        As format
        """
        return pulumi.get(self, "as_format")

    @as_format.setter
    def as_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "as_format", value)

    @_builtins.property
    @pulumi.getter(name="confederationMemberAs")
    def confederation_member_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Confederation member as
        """
        return pulumi.get(self, "confederation_member_as")

    @confederation_member_as.setter
    def confederation_member_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "confederation_member_as", value)

    @_builtins.property
    @pulumi.getter(name="defaultLocalPreference")
    def default_local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Default local preference
        """
        return pulumi.get(self, "default_local_preference")

    @default_local_preference.setter
    def default_local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_local_preference", value)

    @_builtins.property
    @pulumi.getter(name="ecmpMultiAs")
    def ecmp_multi_as(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Ecmp multi as
        """
        return pulumi.get(self, "ecmp_multi_as")

    @ecmp_multi_as.setter
    def ecmp_multi_as(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ecmp_multi_as", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="enforceFirstAs")
    def enforce_first_as(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enforce first as
        """
        return pulumi.get(self, "enforce_first_as")

    @enforce_first_as.setter
    def enforce_first_as(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_first_as", value)

    @_builtins.property
    @pulumi.getter(name="fastExternalFailover")
    def fast_external_failover(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Fast external failover
        """
        return pulumi.get(self, "fast_external_failover")

    @fast_external_failover.setter
    def fast_external_failover(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fast_external_failover", value)

    @_builtins.property
    @pulumi.getter(name="globalBfd")
    def global_bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpGlobalBfdArgs']]:
        """
        Global bfd
        """
        return pulumi.get(self, "global_bfd")

    @global_bfd.setter
    def global_bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpGlobalBfdArgs']]):
        pulumi.set(self, "global_bfd", value)

    @_builtins.property
    @pulumi.getter(name="gracefulRestart")
    def graceful_restart(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpGracefulRestartArgs']]:
        """
        Graceful restart
        """
        return pulumi.get(self, "graceful_restart")

    @graceful_restart.setter
    def graceful_restart(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpGracefulRestartArgs']]):
        pulumi.set(self, "graceful_restart", value)

    @_builtins.property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Graceful shutdown
        """
        return pulumi.get(self, "graceful_shutdown")

    @graceful_shutdown.setter
    def graceful_shutdown(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "graceful_shutdown", value)

    @_builtins.property
    @pulumi.getter(name="installRoute")
    def install_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Install route
        """
        return pulumi.get(self, "install_route")

    @install_route.setter
    def install_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "install_route", value)

    @_builtins.property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local as
        """
        return pulumi.get(self, "local_as")

    @local_as.setter
    def local_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_as", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpMedArgs']]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpMedArgs']]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter(name="peerGroups")
    def peer_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupArgs']]]]:
        """
        Peer group
        """
        return pulumi.get(self, "peer_groups")

    @peer_groups.setter
    def peer_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupArgs']]]]):
        pulumi.set(self, "peer_groups", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyArgs']]:
        """
        Policy
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyArgs']]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter(name="redistRules")
    def redist_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpRedistRuleArgs']]]]:
        """
        Redist rules
        """
        return pulumi.get(self, "redist_rules")

    @redist_rules.setter
    def redist_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpRedistRuleArgs']]]]):
        pulumi.set(self, "redist_rules", value)

    @_builtins.property
    @pulumi.getter(name="redistributionProfile")
    def redistribution_profile(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileArgs']]:
        """
        Redistribution profile
        """
        return pulumi.get(self, "redistribution_profile")

    @redistribution_profile.setter
    def redistribution_profile(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileArgs']]):
        pulumi.set(self, "redistribution_profile", value)

    @_builtins.property
    @pulumi.getter(name="rejectDefaultRoute")
    def reject_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reject default route
        """
        return pulumi.get(self, "reject_default_route")

    @reject_default_route.setter
    def reject_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_default_route", value)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Router id
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "router_id", value)


if not MYPY:
    class LogicalRouterVrfBgpAdvertiseNetworkArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4ArgsDict']]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6ArgsDict']]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfBgpAdvertiseNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAdvertiseNetworkArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4Args'] ipv4: Ipv4
        :param pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6Args'] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6Args']]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpAdvertiseNetworkIpv4ArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgsDict']]]]
        """
        Network
        """
elif False:
    LogicalRouterVrfBgpAdvertiseNetworkIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAdvertiseNetworkIpv4Args:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgs']]] networks: Network
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgs']]]]:
        """
        Network
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        backdoor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Backdoor
        """
        multicast: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Multicast
        """
        unicast: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Unicast
        """
elif False:
    LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 backdoor: Optional[pulumi.Input[_builtins.bool]] = None,
                 multicast: Optional[pulumi.Input[_builtins.bool]] = None,
                 unicast: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] backdoor: Backdoor
        :param pulumi.Input[_builtins.bool] multicast: Multicast
        :param pulumi.Input[_builtins.bool] unicast: Unicast
        """
        pulumi.set(__self__, "name", name)
        if backdoor is not None:
            pulumi.set(__self__, "backdoor", backdoor)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def backdoor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Backdoor
        """
        return pulumi.get(self, "backdoor")

    @backdoor.setter
    def backdoor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "backdoor", value)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Multicast
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfBgpAdvertiseNetworkIpv6ArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgsDict']]]]
        """
        Network
        """
elif False:
    LogicalRouterVrfBgpAdvertiseNetworkIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAdvertiseNetworkIpv6Args:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgs']]] networks: Network
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgs']]]]:
        """
        Network
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        unicast: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Unicast
        """
elif False:
    LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 unicast: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] unicast: Unicast
        """
        pulumi.set(__self__, "name", name)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfBgpAggregateArgsDict(TypedDict):
        aggregate_med: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Aggregate med
        """
elif False:
    LogicalRouterVrfBgpAggregateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAggregateArgs:
    def __init__(__self__, *,
                 aggregate_med: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] aggregate_med: Aggregate med
        """
        if aggregate_med is not None:
            pulumi.set(__self__, "aggregate_med", aggregate_med)

    @_builtins.property
    @pulumi.getter(name="aggregateMed")
    def aggregate_med(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Aggregate med
        """
        return pulumi.get(self, "aggregate_med")

    @aggregate_med.setter
    def aggregate_med(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "aggregate_med", value)


if not MYPY:
    class LogicalRouterVrfBgpAggregateRouteArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        as_set: NotRequired[pulumi.Input[_builtins.bool]]
        """
        As set
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        same_med: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Same med
        """
        summary_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Summary only
        """
        type: NotRequired[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeArgsDict']]
        """
        Type
        """
elif False:
    LogicalRouterVrfBgpAggregateRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAggregateRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 as_set: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 same_med: Optional[pulumi.Input[_builtins.bool]] = None,
                 summary_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] as_set: As set
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.bool] same_med: Same med
        :param pulumi.Input[_builtins.bool] summary_only: Summary only
        :param pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeArgs'] type: Type
        """
        pulumi.set(__self__, "name", name)
        if as_set is not None:
            pulumi.set(__self__, "as_set", as_set)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if same_med is not None:
            pulumi.set(__self__, "same_med", same_med)
        if summary_only is not None:
            pulumi.set(__self__, "summary_only", summary_only)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="asSet")
    def as_set(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        As set
        """
        return pulumi.get(self, "as_set")

    @as_set.setter
    def as_set(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_set", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="sameMed")
    def same_med(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Same med
        """
        return pulumi.get(self, "same_med")

    @same_med.setter
    def same_med(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "same_med", value)

    @_builtins.property
    @pulumi.getter(name="summaryOnly")
    def summary_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Summary only
        """
        return pulumi.get(self, "summary_only")

    @summary_only.setter
    def summary_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "summary_only", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeArgs']]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeArgs']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogicalRouterVrfBgpAggregateRouteTypeArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv4ArgsDict']]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv6ArgsDict']]
        """
        Ipv6

        >  **Note:** You must specify exactly one of `ipv4` and `ipv6`.
        """
elif False:
    LogicalRouterVrfBgpAggregateRouteTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAggregateRouteTypeArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv6Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv4Args'] ipv4: Ipv4
        :param pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv6Args'] ipv6: Ipv6
               
               >  **Note:** You must specify exactly one of `ipv4` and `ipv6`.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv6Args']]:
        """
        Ipv6

        >  **Note:** You must specify exactly one of `ipv4` and `ipv6`.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpAggregateRouteTypeIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpAggregateRouteTypeIpv4ArgsDict(TypedDict):
        attribute_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute map
        """
        summary_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Summary prefix
        """
        suppress_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Suppress map
        """
elif False:
    LogicalRouterVrfBgpAggregateRouteTypeIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAggregateRouteTypeIpv4Args:
    def __init__(__self__, *,
                 attribute_map: Optional[pulumi.Input[_builtins.str]] = None,
                 summary_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_map: Attribute map
        :param pulumi.Input[_builtins.str] summary_prefix: Summary prefix
        :param pulumi.Input[_builtins.str] suppress_map: Suppress map
        """
        if attribute_map is not None:
            pulumi.set(__self__, "attribute_map", attribute_map)
        if summary_prefix is not None:
            pulumi.set(__self__, "summary_prefix", summary_prefix)
        if suppress_map is not None:
            pulumi.set(__self__, "suppress_map", suppress_map)

    @_builtins.property
    @pulumi.getter(name="attributeMap")
    def attribute_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute map
        """
        return pulumi.get(self, "attribute_map")

    @attribute_map.setter
    def attribute_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_map", value)

    @_builtins.property
    @pulumi.getter(name="summaryPrefix")
    def summary_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Summary prefix
        """
        return pulumi.get(self, "summary_prefix")

    @summary_prefix.setter
    def summary_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "summary_prefix", value)

    @_builtins.property
    @pulumi.getter(name="suppressMap")
    def suppress_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Suppress map
        """
        return pulumi.get(self, "suppress_map")

    @suppress_map.setter
    def suppress_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suppress_map", value)


if not MYPY:
    class LogicalRouterVrfBgpAggregateRouteTypeIpv6ArgsDict(TypedDict):
        attribute_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute map
        """
        summary_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Summary prefix
        """
        suppress_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Suppress map
        """
elif False:
    LogicalRouterVrfBgpAggregateRouteTypeIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpAggregateRouteTypeIpv6Args:
    def __init__(__self__, *,
                 attribute_map: Optional[pulumi.Input[_builtins.str]] = None,
                 summary_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_map: Attribute map
        :param pulumi.Input[_builtins.str] summary_prefix: Summary prefix
        :param pulumi.Input[_builtins.str] suppress_map: Suppress map
        """
        if attribute_map is not None:
            pulumi.set(__self__, "attribute_map", attribute_map)
        if summary_prefix is not None:
            pulumi.set(__self__, "summary_prefix", summary_prefix)
        if suppress_map is not None:
            pulumi.set(__self__, "suppress_map", suppress_map)

    @_builtins.property
    @pulumi.getter(name="attributeMap")
    def attribute_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute map
        """
        return pulumi.get(self, "attribute_map")

    @attribute_map.setter
    def attribute_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_map", value)

    @_builtins.property
    @pulumi.getter(name="summaryPrefix")
    def summary_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Summary prefix
        """
        return pulumi.get(self, "summary_prefix")

    @summary_prefix.setter
    def summary_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "summary_prefix", value)

    @_builtins.property
    @pulumi.getter(name="suppressMap")
    def suppress_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Suppress map
        """
        return pulumi.get(self, "suppress_map")

    @suppress_map.setter
    def suppress_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suppress_map", value)


if not MYPY:
    class LogicalRouterVrfBgpGlobalBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfBgpGlobalBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpGlobalBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfBgpGracefulRestartArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        local_restart_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local restart time
        """
        max_peer_restart_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max peer restart time
        """
        stale_route_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Stale route time
        """
elif False:
    LogicalRouterVrfBgpGracefulRestartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpGracefulRestartArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_restart_time: Optional[pulumi.Input[_builtins.int]] = None,
                 max_peer_restart_time: Optional[pulumi.Input[_builtins.int]] = None,
                 stale_route_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] local_restart_time: Local restart time
        :param pulumi.Input[_builtins.int] max_peer_restart_time: Max peer restart time
        :param pulumi.Input[_builtins.int] stale_route_time: Stale route time
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if local_restart_time is not None:
            pulumi.set(__self__, "local_restart_time", local_restart_time)
        if max_peer_restart_time is not None:
            pulumi.set(__self__, "max_peer_restart_time", max_peer_restart_time)
        if stale_route_time is not None:
            pulumi.set(__self__, "stale_route_time", stale_route_time)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="localRestartTime")
    def local_restart_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local restart time
        """
        return pulumi.get(self, "local_restart_time")

    @local_restart_time.setter
    def local_restart_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_restart_time", value)

    @_builtins.property
    @pulumi.getter(name="maxPeerRestartTime")
    def max_peer_restart_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max peer restart time
        """
        return pulumi.get(self, "max_peer_restart_time")

    @max_peer_restart_time.setter
    def max_peer_restart_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_peer_restart_time", value)

    @_builtins.property
    @pulumi.getter(name="staleRouteTime")
    def stale_route_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Stale route time
        """
        return pulumi.get(self, "stale_route_time")

    @stale_route_time.setter
    def stale_route_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stale_route_time", value)


if not MYPY:
    class LogicalRouterVrfBgpMedArgsDict(TypedDict):
        always_compare_med: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Always compare med
        """
        deterministic_med_comparison: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deterministic med comparison
        """
elif False:
    LogicalRouterVrfBgpMedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpMedArgs:
    def __init__(__self__, *,
                 always_compare_med: Optional[pulumi.Input[_builtins.bool]] = None,
                 deterministic_med_comparison: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] always_compare_med: Always compare med
        :param pulumi.Input[_builtins.bool] deterministic_med_comparison: Deterministic med comparison
        """
        if always_compare_med is not None:
            pulumi.set(__self__, "always_compare_med", always_compare_med)
        if deterministic_med_comparison is not None:
            pulumi.set(__self__, "deterministic_med_comparison", deterministic_med_comparison)

    @_builtins.property
    @pulumi.getter(name="alwaysCompareMed")
    def always_compare_med(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Always compare med
        """
        return pulumi.get(self, "always_compare_med")

    @always_compare_med.setter
    def always_compare_med(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "always_compare_med", value)

    @_builtins.property
    @pulumi.getter(name="deterministicMedComparison")
    def deterministic_med_comparison(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deterministic med comparison
        """
        return pulumi.get(self, "deterministic_med_comparison")

    @deterministic_med_comparison.setter
    def deterministic_med_comparison(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deterministic_med_comparison", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        address_family: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupAddressFamilyArgsDict']]
        """
        Address family
        """
        aggregated_confed_as_path: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Aggregated confed as path
        """
        connection_options: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupConnectionOptionsArgsDict']]
        """
        Connection options
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        filtering_profile: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupFilteringProfileArgsDict']]
        """
        Filtering profile
        """
        peers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerArgsDict']]]]
        """
        Peer
        """
        soft_reset_with_stored_info: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Soft reset with stored info
        """
        type: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeArgsDict']]
        """
        Type
        """
elif False:
    LogicalRouterVrfBgpPeerGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 address_family: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupAddressFamilyArgs']] = None,
                 aggregated_confed_as_path: Optional[pulumi.Input[_builtins.bool]] = None,
                 connection_options: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupConnectionOptionsArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 filtering_profile: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupFilteringProfileArgs']] = None,
                 peers: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerArgs']]]] = None,
                 soft_reset_with_stored_info: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupAddressFamilyArgs'] address_family: Address family
        :param pulumi.Input[_builtins.bool] aggregated_confed_as_path: Aggregated confed as path
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupConnectionOptionsArgs'] connection_options: Connection options
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupFilteringProfileArgs'] filtering_profile: Filtering profile
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerArgs']]] peers: Peer
        :param pulumi.Input[_builtins.bool] soft_reset_with_stored_info: Soft reset with stored info
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeArgs'] type: Type
        """
        pulumi.set(__self__, "name", name)
        if address_family is not None:
            pulumi.set(__self__, "address_family", address_family)
        if aggregated_confed_as_path is not None:
            pulumi.set(__self__, "aggregated_confed_as_path", aggregated_confed_as_path)
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if filtering_profile is not None:
            pulumi.set(__self__, "filtering_profile", filtering_profile)
        if peers is not None:
            pulumi.set(__self__, "peers", peers)
        if soft_reset_with_stored_info is not None:
            pulumi.set(__self__, "soft_reset_with_stored_info", soft_reset_with_stored_info)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupAddressFamilyArgs']]:
        """
        Address family
        """
        return pulumi.get(self, "address_family")

    @address_family.setter
    def address_family(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupAddressFamilyArgs']]):
        pulumi.set(self, "address_family", value)

    @_builtins.property
    @pulumi.getter(name="aggregatedConfedAsPath")
    def aggregated_confed_as_path(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Aggregated confed as path
        """
        return pulumi.get(self, "aggregated_confed_as_path")

    @aggregated_confed_as_path.setter
    def aggregated_confed_as_path(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "aggregated_confed_as_path", value)

    @_builtins.property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupConnectionOptionsArgs']]:
        """
        Connection options
        """
        return pulumi.get(self, "connection_options")

    @connection_options.setter
    def connection_options(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupConnectionOptionsArgs']]):
        pulumi.set(self, "connection_options", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="filteringProfile")
    def filtering_profile(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupFilteringProfileArgs']]:
        """
        Filtering profile
        """
        return pulumi.get(self, "filtering_profile")

    @filtering_profile.setter
    def filtering_profile(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupFilteringProfileArgs']]):
        pulumi.set(self, "filtering_profile", value)

    @_builtins.property
    @pulumi.getter
    def peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerArgs']]]]:
        """
        Peer
        """
        return pulumi.get(self, "peers")

    @peers.setter
    def peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerArgs']]]]):
        pulumi.set(self, "peers", value)

    @_builtins.property
    @pulumi.getter(name="softResetWithStoredInfo")
    def soft_reset_with_stored_info(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Soft reset with stored info
        """
        return pulumi.get(self, "soft_reset_with_stored_info")

    @soft_reset_with_stored_info.setter
    def soft_reset_with_stored_info(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "soft_reset_with_stored_info", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeArgs']]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeArgs']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupAddressFamilyArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfBgpPeerGroupAddressFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupAddressFamilyArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: Ipv4
        :param pulumi.Input[_builtins.str] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupConnectionOptionsArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        dampening: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dampening
        """
        multihop: NotRequired[pulumi.Input[_builtins.int]]
        """
        Multihop
        """
        timers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timers
        """
elif False:
    LogicalRouterVrfBgpPeerGroupConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupConnectionOptionsArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 dampening: Optional[pulumi.Input[_builtins.str]] = None,
                 multihop: Optional[pulumi.Input[_builtins.int]] = None,
                 timers: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input[_builtins.str] dampening: Dampening
        :param pulumi.Input[_builtins.int] multihop: Multihop
        :param pulumi.Input[_builtins.str] timers: Timers
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if dampening is not None:
            pulumi.set(__self__, "dampening", dampening)
        if multihop is not None:
            pulumi.set(__self__, "multihop", multihop)
        if timers is not None:
            pulumi.set(__self__, "timers", timers)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def dampening(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dampening
        """
        return pulumi.get(self, "dampening")

    @dampening.setter
    def dampening(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dampening", value)

    @_builtins.property
    @pulumi.getter
    def multihop(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Multihop
        """
        return pulumi.get(self, "multihop")

    @multihop.setter
    def multihop(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "multihop", value)

    @_builtins.property
    @pulumi.getter
    def timers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timers
        """
        return pulumi.get(self, "timers")

    @timers.setter
    def timers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timers", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupFilteringProfileArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfBgpPeerGroupFilteringProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupFilteringProfileArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: Ipv4
        :param pulumi.Input[_builtins.str] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdArgsDict']]
        """
        Bfd
        """
        connection_options: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgsDict']]
        """
        Connection options
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        enable_mp_bgp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable mp bgp
        """
        enable_sender_side_loop_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable sender side loop detection
        """
        inherit: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritArgsDict']]
        """
        Inherit
        """
        local_address: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgsDict']]
        """
        Local address
        """
        passive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passive
        """
        peer_address: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgsDict']]
        """
        Peer address
        """
        peer_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer as
        """
        peering_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peering type
        """
        reflector_client: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reflector client
        """
        subsequent_address_family_identifier: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgsDict']]
        """
        Subsequent address family identifier
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 bfd: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdArgs']] = None,
                 connection_options: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_mp_bgp: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_sender_side_loop_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 inherit: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritArgs']] = None,
                 local_address: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgs']] = None,
                 passive: Optional[pulumi.Input[_builtins.bool]] = None,
                 peer_address: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgs']] = None,
                 peer_as: Optional[pulumi.Input[_builtins.str]] = None,
                 peering_type: Optional[pulumi.Input[_builtins.str]] = None,
                 reflector_client: Optional[pulumi.Input[_builtins.str]] = None,
                 subsequent_address_family_identifier: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdArgs'] bfd: Bfd
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgs'] connection_options: Connection options
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.bool] enable_mp_bgp: Enable mp bgp
        :param pulumi.Input[_builtins.bool] enable_sender_side_loop_detection: Enable sender side loop detection
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritArgs'] inherit: Inherit
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgs'] local_address: Local address
        :param pulumi.Input[_builtins.bool] passive: Passive
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgs'] peer_address: Peer address
        :param pulumi.Input[_builtins.str] peer_as: Peer as
        :param pulumi.Input[_builtins.str] peering_type: Peering type
        :param pulumi.Input[_builtins.str] reflector_client: Reflector client
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgs'] subsequent_address_family_identifier: Subsequent address family identifier
        """
        pulumi.set(__self__, "name", name)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if enable_mp_bgp is not None:
            pulumi.set(__self__, "enable_mp_bgp", enable_mp_bgp)
        if enable_sender_side_loop_detection is not None:
            pulumi.set(__self__, "enable_sender_side_loop_detection", enable_sender_side_loop_detection)
        if inherit is not None:
            pulumi.set(__self__, "inherit", inherit)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if peer_address is not None:
            pulumi.set(__self__, "peer_address", peer_address)
        if peer_as is not None:
            pulumi.set(__self__, "peer_as", peer_as)
        if peering_type is not None:
            pulumi.set(__self__, "peering_type", peering_type)
        if reflector_client is not None:
            pulumi.set(__self__, "reflector_client", reflector_client)
        if subsequent_address_family_identifier is not None:
            pulumi.set(__self__, "subsequent_address_family_identifier", subsequent_address_family_identifier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgs']]:
        """
        Connection options
        """
        return pulumi.get(self, "connection_options")

    @connection_options.setter
    def connection_options(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgs']]):
        pulumi.set(self, "connection_options", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="enableMpBgp")
    def enable_mp_bgp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable mp bgp
        """
        return pulumi.get(self, "enable_mp_bgp")

    @enable_mp_bgp.setter
    def enable_mp_bgp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_mp_bgp", value)

    @_builtins.property
    @pulumi.getter(name="enableSenderSideLoopDetection")
    def enable_sender_side_loop_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable sender side loop detection
        """
        return pulumi.get(self, "enable_sender_side_loop_detection")

    @enable_sender_side_loop_detection.setter
    def enable_sender_side_loop_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_sender_side_loop_detection", value)

    @_builtins.property
    @pulumi.getter
    def inherit(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritArgs']]:
        """
        Inherit
        """
        return pulumi.get(self, "inherit")

    @inherit.setter
    def inherit(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritArgs']]):
        pulumi.set(self, "inherit", value)

    @_builtins.property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgs']]:
        """
        Local address
        """
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgs']]):
        pulumi.set(self, "local_address", value)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passive", value)

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgs']]:
        """
        Peer address
        """
        return pulumi.get(self, "peer_address")

    @peer_address.setter
    def peer_address(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgs']]):
        pulumi.set(self, "peer_address", value)

    @_builtins.property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer as
        """
        return pulumi.get(self, "peer_as")

    @peer_as.setter
    def peer_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_as", value)

    @_builtins.property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peering type
        """
        return pulumi.get(self, "peering_type")

    @peering_type.setter
    def peering_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peering_type", value)

    @_builtins.property
    @pulumi.getter(name="reflectorClient")
    def reflector_client(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reflector client
        """
        return pulumi.get(self, "reflector_client")

    @reflector_client.setter
    def reflector_client(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reflector_client", value)

    @_builtins.property
    @pulumi.getter(name="subsequentAddressFamilyIdentifier")
    def subsequent_address_family_identifier(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgs']]:
        """
        Subsequent address family identifier
        """
        return pulumi.get(self, "subsequent_address_family_identifier")

    @subsequent_address_family_identifier.setter
    def subsequent_address_family_identifier(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgs']]):
        pulumi.set(self, "subsequent_address_family_identifier", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerBfdArgsDict(TypedDict):
        multihop: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgsDict']]
        """
        Multihop
        """
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerBfdArgs:
    def __init__(__self__, *,
                 multihop: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgs']] = None,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgs'] multihop: Multihop
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if multihop is not None:
            pulumi.set(__self__, "multihop", multihop)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def multihop(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgs']]:
        """
        Multihop
        """
        return pulumi.get(self, "multihop")

    @multihop.setter
    def multihop(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgs']]):
        pulumi.set(self, "multihop", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgsDict(TypedDict):
        min_received_ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        Min received ttl
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerBfdMultihopArgs:
    def __init__(__self__, *,
                 min_received_ttl: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] min_received_ttl: Min received ttl
        """
        if min_received_ttl is not None:
            pulumi.set(__self__, "min_received_ttl", min_received_ttl)

    @_builtins.property
    @pulumi.getter(name="minReceivedTtl")
    def min_received_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Min received ttl
        """
        return pulumi.get(self, "min_received_ttl")

    @min_received_ttl.setter
    def min_received_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_received_ttl", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        dampening: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dampening
        """
        hold_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hold time
        """
        idle_hold_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Idle hold time
        """
        incoming_bgp_connection: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgsDict']]
        """
        Incoming bgp connection
        """
        keep_alive_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Keep alive interval
        """
        max_prefixes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max prefixes
        """
        min_route_adv_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Min route adv interval
        """
        multihop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Multihop
        """
        open_delay_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Open delay time
        """
        outgoing_bgp_connection: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgsDict']]
        """
        Outgoing bgp connection
        """
        timers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timers
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 dampening: Optional[pulumi.Input[_builtins.str]] = None,
                 hold_time: Optional[pulumi.Input[_builtins.str]] = None,
                 idle_hold_time: Optional[pulumi.Input[_builtins.int]] = None,
                 incoming_bgp_connection: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgs']] = None,
                 keep_alive_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 max_prefixes: Optional[pulumi.Input[_builtins.str]] = None,
                 min_route_adv_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 multihop: Optional[pulumi.Input[_builtins.str]] = None,
                 open_delay_time: Optional[pulumi.Input[_builtins.int]] = None,
                 outgoing_bgp_connection: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgs']] = None,
                 timers: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input[_builtins.str] dampening: Dampening
        :param pulumi.Input[_builtins.str] hold_time: Hold time
        :param pulumi.Input[_builtins.int] idle_hold_time: Idle hold time
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgs'] incoming_bgp_connection: Incoming bgp connection
        :param pulumi.Input[_builtins.str] keep_alive_interval: Keep alive interval
        :param pulumi.Input[_builtins.str] max_prefixes: Max prefixes
        :param pulumi.Input[_builtins.int] min_route_adv_interval: Min route adv interval
        :param pulumi.Input[_builtins.str] multihop: Multihop
        :param pulumi.Input[_builtins.int] open_delay_time: Open delay time
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgs'] outgoing_bgp_connection: Outgoing bgp connection
        :param pulumi.Input[_builtins.str] timers: Timers
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if dampening is not None:
            pulumi.set(__self__, "dampening", dampening)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if idle_hold_time is not None:
            pulumi.set(__self__, "idle_hold_time", idle_hold_time)
        if incoming_bgp_connection is not None:
            pulumi.set(__self__, "incoming_bgp_connection", incoming_bgp_connection)
        if keep_alive_interval is not None:
            pulumi.set(__self__, "keep_alive_interval", keep_alive_interval)
        if max_prefixes is not None:
            pulumi.set(__self__, "max_prefixes", max_prefixes)
        if min_route_adv_interval is not None:
            pulumi.set(__self__, "min_route_adv_interval", min_route_adv_interval)
        if multihop is not None:
            pulumi.set(__self__, "multihop", multihop)
        if open_delay_time is not None:
            pulumi.set(__self__, "open_delay_time", open_delay_time)
        if outgoing_bgp_connection is not None:
            pulumi.set(__self__, "outgoing_bgp_connection", outgoing_bgp_connection)
        if timers is not None:
            pulumi.set(__self__, "timers", timers)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def dampening(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dampening
        """
        return pulumi.get(self, "dampening")

    @dampening.setter
    def dampening(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dampening", value)

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hold time
        """
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hold_time", value)

    @_builtins.property
    @pulumi.getter(name="idleHoldTime")
    def idle_hold_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Idle hold time
        """
        return pulumi.get(self, "idle_hold_time")

    @idle_hold_time.setter
    def idle_hold_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_hold_time", value)

    @_builtins.property
    @pulumi.getter(name="incomingBgpConnection")
    def incoming_bgp_connection(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgs']]:
        """
        Incoming bgp connection
        """
        return pulumi.get(self, "incoming_bgp_connection")

    @incoming_bgp_connection.setter
    def incoming_bgp_connection(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgs']]):
        pulumi.set(self, "incoming_bgp_connection", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveInterval")
    def keep_alive_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Keep alive interval
        """
        return pulumi.get(self, "keep_alive_interval")

    @keep_alive_interval.setter
    def keep_alive_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keep_alive_interval", value)

    @_builtins.property
    @pulumi.getter(name="maxPrefixes")
    def max_prefixes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max prefixes
        """
        return pulumi.get(self, "max_prefixes")

    @max_prefixes.setter
    def max_prefixes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="minRouteAdvInterval")
    def min_route_adv_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Min route adv interval
        """
        return pulumi.get(self, "min_route_adv_interval")

    @min_route_adv_interval.setter
    def min_route_adv_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_route_adv_interval", value)

    @_builtins.property
    @pulumi.getter
    def multihop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Multihop
        """
        return pulumi.get(self, "multihop")

    @multihop.setter
    def multihop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "multihop", value)

    @_builtins.property
    @pulumi.getter(name="openDelayTime")
    def open_delay_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Open delay time
        """
        return pulumi.get(self, "open_delay_time")

    @open_delay_time.setter
    def open_delay_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "open_delay_time", value)

    @_builtins.property
    @pulumi.getter(name="outgoingBgpConnection")
    def outgoing_bgp_connection(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgs']]:
        """
        Outgoing bgp connection
        """
        return pulumi.get(self, "outgoing_bgp_connection")

    @outgoing_bgp_connection.setter
    def outgoing_bgp_connection(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgs']]):
        pulumi.set(self, "outgoing_bgp_connection", value)

    @_builtins.property
    @pulumi.getter
    def timers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timers
        """
        return pulumi.get(self, "timers")

    @timers.setter
    def timers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timers", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow
        """
        remote_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remote port
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[_builtins.bool]] = None,
                 remote_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow: Allow
        :param pulumi.Input[_builtins.int] remote_port: Remote port
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remote port
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remote_port", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow
        """
        local_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local port
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow: Allow
        :param pulumi.Input[_builtins.int] local_port: Local port
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local port
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_port", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerInheritArgsDict(TypedDict):
        no: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoArgsDict']]
        """
        No
        """
        yes: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritYesArgsDict']]
        """
        Yes

        >  **Note:** You must specify exactly one of `ipv4`, `no`, and `yes`.
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerInheritArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerInheritArgs:
    def __init__(__self__, *,
                 no: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoArgs']] = None,
                 yes: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritYesArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoArgs'] no: No
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritYesArgs'] yes: Yes
               
               >  **Note:** You must specify exactly one of `ipv4`, `no`, and `yes`.
        """
        if no is not None:
            pulumi.set(__self__, "no", no)
        if yes is not None:
            pulumi.set(__self__, "yes", yes)

    @_builtins.property
    @pulumi.getter
    def no(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoArgs']]:
        """
        No
        """
        return pulumi.get(self, "no")

    @no.setter
    def no(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoArgs']]):
        pulumi.set(self, "no", value)

    @_builtins.property
    @pulumi.getter
    def yes(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritYesArgs']]:
        """
        Yes

        >  **Note:** You must specify exactly one of `ipv4`, `no`, and `yes`.
        """
        return pulumi.get(self, "yes")

    @yes.setter
    def yes(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritYesArgs']]):
        pulumi.set(self, "yes", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerInheritNoArgsDict(TypedDict):
        address_family: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgsDict']]
        """
        Address family
        """
        filtering_profile: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgsDict']]
        """
        Filtering profile
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerInheritNoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerInheritNoArgs:
    def __init__(__self__, *,
                 address_family: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgs']] = None,
                 filtering_profile: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgs'] address_family: Address family
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgs'] filtering_profile: Filtering profile
        """
        if address_family is not None:
            pulumi.set(__self__, "address_family", address_family)
        if filtering_profile is not None:
            pulumi.set(__self__, "filtering_profile", filtering_profile)

    @_builtins.property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgs']]:
        """
        Address family
        """
        return pulumi.get(self, "address_family")

    @address_family.setter
    def address_family(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgs']]):
        pulumi.set(self, "address_family", value)

    @_builtins.property
    @pulumi.getter(name="filteringProfile")
    def filtering_profile(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgs']]:
        """
        Filtering profile
        """
        return pulumi.get(self, "filtering_profile")

    @filtering_profile.setter
    def filtering_profile(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgs']]):
        pulumi.set(self, "filtering_profile", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: Ipv4
        :param pulumi.Input[_builtins.str] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: Ipv4
        :param pulumi.Input[_builtins.str] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerInheritYesArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPeerGroupPeerInheritYesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerInheritYesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerLocalAddressArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.str] ip: Ip
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fqdn
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip

        >  **Note:** You must specify exactly one of `fqdn` and `ip`.
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerPeerAddressArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: Fqdn
        :param pulumi.Input[_builtins.str] ip: Ip
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fqdn
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip

        >  **Note:** You must specify exactly one of `fqdn` and `ip`.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgsDict(TypedDict):
        multicast: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Multicast
        """
        unicast: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Unicast
        """
elif False:
    LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierArgs:
    def __init__(__self__, *,
                 multicast: Optional[pulumi.Input[_builtins.bool]] = None,
                 unicast: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] multicast: Multicast
        :param pulumi.Input[_builtins.bool] unicast: Unicast
        """
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Multicast
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupTypeArgsDict(TypedDict):
        ebgp: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpArgsDict']]
        """
        Ebgp
        """
        ebgp_confed: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgsDict']]
        """
        Ebgp confed

        >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
        ibgp: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpArgsDict']]
        """
        Ibgp

        >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
        ibgp_confed: NotRequired[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgsDict']]
        """
        Ibgp confed

        >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
elif False:
    LogicalRouterVrfBgpPeerGroupTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupTypeArgs:
    def __init__(__self__, *,
                 ebgp: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpArgs']] = None,
                 ebgp_confed: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgs']] = None,
                 ibgp: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpArgs']] = None,
                 ibgp_confed: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpArgs'] ebgp: Ebgp
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgs'] ebgp_confed: Ebgp confed
               
               >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpArgs'] ibgp: Ibgp
               
               >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        :param pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgs'] ibgp_confed: Ibgp confed
               
               >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
        if ebgp is not None:
            pulumi.set(__self__, "ebgp", ebgp)
        if ebgp_confed is not None:
            pulumi.set(__self__, "ebgp_confed", ebgp_confed)
        if ibgp is not None:
            pulumi.set(__self__, "ibgp", ibgp)
        if ibgp_confed is not None:
            pulumi.set(__self__, "ibgp_confed", ibgp_confed)

    @_builtins.property
    @pulumi.getter
    def ebgp(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpArgs']]:
        """
        Ebgp
        """
        return pulumi.get(self, "ebgp")

    @ebgp.setter
    def ebgp(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpArgs']]):
        pulumi.set(self, "ebgp", value)

    @_builtins.property
    @pulumi.getter(name="ebgpConfed")
    def ebgp_confed(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgs']]:
        """
        Ebgp confed

        >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
        return pulumi.get(self, "ebgp_confed")

    @ebgp_confed.setter
    def ebgp_confed(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgs']]):
        pulumi.set(self, "ebgp_confed", value)

    @_builtins.property
    @pulumi.getter
    def ibgp(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpArgs']]:
        """
        Ibgp

        >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
        return pulumi.get(self, "ibgp")

    @ibgp.setter
    def ibgp(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpArgs']]):
        pulumi.set(self, "ibgp", value)

    @_builtins.property
    @pulumi.getter(name="ibgpConfed")
    def ibgp_confed(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgs']]:
        """
        Ibgp confed

        >  **Note:** You must specify exactly one of `ebgp`, `ebgp_confed`, `ibgp`, and `ibgp_confed`.
        """
        return pulumi.get(self, "ibgp_confed")

    @ibgp_confed.setter
    def ibgp_confed(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgs']]):
        pulumi.set(self, "ibgp_confed", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupTypeEbgpArgsDict(TypedDict):
        export_nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export nexthop
        """
        import_nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import nexthop
        """
        remove_private_as: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Remove private as
        """
elif False:
    LogicalRouterVrfBgpPeerGroupTypeEbgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupTypeEbgpArgs:
    def __init__(__self__, *,
                 export_nexthop: Optional[pulumi.Input[_builtins.str]] = None,
                 import_nexthop: Optional[pulumi.Input[_builtins.str]] = None,
                 remove_private_as: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] export_nexthop: Export nexthop
        :param pulumi.Input[_builtins.str] import_nexthop: Import nexthop
        :param pulumi.Input[_builtins.bool] remove_private_as: Remove private as
        """
        if export_nexthop is not None:
            pulumi.set(__self__, "export_nexthop", export_nexthop)
        if import_nexthop is not None:
            pulumi.set(__self__, "import_nexthop", import_nexthop)
        if remove_private_as is not None:
            pulumi.set(__self__, "remove_private_as", remove_private_as)

    @_builtins.property
    @pulumi.getter(name="exportNexthop")
    def export_nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export nexthop
        """
        return pulumi.get(self, "export_nexthop")

    @export_nexthop.setter
    def export_nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_nexthop", value)

    @_builtins.property
    @pulumi.getter(name="importNexthop")
    def import_nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import nexthop
        """
        return pulumi.get(self, "import_nexthop")

    @import_nexthop.setter
    def import_nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_nexthop", value)

    @_builtins.property
    @pulumi.getter(name="removePrivateAs")
    def remove_private_as(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Remove private as
        """
        return pulumi.get(self, "remove_private_as")

    @remove_private_as.setter
    def remove_private_as(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "remove_private_as", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgsDict(TypedDict):
        export_nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export nexthop
        """
elif False:
    LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupTypeEbgpConfedArgs:
    def __init__(__self__, *,
                 export_nexthop: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_nexthop: Export nexthop
        """
        if export_nexthop is not None:
            pulumi.set(__self__, "export_nexthop", export_nexthop)

    @_builtins.property
    @pulumi.getter(name="exportNexthop")
    def export_nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export nexthop
        """
        return pulumi.get(self, "export_nexthop")

    @export_nexthop.setter
    def export_nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_nexthop", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupTypeIbgpArgsDict(TypedDict):
        export_nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export nexthop
        """
elif False:
    LogicalRouterVrfBgpPeerGroupTypeIbgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupTypeIbgpArgs:
    def __init__(__self__, *,
                 export_nexthop: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_nexthop: Export nexthop
        """
        if export_nexthop is not None:
            pulumi.set(__self__, "export_nexthop", export_nexthop)

    @_builtins.property
    @pulumi.getter(name="exportNexthop")
    def export_nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export nexthop
        """
        return pulumi.get(self, "export_nexthop")

    @export_nexthop.setter
    def export_nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_nexthop", value)


if not MYPY:
    class LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgsDict(TypedDict):
        export_nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export nexthop
        """
elif False:
    LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPeerGroupTypeIbgpConfedArgs:
    def __init__(__self__, *,
                 export_nexthop: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_nexthop: Export nexthop
        """
        if export_nexthop is not None:
            pulumi.set(__self__, "export_nexthop", export_nexthop)

    @_builtins.property
    @pulumi.getter(name="exportNexthop")
    def export_nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export nexthop
        """
        return pulumi.get(self, "export_nexthop")

    @export_nexthop.setter
    def export_nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_nexthop", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyArgsDict(TypedDict):
        aggregation: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationArgsDict']]
        """
        Aggregation
        """
        conditional_advertisement: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementArgsDict']]
        """
        Conditional advertisement
        """
        export: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportArgsDict']]
        """
        Export
        """
        import_: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportArgsDict']]
        """
        Import
        """
elif False:
    LogicalRouterVrfBgpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyArgs:
    def __init__(__self__, *,
                 aggregation: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationArgs']] = None,
                 conditional_advertisement: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementArgs']] = None,
                 export: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportArgs']] = None,
                 import_: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationArgs'] aggregation: Aggregation
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementArgs'] conditional_advertisement: Conditional advertisement
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportArgs'] export: Export
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportArgs'] import_: Import
        """
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if conditional_advertisement is not None:
            pulumi.set(__self__, "conditional_advertisement", conditional_advertisement)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationArgs']]:
        """
        Aggregation
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationArgs']]):
        pulumi.set(self, "aggregation", value)

    @_builtins.property
    @pulumi.getter(name="conditionalAdvertisement")
    def conditional_advertisement(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementArgs']]:
        """
        Conditional advertisement
        """
        return pulumi.get(self, "conditional_advertisement")

    @conditional_advertisement.setter
    def conditional_advertisement(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementArgs']]):
        pulumi.set(self, "conditional_advertisement", value)

    @_builtins.property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportArgs']]:
        """
        Export
        """
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportArgs']]):
        pulumi.set(self, "export", value)

    @_builtins.property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportArgs']]:
        """
        Import
        """
        return pulumi.get(self, "import_")

    @import_.setter
    def import_(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportArgs']]):
        pulumi.set(self, "import_", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressArgsDict']]]]
        """
        Address
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressArgs']]] addresses: Address
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressArgs']]]]:
        """
        Address
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressArgs']]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgsDict']]]]
        """
        Advertise filters
        """
        aggregate_route_attributes: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgsDict']]
        """
        Aggregate route attributes
        """
        as_set: NotRequired[pulumi.Input[_builtins.bool]]
        """
        As set
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix
        """
        summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Summary
        """
        suppress_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgsDict']]]]
        """
        Suppress filters
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise_filters: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgs']]]] = None,
                 aggregate_route_attributes: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgs']] = None,
                 as_set: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 suppress_filters: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgs']]] advertise_filters: Advertise filters
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgs'] aggregate_route_attributes: Aggregate route attributes
        :param pulumi.Input[_builtins.bool] as_set: As set
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] prefix: Prefix
        :param pulumi.Input[_builtins.bool] summary: Summary
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgs']]] suppress_filters: Suppress filters
        """
        pulumi.set(__self__, "name", name)
        if advertise_filters is not None:
            pulumi.set(__self__, "advertise_filters", advertise_filters)
        if aggregate_route_attributes is not None:
            pulumi.set(__self__, "aggregate_route_attributes", aggregate_route_attributes)
        if as_set is not None:
            pulumi.set(__self__, "as_set", as_set)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if suppress_filters is not None:
            pulumi.set(__self__, "suppress_filters", suppress_filters)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="advertiseFilters")
    def advertise_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgs']]]]:
        """
        Advertise filters
        """
        return pulumi.get(self, "advertise_filters")

    @advertise_filters.setter
    def advertise_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgs']]]]):
        pulumi.set(self, "advertise_filters", value)

    @_builtins.property
    @pulumi.getter(name="aggregateRouteAttributes")
    def aggregate_route_attributes(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgs']]:
        """
        Aggregate route attributes
        """
        return pulumi.get(self, "aggregate_route_attributes")

    @aggregate_route_attributes.setter
    def aggregate_route_attributes(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgs']]):
        pulumi.set(self, "aggregate_route_attributes", value)

    @_builtins.property
    @pulumi.getter(name="asSet")
    def as_set(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        As set
        """
        return pulumi.get(self, "as_set")

    @as_set.setter
    def as_set(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "as_set", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Summary
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "summary", value)

    @_builtins.property
    @pulumi.getter(name="suppressFilters")
    def suppress_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgs']]]]:
        """
        Suppress filters
        """
        return pulumi.get(self, "suppress_filters")

    @suppress_filters.setter
    def suppress_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgs']]]]):
        pulumi.set(self, "suppress_filters", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        match: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgsDict']]
        """
        Match
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 match: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgs'] match: Match
        """
        pulumi.set(__self__, "name", name)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgsDict(TypedDict):
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgsDict']]]]
        """
        Address prefix
        """
        afi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Afi
        """
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgsDict']]
        """
        As path
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgsDict']]
        """
        Extended community
        """
        from_peers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        From peer
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Nexthop
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        safi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Safi
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchArgs:
    def __init__(__self__, *,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgs']]]] = None,
                 afi: Optional[pulumi.Input[_builtins.str]] = None,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgs']] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgs']] = None,
                 from_peers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 safi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgs']]] address_prefixes: Address prefix
        :param pulumi.Input[_builtins.str] afi: Afi
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgs'] as_path: As path
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] from_peers: From peer
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nexthops: Nexthop
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.str] safi: Safi
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if afi is not None:
            pulumi.set(__self__, "afi", afi)
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if from_peers is not None:
            pulumi.set(__self__, "from_peers", from_peers)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthops is not None:
            pulumi.set(__self__, "nexthops", nexthops)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if safi is not None:
            pulumi.set(__self__, "safi", safi)

    @_builtins.property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgs']]]]:
        """
        Address prefix
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgs']]]]):
        pulumi.set(self, "address_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def afi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Afi
        """
        return pulumi.get(self, "afi")

    @afi.setter
    def afi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "afi", value)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="fromPeers")
    def from_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        From peer
        """
        return pulumi.get(self, "from_peers")

    @from_peers.setter
    def from_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "from_peers", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthops")

    @nexthops.setter
    def nexthops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nexthops", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter
    def safi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Safi
        """
        return pulumi.get(self, "safi")

    @safi.setter
    def safi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "safi", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        exact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exact
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAddressPrefixArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 exact: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] exact: Exact
        """
        pulumi.set(__self__, "name", name)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exact
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchAsPathArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilterMatchExtendedCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgsDict(TypedDict):
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgsDict']]
        """
        As path
        """
        as_path_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        As path limit
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgsDict']]
        """
        Extended community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local preference
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Nexthop
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesArgs:
    def __init__(__self__, *,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgs']] = None,
                 as_path_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgs']] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthop: Optional[pulumi.Input[_builtins.str]] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgs'] as_path: As path
        :param pulumi.Input[_builtins.int] as_path_limit: As path limit
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[_builtins.int] local_preference: Local preference
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[_builtins.str] nexthop: Nexthop
        :param pulumi.Input[_builtins.str] origin: Origin
        :param pulumi.Input[_builtins.int] weight: Weight
        """
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if as_path_limit is not None:
            pulumi.set(__self__, "as_path_limit", as_path_limit)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter(name="asPathLimit")
    def as_path_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        As path limit
        """
        return pulumi.get(self, "as_path_limit")

    @as_path_limit.setter
    def as_path_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "as_path_limit", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgsDict(TypedDict):
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgsDict']]
        """
        None
        """
        prepend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        remove: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgsDict']]
        """
        Remove

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        remove_and_prepend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remove and prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathArgs:
    def __init__(__self__, *,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgs']] = None,
                 prepend: Optional[pulumi.Input[_builtins.int]] = None,
                 remove: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgs']] = None,
                 remove_and_prepend: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgs'] none: None
        :param pulumi.Input[_builtins.int] prepend: Prepend
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgs'] remove: Remove
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        :param pulumi.Input[_builtins.int] remove_and_prepend: Remove and prepend
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        if none is not None:
            pulumi.set(__self__, "none", none)
        if prepend is not None:
            pulumi.set(__self__, "prepend", prepend)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if remove_and_prepend is not None:
            pulumi.set(__self__, "remove_and_prepend", remove_and_prepend)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgs']]:
        """
        None
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def prepend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "prepend")

    @prepend.setter
    def prepend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prepend", value)

    @_builtins.property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgs']]:
        """
        Remove

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgs']]):
        pulumi.set(self, "remove", value)

    @_builtins.property
    @pulumi.getter(name="removeAndPrepend")
    def remove_and_prepend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remove and prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "remove_and_prepend")

    @remove_and_prepend.setter
    def remove_and_prepend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remove_and_prepend", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgsDict(TypedDict):
        appends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Append
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_all: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgsDict']]
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityArgs:
    def __init__(__self__, *,
                 appends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgs']] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_all: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgs']] = None,
                 remove_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] appends: Append
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overwrites: Overwrite
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgs'] remove_all: Remove all
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[_builtins.str] remove_regex: Remove regex
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)
        if remove_all is not None:
            pulumi.set(__self__, "remove_all", remove_all)
        if remove_regex is not None:
            pulumi.set(__self__, "remove_regex", remove_regex)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Append
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overwrites", value)

    @_builtins.property
    @pulumi.getter(name="removeAll")
    def remove_all(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgs']]:
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_all")

    @remove_all.setter
    def remove_all(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgs']]):
        pulumi.set(self, "remove_all", value)

    @_builtins.property
    @pulumi.getter(name="removeRegex")
    def remove_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_regex")

    @remove_regex.setter
    def remove_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgsDict(TypedDict):
        appends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Append
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_all: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgsDict']]
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityArgs:
    def __init__(__self__, *,
                 appends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgs']] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_all: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgs']] = None,
                 remove_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] appends: Append
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overwrites: Overwrite
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgs'] remove_all: Remove all
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[_builtins.str] remove_regex: Remove regex
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)
        if remove_all is not None:
            pulumi.set(__self__, "remove_all", remove_all)
        if remove_regex is not None:
            pulumi.set(__self__, "remove_regex", remove_regex)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Append
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overwrites", value)

    @_builtins.property
    @pulumi.getter(name="removeAll")
    def remove_all(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgs']]:
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_all")

    @remove_all.setter
    def remove_all(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgs']]):
        pulumi.set(self, "remove_all", value)

    @_builtins.property
    @pulumi.getter(name="removeRegex")
    def remove_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_regex")

    @remove_regex.setter
    def remove_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        match: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgsDict']]
        """
        Match
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 match: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgs'] match: Match
        """
        pulumi.set(__self__, "name", name)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgsDict(TypedDict):
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgsDict']]]]
        """
        Address prefix
        """
        afi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Afi
        """
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgsDict']]
        """
        As path
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgsDict']]
        """
        Extended community
        """
        from_peers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        From peer
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Nexthop
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        safi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Safi
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchArgs:
    def __init__(__self__, *,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgs']]]] = None,
                 afi: Optional[pulumi.Input[_builtins.str]] = None,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgs']] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgs']] = None,
                 from_peers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 safi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgs']]] address_prefixes: Address prefix
        :param pulumi.Input[_builtins.str] afi: Afi
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgs'] as_path: As path
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] from_peers: From peer
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nexthops: Nexthop
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.str] safi: Safi
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if afi is not None:
            pulumi.set(__self__, "afi", afi)
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if from_peers is not None:
            pulumi.set(__self__, "from_peers", from_peers)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthops is not None:
            pulumi.set(__self__, "nexthops", nexthops)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if safi is not None:
            pulumi.set(__self__, "safi", safi)

    @_builtins.property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgs']]]]:
        """
        Address prefix
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgs']]]]):
        pulumi.set(self, "address_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def afi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Afi
        """
        return pulumi.get(self, "afi")

    @afi.setter
    def afi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "afi", value)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="fromPeers")
    def from_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        From peer
        """
        return pulumi.get(self, "from_peers")

    @from_peers.setter
    def from_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "from_peers", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthops")

    @nexthops.setter
    def nexthops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nexthops", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter
    def safi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Safi
        """
        return pulumi.get(self, "safi")

    @safi.setter
    def safi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "safi", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        exact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exact
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAddressPrefixArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 exact: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] exact: Exact
        """
        pulumi.set(__self__, "name", name)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exact
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchAsPathArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilterMatchExtendedCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgsDict']]]]
        """
        Policy
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgs']]] policies: Policy
        """
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgs']]]]:
        """
        Policy
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgs']]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgsDict']]]]
        """
        Advertise filters
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        non_exist_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgsDict']]]]
        """
        Non exist filters
        """
        used_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used by
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise_filters: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgs']]]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 non_exist_filters: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgs']]]] = None,
                 used_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgs']]] advertise_filters: Advertise filters
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgs']]] non_exist_filters: Non exist filters
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] used_bies: Used by
        """
        pulumi.set(__self__, "name", name)
        if advertise_filters is not None:
            pulumi.set(__self__, "advertise_filters", advertise_filters)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if non_exist_filters is not None:
            pulumi.set(__self__, "non_exist_filters", non_exist_filters)
        if used_bies is not None:
            pulumi.set(__self__, "used_bies", used_bies)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="advertiseFilters")
    def advertise_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgs']]]]:
        """
        Advertise filters
        """
        return pulumi.get(self, "advertise_filters")

    @advertise_filters.setter
    def advertise_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgs']]]]):
        pulumi.set(self, "advertise_filters", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="nonExistFilters")
    def non_exist_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgs']]]]:
        """
        Non exist filters
        """
        return pulumi.get(self, "non_exist_filters")

    @non_exist_filters.setter
    def non_exist_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgs']]]]):
        pulumi.set(self, "non_exist_filters", value)

    @_builtins.property
    @pulumi.getter(name="usedBies")
    def used_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used by
        """
        return pulumi.get(self, "used_bies")

    @used_bies.setter
    def used_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "used_bies", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        match: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgsDict']]
        """
        Match
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 match: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgs'] match: Match
        """
        pulumi.set(__self__, "name", name)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgsDict(TypedDict):
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgsDict']]]]
        """
        Address prefix
        """
        afi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Afi
        """
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgsDict']]
        """
        As path
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgsDict']]
        """
        Extended community
        """
        from_peers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        From peer
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Nexthop
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        safi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Safi
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchArgs:
    def __init__(__self__, *,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgs']]]] = None,
                 afi: Optional[pulumi.Input[_builtins.str]] = None,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgs']] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgs']] = None,
                 from_peers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 safi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgs']]] address_prefixes: Address prefix
        :param pulumi.Input[_builtins.str] afi: Afi
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgs'] as_path: As path
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] from_peers: From peer
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nexthops: Nexthop
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.str] safi: Safi
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if afi is not None:
            pulumi.set(__self__, "afi", afi)
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if from_peers is not None:
            pulumi.set(__self__, "from_peers", from_peers)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthops is not None:
            pulumi.set(__self__, "nexthops", nexthops)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if safi is not None:
            pulumi.set(__self__, "safi", safi)

    @_builtins.property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgs']]]]:
        """
        Address prefix
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgs']]]]):
        pulumi.set(self, "address_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def afi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Afi
        """
        return pulumi.get(self, "afi")

    @afi.setter
    def afi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "afi", value)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="fromPeers")
    def from_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        From peer
        """
        return pulumi.get(self, "from_peers")

    @from_peers.setter
    def from_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "from_peers", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthops")

    @nexthops.setter
    def nexthops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nexthops", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter
    def safi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Safi
        """
        return pulumi.get(self, "safi")

    @safi.setter
    def safi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "safi", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        exact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exact
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAddressPrefixArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 exact: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] exact: Exact
        """
        pulumi.set(__self__, "name", name)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exact
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchAsPathArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilterMatchExtendedCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        match: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgsDict']]
        """
        Match
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 match: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgs'] match: Match
        """
        pulumi.set(__self__, "name", name)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgsDict(TypedDict):
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgsDict']]]]
        """
        Address prefix
        """
        afi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Afi
        """
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgsDict']]
        """
        As path
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgsDict']]
        """
        Extended community
        """
        from_peers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        From peer
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Nexthop
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        safi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Safi
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchArgs:
    def __init__(__self__, *,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgs']]]] = None,
                 afi: Optional[pulumi.Input[_builtins.str]] = None,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgs']] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgs']] = None,
                 from_peers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 safi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgs']]] address_prefixes: Address prefix
        :param pulumi.Input[_builtins.str] afi: Afi
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgs'] as_path: As path
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] from_peers: From peer
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nexthops: Nexthop
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.str] safi: Safi
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if afi is not None:
            pulumi.set(__self__, "afi", afi)
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if from_peers is not None:
            pulumi.set(__self__, "from_peers", from_peers)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthops is not None:
            pulumi.set(__self__, "nexthops", nexthops)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if safi is not None:
            pulumi.set(__self__, "safi", safi)

    @_builtins.property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgs']]]]:
        """
        Address prefix
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgs']]]]):
        pulumi.set(self, "address_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def afi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Afi
        """
        return pulumi.get(self, "afi")

    @afi.setter
    def afi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "afi", value)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="fromPeers")
    def from_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        From peer
        """
        return pulumi.get(self, "from_peers")

    @from_peers.setter
    def from_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "from_peers", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthops")

    @nexthops.setter
    def nexthops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nexthops", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter
    def safi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Safi
        """
        return pulumi.get(self, "safi")

    @safi.setter
    def safi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "safi", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        exact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exact
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAddressPrefixArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 exact: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] exact: Exact
        """
        pulumi.set(__self__, "name", name)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exact
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchAsPathArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilterMatchExtendedCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleArgsDict']]]]
        """
        Rules
        """
elif False:
    LogicalRouterVrfBgpPolicyExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleArgs']]] rules: Rules
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleArgs']]]]:
        """
        Rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        action: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionArgsDict']]
        """
        Action
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        match: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchArgsDict']]
        """
        Match
        """
        used_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used by
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 match: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchArgs']] = None,
                 used_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionArgs'] action: Action
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchArgs'] match: Match
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] used_bies: Used by
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if used_bies is not None:
            pulumi.set(__self__, "used_bies", used_bies)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionArgs']]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter(name="usedBies")
    def used_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used by
        """
        return pulumi.get(self, "used_bies")

    @used_bies.setter
    def used_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "used_bies", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowArgsDict']]
        """
        Allow
        """
        deny: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionDenyArgsDict']]
        """
        Deny

        >  **Note:** You must specify exactly one of `allow` and `deny`.
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowArgs']] = None,
                 deny: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionDenyArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowArgs'] allow: Allow
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionDenyArgs'] deny: Deny
               
               >  **Note:** You must specify exactly one of `allow` and `deny`.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if deny is not None:
            pulumi.set(__self__, "deny", deny)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowArgs']]:
        """
        Allow
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def deny(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionDenyArgs']]:
        """
        Deny

        >  **Note:** You must specify exactly one of `allow` and `deny`.
        """
        return pulumi.get(self, "deny")

    @deny.setter
    def deny(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionDenyArgs']]):
        pulumi.set(self, "deny", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowArgsDict(TypedDict):
        update: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgsDict']]
        """
        Update
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowArgs:
    def __init__(__self__, *,
                 update: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgs'] update: Update
        """
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgs']]:
        """
        Update
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgs']]):
        pulumi.set(self, "update", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgsDict(TypedDict):
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgsDict']]
        """
        As path
        """
        as_path_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        As path limit
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgsDict']]
        """
        Extended community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local preference
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Nexthop
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateArgs:
    def __init__(__self__, *,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgs']] = None,
                 as_path_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgs']] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthop: Optional[pulumi.Input[_builtins.str]] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgs'] as_path: As path
        :param pulumi.Input[_builtins.int] as_path_limit: As path limit
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[_builtins.int] local_preference: Local preference
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[_builtins.str] nexthop: Nexthop
        :param pulumi.Input[_builtins.str] origin: Origin
        """
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if as_path_limit is not None:
            pulumi.set(__self__, "as_path_limit", as_path_limit)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter(name="asPathLimit")
    def as_path_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        As path limit
        """
        return pulumi.get(self, "as_path_limit")

    @as_path_limit.setter
    def as_path_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "as_path_limit", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgsDict(TypedDict):
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgsDict']]
        """
        None
        """
        prepend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        remove: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgsDict']]
        """
        Remove

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        remove_and_prepend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remove and prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathArgs:
    def __init__(__self__, *,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgs']] = None,
                 prepend: Optional[pulumi.Input[_builtins.int]] = None,
                 remove: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgs']] = None,
                 remove_and_prepend: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgs'] none: None
        :param pulumi.Input[_builtins.int] prepend: Prepend
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgs'] remove: Remove
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        :param pulumi.Input[_builtins.int] remove_and_prepend: Remove and prepend
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        if none is not None:
            pulumi.set(__self__, "none", none)
        if prepend is not None:
            pulumi.set(__self__, "prepend", prepend)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if remove_and_prepend is not None:
            pulumi.set(__self__, "remove_and_prepend", remove_and_prepend)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgs']]:
        """
        None
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def prepend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "prepend")

    @prepend.setter
    def prepend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prepend", value)

    @_builtins.property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgs']]:
        """
        Remove

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgs']]):
        pulumi.set(self, "remove", value)

    @_builtins.property
    @pulumi.getter(name="removeAndPrepend")
    def remove_and_prepend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remove and prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "remove_and_prepend")

    @remove_and_prepend.setter
    def remove_and_prepend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remove_and_prepend", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateAsPathRemoveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgsDict(TypedDict):
        appends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Append
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_all: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgsDict']]
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityArgs:
    def __init__(__self__, *,
                 appends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgs']] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_all: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgs']] = None,
                 remove_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] appends: Append
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overwrites: Overwrite
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgs'] remove_all: Remove all
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[_builtins.str] remove_regex: Remove regex
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)
        if remove_all is not None:
            pulumi.set(__self__, "remove_all", remove_all)
        if remove_regex is not None:
            pulumi.set(__self__, "remove_regex", remove_regex)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Append
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overwrites", value)

    @_builtins.property
    @pulumi.getter(name="removeAll")
    def remove_all(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgs']]:
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_all")

    @remove_all.setter
    def remove_all(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgs']]):
        pulumi.set(self, "remove_all", value)

    @_builtins.property
    @pulumi.getter(name="removeRegex")
    def remove_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_regex")

    @remove_regex.setter
    def remove_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateCommunityRemoveAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgsDict(TypedDict):
        appends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Append
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_all: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict']]
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityArgs:
    def __init__(__self__, *,
                 appends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgs']] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_all: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs']] = None,
                 remove_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] appends: Append
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overwrites: Overwrite
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs'] remove_all: Remove all
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[_builtins.str] remove_regex: Remove regex
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)
        if remove_all is not None:
            pulumi.set(__self__, "remove_all", remove_all)
        if remove_regex is not None:
            pulumi.set(__self__, "remove_regex", remove_regex)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Append
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overwrites", value)

    @_builtins.property
    @pulumi.getter(name="removeAll")
    def remove_all(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs']]:
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_all")

    @remove_all.setter
    def remove_all(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs']]):
        pulumi.set(self, "remove_all", value)

    @_builtins.property
    @pulumi.getter(name="removeRegex")
    def remove_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_regex")

    @remove_regex.setter
    def remove_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleActionDenyArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyExportRuleActionDenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleActionDenyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleMatchArgsDict(TypedDict):
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgsDict']]]]
        """
        Address prefix
        """
        afi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Afi
        """
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgsDict']]
        """
        As path
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgsDict']]
        """
        Extended community
        """
        from_peers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        From peer
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Nexthop
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        safi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Safi
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleMatchArgs:
    def __init__(__self__, *,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgs']]]] = None,
                 afi: Optional[pulumi.Input[_builtins.str]] = None,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgs']] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgs']] = None,
                 from_peers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 safi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgs']]] address_prefixes: Address prefix
        :param pulumi.Input[_builtins.str] afi: Afi
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgs'] as_path: As path
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] from_peers: From peer
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nexthops: Nexthop
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.str] safi: Safi
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if afi is not None:
            pulumi.set(__self__, "afi", afi)
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if from_peers is not None:
            pulumi.set(__self__, "from_peers", from_peers)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthops is not None:
            pulumi.set(__self__, "nexthops", nexthops)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if safi is not None:
            pulumi.set(__self__, "safi", safi)

    @_builtins.property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgs']]]]:
        """
        Address prefix
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgs']]]]):
        pulumi.set(self, "address_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def afi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Afi
        """
        return pulumi.get(self, "afi")

    @afi.setter
    def afi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "afi", value)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="fromPeers")
    def from_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        From peer
        """
        return pulumi.get(self, "from_peers")

    @from_peers.setter
    def from_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "from_peers", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthops")

    @nexthops.setter
    def nexthops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nexthops", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter
    def safi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Safi
        """
        return pulumi.get(self, "safi")

    @safi.setter
    def safi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "safi", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exact
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleMatchAddressPrefixArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] exact: Exact
        :param pulumi.Input[_builtins.str] name: Name
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exact
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleMatchAsPathArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleMatchCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyExportRuleMatchExtendedCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleArgsDict']]]]
        """
        Rules
        """
elif False:
    LogicalRouterVrfBgpPolicyImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleArgs']]] rules: Rules
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleArgs']]]]:
        """
        Rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        action: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionArgsDict']]
        """
        Action
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        match: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchArgsDict']]
        """
        Match
        """
        used_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used by
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 match: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchArgs']] = None,
                 used_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionArgs'] action: Action
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchArgs'] match: Match
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] used_bies: Used by
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if used_bies is not None:
            pulumi.set(__self__, "used_bies", used_bies)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionArgs']]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchArgs']]:
        """
        Match
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter(name="usedBies")
    def used_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used by
        """
        return pulumi.get(self, "used_bies")

    @used_bies.setter
    def used_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "used_bies", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowArgsDict']]
        """
        Allow
        """
        deny: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionDenyArgsDict']]
        """
        Deny

        >  **Note:** You must specify exactly one of `allow` and `deny`.
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowArgs']] = None,
                 deny: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionDenyArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowArgs'] allow: Allow
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionDenyArgs'] deny: Deny
               
               >  **Note:** You must specify exactly one of `allow` and `deny`.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if deny is not None:
            pulumi.set(__self__, "deny", deny)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowArgs']]:
        """
        Allow
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def deny(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionDenyArgs']]:
        """
        Deny

        >  **Note:** You must specify exactly one of `allow` and `deny`.
        """
        return pulumi.get(self, "deny")

    @deny.setter
    def deny(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionDenyArgs']]):
        pulumi.set(self, "deny", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowArgsDict(TypedDict):
        dampening: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dampening
        """
        update: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgsDict']]
        """
        Update
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowArgs:
    def __init__(__self__, *,
                 dampening: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] dampening: Dampening
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgs'] update: Update
        """
        if dampening is not None:
            pulumi.set(__self__, "dampening", dampening)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def dampening(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dampening
        """
        return pulumi.get(self, "dampening")

    @dampening.setter
    def dampening(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dampening", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgs']]:
        """
        Update
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgs']]):
        pulumi.set(self, "update", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgsDict(TypedDict):
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgsDict']]
        """
        As path
        """
        as_path_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        As path limit
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgsDict']]
        """
        Extended community
        """
        local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Local preference
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Nexthop
        """
        origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateArgs:
    def __init__(__self__, *,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgs']] = None,
                 as_path_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgs']] = None,
                 local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthop: Optional[pulumi.Input[_builtins.str]] = None,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgs'] as_path: As path
        :param pulumi.Input[_builtins.int] as_path_limit: As path limit
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[_builtins.int] local_preference: Local preference
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[_builtins.str] nexthop: Nexthop
        :param pulumi.Input[_builtins.str] origin: Origin
        :param pulumi.Input[_builtins.int] weight: Weight
        """
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if as_path_limit is not None:
            pulumi.set(__self__, "as_path_limit", as_path_limit)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter(name="asPathLimit")
    def as_path_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        As path limit
        """
        return pulumi.get(self, "as_path_limit")

    @as_path_limit.setter
    def as_path_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "as_path_limit", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Local preference
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_preference", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgsDict(TypedDict):
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgsDict']]
        """
        None
        """
        prepend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        remove: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgsDict']]
        """
        Remove

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        remove_and_prepend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Remove and prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathArgs:
    def __init__(__self__, *,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgs']] = None,
                 prepend: Optional[pulumi.Input[_builtins.int]] = None,
                 remove: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgs']] = None,
                 remove_and_prepend: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgs'] none: None
        :param pulumi.Input[_builtins.int] prepend: Prepend
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgs'] remove: Remove
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        :param pulumi.Input[_builtins.int] remove_and_prepend: Remove and prepend
               
               >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        if none is not None:
            pulumi.set(__self__, "none", none)
        if prepend is not None:
            pulumi.set(__self__, "prepend", prepend)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if remove_and_prepend is not None:
            pulumi.set(__self__, "remove_and_prepend", remove_and_prepend)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgs']]:
        """
        None
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def prepend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "prepend")

    @prepend.setter
    def prepend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prepend", value)

    @_builtins.property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgs']]:
        """
        Remove

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgs']]):
        pulumi.set(self, "remove", value)

    @_builtins.property
    @pulumi.getter(name="removeAndPrepend")
    def remove_and_prepend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Remove and prepend

        >  **Note:** You must specify exactly one of `none`, `prepend`, `remove`, and `remove_and_prepend`.
        """
        return pulumi.get(self, "remove_and_prepend")

    @remove_and_prepend.setter
    def remove_and_prepend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "remove_and_prepend", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateAsPathRemoveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgsDict(TypedDict):
        appends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Append
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_all: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgsDict']]
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityArgs:
    def __init__(__self__, *,
                 appends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgs']] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_all: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgs']] = None,
                 remove_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] appends: Append
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overwrites: Overwrite
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgs'] remove_all: Remove all
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[_builtins.str] remove_regex: Remove regex
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)
        if remove_all is not None:
            pulumi.set(__self__, "remove_all", remove_all)
        if remove_regex is not None:
            pulumi.set(__self__, "remove_regex", remove_regex)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Append
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overwrites", value)

    @_builtins.property
    @pulumi.getter(name="removeAll")
    def remove_all(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgs']]:
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_all")

    @remove_all.setter
    def remove_all(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgs']]):
        pulumi.set(self, "remove_all", value)

    @_builtins.property
    @pulumi.getter(name="removeRegex")
    def remove_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_regex")

    @remove_regex.setter
    def remove_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateCommunityRemoveAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgsDict(TypedDict):
        appends: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Append
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_all: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict']]
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        remove_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityArgs:
    def __init__(__self__, *,
                 appends: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgs']] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 remove_all: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs']] = None,
                 remove_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] appends: Append
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overwrites: Overwrite
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs'] remove_all: Remove all
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        :param pulumi.Input[_builtins.str] remove_regex: Remove regex
               
               >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)
        if remove_all is not None:
            pulumi.set(__self__, "remove_all", remove_all)
        if remove_regex is not None:
            pulumi.set(__self__, "remove_regex", remove_regex)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Append
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Overwrite

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overwrites", value)

    @_builtins.property
    @pulumi.getter(name="removeAll")
    def remove_all(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs']]:
        """
        Remove all

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_all")

    @remove_all.setter
    def remove_all(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs']]):
        pulumi.set(self, "remove_all", value)

    @_builtins.property
    @pulumi.getter(name="removeRegex")
    def remove_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remove regex

        >  **Note:** You must specify exactly one of `append`, `none`, `overwrite`, `remove_all`, and `remove_regex`.
        """
        return pulumi.get(self, "remove_regex")

    @remove_regex.setter
    def remove_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remove_regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionAllowUpdateExtendedCommunityRemoveAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleActionDenyArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfBgpPolicyImportRuleActionDenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleActionDenyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleMatchArgsDict(TypedDict):
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgsDict']]]]
        """
        Address prefix
        """
        afi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Afi
        """
        as_path: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgsDict']]
        """
        As path
        """
        community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgsDict']]
        """
        Community
        """
        extended_community: NotRequired[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgsDict']]
        """
        Extended community
        """
        from_peers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        From peer
        """
        med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Med
        """
        nexthops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Nexthop
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        safi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Safi
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleMatchArgs:
    def __init__(__self__, *,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgs']]]] = None,
                 afi: Optional[pulumi.Input[_builtins.str]] = None,
                 as_path: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgs']] = None,
                 community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgs']] = None,
                 extended_community: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgs']] = None,
                 from_peers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 med: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 safi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgs']]] address_prefixes: Address prefix
        :param pulumi.Input[_builtins.str] afi: Afi
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgs'] as_path: As path
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgs'] community: Community
        :param pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgs'] extended_community: Extended community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] from_peers: From peer
        :param pulumi.Input[_builtins.int] med: Med
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nexthops: Nexthop
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.str] safi: Safi
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if afi is not None:
            pulumi.set(__self__, "afi", afi)
        if as_path is not None:
            pulumi.set(__self__, "as_path", as_path)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if extended_community is not None:
            pulumi.set(__self__, "extended_community", extended_community)
        if from_peers is not None:
            pulumi.set(__self__, "from_peers", from_peers)
        if med is not None:
            pulumi.set(__self__, "med", med)
        if nexthops is not None:
            pulumi.set(__self__, "nexthops", nexthops)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if safi is not None:
            pulumi.set(__self__, "safi", safi)

    @_builtins.property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgs']]]]:
        """
        Address prefix
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgs']]]]):
        pulumi.set(self, "address_prefixes", value)

    @_builtins.property
    @pulumi.getter
    def afi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Afi
        """
        return pulumi.get(self, "afi")

    @afi.setter
    def afi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "afi", value)

    @_builtins.property
    @pulumi.getter(name="asPath")
    def as_path(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgs']]:
        """
        As path
        """
        return pulumi.get(self, "as_path")

    @as_path.setter
    def as_path(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgs']]):
        pulumi.set(self, "as_path", value)

    @_builtins.property
    @pulumi.getter
    def community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgs']]:
        """
        Community
        """
        return pulumi.get(self, "community")

    @community.setter
    def community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgs']]):
        pulumi.set(self, "community", value)

    @_builtins.property
    @pulumi.getter(name="extendedCommunity")
    def extended_community(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgs']]:
        """
        Extended community
        """
        return pulumi.get(self, "extended_community")

    @extended_community.setter
    def extended_community(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgs']]):
        pulumi.set(self, "extended_community", value)

    @_builtins.property
    @pulumi.getter(name="fromPeers")
    def from_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        From peer
        """
        return pulumi.get(self, "from_peers")

    @from_peers.setter
    def from_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "from_peers", value)

    @_builtins.property
    @pulumi.getter
    def med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Med
        """
        return pulumi.get(self, "med")

    @med.setter
    def med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "med", value)

    @_builtins.property
    @pulumi.getter
    def nexthops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthops")

    @nexthops.setter
    def nexthops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nexthops", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter
    def safi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Safi
        """
        return pulumi.get(self, "safi")

    @safi.setter
    def safi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "safi", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        exact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Exact
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleMatchAddressPrefixArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 exact: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] exact: Exact
        """
        pulumi.set(__self__, "name", name)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Exact
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleMatchAsPathArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleMatchCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex
        """
elif False:
    LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpPolicyImportRuleMatchExtendedCommunityArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] regex: Regex
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class LogicalRouterVrfBgpRedistRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        address_family_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address family identifier
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        route_table: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route table
        """
        set_as_path_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set as path limit
        """
        set_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set community
        """
        set_extended_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set extended community
        """
        set_local_preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set local preference
        """
        set_med: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set med
        """
        set_origin: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set origin
        """
elif False:
    LogicalRouterVrfBgpRedistRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpRedistRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 address_family_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 route_table: Optional[pulumi.Input[_builtins.str]] = None,
                 set_as_path_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 set_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 set_extended_communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 set_local_preference: Optional[pulumi.Input[_builtins.int]] = None,
                 set_med: Optional[pulumi.Input[_builtins.int]] = None,
                 set_origin: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] address_family_identifier: Address family identifier
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] route_table: Route table
        :param pulumi.Input[_builtins.int] set_as_path_limit: Set as path limit
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] set_communities: Set community
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] set_extended_communities: Set extended community
        :param pulumi.Input[_builtins.int] set_local_preference: Set local preference
        :param pulumi.Input[_builtins.int] set_med: Set med
        :param pulumi.Input[_builtins.str] set_origin: Set origin
        """
        pulumi.set(__self__, "name", name)
        if address_family_identifier is not None:
            pulumi.set(__self__, "address_family_identifier", address_family_identifier)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if set_as_path_limit is not None:
            pulumi.set(__self__, "set_as_path_limit", set_as_path_limit)
        if set_communities is not None:
            pulumi.set(__self__, "set_communities", set_communities)
        if set_extended_communities is not None:
            pulumi.set(__self__, "set_extended_communities", set_extended_communities)
        if set_local_preference is not None:
            pulumi.set(__self__, "set_local_preference", set_local_preference)
        if set_med is not None:
            pulumi.set(__self__, "set_med", set_med)
        if set_origin is not None:
            pulumi.set(__self__, "set_origin", set_origin)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="addressFamilyIdentifier")
    def address_family_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address family identifier
        """
        return pulumi.get(self, "address_family_identifier")

    @address_family_identifier.setter
    def address_family_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_family_identifier", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_table", value)

    @_builtins.property
    @pulumi.getter(name="setAsPathLimit")
    def set_as_path_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set as path limit
        """
        return pulumi.get(self, "set_as_path_limit")

    @set_as_path_limit.setter
    def set_as_path_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "set_as_path_limit", value)

    @_builtins.property
    @pulumi.getter(name="setCommunities")
    def set_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set community
        """
        return pulumi.get(self, "set_communities")

    @set_communities.setter
    def set_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "set_communities", value)

    @_builtins.property
    @pulumi.getter(name="setExtendedCommunities")
    def set_extended_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set extended community
        """
        return pulumi.get(self, "set_extended_communities")

    @set_extended_communities.setter
    def set_extended_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "set_extended_communities", value)

    @_builtins.property
    @pulumi.getter(name="setLocalPreference")
    def set_local_preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set local preference
        """
        return pulumi.get(self, "set_local_preference")

    @set_local_preference.setter
    def set_local_preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "set_local_preference", value)

    @_builtins.property
    @pulumi.getter(name="setMed")
    def set_med(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set med
        """
        return pulumi.get(self, "set_med")

    @set_med.setter
    def set_med(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "set_med", value)

    @_builtins.property
    @pulumi.getter(name="setOrigin")
    def set_origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set origin
        """
        return pulumi.get(self, "set_origin")

    @set_origin.setter
    def set_origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "set_origin", value)


if not MYPY:
    class LogicalRouterVrfBgpRedistributionProfileArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv4ArgsDict']]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv6ArgsDict']]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfBgpRedistributionProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpRedistributionProfileArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv6Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv4Args'] ipv4: Ipv4
        :param pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv6Args'] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv6Args']]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['LogicalRouterVrfBgpRedistributionProfileIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfBgpRedistributionProfileIpv4ArgsDict(TypedDict):
        unicast: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unicast
        """
elif False:
    LogicalRouterVrfBgpRedistributionProfileIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpRedistributionProfileIpv4Args:
    def __init__(__self__, *,
                 unicast: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] unicast: Unicast
        """
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfBgpRedistributionProfileIpv6ArgsDict(TypedDict):
        unicast: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unicast
        """
elif False:
    LogicalRouterVrfBgpRedistributionProfileIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfBgpRedistributionProfileIpv6Args:
    def __init__(__self__, *,
                 unicast: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] unicast: Unicast
        """
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfEcmpArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input['LogicalRouterVrfEcmpAlgorithmArgsDict']]
        """
        Algorithm
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        max_path: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max path
        """
        strict_source_path: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strict source path
        """
        symmetric_return: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Symmetric return
        """
elif False:
    LogicalRouterVrfEcmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_path: Optional[pulumi.Input[_builtins.int]] = None,
                 strict_source_path: Optional[pulumi.Input[_builtins.bool]] = None,
                 symmetric_return: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfEcmpAlgorithmArgs'] algorithm: Algorithm
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] max_path: Max path
        :param pulumi.Input[_builtins.bool] strict_source_path: Strict source path
        :param pulumi.Input[_builtins.bool] symmetric_return: Symmetric return
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_path is not None:
            pulumi.set(__self__, "max_path", max_path)
        if strict_source_path is not None:
            pulumi.set(__self__, "strict_source_path", strict_source_path)
        if symmetric_return is not None:
            pulumi.set(__self__, "symmetric_return", symmetric_return)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmArgs']]:
        """
        Algorithm
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmArgs']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maxPath")
    def max_path(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max path
        """
        return pulumi.get(self, "max_path")

    @max_path.setter
    def max_path(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_path", value)

    @_builtins.property
    @pulumi.getter(name="strictSourcePath")
    def strict_source_path(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strict source path
        """
        return pulumi.get(self, "strict_source_path")

    @strict_source_path.setter
    def strict_source_path(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strict_source_path", value)

    @_builtins.property
    @pulumi.getter(name="symmetricReturn")
    def symmetric_return(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Symmetric return
        """
        return pulumi.get(self, "symmetric_return")

    @symmetric_return.setter
    def symmetric_return(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "symmetric_return", value)


if not MYPY:
    class LogicalRouterVrfEcmpAlgorithmArgsDict(TypedDict):
        balanced_round_robin: NotRequired[pulumi.Input['LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgsDict']]
        """
        Balanced round robin
        """
        ip_hash: NotRequired[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpHashArgsDict']]
        """
        Ip hash

        >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
        ip_modulo: NotRequired[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpModuloArgsDict']]
        """
        Ip modulo

        >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
        weighted_round_robin: NotRequired[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgsDict']]
        """
        Weighted round robin

        >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
elif False:
    LogicalRouterVrfEcmpAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpAlgorithmArgs:
    def __init__(__self__, *,
                 balanced_round_robin: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgs']] = None,
                 ip_hash: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpHashArgs']] = None,
                 ip_modulo: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpModuloArgs']] = None,
                 weighted_round_robin: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgs'] balanced_round_robin: Balanced round robin
        :param pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpHashArgs'] ip_hash: Ip hash
               
               >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        :param pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpModuloArgs'] ip_modulo: Ip modulo
               
               >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        :param pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgs'] weighted_round_robin: Weighted round robin
               
               >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
        if balanced_round_robin is not None:
            pulumi.set(__self__, "balanced_round_robin", balanced_round_robin)
        if ip_hash is not None:
            pulumi.set(__self__, "ip_hash", ip_hash)
        if ip_modulo is not None:
            pulumi.set(__self__, "ip_modulo", ip_modulo)
        if weighted_round_robin is not None:
            pulumi.set(__self__, "weighted_round_robin", weighted_round_robin)

    @_builtins.property
    @pulumi.getter(name="balancedRoundRobin")
    def balanced_round_robin(self) -> Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgs']]:
        """
        Balanced round robin
        """
        return pulumi.get(self, "balanced_round_robin")

    @balanced_round_robin.setter
    def balanced_round_robin(self, value: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgs']]):
        pulumi.set(self, "balanced_round_robin", value)

    @_builtins.property
    @pulumi.getter(name="ipHash")
    def ip_hash(self) -> Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpHashArgs']]:
        """
        Ip hash

        >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
        return pulumi.get(self, "ip_hash")

    @ip_hash.setter
    def ip_hash(self, value: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpHashArgs']]):
        pulumi.set(self, "ip_hash", value)

    @_builtins.property
    @pulumi.getter(name="ipModulo")
    def ip_modulo(self) -> Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpModuloArgs']]:
        """
        Ip modulo

        >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
        return pulumi.get(self, "ip_modulo")

    @ip_modulo.setter
    def ip_modulo(self, value: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmIpModuloArgs']]):
        pulumi.set(self, "ip_modulo", value)

    @_builtins.property
    @pulumi.getter(name="weightedRoundRobin")
    def weighted_round_robin(self) -> Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgs']]:
        """
        Weighted round robin

        >  **Note:** You must specify exactly one of `balanced_round_robin`, `ip_hash`, `ip_modulo`, and `weighted_round_robin`.
        """
        return pulumi.get(self, "weighted_round_robin")

    @weighted_round_robin.setter
    def weighted_round_robin(self, value: Optional[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgs']]):
        pulumi.set(self, "weighted_round_robin", value)


if not MYPY:
    class LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfEcmpAlgorithmIpHashArgsDict(TypedDict):
        hash_seed: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hash seed
        """
        src_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Src only
        """
        use_port: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use port
        """
elif False:
    LogicalRouterVrfEcmpAlgorithmIpHashArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpAlgorithmIpHashArgs:
    def __init__(__self__, *,
                 hash_seed: Optional[pulumi.Input[_builtins.int]] = None,
                 src_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_port: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] hash_seed: Hash seed
        :param pulumi.Input[_builtins.bool] src_only: Src only
        :param pulumi.Input[_builtins.bool] use_port: Use port
        """
        if hash_seed is not None:
            pulumi.set(__self__, "hash_seed", hash_seed)
        if src_only is not None:
            pulumi.set(__self__, "src_only", src_only)
        if use_port is not None:
            pulumi.set(__self__, "use_port", use_port)

    @_builtins.property
    @pulumi.getter(name="hashSeed")
    def hash_seed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hash seed
        """
        return pulumi.get(self, "hash_seed")

    @hash_seed.setter
    def hash_seed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hash_seed", value)

    @_builtins.property
    @pulumi.getter(name="srcOnly")
    def src_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Src only
        """
        return pulumi.get(self, "src_only")

    @src_only.setter
    def src_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "src_only", value)

    @_builtins.property
    @pulumi.getter(name="usePort")
    def use_port(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use port
        """
        return pulumi.get(self, "use_port")

    @use_port.setter
    def use_port(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_port", value)


if not MYPY:
    class LogicalRouterVrfEcmpAlgorithmIpModuloArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfEcmpAlgorithmIpModuloArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpAlgorithmIpModuloArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgsDict(TypedDict):
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgsDict']]]]
        """
        Interface
        """
elif False:
    LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgs']]] interfaces: Interface
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgs']]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)


if not MYPY:
    class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight
        """
elif False:
    LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] weight: Weight
        """
        pulumi.set(__self__, "name", name)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LogicalRouterVrfMulticastArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        enable_v6: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable v6
        """
        igmp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastIgmpArgsDict']]
        """
        Igmp
        """
        interface_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupArgsDict']]]]
        """
        Interface group
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode
        """
        msdp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastMsdpArgsDict']]
        """
        Msdp
        """
        pim: NotRequired[pulumi.Input['LogicalRouterVrfMulticastPimArgsDict']]
        """
        Pim
        """
        route_ageout_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route ageout time
        """
        rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastRpArgsDict']]
        """
        Rp
        """
        spt_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSptThresholdArgsDict']]]]
        """
        Spt threshold
        """
        ssm_address_spaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSsmAddressSpaceArgsDict']]]]
        """
        Ssm address space
        """
        static_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastStaticRouteArgsDict']]]]
        """
        Static route
        """
elif False:
    LogicalRouterVrfMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_v6: Optional[pulumi.Input[_builtins.bool]] = None,
                 igmp: Optional[pulumi.Input['LogicalRouterVrfMulticastIgmpArgs']] = None,
                 interface_groups: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupArgs']]]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 msdp: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpArgs']] = None,
                 pim: Optional[pulumi.Input['LogicalRouterVrfMulticastPimArgs']] = None,
                 route_ageout_time: Optional[pulumi.Input[_builtins.int]] = None,
                 rp: Optional[pulumi.Input['LogicalRouterVrfMulticastRpArgs']] = None,
                 spt_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSptThresholdArgs']]]] = None,
                 ssm_address_spaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSsmAddressSpaceArgs']]]] = None,
                 static_routes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastStaticRouteArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.bool] enable_v6: Enable v6
        :param pulumi.Input['LogicalRouterVrfMulticastIgmpArgs'] igmp: Igmp
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupArgs']]] interface_groups: Interface group
        :param pulumi.Input[_builtins.str] mode: Mode
        :param pulumi.Input['LogicalRouterVrfMulticastMsdpArgs'] msdp: Msdp
        :param pulumi.Input['LogicalRouterVrfMulticastPimArgs'] pim: Pim
        :param pulumi.Input[_builtins.int] route_ageout_time: Route ageout time
        :param pulumi.Input['LogicalRouterVrfMulticastRpArgs'] rp: Rp
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSptThresholdArgs']]] spt_thresholds: Spt threshold
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSsmAddressSpaceArgs']]] ssm_address_spaces: Ssm address space
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastStaticRouteArgs']]] static_routes: Static route
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if enable_v6 is not None:
            pulumi.set(__self__, "enable_v6", enable_v6)
        if igmp is not None:
            pulumi.set(__self__, "igmp", igmp)
        if interface_groups is not None:
            pulumi.set(__self__, "interface_groups", interface_groups)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if msdp is not None:
            pulumi.set(__self__, "msdp", msdp)
        if pim is not None:
            pulumi.set(__self__, "pim", pim)
        if route_ageout_time is not None:
            pulumi.set(__self__, "route_ageout_time", route_ageout_time)
        if rp is not None:
            pulumi.set(__self__, "rp", rp)
        if spt_thresholds is not None:
            pulumi.set(__self__, "spt_thresholds", spt_thresholds)
        if ssm_address_spaces is not None:
            pulumi.set(__self__, "ssm_address_spaces", ssm_address_spaces)
        if static_routes is not None:
            pulumi.set(__self__, "static_routes", static_routes)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="enableV6")
    def enable_v6(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable v6
        """
        return pulumi.get(self, "enable_v6")

    @enable_v6.setter
    def enable_v6(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_v6", value)

    @_builtins.property
    @pulumi.getter
    def igmp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastIgmpArgs']]:
        """
        Igmp
        """
        return pulumi.get(self, "igmp")

    @igmp.setter
    def igmp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastIgmpArgs']]):
        pulumi.set(self, "igmp", value)

    @_builtins.property
    @pulumi.getter(name="interfaceGroups")
    def interface_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupArgs']]]]:
        """
        Interface group
        """
        return pulumi.get(self, "interface_groups")

    @interface_groups.setter
    def interface_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupArgs']]]]):
        pulumi.set(self, "interface_groups", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def msdp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpArgs']]:
        """
        Msdp
        """
        return pulumi.get(self, "msdp")

    @msdp.setter
    def msdp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpArgs']]):
        pulumi.set(self, "msdp", value)

    @_builtins.property
    @pulumi.getter
    def pim(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastPimArgs']]:
        """
        Pim
        """
        return pulumi.get(self, "pim")

    @pim.setter
    def pim(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastPimArgs']]):
        pulumi.set(self, "pim", value)

    @_builtins.property
    @pulumi.getter(name="routeAgeoutTime")
    def route_ageout_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route ageout time
        """
        return pulumi.get(self, "route_ageout_time")

    @route_ageout_time.setter
    def route_ageout_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "route_ageout_time", value)

    @_builtins.property
    @pulumi.getter
    def rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastRpArgs']]:
        """
        Rp
        """
        return pulumi.get(self, "rp")

    @rp.setter
    def rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastRpArgs']]):
        pulumi.set(self, "rp", value)

    @_builtins.property
    @pulumi.getter(name="sptThresholds")
    def spt_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSptThresholdArgs']]]]:
        """
        Spt threshold
        """
        return pulumi.get(self, "spt_thresholds")

    @spt_thresholds.setter
    def spt_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSptThresholdArgs']]]]):
        pulumi.set(self, "spt_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="ssmAddressSpaces")
    def ssm_address_spaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSsmAddressSpaceArgs']]]]:
        """
        Ssm address space
        """
        return pulumi.get(self, "ssm_address_spaces")

    @ssm_address_spaces.setter
    def ssm_address_spaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastSsmAddressSpaceArgs']]]]):
        pulumi.set(self, "ssm_address_spaces", value)

    @_builtins.property
    @pulumi.getter(name="staticRoutes")
    def static_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastStaticRouteArgs']]]]:
        """
        Static route
        """
        return pulumi.get(self, "static_routes")

    @static_routes.setter
    def static_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastStaticRouteArgs']]]]):
        pulumi.set(self, "static_routes", value)


if not MYPY:
    class LogicalRouterVrfMulticastIgmpArgsDict(TypedDict):
        dynamic: NotRequired[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicArgsDict']]
        """
        Dynamic
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        statics: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpStaticArgsDict']]]]
        """
        Static
        """
elif False:
    LogicalRouterVrfMulticastIgmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastIgmpArgs:
    def __init__(__self__, *,
                 dynamic: Optional[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpStaticArgs']]]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicArgs'] dynamic: Dynamic
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpStaticArgs']]] statics: Static
        """
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicArgs']]:
        """
        Dynamic
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicArgs']]):
        pulumi.set(self, "dynamic", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpStaticArgs']]]]:
        """
        Static
        """
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpStaticArgs']]]]):
        pulumi.set(self, "statics", value)


if not MYPY:
    class LogicalRouterVrfMulticastIgmpDynamicArgsDict(TypedDict):
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicInterfaceArgsDict']]]]
        """
        Interface
        """
elif False:
    LogicalRouterVrfMulticastIgmpDynamicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastIgmpDynamicArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicInterfaceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicInterfaceArgs']]] interfaces: Interface
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicInterfaceArgs']]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastIgmpDynamicInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)


if not MYPY:
    class LogicalRouterVrfMulticastIgmpDynamicInterfaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        group_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group filter
        """
        max_groups: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max groups
        """
        max_sources: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max sources
        """
        query_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Query profile
        """
        robustness: NotRequired[pulumi.Input[_builtins.str]]
        """
        Robustness
        """
        router_alert_policing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Router alert policing
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version
        """
elif False:
    LogicalRouterVrfMulticastIgmpDynamicInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastIgmpDynamicInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 max_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 max_sources: Optional[pulumi.Input[_builtins.str]] = None,
                 query_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 robustness: Optional[pulumi.Input[_builtins.str]] = None,
                 router_alert_policing: Optional[pulumi.Input[_builtins.bool]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] group_filter: Group filter
        :param pulumi.Input[_builtins.str] max_groups: Max groups
        :param pulumi.Input[_builtins.str] max_sources: Max sources
        :param pulumi.Input[_builtins.str] query_profile: Query profile
        :param pulumi.Input[_builtins.str] robustness: Robustness
        :param pulumi.Input[_builtins.bool] router_alert_policing: Router alert policing
        :param pulumi.Input[_builtins.str] version: Version
        """
        pulumi.set(__self__, "name", name)
        if group_filter is not None:
            pulumi.set(__self__, "group_filter", group_filter)
        if max_groups is not None:
            pulumi.set(__self__, "max_groups", max_groups)
        if max_sources is not None:
            pulumi.set(__self__, "max_sources", max_sources)
        if query_profile is not None:
            pulumi.set(__self__, "query_profile", query_profile)
        if robustness is not None:
            pulumi.set(__self__, "robustness", robustness)
        if router_alert_policing is not None:
            pulumi.set(__self__, "router_alert_policing", router_alert_policing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="groupFilter")
    def group_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group filter
        """
        return pulumi.get(self, "group_filter")

    @group_filter.setter
    def group_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_filter", value)

    @_builtins.property
    @pulumi.getter(name="maxGroups")
    def max_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max groups
        """
        return pulumi.get(self, "max_groups")

    @max_groups.setter
    def max_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_groups", value)

    @_builtins.property
    @pulumi.getter(name="maxSources")
    def max_sources(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max sources
        """
        return pulumi.get(self, "max_sources")

    @max_sources.setter
    def max_sources(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_sources", value)

    @_builtins.property
    @pulumi.getter(name="queryProfile")
    def query_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Query profile
        """
        return pulumi.get(self, "query_profile")

    @query_profile.setter
    def query_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_profile", value)

    @_builtins.property
    @pulumi.getter
    def robustness(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Robustness
        """
        return pulumi.get(self, "robustness")

    @robustness.setter
    def robustness(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "robustness", value)

    @_builtins.property
    @pulumi.getter(name="routerAlertPolicing")
    def router_alert_policing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Router alert policing
        """
        return pulumi.get(self, "router_alert_policing")

    @router_alert_policing.setter
    def router_alert_policing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "router_alert_policing", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class LogicalRouterVrfMulticastIgmpStaticArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        group_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source address
        """
elif False:
    LogicalRouterVrfMulticastIgmpStaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastIgmpStaticArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group_address: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] group_address: Group address
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.str] source_address: Source address
        """
        pulumi.set(__self__, "name", name)
        if group_address is not None:
            pulumi.set(__self__, "group_address", group_address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="groupAddress")
    def group_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group address
        """
        return pulumi.get(self, "group_address")

    @group_address.setter
    def group_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        group_permission: NotRequired[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgsDict']]
        """
        Group permission
        """
        igmp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupIgmpArgsDict']]
        """
        Igmp
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Interface
        """
        pim: NotRequired[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimArgsDict']]
        """
        Pim
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_permission: Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgs']] = None,
                 igmp: Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupIgmpArgs']] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pim: Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgs'] group_permission: Group permission
        :param pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupIgmpArgs'] igmp: Igmp
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interfaces: Interface
        :param pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimArgs'] pim: Pim
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_permission is not None:
            pulumi.set(__self__, "group_permission", group_permission)
        if igmp is not None:
            pulumi.set(__self__, "igmp", igmp)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if pim is not None:
            pulumi.set(__self__, "pim", pim)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="groupPermission")
    def group_permission(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgs']]:
        """
        Group permission
        """
        return pulumi.get(self, "group_permission")

    @group_permission.setter
    def group_permission(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgs']]):
        pulumi.set(self, "group_permission", value)

    @_builtins.property
    @pulumi.getter
    def igmp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupIgmpArgs']]:
        """
        Igmp
        """
        return pulumi.get(self, "igmp")

    @igmp.setter
    def igmp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupIgmpArgs']]):
        pulumi.set(self, "igmp", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def pim(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimArgs']]:
        """
        Pim
        """
        return pulumi.get(self, "pim")

    @pim.setter
    def pim(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimArgs']]):
        pulumi.set(self, "pim", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgsDict(TypedDict):
        any_source_multicasts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgsDict']]]]
        """
        Any source multicast
        """
        source_specific_multicasts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgsDict']]]]
        """
        Source specific multicast
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionArgs:
    def __init__(__self__, *,
                 any_source_multicasts: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgs']]]] = None,
                 source_specific_multicasts: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgs']]] any_source_multicasts: Any source multicast
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgs']]] source_specific_multicasts: Source specific multicast
        """
        if any_source_multicasts is not None:
            pulumi.set(__self__, "any_source_multicasts", any_source_multicasts)
        if source_specific_multicasts is not None:
            pulumi.set(__self__, "source_specific_multicasts", source_specific_multicasts)

    @_builtins.property
    @pulumi.getter(name="anySourceMulticasts")
    def any_source_multicasts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgs']]]]:
        """
        Any source multicast
        """
        return pulumi.get(self, "any_source_multicasts")

    @any_source_multicasts.setter
    def any_source_multicasts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgs']]]]):
        pulumi.set(self, "any_source_multicasts", value)

    @_builtins.property
    @pulumi.getter(name="sourceSpecificMulticasts")
    def source_specific_multicasts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgs']]]]:
        """
        Source specific multicast
        """
        return pulumi.get(self, "source_specific_multicasts")

    @source_specific_multicasts.setter
    def source_specific_multicasts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgs']]]]):
        pulumi.set(self, "source_specific_multicasts", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        group_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group address
        """
        included: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Included
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group_address: Optional[pulumi.Input[_builtins.str]] = None,
                 included: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] group_address: Group address
        :param pulumi.Input[_builtins.bool] included: Included
        """
        pulumi.set(__self__, "name", name)
        if group_address is not None:
            pulumi.set(__self__, "group_address", group_address)
        if included is not None:
            pulumi.set(__self__, "included", included)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="groupAddress")
    def group_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group address
        """
        return pulumi.get(self, "group_address")

    @group_address.setter
    def group_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_address", value)

    @_builtins.property
    @pulumi.getter
    def included(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Included
        """
        return pulumi.get(self, "included")

    @included.setter
    def included(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "included", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        group_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group address
        """
        included: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Included
        """
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source address
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group_address: Optional[pulumi.Input[_builtins.str]] = None,
                 included: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] group_address: Group address
        :param pulumi.Input[_builtins.bool] included: Included
        :param pulumi.Input[_builtins.str] source_address: Source address
        """
        pulumi.set(__self__, "name", name)
        if group_address is not None:
            pulumi.set(__self__, "group_address", group_address)
        if included is not None:
            pulumi.set(__self__, "included", included)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="groupAddress")
    def group_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group address
        """
        return pulumi.get(self, "group_address")

    @group_address.setter
    def group_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_address", value)

    @_builtins.property
    @pulumi.getter
    def included(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Included
        """
        return pulumi.get(self, "included")

    @included.setter
    def included(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "included", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupIgmpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        immediate_leave: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Immediate leave
        """
        last_member_query_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Last member query interval
        """
        max_groups: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max groups
        """
        max_query_response_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max query response time
        """
        max_sources: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max sources
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode
        """
        query_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Query interval
        """
        robustness: NotRequired[pulumi.Input[_builtins.str]]
        """
        Robustness
        """
        router_alert_policing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Router alert policing
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupIgmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupIgmpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 immediate_leave: Optional[pulumi.Input[_builtins.bool]] = None,
                 last_member_query_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 max_groups: Optional[pulumi.Input[_builtins.str]] = None,
                 max_query_response_time: Optional[pulumi.Input[_builtins.int]] = None,
                 max_sources: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 query_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 robustness: Optional[pulumi.Input[_builtins.str]] = None,
                 router_alert_policing: Optional[pulumi.Input[_builtins.bool]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.bool] immediate_leave: Immediate leave
        :param pulumi.Input[_builtins.int] last_member_query_interval: Last member query interval
        :param pulumi.Input[_builtins.str] max_groups: Max groups
        :param pulumi.Input[_builtins.int] max_query_response_time: Max query response time
        :param pulumi.Input[_builtins.str] max_sources: Max sources
        :param pulumi.Input[_builtins.str] mode: Mode
        :param pulumi.Input[_builtins.int] query_interval: Query interval
        :param pulumi.Input[_builtins.str] robustness: Robustness
        :param pulumi.Input[_builtins.bool] router_alert_policing: Router alert policing
        :param pulumi.Input[_builtins.str] version: Version
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if immediate_leave is not None:
            pulumi.set(__self__, "immediate_leave", immediate_leave)
        if last_member_query_interval is not None:
            pulumi.set(__self__, "last_member_query_interval", last_member_query_interval)
        if max_groups is not None:
            pulumi.set(__self__, "max_groups", max_groups)
        if max_query_response_time is not None:
            pulumi.set(__self__, "max_query_response_time", max_query_response_time)
        if max_sources is not None:
            pulumi.set(__self__, "max_sources", max_sources)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if query_interval is not None:
            pulumi.set(__self__, "query_interval", query_interval)
        if robustness is not None:
            pulumi.set(__self__, "robustness", robustness)
        if router_alert_policing is not None:
            pulumi.set(__self__, "router_alert_policing", router_alert_policing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="immediateLeave")
    def immediate_leave(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Immediate leave
        """
        return pulumi.get(self, "immediate_leave")

    @immediate_leave.setter
    def immediate_leave(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "immediate_leave", value)

    @_builtins.property
    @pulumi.getter(name="lastMemberQueryInterval")
    def last_member_query_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Last member query interval
        """
        return pulumi.get(self, "last_member_query_interval")

    @last_member_query_interval.setter
    def last_member_query_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_member_query_interval", value)

    @_builtins.property
    @pulumi.getter(name="maxGroups")
    def max_groups(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max groups
        """
        return pulumi.get(self, "max_groups")

    @max_groups.setter
    def max_groups(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_groups", value)

    @_builtins.property
    @pulumi.getter(name="maxQueryResponseTime")
    def max_query_response_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max query response time
        """
        return pulumi.get(self, "max_query_response_time")

    @max_query_response_time.setter
    def max_query_response_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_query_response_time", value)

    @_builtins.property
    @pulumi.getter(name="maxSources")
    def max_sources(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max sources
        """
        return pulumi.get(self, "max_sources")

    @max_sources.setter
    def max_sources(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_sources", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="queryInterval")
    def query_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Query interval
        """
        return pulumi.get(self, "query_interval")

    @query_interval.setter
    def query_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "query_interval", value)

    @_builtins.property
    @pulumi.getter
    def robustness(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Robustness
        """
        return pulumi.get(self, "robustness")

    @robustness.setter
    def robustness(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "robustness", value)

    @_builtins.property
    @pulumi.getter(name="routerAlertPolicing")
    def router_alert_policing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Router alert policing
        """
        return pulumi.get(self, "router_alert_policing")

    @router_alert_policing.setter
    def router_alert_policing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "router_alert_policing", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupPimArgsDict(TypedDict):
        allowed_neighbors: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgsDict']]]]
        """
        Allowed neighbors
        """
        assert_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Assert interval
        """
        bsr_border: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Bsr border
        """
        dr_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dr priority
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        hello_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hello interval
        """
        join_prune_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Join prune interval
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupPimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupPimArgs:
    def __init__(__self__, *,
                 allowed_neighbors: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgs']]]] = None,
                 assert_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 bsr_border: Optional[pulumi.Input[_builtins.bool]] = None,
                 dr_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 hello_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 join_prune_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgs']]] allowed_neighbors: Allowed neighbors
        :param pulumi.Input[_builtins.int] assert_interval: Assert interval
        :param pulumi.Input[_builtins.bool] bsr_border: Bsr border
        :param pulumi.Input[_builtins.int] dr_priority: Dr priority
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] hello_interval: Hello interval
        :param pulumi.Input[_builtins.int] join_prune_interval: Join prune interval
        """
        if allowed_neighbors is not None:
            pulumi.set(__self__, "allowed_neighbors", allowed_neighbors)
        if assert_interval is not None:
            pulumi.set(__self__, "assert_interval", assert_interval)
        if bsr_border is not None:
            pulumi.set(__self__, "bsr_border", bsr_border)
        if dr_priority is not None:
            pulumi.set(__self__, "dr_priority", dr_priority)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if join_prune_interval is not None:
            pulumi.set(__self__, "join_prune_interval", join_prune_interval)

    @_builtins.property
    @pulumi.getter(name="allowedNeighbors")
    def allowed_neighbors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgs']]]]:
        """
        Allowed neighbors
        """
        return pulumi.get(self, "allowed_neighbors")

    @allowed_neighbors.setter
    def allowed_neighbors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgs']]]]):
        pulumi.set(self, "allowed_neighbors", value)

    @_builtins.property
    @pulumi.getter(name="assertInterval")
    def assert_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Assert interval
        """
        return pulumi.get(self, "assert_interval")

    @assert_interval.setter
    def assert_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "assert_interval", value)

    @_builtins.property
    @pulumi.getter(name="bsrBorder")
    def bsr_border(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Bsr border
        """
        return pulumi.get(self, "bsr_border")

    @bsr_border.setter
    def bsr_border(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bsr_border", value)

    @_builtins.property
    @pulumi.getter(name="drPriority")
    def dr_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dr priority
        """
        return pulumi.get(self, "dr_priority")

    @dr_priority.setter
    def dr_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dr_priority", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hello interval
        """
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hello_interval", value)

    @_builtins.property
    @pulumi.getter(name="joinPruneInterval")
    def join_prune_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Join prune interval
        """
        return pulumi.get(self, "join_prune_interval")

    @join_prune_interval.setter
    def join_prune_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "join_prune_interval", value)


if not MYPY:
    class LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
elif False:
    LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LogicalRouterVrfMulticastMsdpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        global_authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global authentication
        """
        global_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global timer
        """
        originator_id: NotRequired[pulumi.Input['LogicalRouterVrfMulticastMsdpOriginatorIdArgsDict']]
        """
        Originator id
        """
        peers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerArgsDict']]]]
        """
        Peer
        """
elif False:
    LogicalRouterVrfMulticastMsdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastMsdpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 global_authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 global_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 originator_id: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpOriginatorIdArgs']] = None,
                 peers: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] global_authentication: Global authentication
        :param pulumi.Input[_builtins.str] global_timer: Global timer
        :param pulumi.Input['LogicalRouterVrfMulticastMsdpOriginatorIdArgs'] originator_id: Originator id
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerArgs']]] peers: Peer
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if global_authentication is not None:
            pulumi.set(__self__, "global_authentication", global_authentication)
        if global_timer is not None:
            pulumi.set(__self__, "global_timer", global_timer)
        if originator_id is not None:
            pulumi.set(__self__, "originator_id", originator_id)
        if peers is not None:
            pulumi.set(__self__, "peers", peers)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="globalAuthentication")
    def global_authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global authentication
        """
        return pulumi.get(self, "global_authentication")

    @global_authentication.setter
    def global_authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_authentication", value)

    @_builtins.property
    @pulumi.getter(name="globalTimer")
    def global_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global timer
        """
        return pulumi.get(self, "global_timer")

    @global_timer.setter
    def global_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_timer", value)

    @_builtins.property
    @pulumi.getter(name="originatorId")
    def originator_id(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpOriginatorIdArgs']]:
        """
        Originator id
        """
        return pulumi.get(self, "originator_id")

    @originator_id.setter
    def originator_id(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpOriginatorIdArgs']]):
        pulumi.set(self, "originator_id", value)

    @_builtins.property
    @pulumi.getter
    def peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerArgs']]]]:
        """
        Peer
        """
        return pulumi.get(self, "peers")

    @peers.setter
    def peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerArgs']]]]):
        pulumi.set(self, "peers", value)


if not MYPY:
    class LogicalRouterVrfMulticastMsdpOriginatorIdArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip
        """
elif False:
    LogicalRouterVrfMulticastMsdpOriginatorIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastMsdpOriginatorIdArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.str] ip: Ip
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class LogicalRouterVrfMulticastMsdpPeerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        inbound_sa_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound sa filter
        """
        local_address: NotRequired[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerLocalAddressArgsDict']]
        """
        Local address
        """
        max_sa: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max sa
        """
        outbound_sa_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound sa filter
        """
        peer_address: NotRequired[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerPeerAddressArgsDict']]
        """
        Peer address
        """
        peer_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer as
        """
elif False:
    LogicalRouterVrfMulticastMsdpPeerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastMsdpPeerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 inbound_sa_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 local_address: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerLocalAddressArgs']] = None,
                 max_sa: Optional[pulumi.Input[_builtins.int]] = None,
                 outbound_sa_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_address: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerPeerAddressArgs']] = None,
                 peer_as: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] inbound_sa_filter: Inbound sa filter
        :param pulumi.Input['LogicalRouterVrfMulticastMsdpPeerLocalAddressArgs'] local_address: Local address
        :param pulumi.Input[_builtins.int] max_sa: Max sa
        :param pulumi.Input[_builtins.str] outbound_sa_filter: Outbound sa filter
        :param pulumi.Input['LogicalRouterVrfMulticastMsdpPeerPeerAddressArgs'] peer_address: Peer address
        :param pulumi.Input[_builtins.str] peer_as: Peer as
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if inbound_sa_filter is not None:
            pulumi.set(__self__, "inbound_sa_filter", inbound_sa_filter)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if max_sa is not None:
            pulumi.set(__self__, "max_sa", max_sa)
        if outbound_sa_filter is not None:
            pulumi.set(__self__, "outbound_sa_filter", outbound_sa_filter)
        if peer_address is not None:
            pulumi.set(__self__, "peer_address", peer_address)
        if peer_as is not None:
            pulumi.set(__self__, "peer_as", peer_as)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="inboundSaFilter")
    def inbound_sa_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound sa filter
        """
        return pulumi.get(self, "inbound_sa_filter")

    @inbound_sa_filter.setter
    def inbound_sa_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_sa_filter", value)

    @_builtins.property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerLocalAddressArgs']]:
        """
        Local address
        """
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerLocalAddressArgs']]):
        pulumi.set(self, "local_address", value)

    @_builtins.property
    @pulumi.getter(name="maxSa")
    def max_sa(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max sa
        """
        return pulumi.get(self, "max_sa")

    @max_sa.setter
    def max_sa(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_sa", value)

    @_builtins.property
    @pulumi.getter(name="outboundSaFilter")
    def outbound_sa_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound sa filter
        """
        return pulumi.get(self, "outbound_sa_filter")

    @outbound_sa_filter.setter
    def outbound_sa_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_sa_filter", value)

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerPeerAddressArgs']]:
        """
        Peer address
        """
        return pulumi.get(self, "peer_address")

    @peer_address.setter
    def peer_address(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastMsdpPeerPeerAddressArgs']]):
        pulumi.set(self, "peer_address", value)

    @_builtins.property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer as
        """
        return pulumi.get(self, "peer_as")

    @peer_as.setter
    def peer_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_as", value)


if not MYPY:
    class LogicalRouterVrfMulticastMsdpPeerLocalAddressArgsDict(TypedDict):
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip
        """
elif False:
    LogicalRouterVrfMulticastMsdpPeerLocalAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastMsdpPeerLocalAddressArgs:
    def __init__(__self__, *,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.str] ip: Ip
        """
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class LogicalRouterVrfMulticastMsdpPeerPeerAddressArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fqdn
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip

        >  **Note:** You must specify exactly one of `fqdn` and `ip`.
        """
elif False:
    LogicalRouterVrfMulticastMsdpPeerPeerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastMsdpPeerPeerAddressArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: Fqdn
        :param pulumi.Input[_builtins.str] ip: Ip
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fqdn
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip

        >  **Note:** You must specify exactly one of `fqdn` and `ip`.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        group_permission: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group permission
        """
        if_timer_global: NotRequired[pulumi.Input[_builtins.str]]
        """
        If timer global
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimInterfaceArgsDict']]]]
        """
        Interface
        """
        route_ageout_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route ageout time
        """
        rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastPimRpArgsDict']]
        """
        Rp
        """
        rpf_lookup_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rpf lookup mode
        """
        spt_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimSptThresholdArgsDict']]]]
        """
        Spt threshold
        """
        ssm_address_space: NotRequired[pulumi.Input['LogicalRouterVrfMulticastPimSsmAddressSpaceArgsDict']]
        """
        Ssm address space
        """
elif False:
    LogicalRouterVrfMulticastPimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 group_permission: Optional[pulumi.Input[_builtins.str]] = None,
                 if_timer_global: Optional[pulumi.Input[_builtins.str]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimInterfaceArgs']]]] = None,
                 route_ageout_time: Optional[pulumi.Input[_builtins.int]] = None,
                 rp: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpArgs']] = None,
                 rpf_lookup_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 spt_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimSptThresholdArgs']]]] = None,
                 ssm_address_space: Optional[pulumi.Input['LogicalRouterVrfMulticastPimSsmAddressSpaceArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] group_permission: Group permission
        :param pulumi.Input[_builtins.str] if_timer_global: If timer global
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimInterfaceArgs']]] interfaces: Interface
        :param pulumi.Input[_builtins.int] route_ageout_time: Route ageout time
        :param pulumi.Input['LogicalRouterVrfMulticastPimRpArgs'] rp: Rp
        :param pulumi.Input[_builtins.str] rpf_lookup_mode: Rpf lookup mode
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimSptThresholdArgs']]] spt_thresholds: Spt threshold
        :param pulumi.Input['LogicalRouterVrfMulticastPimSsmAddressSpaceArgs'] ssm_address_space: Ssm address space
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if group_permission is not None:
            pulumi.set(__self__, "group_permission", group_permission)
        if if_timer_global is not None:
            pulumi.set(__self__, "if_timer_global", if_timer_global)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if route_ageout_time is not None:
            pulumi.set(__self__, "route_ageout_time", route_ageout_time)
        if rp is not None:
            pulumi.set(__self__, "rp", rp)
        if rpf_lookup_mode is not None:
            pulumi.set(__self__, "rpf_lookup_mode", rpf_lookup_mode)
        if spt_thresholds is not None:
            pulumi.set(__self__, "spt_thresholds", spt_thresholds)
        if ssm_address_space is not None:
            pulumi.set(__self__, "ssm_address_space", ssm_address_space)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="groupPermission")
    def group_permission(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group permission
        """
        return pulumi.get(self, "group_permission")

    @group_permission.setter
    def group_permission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_permission", value)

    @_builtins.property
    @pulumi.getter(name="ifTimerGlobal")
    def if_timer_global(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If timer global
        """
        return pulumi.get(self, "if_timer_global")

    @if_timer_global.setter
    def if_timer_global(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_timer_global", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimInterfaceArgs']]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter(name="routeAgeoutTime")
    def route_ageout_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route ageout time
        """
        return pulumi.get(self, "route_ageout_time")

    @route_ageout_time.setter
    def route_ageout_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "route_ageout_time", value)

    @_builtins.property
    @pulumi.getter
    def rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpArgs']]:
        """
        Rp
        """
        return pulumi.get(self, "rp")

    @rp.setter
    def rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpArgs']]):
        pulumi.set(self, "rp", value)

    @_builtins.property
    @pulumi.getter(name="rpfLookupMode")
    def rpf_lookup_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rpf lookup mode
        """
        return pulumi.get(self, "rpf_lookup_mode")

    @rpf_lookup_mode.setter
    def rpf_lookup_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rpf_lookup_mode", value)

    @_builtins.property
    @pulumi.getter(name="sptThresholds")
    def spt_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimSptThresholdArgs']]]]:
        """
        Spt threshold
        """
        return pulumi.get(self, "spt_thresholds")

    @spt_thresholds.setter
    def spt_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimSptThresholdArgs']]]]):
        pulumi.set(self, "spt_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="ssmAddressSpace")
    def ssm_address_space(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastPimSsmAddressSpaceArgs']]:
        """
        Ssm address space
        """
        return pulumi.get(self, "ssm_address_space")

    @ssm_address_space.setter
    def ssm_address_space(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastPimSsmAddressSpaceArgs']]):
        pulumi.set(self, "ssm_address_space", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimInterfaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        dr_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dr priority
        """
        if_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        If timer
        """
        neighbor_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Neighbor filter
        """
        send_bsm: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Send bsm
        """
elif False:
    LogicalRouterVrfMulticastPimInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dr_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 if_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 neighbor_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 send_bsm: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[_builtins.int] dr_priority: Dr priority
        :param pulumi.Input[_builtins.str] if_timer: If timer
        :param pulumi.Input[_builtins.str] neighbor_filter: Neighbor filter
        :param pulumi.Input[_builtins.bool] send_bsm: Send bsm
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dr_priority is not None:
            pulumi.set(__self__, "dr_priority", dr_priority)
        if if_timer is not None:
            pulumi.set(__self__, "if_timer", if_timer)
        if neighbor_filter is not None:
            pulumi.set(__self__, "neighbor_filter", neighbor_filter)
        if send_bsm is not None:
            pulumi.set(__self__, "send_bsm", send_bsm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="drPriority")
    def dr_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dr priority
        """
        return pulumi.get(self, "dr_priority")

    @dr_priority.setter
    def dr_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dr_priority", value)

    @_builtins.property
    @pulumi.getter(name="ifTimer")
    def if_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If timer
        """
        return pulumi.get(self, "if_timer")

    @if_timer.setter
    def if_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_timer", value)

    @_builtins.property
    @pulumi.getter(name="neighborFilter")
    def neighbor_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Neighbor filter
        """
        return pulumi.get(self, "neighbor_filter")

    @neighbor_filter.setter
    def neighbor_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "neighbor_filter", value)

    @_builtins.property
    @pulumi.getter(name="sendBsm")
    def send_bsm(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Send bsm
        """
        return pulumi.get(self, "send_bsm")

    @send_bsm.setter
    def send_bsm(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_bsm", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimRpArgsDict(TypedDict):
        external_rps: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimRpExternalRpArgsDict']]]]
        """
        External rp
        """
        local_rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpArgsDict']]
        """
        Local rp
        """
elif False:
    LogicalRouterVrfMulticastPimRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimRpArgs:
    def __init__(__self__, *,
                 external_rps: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimRpExternalRpArgs']]]] = None,
                 local_rp: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimRpExternalRpArgs']]] external_rps: External rp
        :param pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpArgs'] local_rp: Local rp
        """
        if external_rps is not None:
            pulumi.set(__self__, "external_rps", external_rps)
        if local_rp is not None:
            pulumi.set(__self__, "local_rp", local_rp)

    @_builtins.property
    @pulumi.getter(name="externalRps")
    def external_rps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimRpExternalRpArgs']]]]:
        """
        External rp
        """
        return pulumi.get(self, "external_rps")

    @external_rps.setter
    def external_rps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastPimRpExternalRpArgs']]]]):
        pulumi.set(self, "external_rps", value)

    @_builtins.property
    @pulumi.getter(name="localRp")
    def local_rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpArgs']]:
        """
        Local rp
        """
        return pulumi.get(self, "local_rp")

    @local_rp.setter
    def local_rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpArgs']]):
        pulumi.set(self, "local_rp", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimRpExternalRpArgsDict(TypedDict):
        group_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group list
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override
        """
elif False:
    LogicalRouterVrfMulticastPimRpExternalRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimRpExternalRpArgs:
    def __init__(__self__, *,
                 group_list: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 override: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] group_list: Group list
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] override: Override
        """
        if group_list is not None:
            pulumi.set(__self__, "group_list", group_list)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override is not None:
            pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="groupList")
    def group_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group list
        """
        return pulumi.get(self, "group_list")

    @group_list.setter
    def group_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_list", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimRpLocalRpArgsDict(TypedDict):
        candidate_rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgsDict']]
        """
        Candidate rp
        """
        static_rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgsDict']]
        """
        Static rp

        >  **Note:** You must specify exactly one of `candidate_rp` and `static_rp`.
        """
elif False:
    LogicalRouterVrfMulticastPimRpLocalRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimRpLocalRpArgs:
    def __init__(__self__, *,
                 candidate_rp: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgs']] = None,
                 static_rp: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgs'] candidate_rp: Candidate rp
        :param pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgs'] static_rp: Static rp
               
               >  **Note:** You must specify exactly one of `candidate_rp` and `static_rp`.
        """
        if candidate_rp is not None:
            pulumi.set(__self__, "candidate_rp", candidate_rp)
        if static_rp is not None:
            pulumi.set(__self__, "static_rp", static_rp)

    @_builtins.property
    @pulumi.getter(name="candidateRp")
    def candidate_rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgs']]:
        """
        Candidate rp
        """
        return pulumi.get(self, "candidate_rp")

    @candidate_rp.setter
    def candidate_rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgs']]):
        pulumi.set(self, "candidate_rp", value)

    @_builtins.property
    @pulumi.getter(name="staticRp")
    def static_rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgs']]:
        """
        Static rp

        >  **Note:** You must specify exactly one of `candidate_rp` and `static_rp`.
        """
        return pulumi.get(self, "static_rp")

    @static_rp.setter
    def static_rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgs']]):
        pulumi.set(self, "static_rp", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        advertisement_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Advertisement interval
        """
        group_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group list
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority
        """
elif False:
    LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimRpLocalRpCandidateRpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 advertisement_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 group_list: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[_builtins.int] advertisement_interval: Advertisement interval
        :param pulumi.Input[_builtins.str] group_list: Group list
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.int] priority: Priority
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if advertisement_interval is not None:
            pulumi.set(__self__, "advertisement_interval", advertisement_interval)
        if group_list is not None:
            pulumi.set(__self__, "group_list", group_list)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="advertisementInterval")
    def advertisement_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Advertisement interval
        """
        return pulumi.get(self, "advertisement_interval")

    @advertisement_interval.setter
    def advertisement_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "advertisement_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupList")
    def group_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group list
        """
        return pulumi.get(self, "group_list")

    @group_list.setter
    def group_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_list", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        group_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group list
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override
        """
elif False:
    LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimRpLocalRpStaticRpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 group_list: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 override: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[_builtins.str] group_list: Group list
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.bool] override: Override
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if group_list is not None:
            pulumi.set(__self__, "group_list", group_list)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if override is not None:
            pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="groupList")
    def group_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group list
        """
        return pulumi.get(self, "group_list")

    @group_list.setter
    def group_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_list", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimSptThresholdArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threshold
        """
elif False:
    LogicalRouterVrfMulticastPimSptThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimSptThresholdArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 threshold: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] threshold: Threshold
        """
        pulumi.set(__self__, "name", name)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class LogicalRouterVrfMulticastPimSsmAddressSpaceArgsDict(TypedDict):
        group_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group list
        """
elif False:
    LogicalRouterVrfMulticastPimSsmAddressSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastPimSsmAddressSpaceArgs:
    def __init__(__self__, *,
                 group_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] group_list: Group list
        """
        if group_list is not None:
            pulumi.set(__self__, "group_list", group_list)

    @_builtins.property
    @pulumi.getter(name="groupList")
    def group_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group list
        """
        return pulumi.get(self, "group_list")

    @group_list.setter
    def group_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_list", value)


if not MYPY:
    class LogicalRouterVrfMulticastRpArgsDict(TypedDict):
        external_rps: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastRpExternalRpArgsDict']]]]
        """
        External rp
        """
        local_rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpArgsDict']]
        """
        Local rp
        """
elif False:
    LogicalRouterVrfMulticastRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastRpArgs:
    def __init__(__self__, *,
                 external_rps: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastRpExternalRpArgs']]]] = None,
                 local_rp: Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastRpExternalRpArgs']]] external_rps: External rp
        :param pulumi.Input['LogicalRouterVrfMulticastRpLocalRpArgs'] local_rp: Local rp
        """
        if external_rps is not None:
            pulumi.set(__self__, "external_rps", external_rps)
        if local_rp is not None:
            pulumi.set(__self__, "local_rp", local_rp)

    @_builtins.property
    @pulumi.getter(name="externalRps")
    def external_rps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastRpExternalRpArgs']]]]:
        """
        External rp
        """
        return pulumi.get(self, "external_rps")

    @external_rps.setter
    def external_rps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfMulticastRpExternalRpArgs']]]]):
        pulumi.set(self, "external_rps", value)

    @_builtins.property
    @pulumi.getter(name="localRp")
    def local_rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpArgs']]:
        """
        Local rp
        """
        return pulumi.get(self, "local_rp")

    @local_rp.setter
    def local_rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpArgs']]):
        pulumi.set(self, "local_rp", value)


if not MYPY:
    class LogicalRouterVrfMulticastRpExternalRpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        group_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Group addresses
        """
        override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override
        """
elif False:
    LogicalRouterVrfMulticastRpExternalRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastRpExternalRpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 override: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_addresses: Group addresses
        :param pulumi.Input[_builtins.bool] override: Override
        """
        pulumi.set(__self__, "name", name)
        if group_addresses is not None:
            pulumi.set(__self__, "group_addresses", group_addresses)
        if override is not None:
            pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="groupAddresses")
    def group_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Group addresses
        """
        return pulumi.get(self, "group_addresses")

    @group_addresses.setter
    def group_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_addresses", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override", value)


if not MYPY:
    class LogicalRouterVrfMulticastRpLocalRpArgsDict(TypedDict):
        candidate_rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpCandidateRpArgsDict']]
        """
        Candidate rp
        """
        static_rp: NotRequired[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpStaticRpArgsDict']]
        """
        Static rp

        >  **Note:** You must specify exactly one of `candidate_rp` and `static_rp`.
        """
elif False:
    LogicalRouterVrfMulticastRpLocalRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastRpLocalRpArgs:
    def __init__(__self__, *,
                 candidate_rp: Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpCandidateRpArgs']] = None,
                 static_rp: Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpStaticRpArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfMulticastRpLocalRpCandidateRpArgs'] candidate_rp: Candidate rp
        :param pulumi.Input['LogicalRouterVrfMulticastRpLocalRpStaticRpArgs'] static_rp: Static rp
               
               >  **Note:** You must specify exactly one of `candidate_rp` and `static_rp`.
        """
        if candidate_rp is not None:
            pulumi.set(__self__, "candidate_rp", candidate_rp)
        if static_rp is not None:
            pulumi.set(__self__, "static_rp", static_rp)

    @_builtins.property
    @pulumi.getter(name="candidateRp")
    def candidate_rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpCandidateRpArgs']]:
        """
        Candidate rp
        """
        return pulumi.get(self, "candidate_rp")

    @candidate_rp.setter
    def candidate_rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpCandidateRpArgs']]):
        pulumi.set(self, "candidate_rp", value)

    @_builtins.property
    @pulumi.getter(name="staticRp")
    def static_rp(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpStaticRpArgs']]:
        """
        Static rp

        >  **Note:** You must specify exactly one of `candidate_rp` and `static_rp`.
        """
        return pulumi.get(self, "static_rp")

    @static_rp.setter
    def static_rp(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastRpLocalRpStaticRpArgs']]):
        pulumi.set(self, "static_rp", value)


if not MYPY:
    class LogicalRouterVrfMulticastRpLocalRpCandidateRpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        advertisement_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Advertisement interval
        """
        group_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Group addresses
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority
        """
elif False:
    LogicalRouterVrfMulticastRpLocalRpCandidateRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastRpLocalRpCandidateRpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 advertisement_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 group_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[_builtins.int] advertisement_interval: Advertisement interval
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_addresses: Group addresses
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.int] priority: Priority
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if advertisement_interval is not None:
            pulumi.set(__self__, "advertisement_interval", advertisement_interval)
        if group_addresses is not None:
            pulumi.set(__self__, "group_addresses", group_addresses)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="advertisementInterval")
    def advertisement_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Advertisement interval
        """
        return pulumi.get(self, "advertisement_interval")

    @advertisement_interval.setter
    def advertisement_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "advertisement_interval", value)

    @_builtins.property
    @pulumi.getter(name="groupAddresses")
    def group_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Group addresses
        """
        return pulumi.get(self, "group_addresses")

    @group_addresses.setter
    def group_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_addresses", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class LogicalRouterVrfMulticastRpLocalRpStaticRpArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        group_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Group addresses
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override
        """
elif False:
    LogicalRouterVrfMulticastRpLocalRpStaticRpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastRpLocalRpStaticRpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 group_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 override: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_addresses: Group addresses
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.bool] override: Override
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if group_addresses is not None:
            pulumi.set(__self__, "group_addresses", group_addresses)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if override is not None:
            pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="groupAddresses")
    def group_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Group addresses
        """
        return pulumi.get(self, "group_addresses")

    @group_addresses.setter
    def group_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_addresses", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override", value)


if not MYPY:
    class LogicalRouterVrfMulticastSptThresholdArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threshold
        """
elif False:
    LogicalRouterVrfMulticastSptThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastSptThresholdArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 threshold: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] threshold: Threshold
        """
        pulumi.set(__self__, "name", name)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class LogicalRouterVrfMulticastSsmAddressSpaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        group_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group address
        """
        included: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Included
        """
elif False:
    LogicalRouterVrfMulticastSsmAddressSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastSsmAddressSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group_address: Optional[pulumi.Input[_builtins.str]] = None,
                 included: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] group_address: Group address
        :param pulumi.Input[_builtins.bool] included: Included
        """
        pulumi.set(__self__, "name", name)
        if group_address is not None:
            pulumi.set(__self__, "group_address", group_address)
        if included is not None:
            pulumi.set(__self__, "included", included)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="groupAddress")
    def group_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group address
        """
        return pulumi.get(self, "group_address")

    @group_address.setter
    def group_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_address", value)

    @_builtins.property
    @pulumi.getter
    def included(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Included
        """
        return pulumi.get(self, "included")

    @included.setter
    def included(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "included", value)


if not MYPY:
    class LogicalRouterVrfMulticastStaticRouteArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        nexthop: NotRequired[pulumi.Input['LogicalRouterVrfMulticastStaticRouteNexthopArgsDict']]
        """
        Nexthop
        """
        preference: NotRequired[pulumi.Input[_builtins.int]]
        """
        Preference
        """
elif False:
    LogicalRouterVrfMulticastStaticRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastStaticRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 nexthop: Optional[pulumi.Input['LogicalRouterVrfMulticastStaticRouteNexthopArgs']] = None,
                 preference: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] destination: Destination
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input['LogicalRouterVrfMulticastStaticRouteNexthopArgs'] nexthop: Nexthop
        :param pulumi.Input[_builtins.int] preference: Preference
        """
        pulumi.set(__self__, "name", name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input['LogicalRouterVrfMulticastStaticRouteNexthopArgs']]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input['LogicalRouterVrfMulticastStaticRouteNexthopArgs']]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Preference
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class LogicalRouterVrfMulticastStaticRouteNexthopArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip address
        """
elif False:
    LogicalRouterVrfMulticastStaticRouteNexthopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfMulticastStaticRouteNexthopArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: Ip address
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip address
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class LogicalRouterVrfOspfArgsDict(TypedDict):
        allow_redist_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow redist default route
        """
        areas: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaArgsDict']]]]
        """
        Area
        """
        auth_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileArgsDict']]]]
        """
        Auth profile
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        export_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfExportRuleArgsDict']]]]
        """
        Export rules
        """
        flood_prevention: NotRequired[pulumi.Input['LogicalRouterVrfOspfFloodPreventionArgsDict']]
        """
        Flood prevention
        """
        global_bfd: NotRequired[pulumi.Input['LogicalRouterVrfOspfGlobalBfdArgsDict']]
        """
        Global bfd
        """
        global_if_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global if timer
        """
        graceful_restart: NotRequired[pulumi.Input['LogicalRouterVrfOspfGracefulRestartArgsDict']]
        """
        Graceful restart
        """
        redistribution_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Redistribution profile
        """
        reject_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reject default route
        """
        rfc1583: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Rfc1583
        """
        router_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Router id
        """
        spf_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Spf timer
        """
        vr_timers: NotRequired[pulumi.Input['LogicalRouterVrfOspfVrTimersArgsDict']]
        """
        Vr timers
        """
elif False:
    LogicalRouterVrfOspfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfArgs:
    def __init__(__self__, *,
                 allow_redist_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 areas: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaArgs']]]] = None,
                 auth_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileArgs']]]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 export_rules: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfExportRuleArgs']]]] = None,
                 flood_prevention: Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionArgs']] = None,
                 global_bfd: Optional[pulumi.Input['LogicalRouterVrfOspfGlobalBfdArgs']] = None,
                 global_if_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 graceful_restart: Optional[pulumi.Input['LogicalRouterVrfOspfGracefulRestartArgs']] = None,
                 redistribution_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 reject_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 rfc1583: Optional[pulumi.Input[_builtins.bool]] = None,
                 router_id: Optional[pulumi.Input[_builtins.str]] = None,
                 spf_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_timers: Optional[pulumi.Input['LogicalRouterVrfOspfVrTimersArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_redist_default_route: Allow redist default route
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaArgs']]] areas: Area
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileArgs']]] auth_profiles: Auth profile
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfExportRuleArgs']]] export_rules: Export rules
        :param pulumi.Input['LogicalRouterVrfOspfFloodPreventionArgs'] flood_prevention: Flood prevention
        :param pulumi.Input['LogicalRouterVrfOspfGlobalBfdArgs'] global_bfd: Global bfd
        :param pulumi.Input[_builtins.str] global_if_timer: Global if timer
        :param pulumi.Input['LogicalRouterVrfOspfGracefulRestartArgs'] graceful_restart: Graceful restart
        :param pulumi.Input[_builtins.str] redistribution_profile: Redistribution profile
        :param pulumi.Input[_builtins.bool] reject_default_route: Reject default route
        :param pulumi.Input[_builtins.bool] rfc1583: Rfc1583
        :param pulumi.Input[_builtins.str] router_id: Router id
        :param pulumi.Input[_builtins.str] spf_timer: Spf timer
        :param pulumi.Input['LogicalRouterVrfOspfVrTimersArgs'] vr_timers: Vr timers
        """
        if allow_redist_default_route is not None:
            pulumi.set(__self__, "allow_redist_default_route", allow_redist_default_route)
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if auth_profiles is not None:
            pulumi.set(__self__, "auth_profiles", auth_profiles)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if export_rules is not None:
            pulumi.set(__self__, "export_rules", export_rules)
        if flood_prevention is not None:
            pulumi.set(__self__, "flood_prevention", flood_prevention)
        if global_bfd is not None:
            pulumi.set(__self__, "global_bfd", global_bfd)
        if global_if_timer is not None:
            pulumi.set(__self__, "global_if_timer", global_if_timer)
        if graceful_restart is not None:
            pulumi.set(__self__, "graceful_restart", graceful_restart)
        if redistribution_profile is not None:
            pulumi.set(__self__, "redistribution_profile", redistribution_profile)
        if reject_default_route is not None:
            pulumi.set(__self__, "reject_default_route", reject_default_route)
        if rfc1583 is not None:
            pulumi.set(__self__, "rfc1583", rfc1583)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)
        if spf_timer is not None:
            pulumi.set(__self__, "spf_timer", spf_timer)
        if vr_timers is not None:
            pulumi.set(__self__, "vr_timers", vr_timers)

    @_builtins.property
    @pulumi.getter(name="allowRedistDefaultRoute")
    def allow_redist_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow redist default route
        """
        return pulumi.get(self, "allow_redist_default_route")

    @allow_redist_default_route.setter
    def allow_redist_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_redist_default_route", value)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaArgs']]]]:
        """
        Area
        """
        return pulumi.get(self, "areas")

    @areas.setter
    def areas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaArgs']]]]):
        pulumi.set(self, "areas", value)

    @_builtins.property
    @pulumi.getter(name="authProfiles")
    def auth_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileArgs']]]]:
        """
        Auth profile
        """
        return pulumi.get(self, "auth_profiles")

    @auth_profiles.setter
    def auth_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileArgs']]]]):
        pulumi.set(self, "auth_profiles", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="exportRules")
    def export_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfExportRuleArgs']]]]:
        """
        Export rules
        """
        return pulumi.get(self, "export_rules")

    @export_rules.setter
    def export_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfExportRuleArgs']]]]):
        pulumi.set(self, "export_rules", value)

    @_builtins.property
    @pulumi.getter(name="floodPrevention")
    def flood_prevention(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionArgs']]:
        """
        Flood prevention
        """
        return pulumi.get(self, "flood_prevention")

    @flood_prevention.setter
    def flood_prevention(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionArgs']]):
        pulumi.set(self, "flood_prevention", value)

    @_builtins.property
    @pulumi.getter(name="globalBfd")
    def global_bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfGlobalBfdArgs']]:
        """
        Global bfd
        """
        return pulumi.get(self, "global_bfd")

    @global_bfd.setter
    def global_bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfGlobalBfdArgs']]):
        pulumi.set(self, "global_bfd", value)

    @_builtins.property
    @pulumi.getter(name="globalIfTimer")
    def global_if_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global if timer
        """
        return pulumi.get(self, "global_if_timer")

    @global_if_timer.setter
    def global_if_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_if_timer", value)

    @_builtins.property
    @pulumi.getter(name="gracefulRestart")
    def graceful_restart(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfGracefulRestartArgs']]:
        """
        Graceful restart
        """
        return pulumi.get(self, "graceful_restart")

    @graceful_restart.setter
    def graceful_restart(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfGracefulRestartArgs']]):
        pulumi.set(self, "graceful_restart", value)

    @_builtins.property
    @pulumi.getter(name="redistributionProfile")
    def redistribution_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Redistribution profile
        """
        return pulumi.get(self, "redistribution_profile")

    @redistribution_profile.setter
    def redistribution_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redistribution_profile", value)

    @_builtins.property
    @pulumi.getter(name="rejectDefaultRoute")
    def reject_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reject default route
        """
        return pulumi.get(self, "reject_default_route")

    @reject_default_route.setter
    def reject_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_default_route", value)

    @_builtins.property
    @pulumi.getter
    def rfc1583(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Rfc1583
        """
        return pulumi.get(self, "rfc1583")

    @rfc1583.setter
    def rfc1583(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rfc1583", value)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Router id
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "router_id", value)

    @_builtins.property
    @pulumi.getter(name="spfTimer")
    def spf_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Spf timer
        """
        return pulumi.get(self, "spf_timer")

    @spf_timer.setter
    def spf_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spf_timer", value)

    @_builtins.property
    @pulumi.getter(name="vrTimers")
    def vr_timers(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfVrTimersArgs']]:
        """
        Vr timers
        """
        return pulumi.get(self, "vr_timers")

    @vr_timers.setter
    def vr_timers(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfVrTimersArgs']]):
        pulumi.set(self, "vr_timers", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceArgsDict']]]]
        """
        Interface
        """
        ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaRangeArgsDict']]]]
        """
        Range
        """
        type: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeArgsDict']]
        """
        Type
        """
        virtual_links: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkArgsDict']]]]
        """
        Virtual link
        """
        vr_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeArgsDict']]]]
        """
        Vr range
        """
elif False:
    LogicalRouterVrfOspfAreaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceArgs']]]] = None,
                 ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaRangeArgs']]]] = None,
                 type: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeArgs']] = None,
                 virtual_links: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkArgs']]]] = None,
                 vr_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceArgs']]] interfaces: Interface
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaRangeArgs']]] ranges: Range
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeArgs'] type: Type
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkArgs']]] virtual_links: Virtual link
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeArgs']]] vr_ranges: Vr range
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if virtual_links is not None:
            pulumi.set(__self__, "virtual_links", virtual_links)
        if vr_ranges is not None:
            pulumi.set(__self__, "vr_ranges", vr_ranges)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceArgs']]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaRangeArgs']]]]:
        """
        Range
        """
        return pulumi.get(self, "ranges")

    @ranges.setter
    def ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaRangeArgs']]]]):
        pulumi.set(self, "ranges", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeArgs']]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeArgs']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="virtualLinks")
    def virtual_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkArgs']]]]:
        """
        Virtual link
        """
        return pulumi.get(self, "virtual_links")

    @virtual_links.setter
    def virtual_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkArgs']]]]):
        pulumi.set(self, "virtual_links", value)

    @_builtins.property
    @pulumi.getter(name="vrRanges")
    def vr_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeArgs']]]]:
        """
        Vr range
        """
        return pulumi.get(self, "vr_ranges")

    @vr_ranges.setter
    def vr_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeArgs']]]]):
        pulumi.set(self, "vr_ranges", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceBfdArgsDict']]
        """
        Bfd
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        link_type: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeArgsDict']]
        """
        Link type
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        mtu_ignore: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mtu ignore
        """
        passive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passive
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority
        """
        timing: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timing
        """
        vr_timing: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceVrTimingArgsDict']]
        """
        Vr timing
        """
elif False:
    LogicalRouterVrfOspfAreaInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceBfdArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 link_type: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeArgs']] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 mtu_ignore: Optional[pulumi.Input[_builtins.bool]] = None,
                 passive: Optional[pulumi.Input[_builtins.bool]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 timing: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_timing: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceVrTimingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input['LogicalRouterVrfOspfAreaInterfaceBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeArgs'] link_type: Link type
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.bool] mtu_ignore: Mtu ignore
        :param pulumi.Input[_builtins.bool] passive: Passive
        :param pulumi.Input[_builtins.int] priority: Priority
        :param pulumi.Input[_builtins.str] timing: Timing
        :param pulumi.Input['LogicalRouterVrfOspfAreaInterfaceVrTimingArgs'] vr_timing: Vr timing
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if link_type is not None:
            pulumi.set(__self__, "link_type", link_type)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if mtu_ignore is not None:
            pulumi.set(__self__, "mtu_ignore", mtu_ignore)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if timing is not None:
            pulumi.set(__self__, "timing", timing)
        if vr_timing is not None:
            pulumi.set(__self__, "vr_timing", vr_timing)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="linkType")
    def link_type(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeArgs']]:
        """
        Link type
        """
        return pulumi.get(self, "link_type")

    @link_type.setter
    def link_type(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeArgs']]):
        pulumi.set(self, "link_type", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="mtuIgnore")
    def mtu_ignore(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mtu ignore
        """
        return pulumi.get(self, "mtu_ignore")

    @mtu_ignore.setter
    def mtu_ignore(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mtu_ignore", value)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passive", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def timing(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timing
        """
        return pulumi.get(self, "timing")

    @timing.setter
    def timing(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timing", value)

    @_builtins.property
    @pulumi.getter(name="vrTiming")
    def vr_timing(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceVrTimingArgs']]:
        """
        Vr timing
        """
        return pulumi.get(self, "vr_timing")

    @vr_timing.setter
    def vr_timing(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceVrTimingArgs']]):
        pulumi.set(self, "vr_timing", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfOspfAreaInterfaceBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceLinkTypeArgsDict(TypedDict):
        broadcast: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgsDict']]
        """
        Broadcast
        """
        p2mp: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgsDict']]
        """
        P2mp

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        p2p: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgsDict']]
        """
        P2p

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
elif False:
    LogicalRouterVrfOspfAreaInterfaceLinkTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceLinkTypeArgs:
    def __init__(__self__, *,
                 broadcast: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgs']] = None,
                 p2mp: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgs']] = None,
                 p2p: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgs'] broadcast: Broadcast
        :param pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgs'] p2mp: P2mp
               
               >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        :param pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgs'] p2p: P2p
               
               >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        if broadcast is not None:
            pulumi.set(__self__, "broadcast", broadcast)
        if p2mp is not None:
            pulumi.set(__self__, "p2mp", p2mp)
        if p2p is not None:
            pulumi.set(__self__, "p2p", p2p)

    @_builtins.property
    @pulumi.getter
    def broadcast(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgs']]:
        """
        Broadcast
        """
        return pulumi.get(self, "broadcast")

    @broadcast.setter
    def broadcast(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgs']]):
        pulumi.set(self, "broadcast", value)

    @_builtins.property
    @pulumi.getter
    def p2mp(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgs']]:
        """
        P2mp

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        return pulumi.get(self, "p2mp")

    @p2mp.setter
    def p2mp(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgs']]):
        pulumi.set(self, "p2mp", value)

    @_builtins.property
    @pulumi.getter
    def p2p(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgs']]:
        """
        P2p

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        return pulumi.get(self, "p2p")

    @p2p.setter
    def p2p(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgs']]):
        pulumi.set(self, "p2p", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgsDict(TypedDict):
        neighbors: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgsDict']]]]
        """
        Neighbor
        """
elif False:
    LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpArgs:
    def __init__(__self__, *,
                 neighbors: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgs']]] neighbors: Neighbor
        """
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgs']]]]:
        """
        Neighbor
        """
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgs']]]]):
        pulumi.set(self, "neighbors", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority
        """
elif False:
    LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceLinkTypeP2mpNeighborArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] priority: Priority
        """
        pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceLinkTypeP2pArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaInterfaceVrTimingArgsDict(TypedDict):
        dead_counts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dead counts
        """
        gr_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Gr delay
        """
        hello_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hello interval
        """
        retransmit_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retransmit interval
        """
        transit_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Transit delay
        """
elif False:
    LogicalRouterVrfOspfAreaInterfaceVrTimingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaInterfaceVrTimingArgs:
    def __init__(__self__, *,
                 dead_counts: Optional[pulumi.Input[_builtins.int]] = None,
                 gr_delay: Optional[pulumi.Input[_builtins.int]] = None,
                 hello_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 retransmit_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 transit_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] dead_counts: Dead counts
        :param pulumi.Input[_builtins.int] gr_delay: Gr delay
        :param pulumi.Input[_builtins.int] hello_interval: Hello interval
        :param pulumi.Input[_builtins.int] retransmit_interval: Retransmit interval
        :param pulumi.Input[_builtins.int] transit_delay: Transit delay
        """
        if dead_counts is not None:
            pulumi.set(__self__, "dead_counts", dead_counts)
        if gr_delay is not None:
            pulumi.set(__self__, "gr_delay", gr_delay)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if retransmit_interval is not None:
            pulumi.set(__self__, "retransmit_interval", retransmit_interval)
        if transit_delay is not None:
            pulumi.set(__self__, "transit_delay", transit_delay)

    @_builtins.property
    @pulumi.getter(name="deadCounts")
    def dead_counts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dead counts
        """
        return pulumi.get(self, "dead_counts")

    @dead_counts.setter
    def dead_counts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dead_counts", value)

    @_builtins.property
    @pulumi.getter(name="grDelay")
    def gr_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Gr delay
        """
        return pulumi.get(self, "gr_delay")

    @gr_delay.setter
    def gr_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gr_delay", value)

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hello interval
        """
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hello_interval", value)

    @_builtins.property
    @pulumi.getter(name="retransmitInterval")
    def retransmit_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retransmit interval
        """
        return pulumi.get(self, "retransmit_interval")

    @retransmit_interval.setter
    def retransmit_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retransmit_interval", value)

    @_builtins.property
    @pulumi.getter(name="transitDelay")
    def transit_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Transit delay
        """
        return pulumi.get(self, "transit_delay")

    @transit_delay.setter
    def transit_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transit_delay", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Advertise
        """
        substitute: NotRequired[pulumi.Input[_builtins.str]]
        """
        Substitute
        """
elif False:
    LogicalRouterVrfOspfAreaRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input[_builtins.bool]] = None,
                 substitute: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] advertise: Advertise
        :param pulumi.Input[_builtins.str] substitute: Substitute
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if substitute is not None:
            pulumi.set(__self__, "substitute", substitute)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def substitute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Substitute
        """
        return pulumi.get(self, "substitute")

    @substitute.setter
    def substitute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "substitute", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeArgsDict(TypedDict):
        normal: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalArgsDict']]
        """
        Normal
        """
        nssa: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaArgsDict']]
        """
        Nssa

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        stub: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubArgsDict']]
        """
        Stub

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
elif False:
    LogicalRouterVrfOspfAreaTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeArgs:
    def __init__(__self__, *,
                 normal: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalArgs']] = None,
                 nssa: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaArgs']] = None,
                 stub: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalArgs'] normal: Normal
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaArgs'] nssa: Nssa
               
               >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeStubArgs'] stub: Stub
               
               >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        if normal is not None:
            pulumi.set(__self__, "normal", normal)
        if nssa is not None:
            pulumi.set(__self__, "nssa", nssa)
        if stub is not None:
            pulumi.set(__self__, "stub", stub)

    @_builtins.property
    @pulumi.getter
    def normal(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalArgs']]:
        """
        Normal
        """
        return pulumi.get(self, "normal")

    @normal.setter
    def normal(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalArgs']]):
        pulumi.set(self, "normal", value)

    @_builtins.property
    @pulumi.getter
    def nssa(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaArgs']]:
        """
        Nssa

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        return pulumi.get(self, "nssa")

    @nssa.setter
    def nssa(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaArgs']]):
        pulumi.set(self, "nssa", value)

    @_builtins.property
    @pulumi.getter
    def stub(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubArgs']]:
        """
        Stub

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        return pulumi.get(self, "stub")

    @stub.setter
    def stub(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubArgs']]):
        pulumi.set(self, "stub", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNormalArgsDict(TypedDict):
        abr: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalAbrArgsDict']]
        """
        Abr
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNormalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNormalArgs:
    def __init__(__self__, *,
                 abr: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalAbrArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalAbrArgs'] abr: Abr
        """
        if abr is not None:
            pulumi.set(__self__, "abr", abr)

    @_builtins.property
    @pulumi.getter
    def abr(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalAbrArgs']]:
        """
        Abr
        """
        return pulumi.get(self, "abr")

    @abr.setter
    def abr(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNormalAbrArgs']]):
        pulumi.set(self, "abr", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNormalAbrArgsDict(TypedDict):
        export_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export list
        """
        import_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import list
        """
        inbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound filter list
        """
        outbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound filter list
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNormalAbrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNormalAbrArgs:
    def __init__(__self__, *,
                 export_list: Optional[pulumi.Input[_builtins.str]] = None,
                 import_list: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_list: Export list
        :param pulumi.Input[_builtins.str] import_list: Import list
        :param pulumi.Input[_builtins.str] inbound_filter_list: Inbound filter list
        :param pulumi.Input[_builtins.str] outbound_filter_list: Outbound filter list
        """
        if export_list is not None:
            pulumi.set(__self__, "export_list", export_list)
        if import_list is not None:
            pulumi.set(__self__, "import_list", import_list)
        if inbound_filter_list is not None:
            pulumi.set(__self__, "inbound_filter_list", inbound_filter_list)
        if outbound_filter_list is not None:
            pulumi.set(__self__, "outbound_filter_list", outbound_filter_list)

    @_builtins.property
    @pulumi.getter(name="exportList")
    def export_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export list
        """
        return pulumi.get(self, "export_list")

    @export_list.setter
    def export_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_list", value)

    @_builtins.property
    @pulumi.getter(name="importList")
    def import_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import list
        """
        return pulumi.get(self, "import_list")

    @import_list.setter
    def import_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundFilterList")
    def inbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound filter list
        """
        return pulumi.get(self, "inbound_filter_list")

    @inbound_filter_list.setter
    def inbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_filter_list", value)

    @_builtins.property
    @pulumi.getter(name="outboundFilterList")
    def outbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound filter list
        """
        return pulumi.get(self, "outbound_filter_list")

    @outbound_filter_list.setter
    def outbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_filter_list", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaArgsDict(TypedDict):
        abr: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrArgsDict']]
        """
        Abr
        """
        accept_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept summary
        """
        default_information_originate: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgsDict']]
        """
        Default information originate
        """
        default_route: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgsDict']]
        """
        Default route
        """
        no_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        No summary
        """
        nssa_ext_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgsDict']]]]
        """
        Nssa ext range
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaArgs:
    def __init__(__self__, *,
                 abr: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrArgs']] = None,
                 accept_summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_information_originate: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgs']] = None,
                 default_route: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgs']] = None,
                 no_summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 nssa_ext_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgs']]]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrArgs'] abr: Abr
        :param pulumi.Input[_builtins.bool] accept_summary: Accept summary
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgs'] default_information_originate: Default information originate
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgs'] default_route: Default route
        :param pulumi.Input[_builtins.bool] no_summary: No summary
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgs']]] nssa_ext_ranges: Nssa ext range
        """
        if abr is not None:
            pulumi.set(__self__, "abr", abr)
        if accept_summary is not None:
            pulumi.set(__self__, "accept_summary", accept_summary)
        if default_information_originate is not None:
            pulumi.set(__self__, "default_information_originate", default_information_originate)
        if default_route is not None:
            pulumi.set(__self__, "default_route", default_route)
        if no_summary is not None:
            pulumi.set(__self__, "no_summary", no_summary)
        if nssa_ext_ranges is not None:
            pulumi.set(__self__, "nssa_ext_ranges", nssa_ext_ranges)

    @_builtins.property
    @pulumi.getter
    def abr(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrArgs']]:
        """
        Abr
        """
        return pulumi.get(self, "abr")

    @abr.setter
    def abr(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrArgs']]):
        pulumi.set(self, "abr", value)

    @_builtins.property
    @pulumi.getter(name="acceptSummary")
    def accept_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept summary
        """
        return pulumi.get(self, "accept_summary")

    @accept_summary.setter
    def accept_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_summary", value)

    @_builtins.property
    @pulumi.getter(name="defaultInformationOriginate")
    def default_information_originate(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgs']]:
        """
        Default information originate
        """
        return pulumi.get(self, "default_information_originate")

    @default_information_originate.setter
    def default_information_originate(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgs']]):
        pulumi.set(self, "default_information_originate", value)

    @_builtins.property
    @pulumi.getter(name="defaultRoute")
    def default_route(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgs']]:
        """
        Default route
        """
        return pulumi.get(self, "default_route")

    @default_route.setter
    def default_route(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgs']]):
        pulumi.set(self, "default_route", value)

    @_builtins.property
    @pulumi.getter(name="noSummary")
    def no_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        No summary
        """
        return pulumi.get(self, "no_summary")

    @no_summary.setter
    def no_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_summary", value)

    @_builtins.property
    @pulumi.getter(name="nssaExtRanges")
    def nssa_ext_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgs']]]]:
        """
        Nssa ext range
        """
        return pulumi.get(self, "nssa_ext_ranges")

    @nssa_ext_ranges.setter
    def nssa_ext_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgs']]]]):
        pulumi.set(self, "nssa_ext_ranges", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaAbrArgsDict(TypedDict):
        export_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export list
        """
        import_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import list
        """
        inbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound filter list
        """
        nssa_ext_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgsDict']]]]
        """
        Nssa ext range
        """
        outbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound filter list
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaAbrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaAbrArgs:
    def __init__(__self__, *,
                 export_list: Optional[pulumi.Input[_builtins.str]] = None,
                 import_list: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None,
                 nssa_ext_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgs']]]] = None,
                 outbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_list: Export list
        :param pulumi.Input[_builtins.str] import_list: Import list
        :param pulumi.Input[_builtins.str] inbound_filter_list: Inbound filter list
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgs']]] nssa_ext_ranges: Nssa ext range
        :param pulumi.Input[_builtins.str] outbound_filter_list: Outbound filter list
        """
        if export_list is not None:
            pulumi.set(__self__, "export_list", export_list)
        if import_list is not None:
            pulumi.set(__self__, "import_list", import_list)
        if inbound_filter_list is not None:
            pulumi.set(__self__, "inbound_filter_list", inbound_filter_list)
        if nssa_ext_ranges is not None:
            pulumi.set(__self__, "nssa_ext_ranges", nssa_ext_ranges)
        if outbound_filter_list is not None:
            pulumi.set(__self__, "outbound_filter_list", outbound_filter_list)

    @_builtins.property
    @pulumi.getter(name="exportList")
    def export_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export list
        """
        return pulumi.get(self, "export_list")

    @export_list.setter
    def export_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_list", value)

    @_builtins.property
    @pulumi.getter(name="importList")
    def import_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import list
        """
        return pulumi.get(self, "import_list")

    @import_list.setter
    def import_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundFilterList")
    def inbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound filter list
        """
        return pulumi.get(self, "inbound_filter_list")

    @inbound_filter_list.setter
    def inbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_filter_list", value)

    @_builtins.property
    @pulumi.getter(name="nssaExtRanges")
    def nssa_ext_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgs']]]]:
        """
        Nssa ext range
        """
        return pulumi.get(self, "nssa_ext_ranges")

    @nssa_ext_ranges.setter
    def nssa_ext_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgs']]]]):
        pulumi.set(self, "nssa_ext_ranges", value)

    @_builtins.property
    @pulumi.getter(name="outboundFilterList")
    def outbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound filter list
        """
        return pulumi.get(self, "outbound_filter_list")

    @outbound_filter_list.setter
    def outbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_filter_list", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Advertise
        """
        route_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route tag
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaAbrNssaExtRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_tag: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] advertise: Advertise
        :param pulumi.Input[_builtins.int] route_tag: Route tag
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if route_tag is not None:
            pulumi.set(__self__, "route_tag", route_tag)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter(name="routeTag")
    def route_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route tag
        """
        return pulumi.get(self, "route_tag")

    @route_tag.setter
    def route_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "route_tag", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric type
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaDefaultInformationOriginateArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] metric_type: Metric type
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric type
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgsDict(TypedDict):
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgsDict']]
        """
        Advertise
        """
        disable: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgsDict']]
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaDefaultRouteArgs:
    def __init__(__self__, *,
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgs']] = None,
                 disable: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgs'] disable: Disable
               
               >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgs']]:
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgs']]):
        pulumi.set(self, "disable", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaDefaultRouteAdvertiseArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] type: Type
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaDefaultRouteDisableArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgsDict']]
        """
        Advertise
        """
        suppress: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgsDict']]
        """
        Suppress
        """
elif False:
    LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgs']] = None,
                 suppress: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgs'] suppress: Suppress
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgs']]:
        """
        Suppress
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgs']]):
        pulumi.set(self, "suppress", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeAdvertiseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeNssaNssaExtRangeSuppressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeStubArgsDict(TypedDict):
        abr: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubAbrArgsDict']]
        """
        Abr
        """
        accept_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept summary
        """
        default_route: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgsDict']]
        """
        Default route
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Default route metric
        """
        no_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        No summary
        """
elif False:
    LogicalRouterVrfOspfAreaTypeStubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeStubArgs:
    def __init__(__self__, *,
                 abr: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubAbrArgs']] = None,
                 accept_summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_route: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgs']] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 no_summary: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeStubAbrArgs'] abr: Abr
        :param pulumi.Input[_builtins.bool] accept_summary: Accept summary
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgs'] default_route: Default route
        :param pulumi.Input[_builtins.int] default_route_metric: Default route metric
        :param pulumi.Input[_builtins.bool] no_summary: No summary
        """
        if abr is not None:
            pulumi.set(__self__, "abr", abr)
        if accept_summary is not None:
            pulumi.set(__self__, "accept_summary", accept_summary)
        if default_route is not None:
            pulumi.set(__self__, "default_route", default_route)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if no_summary is not None:
            pulumi.set(__self__, "no_summary", no_summary)

    @_builtins.property
    @pulumi.getter
    def abr(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubAbrArgs']]:
        """
        Abr
        """
        return pulumi.get(self, "abr")

    @abr.setter
    def abr(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubAbrArgs']]):
        pulumi.set(self, "abr", value)

    @_builtins.property
    @pulumi.getter(name="acceptSummary")
    def accept_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept summary
        """
        return pulumi.get(self, "accept_summary")

    @accept_summary.setter
    def accept_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_summary", value)

    @_builtins.property
    @pulumi.getter(name="defaultRoute")
    def default_route(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgs']]:
        """
        Default route
        """
        return pulumi.get(self, "default_route")

    @default_route.setter
    def default_route(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgs']]):
        pulumi.set(self, "default_route", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Default route metric
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter(name="noSummary")
    def no_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        No summary
        """
        return pulumi.get(self, "no_summary")

    @no_summary.setter
    def no_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_summary", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeStubAbrArgsDict(TypedDict):
        export_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export list
        """
        import_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import list
        """
        inbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound filter list
        """
        outbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound filter list
        """
elif False:
    LogicalRouterVrfOspfAreaTypeStubAbrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeStubAbrArgs:
    def __init__(__self__, *,
                 export_list: Optional[pulumi.Input[_builtins.str]] = None,
                 import_list: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_list: Export list
        :param pulumi.Input[_builtins.str] import_list: Import list
        :param pulumi.Input[_builtins.str] inbound_filter_list: Inbound filter list
        :param pulumi.Input[_builtins.str] outbound_filter_list: Outbound filter list
        """
        if export_list is not None:
            pulumi.set(__self__, "export_list", export_list)
        if import_list is not None:
            pulumi.set(__self__, "import_list", import_list)
        if inbound_filter_list is not None:
            pulumi.set(__self__, "inbound_filter_list", inbound_filter_list)
        if outbound_filter_list is not None:
            pulumi.set(__self__, "outbound_filter_list", outbound_filter_list)

    @_builtins.property
    @pulumi.getter(name="exportList")
    def export_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export list
        """
        return pulumi.get(self, "export_list")

    @export_list.setter
    def export_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_list", value)

    @_builtins.property
    @pulumi.getter(name="importList")
    def import_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import list
        """
        return pulumi.get(self, "import_list")

    @import_list.setter
    def import_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundFilterList")
    def inbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound filter list
        """
        return pulumi.get(self, "inbound_filter_list")

    @inbound_filter_list.setter
    def inbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_filter_list", value)

    @_builtins.property
    @pulumi.getter(name="outboundFilterList")
    def outbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound filter list
        """
        return pulumi.get(self, "outbound_filter_list")

    @outbound_filter_list.setter
    def outbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_filter_list", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgsDict(TypedDict):
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgsDict']]
        """
        Advertise
        """
        disable: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgsDict']]
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
elif False:
    LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeStubDefaultRouteArgs:
    def __init__(__self__, *,
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgs']] = None,
                 disable: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgs'] disable: Disable
               
               >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgs']]:
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgs']]):
        pulumi.set(self, "disable", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
elif False:
    LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeStubDefaultRouteAdvertiseArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] metric: Metric
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaTypeStubDefaultRouteDisableArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaVirtualLinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkBfdArgsDict']]
        """
        Bfd
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        instance_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Instance id
        """
        interface_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interface id
        """
        neighbor_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Neighbor id
        """
        passive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passive
        """
        timing: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timing
        """
        transit_area_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transit area id
        """
        vr_timing: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgsDict']]
        """
        Vr timing
        """
elif False:
    LogicalRouterVrfOspfAreaVirtualLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaVirtualLinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkBfdArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.int]] = None,
                 interface_id: Optional[pulumi.Input[_builtins.int]] = None,
                 neighbor_id: Optional[pulumi.Input[_builtins.str]] = None,
                 passive: Optional[pulumi.Input[_builtins.bool]] = None,
                 timing: Optional[pulumi.Input[_builtins.str]] = None,
                 transit_area_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_timing: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] instance_id: Instance id
        :param pulumi.Input[_builtins.int] interface_id: Interface id
        :param pulumi.Input[_builtins.str] neighbor_id: Neighbor id
        :param pulumi.Input[_builtins.bool] passive: Passive
        :param pulumi.Input[_builtins.str] timing: Timing
        :param pulumi.Input[_builtins.str] transit_area_id: Transit area id
        :param pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgs'] vr_timing: Vr timing
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if neighbor_id is not None:
            pulumi.set(__self__, "neighbor_id", neighbor_id)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if timing is not None:
            pulumi.set(__self__, "timing", timing)
        if transit_area_id is not None:
            pulumi.set(__self__, "transit_area_id", transit_area_id)
        if vr_timing is not None:
            pulumi.set(__self__, "vr_timing", vr_timing)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Instance id
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interface id
        """
        return pulumi.get(self, "interface_id")

    @interface_id.setter
    def interface_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interface_id", value)

    @_builtins.property
    @pulumi.getter(name="neighborId")
    def neighbor_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Neighbor id
        """
        return pulumi.get(self, "neighbor_id")

    @neighbor_id.setter
    def neighbor_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "neighbor_id", value)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passive", value)

    @_builtins.property
    @pulumi.getter
    def timing(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timing
        """
        return pulumi.get(self, "timing")

    @timing.setter
    def timing(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timing", value)

    @_builtins.property
    @pulumi.getter(name="transitAreaId")
    def transit_area_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transit area id
        """
        return pulumi.get(self, "transit_area_id")

    @transit_area_id.setter
    def transit_area_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_area_id", value)

    @_builtins.property
    @pulumi.getter(name="vrTiming")
    def vr_timing(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgs']]:
        """
        Vr timing
        """
        return pulumi.get(self, "vr_timing")

    @vr_timing.setter
    def vr_timing(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgs']]):
        pulumi.set(self, "vr_timing", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaVirtualLinkBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfOspfAreaVirtualLinkBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaVirtualLinkBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgsDict(TypedDict):
        dead_counts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dead counts
        """
        hello_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hello interval
        """
        retransmit_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retransmit interval
        """
        transit_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Transit delay
        """
elif False:
    LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaVirtualLinkVrTimingArgs:
    def __init__(__self__, *,
                 dead_counts: Optional[pulumi.Input[_builtins.int]] = None,
                 hello_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 retransmit_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 transit_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] dead_counts: Dead counts
        :param pulumi.Input[_builtins.int] hello_interval: Hello interval
        :param pulumi.Input[_builtins.int] retransmit_interval: Retransmit interval
        :param pulumi.Input[_builtins.int] transit_delay: Transit delay
        """
        if dead_counts is not None:
            pulumi.set(__self__, "dead_counts", dead_counts)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if retransmit_interval is not None:
            pulumi.set(__self__, "retransmit_interval", retransmit_interval)
        if transit_delay is not None:
            pulumi.set(__self__, "transit_delay", transit_delay)

    @_builtins.property
    @pulumi.getter(name="deadCounts")
    def dead_counts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dead counts
        """
        return pulumi.get(self, "dead_counts")

    @dead_counts.setter
    def dead_counts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dead_counts", value)

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hello interval
        """
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hello_interval", value)

    @_builtins.property
    @pulumi.getter(name="retransmitInterval")
    def retransmit_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retransmit interval
        """
        return pulumi.get(self, "retransmit_interval")

    @retransmit_interval.setter
    def retransmit_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retransmit_interval", value)

    @_builtins.property
    @pulumi.getter(name="transitDelay")
    def transit_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Transit delay
        """
        return pulumi.get(self, "transit_delay")

    @transit_delay.setter
    def transit_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transit_delay", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaVrRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeAdvertiseArgsDict']]
        """
        Advertise
        """
        suppress: NotRequired[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeSuppressArgsDict']]
        """
        Suppress
        """
elif False:
    LogicalRouterVrfOspfAreaVrRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaVrRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeAdvertiseArgs']] = None,
                 suppress: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeSuppressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfOspfAreaVrRangeAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfAreaVrRangeSuppressArgs'] suppress: Suppress
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeSuppressArgs']]:
        """
        Suppress
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfAreaVrRangeSuppressArgs']]):
        pulumi.set(self, "suppress", value)


if not MYPY:
    class LogicalRouterVrfOspfAreaVrRangeAdvertiseArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaVrRangeAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaVrRangeAdvertiseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAreaVrRangeSuppressArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfAreaVrRangeSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAreaVrRangeSuppressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfAuthProfileArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        md5s: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileMd5ArgsDict']]]]
        """
        Md5
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password
        """
elif False:
    LogicalRouterVrfOspfAuthProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAuthProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 md5s: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileMd5Args']]]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileMd5Args']]] md5s: Md5
        :param pulumi.Input[_builtins.str] password: Password
        """
        pulumi.set(__self__, "name", name)
        if md5s is not None:
            pulumi.set(__self__, "md5s", md5s)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def md5s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileMd5Args']]]]:
        """
        Md5
        """
        return pulumi.get(self, "md5s")

    @md5s.setter
    def md5s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfAuthProfileMd5Args']]]]):
        pulumi.set(self, "md5s", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LogicalRouterVrfOspfAuthProfileMd5ArgsDict(TypedDict):
        name: pulumi.Input[_builtins.float]
        """
        Name
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
        preferred: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Preferred
        """
elif False:
    LogicalRouterVrfOspfAuthProfileMd5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfAuthProfileMd5Args:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.float],
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 preferred: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.float] name: Name
        :param pulumi.Input[_builtins.str] key: Key
        :param pulumi.Input[_builtins.bool] preferred: Preferred
        """
        pulumi.set(__self__, "name", name)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if preferred is not None:
            pulumi.set(__self__, "preferred", preferred)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.float]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def preferred(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Preferred
        """
        return pulumi.get(self, "preferred")

    @preferred.setter
    def preferred(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preferred", value)


if not MYPY:
    class LogicalRouterVrfOspfExportRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        new_path_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        New path type
        """
        new_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        New tag
        """
elif False:
    LogicalRouterVrfOspfExportRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfExportRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 new_path_type: Optional[pulumi.Input[_builtins.str]] = None,
                 new_tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] new_path_type: New path type
        :param pulumi.Input[_builtins.str] new_tag: New tag
        """
        pulumi.set(__self__, "name", name)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if new_path_type is not None:
            pulumi.set(__self__, "new_path_type", new_path_type)
        if new_tag is not None:
            pulumi.set(__self__, "new_tag", new_tag)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="newPathType")
    def new_path_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        New path type
        """
        return pulumi.get(self, "new_path_type")

    @new_path_type.setter
    def new_path_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_path_type", value)

    @_builtins.property
    @pulumi.getter(name="newTag")
    def new_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        New tag
        """
        return pulumi.get(self, "new_tag")

    @new_tag.setter
    def new_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_tag", value)


if not MYPY:
    class LogicalRouterVrfOspfFloodPreventionArgsDict(TypedDict):
        hello: NotRequired[pulumi.Input['LogicalRouterVrfOspfFloodPreventionHelloArgsDict']]
        """
        Hello
        """
        lsa: NotRequired[pulumi.Input['LogicalRouterVrfOspfFloodPreventionLsaArgsDict']]
        """
        Lsa
        """
elif False:
    LogicalRouterVrfOspfFloodPreventionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfFloodPreventionArgs:
    def __init__(__self__, *,
                 hello: Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionHelloArgs']] = None,
                 lsa: Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionLsaArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfFloodPreventionHelloArgs'] hello: Hello
        :param pulumi.Input['LogicalRouterVrfOspfFloodPreventionLsaArgs'] lsa: Lsa
        """
        if hello is not None:
            pulumi.set(__self__, "hello", hello)
        if lsa is not None:
            pulumi.set(__self__, "lsa", lsa)

    @_builtins.property
    @pulumi.getter
    def hello(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionHelloArgs']]:
        """
        Hello
        """
        return pulumi.get(self, "hello")

    @hello.setter
    def hello(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionHelloArgs']]):
        pulumi.set(self, "hello", value)

    @_builtins.property
    @pulumi.getter
    def lsa(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionLsaArgs']]:
        """
        Lsa
        """
        return pulumi.get(self, "lsa")

    @lsa.setter
    def lsa(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfFloodPreventionLsaArgs']]):
        pulumi.set(self, "lsa", value)


if not MYPY:
    class LogicalRouterVrfOspfFloodPreventionHelloArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        max_packet: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max packet
        """
elif False:
    LogicalRouterVrfOspfFloodPreventionHelloArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfFloodPreventionHelloArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_packet: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] max_packet: Max packet
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_packet is not None:
            pulumi.set(__self__, "max_packet", max_packet)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maxPacket")
    def max_packet(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max packet
        """
        return pulumi.get(self, "max_packet")

    @max_packet.setter
    def max_packet(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_packet", value)


if not MYPY:
    class LogicalRouterVrfOspfFloodPreventionLsaArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        max_packet: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max packet
        """
elif False:
    LogicalRouterVrfOspfFloodPreventionLsaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfFloodPreventionLsaArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_packet: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] max_packet: Max packet
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_packet is not None:
            pulumi.set(__self__, "max_packet", max_packet)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maxPacket")
    def max_packet(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max packet
        """
        return pulumi.get(self, "max_packet")

    @max_packet.setter
    def max_packet(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_packet", value)


if not MYPY:
    class LogicalRouterVrfOspfGlobalBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfOspfGlobalBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfGlobalBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfOspfGracefulRestartArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        grace_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Grace period
        """
        helper_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Helper enable
        """
        max_neighbor_restart_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max neighbor restart time
        """
        strict_lsa_checking: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strict l s a checking
        """
elif False:
    LogicalRouterVrfOspfGracefulRestartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfGracefulRestartArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 grace_period: Optional[pulumi.Input[_builtins.int]] = None,
                 helper_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_neighbor_restart_time: Optional[pulumi.Input[_builtins.int]] = None,
                 strict_lsa_checking: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] grace_period: Grace period
        :param pulumi.Input[_builtins.bool] helper_enable: Helper enable
        :param pulumi.Input[_builtins.int] max_neighbor_restart_time: Max neighbor restart time
        :param pulumi.Input[_builtins.bool] strict_lsa_checking: Strict l s a checking
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if helper_enable is not None:
            pulumi.set(__self__, "helper_enable", helper_enable)
        if max_neighbor_restart_time is not None:
            pulumi.set(__self__, "max_neighbor_restart_time", max_neighbor_restart_time)
        if strict_lsa_checking is not None:
            pulumi.set(__self__, "strict_lsa_checking", strict_lsa_checking)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Grace period
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_period", value)

    @_builtins.property
    @pulumi.getter(name="helperEnable")
    def helper_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Helper enable
        """
        return pulumi.get(self, "helper_enable")

    @helper_enable.setter
    def helper_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "helper_enable", value)

    @_builtins.property
    @pulumi.getter(name="maxNeighborRestartTime")
    def max_neighbor_restart_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max neighbor restart time
        """
        return pulumi.get(self, "max_neighbor_restart_time")

    @max_neighbor_restart_time.setter
    def max_neighbor_restart_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_neighbor_restart_time", value)

    @_builtins.property
    @pulumi.getter(name="strictLsaChecking")
    def strict_lsa_checking(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strict l s a checking
        """
        return pulumi.get(self, "strict_lsa_checking")

    @strict_lsa_checking.setter
    def strict_lsa_checking(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strict_lsa_checking", value)


if not MYPY:
    class LogicalRouterVrfOspfVrTimersArgsDict(TypedDict):
        lsa_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lsa interval
        """
        spf_calculation_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Spf calculation delay
        """
elif False:
    LogicalRouterVrfOspfVrTimersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfVrTimersArgs:
    def __init__(__self__, *,
                 lsa_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 spf_calculation_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] lsa_interval: Lsa interval
        :param pulumi.Input[_builtins.int] spf_calculation_delay: Spf calculation delay
        """
        if lsa_interval is not None:
            pulumi.set(__self__, "lsa_interval", lsa_interval)
        if spf_calculation_delay is not None:
            pulumi.set(__self__, "spf_calculation_delay", spf_calculation_delay)

    @_builtins.property
    @pulumi.getter(name="lsaInterval")
    def lsa_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lsa interval
        """
        return pulumi.get(self, "lsa_interval")

    @lsa_interval.setter
    def lsa_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lsa_interval", value)

    @_builtins.property
    @pulumi.getter(name="spfCalculationDelay")
    def spf_calculation_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Spf calculation delay
        """
        return pulumi.get(self, "spf_calculation_delay")

    @spf_calculation_delay.setter
    def spf_calculation_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spf_calculation_delay", value)


if not MYPY:
    class LogicalRouterVrfOspfv3ArgsDict(TypedDict):
        allow_redist_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow redist default route
        """
        areas: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaArgsDict']]]]
        """
        Area
        """
        auth_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileArgsDict']]]]
        """
        Auth profile
        """
        disable_transit_traffic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable transit traffic
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        export_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3ExportRuleArgsDict']]]]
        """
        Export rules
        """
        global_bfd: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3GlobalBfdArgsDict']]
        """
        Global bfd
        """
        global_if_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global if timer
        """
        graceful_restart: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3GracefulRestartArgsDict']]
        """
        Graceful restart
        """
        redistribution_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Redistribution profile
        """
        reject_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reject default route
        """
        router_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Router id
        """
        spf_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Spf timer
        """
        vr_timers: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3VrTimersArgsDict']]
        """
        Vr timers
        """
elif False:
    LogicalRouterVrfOspfv3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3Args:
    def __init__(__self__, *,
                 allow_redist_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 areas: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaArgs']]]] = None,
                 auth_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileArgs']]]] = None,
                 disable_transit_traffic: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 export_rules: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3ExportRuleArgs']]]] = None,
                 global_bfd: Optional[pulumi.Input['LogicalRouterVrfOspfv3GlobalBfdArgs']] = None,
                 global_if_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 graceful_restart: Optional[pulumi.Input['LogicalRouterVrfOspfv3GracefulRestartArgs']] = None,
                 redistribution_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 reject_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 router_id: Optional[pulumi.Input[_builtins.str]] = None,
                 spf_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_timers: Optional[pulumi.Input['LogicalRouterVrfOspfv3VrTimersArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_redist_default_route: Allow redist default route
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaArgs']]] areas: Area
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileArgs']]] auth_profiles: Auth profile
        :param pulumi.Input[_builtins.bool] disable_transit_traffic: Disable transit traffic
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3ExportRuleArgs']]] export_rules: Export rules
        :param pulumi.Input['LogicalRouterVrfOspfv3GlobalBfdArgs'] global_bfd: Global bfd
        :param pulumi.Input[_builtins.str] global_if_timer: Global if timer
        :param pulumi.Input['LogicalRouterVrfOspfv3GracefulRestartArgs'] graceful_restart: Graceful restart
        :param pulumi.Input[_builtins.str] redistribution_profile: Redistribution profile
        :param pulumi.Input[_builtins.bool] reject_default_route: Reject default route
        :param pulumi.Input[_builtins.str] router_id: Router id
        :param pulumi.Input[_builtins.str] spf_timer: Spf timer
        :param pulumi.Input['LogicalRouterVrfOspfv3VrTimersArgs'] vr_timers: Vr timers
        """
        if allow_redist_default_route is not None:
            pulumi.set(__self__, "allow_redist_default_route", allow_redist_default_route)
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if auth_profiles is not None:
            pulumi.set(__self__, "auth_profiles", auth_profiles)
        if disable_transit_traffic is not None:
            pulumi.set(__self__, "disable_transit_traffic", disable_transit_traffic)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if export_rules is not None:
            pulumi.set(__self__, "export_rules", export_rules)
        if global_bfd is not None:
            pulumi.set(__self__, "global_bfd", global_bfd)
        if global_if_timer is not None:
            pulumi.set(__self__, "global_if_timer", global_if_timer)
        if graceful_restart is not None:
            pulumi.set(__self__, "graceful_restart", graceful_restart)
        if redistribution_profile is not None:
            pulumi.set(__self__, "redistribution_profile", redistribution_profile)
        if reject_default_route is not None:
            pulumi.set(__self__, "reject_default_route", reject_default_route)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)
        if spf_timer is not None:
            pulumi.set(__self__, "spf_timer", spf_timer)
        if vr_timers is not None:
            pulumi.set(__self__, "vr_timers", vr_timers)

    @_builtins.property
    @pulumi.getter(name="allowRedistDefaultRoute")
    def allow_redist_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow redist default route
        """
        return pulumi.get(self, "allow_redist_default_route")

    @allow_redist_default_route.setter
    def allow_redist_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_redist_default_route", value)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaArgs']]]]:
        """
        Area
        """
        return pulumi.get(self, "areas")

    @areas.setter
    def areas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaArgs']]]]):
        pulumi.set(self, "areas", value)

    @_builtins.property
    @pulumi.getter(name="authProfiles")
    def auth_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileArgs']]]]:
        """
        Auth profile
        """
        return pulumi.get(self, "auth_profiles")

    @auth_profiles.setter
    def auth_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileArgs']]]]):
        pulumi.set(self, "auth_profiles", value)

    @_builtins.property
    @pulumi.getter(name="disableTransitTraffic")
    def disable_transit_traffic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable transit traffic
        """
        return pulumi.get(self, "disable_transit_traffic")

    @disable_transit_traffic.setter
    def disable_transit_traffic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_transit_traffic", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="exportRules")
    def export_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3ExportRuleArgs']]]]:
        """
        Export rules
        """
        return pulumi.get(self, "export_rules")

    @export_rules.setter
    def export_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3ExportRuleArgs']]]]):
        pulumi.set(self, "export_rules", value)

    @_builtins.property
    @pulumi.getter(name="globalBfd")
    def global_bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3GlobalBfdArgs']]:
        """
        Global bfd
        """
        return pulumi.get(self, "global_bfd")

    @global_bfd.setter
    def global_bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3GlobalBfdArgs']]):
        pulumi.set(self, "global_bfd", value)

    @_builtins.property
    @pulumi.getter(name="globalIfTimer")
    def global_if_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global if timer
        """
        return pulumi.get(self, "global_if_timer")

    @global_if_timer.setter
    def global_if_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_if_timer", value)

    @_builtins.property
    @pulumi.getter(name="gracefulRestart")
    def graceful_restart(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3GracefulRestartArgs']]:
        """
        Graceful restart
        """
        return pulumi.get(self, "graceful_restart")

    @graceful_restart.setter
    def graceful_restart(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3GracefulRestartArgs']]):
        pulumi.set(self, "graceful_restart", value)

    @_builtins.property
    @pulumi.getter(name="redistributionProfile")
    def redistribution_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Redistribution profile
        """
        return pulumi.get(self, "redistribution_profile")

    @redistribution_profile.setter
    def redistribution_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redistribution_profile", value)

    @_builtins.property
    @pulumi.getter(name="rejectDefaultRoute")
    def reject_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reject default route
        """
        return pulumi.get(self, "reject_default_route")

    @reject_default_route.setter
    def reject_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_default_route", value)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Router id
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "router_id", value)

    @_builtins.property
    @pulumi.getter(name="spfTimer")
    def spf_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Spf timer
        """
        return pulumi.get(self, "spf_timer")

    @spf_timer.setter
    def spf_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spf_timer", value)

    @_builtins.property
    @pulumi.getter(name="vrTimers")
    def vr_timers(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3VrTimersArgs']]:
        """
        Vr timers
        """
        return pulumi.get(self, "vr_timers")

    @vr_timers.setter
    def vr_timers(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3VrTimersArgs']]):
        pulumi.set(self, "vr_timers", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceArgsDict']]]]
        """
        Interface
        """
        ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaRangeArgsDict']]]]
        """
        Range
        """
        type: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeArgsDict']]
        """
        Type
        """
        virtual_links: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkArgsDict']]]]
        """
        Virtual link
        """
        vr_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeArgsDict']]]]
        """
        Vr range
        """
elif False:
    LogicalRouterVrfOspfv3AreaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceArgs']]]] = None,
                 ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaRangeArgs']]]] = None,
                 type: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeArgs']] = None,
                 virtual_links: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkArgs']]]] = None,
                 vr_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceArgs']]] interfaces: Interface
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaRangeArgs']]] ranges: Range
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeArgs'] type: Type
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkArgs']]] virtual_links: Virtual link
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeArgs']]] vr_ranges: Vr range
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if virtual_links is not None:
            pulumi.set(__self__, "virtual_links", virtual_links)
        if vr_ranges is not None:
            pulumi.set(__self__, "vr_ranges", vr_ranges)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceArgs']]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaRangeArgs']]]]:
        """
        Range
        """
        return pulumi.get(self, "ranges")

    @ranges.setter
    def ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaRangeArgs']]]]):
        pulumi.set(self, "ranges", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeArgs']]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeArgs']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="virtualLinks")
    def virtual_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkArgs']]]]:
        """
        Virtual link
        """
        return pulumi.get(self, "virtual_links")

    @virtual_links.setter
    def virtual_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkArgs']]]]):
        pulumi.set(self, "virtual_links", value)

    @_builtins.property
    @pulumi.getter(name="vrRanges")
    def vr_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeArgs']]]]:
        """
        Vr range
        """
        return pulumi.get(self, "vr_ranges")

    @vr_ranges.setter
    def vr_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeArgs']]]]):
        pulumi.set(self, "vr_ranges", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceBfdArgsDict']]
        """
        Bfd
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        instance_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Instance id
        """
        link_type: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgsDict']]
        """
        Link type
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        mtu_ignore: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mtu ignore
        """
        neighbors: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceNeighborArgsDict']]]]
        """
        Neighbor
        """
        passive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passive
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority
        """
        timing: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timing
        """
        vr_timing: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgsDict']]
        """
        Vr timing
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceBfdArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.int]] = None,
                 link_type: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgs']] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 mtu_ignore: Optional[pulumi.Input[_builtins.bool]] = None,
                 neighbors: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceNeighborArgs']]]] = None,
                 passive: Optional[pulumi.Input[_builtins.bool]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 timing: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_timing: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] instance_id: Instance id
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgs'] link_type: Link type
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.bool] mtu_ignore: Mtu ignore
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceNeighborArgs']]] neighbors: Neighbor
        :param pulumi.Input[_builtins.bool] passive: Passive
        :param pulumi.Input[_builtins.int] priority: Priority
        :param pulumi.Input[_builtins.str] timing: Timing
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgs'] vr_timing: Vr timing
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if link_type is not None:
            pulumi.set(__self__, "link_type", link_type)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if mtu_ignore is not None:
            pulumi.set(__self__, "mtu_ignore", mtu_ignore)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if timing is not None:
            pulumi.set(__self__, "timing", timing)
        if vr_timing is not None:
            pulumi.set(__self__, "vr_timing", vr_timing)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Instance id
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="linkType")
    def link_type(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgs']]:
        """
        Link type
        """
        return pulumi.get(self, "link_type")

    @link_type.setter
    def link_type(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgs']]):
        pulumi.set(self, "link_type", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="mtuIgnore")
    def mtu_ignore(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mtu ignore
        """
        return pulumi.get(self, "mtu_ignore")

    @mtu_ignore.setter
    def mtu_ignore(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mtu_ignore", value)

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceNeighborArgs']]]]:
        """
        Neighbor
        """
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceNeighborArgs']]]]):
        pulumi.set(self, "neighbors", value)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passive", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def timing(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timing
        """
        return pulumi.get(self, "timing")

    @timing.setter
    def timing(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timing", value)

    @_builtins.property
    @pulumi.getter(name="vrTiming")
    def vr_timing(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgs']]:
        """
        Vr timing
        """
        return pulumi.get(self, "vr_timing")

    @vr_timing.setter
    def vr_timing(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgs']]):
        pulumi.set(self, "vr_timing", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgsDict(TypedDict):
        broadcast: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgsDict']]
        """
        Broadcast
        """
        p2mp: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgsDict']]
        """
        P2mp

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        p2p: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgsDict']]
        """
        P2p

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeArgs:
    def __init__(__self__, *,
                 broadcast: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgs']] = None,
                 p2mp: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgs']] = None,
                 p2p: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgs'] broadcast: Broadcast
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgs'] p2mp: P2mp
               
               >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgs'] p2p: P2p
               
               >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        if broadcast is not None:
            pulumi.set(__self__, "broadcast", broadcast)
        if p2mp is not None:
            pulumi.set(__self__, "p2mp", p2mp)
        if p2p is not None:
            pulumi.set(__self__, "p2p", p2p)

    @_builtins.property
    @pulumi.getter
    def broadcast(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgs']]:
        """
        Broadcast
        """
        return pulumi.get(self, "broadcast")

    @broadcast.setter
    def broadcast(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgs']]):
        pulumi.set(self, "broadcast", value)

    @_builtins.property
    @pulumi.getter
    def p2mp(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgs']]:
        """
        P2mp

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        return pulumi.get(self, "p2mp")

    @p2mp.setter
    def p2mp(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgs']]):
        pulumi.set(self, "p2mp", value)

    @_builtins.property
    @pulumi.getter
    def p2p(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgs']]:
        """
        P2p

        >  **Note:** You must specify exactly one of `broadcast`, `p2mp`, and `p2p`.
        """
        return pulumi.get(self, "p2p")

    @p2p.setter
    def p2p(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgs']]):
        pulumi.set(self, "p2p", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeBroadcastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgsDict(TypedDict):
        neighbors: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgsDict']]]]
        """
        Neighbor
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpArgs:
    def __init__(__self__, *,
                 neighbors: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgs']]] neighbors: Neighbor
        """
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgs']]]]:
        """
        Neighbor
        """
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgs']]]]):
        pulumi.set(self, "neighbors", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] priority: Priority
        """
        pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceLinkTypeP2pArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceNeighborArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceNeighborArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceNeighborArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgsDict(TypedDict):
        dead_counts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dead counts
        """
        gr_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Gr delay
        """
        hello_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hello interval
        """
        retransmit_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retransmit interval
        """
        transit_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Transit delay
        """
elif False:
    LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaInterfaceVrTimingArgs:
    def __init__(__self__, *,
                 dead_counts: Optional[pulumi.Input[_builtins.int]] = None,
                 gr_delay: Optional[pulumi.Input[_builtins.int]] = None,
                 hello_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 retransmit_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 transit_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] dead_counts: Dead counts
        :param pulumi.Input[_builtins.int] gr_delay: Gr delay
        :param pulumi.Input[_builtins.int] hello_interval: Hello interval
        :param pulumi.Input[_builtins.int] retransmit_interval: Retransmit interval
        :param pulumi.Input[_builtins.int] transit_delay: Transit delay
        """
        if dead_counts is not None:
            pulumi.set(__self__, "dead_counts", dead_counts)
        if gr_delay is not None:
            pulumi.set(__self__, "gr_delay", gr_delay)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if retransmit_interval is not None:
            pulumi.set(__self__, "retransmit_interval", retransmit_interval)
        if transit_delay is not None:
            pulumi.set(__self__, "transit_delay", transit_delay)

    @_builtins.property
    @pulumi.getter(name="deadCounts")
    def dead_counts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dead counts
        """
        return pulumi.get(self, "dead_counts")

    @dead_counts.setter
    def dead_counts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dead_counts", value)

    @_builtins.property
    @pulumi.getter(name="grDelay")
    def gr_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Gr delay
        """
        return pulumi.get(self, "gr_delay")

    @gr_delay.setter
    def gr_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gr_delay", value)

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hello interval
        """
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hello_interval", value)

    @_builtins.property
    @pulumi.getter(name="retransmitInterval")
    def retransmit_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retransmit interval
        """
        return pulumi.get(self, "retransmit_interval")

    @retransmit_interval.setter
    def retransmit_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retransmit_interval", value)

    @_builtins.property
    @pulumi.getter(name="transitDelay")
    def transit_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Transit delay
        """
        return pulumi.get(self, "transit_delay")

    @transit_delay.setter
    def transit_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transit_delay", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Advertise
        """
elif False:
    LogicalRouterVrfOspfv3AreaRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.bool] advertise: Advertise
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "advertise", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeArgsDict(TypedDict):
        normal: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalArgsDict']]
        """
        Normal
        """
        nssa: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaArgsDict']]
        """
        Nssa

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        stub: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubArgsDict']]
        """
        Stub

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeArgs:
    def __init__(__self__, *,
                 normal: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalArgs']] = None,
                 nssa: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaArgs']] = None,
                 stub: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalArgs'] normal: Normal
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaArgs'] nssa: Nssa
               
               >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubArgs'] stub: Stub
               
               >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        if normal is not None:
            pulumi.set(__self__, "normal", normal)
        if nssa is not None:
            pulumi.set(__self__, "nssa", nssa)
        if stub is not None:
            pulumi.set(__self__, "stub", stub)

    @_builtins.property
    @pulumi.getter
    def normal(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalArgs']]:
        """
        Normal
        """
        return pulumi.get(self, "normal")

    @normal.setter
    def normal(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalArgs']]):
        pulumi.set(self, "normal", value)

    @_builtins.property
    @pulumi.getter
    def nssa(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaArgs']]:
        """
        Nssa

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        return pulumi.get(self, "nssa")

    @nssa.setter
    def nssa(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaArgs']]):
        pulumi.set(self, "nssa", value)

    @_builtins.property
    @pulumi.getter
    def stub(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubArgs']]:
        """
        Stub

        >  **Note:** You must specify exactly one of `normal`, `nssa`, and `stub`.
        """
        return pulumi.get(self, "stub")

    @stub.setter
    def stub(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubArgs']]):
        pulumi.set(self, "stub", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNormalArgsDict(TypedDict):
        abr: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalAbrArgsDict']]
        """
        Abr
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNormalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNormalArgs:
    def __init__(__self__, *,
                 abr: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalAbrArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalAbrArgs'] abr: Abr
        """
        if abr is not None:
            pulumi.set(__self__, "abr", abr)

    @_builtins.property
    @pulumi.getter
    def abr(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalAbrArgs']]:
        """
        Abr
        """
        return pulumi.get(self, "abr")

    @abr.setter
    def abr(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNormalAbrArgs']]):
        pulumi.set(self, "abr", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNormalAbrArgsDict(TypedDict):
        export_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export list
        """
        import_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import list
        """
        inbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound filter list
        """
        outbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound filter list
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNormalAbrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNormalAbrArgs:
    def __init__(__self__, *,
                 export_list: Optional[pulumi.Input[_builtins.str]] = None,
                 import_list: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_list: Export list
        :param pulumi.Input[_builtins.str] import_list: Import list
        :param pulumi.Input[_builtins.str] inbound_filter_list: Inbound filter list
        :param pulumi.Input[_builtins.str] outbound_filter_list: Outbound filter list
        """
        if export_list is not None:
            pulumi.set(__self__, "export_list", export_list)
        if import_list is not None:
            pulumi.set(__self__, "import_list", import_list)
        if inbound_filter_list is not None:
            pulumi.set(__self__, "inbound_filter_list", inbound_filter_list)
        if outbound_filter_list is not None:
            pulumi.set(__self__, "outbound_filter_list", outbound_filter_list)

    @_builtins.property
    @pulumi.getter(name="exportList")
    def export_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export list
        """
        return pulumi.get(self, "export_list")

    @export_list.setter
    def export_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_list", value)

    @_builtins.property
    @pulumi.getter(name="importList")
    def import_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import list
        """
        return pulumi.get(self, "import_list")

    @import_list.setter
    def import_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundFilterList")
    def inbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound filter list
        """
        return pulumi.get(self, "inbound_filter_list")

    @inbound_filter_list.setter
    def inbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_filter_list", value)

    @_builtins.property
    @pulumi.getter(name="outboundFilterList")
    def outbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound filter list
        """
        return pulumi.get(self, "outbound_filter_list")

    @outbound_filter_list.setter
    def outbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_filter_list", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaArgsDict(TypedDict):
        abr: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrArgsDict']]
        """
        Abr
        """
        accept_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept summary
        """
        default_information_originate: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgsDict']]
        """
        Default information originate
        """
        default_route: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgsDict']]
        """
        Default route
        """
        no_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        No summary
        """
        nssa_ext_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgsDict']]]]
        """
        Nssa ext range
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaArgs:
    def __init__(__self__, *,
                 abr: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrArgs']] = None,
                 accept_summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_information_originate: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgs']] = None,
                 default_route: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgs']] = None,
                 no_summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 nssa_ext_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgs']]]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrArgs'] abr: Abr
        :param pulumi.Input[_builtins.bool] accept_summary: Accept summary
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgs'] default_information_originate: Default information originate
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgs'] default_route: Default route
        :param pulumi.Input[_builtins.bool] no_summary: No summary
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgs']]] nssa_ext_ranges: Nssa ext range
        """
        if abr is not None:
            pulumi.set(__self__, "abr", abr)
        if accept_summary is not None:
            pulumi.set(__self__, "accept_summary", accept_summary)
        if default_information_originate is not None:
            pulumi.set(__self__, "default_information_originate", default_information_originate)
        if default_route is not None:
            pulumi.set(__self__, "default_route", default_route)
        if no_summary is not None:
            pulumi.set(__self__, "no_summary", no_summary)
        if nssa_ext_ranges is not None:
            pulumi.set(__self__, "nssa_ext_ranges", nssa_ext_ranges)

    @_builtins.property
    @pulumi.getter
    def abr(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrArgs']]:
        """
        Abr
        """
        return pulumi.get(self, "abr")

    @abr.setter
    def abr(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrArgs']]):
        pulumi.set(self, "abr", value)

    @_builtins.property
    @pulumi.getter(name="acceptSummary")
    def accept_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept summary
        """
        return pulumi.get(self, "accept_summary")

    @accept_summary.setter
    def accept_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_summary", value)

    @_builtins.property
    @pulumi.getter(name="defaultInformationOriginate")
    def default_information_originate(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgs']]:
        """
        Default information originate
        """
        return pulumi.get(self, "default_information_originate")

    @default_information_originate.setter
    def default_information_originate(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgs']]):
        pulumi.set(self, "default_information_originate", value)

    @_builtins.property
    @pulumi.getter(name="defaultRoute")
    def default_route(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgs']]:
        """
        Default route
        """
        return pulumi.get(self, "default_route")

    @default_route.setter
    def default_route(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgs']]):
        pulumi.set(self, "default_route", value)

    @_builtins.property
    @pulumi.getter(name="noSummary")
    def no_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        No summary
        """
        return pulumi.get(self, "no_summary")

    @no_summary.setter
    def no_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_summary", value)

    @_builtins.property
    @pulumi.getter(name="nssaExtRanges")
    def nssa_ext_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgs']]]]:
        """
        Nssa ext range
        """
        return pulumi.get(self, "nssa_ext_ranges")

    @nssa_ext_ranges.setter
    def nssa_ext_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgs']]]]):
        pulumi.set(self, "nssa_ext_ranges", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaAbrArgsDict(TypedDict):
        export_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export list
        """
        import_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import list
        """
        inbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound filter list
        """
        nssa_ext_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgsDict']]]]
        """
        Nssa ext range
        """
        outbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound filter list
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaAbrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaAbrArgs:
    def __init__(__self__, *,
                 export_list: Optional[pulumi.Input[_builtins.str]] = None,
                 import_list: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None,
                 nssa_ext_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgs']]]] = None,
                 outbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_list: Export list
        :param pulumi.Input[_builtins.str] import_list: Import list
        :param pulumi.Input[_builtins.str] inbound_filter_list: Inbound filter list
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgs']]] nssa_ext_ranges: Nssa ext range
        :param pulumi.Input[_builtins.str] outbound_filter_list: Outbound filter list
        """
        if export_list is not None:
            pulumi.set(__self__, "export_list", export_list)
        if import_list is not None:
            pulumi.set(__self__, "import_list", import_list)
        if inbound_filter_list is not None:
            pulumi.set(__self__, "inbound_filter_list", inbound_filter_list)
        if nssa_ext_ranges is not None:
            pulumi.set(__self__, "nssa_ext_ranges", nssa_ext_ranges)
        if outbound_filter_list is not None:
            pulumi.set(__self__, "outbound_filter_list", outbound_filter_list)

    @_builtins.property
    @pulumi.getter(name="exportList")
    def export_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export list
        """
        return pulumi.get(self, "export_list")

    @export_list.setter
    def export_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_list", value)

    @_builtins.property
    @pulumi.getter(name="importList")
    def import_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import list
        """
        return pulumi.get(self, "import_list")

    @import_list.setter
    def import_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundFilterList")
    def inbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound filter list
        """
        return pulumi.get(self, "inbound_filter_list")

    @inbound_filter_list.setter
    def inbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_filter_list", value)

    @_builtins.property
    @pulumi.getter(name="nssaExtRanges")
    def nssa_ext_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgs']]]]:
        """
        Nssa ext range
        """
        return pulumi.get(self, "nssa_ext_ranges")

    @nssa_ext_ranges.setter
    def nssa_ext_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgs']]]]):
        pulumi.set(self, "nssa_ext_ranges", value)

    @_builtins.property
    @pulumi.getter(name="outboundFilterList")
    def outbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound filter list
        """
        return pulumi.get(self, "outbound_filter_list")

    @outbound_filter_list.setter
    def outbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_filter_list", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgsDict']]
        """
        Advertise
        """
        route_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route tag
        """
        suppress: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgsDict']]
        """
        Suppress
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgs']] = None,
                 route_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 suppress: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input[_builtins.int] route_tag: Route tag
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgs'] suppress: Suppress
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if route_tag is not None:
            pulumi.set(__self__, "route_tag", route_tag)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter(name="routeTag")
    def route_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route tag
        """
        return pulumi.get(self, "route_tag")

    @route_tag.setter
    def route_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "route_tag", value)

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgs']]:
        """
        Suppress
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgs']]):
        pulumi.set(self, "suppress", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeAdvertiseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaAbrNssaExtRangeSuppressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Metric type
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaDefaultInformationOriginateArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] metric_type: Metric type
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Metric type
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgsDict(TypedDict):
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgsDict']]
        """
        Advertise
        """
        disable: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgsDict']]
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteArgs:
    def __init__(__self__, *,
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgs']] = None,
                 disable: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgs'] disable: Disable
               
               >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgs']]:
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgs']]):
        pulumi.set(self, "disable", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteAdvertiseArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] type: Type
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaDefaultRouteDisableArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgsDict']]
        """
        Advertise
        """
        route_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Route tag
        """
        suppress: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgsDict']]
        """
        Suppress
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgs']] = None,
                 route_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 suppress: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input[_builtins.int] route_tag: Route tag
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgs'] suppress: Suppress
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if route_tag is not None:
            pulumi.set(__self__, "route_tag", route_tag)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter(name="routeTag")
    def route_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Route tag
        """
        return pulumi.get(self, "route_tag")

    @route_tag.setter
    def route_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "route_tag", value)

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgs']]:
        """
        Suppress
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgs']]):
        pulumi.set(self, "suppress", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeAdvertiseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeNssaNssaExtRangeSuppressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeStubArgsDict(TypedDict):
        abr: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubAbrArgsDict']]
        """
        Abr
        """
        accept_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept summary
        """
        default_route: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgsDict']]
        """
        Default route
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Default route metric
        """
        no_summary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        No summary
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeStubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeStubArgs:
    def __init__(__self__, *,
                 abr: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubAbrArgs']] = None,
                 accept_summary: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_route: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgs']] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 no_summary: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubAbrArgs'] abr: Abr
        :param pulumi.Input[_builtins.bool] accept_summary: Accept summary
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgs'] default_route: Default route
        :param pulumi.Input[_builtins.int] default_route_metric: Default route metric
        :param pulumi.Input[_builtins.bool] no_summary: No summary
        """
        if abr is not None:
            pulumi.set(__self__, "abr", abr)
        if accept_summary is not None:
            pulumi.set(__self__, "accept_summary", accept_summary)
        if default_route is not None:
            pulumi.set(__self__, "default_route", default_route)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if no_summary is not None:
            pulumi.set(__self__, "no_summary", no_summary)

    @_builtins.property
    @pulumi.getter
    def abr(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubAbrArgs']]:
        """
        Abr
        """
        return pulumi.get(self, "abr")

    @abr.setter
    def abr(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubAbrArgs']]):
        pulumi.set(self, "abr", value)

    @_builtins.property
    @pulumi.getter(name="acceptSummary")
    def accept_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept summary
        """
        return pulumi.get(self, "accept_summary")

    @accept_summary.setter
    def accept_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_summary", value)

    @_builtins.property
    @pulumi.getter(name="defaultRoute")
    def default_route(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgs']]:
        """
        Default route
        """
        return pulumi.get(self, "default_route")

    @default_route.setter
    def default_route(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgs']]):
        pulumi.set(self, "default_route", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Default route metric
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter(name="noSummary")
    def no_summary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        No summary
        """
        return pulumi.get(self, "no_summary")

    @no_summary.setter
    def no_summary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_summary", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeStubAbrArgsDict(TypedDict):
        export_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Export list
        """
        import_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Import list
        """
        inbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inbound filter list
        """
        outbound_filter_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Outbound filter list
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeStubAbrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeStubAbrArgs:
    def __init__(__self__, *,
                 export_list: Optional[pulumi.Input[_builtins.str]] = None,
                 import_list: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_filter_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] export_list: Export list
        :param pulumi.Input[_builtins.str] import_list: Import list
        :param pulumi.Input[_builtins.str] inbound_filter_list: Inbound filter list
        :param pulumi.Input[_builtins.str] outbound_filter_list: Outbound filter list
        """
        if export_list is not None:
            pulumi.set(__self__, "export_list", export_list)
        if import_list is not None:
            pulumi.set(__self__, "import_list", import_list)
        if inbound_filter_list is not None:
            pulumi.set(__self__, "inbound_filter_list", inbound_filter_list)
        if outbound_filter_list is not None:
            pulumi.set(__self__, "outbound_filter_list", outbound_filter_list)

    @_builtins.property
    @pulumi.getter(name="exportList")
    def export_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Export list
        """
        return pulumi.get(self, "export_list")

    @export_list.setter
    def export_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_list", value)

    @_builtins.property
    @pulumi.getter(name="importList")
    def import_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Import list
        """
        return pulumi.get(self, "import_list")

    @import_list.setter
    def import_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "import_list", value)

    @_builtins.property
    @pulumi.getter(name="inboundFilterList")
    def inbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inbound filter list
        """
        return pulumi.get(self, "inbound_filter_list")

    @inbound_filter_list.setter
    def inbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_filter_list", value)

    @_builtins.property
    @pulumi.getter(name="outboundFilterList")
    def outbound_filter_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Outbound filter list
        """
        return pulumi.get(self, "outbound_filter_list")

    @outbound_filter_list.setter
    def outbound_filter_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_filter_list", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgsDict(TypedDict):
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgsDict']]
        """
        Advertise
        """
        disable: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgsDict']]
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteArgs:
    def __init__(__self__, *,
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgs']] = None,
                 disable: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgs'] disable: Disable
               
               >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgs']]:
        """
        Disable

        >  **Note:** You must specify exactly one of `advertise` and `disable`.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgs']]):
        pulumi.set(self, "disable", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
elif False:
    LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteAdvertiseArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] metric: Metric
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaTypeStubDefaultRouteDisableArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaVirtualLinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgsDict']]
        """
        Bfd
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        instance_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Instance id
        """
        interface_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interface id
        """
        neighbor_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Neighbor id
        """
        passive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Passive
        """
        timing: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timing
        """
        transit_area_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transit area id
        """
        vr_timing: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgsDict']]
        """
        Vr timing
        """
elif False:
    LogicalRouterVrfOspfv3AreaVirtualLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaVirtualLinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.int]] = None,
                 interface_id: Optional[pulumi.Input[_builtins.int]] = None,
                 neighbor_id: Optional[pulumi.Input[_builtins.str]] = None,
                 passive: Optional[pulumi.Input[_builtins.bool]] = None,
                 timing: Optional[pulumi.Input[_builtins.str]] = None,
                 transit_area_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vr_timing: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] instance_id: Instance id
        :param pulumi.Input[_builtins.int] interface_id: Interface id
        :param pulumi.Input[_builtins.str] neighbor_id: Neighbor id
        :param pulumi.Input[_builtins.bool] passive: Passive
        :param pulumi.Input[_builtins.str] timing: Timing
        :param pulumi.Input[_builtins.str] transit_area_id: Transit area id
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgs'] vr_timing: Vr timing
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)
        if neighbor_id is not None:
            pulumi.set(__self__, "neighbor_id", neighbor_id)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)
        if timing is not None:
            pulumi.set(__self__, "timing", timing)
        if transit_area_id is not None:
            pulumi.set(__self__, "transit_area_id", transit_area_id)
        if vr_timing is not None:
            pulumi.set(__self__, "vr_timing", vr_timing)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Instance id
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interface id
        """
        return pulumi.get(self, "interface_id")

    @interface_id.setter
    def interface_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interface_id", value)

    @_builtins.property
    @pulumi.getter(name="neighborId")
    def neighbor_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Neighbor id
        """
        return pulumi.get(self, "neighbor_id")

    @neighbor_id.setter
    def neighbor_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "neighbor_id", value)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "passive", value)

    @_builtins.property
    @pulumi.getter
    def timing(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timing
        """
        return pulumi.get(self, "timing")

    @timing.setter
    def timing(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timing", value)

    @_builtins.property
    @pulumi.getter(name="transitAreaId")
    def transit_area_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transit area id
        """
        return pulumi.get(self, "transit_area_id")

    @transit_area_id.setter
    def transit_area_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_area_id", value)

    @_builtins.property
    @pulumi.getter(name="vrTiming")
    def vr_timing(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgs']]:
        """
        Vr timing
        """
        return pulumi.get(self, "vr_timing")

    @vr_timing.setter
    def vr_timing(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgs']]):
        pulumi.set(self, "vr_timing", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaVirtualLinkBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgsDict(TypedDict):
        dead_counts: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dead counts
        """
        hello_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hello interval
        """
        retransmit_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retransmit interval
        """
        transit_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Transit delay
        """
elif False:
    LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaVirtualLinkVrTimingArgs:
    def __init__(__self__, *,
                 dead_counts: Optional[pulumi.Input[_builtins.int]] = None,
                 hello_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 retransmit_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 transit_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] dead_counts: Dead counts
        :param pulumi.Input[_builtins.int] hello_interval: Hello interval
        :param pulumi.Input[_builtins.int] retransmit_interval: Retransmit interval
        :param pulumi.Input[_builtins.int] transit_delay: Transit delay
        """
        if dead_counts is not None:
            pulumi.set(__self__, "dead_counts", dead_counts)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if retransmit_interval is not None:
            pulumi.set(__self__, "retransmit_interval", retransmit_interval)
        if transit_delay is not None:
            pulumi.set(__self__, "transit_delay", transit_delay)

    @_builtins.property
    @pulumi.getter(name="deadCounts")
    def dead_counts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dead counts
        """
        return pulumi.get(self, "dead_counts")

    @dead_counts.setter
    def dead_counts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dead_counts", value)

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hello interval
        """
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hello_interval", value)

    @_builtins.property
    @pulumi.getter(name="retransmitInterval")
    def retransmit_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retransmit interval
        """
        return pulumi.get(self, "retransmit_interval")

    @retransmit_interval.setter
    def retransmit_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retransmit_interval", value)

    @_builtins.property
    @pulumi.getter(name="transitDelay")
    def transit_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Transit delay
        """
        return pulumi.get(self, "transit_delay")

    @transit_delay.setter
    def transit_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transit_delay", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaVrRangeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        advertise: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgsDict']]
        """
        Advertise
        """
        suppress: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeSuppressArgsDict']]
        """
        Suppress
        """
elif False:
    LogicalRouterVrfOspfv3AreaVrRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaVrRangeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 advertise: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgs']] = None,
                 suppress: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeSuppressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgs'] advertise: Advertise
        :param pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeSuppressArgs'] suppress: Suppress
        """
        pulumi.set(__self__, "name", name)
        if advertise is not None:
            pulumi.set(__self__, "advertise", advertise)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def advertise(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgs']]:
        """
        Advertise
        """
        return pulumi.get(self, "advertise")

    @advertise.setter
    def advertise(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgs']]):
        pulumi.set(self, "advertise", value)

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeSuppressArgs']]:
        """
        Suppress
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AreaVrRangeSuppressArgs']]):
        pulumi.set(self, "suppress", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaVrRangeAdvertiseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AreaVrRangeSuppressArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AreaVrRangeSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AreaVrRangeSuppressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        ah: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhArgsDict']]
        """
        Ah
        """
        esp: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspArgsDict']]
        """
        Esp
        """
        spi: NotRequired[pulumi.Input[_builtins.str]]
        """
        Spi
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 ah: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhArgs']] = None,
                 esp: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspArgs']] = None,
                 spi: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhArgs'] ah: Ah
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspArgs'] esp: Esp
        :param pulumi.Input[_builtins.str] spi: Spi
        """
        pulumi.set(__self__, "name", name)
        if ah is not None:
            pulumi.set(__self__, "ah", ah)
        if esp is not None:
            pulumi.set(__self__, "esp", esp)
        if spi is not None:
            pulumi.set(__self__, "spi", spi)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ah(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhArgs']]:
        """
        Ah
        """
        return pulumi.get(self, "ah")

    @ah.setter
    def ah(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhArgs']]):
        pulumi.set(self, "ah", value)

    @_builtins.property
    @pulumi.getter
    def esp(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspArgs']]:
        """
        Esp
        """
        return pulumi.get(self, "esp")

    @esp.setter
    def esp(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspArgs']]):
        pulumi.set(self, "esp", value)

    @_builtins.property
    @pulumi.getter
    def spi(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Spi
        """
        return pulumi.get(self, "spi")

    @spi.setter
    def spi(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spi", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileAhArgsDict(TypedDict):
        md5: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhMd5ArgsDict']]
        """
        Md5
        """
        sha1: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha1ArgsDict']]
        """
        Sha1

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha256: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha256ArgsDict']]
        """
        Sha256

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha384: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha384ArgsDict']]
        """
        Sha384

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha512: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha512ArgsDict']]
        """
        Sha512

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileAhArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileAhArgs:
    def __init__(__self__, *,
                 md5: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhMd5Args']] = None,
                 sha1: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha1Args']] = None,
                 sha256: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha256Args']] = None,
                 sha384: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha384Args']] = None,
                 sha512: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha512Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhMd5Args'] md5: Md5
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha1Args'] sha1: Sha1
               
               >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha256Args'] sha256: Sha256
               
               >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha384Args'] sha384: Sha384
               
               >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha512Args'] sha512: Sha512
               
               >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if sha384 is not None:
            pulumi.set(__self__, "sha384", sha384)
        if sha512 is not None:
            pulumi.set(__self__, "sha512", sha512)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhMd5Args']]:
        """
        Md5
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhMd5Args']]):
        pulumi.set(self, "md5", value)

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha1Args']]:
        """
        Sha1

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha1")

    @sha1.setter
    def sha1(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha1Args']]):
        pulumi.set(self, "sha1", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha256Args']]:
        """
        Sha256

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha256Args']]):
        pulumi.set(self, "sha256", value)

    @_builtins.property
    @pulumi.getter
    def sha384(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha384Args']]:
        """
        Sha384

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha384")

    @sha384.setter
    def sha384(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha384Args']]):
        pulumi.set(self, "sha384", value)

    @_builtins.property
    @pulumi.getter
    def sha512(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha512Args']]:
        """
        Sha512

        >  **Note:** You must specify exactly one of `md5`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha512")

    @sha512.setter
    def sha512(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileAhSha512Args']]):
        pulumi.set(self, "sha512", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileAhMd5ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileAhMd5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileAhMd5Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileAhSha1ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileAhSha1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileAhSha1Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileAhSha256ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileAhSha256ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileAhSha256Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileAhSha384ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileAhSha384ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileAhSha384Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileAhSha512ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileAhSha512ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileAhSha512Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgsDict']]
        """
        Authentication
        """
        encryption: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgsDict']]
        """
        Encryption
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgs']] = None,
                 encryption: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgs'] authentication: Authentication
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgs'] encryption: Encryption
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgs']]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgs']]:
        """
        Encryption
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgs']]):
        pulumi.set(self, "encryption", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgsDict(TypedDict):
        md5: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5ArgsDict']]
        """
        Md5
        """
        none: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha1: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1ArgsDict']]
        """
        Sha1

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha256: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256ArgsDict']]
        """
        Sha256

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha384: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384ArgsDict']]
        """
        Sha384

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        sha512: NotRequired[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512ArgsDict']]
        """
        Sha512

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationArgs:
    def __init__(__self__, *,
                 md5: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5Args']] = None,
                 none: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgs']] = None,
                 sha1: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1Args']] = None,
                 sha256: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256Args']] = None,
                 sha384: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384Args']] = None,
                 sha512: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5Args'] md5: Md5
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1Args'] sha1: Sha1
               
               >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256Args'] sha256: Sha256
               
               >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384Args'] sha384: Sha384
               
               >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        :param pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512Args'] sha512: Sha512
               
               >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if sha384 is not None:
            pulumi.set(__self__, "sha384", sha384)
        if sha512 is not None:
            pulumi.set(__self__, "sha512", sha512)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5Args']]:
        """
        Md5
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5Args']]):
        pulumi.set(self, "md5", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1Args']]:
        """
        Sha1

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha1")

    @sha1.setter
    def sha1(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1Args']]):
        pulumi.set(self, "sha1", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256Args']]:
        """
        Sha256

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256Args']]):
        pulumi.set(self, "sha256", value)

    @_builtins.property
    @pulumi.getter
    def sha384(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384Args']]:
        """
        Sha384

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha384")

    @sha384.setter
    def sha384(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384Args']]):
        pulumi.set(self, "sha384", value)

    @_builtins.property
    @pulumi.getter
    def sha512(self) -> Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512Args']]:
        """
        Sha512

        >  **Note:** You must specify exactly one of `md5`, `none`, `sha1`, `sha256`, `sha384`, and `sha512`.
        """
        return pulumi.get(self, "sha512")

    @sha512.setter
    def sha512(self, value: Optional[pulumi.Input['LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512Args']]):
        pulumi.set(self, "sha512", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationMd5Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha1Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha256Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha384Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspAuthenticationSha512Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Key
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Algorithm
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key
        """
elif False:
    LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3AuthProfileEspEncryptionArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] algorithm: Algorithm
        :param pulumi.Input[_builtins.str] key: Key
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Algorithm
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class LogicalRouterVrfOspfv3ExportRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        new_path_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        New path type
        """
        new_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        New tag
        """
elif False:
    LogicalRouterVrfOspfv3ExportRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3ExportRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 new_path_type: Optional[pulumi.Input[_builtins.str]] = None,
                 new_tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input[_builtins.str] new_path_type: New path type
        :param pulumi.Input[_builtins.str] new_tag: New tag
        """
        pulumi.set(__self__, "name", name)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if new_path_type is not None:
            pulumi.set(__self__, "new_path_type", new_path_type)
        if new_tag is not None:
            pulumi.set(__self__, "new_tag", new_tag)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="newPathType")
    def new_path_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        New path type
        """
        return pulumi.get(self, "new_path_type")

    @new_path_type.setter
    def new_path_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_path_type", value)

    @_builtins.property
    @pulumi.getter(name="newTag")
    def new_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        New tag
        """
        return pulumi.get(self, "new_tag")

    @new_tag.setter
    def new_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_tag", value)


if not MYPY:
    class LogicalRouterVrfOspfv3GlobalBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfOspfv3GlobalBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3GlobalBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfOspfv3GracefulRestartArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        grace_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Grace period
        """
        helper_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Helper enable
        """
        max_neighbor_restart_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max neighbor restart time
        """
        strict_lsa_checking: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strict l s a checking
        """
elif False:
    LogicalRouterVrfOspfv3GracefulRestartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3GracefulRestartArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 grace_period: Optional[pulumi.Input[_builtins.int]] = None,
                 helper_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_neighbor_restart_time: Optional[pulumi.Input[_builtins.int]] = None,
                 strict_lsa_checking: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] grace_period: Grace period
        :param pulumi.Input[_builtins.bool] helper_enable: Helper enable
        :param pulumi.Input[_builtins.int] max_neighbor_restart_time: Max neighbor restart time
        :param pulumi.Input[_builtins.bool] strict_lsa_checking: Strict l s a checking
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if helper_enable is not None:
            pulumi.set(__self__, "helper_enable", helper_enable)
        if max_neighbor_restart_time is not None:
            pulumi.set(__self__, "max_neighbor_restart_time", max_neighbor_restart_time)
        if strict_lsa_checking is not None:
            pulumi.set(__self__, "strict_lsa_checking", strict_lsa_checking)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Grace period
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_period", value)

    @_builtins.property
    @pulumi.getter(name="helperEnable")
    def helper_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Helper enable
        """
        return pulumi.get(self, "helper_enable")

    @helper_enable.setter
    def helper_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "helper_enable", value)

    @_builtins.property
    @pulumi.getter(name="maxNeighborRestartTime")
    def max_neighbor_restart_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max neighbor restart time
        """
        return pulumi.get(self, "max_neighbor_restart_time")

    @max_neighbor_restart_time.setter
    def max_neighbor_restart_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_neighbor_restart_time", value)

    @_builtins.property
    @pulumi.getter(name="strictLsaChecking")
    def strict_lsa_checking(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strict l s a checking
        """
        return pulumi.get(self, "strict_lsa_checking")

    @strict_lsa_checking.setter
    def strict_lsa_checking(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strict_lsa_checking", value)


if not MYPY:
    class LogicalRouterVrfOspfv3VrTimersArgsDict(TypedDict):
        lsa_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lsa interval
        """
        spf_calculation_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Spf calculation delay
        """
elif False:
    LogicalRouterVrfOspfv3VrTimersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfOspfv3VrTimersArgs:
    def __init__(__self__, *,
                 lsa_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 spf_calculation_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] lsa_interval: Lsa interval
        :param pulumi.Input[_builtins.int] spf_calculation_delay: Spf calculation delay
        """
        if lsa_interval is not None:
            pulumi.set(__self__, "lsa_interval", lsa_interval)
        if spf_calculation_delay is not None:
            pulumi.set(__self__, "spf_calculation_delay", spf_calculation_delay)

    @_builtins.property
    @pulumi.getter(name="lsaInterval")
    def lsa_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lsa interval
        """
        return pulumi.get(self, "lsa_interval")

    @lsa_interval.setter
    def lsa_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lsa_interval", value)

    @_builtins.property
    @pulumi.getter(name="spfCalculationDelay")
    def spf_calculation_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Spf calculation delay
        """
        return pulumi.get(self, "spf_calculation_delay")

    @spf_calculation_delay.setter
    def spf_calculation_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spf_calculation_delay", value)


if not MYPY:
    class LogicalRouterVrfRibFilterArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv4ArgsDict']]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv6ArgsDict']]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfRibFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv4Args'] ipv4: Ipv4
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv6Args'] ipv6: Ipv6
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6Args']]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv4ArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv4BgpArgsDict']]
        """
        Bgp
        """
        ospf: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv4OspfArgsDict']]
        """
        Ospf
        """
        rip: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv4RipArgsDict']]
        """
        Rip
        """
        static: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv4StaticArgsDict']]
        """
        Static
        """
elif False:
    LogicalRouterVrfRibFilterIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv4Args:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4BgpArgs']] = None,
                 ospf: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4OspfArgs']] = None,
                 rip: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4RipArgs']] = None,
                 static: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4StaticArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv4BgpArgs'] bgp: Bgp
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv4OspfArgs'] ospf: Ospf
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv4RipArgs'] rip: Rip
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv4StaticArgs'] static: Static
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if ospf is not None:
            pulumi.set(__self__, "ospf", ospf)
        if rip is not None:
            pulumi.set(__self__, "rip", rip)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4BgpArgs']]:
        """
        Bgp
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4BgpArgs']]):
        pulumi.set(self, "bgp", value)

    @_builtins.property
    @pulumi.getter
    def ospf(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4OspfArgs']]:
        """
        Ospf
        """
        return pulumi.get(self, "ospf")

    @ospf.setter
    def ospf(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4OspfArgs']]):
        pulumi.set(self, "ospf", value)

    @_builtins.property
    @pulumi.getter
    def rip(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4RipArgs']]:
        """
        Rip
        """
        return pulumi.get(self, "rip")

    @rip.setter
    def rip(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4RipArgs']]):
        pulumi.set(self, "rip", value)

    @_builtins.property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4StaticArgs']]:
        """
        Static
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv4StaticArgs']]):
        pulumi.set(self, "static", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv4BgpArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv4BgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv4BgpArgs:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv4OspfArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv4OspfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv4OspfArgs:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv4RipArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv4RipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv4RipArgs:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv4StaticArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv4StaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv4StaticArgs:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv6ArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv6BgpArgsDict']]
        """
        Bgp
        """
        ospfv3: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv6Ospfv3ArgsDict']]
        """
        Ospfv3
        """
        static: NotRequired[pulumi.Input['LogicalRouterVrfRibFilterIpv6StaticArgsDict']]
        """
        Static
        """
elif False:
    LogicalRouterVrfRibFilterIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv6Args:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6BgpArgs']] = None,
                 ospfv3: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6Ospfv3Args']] = None,
                 static: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6StaticArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv6BgpArgs'] bgp: Bgp
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv6Ospfv3Args'] ospfv3: Ospfv3
        :param pulumi.Input['LogicalRouterVrfRibFilterIpv6StaticArgs'] static: Static
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if ospfv3 is not None:
            pulumi.set(__self__, "ospfv3", ospfv3)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6BgpArgs']]:
        """
        Bgp
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6BgpArgs']]):
        pulumi.set(self, "bgp", value)

    @_builtins.property
    @pulumi.getter
    def ospfv3(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6Ospfv3Args']]:
        """
        Ospfv3
        """
        return pulumi.get(self, "ospfv3")

    @ospfv3.setter
    def ospfv3(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6Ospfv3Args']]):
        pulumi.set(self, "ospfv3", value)

    @_builtins.property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6StaticArgs']]:
        """
        Static
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input['LogicalRouterVrfRibFilterIpv6StaticArgs']]):
        pulumi.set(self, "static", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv6BgpArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv6BgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv6BgpArgs:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv6Ospfv3ArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv6Ospfv3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv6Ospfv3Args:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRibFilterIpv6StaticArgsDict(TypedDict):
        route_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route map
        """
elif False:
    LogicalRouterVrfRibFilterIpv6StaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRibFilterIpv6StaticArgs:
    def __init__(__self__, *,
                 route_map: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route_map: Route map
        """
        if route_map is not None:
            pulumi.set(__self__, "route_map", route_map)

    @_builtins.property
    @pulumi.getter(name="routeMap")
    def route_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route map
        """
        return pulumi.get(self, "route_map")

    @route_map.setter
    def route_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_map", value)


if not MYPY:
    class LogicalRouterVrfRipArgsDict(TypedDict):
        auth_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Auth profile
        """
        default_information_originate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Default information originate
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        global_bfd: NotRequired[pulumi.Input['LogicalRouterVrfRipGlobalBfdArgsDict']]
        """
        Global bfd
        """
        global_inbound_distribute_list: NotRequired[pulumi.Input['LogicalRouterVrfRipGlobalInboundDistributeListArgsDict']]
        """
        Global inbound distribute list
        """
        global_outbound_distribute_list: NotRequired[pulumi.Input['LogicalRouterVrfRipGlobalOutboundDistributeListArgsDict']]
        """
        Global outbound distribute list
        """
        global_timer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Global timer
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRipInterfaceArgsDict']]]]
        """
        Interface
        """
        redistribution_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Redistribution profile
        """
elif False:
    LogicalRouterVrfRipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipArgs:
    def __init__(__self__, *,
                 auth_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 default_information_originate: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 global_bfd: Optional[pulumi.Input['LogicalRouterVrfRipGlobalBfdArgs']] = None,
                 global_inbound_distribute_list: Optional[pulumi.Input['LogicalRouterVrfRipGlobalInboundDistributeListArgs']] = None,
                 global_outbound_distribute_list: Optional[pulumi.Input['LogicalRouterVrfRipGlobalOutboundDistributeListArgs']] = None,
                 global_timer: Optional[pulumi.Input[_builtins.str]] = None,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRipInterfaceArgs']]]] = None,
                 redistribution_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_profile: Auth profile
        :param pulumi.Input[_builtins.bool] default_information_originate: Default information originate
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfRipGlobalBfdArgs'] global_bfd: Global bfd
        :param pulumi.Input['LogicalRouterVrfRipGlobalInboundDistributeListArgs'] global_inbound_distribute_list: Global inbound distribute list
        :param pulumi.Input['LogicalRouterVrfRipGlobalOutboundDistributeListArgs'] global_outbound_distribute_list: Global outbound distribute list
        :param pulumi.Input[_builtins.str] global_timer: Global timer
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRipInterfaceArgs']]] interfaces: Interface
        :param pulumi.Input[_builtins.str] redistribution_profile: Redistribution profile
        """
        if auth_profile is not None:
            pulumi.set(__self__, "auth_profile", auth_profile)
        if default_information_originate is not None:
            pulumi.set(__self__, "default_information_originate", default_information_originate)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if global_bfd is not None:
            pulumi.set(__self__, "global_bfd", global_bfd)
        if global_inbound_distribute_list is not None:
            pulumi.set(__self__, "global_inbound_distribute_list", global_inbound_distribute_list)
        if global_outbound_distribute_list is not None:
            pulumi.set(__self__, "global_outbound_distribute_list", global_outbound_distribute_list)
        if global_timer is not None:
            pulumi.set(__self__, "global_timer", global_timer)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if redistribution_profile is not None:
            pulumi.set(__self__, "redistribution_profile", redistribution_profile)

    @_builtins.property
    @pulumi.getter(name="authProfile")
    def auth_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Auth profile
        """
        return pulumi.get(self, "auth_profile")

    @auth_profile.setter
    def auth_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_profile", value)

    @_builtins.property
    @pulumi.getter(name="defaultInformationOriginate")
    def default_information_originate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Default information originate
        """
        return pulumi.get(self, "default_information_originate")

    @default_information_originate.setter
    def default_information_originate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_information_originate", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="globalBfd")
    def global_bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfRipGlobalBfdArgs']]:
        """
        Global bfd
        """
        return pulumi.get(self, "global_bfd")

    @global_bfd.setter
    def global_bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfRipGlobalBfdArgs']]):
        pulumi.set(self, "global_bfd", value)

    @_builtins.property
    @pulumi.getter(name="globalInboundDistributeList")
    def global_inbound_distribute_list(self) -> Optional[pulumi.Input['LogicalRouterVrfRipGlobalInboundDistributeListArgs']]:
        """
        Global inbound distribute list
        """
        return pulumi.get(self, "global_inbound_distribute_list")

    @global_inbound_distribute_list.setter
    def global_inbound_distribute_list(self, value: Optional[pulumi.Input['LogicalRouterVrfRipGlobalInboundDistributeListArgs']]):
        pulumi.set(self, "global_inbound_distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="globalOutboundDistributeList")
    def global_outbound_distribute_list(self) -> Optional[pulumi.Input['LogicalRouterVrfRipGlobalOutboundDistributeListArgs']]:
        """
        Global outbound distribute list
        """
        return pulumi.get(self, "global_outbound_distribute_list")

    @global_outbound_distribute_list.setter
    def global_outbound_distribute_list(self, value: Optional[pulumi.Input['LogicalRouterVrfRipGlobalOutboundDistributeListArgs']]):
        pulumi.set(self, "global_outbound_distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="globalTimer")
    def global_timer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Global timer
        """
        return pulumi.get(self, "global_timer")

    @global_timer.setter
    def global_timer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_timer", value)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRipInterfaceArgs']]]]:
        """
        Interface
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRipInterfaceArgs']]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter(name="redistributionProfile")
    def redistribution_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Redistribution profile
        """
        return pulumi.get(self, "redistribution_profile")

    @redistribution_profile.setter
    def redistribution_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redistribution_profile", value)


if not MYPY:
    class LogicalRouterVrfRipGlobalBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfRipGlobalBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipGlobalBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfRipGlobalInboundDistributeListArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
elif False:
    LogicalRouterVrfRipGlobalInboundDistributeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipGlobalInboundDistributeListArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)


if not MYPY:
    class LogicalRouterVrfRipGlobalOutboundDistributeListArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
elif False:
    LogicalRouterVrfRipGlobalOutboundDistributeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipGlobalOutboundDistributeListArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)


if not MYPY:
    class LogicalRouterVrfRipInterfaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfRipInterfaceBfdArgsDict']]
        """
        Bfd
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        interface_inbound_distribute_list: NotRequired[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgsDict']]
        """
        Interface inbound distribute list
        """
        interface_outbound_distribute_list: NotRequired[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgsDict']]
        """
        Interface outbound distribute list
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mode
        """
        split_horizon: NotRequired[pulumi.Input[_builtins.str]]
        """
        Split horizon
        """
elif False:
    LogicalRouterVrfRipInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfRipInterfaceBfdArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 interface_inbound_distribute_list: Optional[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgs']] = None,
                 interface_outbound_distribute_list: Optional[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgs']] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 split_horizon: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] authentication: Authentication
        :param pulumi.Input['LogicalRouterVrfRipInterfaceBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgs'] interface_inbound_distribute_list: Interface inbound distribute list
        :param pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgs'] interface_outbound_distribute_list: Interface outbound distribute list
        :param pulumi.Input[_builtins.str] mode: Mode
        :param pulumi.Input[_builtins.str] split_horizon: Split horizon
        """
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if interface_inbound_distribute_list is not None:
            pulumi.set(__self__, "interface_inbound_distribute_list", interface_inbound_distribute_list)
        if interface_outbound_distribute_list is not None:
            pulumi.set(__self__, "interface_outbound_distribute_list", interface_outbound_distribute_list)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if split_horizon is not None:
            pulumi.set(__self__, "split_horizon", split_horizon)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfRipInterfaceBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfRipInterfaceBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="interfaceInboundDistributeList")
    def interface_inbound_distribute_list(self) -> Optional[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgs']]:
        """
        Interface inbound distribute list
        """
        return pulumi.get(self, "interface_inbound_distribute_list")

    @interface_inbound_distribute_list.setter
    def interface_inbound_distribute_list(self, value: Optional[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgs']]):
        pulumi.set(self, "interface_inbound_distribute_list", value)

    @_builtins.property
    @pulumi.getter(name="interfaceOutboundDistributeList")
    def interface_outbound_distribute_list(self) -> Optional[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgs']]:
        """
        Interface outbound distribute list
        """
        return pulumi.get(self, "interface_outbound_distribute_list")

    @interface_outbound_distribute_list.setter
    def interface_outbound_distribute_list(self, value: Optional[pulumi.Input['LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgs']]):
        pulumi.set(self, "interface_outbound_distribute_list", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="splitHorizon")
    def split_horizon(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Split horizon
        """
        return pulumi.get(self, "split_horizon")

    @split_horizon.setter
    def split_horizon(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "split_horizon", value)


if not MYPY:
    class LogicalRouterVrfRipInterfaceBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfRipInterfaceBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipInterfaceBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
elif False:
    LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipInterfaceInterfaceInboundDistributeListArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        :param pulumi.Input[_builtins.int] metric: Metric
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgsDict(TypedDict):
        access_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access list
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
elif False:
    LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRipInterfaceInterfaceOutboundDistributeListArgs:
    def __init__(__self__, *,
                 access_list: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_list: Access list
        :param pulumi.Input[_builtins.int] metric: Metric
        """
        if access_list is not None:
            pulumi.set(__self__, "access_list", access_list)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter(name="accessList")
    def access_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access list
        """
        return pulumi.get(self, "access_list")

    @access_list.setter
    def access_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_list", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpArgsDict']]
        """
        Ip
        """
        ipv6: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6ArgsDict']]
        """
        Ipv6
        """
elif False:
    LogicalRouterVrfRoutingTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpArgs']] = None,
                 ipv6: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6Args']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpArgs'] ip: Ip
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6Args'] ipv6: Ipv6
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpArgs']]:
        """
        Ip
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6Args']]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpArgsDict(TypedDict):
        static_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteArgsDict']]]]
        """
        Static route
        """
elif False:
    LogicalRouterVrfRoutingTableIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpArgs:
    def __init__(__self__, *,
                 static_routes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteArgs']]] static_routes: Static route
        """
        if static_routes is not None:
            pulumi.set(__self__, "static_routes", static_routes)

    @_builtins.property
    @pulumi.getter(name="staticRoutes")
    def static_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteArgs']]]]:
        """
        Static route
        """
        return pulumi.get(self, "static_routes")

    @static_routes.setter
    def static_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteArgs']]]]):
        pulumi.set(self, "static_routes", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        admin_dist: NotRequired[pulumi.Input[_builtins.int]]
        """
        Admin dist
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteBfdArgsDict']]
        """
        Bfd
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        nexthop: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgsDict']]
        """
        Nexthop
        """
        path_monitor: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgsDict']]
        """
        Path monitor
        """
        route_table: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgsDict']]
        """
        Route table
        """
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 admin_dist: Optional[pulumi.Input[_builtins.int]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteBfdArgs']] = None,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthop: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgs']] = None,
                 path_monitor: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgs']] = None,
                 route_table: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] admin_dist: Admin dist
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.str] destination: Destination
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgs'] nexthop: Nexthop
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgs'] path_monitor: Path monitor
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgs'] route_table: Route table
        """
        pulumi.set(__self__, "name", name)
        if admin_dist is not None:
            pulumi.set(__self__, "admin_dist", admin_dist)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if path_monitor is not None:
            pulumi.set(__self__, "path_monitor", path_monitor)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="adminDist")
    def admin_dist(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Admin dist
        """
        return pulumi.get(self, "admin_dist")

    @admin_dist.setter
    def admin_dist(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "admin_dist", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgs']]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgs']]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter(name="pathMonitor")
    def path_monitor(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgs']]:
        """
        Path monitor
        """
        return pulumi.get(self, "path_monitor")

    @path_monitor.setter
    def path_monitor(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgs']]):
        pulumi.set(self, "path_monitor", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgs']]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgs']]):
        pulumi.set(self, "route_table", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgsDict(TypedDict):
        discard: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgsDict']]
        """
        Discard
        """
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fqdn

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ip address

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6 address

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        next_lr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next lr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        next_vr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next vr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        receive: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgsDict']]
        """
        Receive

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        tunnel: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tunnel

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteNexthopArgs:
    def __init__(__self__, *,
                 discard: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgs']] = None,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_address: Optional[pulumi.Input[_builtins.str]] = None,
                 next_lr: Optional[pulumi.Input[_builtins.str]] = None,
                 next_vr: Optional[pulumi.Input[_builtins.str]] = None,
                 receive: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgs']] = None,
                 tunnel: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgs'] discard: Discard
        :param pulumi.Input[_builtins.str] fqdn: Fqdn
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] ip_address: Ip address
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] ipv6_address: Ipv6 address
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] next_lr: Next lr
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] next_vr: Next vr
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgs'] receive: Receive
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] tunnel: Tunnel
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if next_lr is not None:
            pulumi.set(__self__, "next_lr", next_lr)
        if next_vr is not None:
            pulumi.set(__self__, "next_vr", next_vr)
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgs']]:
        """
        Discard
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgs']]):
        pulumi.set(self, "discard", value)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fqdn

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ip address

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6 address

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address", value)

    @_builtins.property
    @pulumi.getter(name="nextLr")
    def next_lr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next lr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "next_lr")

    @next_lr.setter
    def next_lr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_lr", value)

    @_builtins.property
    @pulumi.getter(name="nextVr")
    def next_vr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next vr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "next_vr")

    @next_vr.setter
    def next_vr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_vr", value)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgs']]:
        """
        Receive

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgs']]):
        pulumi.set(self, "receive", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tunnel

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ip_address`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tunnel", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteNexthopDiscardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteNexthopReceiveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        failure_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Failure condition
        """
        hold_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hold time
        """
        monitor_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgsDict']]]]
        """
        Monitor destinations
        """
elif False:
    LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 failure_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 hold_time: Optional[pulumi.Input[_builtins.int]] = None,
                 monitor_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] failure_condition: Failure condition
        :param pulumi.Input[_builtins.int] hold_time: Hold time
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgs']]] monitor_destinations: Monitor destinations
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if failure_condition is not None:
            pulumi.set(__self__, "failure_condition", failure_condition)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if monitor_destinations is not None:
            pulumi.set(__self__, "monitor_destinations", monitor_destinations)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="failureCondition")
    def failure_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Failure condition
        """
        return pulumi.get(self, "failure_condition")

    @failure_condition.setter
    def failure_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "failure_condition", value)

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hold time
        """
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hold_time", value)

    @_builtins.property
    @pulumi.getter(name="monitorDestinations")
    def monitor_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgs']]]]:
        """
        Monitor destinations
        """
        return pulumi.get(self, "monitor_destinations")

    @monitor_destinations.setter
    def monitor_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgs']]]]):
        pulumi.set(self, "monitor_destinations", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination
        """
        destination_fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination fqdn
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source
        """
elif False:
    LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] count: Count
        :param pulumi.Input[_builtins.str] destination: Destination
        :param pulumi.Input[_builtins.str] destination_fqdn: Destination fqdn
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] interval: Interval
        :param pulumi.Input[_builtins.str] source: Source
        """
        pulumi.set(__self__, "name", name)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_fqdn is not None:
            pulumi.set(__self__, "destination_fqdn", destination_fqdn)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationFqdn")
    def destination_fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination fqdn
        """
        return pulumi.get(self, "destination_fqdn")

    @destination_fqdn.setter
    def destination_fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_fqdn", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgsDict(TypedDict):
        both: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgsDict']]
        """
        Both
        """
        multicast: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgsDict']]
        """
        Multicast

        >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
        no_install: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgsDict']]
        """
        No install

        >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
        unicast: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgsDict']]
        """
        Unicast

        >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableArgs:
    def __init__(__self__, *,
                 both: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgs']] = None,
                 multicast: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgs']] = None,
                 no_install: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgs']] = None,
                 unicast: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgs'] both: Both
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgs'] multicast: Multicast
               
               >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgs'] no_install: No install
               
               >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgs'] unicast: Unicast
               
               >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
        if both is not None:
            pulumi.set(__self__, "both", both)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if no_install is not None:
            pulumi.set(__self__, "no_install", no_install)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def both(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgs']]:
        """
        Both
        """
        return pulumi.get(self, "both")

    @both.setter
    def both(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgs']]):
        pulumi.set(self, "both", value)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgs']]:
        """
        Multicast

        >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter(name="noInstall")
    def no_install(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgs']]:
        """
        No install

        >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
        return pulumi.get(self, "no_install")

    @no_install.setter
    def no_install(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgs']]):
        pulumi.set(self, "no_install", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgs']]:
        """
        Unicast

        >  **Note:** You must specify exactly one of `both`, `multicast`, `no_install`, and `unicast`.
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgs']]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableMulticastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableNoInstallArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpStaticRouteRouteTableUnicastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6ArgsDict(TypedDict):
        static_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteArgsDict']]]]
        """
        Static route
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6Args:
    def __init__(__self__, *,
                 static_routes: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteArgs']]] static_routes: Static route
        """
        if static_routes is not None:
            pulumi.set(__self__, "static_routes", static_routes)

    @_builtins.property
    @pulumi.getter(name="staticRoutes")
    def static_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteArgs']]]]:
        """
        Static route
        """
        return pulumi.get(self, "static_routes")

    @static_routes.setter
    def static_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteArgs']]]]):
        pulumi.set(self, "static_routes", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        admin_dist: NotRequired[pulumi.Input[_builtins.int]]
        """
        Admin dist
        """
        bfd: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgsDict']]
        """
        Bfd
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
        metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric
        """
        nexthop: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgsDict']]
        """
        Nexthop
        """
        option: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgsDict']]
        """
        Option
        """
        path_monitor: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgsDict']]
        """
        Path monitor
        """
        route_table: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgsDict']]
        """
        Route table
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 admin_dist: Optional[pulumi.Input[_builtins.int]] = None,
                 bfd: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgs']] = None,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input[_builtins.int]] = None,
                 nexthop: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgs']] = None,
                 option: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgs']] = None,
                 path_monitor: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgs']] = None,
                 route_table: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] admin_dist: Admin dist
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgs'] bfd: Bfd
        :param pulumi.Input[_builtins.str] destination: Destination
        :param pulumi.Input[_builtins.str] interface: Interface
        :param pulumi.Input[_builtins.int] metric: Metric
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgs'] nexthop: Nexthop
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgs'] option: Option
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgs'] path_monitor: Path monitor
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgs'] route_table: Route table
        """
        pulumi.set(__self__, "name", name)
        if admin_dist is not None:
            pulumi.set(__self__, "admin_dist", admin_dist)
        if bfd is not None:
            pulumi.set(__self__, "bfd", bfd)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if option is not None:
            pulumi.set(__self__, "option", option)
        if path_monitor is not None:
            pulumi.set(__self__, "path_monitor", path_monitor)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="adminDist")
    def admin_dist(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Admin dist
        """
        return pulumi.get(self, "admin_dist")

    @admin_dist.setter
    def admin_dist(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "admin_dist", value)

    @_builtins.property
    @pulumi.getter
    def bfd(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgs']]:
        """
        Bfd
        """
        return pulumi.get(self, "bfd")

    @bfd.setter
    def bfd(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgs']]):
        pulumi.set(self, "bfd", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgs']]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgs']]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgs']]:
        """
        Option
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgs']]):
        pulumi.set(self, "option", value)

    @_builtins.property
    @pulumi.getter(name="pathMonitor")
    def path_monitor(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgs']]:
        """
        Path monitor
        """
        return pulumi.get(self, "path_monitor")

    @path_monitor.setter
    def path_monitor(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgs']]):
        pulumi.set(self, "path_monitor", value)

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgs']]:
        """
        Route table
        """
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgs']]):
        pulumi.set(self, "route_table", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgsDict(TypedDict):
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Profile
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteBfdArgs:
    def __init__(__self__, *,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] profile: Profile
        """
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgsDict(TypedDict):
        discard: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgsDict']]
        """
        Discard
        """
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fqdn

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6 address

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        next_lr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next lr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        next_vr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next vr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        receive: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgsDict']]
        """
        Receive

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        tunnel: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tunnel

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopArgs:
    def __init__(__self__, *,
                 discard: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgs']] = None,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_address: Optional[pulumi.Input[_builtins.str]] = None,
                 next_lr: Optional[pulumi.Input[_builtins.str]] = None,
                 next_vr: Optional[pulumi.Input[_builtins.str]] = None,
                 receive: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgs']] = None,
                 tunnel: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgs'] discard: Discard
        :param pulumi.Input[_builtins.str] fqdn: Fqdn
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] ipv6_address: Ipv6 address
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] next_lr: Next lr
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] next_vr: Next vr
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgs'] receive: Receive
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        :param pulumi.Input[_builtins.str] tunnel: Tunnel
               
               >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if next_lr is not None:
            pulumi.set(__self__, "next_lr", next_lr)
        if next_vr is not None:
            pulumi.set(__self__, "next_vr", next_vr)
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgs']]:
        """
        Discard
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgs']]):
        pulumi.set(self, "discard", value)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fqdn

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6 address

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address", value)

    @_builtins.property
    @pulumi.getter(name="nextLr")
    def next_lr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next lr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "next_lr")

    @next_lr.setter
    def next_lr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_lr", value)

    @_builtins.property
    @pulumi.getter(name="nextVr")
    def next_vr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next vr

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "next_vr")

    @next_vr.setter
    def next_vr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_vr", value)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgs']]:
        """
        Receive

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "receive")

    @receive.setter
    def receive(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgs']]):
        pulumi.set(self, "receive", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tunnel

        >  **Note:** You must specify exactly one of `discard`, `fqdn`, `ipv6_address`, `next_lr`, `next_vr`, `receive`, and `tunnel`.
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tunnel", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopDiscardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteNexthopReceiveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgsDict(TypedDict):
        passive: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgsDict']]
        """
        Passive
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteOptionArgs:
    def __init__(__self__, *,
                 passive: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgs'] passive: Passive
        """
        if passive is not None:
            pulumi.set(__self__, "passive", passive)

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgs']]:
        """
        Passive
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgs']]):
        pulumi.set(self, "passive", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteOptionPassiveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        failure_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Failure condition
        """
        hold_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Hold time
        """
        monitor_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgsDict']]]]
        """
        Monitor destinations
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 failure_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 hold_time: Optional[pulumi.Input[_builtins.int]] = None,
                 monitor_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] failure_condition: Failure condition
        :param pulumi.Input[_builtins.int] hold_time: Hold time
        :param pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgs']]] monitor_destinations: Monitor destinations
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if failure_condition is not None:
            pulumi.set(__self__, "failure_condition", failure_condition)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if monitor_destinations is not None:
            pulumi.set(__self__, "monitor_destinations", monitor_destinations)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="failureCondition")
    def failure_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Failure condition
        """
        return pulumi.get(self, "failure_condition")

    @failure_condition.setter
    def failure_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "failure_condition", value)

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Hold time
        """
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hold_time", value)

    @_builtins.property
    @pulumi.getter(name="monitorDestinations")
    def monitor_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgs']]]]:
        """
        Monitor destinations
        """
        return pulumi.get(self, "monitor_destinations")

    @monitor_destinations.setter
    def monitor_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgs']]]]):
        pulumi.set(self, "monitor_destinations", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Count
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination
        """
        destination_fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination fqdn
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.int] count: Count
        :param pulumi.Input[_builtins.str] destination: Destination
        :param pulumi.Input[_builtins.str] destination_fqdn: Destination fqdn
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.int] interval: Interval
        :param pulumi.Input[_builtins.str] source: Source
        """
        pulumi.set(__self__, "name", name)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_fqdn is not None:
            pulumi.set(__self__, "destination_fqdn", destination_fqdn)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Count
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationFqdn")
    def destination_fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination fqdn
        """
        return pulumi.get(self, "destination_fqdn")

    @destination_fqdn.setter
    def destination_fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_fqdn", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgsDict(TypedDict):
        both: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgsDict']]
        """
        Both
        """
        multicast: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgsDict']]
        """
        Multicast
        """
        no_install: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgsDict']]
        """
        No install
        """
        unicast: NotRequired[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgsDict']]
        """
        Unicast
        """
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableArgs:
    def __init__(__self__, *,
                 both: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgs']] = None,
                 multicast: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgs']] = None,
                 no_install: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgs']] = None,
                 unicast: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgs']] = None):
        """
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgs'] both: Both
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgs'] multicast: Multicast
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgs'] no_install: No install
        :param pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgs'] unicast: Unicast
        """
        if both is not None:
            pulumi.set(__self__, "both", both)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if no_install is not None:
            pulumi.set(__self__, "no_install", no_install)
        if unicast is not None:
            pulumi.set(__self__, "unicast", unicast)

    @_builtins.property
    @pulumi.getter
    def both(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgs']]:
        """
        Both
        """
        return pulumi.get(self, "both")

    @both.setter
    def both(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgs']]):
        pulumi.set(self, "both", value)

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgs']]:
        """
        Multicast
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @_builtins.property
    @pulumi.getter(name="noInstall")
    def no_install(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgs']]:
        """
        No install
        """
        return pulumi.get(self, "no_install")

    @no_install.setter
    def no_install(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgs']]):
        pulumi.set(self, "no_install", value)

    @_builtins.property
    @pulumi.getter
    def unicast(self) -> Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgs']]:
        """
        Unicast
        """
        return pulumi.get(self, "unicast")

    @unicast.setter
    def unicast(self, value: Optional[pulumi.Input['LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgs']]):
        pulumi.set(self, "unicast", value)


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableMulticastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableNoInstallArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgsDict(TypedDict):
        pass
elif False:
    LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfRoutingTableIpv6StaticRouteRouteTableUnicastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LogicalRouterVrfVrAdminDistsArgsDict(TypedDict):
        ebgp: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ebgp
        """
        ibgp: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ibgp
        """
        ospf_ext: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospf ext
        """
        ospf_int: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospf int
        """
        ospfv3_ext: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospfv3 ext
        """
        ospfv3_int: NotRequired[pulumi.Input[_builtins.int]]
        """
        Ospfv3 int
        """
        rip: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rip
        """
        static: NotRequired[pulumi.Input[_builtins.int]]
        """
        Static
        """
        static_ipv6: NotRequired[pulumi.Input[_builtins.int]]
        """
        Static ipv6
        """
elif False:
    LogicalRouterVrfVrAdminDistsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogicalRouterVrfVrAdminDistsArgs:
    def __init__(__self__, *,
                 ebgp: Optional[pulumi.Input[_builtins.int]] = None,
                 ibgp: Optional[pulumi.Input[_builtins.int]] = None,
                 ospf_ext: Optional[pulumi.Input[_builtins.int]] = None,
                 ospf_int: Optional[pulumi.Input[_builtins.int]] = None,
                 ospfv3_ext: Optional[pulumi.Input[_builtins.int]] = None,
                 ospfv3_int: Optional[pulumi.Input[_builtins.int]] = None,
                 rip: Optional[pulumi.Input[_builtins.int]] = None,
                 static: Optional[pulumi.Input[_builtins.int]] = None,
                 static_ipv6: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] ebgp: Ebgp
        :param pulumi.Input[_builtins.int] ibgp: Ibgp
        :param pulumi.Input[_builtins.int] ospf_ext: Ospf ext
        :param pulumi.Input[_builtins.int] ospf_int: Ospf int
        :param pulumi.Input[_builtins.int] ospfv3_ext: Ospfv3 ext
        :param pulumi.Input[_builtins.int] ospfv3_int: Ospfv3 int
        :param pulumi.Input[_builtins.int] rip: Rip
        :param pulumi.Input[_builtins.int] static: Static
        :param pulumi.Input[_builtins.int] static_ipv6: Static ipv6
        """
        if ebgp is not None:
            pulumi.set(__self__, "ebgp", ebgp)
        if ibgp is not None:
            pulumi.set(__self__, "ibgp", ibgp)
        if ospf_ext is not None:
            pulumi.set(__self__, "ospf_ext", ospf_ext)
        if ospf_int is not None:
            pulumi.set(__self__, "ospf_int", ospf_int)
        if ospfv3_ext is not None:
            pulumi.set(__self__, "ospfv3_ext", ospfv3_ext)
        if ospfv3_int is not None:
            pulumi.set(__self__, "ospfv3_int", ospfv3_int)
        if rip is not None:
            pulumi.set(__self__, "rip", rip)
        if static is not None:
            pulumi.set(__self__, "static", static)
        if static_ipv6 is not None:
            pulumi.set(__self__, "static_ipv6", static_ipv6)

    @_builtins.property
    @pulumi.getter
    def ebgp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ebgp
        """
        return pulumi.get(self, "ebgp")

    @ebgp.setter
    def ebgp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ebgp", value)

    @_builtins.property
    @pulumi.getter
    def ibgp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ibgp
        """
        return pulumi.get(self, "ibgp")

    @ibgp.setter
    def ibgp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ibgp", value)

    @_builtins.property
    @pulumi.getter(name="ospfExt")
    def ospf_ext(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospf ext
        """
        return pulumi.get(self, "ospf_ext")

    @ospf_ext.setter
    def ospf_ext(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospf_ext", value)

    @_builtins.property
    @pulumi.getter(name="ospfInt")
    def ospf_int(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospf int
        """
        return pulumi.get(self, "ospf_int")

    @ospf_int.setter
    def ospf_int(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospf_int", value)

    @_builtins.property
    @pulumi.getter(name="ospfv3Ext")
    def ospfv3_ext(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospfv3 ext
        """
        return pulumi.get(self, "ospfv3_ext")

    @ospfv3_ext.setter
    def ospfv3_ext(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospfv3_ext", value)

    @_builtins.property
    @pulumi.getter(name="ospfv3Int")
    def ospfv3_int(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Ospfv3 int
        """
        return pulumi.get(self, "ospfv3_int")

    @ospfv3_int.setter
    def ospfv3_int(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ospfv3_int", value)

    @_builtins.property
    @pulumi.getter
    def rip(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rip
        """
        return pulumi.get(self, "rip")

    @rip.setter
    def rip(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rip", value)

    @_builtins.property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Static
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "static", value)

    @_builtins.property
    @pulumi.getter(name="staticIpv6")
    def static_ipv6(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Static ipv6
        """
        return pulumi.get(self, "static_ipv6")

    @static_ipv6.setter
    def static_ipv6(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "static_ipv6", value)


if not MYPY:
    class LoopbackInterfaceIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Loopback IP address(es)
        """
elif False:
    LoopbackInterfaceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoopbackInterfaceIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Loopback IP address(es)
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Loopback IP address(es)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LoopbackInterfaceIpv6ArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoopbackInterfaceIpv6AddressArgsDict']]]]
        """
        IPv6 Address Parent
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable IPv6
        """
        interface_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface ID
        """
elif False:
    LoopbackInterfaceIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoopbackInterfaceIpv6Args:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LoopbackInterfaceIpv6AddressArgs']]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 interface_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoopbackInterfaceIpv6AddressArgs']]] addresses: IPv6 Address Parent
        :param pulumi.Input[_builtins.bool] enabled: Enable IPv6
        :param pulumi.Input[_builtins.str] interface_id: Interface ID
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoopbackInterfaceIpv6AddressArgs']]]]:
        """
        IPv6 Address Parent
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoopbackInterfaceIpv6AddressArgs']]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable IPv6
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface ID
        """
        return pulumi.get(self, "interface_id")

    @interface_id.setter
    def interface_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface_id", value)


if not MYPY:
    class LoopbackInterfaceIpv6AddressArgsDict(TypedDict):
        anycast: NotRequired[pulumi.Input['LoopbackInterfaceIpv6AddressAnycastArgsDict']]
        """
        Anycast
        """
        enable_on_interface: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Address on Interface
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 Address
        """
        prefix: NotRequired[pulumi.Input['LoopbackInterfaceIpv6AddressPrefixArgsDict']]
        """
        Use interface ID as host portion
        """
elif False:
    LoopbackInterfaceIpv6AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoopbackInterfaceIpv6AddressArgs:
    def __init__(__self__, *,
                 anycast: Optional[pulumi.Input['LoopbackInterfaceIpv6AddressAnycastArgs']] = None,
                 enable_on_interface: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input['LoopbackInterfaceIpv6AddressPrefixArgs']] = None):
        """
        :param pulumi.Input['LoopbackInterfaceIpv6AddressAnycastArgs'] anycast: Anycast
        :param pulumi.Input[_builtins.bool] enable_on_interface: Enable Address on Interface
        :param pulumi.Input[_builtins.str] name: IPv6 Address
        :param pulumi.Input['LoopbackInterfaceIpv6AddressPrefixArgs'] prefix: Use interface ID as host portion
        """
        if anycast is not None:
            pulumi.set(__self__, "anycast", anycast)
        if enable_on_interface is not None:
            pulumi.set(__self__, "enable_on_interface", enable_on_interface)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def anycast(self) -> Optional[pulumi.Input['LoopbackInterfaceIpv6AddressAnycastArgs']]:
        """
        Anycast
        """
        return pulumi.get(self, "anycast")

    @anycast.setter
    def anycast(self, value: Optional[pulumi.Input['LoopbackInterfaceIpv6AddressAnycastArgs']]):
        pulumi.set(self, "anycast", value)

    @_builtins.property
    @pulumi.getter(name="enableOnInterface")
    def enable_on_interface(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Address on Interface
        """
        return pulumi.get(self, "enable_on_interface")

    @enable_on_interface.setter
    def enable_on_interface(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_on_interface", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 Address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input['LoopbackInterfaceIpv6AddressPrefixArgs']]:
        """
        Use interface ID as host portion
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input['LoopbackInterfaceIpv6AddressPrefixArgs']]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class LoopbackInterfaceIpv6AddressAnycastArgsDict(TypedDict):
        pass
elif False:
    LoopbackInterfaceIpv6AddressAnycastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoopbackInterfaceIpv6AddressAnycastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LoopbackInterfaceIpv6AddressPrefixArgsDict(TypedDict):
        pass
elif False:
    LoopbackInterfaceIpv6AddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoopbackInterfaceIpv6AddressPrefixArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ManagementInterfaceManagementInterfaceArgsDict(TypedDict):
        mgmt_type: NotRequired[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeArgsDict']]
        """
        IP type
        """
        mtu: NotRequired[pulumi.Input[_builtins.int]]
        """
        MTU
        """
        permitted_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ManagementInterfaceManagementInterfacePermittedIpArgsDict']]]]
        """
        Permitting IP addresses
        """
        service: NotRequired[pulumi.Input['ManagementInterfaceManagementInterfaceServiceArgsDict']]
        """
        Network services
        """
        speed_duplex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Speed and duplex
        """
elif False:
    ManagementInterfaceManagementInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceManagementInterfaceArgs:
    def __init__(__self__, *,
                 mgmt_type: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeArgs']] = None,
                 mtu: Optional[pulumi.Input[_builtins.int]] = None,
                 permitted_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ManagementInterfaceManagementInterfacePermittedIpArgs']]]] = None,
                 service: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceServiceArgs']] = None,
                 speed_duplex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeArgs'] mgmt_type: IP type
        :param pulumi.Input[_builtins.int] mtu: MTU
        :param pulumi.Input[Sequence[pulumi.Input['ManagementInterfaceManagementInterfacePermittedIpArgs']]] permitted_ips: Permitting IP addresses
        :param pulumi.Input['ManagementInterfaceManagementInterfaceServiceArgs'] service: Network services
        :param pulumi.Input[_builtins.str] speed_duplex: Speed and duplex
        """
        if mgmt_type is not None:
            pulumi.set(__self__, "mgmt_type", mgmt_type)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if permitted_ips is not None:
            pulumi.set(__self__, "permitted_ips", permitted_ips)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if speed_duplex is not None:
            pulumi.set(__self__, "speed_duplex", speed_duplex)

    @_builtins.property
    @pulumi.getter(name="mgmtType")
    def mgmt_type(self) -> Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeArgs']]:
        """
        IP type
        """
        return pulumi.get(self, "mgmt_type")

    @mgmt_type.setter
    def mgmt_type(self, value: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeArgs']]):
        pulumi.set(self, "mgmt_type", value)

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        MTU
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mtu", value)

    @_builtins.property
    @pulumi.getter(name="permittedIps")
    def permitted_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagementInterfaceManagementInterfacePermittedIpArgs']]]]:
        """
        Permitting IP addresses
        """
        return pulumi.get(self, "permitted_ips")

    @permitted_ips.setter
    def permitted_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagementInterfaceManagementInterfacePermittedIpArgs']]]]):
        pulumi.set(self, "permitted_ips", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ManagementInterfaceManagementInterfaceServiceArgs']]:
        """
        Network services
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceServiceArgs']]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="speedDuplex")
    def speed_duplex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Speed and duplex
        """
        return pulumi.get(self, "speed_duplex")

    @speed_duplex.setter
    def speed_duplex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "speed_duplex", value)


if not MYPY:
    class ManagementInterfaceManagementInterfaceMgmtTypeArgsDict(TypedDict):
        dhcp_client: NotRequired[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgsDict']]
        """
        Dhcp client
        """
        static: NotRequired[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeStaticArgsDict']]
        """
        Static

        >  **Note:** You must specify exactly one of `dhcp_client` and `static`.
        """
elif False:
    ManagementInterfaceManagementInterfaceMgmtTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceManagementInterfaceMgmtTypeArgs:
    def __init__(__self__, *,
                 dhcp_client: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgs']] = None,
                 static: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeStaticArgs']] = None):
        """
        :param pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgs'] dhcp_client: Dhcp client
        :param pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeStaticArgs'] static: Static
               
               >  **Note:** You must specify exactly one of `dhcp_client` and `static`.
        """
        if dhcp_client is not None:
            pulumi.set(__self__, "dhcp_client", dhcp_client)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @_builtins.property
    @pulumi.getter(name="dhcpClient")
    def dhcp_client(self) -> Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgs']]:
        """
        Dhcp client
        """
        return pulumi.get(self, "dhcp_client")

    @dhcp_client.setter
    def dhcp_client(self, value: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgs']]):
        pulumi.set(self, "dhcp_client", value)

    @_builtins.property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeStaticArgs']]:
        """
        Static

        >  **Note:** You must specify exactly one of `dhcp_client` and `static`.
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input['ManagementInterfaceManagementInterfaceMgmtTypeStaticArgs']]):
        pulumi.set(self, "static", value)


if not MYPY:
    class ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgsDict(TypedDict):
        accept_dhcp_domain: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept DHCP server provided domain name
        """
        accept_dhcp_hostname: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept DHCP server provided hostname
        """
        send_client_id: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Send client ID
        """
        send_hostname: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Send hostname
        """
elif False:
    ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceManagementInterfaceMgmtTypeDhcpClientArgs:
    def __init__(__self__, *,
                 accept_dhcp_domain: Optional[pulumi.Input[_builtins.bool]] = None,
                 accept_dhcp_hostname: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_client_id: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_hostname: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] accept_dhcp_domain: Accept DHCP server provided domain name
        :param pulumi.Input[_builtins.bool] accept_dhcp_hostname: Accept DHCP server provided hostname
        :param pulumi.Input[_builtins.bool] send_client_id: Send client ID
        :param pulumi.Input[_builtins.bool] send_hostname: Send hostname
        """
        if accept_dhcp_domain is not None:
            pulumi.set(__self__, "accept_dhcp_domain", accept_dhcp_domain)
        if accept_dhcp_hostname is not None:
            pulumi.set(__self__, "accept_dhcp_hostname", accept_dhcp_hostname)
        if send_client_id is not None:
            pulumi.set(__self__, "send_client_id", send_client_id)
        if send_hostname is not None:
            pulumi.set(__self__, "send_hostname", send_hostname)

    @_builtins.property
    @pulumi.getter(name="acceptDhcpDomain")
    def accept_dhcp_domain(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept DHCP server provided domain name
        """
        return pulumi.get(self, "accept_dhcp_domain")

    @accept_dhcp_domain.setter
    def accept_dhcp_domain(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_dhcp_domain", value)

    @_builtins.property
    @pulumi.getter(name="acceptDhcpHostname")
    def accept_dhcp_hostname(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept DHCP server provided hostname
        """
        return pulumi.get(self, "accept_dhcp_hostname")

    @accept_dhcp_hostname.setter
    def accept_dhcp_hostname(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_dhcp_hostname", value)

    @_builtins.property
    @pulumi.getter(name="sendClientId")
    def send_client_id(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Send client ID
        """
        return pulumi.get(self, "send_client_id")

    @send_client_id.setter
    def send_client_id(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_client_id", value)

    @_builtins.property
    @pulumi.getter(name="sendHostname")
    def send_hostname(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Send hostname
        """
        return pulumi.get(self, "send_hostname")

    @send_hostname.setter
    def send_hostname(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_hostname", value)


if not MYPY:
    class ManagementInterfaceManagementInterfaceMgmtTypeStaticArgsDict(TypedDict):
        default_gateway: pulumi.Input[_builtins.str]
        """
        Default gateway
        """
        ip_address: pulumi.Input[_builtins.str]
        """
        IP address
        """
        netmask: pulumi.Input[_builtins.str]
        """
        Netmask
        """
elif False:
    ManagementInterfaceManagementInterfaceMgmtTypeStaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceManagementInterfaceMgmtTypeStaticArgs:
    def __init__(__self__, *,
                 default_gateway: pulumi.Input[_builtins.str],
                 ip_address: pulumi.Input[_builtins.str],
                 netmask: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] default_gateway: Default gateway
        :param pulumi.Input[_builtins.str] ip_address: IP address
        :param pulumi.Input[_builtins.str] netmask: Netmask
        """
        pulumi.set(__self__, "default_gateway", default_gateway)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> pulumi.Input[_builtins.str]:
        """
        Default gateway
        """
        return pulumi.get(self, "default_gateway")

    @default_gateway.setter
    def default_gateway(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_gateway", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        IP address
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[_builtins.str]:
        """
        Netmask
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "netmask", value)


if not MYPY:
    class ManagementInterfaceManagementInterfacePermittedIpArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
elif False:
    ManagementInterfaceManagementInterfacePermittedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceManagementInterfacePermittedIpArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[_builtins.str] name: IP address
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ManagementInterfaceManagementInterfaceServiceArgsDict(TypedDict):
        disable_http: NotRequired[pulumi.Input[_builtins.bool]]
        """
        HTTP
        """
        disable_http_ocsp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        HTTP OCSP
        """
        disable_https: NotRequired[pulumi.Input[_builtins.bool]]
        """
        HTTPS
        """
        disable_icmp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Ping
        """
        disable_snmp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        SNMP
        """
        disable_ssh: NotRequired[pulumi.Input[_builtins.bool]]
        """
        SSH
        """
        disable_telnet: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Telnet
        """
        disable_userid_service: NotRequired[pulumi.Input[_builtins.bool]]
        """
        User-ID
        """
        disable_userid_syslog_listener_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        User-ID syslog listener over SSL
        """
        disable_userid_syslog_listener_udp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        User-ID syslog listener over UDP
        """
elif False:
    ManagementInterfaceManagementInterfaceServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementInterfaceManagementInterfaceServiceArgs:
    def __init__(__self__, *,
                 disable_http: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_http_ocsp: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_https: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_icmp: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_snmp: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_ssh: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_telnet: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_userid_service: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_userid_syslog_listener_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_userid_syslog_listener_udp: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_http: HTTP
        :param pulumi.Input[_builtins.bool] disable_http_ocsp: HTTP OCSP
        :param pulumi.Input[_builtins.bool] disable_https: HTTPS
        :param pulumi.Input[_builtins.bool] disable_icmp: Ping
        :param pulumi.Input[_builtins.bool] disable_snmp: SNMP
        :param pulumi.Input[_builtins.bool] disable_ssh: SSH
        :param pulumi.Input[_builtins.bool] disable_telnet: Telnet
        :param pulumi.Input[_builtins.bool] disable_userid_service: User-ID
        :param pulumi.Input[_builtins.bool] disable_userid_syslog_listener_ssl: User-ID syslog listener over SSL
        :param pulumi.Input[_builtins.bool] disable_userid_syslog_listener_udp: User-ID syslog listener over UDP
        """
        if disable_http is not None:
            pulumi.set(__self__, "disable_http", disable_http)
        if disable_http_ocsp is not None:
            pulumi.set(__self__, "disable_http_ocsp", disable_http_ocsp)
        if disable_https is not None:
            pulumi.set(__self__, "disable_https", disable_https)
        if disable_icmp is not None:
            pulumi.set(__self__, "disable_icmp", disable_icmp)
        if disable_snmp is not None:
            pulumi.set(__self__, "disable_snmp", disable_snmp)
        if disable_ssh is not None:
            pulumi.set(__self__, "disable_ssh", disable_ssh)
        if disable_telnet is not None:
            pulumi.set(__self__, "disable_telnet", disable_telnet)
        if disable_userid_service is not None:
            pulumi.set(__self__, "disable_userid_service", disable_userid_service)
        if disable_userid_syslog_listener_ssl is not None:
            pulumi.set(__self__, "disable_userid_syslog_listener_ssl", disable_userid_syslog_listener_ssl)
        if disable_userid_syslog_listener_udp is not None:
            pulumi.set(__self__, "disable_userid_syslog_listener_udp", disable_userid_syslog_listener_udp)

    @_builtins.property
    @pulumi.getter(name="disableHttp")
    def disable_http(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        HTTP
        """
        return pulumi.get(self, "disable_http")

    @disable_http.setter
    def disable_http(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_http", value)

    @_builtins.property
    @pulumi.getter(name="disableHttpOcsp")
    def disable_http_ocsp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        HTTP OCSP
        """
        return pulumi.get(self, "disable_http_ocsp")

    @disable_http_ocsp.setter
    def disable_http_ocsp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_http_ocsp", value)

    @_builtins.property
    @pulumi.getter(name="disableHttps")
    def disable_https(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        HTTPS
        """
        return pulumi.get(self, "disable_https")

    @disable_https.setter
    def disable_https(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_https", value)

    @_builtins.property
    @pulumi.getter(name="disableIcmp")
    def disable_icmp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Ping
        """
        return pulumi.get(self, "disable_icmp")

    @disable_icmp.setter
    def disable_icmp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_icmp", value)

    @_builtins.property
    @pulumi.getter(name="disableSnmp")
    def disable_snmp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        SNMP
        """
        return pulumi.get(self, "disable_snmp")

    @disable_snmp.setter
    def disable_snmp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_snmp", value)

    @_builtins.property
    @pulumi.getter(name="disableSsh")
    def disable_ssh(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        SSH
        """
        return pulumi.get(self, "disable_ssh")

    @disable_ssh.setter
    def disable_ssh(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_ssh", value)

    @_builtins.property
    @pulumi.getter(name="disableTelnet")
    def disable_telnet(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Telnet
        """
        return pulumi.get(self, "disable_telnet")

    @disable_telnet.setter
    def disable_telnet(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_telnet", value)

    @_builtins.property
    @pulumi.getter(name="disableUseridService")
    def disable_userid_service(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        User-ID
        """
        return pulumi.get(self, "disable_userid_service")

    @disable_userid_service.setter
    def disable_userid_service(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_userid_service", value)

    @_builtins.property
    @pulumi.getter(name="disableUseridSyslogListenerSsl")
    def disable_userid_syslog_listener_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        User-ID syslog listener over SSL
        """
        return pulumi.get(self, "disable_userid_syslog_listener_ssl")

    @disable_userid_syslog_listener_ssl.setter
    def disable_userid_syslog_listener_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_userid_syslog_listener_ssl", value)

    @_builtins.property
    @pulumi.getter(name="disableUseridSyslogListenerUdp")
    def disable_userid_syslog_listener_udp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        User-ID syslog listener over UDP
        """
        return pulumi.get(self, "disable_userid_syslog_listener_udp")

    @disable_userid_syslog_listener_udp.setter
    def disable_userid_syslog_listener_udp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_userid_syslog_listener_udp", value)


if not MYPY:
    class MfaServerMfaVendorTypeArgsDict(TypedDict):
        duo_security_v2: NotRequired[pulumi.Input['MfaServerMfaVendorTypeDuoSecurityV2ArgsDict']]
        """
        Integration with [Duo Security](https://duo.com/product)
        """
        okta_adaptive_v1: NotRequired[pulumi.Input['MfaServerMfaVendorTypeOktaAdaptiveV1ArgsDict']]
        """
        Integration with [Okta Adaptive MFA](https://www.okta.com/products/adaptive-multi-factor-authentication)

        >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
        ping_identity_v1: NotRequired[pulumi.Input['MfaServerMfaVendorTypePingIdentityV1ArgsDict']]
        """
        Integation with [Ping Identity](https://www.pingidentity.com/en/platform.html)

        >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
        rsa_securid_access_v1: NotRequired[pulumi.Input['MfaServerMfaVendorTypeRsaSecuridAccessV1ArgsDict']]
        """
        Integration with [RSA SecurID](https://www.rsa.com/products/securid/)

        >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
elif False:
    MfaServerMfaVendorTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MfaServerMfaVendorTypeArgs:
    def __init__(__self__, *,
                 duo_security_v2: Optional[pulumi.Input['MfaServerMfaVendorTypeDuoSecurityV2Args']] = None,
                 okta_adaptive_v1: Optional[pulumi.Input['MfaServerMfaVendorTypeOktaAdaptiveV1Args']] = None,
                 ping_identity_v1: Optional[pulumi.Input['MfaServerMfaVendorTypePingIdentityV1Args']] = None,
                 rsa_securid_access_v1: Optional[pulumi.Input['MfaServerMfaVendorTypeRsaSecuridAccessV1Args']] = None):
        """
        :param pulumi.Input['MfaServerMfaVendorTypeDuoSecurityV2Args'] duo_security_v2: Integration with [Duo Security](https://duo.com/product)
        :param pulumi.Input['MfaServerMfaVendorTypeOktaAdaptiveV1Args'] okta_adaptive_v1: Integration with [Okta Adaptive MFA](https://www.okta.com/products/adaptive-multi-factor-authentication)
               
               >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        :param pulumi.Input['MfaServerMfaVendorTypePingIdentityV1Args'] ping_identity_v1: Integation with [Ping Identity](https://www.pingidentity.com/en/platform.html)
               
               >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        :param pulumi.Input['MfaServerMfaVendorTypeRsaSecuridAccessV1Args'] rsa_securid_access_v1: Integration with [RSA SecurID](https://www.rsa.com/products/securid/)
               
               >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
        if duo_security_v2 is not None:
            pulumi.set(__self__, "duo_security_v2", duo_security_v2)
        if okta_adaptive_v1 is not None:
            pulumi.set(__self__, "okta_adaptive_v1", okta_adaptive_v1)
        if ping_identity_v1 is not None:
            pulumi.set(__self__, "ping_identity_v1", ping_identity_v1)
        if rsa_securid_access_v1 is not None:
            pulumi.set(__self__, "rsa_securid_access_v1", rsa_securid_access_v1)

    @_builtins.property
    @pulumi.getter(name="duoSecurityV2")
    def duo_security_v2(self) -> Optional[pulumi.Input['MfaServerMfaVendorTypeDuoSecurityV2Args']]:
        """
        Integration with [Duo Security](https://duo.com/product)
        """
        return pulumi.get(self, "duo_security_v2")

    @duo_security_v2.setter
    def duo_security_v2(self, value: Optional[pulumi.Input['MfaServerMfaVendorTypeDuoSecurityV2Args']]):
        pulumi.set(self, "duo_security_v2", value)

    @_builtins.property
    @pulumi.getter(name="oktaAdaptiveV1")
    def okta_adaptive_v1(self) -> Optional[pulumi.Input['MfaServerMfaVendorTypeOktaAdaptiveV1Args']]:
        """
        Integration with [Okta Adaptive MFA](https://www.okta.com/products/adaptive-multi-factor-authentication)

        >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
        return pulumi.get(self, "okta_adaptive_v1")

    @okta_adaptive_v1.setter
    def okta_adaptive_v1(self, value: Optional[pulumi.Input['MfaServerMfaVendorTypeOktaAdaptiveV1Args']]):
        pulumi.set(self, "okta_adaptive_v1", value)

    @_builtins.property
    @pulumi.getter(name="pingIdentityV1")
    def ping_identity_v1(self) -> Optional[pulumi.Input['MfaServerMfaVendorTypePingIdentityV1Args']]:
        """
        Integation with [Ping Identity](https://www.pingidentity.com/en/platform.html)

        >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
        return pulumi.get(self, "ping_identity_v1")

    @ping_identity_v1.setter
    def ping_identity_v1(self, value: Optional[pulumi.Input['MfaServerMfaVendorTypePingIdentityV1Args']]):
        pulumi.set(self, "ping_identity_v1", value)

    @_builtins.property
    @pulumi.getter(name="rsaSecuridAccessV1")
    def rsa_securid_access_v1(self) -> Optional[pulumi.Input['MfaServerMfaVendorTypeRsaSecuridAccessV1Args']]:
        """
        Integration with [RSA SecurID](https://www.rsa.com/products/securid/)

        >  **Note:** You must specify exactly one of `duo_security_v2`, `okta_adaptive_v1`, `ping_identity_v1`, and `rsa_securid_access_v1`.
        """
        return pulumi.get(self, "rsa_securid_access_v1")

    @rsa_securid_access_v1.setter
    def rsa_securid_access_v1(self, value: Optional[pulumi.Input['MfaServerMfaVendorTypeRsaSecuridAccessV1Args']]):
        pulumi.set(self, "rsa_securid_access_v1", value)


if not MYPY:
    class MfaServerMfaVendorTypeDuoSecurityV2ArgsDict(TypedDict):
        duo_api_host: pulumi.Input[_builtins.str]
        """
        Duo Security API hostname
        """
        duo_baseuri: pulumi.Input[_builtins.str]
        """
        Duo Security API base URI
        """
        duo_integration_key: pulumi.Input[_builtins.str]
        """
        Duo Security integration key
        """
        duo_secret_key: pulumi.Input[_builtins.str]
        """
        Duo Security secret key
        """
        duo_timeout: pulumi.Input[_builtins.int]
        """
        Duo Security timeout (seconds)
        """
elif False:
    MfaServerMfaVendorTypeDuoSecurityV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MfaServerMfaVendorTypeDuoSecurityV2Args:
    def __init__(__self__, *,
                 duo_api_host: pulumi.Input[_builtins.str],
                 duo_baseuri: pulumi.Input[_builtins.str],
                 duo_integration_key: pulumi.Input[_builtins.str],
                 duo_secret_key: pulumi.Input[_builtins.str],
                 duo_timeout: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] duo_api_host: Duo Security API hostname
        :param pulumi.Input[_builtins.str] duo_baseuri: Duo Security API base URI
        :param pulumi.Input[_builtins.str] duo_integration_key: Duo Security integration key
        :param pulumi.Input[_builtins.str] duo_secret_key: Duo Security secret key
        :param pulumi.Input[_builtins.int] duo_timeout: Duo Security timeout (seconds)
        """
        pulumi.set(__self__, "duo_api_host", duo_api_host)
        pulumi.set(__self__, "duo_baseuri", duo_baseuri)
        pulumi.set(__self__, "duo_integration_key", duo_integration_key)
        pulumi.set(__self__, "duo_secret_key", duo_secret_key)
        pulumi.set(__self__, "duo_timeout", duo_timeout)

    @_builtins.property
    @pulumi.getter(name="duoApiHost")
    def duo_api_host(self) -> pulumi.Input[_builtins.str]:
        """
        Duo Security API hostname
        """
        return pulumi.get(self, "duo_api_host")

    @duo_api_host.setter
    def duo_api_host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duo_api_host", value)

    @_builtins.property
    @pulumi.getter(name="duoBaseuri")
    def duo_baseuri(self) -> pulumi.Input[_builtins.str]:
        """
        Duo Security API base URI
        """
        return pulumi.get(self, "duo_baseuri")

    @duo_baseuri.setter
    def duo_baseuri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duo_baseuri", value)

    @_builtins.property
    @pulumi.getter(name="duoIntegrationKey")
    def duo_integration_key(self) -> pulumi.Input[_builtins.str]:
        """
        Duo Security integration key
        """
        return pulumi.get(self, "duo_integration_key")

    @duo_integration_key.setter
    def duo_integration_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duo_integration_key", value)

    @_builtins.property
    @pulumi.getter(name="duoSecretKey")
    def duo_secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Duo Security secret key
        """
        return pulumi.get(self, "duo_secret_key")

    @duo_secret_key.setter
    def duo_secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duo_secret_key", value)

    @_builtins.property
    @pulumi.getter(name="duoTimeout")
    def duo_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        Duo Security timeout (seconds)
        """
        return pulumi.get(self, "duo_timeout")

    @duo_timeout.setter
    def duo_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "duo_timeout", value)


if not MYPY:
    class MfaServerMfaVendorTypeOktaAdaptiveV1ArgsDict(TypedDict):
        okta_api_host: pulumi.Input[_builtins.str]
        """
        Okta API hostname
        """
        okta_baseuri: pulumi.Input[_builtins.str]
        """
        Okta baseuri
        """
        okta_org: pulumi.Input[_builtins.str]
        """
        Okta organization
        """
        okta_timeout: pulumi.Input[_builtins.int]
        """
        Okta timeout (seconds)
        """
        okta_token: pulumi.Input[_builtins.str]
        """
        Okta API token
        """
elif False:
    MfaServerMfaVendorTypeOktaAdaptiveV1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MfaServerMfaVendorTypeOktaAdaptiveV1Args:
    def __init__(__self__, *,
                 okta_api_host: pulumi.Input[_builtins.str],
                 okta_baseuri: pulumi.Input[_builtins.str],
                 okta_org: pulumi.Input[_builtins.str],
                 okta_timeout: pulumi.Input[_builtins.int],
                 okta_token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] okta_api_host: Okta API hostname
        :param pulumi.Input[_builtins.str] okta_baseuri: Okta baseuri
        :param pulumi.Input[_builtins.str] okta_org: Okta organization
        :param pulumi.Input[_builtins.int] okta_timeout: Okta timeout (seconds)
        :param pulumi.Input[_builtins.str] okta_token: Okta API token
        """
        pulumi.set(__self__, "okta_api_host", okta_api_host)
        pulumi.set(__self__, "okta_baseuri", okta_baseuri)
        pulumi.set(__self__, "okta_org", okta_org)
        pulumi.set(__self__, "okta_timeout", okta_timeout)
        pulumi.set(__self__, "okta_token", okta_token)

    @_builtins.property
    @pulumi.getter(name="oktaApiHost")
    def okta_api_host(self) -> pulumi.Input[_builtins.str]:
        """
        Okta API hostname
        """
        return pulumi.get(self, "okta_api_host")

    @okta_api_host.setter
    def okta_api_host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "okta_api_host", value)

    @_builtins.property
    @pulumi.getter(name="oktaBaseuri")
    def okta_baseuri(self) -> pulumi.Input[_builtins.str]:
        """
        Okta baseuri
        """
        return pulumi.get(self, "okta_baseuri")

    @okta_baseuri.setter
    def okta_baseuri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "okta_baseuri", value)

    @_builtins.property
    @pulumi.getter(name="oktaOrg")
    def okta_org(self) -> pulumi.Input[_builtins.str]:
        """
        Okta organization
        """
        return pulumi.get(self, "okta_org")

    @okta_org.setter
    def okta_org(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "okta_org", value)

    @_builtins.property
    @pulumi.getter(name="oktaTimeout")
    def okta_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        Okta timeout (seconds)
        """
        return pulumi.get(self, "okta_timeout")

    @okta_timeout.setter
    def okta_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "okta_timeout", value)

    @_builtins.property
    @pulumi.getter(name="oktaToken")
    def okta_token(self) -> pulumi.Input[_builtins.str]:
        """
        Okta API token
        """
        return pulumi.get(self, "okta_token")

    @okta_token.setter
    def okta_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "okta_token", value)


if not MYPY:
    class MfaServerMfaVendorTypePingIdentityV1ArgsDict(TypedDict):
        ping_api_host: pulumi.Input[_builtins.str]
        """
        Ping Identity API hostname
        """
        ping_baseuri: pulumi.Input[_builtins.str]
        """
        Ping Identity API base URI
        """
        ping_timeout: pulumi.Input[_builtins.int]
        """
        Ping Identity timeout (seconds)
        """
        ping_token: pulumi.Input[_builtins.str]
        """
        Ping Identity API token
        """
        ping_use_base64_key: pulumi.Input[_builtins.str]
        """
        Ping Identity Base64 key
        """
        ping_org_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ping Identity client organization ID
        """
elif False:
    MfaServerMfaVendorTypePingIdentityV1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MfaServerMfaVendorTypePingIdentityV1Args:
    def __init__(__self__, *,
                 ping_api_host: pulumi.Input[_builtins.str],
                 ping_baseuri: pulumi.Input[_builtins.str],
                 ping_timeout: pulumi.Input[_builtins.int],
                 ping_token: pulumi.Input[_builtins.str],
                 ping_use_base64_key: pulumi.Input[_builtins.str],
                 ping_org_alias: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ping_api_host: Ping Identity API hostname
        :param pulumi.Input[_builtins.str] ping_baseuri: Ping Identity API base URI
        :param pulumi.Input[_builtins.int] ping_timeout: Ping Identity timeout (seconds)
        :param pulumi.Input[_builtins.str] ping_token: Ping Identity API token
        :param pulumi.Input[_builtins.str] ping_use_base64_key: Ping Identity Base64 key
        :param pulumi.Input[_builtins.str] ping_org_alias: Ping Identity client organization ID
        """
        pulumi.set(__self__, "ping_api_host", ping_api_host)
        pulumi.set(__self__, "ping_baseuri", ping_baseuri)
        pulumi.set(__self__, "ping_timeout", ping_timeout)
        pulumi.set(__self__, "ping_token", ping_token)
        pulumi.set(__self__, "ping_use_base64_key", ping_use_base64_key)
        if ping_org_alias is not None:
            pulumi.set(__self__, "ping_org_alias", ping_org_alias)

    @_builtins.property
    @pulumi.getter(name="pingApiHost")
    def ping_api_host(self) -> pulumi.Input[_builtins.str]:
        """
        Ping Identity API hostname
        """
        return pulumi.get(self, "ping_api_host")

    @ping_api_host.setter
    def ping_api_host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ping_api_host", value)

    @_builtins.property
    @pulumi.getter(name="pingBaseuri")
    def ping_baseuri(self) -> pulumi.Input[_builtins.str]:
        """
        Ping Identity API base URI
        """
        return pulumi.get(self, "ping_baseuri")

    @ping_baseuri.setter
    def ping_baseuri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ping_baseuri", value)

    @_builtins.property
    @pulumi.getter(name="pingTimeout")
    def ping_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        Ping Identity timeout (seconds)
        """
        return pulumi.get(self, "ping_timeout")

    @ping_timeout.setter
    def ping_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ping_timeout", value)

    @_builtins.property
    @pulumi.getter(name="pingToken")
    def ping_token(self) -> pulumi.Input[_builtins.str]:
        """
        Ping Identity API token
        """
        return pulumi.get(self, "ping_token")

    @ping_token.setter
    def ping_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ping_token", value)

    @_builtins.property
    @pulumi.getter(name="pingUseBase64Key")
    def ping_use_base64_key(self) -> pulumi.Input[_builtins.str]:
        """
        Ping Identity Base64 key
        """
        return pulumi.get(self, "ping_use_base64_key")

    @ping_use_base64_key.setter
    def ping_use_base64_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ping_use_base64_key", value)

    @_builtins.property
    @pulumi.getter(name="pingOrgAlias")
    def ping_org_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ping Identity client organization ID
        """
        return pulumi.get(self, "ping_org_alias")

    @ping_org_alias.setter
    def ping_org_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ping_org_alias", value)


if not MYPY:
    class MfaServerMfaVendorTypeRsaSecuridAccessV1ArgsDict(TypedDict):
        rsa_accessid: NotRequired[pulumi.Input[_builtins.str]]
        """
        RSA SecurID access ID
        """
        rsa_accesskey: NotRequired[pulumi.Input[_builtins.str]]
        """
        RSA SecurID access key
        """
        rsa_api_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        RSA SecurID hostname
        """
        rsa_assurancepolicyid: NotRequired[pulumi.Input[_builtins.str]]
        """
        RSA SecurID assurance level
        """
        rsa_baseuri: NotRequired[pulumi.Input[_builtins.str]]
        """
        RSA SecurID API base URI
        """
        rsa_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        RSA SecurID timeout (seconds)
        """
elif False:
    MfaServerMfaVendorTypeRsaSecuridAccessV1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MfaServerMfaVendorTypeRsaSecuridAccessV1Args:
    def __init__(__self__, *,
                 rsa_accessid: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_accesskey: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_api_host: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_assurancepolicyid: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_baseuri: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] rsa_accessid: RSA SecurID access ID
        :param pulumi.Input[_builtins.str] rsa_accesskey: RSA SecurID access key
        :param pulumi.Input[_builtins.str] rsa_api_host: RSA SecurID hostname
        :param pulumi.Input[_builtins.str] rsa_assurancepolicyid: RSA SecurID assurance level
        :param pulumi.Input[_builtins.str] rsa_baseuri: RSA SecurID API base URI
        :param pulumi.Input[_builtins.int] rsa_timeout: RSA SecurID timeout (seconds)
        """
        if rsa_accessid is not None:
            pulumi.set(__self__, "rsa_accessid", rsa_accessid)
        if rsa_accesskey is not None:
            pulumi.set(__self__, "rsa_accesskey", rsa_accesskey)
        if rsa_api_host is not None:
            pulumi.set(__self__, "rsa_api_host", rsa_api_host)
        if rsa_assurancepolicyid is not None:
            pulumi.set(__self__, "rsa_assurancepolicyid", rsa_assurancepolicyid)
        if rsa_baseuri is not None:
            pulumi.set(__self__, "rsa_baseuri", rsa_baseuri)
        if rsa_timeout is not None:
            pulumi.set(__self__, "rsa_timeout", rsa_timeout)

    @_builtins.property
    @pulumi.getter(name="rsaAccessid")
    def rsa_accessid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RSA SecurID access ID
        """
        return pulumi.get(self, "rsa_accessid")

    @rsa_accessid.setter
    def rsa_accessid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_accessid", value)

    @_builtins.property
    @pulumi.getter(name="rsaAccesskey")
    def rsa_accesskey(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RSA SecurID access key
        """
        return pulumi.get(self, "rsa_accesskey")

    @rsa_accesskey.setter
    def rsa_accesskey(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_accesskey", value)

    @_builtins.property
    @pulumi.getter(name="rsaApiHost")
    def rsa_api_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RSA SecurID hostname
        """
        return pulumi.get(self, "rsa_api_host")

    @rsa_api_host.setter
    def rsa_api_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_api_host", value)

    @_builtins.property
    @pulumi.getter(name="rsaAssurancepolicyid")
    def rsa_assurancepolicyid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RSA SecurID assurance level
        """
        return pulumi.get(self, "rsa_assurancepolicyid")

    @rsa_assurancepolicyid.setter
    def rsa_assurancepolicyid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_assurancepolicyid", value)

    @_builtins.property
    @pulumi.getter(name="rsaBaseuri")
    def rsa_baseuri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RSA SecurID API base URI
        """
        return pulumi.get(self, "rsa_baseuri")

    @rsa_baseuri.setter
    def rsa_baseuri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_baseuri", value)

    @_builtins.property
    @pulumi.getter(name="rsaTimeout")
    def rsa_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        RSA SecurID timeout (seconds)
        """
        return pulumi.get(self, "rsa_timeout")

    @rsa_timeout.setter
    def rsa_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rsa_timeout", value)


if not MYPY:
    class MotdBannerSettingMotdAndBannerArgsDict(TypedDict):
        banner_footer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Banner footer
        """
        banner_footer_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The following list details the supported values and their colors.
        """
        banner_footer_text_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The following list details the supported values and their colors.
        """
        banner_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        Banner header
        """
        banner_header_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The following list details the supported values and their colors.
        """
        banner_header_footer_match: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Banner header footer match
        """
        banner_header_text_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The following list details the supported values and their colors.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message
        """
        motd_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The following list details the supported values and their colors.
        """
        motd_do_not_display_again: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Motd do not display again
        """
        motd_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Motd enable
        """
        motd_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Motd title
        """
        severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Severity
        """
elif False:
    MotdBannerSettingMotdAndBannerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MotdBannerSettingMotdAndBannerArgs:
    def __init__(__self__, *,
                 banner_footer: Optional[pulumi.Input[_builtins.str]] = None,
                 banner_footer_color: Optional[pulumi.Input[_builtins.str]] = None,
                 banner_footer_text_color: Optional[pulumi.Input[_builtins.str]] = None,
                 banner_header: Optional[pulumi.Input[_builtins.str]] = None,
                 banner_header_color: Optional[pulumi.Input[_builtins.str]] = None,
                 banner_header_footer_match: Optional[pulumi.Input[_builtins.bool]] = None,
                 banner_header_text_color: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 motd_color: Optional[pulumi.Input[_builtins.str]] = None,
                 motd_do_not_display_again: Optional[pulumi.Input[_builtins.bool]] = None,
                 motd_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 motd_title: Optional[pulumi.Input[_builtins.str]] = None,
                 severity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] banner_footer: Banner footer
        :param pulumi.Input[_builtins.str] banner_footer_color: The following list details the supported values and their colors.
        :param pulumi.Input[_builtins.str] banner_footer_text_color: The following list details the supported values and their colors.
        :param pulumi.Input[_builtins.str] banner_header: Banner header
        :param pulumi.Input[_builtins.str] banner_header_color: The following list details the supported values and their colors.
        :param pulumi.Input[_builtins.bool] banner_header_footer_match: Banner header footer match
        :param pulumi.Input[_builtins.str] banner_header_text_color: The following list details the supported values and their colors.
        :param pulumi.Input[_builtins.str] message: Message
        :param pulumi.Input[_builtins.str] motd_color: The following list details the supported values and their colors.
        :param pulumi.Input[_builtins.bool] motd_do_not_display_again: Motd do not display again
        :param pulumi.Input[_builtins.bool] motd_enable: Motd enable
        :param pulumi.Input[_builtins.str] motd_title: Motd title
        :param pulumi.Input[_builtins.str] severity: Severity
        """
        if banner_footer is not None:
            pulumi.set(__self__, "banner_footer", banner_footer)
        if banner_footer_color is not None:
            pulumi.set(__self__, "banner_footer_color", banner_footer_color)
        if banner_footer_text_color is not None:
            pulumi.set(__self__, "banner_footer_text_color", banner_footer_text_color)
        if banner_header is not None:
            pulumi.set(__self__, "banner_header", banner_header)
        if banner_header_color is not None:
            pulumi.set(__self__, "banner_header_color", banner_header_color)
        if banner_header_footer_match is not None:
            pulumi.set(__self__, "banner_header_footer_match", banner_header_footer_match)
        if banner_header_text_color is not None:
            pulumi.set(__self__, "banner_header_text_color", banner_header_text_color)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if motd_color is not None:
            pulumi.set(__self__, "motd_color", motd_color)
        if motd_do_not_display_again is not None:
            pulumi.set(__self__, "motd_do_not_display_again", motd_do_not_display_again)
        if motd_enable is not None:
            pulumi.set(__self__, "motd_enable", motd_enable)
        if motd_title is not None:
            pulumi.set(__self__, "motd_title", motd_title)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter(name="bannerFooter")
    def banner_footer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Banner footer
        """
        return pulumi.get(self, "banner_footer")

    @banner_footer.setter
    def banner_footer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "banner_footer", value)

    @_builtins.property
    @pulumi.getter(name="bannerFooterColor")
    def banner_footer_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The following list details the supported values and their colors.
        """
        return pulumi.get(self, "banner_footer_color")

    @banner_footer_color.setter
    def banner_footer_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "banner_footer_color", value)

    @_builtins.property
    @pulumi.getter(name="bannerFooterTextColor")
    def banner_footer_text_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The following list details the supported values and their colors.
        """
        return pulumi.get(self, "banner_footer_text_color")

    @banner_footer_text_color.setter
    def banner_footer_text_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "banner_footer_text_color", value)

    @_builtins.property
    @pulumi.getter(name="bannerHeader")
    def banner_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Banner header
        """
        return pulumi.get(self, "banner_header")

    @banner_header.setter
    def banner_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "banner_header", value)

    @_builtins.property
    @pulumi.getter(name="bannerHeaderColor")
    def banner_header_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The following list details the supported values and their colors.
        """
        return pulumi.get(self, "banner_header_color")

    @banner_header_color.setter
    def banner_header_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "banner_header_color", value)

    @_builtins.property
    @pulumi.getter(name="bannerHeaderFooterMatch")
    def banner_header_footer_match(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Banner header footer match
        """
        return pulumi.get(self, "banner_header_footer_match")

    @banner_header_footer_match.setter
    def banner_header_footer_match(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "banner_header_footer_match", value)

    @_builtins.property
    @pulumi.getter(name="bannerHeaderTextColor")
    def banner_header_text_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The following list details the supported values and their colors.
        """
        return pulumi.get(self, "banner_header_text_color")

    @banner_header_text_color.setter
    def banner_header_text_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "banner_header_text_color", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="motdColor")
    def motd_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The following list details the supported values and their colors.
        """
        return pulumi.get(self, "motd_color")

    @motd_color.setter
    def motd_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "motd_color", value)

    @_builtins.property
    @pulumi.getter(name="motdDoNotDisplayAgain")
    def motd_do_not_display_again(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Motd do not display again
        """
        return pulumi.get(self, "motd_do_not_display_again")

    @motd_do_not_display_again.setter
    def motd_do_not_display_again(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "motd_do_not_display_again", value)

    @_builtins.property
    @pulumi.getter(name="motdEnable")
    def motd_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Motd enable
        """
        return pulumi.get(self, "motd_enable")

    @motd_enable.setter
    def motd_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "motd_enable", value)

    @_builtins.property
    @pulumi.getter(name="motdTitle")
    def motd_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Motd title
        """
        return pulumi.get(self, "motd_title")

    @motd_title.setter
    def motd_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "motd_title", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Severity
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class NatRuleDestinationTranslationArgsDict(TypedDict):
        dns_rewrite: NotRequired[pulumi.Input['NatRuleDestinationTranslationDnsRewriteArgsDict']]
        """
        DNS rewrite
        """
        translated_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Translated destination IP address
        """
        translated_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Translated destination port
        """
elif False:
    NatRuleDestinationTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleDestinationTranslationArgs:
    def __init__(__self__, *,
                 dns_rewrite: Optional[pulumi.Input['NatRuleDestinationTranslationDnsRewriteArgs']] = None,
                 translated_address: Optional[pulumi.Input[_builtins.str]] = None,
                 translated_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['NatRuleDestinationTranslationDnsRewriteArgs'] dns_rewrite: DNS rewrite
        :param pulumi.Input[_builtins.str] translated_address: Translated destination IP address
        :param pulumi.Input[_builtins.int] translated_port: Translated destination port
        """
        if dns_rewrite is not None:
            pulumi.set(__self__, "dns_rewrite", dns_rewrite)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_port is not None:
            pulumi.set(__self__, "translated_port", translated_port)

    @_builtins.property
    @pulumi.getter(name="dnsRewrite")
    def dns_rewrite(self) -> Optional[pulumi.Input['NatRuleDestinationTranslationDnsRewriteArgs']]:
        """
        DNS rewrite
        """
        return pulumi.get(self, "dns_rewrite")

    @dns_rewrite.setter
    def dns_rewrite(self, value: Optional[pulumi.Input['NatRuleDestinationTranslationDnsRewriteArgs']]):
        pulumi.set(self, "dns_rewrite", value)

    @_builtins.property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Translated destination IP address
        """
        return pulumi.get(self, "translated_address")

    @translated_address.setter
    def translated_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "translated_address", value)

    @_builtins.property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Translated destination port
        """
        return pulumi.get(self, "translated_port")

    @translated_port.setter
    def translated_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "translated_port", value)


if not MYPY:
    class NatRuleDestinationTranslationDnsRewriteArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Direction
        """
elif False:
    NatRuleDestinationTranslationDnsRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleDestinationTranslationDnsRewriteArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] direction: Direction
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Direction
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class NatRuleDynamicDestinationTranslationArgsDict(TypedDict):
        distribution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Distribution method
        """
        translated_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Translated destination IP address
        """
        translated_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Translated destination port
        """
elif False:
    NatRuleDynamicDestinationTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleDynamicDestinationTranslationArgs:
    def __init__(__self__, *,
                 distribution: Optional[pulumi.Input[_builtins.str]] = None,
                 translated_address: Optional[pulumi.Input[_builtins.str]] = None,
                 translated_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] distribution: Distribution method
        :param pulumi.Input[_builtins.str] translated_address: Translated destination IP address
        :param pulumi.Input[_builtins.int] translated_port: Translated destination port
        """
        if distribution is not None:
            pulumi.set(__self__, "distribution", distribution)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_port is not None:
            pulumi.set(__self__, "translated_port", translated_port)

    @_builtins.property
    @pulumi.getter
    def distribution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Distribution method
        """
        return pulumi.get(self, "distribution")

    @distribution.setter
    def distribution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "distribution", value)

    @_builtins.property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Translated destination IP address
        """
        return pulumi.get(self, "translated_address")

    @translated_address.setter
    def translated_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "translated_address", value)

    @_builtins.property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Translated destination port
        """
        return pulumi.get(self, "translated_port")

    @translated_port.setter
    def translated_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "translated_port", value)


if not MYPY:
    class NatRuleSourceTranslationArgsDict(TypedDict):
        dynamic_ip: NotRequired[pulumi.Input['NatRuleSourceTranslationDynamicIpArgsDict']]
        """
        Dynamic IP
        """
        dynamic_ip_and_port: NotRequired[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortArgsDict']]
        """
        Dynamic IP and port
        """
        static_ip: NotRequired[pulumi.Input['NatRuleSourceTranslationStaticIpArgsDict']]
        """
        Static IP
        """
elif False:
    NatRuleSourceTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationArgs:
    def __init__(__self__, *,
                 dynamic_ip: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpArgs']] = None,
                 dynamic_ip_and_port: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortArgs']] = None,
                 static_ip: Optional[pulumi.Input['NatRuleSourceTranslationStaticIpArgs']] = None):
        """
        :param pulumi.Input['NatRuleSourceTranslationDynamicIpArgs'] dynamic_ip: Dynamic IP
        :param pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortArgs'] dynamic_ip_and_port: Dynamic IP and port
        :param pulumi.Input['NatRuleSourceTranslationStaticIpArgs'] static_ip: Static IP
        """
        if dynamic_ip is not None:
            pulumi.set(__self__, "dynamic_ip", dynamic_ip)
        if dynamic_ip_and_port is not None:
            pulumi.set(__self__, "dynamic_ip_and_port", dynamic_ip_and_port)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)

    @_builtins.property
    @pulumi.getter(name="dynamicIp")
    def dynamic_ip(self) -> Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpArgs']]:
        """
        Dynamic IP
        """
        return pulumi.get(self, "dynamic_ip")

    @dynamic_ip.setter
    def dynamic_ip(self, value: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpArgs']]):
        pulumi.set(self, "dynamic_ip", value)

    @_builtins.property
    @pulumi.getter(name="dynamicIpAndPort")
    def dynamic_ip_and_port(self) -> Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortArgs']]:
        """
        Dynamic IP and port
        """
        return pulumi.get(self, "dynamic_ip_and_port")

    @dynamic_ip_and_port.setter
    def dynamic_ip_and_port(self, value: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortArgs']]):
        pulumi.set(self, "dynamic_ip_and_port", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input['NatRuleSourceTranslationStaticIpArgs']]:
        """
        Static IP
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input['NatRuleSourceTranslationStaticIpArgs']]):
        pulumi.set(self, "static_ip", value)


if not MYPY:
    class NatRuleSourceTranslationDynamicIpArgsDict(TypedDict):
        fallback: NotRequired[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackArgsDict']]
        """
        Fallback
        """
        translated_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Translated IP addresses
        """
elif False:
    NatRuleSourceTranslationDynamicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationDynamicIpArgs:
    def __init__(__self__, *,
                 fallback: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackArgs']] = None,
                 translated_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackArgs'] fallback: Fallback
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] translated_addresses: Translated IP addresses
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if translated_addresses is not None:
            pulumi.set(__self__, "translated_addresses", translated_addresses)

    @_builtins.property
    @pulumi.getter
    def fallback(self) -> Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackArgs']]:
        """
        Fallback
        """
        return pulumi.get(self, "fallback")

    @fallback.setter
    def fallback(self, value: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackArgs']]):
        pulumi.set(self, "fallback", value)

    @_builtins.property
    @pulumi.getter(name="translatedAddresses")
    def translated_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Translated IP addresses
        """
        return pulumi.get(self, "translated_addresses")

    @translated_addresses.setter
    def translated_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "translated_addresses", value)


if not MYPY:
    class NatRuleSourceTranslationDynamicIpAndPortArgsDict(TypedDict):
        interface_address: NotRequired[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgsDict']]
        """
        Translated source interface
        """
        translated_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Translated source IP addresses
        """
elif False:
    NatRuleSourceTranslationDynamicIpAndPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationDynamicIpAndPortArgs:
    def __init__(__self__, *,
                 interface_address: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgs']] = None,
                 translated_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgs'] interface_address: Translated source interface
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] translated_addresses: Translated source IP addresses
        """
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if translated_addresses is not None:
            pulumi.set(__self__, "translated_addresses", translated_addresses)

    @_builtins.property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgs']]:
        """
        Translated source interface
        """
        return pulumi.get(self, "interface_address")

    @interface_address.setter
    def interface_address(self, value: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgs']]):
        pulumi.set(self, "interface_address", value)

    @_builtins.property
    @pulumi.getter(name="translatedAddresses")
    def translated_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Translated source IP addresses
        """
        return pulumi.get(self, "translated_addresses")

    @translated_addresses.setter
    def translated_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "translated_addresses", value)


if not MYPY:
    class NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgsDict(TypedDict):
        floating_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Floating IP address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface name
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Translated source IP address
        """
elif False:
    NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationDynamicIpAndPortInterfaceAddressArgs:
    def __init__(__self__, *,
                 floating_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] floating_ip: Floating IP address
        :param pulumi.Input[_builtins.str] interface: Interface name
        :param pulumi.Input[_builtins.str] ip: Translated source IP address
        """
        if floating_ip is not None:
            pulumi.set(__self__, "floating_ip", floating_ip)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter(name="floatingIp")
    def floating_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Floating IP address
        """
        return pulumi.get(self, "floating_ip")

    @floating_ip.setter
    def floating_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "floating_ip", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface name
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Translated source IP address
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class NatRuleSourceTranslationDynamicIpFallbackArgsDict(TypedDict):
        interface_address: NotRequired[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgsDict']]
        """
        Fallback interface
        """
        translated_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Fallback IP addresses
        """
elif False:
    NatRuleSourceTranslationDynamicIpFallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationDynamicIpFallbackArgs:
    def __init__(__self__, *,
                 interface_address: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgs']] = None,
                 translated_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgs'] interface_address: Fallback interface
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] translated_addresses: Fallback IP addresses
        """
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if translated_addresses is not None:
            pulumi.set(__self__, "translated_addresses", translated_addresses)

    @_builtins.property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgs']]:
        """
        Fallback interface
        """
        return pulumi.get(self, "interface_address")

    @interface_address.setter
    def interface_address(self, value: Optional[pulumi.Input['NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgs']]):
        pulumi.set(self, "interface_address", value)

    @_builtins.property
    @pulumi.getter(name="translatedAddresses")
    def translated_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Fallback IP addresses
        """
        return pulumi.get(self, "translated_addresses")

    @translated_addresses.setter
    def translated_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "translated_addresses", value)


if not MYPY:
    class NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgsDict(TypedDict):
        floating_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Floating IP address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface name
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
elif False:
    NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationDynamicIpFallbackInterfaceAddressArgs:
    def __init__(__self__, *,
                 floating_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] floating_ip: Floating IP address
        :param pulumi.Input[_builtins.str] interface: Interface name
        :param pulumi.Input[_builtins.str] ip: IP address
        """
        if floating_ip is not None:
            pulumi.set(__self__, "floating_ip", floating_ip)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter(name="floatingIp")
    def floating_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Floating IP address
        """
        return pulumi.get(self, "floating_ip")

    @floating_ip.setter
    def floating_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "floating_ip", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface name
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class NatRuleSourceTranslationStaticIpArgsDict(TypedDict):
        bi_directional: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bi directional
        """
        translated_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Translated IP address
        """
elif False:
    NatRuleSourceTranslationStaticIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleSourceTranslationStaticIpArgs:
    def __init__(__self__, *,
                 bi_directional: Optional[pulumi.Input[_builtins.str]] = None,
                 translated_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bi_directional: Bi directional
        :param pulumi.Input[_builtins.str] translated_address: Translated IP address
        """
        if bi_directional is not None:
            pulumi.set(__self__, "bi_directional", bi_directional)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)

    @_builtins.property
    @pulumi.getter(name="biDirectional")
    def bi_directional(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bi directional
        """
        return pulumi.get(self, "bi_directional")

    @bi_directional.setter
    def bi_directional(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bi_directional", value)

    @_builtins.property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Translated IP address
        """
        return pulumi.get(self, "translated_address")

    @translated_address.setter
    def translated_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "translated_address", value)


if not MYPY:
    class OspfAuthProfileMd5ArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        MD5 hash
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Key ID
        """
        preferred: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Preferred?
        """
elif False:
    OspfAuthProfileMd5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OspfAuthProfileMd5Args:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 preferred: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] key: MD5 hash
        :param pulumi.Input[_builtins.int] name: Key ID
        :param pulumi.Input[_builtins.bool] preferred: Preferred?
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if preferred is not None:
            pulumi.set(__self__, "preferred", preferred)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MD5 hash
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Key ID
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def preferred(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Preferred?
        """
        return pulumi.get(self, "preferred")

    @preferred.setter
    def preferred(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preferred", value)


if not MYPY:
    class PbfRuleActionArgsDict(TypedDict):
        discard: NotRequired[pulumi.Input['PbfRuleActionDiscardArgsDict']]
        """
        Discard
        """
        forward: NotRequired[pulumi.Input['PbfRuleActionForwardArgsDict']]
        """
        Forward

        >  **Note:** You must specify exactly one of `discard`, `forward`, and `no_pbf`.
        """
        no_pbf: NotRequired[pulumi.Input['PbfRuleActionNoPbfArgsDict']]
        """
        No pbf

        >  **Note:** You must specify exactly one of `discard`, `forward`, and `no_pbf`.
        """
elif False:
    PbfRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleActionArgs:
    def __init__(__self__, *,
                 discard: Optional[pulumi.Input['PbfRuleActionDiscardArgs']] = None,
                 forward: Optional[pulumi.Input['PbfRuleActionForwardArgs']] = None,
                 no_pbf: Optional[pulumi.Input['PbfRuleActionNoPbfArgs']] = None):
        """
        :param pulumi.Input['PbfRuleActionDiscardArgs'] discard: Discard
        :param pulumi.Input['PbfRuleActionForwardArgs'] forward: Forward
               
               >  **Note:** You must specify exactly one of `discard`, `forward`, and `no_pbf`.
        :param pulumi.Input['PbfRuleActionNoPbfArgs'] no_pbf: No pbf
               
               >  **Note:** You must specify exactly one of `discard`, `forward`, and `no_pbf`.
        """
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if no_pbf is not None:
            pulumi.set(__self__, "no_pbf", no_pbf)

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input['PbfRuleActionDiscardArgs']]:
        """
        Discard
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input['PbfRuleActionDiscardArgs']]):
        pulumi.set(self, "discard", value)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input['PbfRuleActionForwardArgs']]:
        """
        Forward

        >  **Note:** You must specify exactly one of `discard`, `forward`, and `no_pbf`.
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input['PbfRuleActionForwardArgs']]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter(name="noPbf")
    def no_pbf(self) -> Optional[pulumi.Input['PbfRuleActionNoPbfArgs']]:
        """
        No pbf

        >  **Note:** You must specify exactly one of `discard`, `forward`, and `no_pbf`.
        """
        return pulumi.get(self, "no_pbf")

    @no_pbf.setter
    def no_pbf(self, value: Optional[pulumi.Input['PbfRuleActionNoPbfArgs']]):
        pulumi.set(self, "no_pbf", value)


if not MYPY:
    class PbfRuleActionDiscardArgsDict(TypedDict):
        pass
elif False:
    PbfRuleActionDiscardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleActionDiscardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PbfRuleActionForwardArgsDict(TypedDict):
        egress_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Egress interface
        """
        monitor: NotRequired[pulumi.Input['PbfRuleActionForwardMonitorArgsDict']]
        """
        Monitor
        """
        nexthop: NotRequired[pulumi.Input['PbfRuleActionForwardNexthopArgsDict']]
        """
        Nexthop
        """
elif False:
    PbfRuleActionForwardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleActionForwardArgs:
    def __init__(__self__, *,
                 egress_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 monitor: Optional[pulumi.Input['PbfRuleActionForwardMonitorArgs']] = None,
                 nexthop: Optional[pulumi.Input['PbfRuleActionForwardNexthopArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] egress_interface: Egress interface
        :param pulumi.Input['PbfRuleActionForwardMonitorArgs'] monitor: Monitor
        :param pulumi.Input['PbfRuleActionForwardNexthopArgs'] nexthop: Nexthop
        """
        if egress_interface is not None:
            pulumi.set(__self__, "egress_interface", egress_interface)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)

    @_builtins.property
    @pulumi.getter(name="egressInterface")
    def egress_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Egress interface
        """
        return pulumi.get(self, "egress_interface")

    @egress_interface.setter
    def egress_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_interface", value)

    @_builtins.property
    @pulumi.getter
    def monitor(self) -> Optional[pulumi.Input['PbfRuleActionForwardMonitorArgs']]:
        """
        Monitor
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: Optional[pulumi.Input['PbfRuleActionForwardMonitorArgs']]):
        pulumi.set(self, "monitor", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input['PbfRuleActionForwardNexthopArgs']]:
        """
        Nexthop
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input['PbfRuleActionForwardNexthopArgs']]):
        pulumi.set(self, "nexthop", value)


if not MYPY:
    class PbfRuleActionForwardMonitorArgsDict(TypedDict):
        disable_if_unreachable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable this rule if nexthop/monitor ip is unreachable?
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitor IP address
        """
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitoring profile
        """
elif False:
    PbfRuleActionForwardMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleActionForwardMonitorArgs:
    def __init__(__self__, *,
                 disable_if_unreachable: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_if_unreachable: Disable this rule if nexthop/monitor ip is unreachable?
        :param pulumi.Input[_builtins.str] ip_address: Monitor IP address
        :param pulumi.Input[_builtins.str] profile: Monitoring profile
        """
        if disable_if_unreachable is not None:
            pulumi.set(__self__, "disable_if_unreachable", disable_if_unreachable)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="disableIfUnreachable")
    def disable_if_unreachable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable this rule if nexthop/monitor ip is unreachable?
        """
        return pulumi.get(self, "disable_if_unreachable")

    @disable_if_unreachable.setter
    def disable_if_unreachable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_if_unreachable", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitor IP address
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitoring profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class PbfRuleActionForwardNexthopArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop FQDN
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
elif False:
    PbfRuleActionForwardNexthopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleActionForwardNexthopArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: Next hop FQDN
        :param pulumi.Input[_builtins.str] ip_address: Next hop IP address
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop FQDN
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop IP address

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class PbfRuleActionNoPbfArgsDict(TypedDict):
        pass
elif False:
    PbfRuleActionNoPbfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleActionNoPbfArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PbfRuleEnforceSymmetricReturnArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enforce symmetric return?
        """
        nexthop_address_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbfRuleEnforceSymmetricReturnNexthopAddressListArgsDict']]]]
        """
        Next hop IP addresses
        """
elif False:
    PbfRuleEnforceSymmetricReturnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleEnforceSymmetricReturnArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 nexthop_address_lists: Optional[pulumi.Input[Sequence[pulumi.Input['PbfRuleEnforceSymmetricReturnNexthopAddressListArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enforce symmetric return?
        :param pulumi.Input[Sequence[pulumi.Input['PbfRuleEnforceSymmetricReturnNexthopAddressListArgs']]] nexthop_address_lists: Next hop IP addresses
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if nexthop_address_lists is not None:
            pulumi.set(__self__, "nexthop_address_lists", nexthop_address_lists)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enforce symmetric return?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="nexthopAddressLists")
    def nexthop_address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbfRuleEnforceSymmetricReturnNexthopAddressListArgs']]]]:
        """
        Next hop IP addresses
        """
        return pulumi.get(self, "nexthop_address_lists")

    @nexthop_address_lists.setter
    def nexthop_address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbfRuleEnforceSymmetricReturnNexthopAddressListArgs']]]]):
        pulumi.set(self, "nexthop_address_lists", value)


if not MYPY:
    class PbfRuleEnforceSymmetricReturnNexthopAddressListArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Next hop IP address
        """
elif False:
    PbfRuleEnforceSymmetricReturnNexthopAddressListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleEnforceSymmetricReturnNexthopAddressListArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Next hop IP address
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Next hop IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PbfRuleFromArgsDict(TypedDict):
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Source interfaces
        """
        zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Source zones

        >  **Note:** You must specify exactly one of `interface` and `zone`.
        """
elif False:
    PbfRuleFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbfRuleFromArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interfaces: Source interfaces
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Source zones
               
               >  **Note:** You must specify exactly one of `interface` and `zone`.
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Source interfaces
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "interfaces", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Source zones

        >  **Note:** You must specify exactly one of `interface` and `zone`.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class QosPolicyRuleActionArgsDict(TypedDict):
        class_: NotRequired[pulumi.Input[_builtins.str]]
        """
        Class
        """
elif False:
    QosPolicyRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleActionArgs:
    def __init__(__self__, *,
                 class_: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] class_: Class
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Class
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "class_", value)


if not MYPY:
    class QosPolicyRuleDscpTosArgsDict(TypedDict):
        codepoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['QosPolicyRuleDscpTosCodepointArgsDict']]]]
        """
        Codepoints
        """
elif False:
    QosPolicyRuleDscpTosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosArgs:
    def __init__(__self__, *,
                 codepoints: Optional[pulumi.Input[Sequence[pulumi.Input['QosPolicyRuleDscpTosCodepointArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['QosPolicyRuleDscpTosCodepointArgs']]] codepoints: Codepoints
        """
        if codepoints is not None:
            pulumi.set(__self__, "codepoints", codepoints)

    @_builtins.property
    @pulumi.getter
    def codepoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['QosPolicyRuleDscpTosCodepointArgs']]]]:
        """
        Codepoints
        """
        return pulumi.get(self, "codepoints")

    @codepoints.setter
    def codepoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['QosPolicyRuleDscpTosCodepointArgs']]]]):
        pulumi.set(self, "codepoints", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        type: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeArgsDict']]
        """
        Type
        """
elif False:
    QosPolicyRuleDscpTosCodepointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeArgs'] type: Type
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeArgs']]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeArgs']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeArgsDict(TypedDict):
        af: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeAfArgsDict']]
        """
        Af
        """
        cs: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCsArgsDict']]
        """
        Cs

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        custom: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomArgsDict']]
        """
        Custom

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        ef: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeEfArgsDict']]
        """
        Ef

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        tos: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeTosArgsDict']]
        """
        Tos

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
elif False:
    QosPolicyRuleDscpTosCodepointTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeArgs:
    def __init__(__self__, *,
                 af: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeAfArgs']] = None,
                 cs: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCsArgs']] = None,
                 custom: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomArgs']] = None,
                 ef: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeEfArgs']] = None,
                 tos: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeTosArgs']] = None):
        """
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeAfArgs'] af: Af
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCsArgs'] cs: Cs
               
               >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomArgs'] custom: Custom
               
               >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeEfArgs'] ef: Ef
               
               >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeTosArgs'] tos: Tos
               
               >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        if af is not None:
            pulumi.set(__self__, "af", af)
        if cs is not None:
            pulumi.set(__self__, "cs", cs)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if ef is not None:
            pulumi.set(__self__, "ef", ef)
        if tos is not None:
            pulumi.set(__self__, "tos", tos)

    @_builtins.property
    @pulumi.getter
    def af(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeAfArgs']]:
        """
        Af
        """
        return pulumi.get(self, "af")

    @af.setter
    def af(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeAfArgs']]):
        pulumi.set(self, "af", value)

    @_builtins.property
    @pulumi.getter
    def cs(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCsArgs']]:
        """
        Cs

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        return pulumi.get(self, "cs")

    @cs.setter
    def cs(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCsArgs']]):
        pulumi.set(self, "cs", value)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomArgs']]:
        """
        Custom

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomArgs']]):
        pulumi.set(self, "custom", value)

    @_builtins.property
    @pulumi.getter
    def ef(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeEfArgs']]:
        """
        Ef

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        return pulumi.get(self, "ef")

    @ef.setter
    def ef(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeEfArgs']]):
        pulumi.set(self, "ef", value)

    @_builtins.property
    @pulumi.getter
    def tos(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeTosArgs']]:
        """
        Tos

        >  **Note:** You must specify exactly one of `af`, `cs`, `custom`, `ef`, and `tos`.
        """
        return pulumi.get(self, "tos")

    @tos.setter
    def tos(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeTosArgs']]):
        pulumi.set(self, "tos", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeAfArgsDict(TypedDict):
        codepoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Codepoint
        """
elif False:
    QosPolicyRuleDscpTosCodepointTypeAfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeAfArgs:
    def __init__(__self__, *,
                 codepoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] codepoint: Codepoint
        """
        if codepoint is not None:
            pulumi.set(__self__, "codepoint", codepoint)

    @_builtins.property
    @pulumi.getter
    def codepoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Codepoint
        """
        return pulumi.get(self, "codepoint")

    @codepoint.setter
    def codepoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "codepoint", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeCsArgsDict(TypedDict):
        codepoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Codepoint
        """
elif False:
    QosPolicyRuleDscpTosCodepointTypeCsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeCsArgs:
    def __init__(__self__, *,
                 codepoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] codepoint: Codepoint
        """
        if codepoint is not None:
            pulumi.set(__self__, "codepoint", codepoint)

    @_builtins.property
    @pulumi.getter
    def codepoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Codepoint
        """
        return pulumi.get(self, "codepoint")

    @codepoint.setter
    def codepoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "codepoint", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeCustomArgsDict(TypedDict):
        codepoint: NotRequired[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgsDict']]
        """
        Codepoint
        """
elif False:
    QosPolicyRuleDscpTosCodepointTypeCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeCustomArgs:
    def __init__(__self__, *,
                 codepoint: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgs']] = None):
        """
        :param pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgs'] codepoint: Codepoint
        """
        if codepoint is not None:
            pulumi.set(__self__, "codepoint", codepoint)

    @_builtins.property
    @pulumi.getter
    def codepoint(self) -> Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgs']]:
        """
        Codepoint
        """
        return pulumi.get(self, "codepoint")

    @codepoint.setter
    def codepoint(self, value: Optional[pulumi.Input['QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgs']]):
        pulumi.set(self, "codepoint", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgsDict(TypedDict):
        binary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Binary value
        """
        codepoint_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Codepoint name
        """
elif False:
    QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeCustomCodepointArgs:
    def __init__(__self__, *,
                 binary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 codepoint_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] binary_value: Binary value
        :param pulumi.Input[_builtins.str] codepoint_name: Codepoint name
        """
        if binary_value is not None:
            pulumi.set(__self__, "binary_value", binary_value)
        if codepoint_name is not None:
            pulumi.set(__self__, "codepoint_name", codepoint_name)

    @_builtins.property
    @pulumi.getter(name="binaryValue")
    def binary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Binary value
        """
        return pulumi.get(self, "binary_value")

    @binary_value.setter
    def binary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "binary_value", value)

    @_builtins.property
    @pulumi.getter(name="codepointName")
    def codepoint_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Codepoint name
        """
        return pulumi.get(self, "codepoint_name")

    @codepoint_name.setter
    def codepoint_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "codepoint_name", value)


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeEfArgsDict(TypedDict):
        pass
elif False:
    QosPolicyRuleDscpTosCodepointTypeEfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeEfArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class QosPolicyRuleDscpTosCodepointTypeTosArgsDict(TypedDict):
        codepoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Codepoint
        """
elif False:
    QosPolicyRuleDscpTosCodepointTypeTosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosPolicyRuleDscpTosCodepointTypeTosArgs:
    def __init__(__self__, *,
                 codepoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] codepoint: Codepoint
        """
        if codepoint is not None:
            pulumi.set(__self__, "codepoint", codepoint)

    @_builtins.property
    @pulumi.getter
    def codepoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Codepoint
        """
        return pulumi.get(self, "codepoint")

    @codepoint.setter
    def codepoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "codepoint", value)


if not MYPY:
    class QosProfileAggregateBandwidthArgsDict(TypedDict):
        egress_guaranteed: NotRequired[pulumi.Input[_builtins.int]]
        """
        guaranteed sending bandwidth in mbps
        """
        egress_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        max sending bandwidth in mbps
        """
elif False:
    QosProfileAggregateBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileAggregateBandwidthArgs:
    def __init__(__self__, *,
                 egress_guaranteed: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_max: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] egress_guaranteed: guaranteed sending bandwidth in mbps
        :param pulumi.Input[_builtins.int] egress_max: max sending bandwidth in mbps
        """
        if egress_guaranteed is not None:
            pulumi.set(__self__, "egress_guaranteed", egress_guaranteed)
        if egress_max is not None:
            pulumi.set(__self__, "egress_max", egress_max)

    @_builtins.property
    @pulumi.getter(name="egressGuaranteed")
    def egress_guaranteed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        guaranteed sending bandwidth in mbps
        """
        return pulumi.get(self, "egress_guaranteed")

    @egress_guaranteed.setter
    def egress_guaranteed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_guaranteed", value)

    @_builtins.property
    @pulumi.getter(name="egressMax")
    def egress_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        max sending bandwidth in mbps
        """
        return pulumi.get(self, "egress_max")

    @egress_max.setter
    def egress_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_max", value)


if not MYPY:
    class QosProfileClassBandwidthTypeArgsDict(TypedDict):
        mbps: NotRequired[pulumi.Input['QosProfileClassBandwidthTypeMbpsArgsDict']]
        """
        Mbps
        """
        percentage: NotRequired[pulumi.Input['QosProfileClassBandwidthTypePercentageArgsDict']]
        """
        Percentage

        >  **Note:** You must specify exactly one of `mbps` and `percentage`.
        """
elif False:
    QosProfileClassBandwidthTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypeArgs:
    def __init__(__self__, *,
                 mbps: Optional[pulumi.Input['QosProfileClassBandwidthTypeMbpsArgs']] = None,
                 percentage: Optional[pulumi.Input['QosProfileClassBandwidthTypePercentageArgs']] = None):
        """
        :param pulumi.Input['QosProfileClassBandwidthTypeMbpsArgs'] mbps: Mbps
        :param pulumi.Input['QosProfileClassBandwidthTypePercentageArgs'] percentage: Percentage
               
               >  **Note:** You must specify exactly one of `mbps` and `percentage`.
        """
        if mbps is not None:
            pulumi.set(__self__, "mbps", mbps)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter
    def mbps(self) -> Optional[pulumi.Input['QosProfileClassBandwidthTypeMbpsArgs']]:
        """
        Mbps
        """
        return pulumi.get(self, "mbps")

    @mbps.setter
    def mbps(self, value: Optional[pulumi.Input['QosProfileClassBandwidthTypeMbpsArgs']]):
        pulumi.set(self, "mbps", value)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input['QosProfileClassBandwidthTypePercentageArgs']]:
        """
        Percentage

        >  **Note:** You must specify exactly one of `mbps` and `percentage`.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input['QosProfileClassBandwidthTypePercentageArgs']]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class QosProfileClassBandwidthTypeMbpsArgsDict(TypedDict):
        classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassArgsDict']]]]
        """
        QoS setting for traffic classes
        """
elif False:
    QosProfileClassBandwidthTypeMbpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypeMbpsArgs:
    def __init__(__self__, *,
                 classes: Optional[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassArgs']]] classes: QoS setting for traffic classes
        """
        if classes is not None:
            pulumi.set(__self__, "classes", classes)

    @_builtins.property
    @pulumi.getter
    def classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassArgs']]]]:
        """
        QoS setting for traffic classes
        """
        return pulumi.get(self, "classes")

    @classes.setter
    def classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassArgs']]]]):
        pulumi.set(self, "classes", value)


if not MYPY:
    class QosProfileClassBandwidthTypeMbpsClassArgsDict(TypedDict):
        class_bandwidth: NotRequired[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgsDict']]
        """
        Class bandwidth
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Traffic class
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        traffic class priority
        """
elif False:
    QosProfileClassBandwidthTypeMbpsClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypeMbpsClassArgs:
    def __init__(__self__, *,
                 class_bandwidth: Optional[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgs'] class_bandwidth: Class bandwidth
        :param pulumi.Input[_builtins.str] name: Traffic class
        :param pulumi.Input[_builtins.str] priority: traffic class priority
        """
        if class_bandwidth is not None:
            pulumi.set(__self__, "class_bandwidth", class_bandwidth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter(name="classBandwidth")
    def class_bandwidth(self) -> Optional[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgs']]:
        """
        Class bandwidth
        """
        return pulumi.get(self, "class_bandwidth")

    @class_bandwidth.setter
    def class_bandwidth(self, value: Optional[pulumi.Input['QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgs']]):
        pulumi.set(self, "class_bandwidth", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Traffic class
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        traffic class priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgsDict(TypedDict):
        egress_guaranteed: NotRequired[pulumi.Input[_builtins.int]]
        """
        guaranteed sending bandwidth in mbps
        """
        egress_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        max sending bandwidth in mbps
        """
elif False:
    QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypeMbpsClassClassBandwidthArgs:
    def __init__(__self__, *,
                 egress_guaranteed: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_max: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] egress_guaranteed: guaranteed sending bandwidth in mbps
        :param pulumi.Input[_builtins.int] egress_max: max sending bandwidth in mbps
        """
        if egress_guaranteed is not None:
            pulumi.set(__self__, "egress_guaranteed", egress_guaranteed)
        if egress_max is not None:
            pulumi.set(__self__, "egress_max", egress_max)

    @_builtins.property
    @pulumi.getter(name="egressGuaranteed")
    def egress_guaranteed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        guaranteed sending bandwidth in mbps
        """
        return pulumi.get(self, "egress_guaranteed")

    @egress_guaranteed.setter
    def egress_guaranteed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_guaranteed", value)

    @_builtins.property
    @pulumi.getter(name="egressMax")
    def egress_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        max sending bandwidth in mbps
        """
        return pulumi.get(self, "egress_max")

    @egress_max.setter
    def egress_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_max", value)


if not MYPY:
    class QosProfileClassBandwidthTypePercentageArgsDict(TypedDict):
        classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypePercentageClassArgsDict']]]]
        """
        QoS setting for traffic classes
        """
elif False:
    QosProfileClassBandwidthTypePercentageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypePercentageArgs:
    def __init__(__self__, *,
                 classes: Optional[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypePercentageClassArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypePercentageClassArgs']]] classes: QoS setting for traffic classes
        """
        if classes is not None:
            pulumi.set(__self__, "classes", classes)

    @_builtins.property
    @pulumi.getter
    def classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypePercentageClassArgs']]]]:
        """
        QoS setting for traffic classes
        """
        return pulumi.get(self, "classes")

    @classes.setter
    def classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['QosProfileClassBandwidthTypePercentageClassArgs']]]]):
        pulumi.set(self, "classes", value)


if not MYPY:
    class QosProfileClassBandwidthTypePercentageClassArgsDict(TypedDict):
        class_bandwidth: NotRequired[pulumi.Input['QosProfileClassBandwidthTypePercentageClassClassBandwidthArgsDict']]
        """
        Class bandwidth
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Traffic class
        """
        priority: NotRequired[pulumi.Input[_builtins.str]]
        """
        traffic class priority
        """
elif False:
    QosProfileClassBandwidthTypePercentageClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypePercentageClassArgs:
    def __init__(__self__, *,
                 class_bandwidth: Optional[pulumi.Input['QosProfileClassBandwidthTypePercentageClassClassBandwidthArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['QosProfileClassBandwidthTypePercentageClassClassBandwidthArgs'] class_bandwidth: Class bandwidth
        :param pulumi.Input[_builtins.str] name: Traffic class
        :param pulumi.Input[_builtins.str] priority: traffic class priority
        """
        if class_bandwidth is not None:
            pulumi.set(__self__, "class_bandwidth", class_bandwidth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter(name="classBandwidth")
    def class_bandwidth(self) -> Optional[pulumi.Input['QosProfileClassBandwidthTypePercentageClassClassBandwidthArgs']]:
        """
        Class bandwidth
        """
        return pulumi.get(self, "class_bandwidth")

    @class_bandwidth.setter
    def class_bandwidth(self, value: Optional[pulumi.Input['QosProfileClassBandwidthTypePercentageClassClassBandwidthArgs']]):
        pulumi.set(self, "class_bandwidth", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Traffic class
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        traffic class priority
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class QosProfileClassBandwidthTypePercentageClassClassBandwidthArgsDict(TypedDict):
        egress_guaranteed: NotRequired[pulumi.Input[_builtins.int]]
        """
        guaranteed sending bandwidth in percentage
        """
        egress_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        max sending bandwidth in percentage
        """
elif False:
    QosProfileClassBandwidthTypePercentageClassClassBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QosProfileClassBandwidthTypePercentageClassClassBandwidthArgs:
    def __init__(__self__, *,
                 egress_guaranteed: Optional[pulumi.Input[_builtins.int]] = None,
                 egress_max: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] egress_guaranteed: guaranteed sending bandwidth in percentage
        :param pulumi.Input[_builtins.int] egress_max: max sending bandwidth in percentage
        """
        if egress_guaranteed is not None:
            pulumi.set(__self__, "egress_guaranteed", egress_guaranteed)
        if egress_max is not None:
            pulumi.set(__self__, "egress_max", egress_max)

    @_builtins.property
    @pulumi.getter(name="egressGuaranteed")
    def egress_guaranteed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        guaranteed sending bandwidth in percentage
        """
        return pulumi.get(self, "egress_guaranteed")

    @egress_guaranteed.setter
    def egress_guaranteed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_guaranteed", value)

    @_builtins.property
    @pulumi.getter(name="egressMax")
    def egress_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        max sending bandwidth in percentage
        """
        return pulumi.get(self, "egress_max")

    @egress_max.setter
    def egress_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "egress_max", value)


if not MYPY:
    class RadiusServerProfileProtocolArgsDict(TypedDict):
        chap: NotRequired[pulumi.Input['RadiusServerProfileProtocolChapArgsDict']]
        """
        C h a p
        """
        eap_ttls_with_pap: NotRequired[pulumi.Input['RadiusServerProfileProtocolEapTtlsWithPapArgsDict']]
        """
        E a p t t l s with p a p
        """
        pap: NotRequired[pulumi.Input['RadiusServerProfileProtocolPapArgsDict']]
        """
        P a p
        """
        peap_mscha_pv2: NotRequired[pulumi.Input['RadiusServerProfileProtocolPeapMschaPv2ArgsDict']]
        """
        P e a p m s c h a pv2
        """
        peap_with_gtc: NotRequired[pulumi.Input['RadiusServerProfileProtocolPeapWithGtcArgsDict']]
        """
        P e a p with g t c
        """
elif False:
    RadiusServerProfileProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileProtocolArgs:
    def __init__(__self__, *,
                 chap: Optional[pulumi.Input['RadiusServerProfileProtocolChapArgs']] = None,
                 eap_ttls_with_pap: Optional[pulumi.Input['RadiusServerProfileProtocolEapTtlsWithPapArgs']] = None,
                 pap: Optional[pulumi.Input['RadiusServerProfileProtocolPapArgs']] = None,
                 peap_mscha_pv2: Optional[pulumi.Input['RadiusServerProfileProtocolPeapMschaPv2Args']] = None,
                 peap_with_gtc: Optional[pulumi.Input['RadiusServerProfileProtocolPeapWithGtcArgs']] = None):
        """
        :param pulumi.Input['RadiusServerProfileProtocolChapArgs'] chap: C h a p
        :param pulumi.Input['RadiusServerProfileProtocolEapTtlsWithPapArgs'] eap_ttls_with_pap: E a p t t l s with p a p
        :param pulumi.Input['RadiusServerProfileProtocolPapArgs'] pap: P a p
        :param pulumi.Input['RadiusServerProfileProtocolPeapMschaPv2Args'] peap_mscha_pv2: P e a p m s c h a pv2
        :param pulumi.Input['RadiusServerProfileProtocolPeapWithGtcArgs'] peap_with_gtc: P e a p with g t c
        """
        if chap is not None:
            pulumi.set(__self__, "chap", chap)
        if eap_ttls_with_pap is not None:
            pulumi.set(__self__, "eap_ttls_with_pap", eap_ttls_with_pap)
        if pap is not None:
            pulumi.set(__self__, "pap", pap)
        if peap_mscha_pv2 is not None:
            pulumi.set(__self__, "peap_mscha_pv2", peap_mscha_pv2)
        if peap_with_gtc is not None:
            pulumi.set(__self__, "peap_with_gtc", peap_with_gtc)

    @_builtins.property
    @pulumi.getter
    def chap(self) -> Optional[pulumi.Input['RadiusServerProfileProtocolChapArgs']]:
        """
        C h a p
        """
        return pulumi.get(self, "chap")

    @chap.setter
    def chap(self, value: Optional[pulumi.Input['RadiusServerProfileProtocolChapArgs']]):
        pulumi.set(self, "chap", value)

    @_builtins.property
    @pulumi.getter(name="eapTtlsWithPap")
    def eap_ttls_with_pap(self) -> Optional[pulumi.Input['RadiusServerProfileProtocolEapTtlsWithPapArgs']]:
        """
        E a p t t l s with p a p
        """
        return pulumi.get(self, "eap_ttls_with_pap")

    @eap_ttls_with_pap.setter
    def eap_ttls_with_pap(self, value: Optional[pulumi.Input['RadiusServerProfileProtocolEapTtlsWithPapArgs']]):
        pulumi.set(self, "eap_ttls_with_pap", value)

    @_builtins.property
    @pulumi.getter
    def pap(self) -> Optional[pulumi.Input['RadiusServerProfileProtocolPapArgs']]:
        """
        P a p
        """
        return pulumi.get(self, "pap")

    @pap.setter
    def pap(self, value: Optional[pulumi.Input['RadiusServerProfileProtocolPapArgs']]):
        pulumi.set(self, "pap", value)

    @_builtins.property
    @pulumi.getter(name="peapMschaPv2")
    def peap_mscha_pv2(self) -> Optional[pulumi.Input['RadiusServerProfileProtocolPeapMschaPv2Args']]:
        """
        P e a p m s c h a pv2
        """
        return pulumi.get(self, "peap_mscha_pv2")

    @peap_mscha_pv2.setter
    def peap_mscha_pv2(self, value: Optional[pulumi.Input['RadiusServerProfileProtocolPeapMschaPv2Args']]):
        pulumi.set(self, "peap_mscha_pv2", value)

    @_builtins.property
    @pulumi.getter(name="peapWithGtc")
    def peap_with_gtc(self) -> Optional[pulumi.Input['RadiusServerProfileProtocolPeapWithGtcArgs']]:
        """
        P e a p with g t c
        """
        return pulumi.get(self, "peap_with_gtc")

    @peap_with_gtc.setter
    def peap_with_gtc(self, value: Optional[pulumi.Input['RadiusServerProfileProtocolPeapWithGtcArgs']]):
        pulumi.set(self, "peap_with_gtc", value)


if not MYPY:
    class RadiusServerProfileProtocolChapArgsDict(TypedDict):
        pass
elif False:
    RadiusServerProfileProtocolChapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileProtocolChapArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RadiusServerProfileProtocolEapTtlsWithPapArgsDict(TypedDict):
        anon_outer_id: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Anon outer id
        """
        radius_cert_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Radius cert profile
        """
elif False:
    RadiusServerProfileProtocolEapTtlsWithPapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileProtocolEapTtlsWithPapArgs:
    def __init__(__self__, *,
                 anon_outer_id: Optional[pulumi.Input[_builtins.bool]] = None,
                 radius_cert_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] anon_outer_id: Anon outer id
        :param pulumi.Input[_builtins.str] radius_cert_profile: Radius cert profile
        """
        if anon_outer_id is not None:
            pulumi.set(__self__, "anon_outer_id", anon_outer_id)
        if radius_cert_profile is not None:
            pulumi.set(__self__, "radius_cert_profile", radius_cert_profile)

    @_builtins.property
    @pulumi.getter(name="anonOuterId")
    def anon_outer_id(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Anon outer id
        """
        return pulumi.get(self, "anon_outer_id")

    @anon_outer_id.setter
    def anon_outer_id(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "anon_outer_id", value)

    @_builtins.property
    @pulumi.getter(name="radiusCertProfile")
    def radius_cert_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Radius cert profile
        """
        return pulumi.get(self, "radius_cert_profile")

    @radius_cert_profile.setter
    def radius_cert_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "radius_cert_profile", value)


if not MYPY:
    class RadiusServerProfileProtocolPapArgsDict(TypedDict):
        pass
elif False:
    RadiusServerProfileProtocolPapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileProtocolPapArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RadiusServerProfileProtocolPeapMschaPv2ArgsDict(TypedDict):
        allow_pwd_change: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow pwd change
        """
        anon_outer_id: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Anon outer id
        """
        radius_cert_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Radius cert profile
        """
elif False:
    RadiusServerProfileProtocolPeapMschaPv2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileProtocolPeapMschaPv2Args:
    def __init__(__self__, *,
                 allow_pwd_change: Optional[pulumi.Input[_builtins.bool]] = None,
                 anon_outer_id: Optional[pulumi.Input[_builtins.bool]] = None,
                 radius_cert_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_pwd_change: Allow pwd change
        :param pulumi.Input[_builtins.bool] anon_outer_id: Anon outer id
        :param pulumi.Input[_builtins.str] radius_cert_profile: Radius cert profile
        """
        if allow_pwd_change is not None:
            pulumi.set(__self__, "allow_pwd_change", allow_pwd_change)
        if anon_outer_id is not None:
            pulumi.set(__self__, "anon_outer_id", anon_outer_id)
        if radius_cert_profile is not None:
            pulumi.set(__self__, "radius_cert_profile", radius_cert_profile)

    @_builtins.property
    @pulumi.getter(name="allowPwdChange")
    def allow_pwd_change(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow pwd change
        """
        return pulumi.get(self, "allow_pwd_change")

    @allow_pwd_change.setter
    def allow_pwd_change(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_pwd_change", value)

    @_builtins.property
    @pulumi.getter(name="anonOuterId")
    def anon_outer_id(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Anon outer id
        """
        return pulumi.get(self, "anon_outer_id")

    @anon_outer_id.setter
    def anon_outer_id(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "anon_outer_id", value)

    @_builtins.property
    @pulumi.getter(name="radiusCertProfile")
    def radius_cert_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Radius cert profile
        """
        return pulumi.get(self, "radius_cert_profile")

    @radius_cert_profile.setter
    def radius_cert_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "radius_cert_profile", value)


if not MYPY:
    class RadiusServerProfileProtocolPeapWithGtcArgsDict(TypedDict):
        anon_outer_id: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Anon outer id
        """
        radius_cert_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Radius cert profile
        """
elif False:
    RadiusServerProfileProtocolPeapWithGtcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileProtocolPeapWithGtcArgs:
    def __init__(__self__, *,
                 anon_outer_id: Optional[pulumi.Input[_builtins.bool]] = None,
                 radius_cert_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] anon_outer_id: Anon outer id
        :param pulumi.Input[_builtins.str] radius_cert_profile: Radius cert profile
        """
        if anon_outer_id is not None:
            pulumi.set(__self__, "anon_outer_id", anon_outer_id)
        if radius_cert_profile is not None:
            pulumi.set(__self__, "radius_cert_profile", radius_cert_profile)

    @_builtins.property
    @pulumi.getter(name="anonOuterId")
    def anon_outer_id(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Anon outer id
        """
        return pulumi.get(self, "anon_outer_id")

    @anon_outer_id.setter
    def anon_outer_id(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "anon_outer_id", value)

    @_builtins.property
    @pulumi.getter(name="radiusCertProfile")
    def radius_cert_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Radius cert profile
        """
        return pulumi.get(self, "radius_cert_profile")

    @radius_cert_profile.setter
    def radius_cert_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "radius_cert_profile", value)


if not MYPY:
    class RadiusServerProfileServerArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the RADIUS server
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the RADIUS server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The RADIUS server port
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The RADIUS secret
        """
elif False:
    RadiusServerProfileServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RadiusServerProfileServerArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: The IP address of the RADIUS server
        :param pulumi.Input[_builtins.str] name: The name of the RADIUS server
        :param pulumi.Input[_builtins.int] port: The RADIUS server port
        :param pulumi.Input[_builtins.str] secret: The RADIUS secret
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the RADIUS server
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the RADIUS server
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The RADIUS server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The RADIUS secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class RegionGeoLocationArgsDict(TypedDict):
        latitude: pulumi.Input[_builtins.float]
        """
        The latitudinal position of the region
        """
        longitude: pulumi.Input[_builtins.float]
        """
        The longitudinal postition of the region
        """
elif False:
    RegionGeoLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegionGeoLocationArgs:
    def __init__(__self__, *,
                 latitude: pulumi.Input[_builtins.float],
                 longitude: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] latitude: The latitudinal position of the region
        :param pulumi.Input[_builtins.float] longitude: The longitudinal postition of the region
        """
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[_builtins.float]:
        """
        The latitudinal position of the region
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[_builtins.float]:
        """
        The longitudinal postition of the region
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "longitude", value)


if not MYPY:
    class RemoteNetworkEcmpTunnelArgsDict(TypedDict):
        ipsec_tunnel: pulumi.Input[_builtins.str]
        """
        Ipsec tunnel
        """
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        protocol: pulumi.Input['RemoteNetworkEcmpTunnelProtocolArgsDict']
        """
        Protocol
        """
elif False:
    RemoteNetworkEcmpTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNetworkEcmpTunnelArgs:
    def __init__(__self__, *,
                 ipsec_tunnel: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input['RemoteNetworkEcmpTunnelProtocolArgs']):
        """
        :param pulumi.Input[_builtins.str] ipsec_tunnel: Ipsec tunnel
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['RemoteNetworkEcmpTunnelProtocolArgs'] protocol: Protocol
        """
        pulumi.set(__self__, "ipsec_tunnel", ipsec_tunnel)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="ipsecTunnel")
    def ipsec_tunnel(self) -> pulumi.Input[_builtins.str]:
        """
        Ipsec tunnel
        """
        return pulumi.get(self, "ipsec_tunnel")

    @ipsec_tunnel.setter
    def ipsec_tunnel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipsec_tunnel", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['RemoteNetworkEcmpTunnelProtocolArgs']:
        """
        Protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['RemoteNetworkEcmpTunnelProtocolArgs']):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class RemoteNetworkEcmpTunnelProtocolArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['RemoteNetworkEcmpTunnelProtocolBgpArgsDict']]
        """
        Bgp
        """
elif False:
    RemoteNetworkEcmpTunnelProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNetworkEcmpTunnelProtocolArgs:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['RemoteNetworkEcmpTunnelProtocolBgpArgs']] = None):
        """
        :param pulumi.Input['RemoteNetworkEcmpTunnelProtocolBgpArgs'] bgp: Bgp
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['RemoteNetworkEcmpTunnelProtocolBgpArgs']]:
        """
        Bgp
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['RemoteNetworkEcmpTunnelProtocolBgpArgs']]):
        pulumi.set(self, "bgp", value)


if not MYPY:
    class RemoteNetworkEcmpTunnelProtocolBgpArgsDict(TypedDict):
        do_not_export_routes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not export routes?
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable BGP peering?
        """
        local_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local peer IP address
        """
        originate_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Originate default route?
        """
        peer_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP peer ASN
        """
        peer_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remote peer IP address
        """
        peering_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route exchange types
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP peering secret
        """
        summarize_mobile_user_routes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Summarize mobile user routes?
        """
elif False:
    RemoteNetworkEcmpTunnelProtocolBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNetworkEcmpTunnelProtocolBgpArgs:
    def __init__(__self__, *,
                 do_not_export_routes: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 originate_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 peer_as: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peering_type: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 summarize_mobile_user_routes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] do_not_export_routes: Do not export routes?
        :param pulumi.Input[_builtins.bool] enable: Enable BGP peering?
        :param pulumi.Input[_builtins.str] local_ip_address: Local peer IP address
        :param pulumi.Input[_builtins.bool] originate_default_route: Originate default route?
        :param pulumi.Input[_builtins.str] peer_as: BGP peer ASN
        :param pulumi.Input[_builtins.str] peer_ip_address: Remote peer IP address
        :param pulumi.Input[_builtins.str] peering_type: Route exchange types
        :param pulumi.Input[_builtins.str] secret: BGP peering secret
        :param pulumi.Input[_builtins.bool] summarize_mobile_user_routes: Summarize mobile user routes?
        """
        if do_not_export_routes is not None:
            pulumi.set(__self__, "do_not_export_routes", do_not_export_routes)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if originate_default_route is not None:
            pulumi.set(__self__, "originate_default_route", originate_default_route)
        if peer_as is not None:
            pulumi.set(__self__, "peer_as", peer_as)
        if peer_ip_address is not None:
            pulumi.set(__self__, "peer_ip_address", peer_ip_address)
        if peering_type is not None:
            pulumi.set(__self__, "peering_type", peering_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if summarize_mobile_user_routes is not None:
            pulumi.set(__self__, "summarize_mobile_user_routes", summarize_mobile_user_routes)

    @_builtins.property
    @pulumi.getter(name="doNotExportRoutes")
    def do_not_export_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not export routes?
        """
        return pulumi.get(self, "do_not_export_routes")

    @do_not_export_routes.setter
    def do_not_export_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "do_not_export_routes", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable BGP peering?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local peer IP address
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="originateDefaultRoute")
    def originate_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Originate default route?
        """
        return pulumi.get(self, "originate_default_route")

    @originate_default_route.setter
    def originate_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "originate_default_route", value)

    @_builtins.property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP peer ASN
        """
        return pulumi.get(self, "peer_as")

    @peer_as.setter
    def peer_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_as", value)

    @_builtins.property
    @pulumi.getter(name="peerIpAddress")
    def peer_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remote peer IP address
        """
        return pulumi.get(self, "peer_ip_address")

    @peer_ip_address.setter
    def peer_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route exchange types
        """
        return pulumi.get(self, "peering_type")

    @peering_type.setter
    def peering_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peering_type", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP peering secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="summarizeMobileUserRoutes")
    def summarize_mobile_user_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Summarize mobile user routes?
        """
        return pulumi.get(self, "summarize_mobile_user_routes")

    @summarize_mobile_user_routes.setter
    def summarize_mobile_user_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "summarize_mobile_user_routes", value)


if not MYPY:
    class RemoteNetworkProtocolArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['RemoteNetworkProtocolBgpArgsDict']]
        """
        Bgp
        """
        bgp_peer: NotRequired[pulumi.Input['RemoteNetworkProtocolBgpPeerArgsDict']]
        """
        secondary bgp routing as bgp*peer
        """
elif False:
    RemoteNetworkProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNetworkProtocolArgs:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['RemoteNetworkProtocolBgpArgs']] = None,
                 bgp_peer: Optional[pulumi.Input['RemoteNetworkProtocolBgpPeerArgs']] = None):
        """
        :param pulumi.Input['RemoteNetworkProtocolBgpArgs'] bgp: Bgp
        :param pulumi.Input['RemoteNetworkProtocolBgpPeerArgs'] bgp_peer: secondary bgp routing as bgp*peer
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)
        if bgp_peer is not None:
            pulumi.set(__self__, "bgp_peer", bgp_peer)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['RemoteNetworkProtocolBgpArgs']]:
        """
        Bgp
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['RemoteNetworkProtocolBgpArgs']]):
        pulumi.set(self, "bgp", value)

    @_builtins.property
    @pulumi.getter(name="bgpPeer")
    def bgp_peer(self) -> Optional[pulumi.Input['RemoteNetworkProtocolBgpPeerArgs']]:
        """
        secondary bgp routing as bgp*peer
        """
        return pulumi.get(self, "bgp_peer")

    @bgp_peer.setter
    def bgp_peer(self, value: Optional[pulumi.Input['RemoteNetworkProtocolBgpPeerArgs']]):
        pulumi.set(self, "bgp_peer", value)


if not MYPY:
    class RemoteNetworkProtocolBgpArgsDict(TypedDict):
        do_not_export_routes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not export routes?
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable BGP peering?
        """
        local_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local peer IP address
        """
        originate_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Originate default route?
        """
        peer_as: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP peer ASN
        """
        peer_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remote peer IP address
        """
        peering_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route exchange types
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP peering secret
        """
        summarize_mobile_user_routes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Summarize mobile user routes?
        """
elif False:
    RemoteNetworkProtocolBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNetworkProtocolBgpArgs:
    def __init__(__self__, *,
                 do_not_export_routes: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 originate_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 peer_as: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peering_type: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 summarize_mobile_user_routes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] do_not_export_routes: Do not export routes?
        :param pulumi.Input[_builtins.bool] enable: Enable BGP peering?
        :param pulumi.Input[_builtins.str] local_ip_address: Local peer IP address
        :param pulumi.Input[_builtins.bool] originate_default_route: Originate default route?
        :param pulumi.Input[_builtins.str] peer_as: BGP peer ASN
        :param pulumi.Input[_builtins.str] peer_ip_address: Remote peer IP address
        :param pulumi.Input[_builtins.str] peering_type: Route exchange types
        :param pulumi.Input[_builtins.str] secret: BGP peering secret
        :param pulumi.Input[_builtins.bool] summarize_mobile_user_routes: Summarize mobile user routes?
        """
        if do_not_export_routes is not None:
            pulumi.set(__self__, "do_not_export_routes", do_not_export_routes)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if originate_default_route is not None:
            pulumi.set(__self__, "originate_default_route", originate_default_route)
        if peer_as is not None:
            pulumi.set(__self__, "peer_as", peer_as)
        if peer_ip_address is not None:
            pulumi.set(__self__, "peer_ip_address", peer_ip_address)
        if peering_type is not None:
            pulumi.set(__self__, "peering_type", peering_type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if summarize_mobile_user_routes is not None:
            pulumi.set(__self__, "summarize_mobile_user_routes", summarize_mobile_user_routes)

    @_builtins.property
    @pulumi.getter(name="doNotExportRoutes")
    def do_not_export_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not export routes?
        """
        return pulumi.get(self, "do_not_export_routes")

    @do_not_export_routes.setter
    def do_not_export_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "do_not_export_routes", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable BGP peering?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local peer IP address
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="originateDefaultRoute")
    def originate_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Originate default route?
        """
        return pulumi.get(self, "originate_default_route")

    @originate_default_route.setter
    def originate_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "originate_default_route", value)

    @_builtins.property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP peer ASN
        """
        return pulumi.get(self, "peer_as")

    @peer_as.setter
    def peer_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_as", value)

    @_builtins.property
    @pulumi.getter(name="peerIpAddress")
    def peer_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remote peer IP address
        """
        return pulumi.get(self, "peer_ip_address")

    @peer_ip_address.setter
    def peer_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route exchange types
        """
        return pulumi.get(self, "peering_type")

    @peering_type.setter
    def peering_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peering_type", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP peering secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="summarizeMobileUserRoutes")
    def summarize_mobile_user_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Summarize mobile user routes?
        """
        return pulumi.get(self, "summarize_mobile_user_routes")

    @summarize_mobile_user_routes.setter
    def summarize_mobile_user_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "summarize_mobile_user_routes", value)


if not MYPY:
    class RemoteNetworkProtocolBgpPeerArgsDict(TypedDict):
        local_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local peer IP address (secondary WAN)
        """
        peer_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Remote peer IP address (secondary WAN)
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        BGP peering secret (secondary WAN)
        """
elif False:
    RemoteNetworkProtocolBgpPeerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNetworkProtocolBgpPeerArgs:
    def __init__(__self__, *,
                 local_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] local_ip_address: Local peer IP address (secondary WAN)
        :param pulumi.Input[_builtins.str] peer_ip_address: Remote peer IP address (secondary WAN)
        :param pulumi.Input[_builtins.str] secret: BGP peering secret (secondary WAN)
        """
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if peer_ip_address is not None:
            pulumi.set(__self__, "peer_ip_address", peer_ip_address)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local peer IP address (secondary WAN)
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="peerIpAddress")
    def peer_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Remote peer IP address (secondary WAN)
        """
        return pulumi.get(self, "peer_ip_address")

    @peer_ip_address.setter
    def peer_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_ip_address", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BGP peering secret (secondary WAN)
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class RouteAccessListTypeArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['RouteAccessListTypeIpv4ArgsDict']]
        """
        Ipv4
        """
elif False:
    RouteAccessListTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['RouteAccessListTypeIpv4Args']] = None):
        """
        :param pulumi.Input['RouteAccessListTypeIpv4Args'] ipv4: Ipv4
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['RouteAccessListTypeIpv4Args']]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['RouteAccessListTypeIpv4Args']]):
        pulumi.set(self, "ipv4", value)


if not MYPY:
    class RouteAccessListTypeIpv4ArgsDict(TypedDict):
        ipv4_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryArgsDict']]]]
        """
        IPv4 access lists
        """
elif False:
    RouteAccessListTypeIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeIpv4Args:
    def __init__(__self__, *,
                 ipv4_entries: Optional[pulumi.Input[Sequence[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryArgs']]] ipv4_entries: IPv4 access lists
        """
        if ipv4_entries is not None:
            pulumi.set(__self__, "ipv4_entries", ipv4_entries)

    @_builtins.property
    @pulumi.getter(name="ipv4Entries")
    def ipv4_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryArgs']]]]:
        """
        IPv4 access lists
        """
        return pulumi.get(self, "ipv4_entries")

    @ipv4_entries.setter
    def ipv4_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryArgs']]]]):
        pulumi.set(self, "ipv4_entries", value)


if not MYPY:
    class RouteAccessListTypeIpv4Ipv4EntryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        destination_address: NotRequired[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgsDict']]
        """
        Destination address
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
        source_address: NotRequired[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgsDict']]
        """
        Source address
        """
elif False:
    RouteAccessListTypeIpv4Ipv4EntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeIpv4Ipv4EntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_address: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 source_address: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgs'] destination_address: Destination address
        :param pulumi.Input[_builtins.int] name: Sequence number
        :param pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgs'] source_address: Source address
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgs']]:
        """
        Destination address
        """
        return pulumi.get(self, "destination_address")

    @destination_address.setter
    def destination_address(self, value: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgs']]):
        pulumi.set(self, "destination_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgs']]:
        """
        Source address
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgs']]):
        pulumi.set(self, "source_address", value)


if not MYPY:
    class RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination IP address
        """
        entry: NotRequired[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgsDict']]
        """
        Entry
        """
elif False:
    RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeIpv4Ipv4EntryDestinationAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 entry: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] address: Destination IP address
        :param pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgs'] entry: Entry
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if entry is not None:
            pulumi.set(__self__, "entry", entry)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination IP address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def entry(self) -> Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgs']]:
        """
        Entry
        """
        return pulumi.get(self, "entry")

    @entry.setter
    def entry(self, value: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgs']]):
        pulumi.set(self, "entry", value)


if not MYPY:
    class RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination IP address
        """
        wildcard: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination IP wildcard
        """
elif False:
    RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeIpv4Ipv4EntryDestinationAddressEntryArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Destination IP address
        :param pulumi.Input[_builtins.str] wildcard: Destination IP wildcard
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination IP address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination IP wildcard
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP address
        """
        entry: NotRequired[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgsDict']]
        """
        Entry
        """
elif False:
    RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeIpv4Ipv4EntrySourceAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 entry: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] address: Source IP address
        :param pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgs'] entry: Entry
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if entry is not None:
            pulumi.set(__self__, "entry", entry)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def entry(self) -> Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgs']]:
        """
        Entry
        """
        return pulumi.get(self, "entry")

    @entry.setter
    def entry(self, value: Optional[pulumi.Input['RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgs']]):
        pulumi.set(self, "entry", value)


if not MYPY:
    class RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP address
        """
        wildcard: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP wildcard
        """
elif False:
    RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteAccessListTypeIpv4Ipv4EntrySourceAddressEntryArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Source IP address
        :param pulumi.Input[_builtins.str] wildcard: Source IP wildcard
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP wildcard
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class RouteCommunityListTypeArgsDict(TypedDict):
        extended: NotRequired[pulumi.Input['RouteCommunityListTypeExtendedArgsDict']]
        """
        Extended
        """
        large: NotRequired[pulumi.Input['RouteCommunityListTypeLargeArgsDict']]
        """
        Large

        >  **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
        """
        regular: NotRequired[pulumi.Input['RouteCommunityListTypeRegularArgsDict']]
        """
        Regular

        >  **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
        """
elif False:
    RouteCommunityListTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeArgs:
    def __init__(__self__, *,
                 extended: Optional[pulumi.Input['RouteCommunityListTypeExtendedArgs']] = None,
                 large: Optional[pulumi.Input['RouteCommunityListTypeLargeArgs']] = None,
                 regular: Optional[pulumi.Input['RouteCommunityListTypeRegularArgs']] = None):
        """
        :param pulumi.Input['RouteCommunityListTypeExtendedArgs'] extended: Extended
        :param pulumi.Input['RouteCommunityListTypeLargeArgs'] large: Large
               
               >  **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
        :param pulumi.Input['RouteCommunityListTypeRegularArgs'] regular: Regular
               
               >  **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
        """
        if extended is not None:
            pulumi.set(__self__, "extended", extended)
        if large is not None:
            pulumi.set(__self__, "large", large)
        if regular is not None:
            pulumi.set(__self__, "regular", regular)

    @_builtins.property
    @pulumi.getter
    def extended(self) -> Optional[pulumi.Input['RouteCommunityListTypeExtendedArgs']]:
        """
        Extended
        """
        return pulumi.get(self, "extended")

    @extended.setter
    def extended(self, value: Optional[pulumi.Input['RouteCommunityListTypeExtendedArgs']]):
        pulumi.set(self, "extended", value)

    @_builtins.property
    @pulumi.getter
    def large(self) -> Optional[pulumi.Input['RouteCommunityListTypeLargeArgs']]:
        """
        Large

        >  **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
        """
        return pulumi.get(self, "large")

    @large.setter
    def large(self, value: Optional[pulumi.Input['RouteCommunityListTypeLargeArgs']]):
        pulumi.set(self, "large", value)

    @_builtins.property
    @pulumi.getter
    def regular(self) -> Optional[pulumi.Input['RouteCommunityListTypeRegularArgs']]:
        """
        Regular

        >  **Note:** You must specify exactly one of `extended`, `large`, and `regular`.
        """
        return pulumi.get(self, "regular")

    @regular.setter
    def regular(self, value: Optional[pulumi.Input['RouteCommunityListTypeRegularArgs']]):
        pulumi.set(self, "regular", value)


if not MYPY:
    class RouteCommunityListTypeExtendedArgsDict(TypedDict):
        extended_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeExtendedExtendedEntryArgsDict']]]]
        """
        Extended community lists
        """
elif False:
    RouteCommunityListTypeExtendedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeExtendedArgs:
    def __init__(__self__, *,
                 extended_entries: Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeExtendedExtendedEntryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeExtendedExtendedEntryArgs']]] extended_entries: Extended community lists
        """
        if extended_entries is not None:
            pulumi.set(__self__, "extended_entries", extended_entries)

    @_builtins.property
    @pulumi.getter(name="extendedEntries")
    def extended_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeExtendedExtendedEntryArgs']]]]:
        """
        Extended community lists
        """
        return pulumi.get(self, "extended_entries")

    @extended_entries.setter
    def extended_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeExtendedExtendedEntryArgs']]]]):
        pulumi.set(self, "extended_entries", value)


if not MYPY:
    class RouteCommunityListTypeExtendedExtendedEntryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        lc_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Extended community regular expression
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
elif False:
    RouteCommunityListTypeExtendedExtendedEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeExtendedExtendedEntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 lc_regexes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] lc_regexes: Extended community regular expression
        :param pulumi.Input[_builtins.int] name: Sequence number
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if lc_regexes is not None:
            pulumi.set(__self__, "lc_regexes", lc_regexes)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="lcRegexes")
    def lc_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Extended community regular expression
        """
        return pulumi.get(self, "lc_regexes")

    @lc_regexes.setter
    def lc_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "lc_regexes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RouteCommunityListTypeLargeArgsDict(TypedDict):
        large_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeLargeLargeEntryArgsDict']]]]
        """
        Large community lists
        """
elif False:
    RouteCommunityListTypeLargeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeLargeArgs:
    def __init__(__self__, *,
                 large_entries: Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeLargeLargeEntryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeLargeLargeEntryArgs']]] large_entries: Large community lists
        """
        if large_entries is not None:
            pulumi.set(__self__, "large_entries", large_entries)

    @_builtins.property
    @pulumi.getter(name="largeEntries")
    def large_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeLargeLargeEntryArgs']]]]:
        """
        Large community lists
        """
        return pulumi.get(self, "large_entries")

    @large_entries.setter
    def large_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeLargeLargeEntryArgs']]]]):
        pulumi.set(self, "large_entries", value)


if not MYPY:
    class RouteCommunityListTypeLargeLargeEntryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        lc_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Large community regular expression
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
elif False:
    RouteCommunityListTypeLargeLargeEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeLargeLargeEntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 lc_regexes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] lc_regexes: Large community regular expression
        :param pulumi.Input[_builtins.int] name: Sequence number
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if lc_regexes is not None:
            pulumi.set(__self__, "lc_regexes", lc_regexes)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="lcRegexes")
    def lc_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Large community regular expression
        """
        return pulumi.get(self, "lc_regexes")

    @lc_regexes.setter
    def lc_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "lc_regexes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RouteCommunityListTypeRegularArgsDict(TypedDict):
        regular_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeRegularRegularEntryArgsDict']]]]
        """
        Regular community lists
        """
elif False:
    RouteCommunityListTypeRegularArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeRegularArgs:
    def __init__(__self__, *,
                 regular_entries: Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeRegularRegularEntryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeRegularRegularEntryArgs']]] regular_entries: Regular community lists
        """
        if regular_entries is not None:
            pulumi.set(__self__, "regular_entries", regular_entries)

    @_builtins.property
    @pulumi.getter(name="regularEntries")
    def regular_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeRegularRegularEntryArgs']]]]:
        """
        Regular community lists
        """
        return pulumi.get(self, "regular_entries")

    @regular_entries.setter
    def regular_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RouteCommunityListTypeRegularRegularEntryArgs']]]]):
        pulumi.set(self, "regular_entries", value)


if not MYPY:
    class RouteCommunityListTypeRegularRegularEntryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Communities
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
elif False:
    RouteCommunityListTypeRegularRegularEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteCommunityListTypeRegularRegularEntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] communities: Communities
        :param pulumi.Input[_builtins.int] name: Sequence number
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Communities
        """
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "communities", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RoutePathAccessListAspathEntryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        aspath_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        AS path regular expression
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
elif False:
    RoutePathAccessListAspathEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePathAccessListAspathEntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 aspath_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.str] aspath_regex: AS path regular expression
        :param pulumi.Input[_builtins.int] name: Sequence number
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if aspath_regex is not None:
            pulumi.set(__self__, "aspath_regex", aspath_regex)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="aspathRegex")
    def aspath_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AS path regular expression
        """
        return pulumi.get(self, "aspath_regex")

    @aspath_regex.setter
    def aspath_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aspath_regex", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RoutePrefixListTypeArgsDict(TypedDict):
        ipv4: pulumi.Input['RoutePrefixListTypeIpv4ArgsDict']
        """
        Ipv4
        """
elif False:
    RoutePrefixListTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePrefixListTypeArgs:
    def __init__(__self__, *,
                 ipv4: pulumi.Input['RoutePrefixListTypeIpv4Args']):
        """
        :param pulumi.Input['RoutePrefixListTypeIpv4Args'] ipv4: Ipv4
        """
        pulumi.set(__self__, "ipv4", ipv4)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input['RoutePrefixListTypeIpv4Args']:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input['RoutePrefixListTypeIpv4Args']):
        pulumi.set(self, "ipv4", value)


if not MYPY:
    class RoutePrefixListTypeIpv4ArgsDict(TypedDict):
        ipv4_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryArgsDict']]]]
        """
        IPv4 prefix lists
        """
elif False:
    RoutePrefixListTypeIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePrefixListTypeIpv4Args:
    def __init__(__self__, *,
                 ipv4_entries: Optional[pulumi.Input[Sequence[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryArgs']]] ipv4_entries: IPv4 prefix lists
        """
        if ipv4_entries is not None:
            pulumi.set(__self__, "ipv4_entries", ipv4_entries)

    @_builtins.property
    @pulumi.getter(name="ipv4Entries")
    def ipv4_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryArgs']]]]:
        """
        IPv4 prefix lists
        """
        return pulumi.get(self, "ipv4_entries")

    @ipv4_entries.setter
    def ipv4_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryArgs']]]]):
        pulumi.set(self, "ipv4_entries", value)


if not MYPY:
    class RoutePrefixListTypeIpv4Ipv4EntryArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        name: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sequence number
        """
        prefix: NotRequired[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixArgsDict']]
        """
        Prefix
        """
elif False:
    RoutePrefixListTypeIpv4Ipv4EntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePrefixListTypeIpv4Ipv4EntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.int] name: Sequence number
        :param pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixArgs'] prefix: Prefix
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sequence number
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixArgs']]:
        """
        Prefix
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixArgs']]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class RoutePrefixListTypeIpv4Ipv4EntryPrefixArgsDict(TypedDict):
        entry: NotRequired[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgsDict']]
        """
        Entry
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network

        >  **Note:** You must specify exactly one of `entry` and `network`.
        """
elif False:
    RoutePrefixListTypeIpv4Ipv4EntryPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePrefixListTypeIpv4Ipv4EntryPrefixArgs:
    def __init__(__self__, *,
                 entry: Optional[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgs']] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgs'] entry: Entry
        :param pulumi.Input[_builtins.str] network: Network
               
               >  **Note:** You must specify exactly one of `entry` and `network`.
        """
        if entry is not None:
            pulumi.set(__self__, "entry", entry)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def entry(self) -> Optional[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgs']]:
        """
        Entry
        """
        return pulumi.get(self, "entry")

    @entry.setter
    def entry(self, value: Optional[pulumi.Input['RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgs']]):
        pulumi.set(self, "entry", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network

        >  **Note:** You must specify exactly one of `entry` and `network`.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)


if not MYPY:
    class RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgsDict(TypedDict):
        greater_than_or_equal: NotRequired[pulumi.Input[_builtins.int]]
        """
        Greater than or equal to
        """
        less_than_or_equal: NotRequired[pulumi.Input[_builtins.int]]
        """
        Less than or equal to
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network
        """
elif False:
    RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePrefixListTypeIpv4Ipv4EntryPrefixEntryArgs:
    def __init__(__self__, *,
                 greater_than_or_equal: Optional[pulumi.Input[_builtins.int]] = None,
                 less_than_or_equal: Optional[pulumi.Input[_builtins.int]] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] greater_than_or_equal: Greater than or equal to
        :param pulumi.Input[_builtins.int] less_than_or_equal: Less than or equal to
        :param pulumi.Input[_builtins.str] network: Network
        """
        if greater_than_or_equal is not None:
            pulumi.set(__self__, "greater_than_or_equal", greater_than_or_equal)
        if less_than_or_equal is not None:
            pulumi.set(__self__, "less_than_or_equal", less_than_or_equal)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter(name="greaterThanOrEqual")
    def greater_than_or_equal(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Greater than or equal to
        """
        return pulumi.get(self, "greater_than_or_equal")

    @greater_than_or_equal.setter
    def greater_than_or_equal(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "greater_than_or_equal", value)

    @_builtins.property
    @pulumi.getter(name="lessThanOrEqual")
    def less_than_or_equal(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Less than or equal to
        """
        return pulumi.get(self, "less_than_or_equal")

    @less_than_or_equal.setter
    def less_than_or_equal(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "less_than_or_equal", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ScepProfileAlgorithmArgsDict(TypedDict):
        rsa: pulumi.Input['ScepProfileAlgorithmRsaArgsDict']
        """
        Key length (bits)
        """
elif False:
    ScepProfileAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScepProfileAlgorithmArgs:
    def __init__(__self__, *,
                 rsa: pulumi.Input['ScepProfileAlgorithmRsaArgs']):
        """
        :param pulumi.Input['ScepProfileAlgorithmRsaArgs'] rsa: Key length (bits)
        """
        pulumi.set(__self__, "rsa", rsa)

    @_builtins.property
    @pulumi.getter
    def rsa(self) -> pulumi.Input['ScepProfileAlgorithmRsaArgs']:
        """
        Key length (bits)
        """
        return pulumi.get(self, "rsa")

    @rsa.setter
    def rsa(self, value: pulumi.Input['ScepProfileAlgorithmRsaArgs']):
        pulumi.set(self, "rsa", value)


if not MYPY:
    class ScepProfileAlgorithmRsaArgsDict(TypedDict):
        rsa_nbits: pulumi.Input[_builtins.str]
        """
        Rsa nbits
        """
elif False:
    ScepProfileAlgorithmRsaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScepProfileAlgorithmRsaArgs:
    def __init__(__self__, *,
                 rsa_nbits: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] rsa_nbits: Rsa nbits
        """
        pulumi.set(__self__, "rsa_nbits", rsa_nbits)

    @_builtins.property
    @pulumi.getter(name="rsaNbits")
    def rsa_nbits(self) -> pulumi.Input[_builtins.str]:
        """
        Rsa nbits
        """
        return pulumi.get(self, "rsa_nbits")

    @rsa_nbits.setter
    def rsa_nbits(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rsa_nbits", value)


if not MYPY:
    class ScepProfileCertificateAttributesArgsDict(TypedDict):
        dnsname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dnsname
        """
        rfc822name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rfc822name

        >  **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniform_resource_identifier`.
        """
        uniform_resource_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Uniform resource identifier

        >  **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniform_resource_identifier`.
        """
elif False:
    ScepProfileCertificateAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScepProfileCertificateAttributesArgs:
    def __init__(__self__, *,
                 dnsname: Optional[pulumi.Input[_builtins.str]] = None,
                 rfc822name: Optional[pulumi.Input[_builtins.str]] = None,
                 uniform_resource_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dnsname: Dnsname
        :param pulumi.Input[_builtins.str] rfc822name: Rfc822name
               
               >  **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniform_resource_identifier`.
        :param pulumi.Input[_builtins.str] uniform_resource_identifier: Uniform resource identifier
               
               >  **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniform_resource_identifier`.
        """
        if dnsname is not None:
            pulumi.set(__self__, "dnsname", dnsname)
        if rfc822name is not None:
            pulumi.set(__self__, "rfc822name", rfc822name)
        if uniform_resource_identifier is not None:
            pulumi.set(__self__, "uniform_resource_identifier", uniform_resource_identifier)

    @_builtins.property
    @pulumi.getter
    def dnsname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dnsname
        """
        return pulumi.get(self, "dnsname")

    @dnsname.setter
    def dnsname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dnsname", value)

    @_builtins.property
    @pulumi.getter
    def rfc822name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rfc822name

        >  **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniform_resource_identifier`.
        """
        return pulumi.get(self, "rfc822name")

    @rfc822name.setter
    def rfc822name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rfc822name", value)

    @_builtins.property
    @pulumi.getter(name="uniformResourceIdentifier")
    def uniform_resource_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Uniform resource identifier

        >  **Note:** You must specify exactly one of `dnsname`, `rfc822name`, and `uniform_resource_identifier`.
        """
        return pulumi.get(self, "uniform_resource_identifier")

    @uniform_resource_identifier.setter
    def uniform_resource_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uniform_resource_identifier", value)


if not MYPY:
    class ScepProfileScepChallengeArgsDict(TypedDict):
        dynamic: NotRequired[pulumi.Input['ScepProfileScepChallengeDynamicArgsDict']]
        """
        Dynamic
        """
        fixed: NotRequired[pulumi.Input[_builtins.str]]
        """
        Challenge to use for SCEP server on mobile clients

        >  **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
        """
        none: NotRequired[pulumi.Input['ScepProfileScepChallengeNoneArgsDict']]
        """
        No OTP

        >  **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
        """
elif False:
    ScepProfileScepChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScepProfileScepChallengeArgs:
    def __init__(__self__, *,
                 dynamic: Optional[pulumi.Input['ScepProfileScepChallengeDynamicArgs']] = None,
                 fixed: Optional[pulumi.Input[_builtins.str]] = None,
                 none: Optional[pulumi.Input['ScepProfileScepChallengeNoneArgs']] = None):
        """
        :param pulumi.Input['ScepProfileScepChallengeDynamicArgs'] dynamic: Dynamic
        :param pulumi.Input[_builtins.str] fixed: Challenge to use for SCEP server on mobile clients
               
               >  **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
        :param pulumi.Input['ScepProfileScepChallengeNoneArgs'] none: No OTP
               
               >  **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
        """
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if fixed is not None:
            pulumi.set(__self__, "fixed", fixed)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input['ScepProfileScepChallengeDynamicArgs']]:
        """
        Dynamic
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input['ScepProfileScepChallengeDynamicArgs']]):
        pulumi.set(self, "dynamic", value)

    @_builtins.property
    @pulumi.getter
    def fixed(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Challenge to use for SCEP server on mobile clients

        >  **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
        """
        return pulumi.get(self, "fixed")

    @fixed.setter
    def fixed(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fixed", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['ScepProfileScepChallengeNoneArgs']]:
        """
        No OTP

        >  **Note:** You must specify exactly one of `dynamic`, `fixed`, and `none`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['ScepProfileScepChallengeNoneArgs']]):
        pulumi.set(self, "none", value)


if not MYPY:
    class ScepProfileScepChallengeDynamicArgsDict(TypedDict):
        otp_server_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        OTP server URL
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        OTP password
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        OTP username
        """
elif False:
    ScepProfileScepChallengeDynamicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScepProfileScepChallengeDynamicArgs:
    def __init__(__self__, *,
                 otp_server_url: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] otp_server_url: OTP server URL
        :param pulumi.Input[_builtins.str] password: OTP password
        :param pulumi.Input[_builtins.str] username: OTP username
        """
        if otp_server_url is not None:
            pulumi.set(__self__, "otp_server_url", otp_server_url)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="otpServerUrl")
    def otp_server_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OTP server URL
        """
        return pulumi.get(self, "otp_server_url")

    @otp_server_url.setter
    def otp_server_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "otp_server_url", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OTP password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OTP username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ScepProfileScepChallengeNoneArgsDict(TypedDict):
        pass
elif False:
    ScepProfileScepChallengeNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScepProfileScepChallengeNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ScheduleScheduleTypeArgsDict(TypedDict):
        non_recurrings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Non recurring
        """
        recurring: NotRequired[pulumi.Input['ScheduleScheduleTypeRecurringArgsDict']]
        """
        Recurring

        >  **Note:** You must specify exactly one of `non_recurring` and `recurring`.
        """
elif False:
    ScheduleScheduleTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleScheduleTypeArgs:
    def __init__(__self__, *,
                 non_recurrings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 recurring: Optional[pulumi.Input['ScheduleScheduleTypeRecurringArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] non_recurrings: Non recurring
        :param pulumi.Input['ScheduleScheduleTypeRecurringArgs'] recurring: Recurring
               
               >  **Note:** You must specify exactly one of `non_recurring` and `recurring`.
        """
        if non_recurrings is not None:
            pulumi.set(__self__, "non_recurrings", non_recurrings)
        if recurring is not None:
            pulumi.set(__self__, "recurring", recurring)

    @_builtins.property
    @pulumi.getter(name="nonRecurrings")
    def non_recurrings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Non recurring
        """
        return pulumi.get(self, "non_recurrings")

    @non_recurrings.setter
    def non_recurrings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "non_recurrings", value)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> Optional[pulumi.Input['ScheduleScheduleTypeRecurringArgs']]:
        """
        Recurring

        >  **Note:** You must specify exactly one of `non_recurring` and `recurring`.
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: Optional[pulumi.Input['ScheduleScheduleTypeRecurringArgs']]):
        pulumi.set(self, "recurring", value)


if not MYPY:
    class ScheduleScheduleTypeRecurringArgsDict(TypedDict):
        dailies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Daily
        """
        weekly: NotRequired[pulumi.Input['ScheduleScheduleTypeRecurringWeeklyArgsDict']]
        """
        Weekly

        >  **Note:** You must specify exactly one of `daily` and `weekly`.
        """
elif False:
    ScheduleScheduleTypeRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleScheduleTypeRecurringArgs:
    def __init__(__self__, *,
                 dailies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 weekly: Optional[pulumi.Input['ScheduleScheduleTypeRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dailies: Daily
        :param pulumi.Input['ScheduleScheduleTypeRecurringWeeklyArgs'] weekly: Weekly
               
               >  **Note:** You must specify exactly one of `daily` and `weekly`.
        """
        if dailies is not None:
            pulumi.set(__self__, "dailies", dailies)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def dailies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Daily
        """
        return pulumi.get(self, "dailies")

    @dailies.setter
    def dailies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dailies", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['ScheduleScheduleTypeRecurringWeeklyArgs']]:
        """
        Weekly

        >  **Note:** You must specify exactly one of `daily` and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['ScheduleScheduleTypeRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class ScheduleScheduleTypeRecurringWeeklyArgsDict(TypedDict):
        fridays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Friday
        """
        mondays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Monday
        """
        saturdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Saturday
        """
        sundays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Sunday
        """
        thursdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Thursday
        """
        tuesdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tuesday
        """
        wednesdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Wednesday
        """
elif False:
    ScheduleScheduleTypeRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleScheduleTypeRecurringWeeklyArgs:
    def __init__(__self__, *,
                 fridays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 mondays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 saturdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sundays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 thursdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tuesdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wednesdays: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] fridays: Friday
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mondays: Monday
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] saturdays: Saturday
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sundays: Sunday
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] thursdays: Thursday
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tuesdays: Tuesday
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wednesdays: Wednesday
        """
        if fridays is not None:
            pulumi.set(__self__, "fridays", fridays)
        if mondays is not None:
            pulumi.set(__self__, "mondays", mondays)
        if saturdays is not None:
            pulumi.set(__self__, "saturdays", saturdays)
        if sundays is not None:
            pulumi.set(__self__, "sundays", sundays)
        if thursdays is not None:
            pulumi.set(__self__, "thursdays", thursdays)
        if tuesdays is not None:
            pulumi.set(__self__, "tuesdays", tuesdays)
        if wednesdays is not None:
            pulumi.set(__self__, "wednesdays", wednesdays)

    @_builtins.property
    @pulumi.getter
    def fridays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Friday
        """
        return pulumi.get(self, "fridays")

    @fridays.setter
    def fridays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "fridays", value)

    @_builtins.property
    @pulumi.getter
    def mondays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Monday
        """
        return pulumi.get(self, "mondays")

    @mondays.setter
    def mondays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mondays", value)

    @_builtins.property
    @pulumi.getter
    def saturdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Saturday
        """
        return pulumi.get(self, "saturdays")

    @saturdays.setter
    def saturdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "saturdays", value)

    @_builtins.property
    @pulumi.getter
    def sundays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Sunday
        """
        return pulumi.get(self, "sundays")

    @sundays.setter
    def sundays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sundays", value)

    @_builtins.property
    @pulumi.getter
    def thursdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Thursday
        """
        return pulumi.get(self, "thursdays")

    @thursdays.setter
    def thursdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "thursdays", value)

    @_builtins.property
    @pulumi.getter
    def tuesdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tuesday
        """
        return pulumi.get(self, "tuesdays")

    @tuesdays.setter
    def tuesdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tuesdays", value)

    @_builtins.property
    @pulumi.getter
    def wednesdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Wednesday
        """
        return pulumi.get(self, "wednesdays")

    @wednesdays.setter
    def wednesdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wednesdays", value)


if not MYPY:
    class SdwanErrorCorrectionProfileModeArgsDict(TypedDict):
        forward_error_correction: NotRequired[pulumi.Input['SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgsDict']]
        """
        Forward error correction
        """
        packet_duplication: NotRequired[pulumi.Input['SdwanErrorCorrectionProfileModePacketDuplicationArgsDict']]
        """
        Packet duplication

        >  **Note:** You must specify exactly one of `forward_error_correction` and `packet_duplication`.
        """
elif False:
    SdwanErrorCorrectionProfileModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanErrorCorrectionProfileModeArgs:
    def __init__(__self__, *,
                 forward_error_correction: Optional[pulumi.Input['SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgs']] = None,
                 packet_duplication: Optional[pulumi.Input['SdwanErrorCorrectionProfileModePacketDuplicationArgs']] = None):
        """
        :param pulumi.Input['SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgs'] forward_error_correction: Forward error correction
        :param pulumi.Input['SdwanErrorCorrectionProfileModePacketDuplicationArgs'] packet_duplication: Packet duplication
               
               >  **Note:** You must specify exactly one of `forward_error_correction` and `packet_duplication`.
        """
        if forward_error_correction is not None:
            pulumi.set(__self__, "forward_error_correction", forward_error_correction)
        if packet_duplication is not None:
            pulumi.set(__self__, "packet_duplication", packet_duplication)

    @_builtins.property
    @pulumi.getter(name="forwardErrorCorrection")
    def forward_error_correction(self) -> Optional[pulumi.Input['SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgs']]:
        """
        Forward error correction
        """
        return pulumi.get(self, "forward_error_correction")

    @forward_error_correction.setter
    def forward_error_correction(self, value: Optional[pulumi.Input['SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgs']]):
        pulumi.set(self, "forward_error_correction", value)

    @_builtins.property
    @pulumi.getter(name="packetDuplication")
    def packet_duplication(self) -> Optional[pulumi.Input['SdwanErrorCorrectionProfileModePacketDuplicationArgs']]:
        """
        Packet duplication

        >  **Note:** You must specify exactly one of `forward_error_correction` and `packet_duplication`.
        """
        return pulumi.get(self, "packet_duplication")

    @packet_duplication.setter
    def packet_duplication(self, value: Optional[pulumi.Input['SdwanErrorCorrectionProfileModePacketDuplicationArgs']]):
        pulumi.set(self, "packet_duplication", value)


if not MYPY:
    class SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgsDict(TypedDict):
        ratio: pulumi.Input[_builtins.str]
        """
        Ratio
        """
        recovery_duration: pulumi.Input[_builtins.int]
        """
        Recovery duration
        """
elif False:
    SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanErrorCorrectionProfileModeForwardErrorCorrectionArgs:
    def __init__(__self__, *,
                 ratio: pulumi.Input[_builtins.str],
                 recovery_duration: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ratio: Ratio
        :param pulumi.Input[_builtins.int] recovery_duration: Recovery duration
        """
        pulumi.set(__self__, "ratio", ratio)
        pulumi.set(__self__, "recovery_duration", recovery_duration)

    @_builtins.property
    @pulumi.getter
    def ratio(self) -> pulumi.Input[_builtins.str]:
        """
        Ratio
        """
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ratio", value)

    @_builtins.property
    @pulumi.getter(name="recoveryDuration")
    def recovery_duration(self) -> pulumi.Input[_builtins.int]:
        """
        Recovery duration
        """
        return pulumi.get(self, "recovery_duration")

    @recovery_duration.setter
    def recovery_duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recovery_duration", value)


if not MYPY:
    class SdwanErrorCorrectionProfileModePacketDuplicationArgsDict(TypedDict):
        recovery_duration_pd: pulumi.Input[_builtins.int]
        """
        Recovery duration pd
        """
elif False:
    SdwanErrorCorrectionProfileModePacketDuplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanErrorCorrectionProfileModePacketDuplicationArgs:
    def __init__(__self__, *,
                 recovery_duration_pd: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] recovery_duration_pd: Recovery duration pd
        """
        pulumi.set(__self__, "recovery_duration_pd", recovery_duration_pd)

    @_builtins.property
    @pulumi.getter(name="recoveryDurationPd")
    def recovery_duration_pd(self) -> pulumi.Input[_builtins.int]:
        """
        Recovery duration pd
        """
        return pulumi.get(self, "recovery_duration_pd")

    @recovery_duration_pd.setter
    def recovery_duration_pd(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recovery_duration_pd", value)


if not MYPY:
    class SdwanPathQualityProfileMetricArgsDict(TypedDict):
        jitter: pulumi.Input['SdwanPathQualityProfileMetricJitterArgsDict']
        """
        Jitter
        """
        latency: pulumi.Input['SdwanPathQualityProfileMetricLatencyArgsDict']
        """
        Latency
        """
        pkt_loss: NotRequired[pulumi.Input['SdwanPathQualityProfileMetricPktLossArgsDict']]
        """
        Pkt loss
        """
elif False:
    SdwanPathQualityProfileMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanPathQualityProfileMetricArgs:
    def __init__(__self__, *,
                 jitter: pulumi.Input['SdwanPathQualityProfileMetricJitterArgs'],
                 latency: pulumi.Input['SdwanPathQualityProfileMetricLatencyArgs'],
                 pkt_loss: Optional[pulumi.Input['SdwanPathQualityProfileMetricPktLossArgs']] = None):
        """
        :param pulumi.Input['SdwanPathQualityProfileMetricJitterArgs'] jitter: Jitter
        :param pulumi.Input['SdwanPathQualityProfileMetricLatencyArgs'] latency: Latency
        :param pulumi.Input['SdwanPathQualityProfileMetricPktLossArgs'] pkt_loss: Pkt loss
        """
        pulumi.set(__self__, "jitter", jitter)
        pulumi.set(__self__, "latency", latency)
        if pkt_loss is not None:
            pulumi.set(__self__, "pkt_loss", pkt_loss)

    @_builtins.property
    @pulumi.getter
    def jitter(self) -> pulumi.Input['SdwanPathQualityProfileMetricJitterArgs']:
        """
        Jitter
        """
        return pulumi.get(self, "jitter")

    @jitter.setter
    def jitter(self, value: pulumi.Input['SdwanPathQualityProfileMetricJitterArgs']):
        pulumi.set(self, "jitter", value)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> pulumi.Input['SdwanPathQualityProfileMetricLatencyArgs']:
        """
        Latency
        """
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: pulumi.Input['SdwanPathQualityProfileMetricLatencyArgs']):
        pulumi.set(self, "latency", value)

    @_builtins.property
    @pulumi.getter(name="pktLoss")
    def pkt_loss(self) -> Optional[pulumi.Input['SdwanPathQualityProfileMetricPktLossArgs']]:
        """
        Pkt loss
        """
        return pulumi.get(self, "pkt_loss")

    @pkt_loss.setter
    def pkt_loss(self, value: Optional[pulumi.Input['SdwanPathQualityProfileMetricPktLossArgs']]):
        pulumi.set(self, "pkt_loss", value)


if not MYPY:
    class SdwanPathQualityProfileMetricJitterArgsDict(TypedDict):
        sensitivity: pulumi.Input[_builtins.str]
        """
        Jitter sensitivity
        """
        threshold: pulumi.Input[_builtins.int]
        """
        Jitter threshold (ms)
        """
elif False:
    SdwanPathQualityProfileMetricJitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanPathQualityProfileMetricJitterArgs:
    def __init__(__self__, *,
                 sensitivity: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] sensitivity: Jitter sensitivity
        :param pulumi.Input[_builtins.int] threshold: Jitter threshold (ms)
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def sensitivity(self) -> pulumi.Input[_builtins.str]:
        """
        Jitter sensitivity
        """
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Jitter threshold (ms)
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SdwanPathQualityProfileMetricLatencyArgsDict(TypedDict):
        sensitivity: pulumi.Input[_builtins.str]
        """
        Latency sensitivity
        """
        threshold: pulumi.Input[_builtins.int]
        """
        Latency threshold (ms)
        """
elif False:
    SdwanPathQualityProfileMetricLatencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanPathQualityProfileMetricLatencyArgs:
    def __init__(__self__, *,
                 sensitivity: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] sensitivity: Latency sensitivity
        :param pulumi.Input[_builtins.int] threshold: Latency threshold (ms)
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def sensitivity(self) -> pulumi.Input[_builtins.str]:
        """
        Latency sensitivity
        """
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Latency threshold (ms)
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SdwanPathQualityProfileMetricPktLossArgsDict(TypedDict):
        sensitivity: pulumi.Input[_builtins.str]
        """
        Packet loss sensitivity
        """
        threshold: pulumi.Input[_builtins.int]
        """
        Packet loss threshold (percentage)
        """
elif False:
    SdwanPathQualityProfileMetricPktLossArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanPathQualityProfileMetricPktLossArgs:
    def __init__(__self__, *,
                 sensitivity: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] sensitivity: Packet loss sensitivity
        :param pulumi.Input[_builtins.int] threshold: Packet loss threshold (percentage)
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def sensitivity(self) -> pulumi.Input[_builtins.str]:
        """
        Packet loss sensitivity
        """
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Packet loss threshold (percentage)
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SdwanRuleActionArgsDict(TypedDict):
        traffic_distribution_profile: pulumi.Input[_builtins.str]
        """
        Traffic dstribution profile
        """
elif False:
    SdwanRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanRuleActionArgs:
    def __init__(__self__, *,
                 traffic_distribution_profile: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] traffic_distribution_profile: Traffic dstribution profile
        """
        pulumi.set(__self__, "traffic_distribution_profile", traffic_distribution_profile)

    @_builtins.property
    @pulumi.getter(name="trafficDistributionProfile")
    def traffic_distribution_profile(self) -> pulumi.Input[_builtins.str]:
        """
        Traffic dstribution profile
        """
        return pulumi.get(self, "traffic_distribution_profile")

    @traffic_distribution_profile.setter
    def traffic_distribution_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "traffic_distribution_profile", value)


if not MYPY:
    class SdwanSaasQualityProfileMonitorModeArgsDict(TypedDict):
        adaptive: NotRequired[pulumi.Input['SdwanSaasQualityProfileMonitorModeAdaptiveArgsDict']]
        """
        Adaptive
        """
        http_https: NotRequired[pulumi.Input['SdwanSaasQualityProfileMonitorModeHttpHttpsArgsDict']]
        """
        Http https

        >  **Note:** You must specify exactly one of `adaptive`, `http_https`, and `static_ip`.
        """
        static_ip: NotRequired[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpArgsDict']]
        """
        Static ip

        >  **Note:** You must specify exactly one of `adaptive`, `http_https`, and `static_ip`.
        """
elif False:
    SdwanSaasQualityProfileMonitorModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanSaasQualityProfileMonitorModeArgs:
    def __init__(__self__, *,
                 adaptive: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeAdaptiveArgs']] = None,
                 http_https: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeHttpHttpsArgs']] = None,
                 static_ip: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpArgs']] = None):
        """
        :param pulumi.Input['SdwanSaasQualityProfileMonitorModeAdaptiveArgs'] adaptive: Adaptive
        :param pulumi.Input['SdwanSaasQualityProfileMonitorModeHttpHttpsArgs'] http_https: Http https
               
               >  **Note:** You must specify exactly one of `adaptive`, `http_https`, and `static_ip`.
        :param pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpArgs'] static_ip: Static ip
               
               >  **Note:** You must specify exactly one of `adaptive`, `http_https`, and `static_ip`.
        """
        if adaptive is not None:
            pulumi.set(__self__, "adaptive", adaptive)
        if http_https is not None:
            pulumi.set(__self__, "http_https", http_https)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)

    @_builtins.property
    @pulumi.getter
    def adaptive(self) -> Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeAdaptiveArgs']]:
        """
        Adaptive
        """
        return pulumi.get(self, "adaptive")

    @adaptive.setter
    def adaptive(self, value: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeAdaptiveArgs']]):
        pulumi.set(self, "adaptive", value)

    @_builtins.property
    @pulumi.getter(name="httpHttps")
    def http_https(self) -> Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeHttpHttpsArgs']]:
        """
        Http https

        >  **Note:** You must specify exactly one of `adaptive`, `http_https`, and `static_ip`.
        """
        return pulumi.get(self, "http_https")

    @http_https.setter
    def http_https(self, value: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeHttpHttpsArgs']]):
        pulumi.set(self, "http_https", value)

    @_builtins.property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpArgs']]:
        """
        Static ip

        >  **Note:** You must specify exactly one of `adaptive`, `http_https`, and `static_ip`.
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpArgs']]):
        pulumi.set(self, "static_ip", value)


if not MYPY:
    class SdwanSaasQualityProfileMonitorModeAdaptiveArgsDict(TypedDict):
        pass
elif False:
    SdwanSaasQualityProfileMonitorModeAdaptiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanSaasQualityProfileMonitorModeAdaptiveArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class SdwanSaasQualityProfileMonitorModeHttpHttpsArgsDict(TypedDict):
        monitored_url: pulumi.Input[_builtins.str]
        """
        Monitored URL
        """
        probe_interval: pulumi.Input[_builtins.int]
        """
        Probe interval (seconds)
        """
elif False:
    SdwanSaasQualityProfileMonitorModeHttpHttpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanSaasQualityProfileMonitorModeHttpHttpsArgs:
    def __init__(__self__, *,
                 monitored_url: pulumi.Input[_builtins.str],
                 probe_interval: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] monitored_url: Monitored URL
        :param pulumi.Input[_builtins.int] probe_interval: Probe interval (seconds)
        """
        pulumi.set(__self__, "monitored_url", monitored_url)
        pulumi.set(__self__, "probe_interval", probe_interval)

    @_builtins.property
    @pulumi.getter(name="monitoredUrl")
    def monitored_url(self) -> pulumi.Input[_builtins.str]:
        """
        Monitored URL
        """
        return pulumi.get(self, "monitored_url")

    @monitored_url.setter
    def monitored_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "monitored_url", value)

    @_builtins.property
    @pulumi.getter(name="probeInterval")
    def probe_interval(self) -> pulumi.Input[_builtins.int]:
        """
        Probe interval (seconds)
        """
        return pulumi.get(self, "probe_interval")

    @probe_interval.setter
    def probe_interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "probe_interval", value)


if not MYPY:
    class SdwanSaasQualityProfileMonitorModeStaticIpArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgsDict']]
        """
        Fqdn
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgsDict']]]]
        """
        List of IP addresses

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
elif False:
    SdwanSaasQualityProfileMonitorModeStaticIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanSaasQualityProfileMonitorModeStaticIpArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgs']] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgs']]]] = None):
        """
        :param pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgs'] fqdn: Fqdn
        :param pulumi.Input[Sequence[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgs']]] ip_addresses: List of IP addresses
               
               >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgs']]:
        """
        Fqdn
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgs']]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgs']]]]:
        """
        List of IP addresses

        >  **Note:** You must specify exactly one of `fqdn` and `ip_address`.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgsDict(TypedDict):
        fqdn_name: pulumi.Input[_builtins.str]
        """
        FQDN
        """
        probe_interval: pulumi.Input[_builtins.int]
        """
        Probe interval (seconds)
        """
elif False:
    SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanSaasQualityProfileMonitorModeStaticIpFqdnArgs:
    def __init__(__self__, *,
                 fqdn_name: pulumi.Input[_builtins.str],
                 probe_interval: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] fqdn_name: FQDN
        :param pulumi.Input[_builtins.int] probe_interval: Probe interval (seconds)
        """
        pulumi.set(__self__, "fqdn_name", fqdn_name)
        pulumi.set(__self__, "probe_interval", probe_interval)

    @_builtins.property
    @pulumi.getter(name="fqdnName")
    def fqdn_name(self) -> pulumi.Input[_builtins.str]:
        """
        FQDN
        """
        return pulumi.get(self, "fqdn_name")

    @fqdn_name.setter
    def fqdn_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fqdn_name", value)

    @_builtins.property
    @pulumi.getter(name="probeInterval")
    def probe_interval(self) -> pulumi.Input[_builtins.int]:
        """
        Probe interval (seconds)
        """
        return pulumi.get(self, "probe_interval")

    @probe_interval.setter
    def probe_interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "probe_interval", value)


if not MYPY:
    class SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        IP address
        """
        probe_interval: pulumi.Input[_builtins.int]
        """
        Probe interval (seconds)
        """
elif False:
    SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanSaasQualityProfileMonitorModeStaticIpIpAddressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 probe_interval: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] name: IP address
        :param pulumi.Input[_builtins.int] probe_interval: Probe interval (seconds)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "probe_interval", probe_interval)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="probeInterval")
    def probe_interval(self) -> pulumi.Input[_builtins.int]:
        """
        Probe interval (seconds)
        """
        return pulumi.get(self, "probe_interval")

    @probe_interval.setter
    def probe_interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "probe_interval", value)


if not MYPY:
    class SdwanTrafficDistributionProfileLinkTagArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Link-Tag used for identifying a set of interfaces
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight (percentage) (only used when `traffic-distribution` is `Weighted Session Distribution`)
        """
elif False:
    SdwanTrafficDistributionProfileLinkTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SdwanTrafficDistributionProfileLinkTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Link-Tag used for identifying a set of interfaces
        :param pulumi.Input[_builtins.int] weight: Weight (percentage) (only used when `traffic-distribution` is `Weighted Session Distribution`)
        """
        pulumi.set(__self__, "name", name)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Link-Tag used for identifying a set of interfaces
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight (percentage) (only used when `traffic-distribution` is `Weighted Session Distribution`)
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class SecurityRuleAllowUrlCategoryArgsDict(TypedDict):
        additional_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional action
        """
        credential_enforcement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Credential enforcement
        """
        decryption: NotRequired[pulumi.Input[_builtins.str]]
        """
        Decryption
        """
        dlp: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dlp
        """
        file_control: NotRequired[pulumi.Input['SecurityRuleAllowUrlCategoryFileControlArgsDict']]
        """
        File control
        """
        isolation_profiles: NotRequired[pulumi.Input[_builtins.str]]
        """
        Isolation profiles
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    SecurityRuleAllowUrlCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowUrlCategoryArgs:
    def __init__(__self__, *,
                 additional_action: Optional[pulumi.Input[_builtins.str]] = None,
                 credential_enforcement: Optional[pulumi.Input[_builtins.str]] = None,
                 decryption: Optional[pulumi.Input[_builtins.str]] = None,
                 dlp: Optional[pulumi.Input[_builtins.str]] = None,
                 file_control: Optional[pulumi.Input['SecurityRuleAllowUrlCategoryFileControlArgs']] = None,
                 isolation_profiles: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] additional_action: Additional action
        :param pulumi.Input[_builtins.str] credential_enforcement: Credential enforcement
        :param pulumi.Input[_builtins.str] decryption: Decryption
        :param pulumi.Input[_builtins.str] dlp: Dlp
        :param pulumi.Input['SecurityRuleAllowUrlCategoryFileControlArgs'] file_control: File control
        :param pulumi.Input[_builtins.str] isolation_profiles: Isolation profiles
        :param pulumi.Input[_builtins.str] name: Name
        """
        if additional_action is not None:
            pulumi.set(__self__, "additional_action", additional_action)
        if credential_enforcement is not None:
            pulumi.set(__self__, "credential_enforcement", credential_enforcement)
        if decryption is not None:
            pulumi.set(__self__, "decryption", decryption)
        if dlp is not None:
            pulumi.set(__self__, "dlp", dlp)
        if file_control is not None:
            pulumi.set(__self__, "file_control", file_control)
        if isolation_profiles is not None:
            pulumi.set(__self__, "isolation_profiles", isolation_profiles)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="additionalAction")
    def additional_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional action
        """
        return pulumi.get(self, "additional_action")

    @additional_action.setter
    def additional_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_action", value)

    @_builtins.property
    @pulumi.getter(name="credentialEnforcement")
    def credential_enforcement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Credential enforcement
        """
        return pulumi.get(self, "credential_enforcement")

    @credential_enforcement.setter
    def credential_enforcement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_enforcement", value)

    @_builtins.property
    @pulumi.getter
    def decryption(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Decryption
        """
        return pulumi.get(self, "decryption")

    @decryption.setter
    def decryption(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "decryption", value)

    @_builtins.property
    @pulumi.getter
    def dlp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dlp
        """
        return pulumi.get(self, "dlp")

    @dlp.setter
    def dlp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dlp", value)

    @_builtins.property
    @pulumi.getter(name="fileControl")
    def file_control(self) -> Optional[pulumi.Input['SecurityRuleAllowUrlCategoryFileControlArgs']]:
        """
        File control
        """
        return pulumi.get(self, "file_control")

    @file_control.setter
    def file_control(self, value: Optional[pulumi.Input['SecurityRuleAllowUrlCategoryFileControlArgs']]):
        pulumi.set(self, "file_control", value)

    @_builtins.property
    @pulumi.getter(name="isolationProfiles")
    def isolation_profiles(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Isolation profiles
        """
        return pulumi.get(self, "isolation_profiles")

    @isolation_profiles.setter
    def isolation_profiles(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "isolation_profiles", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SecurityRuleAllowUrlCategoryFileControlArgsDict(TypedDict):
        download: NotRequired[pulumi.Input[_builtins.str]]
        """
        Download
        """
        upload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Upload
        """
elif False:
    SecurityRuleAllowUrlCategoryFileControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowUrlCategoryFileControlArgs:
    def __init__(__self__, *,
                 download: Optional[pulumi.Input[_builtins.str]] = None,
                 upload: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] download: Download
        :param pulumi.Input[_builtins.str] upload: Upload
        """
        if download is not None:
            pulumi.set(__self__, "download", download)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)

    @_builtins.property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Download
        """
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "download", value)

    @_builtins.property
    @pulumi.getter
    def upload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Upload
        """
        return pulumi.get(self, "upload")

    @upload.setter
    def upload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload", value)


if not MYPY:
    class SecurityRuleAllowWebApplicationArgsDict(TypedDict):
        application_functions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Application function
        """
        dlp: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dlp
        """
        file_control: NotRequired[pulumi.Input['SecurityRuleAllowWebApplicationFileControlArgsDict']]
        """
        File control
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        saas_enterprise_control: NotRequired[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlArgsDict']]
        """
        Saas enterprise control
        """
        saas_tenant_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Saas tenant list
        """
        saas_user_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Saas user list
        """
        tenant_control: NotRequired[pulumi.Input['SecurityRuleAllowWebApplicationTenantControlArgsDict']]
        """
        Tenant control
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type
        """
elif False:
    SecurityRuleAllowWebApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowWebApplicationArgs:
    def __init__(__self__, *,
                 application_functions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dlp: Optional[pulumi.Input[_builtins.str]] = None,
                 file_control: Optional[pulumi.Input['SecurityRuleAllowWebApplicationFileControlArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 saas_enterprise_control: Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlArgs']] = None,
                 saas_tenant_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 saas_user_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tenant_control: Optional[pulumi.Input['SecurityRuleAllowWebApplicationTenantControlArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] application_functions: Application function
        :param pulumi.Input[_builtins.str] dlp: Dlp
        :param pulumi.Input['SecurityRuleAllowWebApplicationFileControlArgs'] file_control: File control
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlArgs'] saas_enterprise_control: Saas enterprise control
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] saas_tenant_lists: Saas tenant list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] saas_user_lists: Saas user list
        :param pulumi.Input['SecurityRuleAllowWebApplicationTenantControlArgs'] tenant_control: Tenant control
        :param pulumi.Input[_builtins.str] type: Type
        """
        if application_functions is not None:
            pulumi.set(__self__, "application_functions", application_functions)
        if dlp is not None:
            pulumi.set(__self__, "dlp", dlp)
        if file_control is not None:
            pulumi.set(__self__, "file_control", file_control)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if saas_enterprise_control is not None:
            pulumi.set(__self__, "saas_enterprise_control", saas_enterprise_control)
        if saas_tenant_lists is not None:
            pulumi.set(__self__, "saas_tenant_lists", saas_tenant_lists)
        if saas_user_lists is not None:
            pulumi.set(__self__, "saas_user_lists", saas_user_lists)
        if tenant_control is not None:
            pulumi.set(__self__, "tenant_control", tenant_control)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="applicationFunctions")
    def application_functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Application function
        """
        return pulumi.get(self, "application_functions")

    @application_functions.setter
    def application_functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "application_functions", value)

    @_builtins.property
    @pulumi.getter
    def dlp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dlp
        """
        return pulumi.get(self, "dlp")

    @dlp.setter
    def dlp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dlp", value)

    @_builtins.property
    @pulumi.getter(name="fileControl")
    def file_control(self) -> Optional[pulumi.Input['SecurityRuleAllowWebApplicationFileControlArgs']]:
        """
        File control
        """
        return pulumi.get(self, "file_control")

    @file_control.setter
    def file_control(self, value: Optional[pulumi.Input['SecurityRuleAllowWebApplicationFileControlArgs']]):
        pulumi.set(self, "file_control", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="saasEnterpriseControl")
    def saas_enterprise_control(self) -> Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlArgs']]:
        """
        Saas enterprise control
        """
        return pulumi.get(self, "saas_enterprise_control")

    @saas_enterprise_control.setter
    def saas_enterprise_control(self, value: Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlArgs']]):
        pulumi.set(self, "saas_enterprise_control", value)

    @_builtins.property
    @pulumi.getter(name="saasTenantLists")
    def saas_tenant_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Saas tenant list
        """
        return pulumi.get(self, "saas_tenant_lists")

    @saas_tenant_lists.setter
    def saas_tenant_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "saas_tenant_lists", value)

    @_builtins.property
    @pulumi.getter(name="saasUserLists")
    def saas_user_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Saas user list
        """
        return pulumi.get(self, "saas_user_lists")

    @saas_user_lists.setter
    def saas_user_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "saas_user_lists", value)

    @_builtins.property
    @pulumi.getter(name="tenantControl")
    def tenant_control(self) -> Optional[pulumi.Input['SecurityRuleAllowWebApplicationTenantControlArgs']]:
        """
        Tenant control
        """
        return pulumi.get(self, "tenant_control")

    @tenant_control.setter
    def tenant_control(self, value: Optional[pulumi.Input['SecurityRuleAllowWebApplicationTenantControlArgs']]):
        pulumi.set(self, "tenant_control", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SecurityRuleAllowWebApplicationFileControlArgsDict(TypedDict):
        download: NotRequired[pulumi.Input[_builtins.str]]
        """
        Download
        """
        upload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Upload
        """
elif False:
    SecurityRuleAllowWebApplicationFileControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowWebApplicationFileControlArgs:
    def __init__(__self__, *,
                 download: Optional[pulumi.Input[_builtins.str]] = None,
                 upload: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] download: Download
        :param pulumi.Input[_builtins.str] upload: Upload
        """
        if download is not None:
            pulumi.set(__self__, "download", download)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)

    @_builtins.property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Download
        """
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "download", value)

    @_builtins.property
    @pulumi.getter
    def upload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Upload
        """
        return pulumi.get(self, "upload")

    @upload.setter
    def upload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload", value)


if not MYPY:
    class SecurityRuleAllowWebApplicationSaasEnterpriseControlArgsDict(TypedDict):
        consumer_access: NotRequired[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgsDict']]
        """
        Consumer access
        """
        enterprise_access: NotRequired[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgsDict']]
        """
        Enterprise access
        """
elif False:
    SecurityRuleAllowWebApplicationSaasEnterpriseControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowWebApplicationSaasEnterpriseControlArgs:
    def __init__(__self__, *,
                 consumer_access: Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgs']] = None,
                 enterprise_access: Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgs']] = None):
        """
        :param pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgs'] consumer_access: Consumer access
        :param pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgs'] enterprise_access: Enterprise access
        """
        if consumer_access is not None:
            pulumi.set(__self__, "consumer_access", consumer_access)
        if enterprise_access is not None:
            pulumi.set(__self__, "enterprise_access", enterprise_access)

    @_builtins.property
    @pulumi.getter(name="consumerAccess")
    def consumer_access(self) -> Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgs']]:
        """
        Consumer access
        """
        return pulumi.get(self, "consumer_access")

    @consumer_access.setter
    def consumer_access(self, value: Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgs']]):
        pulumi.set(self, "consumer_access", value)

    @_builtins.property
    @pulumi.getter(name="enterpriseAccess")
    def enterprise_access(self) -> Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgs']]:
        """
        Enterprise access
        """
        return pulumi.get(self, "enterprise_access")

    @enterprise_access.setter
    def enterprise_access(self, value: Optional[pulumi.Input['SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgs']]):
        pulumi.set(self, "enterprise_access", value)


if not MYPY:
    class SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enable
        """
elif False:
    SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowWebApplicationSaasEnterpriseControlConsumerAccessArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] enable: Enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enable
        """
        tenant_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tenant restrictions
        """
elif False:
    SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowWebApplicationSaasEnterpriseControlEnterpriseAccessArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] enable: Enable
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tenant_restrictions: Tenant restrictions
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if tenant_restrictions is not None:
            pulumi.set(__self__, "tenant_restrictions", tenant_restrictions)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="tenantRestrictions")
    def tenant_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tenant restrictions
        """
        return pulumi.get(self, "tenant_restrictions")

    @tenant_restrictions.setter
    def tenant_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tenant_restrictions", value)


if not MYPY:
    class SecurityRuleAllowWebApplicationTenantControlArgsDict(TypedDict):
        allowed_activities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed activities
        """
        blocked_activities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Blocked activities
        """
        parent_application: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parent application
        """
        tenants: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tenants
        """
elif False:
    SecurityRuleAllowWebApplicationTenantControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleAllowWebApplicationTenantControlArgs:
    def __init__(__self__, *,
                 allowed_activities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 blocked_activities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 parent_application: Optional[pulumi.Input[_builtins.str]] = None,
                 tenants: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_activities: Allowed activities
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] blocked_activities: Blocked activities
        :param pulumi.Input[_builtins.str] parent_application: Parent application
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tenants: Tenants
        """
        if allowed_activities is not None:
            pulumi.set(__self__, "allowed_activities", allowed_activities)
        if blocked_activities is not None:
            pulumi.set(__self__, "blocked_activities", blocked_activities)
        if parent_application is not None:
            pulumi.set(__self__, "parent_application", parent_application)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @_builtins.property
    @pulumi.getter(name="allowedActivities")
    def allowed_activities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed activities
        """
        return pulumi.get(self, "allowed_activities")

    @allowed_activities.setter
    def allowed_activities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_activities", value)

    @_builtins.property
    @pulumi.getter(name="blockedActivities")
    def blocked_activities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Blocked activities
        """
        return pulumi.get(self, "blocked_activities")

    @blocked_activities.setter
    def blocked_activities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "blocked_activities", value)

    @_builtins.property
    @pulumi.getter(name="parentApplication")
    def parent_application(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parent application
        """
        return pulumi.get(self, "parent_application")

    @parent_application.setter
    def parent_application(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_application", value)

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tenants
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tenants", value)


if not MYPY:
    class SecurityRuleDefaultProfileSettingsArgsDict(TypedDict):
        dlp: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dlp
        """
        file_control: NotRequired[pulumi.Input['SecurityRuleDefaultProfileSettingsFileControlArgsDict']]
        """
        File control
        """
elif False:
    SecurityRuleDefaultProfileSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleDefaultProfileSettingsArgs:
    def __init__(__self__, *,
                 dlp: Optional[pulumi.Input[_builtins.str]] = None,
                 file_control: Optional[pulumi.Input['SecurityRuleDefaultProfileSettingsFileControlArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] dlp: Dlp
        :param pulumi.Input['SecurityRuleDefaultProfileSettingsFileControlArgs'] file_control: File control
        """
        if dlp is not None:
            pulumi.set(__self__, "dlp", dlp)
        if file_control is not None:
            pulumi.set(__self__, "file_control", file_control)

    @_builtins.property
    @pulumi.getter
    def dlp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dlp
        """
        return pulumi.get(self, "dlp")

    @dlp.setter
    def dlp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dlp", value)

    @_builtins.property
    @pulumi.getter(name="fileControl")
    def file_control(self) -> Optional[pulumi.Input['SecurityRuleDefaultProfileSettingsFileControlArgs']]:
        """
        File control
        """
        return pulumi.get(self, "file_control")

    @file_control.setter
    def file_control(self, value: Optional[pulumi.Input['SecurityRuleDefaultProfileSettingsFileControlArgs']]):
        pulumi.set(self, "file_control", value)


if not MYPY:
    class SecurityRuleDefaultProfileSettingsFileControlArgsDict(TypedDict):
        download: NotRequired[pulumi.Input[_builtins.str]]
        """
        Download
        """
        upload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Upload
        """
elif False:
    SecurityRuleDefaultProfileSettingsFileControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleDefaultProfileSettingsFileControlArgs:
    def __init__(__self__, *,
                 download: Optional[pulumi.Input[_builtins.str]] = None,
                 upload: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] download: Download
        :param pulumi.Input[_builtins.str] upload: Upload
        """
        if download is not None:
            pulumi.set(__self__, "download", download)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)

    @_builtins.property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Download
        """
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "download", value)

    @_builtins.property
    @pulumi.getter
    def upload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Upload
        """
        return pulumi.get(self, "upload")

    @upload.setter
    def upload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload", value)


if not MYPY:
    class SecurityRuleLogSettingsArgsDict(TypedDict):
        log_sessions: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log sessions
        """
elif False:
    SecurityRuleLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleLogSettingsArgs:
    def __init__(__self__, *,
                 log_sessions: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] log_sessions: Log sessions
        """
        if log_sessions is not None:
            pulumi.set(__self__, "log_sessions", log_sessions)

    @_builtins.property
    @pulumi.getter(name="logSessions")
    def log_sessions(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log sessions
        """
        return pulumi.get(self, "log_sessions")

    @log_sessions.setter
    def log_sessions(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_sessions", value)


if not MYPY:
    class SecurityRuleProfileSettingArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The security profile group
        """
elif False:
    SecurityRuleProfileSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleProfileSettingArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] groups: The security profile group
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The security profile group
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class SecurityRuleSecuritySettingsArgsDict(TypedDict):
        anti_spyware: NotRequired[pulumi.Input[_builtins.str]]
        """
        Anti spyware
        """
        virus_and_wildfire_analysis: NotRequired[pulumi.Input[_builtins.str]]
        """
        Virus and wildfire analysis
        """
        vulnerability: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vulnerability
        """
elif False:
    SecurityRuleSecuritySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityRuleSecuritySettingsArgs:
    def __init__(__self__, *,
                 anti_spyware: Optional[pulumi.Input[_builtins.str]] = None,
                 virus_and_wildfire_analysis: Optional[pulumi.Input[_builtins.str]] = None,
                 vulnerability: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] anti_spyware: Anti spyware
        :param pulumi.Input[_builtins.str] virus_and_wildfire_analysis: Virus and wildfire analysis
        :param pulumi.Input[_builtins.str] vulnerability: Vulnerability
        """
        if anti_spyware is not None:
            pulumi.set(__self__, "anti_spyware", anti_spyware)
        if virus_and_wildfire_analysis is not None:
            pulumi.set(__self__, "virus_and_wildfire_analysis", virus_and_wildfire_analysis)
        if vulnerability is not None:
            pulumi.set(__self__, "vulnerability", vulnerability)

    @_builtins.property
    @pulumi.getter(name="antiSpyware")
    def anti_spyware(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Anti spyware
        """
        return pulumi.get(self, "anti_spyware")

    @anti_spyware.setter
    def anti_spyware(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "anti_spyware", value)

    @_builtins.property
    @pulumi.getter(name="virusAndWildfireAnalysis")
    def virus_and_wildfire_analysis(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Virus and wildfire analysis
        """
        return pulumi.get(self, "virus_and_wildfire_analysis")

    @virus_and_wildfire_analysis.setter
    def virus_and_wildfire_analysis(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virus_and_wildfire_analysis", value)

    @_builtins.property
    @pulumi.getter
    def vulnerability(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vulnerability
        """
        return pulumi.get(self, "vulnerability")

    @vulnerability.setter
    def vulnerability(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vulnerability", value)


if not MYPY:
    class ServiceConnectionBgpPeerArgsDict(TypedDict):
        local_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local ip address
        """
        local_ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local ipv6 address
        """
        peer_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer ip address
        """
        peer_ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer ipv6 address
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret
        """
elif False:
    ServiceConnectionBgpPeerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionBgpPeerArgs:
    def __init__(__self__, *,
                 local_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 local_ipv6_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_ipv6_address: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] local_ip_address: Local ip address
        :param pulumi.Input[_builtins.str] local_ipv6_address: Local ipv6 address
        :param pulumi.Input[_builtins.str] peer_ip_address: Peer ip address
        :param pulumi.Input[_builtins.str] peer_ipv6_address: Peer ipv6 address
        :param pulumi.Input[_builtins.str] secret: Secret
        """
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if local_ipv6_address is not None:
            pulumi.set(__self__, "local_ipv6_address", local_ipv6_address)
        if peer_ip_address is not None:
            pulumi.set(__self__, "peer_ip_address", peer_ip_address)
        if peer_ipv6_address is not None:
            pulumi.set(__self__, "peer_ipv6_address", peer_ipv6_address)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local ip address
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="localIpv6Address")
    def local_ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local ipv6 address
        """
        return pulumi.get(self, "local_ipv6_address")

    @local_ipv6_address.setter
    def local_ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ipv6_address", value)

    @_builtins.property
    @pulumi.getter(name="peerIpAddress")
    def peer_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer ip address
        """
        return pulumi.get(self, "peer_ip_address")

    @peer_ip_address.setter
    def peer_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="peerIpv6Address")
    def peer_ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer ipv6 address
        """
        return pulumi.get(self, "peer_ipv6_address")

    @peer_ipv6_address.setter
    def peer_ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_ipv6_address", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ServiceConnectionProtocolArgsDict(TypedDict):
        bgp: NotRequired[pulumi.Input['ServiceConnectionProtocolBgpArgsDict']]
        """
        Bgp
        """
elif False:
    ServiceConnectionProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionProtocolArgs:
    def __init__(__self__, *,
                 bgp: Optional[pulumi.Input['ServiceConnectionProtocolBgpArgs']] = None):
        """
        :param pulumi.Input['ServiceConnectionProtocolBgpArgs'] bgp: Bgp
        """
        if bgp is not None:
            pulumi.set(__self__, "bgp", bgp)

    @_builtins.property
    @pulumi.getter
    def bgp(self) -> Optional[pulumi.Input['ServiceConnectionProtocolBgpArgs']]:
        """
        Bgp
        """
        return pulumi.get(self, "bgp")

    @bgp.setter
    def bgp(self, value: Optional[pulumi.Input['ServiceConnectionProtocolBgpArgs']]):
        pulumi.set(self, "bgp", value)


if not MYPY:
    class ServiceConnectionProtocolBgpArgsDict(TypedDict):
        peer_as: pulumi.Input[_builtins.str]
        """
        Peer as
        """
        do_not_export_routes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not export routes
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        fast_failover: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Fast failover
        """
        local_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Local ip address
        """
        originate_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Originate default route
        """
        peer_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Peer ip address
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret
        """
        summarize_mobile_user_routes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Summarize mobile user routes
        """
elif False:
    ServiceConnectionProtocolBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionProtocolBgpArgs:
    def __init__(__self__, *,
                 peer_as: pulumi.Input[_builtins.str],
                 do_not_export_routes: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 fast_failover: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 originate_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 peer_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 summarize_mobile_user_routes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] peer_as: Peer as
        :param pulumi.Input[_builtins.bool] do_not_export_routes: Do not export routes
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.bool] fast_failover: Fast failover
        :param pulumi.Input[_builtins.str] local_ip_address: Local ip address
        :param pulumi.Input[_builtins.bool] originate_default_route: Originate default route
        :param pulumi.Input[_builtins.str] peer_ip_address: Peer ip address
        :param pulumi.Input[_builtins.str] secret: Secret
        :param pulumi.Input[_builtins.bool] summarize_mobile_user_routes: Summarize mobile user routes
        """
        pulumi.set(__self__, "peer_as", peer_as)
        if do_not_export_routes is not None:
            pulumi.set(__self__, "do_not_export_routes", do_not_export_routes)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if fast_failover is not None:
            pulumi.set(__self__, "fast_failover", fast_failover)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if originate_default_route is not None:
            pulumi.set(__self__, "originate_default_route", originate_default_route)
        if peer_ip_address is not None:
            pulumi.set(__self__, "peer_ip_address", peer_ip_address)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if summarize_mobile_user_routes is not None:
            pulumi.set(__self__, "summarize_mobile_user_routes", summarize_mobile_user_routes)

    @_builtins.property
    @pulumi.getter(name="peerAs")
    def peer_as(self) -> pulumi.Input[_builtins.str]:
        """
        Peer as
        """
        return pulumi.get(self, "peer_as")

    @peer_as.setter
    def peer_as(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "peer_as", value)

    @_builtins.property
    @pulumi.getter(name="doNotExportRoutes")
    def do_not_export_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not export routes
        """
        return pulumi.get(self, "do_not_export_routes")

    @do_not_export_routes.setter
    def do_not_export_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "do_not_export_routes", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="fastFailover")
    def fast_failover(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Fast failover
        """
        return pulumi.get(self, "fast_failover")

    @fast_failover.setter
    def fast_failover(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fast_failover", value)

    @_builtins.property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Local ip address
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="originateDefaultRoute")
    def originate_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Originate default route
        """
        return pulumi.get(self, "originate_default_route")

    @originate_default_route.setter
    def originate_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "originate_default_route", value)

    @_builtins.property
    @pulumi.getter(name="peerIpAddress")
    def peer_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Peer ip address
        """
        return pulumi.get(self, "peer_ip_address")

    @peer_ip_address.setter
    def peer_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_ip_address", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="summarizeMobileUserRoutes")
    def summarize_mobile_user_routes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Summarize mobile user routes
        """
        return pulumi.get(self, "summarize_mobile_user_routes")

    @summarize_mobile_user_routes.setter
    def summarize_mobile_user_routes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "summarize_mobile_user_routes", value)


if not MYPY:
    class ServiceConnectionQosArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        qos_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Qos profile
        """
elif False:
    ServiceConnectionQosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionQosArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 qos_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] qos_profile: Qos profile
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if qos_profile is not None:
            pulumi.set(__self__, "qos_profile", qos_profile)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="qosProfile")
    def qos_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Qos profile
        """
        return pulumi.get(self, "qos_profile")

    @qos_profile.setter
    def qos_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "qos_profile", value)


if not MYPY:
    class ServiceProtocolArgsDict(TypedDict):
        tcp: NotRequired[pulumi.Input['ServiceProtocolTcpArgsDict']]
        """
        Tcp
        """
        udp: NotRequired[pulumi.Input['ServiceProtocolUdpArgsDict']]
        """
        Udp

        >  **Note:** You must specify exactly one of `tcp` and `udp`.
        """
elif False:
    ServiceProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProtocolArgs:
    def __init__(__self__, *,
                 tcp: Optional[pulumi.Input['ServiceProtocolTcpArgs']] = None,
                 udp: Optional[pulumi.Input['ServiceProtocolUdpArgs']] = None):
        """
        :param pulumi.Input['ServiceProtocolTcpArgs'] tcp: Tcp
        :param pulumi.Input['ServiceProtocolUdpArgs'] udp: Udp
               
               >  **Note:** You must specify exactly one of `tcp` and `udp`.
        """
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['ServiceProtocolTcpArgs']]:
        """
        Tcp
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['ServiceProtocolTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['ServiceProtocolUdpArgs']]:
        """
        Udp

        >  **Note:** You must specify exactly one of `tcp` and `udp`.
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['ServiceProtocolUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class ServiceProtocolTcpArgsDict(TypedDict):
        port: pulumi.Input[_builtins.str]
        """
        Port
        """
        override: NotRequired[pulumi.Input['ServiceProtocolTcpOverrideArgsDict']]
        """
        Override
        """
        source_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source port
        """
elif False:
    ServiceProtocolTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProtocolTcpArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.str],
                 override: Optional[pulumi.Input['ServiceProtocolTcpOverrideArgs']] = None,
                 source_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] port: Port
        :param pulumi.Input['ServiceProtocolTcpOverrideArgs'] override: Override
        :param pulumi.Input[_builtins.str] source_port: Source port
        """
        pulumi.set(__self__, "port", port)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.str]:
        """
        Port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['ServiceProtocolTcpOverrideArgs']]:
        """
        Override
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['ServiceProtocolTcpOverrideArgs']]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source port
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class ServiceProtocolTcpOverrideArgsDict(TypedDict):
        halfclose_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        tcp session half-close timeout value (in second)
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        tcp session timeout value (in second)
        """
        timewait_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        tcp session time-wait timeout value (in second)
        """
elif False:
    ServiceProtocolTcpOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProtocolTcpOverrideArgs:
    def __init__(__self__, *,
                 halfclose_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 timewait_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] halfclose_timeout: tcp session half-close timeout value (in second)
        :param pulumi.Input[_builtins.int] timeout: tcp session timeout value (in second)
        :param pulumi.Input[_builtins.int] timewait_timeout: tcp session time-wait timeout value (in second)
        """
        if halfclose_timeout is not None:
            pulumi.set(__self__, "halfclose_timeout", halfclose_timeout)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if timewait_timeout is not None:
            pulumi.set(__self__, "timewait_timeout", timewait_timeout)

    @_builtins.property
    @pulumi.getter(name="halfcloseTimeout")
    def halfclose_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        tcp session half-close timeout value (in second)
        """
        return pulumi.get(self, "halfclose_timeout")

    @halfclose_timeout.setter
    def halfclose_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "halfclose_timeout", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        tcp session timeout value (in second)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="timewaitTimeout")
    def timewait_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        tcp session time-wait timeout value (in second)
        """
        return pulumi.get(self, "timewait_timeout")

    @timewait_timeout.setter
    def timewait_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timewait_timeout", value)


if not MYPY:
    class ServiceProtocolUdpArgsDict(TypedDict):
        port: pulumi.Input[_builtins.str]
        """
        Port
        """
        override: NotRequired[pulumi.Input['ServiceProtocolUdpOverrideArgsDict']]
        """
        Override
        """
        source_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source port
        """
elif False:
    ServiceProtocolUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProtocolUdpArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.str],
                 override: Optional[pulumi.Input['ServiceProtocolUdpOverrideArgs']] = None,
                 source_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] port: Port
        :param pulumi.Input['ServiceProtocolUdpOverrideArgs'] override: Override
        :param pulumi.Input[_builtins.str] source_port: Source port
        """
        pulumi.set(__self__, "port", port)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.str]:
        """
        Port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['ServiceProtocolUdpOverrideArgs']]:
        """
        Override
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['ServiceProtocolUdpOverrideArgs']]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source port
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class ServiceProtocolUdpOverrideArgsDict(TypedDict):
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        udp session timeout value (in second)
        """
elif False:
    ServiceProtocolUdpOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceProtocolUdpOverrideArgs:
    def __init__(__self__, *,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] timeout: udp session timeout value (in second)
        """
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        udp session timeout value (in second)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ServiceRouteRouteArgsDict(TypedDict):
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteDestinationArgsDict']]]]
        """
        Destination
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteServiceArgsDict']]]]
        """
        Service
        """
elif False:
    ServiceRouteRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRouteRouteArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteDestinationArgs']]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteServiceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteDestinationArgs']]] destinations: Destination
        :param pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteServiceArgs']]] services: Service
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteDestinationArgs']]]]:
        """
        Destination
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteServiceArgs']]]]:
        """
        Service
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceRouteRouteServiceArgs']]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class ServiceRouteRouteDestinationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        source: NotRequired[pulumi.Input['ServiceRouteRouteDestinationSourceArgsDict']]
        """
        Source
        """
elif False:
    ServiceRouteRouteDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRouteRouteDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ServiceRouteRouteDestinationSourceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['ServiceRouteRouteDestinationSourceArgs'] source: Source
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ServiceRouteRouteDestinationSourceArgs']]:
        """
        Source
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ServiceRouteRouteDestinationSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ServiceRouteRouteDestinationSourceArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
elif False:
    ServiceRouteRouteDestinationSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRouteRouteDestinationSourceArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[_builtins.str] interface: Interface
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)


if not MYPY:
    class ServiceRouteRouteServiceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The follow list details the accepted `name` values and their corresponding service description.
        """
        source: NotRequired[pulumi.Input['ServiceRouteRouteServiceSourceArgsDict']]
        """
        Source
        """
        source_v6: NotRequired[pulumi.Input['ServiceRouteRouteServiceSourceV6ArgsDict']]
        """
        Source v6
        """
elif False:
    ServiceRouteRouteServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRouteRouteServiceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ServiceRouteRouteServiceSourceArgs']] = None,
                 source_v6: Optional[pulumi.Input['ServiceRouteRouteServiceSourceV6Args']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The follow list details the accepted `name` values and their corresponding service description.
        :param pulumi.Input['ServiceRouteRouteServiceSourceArgs'] source: Source
        :param pulumi.Input['ServiceRouteRouteServiceSourceV6Args'] source_v6: Source v6
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_v6 is not None:
            pulumi.set(__self__, "source_v6", source_v6)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The follow list details the accepted `name` values and their corresponding service description.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ServiceRouteRouteServiceSourceArgs']]:
        """
        Source
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ServiceRouteRouteServiceSourceArgs']]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="sourceV6")
    def source_v6(self) -> Optional[pulumi.Input['ServiceRouteRouteServiceSourceV6Args']]:
        """
        Source v6
        """
        return pulumi.get(self, "source_v6")

    @source_v6.setter
    def source_v6(self, value: Optional[pulumi.Input['ServiceRouteRouteServiceSourceV6Args']]):
        pulumi.set(self, "source_v6", value)


if not MYPY:
    class ServiceRouteRouteServiceSourceArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
elif False:
    ServiceRouteRouteServiceSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRouteRouteServiceSourceArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[_builtins.str] interface: Interface
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)


if not MYPY:
    class ServiceRouteRouteServiceSourceV6ArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface
        """
elif False:
    ServiceRouteRouteServiceSourceV6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRouteRouteServiceSourceV6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Address
        :param pulumi.Input[_builtins.str] interface: Interface
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)


if not MYPY:
    class ServiceSettingServicesArgsDict(TypedDict):
        dns_setting: NotRequired[pulumi.Input['ServiceSettingServicesDnsSettingArgsDict']]
        """
        Dns setting
        """
        fqdn_refresh_time: NotRequired[pulumi.Input[_builtins.float]]
        """
        Fqdn refresh time
        """
        fqdn_stale_entry_timeout: NotRequired[pulumi.Input[_builtins.float]]
        """
        Fqdn stale entry timeout
        """
        inline_cloud_proxy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Inline cloud proxy
        """
        lcaas_use_proxy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Lcaas use proxy
        """
        ntp_servers: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersArgsDict']]
        """
        Ntp servers
        """
        secure_proxy_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secure proxy password
        """
        secure_proxy_port: NotRequired[pulumi.Input[_builtins.float]]
        """
        Secure proxy port
        """
        secure_proxy_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secure proxy server
        """
        secure_proxy_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secure proxy user
        """
        server_verification: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Server verification
        """
        update_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        Update server
        """
elif False:
    ServiceSettingServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesArgs:
    def __init__(__self__, *,
                 dns_setting: Optional[pulumi.Input['ServiceSettingServicesDnsSettingArgs']] = None,
                 fqdn_refresh_time: Optional[pulumi.Input[_builtins.float]] = None,
                 fqdn_stale_entry_timeout: Optional[pulumi.Input[_builtins.float]] = None,
                 inline_cloud_proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 lcaas_use_proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 ntp_servers: Optional[pulumi.Input['ServiceSettingServicesNtpServersArgs']] = None,
                 secure_proxy_password: Optional[pulumi.Input[_builtins.str]] = None,
                 secure_proxy_port: Optional[pulumi.Input[_builtins.float]] = None,
                 secure_proxy_server: Optional[pulumi.Input[_builtins.str]] = None,
                 secure_proxy_user: Optional[pulumi.Input[_builtins.str]] = None,
                 server_verification: Optional[pulumi.Input[_builtins.bool]] = None,
                 update_server: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ServiceSettingServicesDnsSettingArgs'] dns_setting: Dns setting
        :param pulumi.Input[_builtins.float] fqdn_refresh_time: Fqdn refresh time
        :param pulumi.Input[_builtins.float] fqdn_stale_entry_timeout: Fqdn stale entry timeout
        :param pulumi.Input[_builtins.bool] inline_cloud_proxy: Inline cloud proxy
        :param pulumi.Input[_builtins.bool] lcaas_use_proxy: Lcaas use proxy
        :param pulumi.Input['ServiceSettingServicesNtpServersArgs'] ntp_servers: Ntp servers
        :param pulumi.Input[_builtins.str] secure_proxy_password: Secure proxy password
        :param pulumi.Input[_builtins.float] secure_proxy_port: Secure proxy port
        :param pulumi.Input[_builtins.str] secure_proxy_server: Secure proxy server
        :param pulumi.Input[_builtins.str] secure_proxy_user: Secure proxy user
        :param pulumi.Input[_builtins.bool] server_verification: Server verification
        :param pulumi.Input[_builtins.str] update_server: Update server
        """
        if dns_setting is not None:
            pulumi.set(__self__, "dns_setting", dns_setting)
        if fqdn_refresh_time is not None:
            pulumi.set(__self__, "fqdn_refresh_time", fqdn_refresh_time)
        if fqdn_stale_entry_timeout is not None:
            pulumi.set(__self__, "fqdn_stale_entry_timeout", fqdn_stale_entry_timeout)
        if inline_cloud_proxy is not None:
            pulumi.set(__self__, "inline_cloud_proxy", inline_cloud_proxy)
        if lcaas_use_proxy is not None:
            pulumi.set(__self__, "lcaas_use_proxy", lcaas_use_proxy)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)
        if secure_proxy_password is not None:
            pulumi.set(__self__, "secure_proxy_password", secure_proxy_password)
        if secure_proxy_port is not None:
            pulumi.set(__self__, "secure_proxy_port", secure_proxy_port)
        if secure_proxy_server is not None:
            pulumi.set(__self__, "secure_proxy_server", secure_proxy_server)
        if secure_proxy_user is not None:
            pulumi.set(__self__, "secure_proxy_user", secure_proxy_user)
        if server_verification is not None:
            pulumi.set(__self__, "server_verification", server_verification)
        if update_server is not None:
            pulumi.set(__self__, "update_server", update_server)

    @_builtins.property
    @pulumi.getter(name="dnsSetting")
    def dns_setting(self) -> Optional[pulumi.Input['ServiceSettingServicesDnsSettingArgs']]:
        """
        Dns setting
        """
        return pulumi.get(self, "dns_setting")

    @dns_setting.setter
    def dns_setting(self, value: Optional[pulumi.Input['ServiceSettingServicesDnsSettingArgs']]):
        pulumi.set(self, "dns_setting", value)

    @_builtins.property
    @pulumi.getter(name="fqdnRefreshTime")
    def fqdn_refresh_time(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Fqdn refresh time
        """
        return pulumi.get(self, "fqdn_refresh_time")

    @fqdn_refresh_time.setter
    def fqdn_refresh_time(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fqdn_refresh_time", value)

    @_builtins.property
    @pulumi.getter(name="fqdnStaleEntryTimeout")
    def fqdn_stale_entry_timeout(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Fqdn stale entry timeout
        """
        return pulumi.get(self, "fqdn_stale_entry_timeout")

    @fqdn_stale_entry_timeout.setter
    def fqdn_stale_entry_timeout(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fqdn_stale_entry_timeout", value)

    @_builtins.property
    @pulumi.getter(name="inlineCloudProxy")
    def inline_cloud_proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Inline cloud proxy
        """
        return pulumi.get(self, "inline_cloud_proxy")

    @inline_cloud_proxy.setter
    def inline_cloud_proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "inline_cloud_proxy", value)

    @_builtins.property
    @pulumi.getter(name="lcaasUseProxy")
    def lcaas_use_proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Lcaas use proxy
        """
        return pulumi.get(self, "lcaas_use_proxy")

    @lcaas_use_proxy.setter
    def lcaas_use_proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lcaas_use_proxy", value)

    @_builtins.property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersArgs']]:
        """
        Ntp servers
        """
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersArgs']]):
        pulumi.set(self, "ntp_servers", value)

    @_builtins.property
    @pulumi.getter(name="secureProxyPassword")
    def secure_proxy_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secure proxy password
        """
        return pulumi.get(self, "secure_proxy_password")

    @secure_proxy_password.setter
    def secure_proxy_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure_proxy_password", value)

    @_builtins.property
    @pulumi.getter(name="secureProxyPort")
    def secure_proxy_port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Secure proxy port
        """
        return pulumi.get(self, "secure_proxy_port")

    @secure_proxy_port.setter
    def secure_proxy_port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "secure_proxy_port", value)

    @_builtins.property
    @pulumi.getter(name="secureProxyServer")
    def secure_proxy_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secure proxy server
        """
        return pulumi.get(self, "secure_proxy_server")

    @secure_proxy_server.setter
    def secure_proxy_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure_proxy_server", value)

    @_builtins.property
    @pulumi.getter(name="secureProxyUser")
    def secure_proxy_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secure proxy user
        """
        return pulumi.get(self, "secure_proxy_user")

    @secure_proxy_user.setter
    def secure_proxy_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure_proxy_user", value)

    @_builtins.property
    @pulumi.getter(name="serverVerification")
    def server_verification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Server verification
        """
        return pulumi.get(self, "server_verification")

    @server_verification.setter
    def server_verification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_verification", value)

    @_builtins.property
    @pulumi.getter(name="updateServer")
    def update_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Update server
        """
        return pulumi.get(self, "update_server")

    @update_server.setter
    def update_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_server", value)


if not MYPY:
    class ServiceSettingServicesDnsSettingArgsDict(TypedDict):
        dns_proxy_object: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dns proxy object
        """
        servers: NotRequired[pulumi.Input['ServiceSettingServicesDnsSettingServersArgsDict']]
        """
        Servers

        >  **Note:** You must specify exactly one of `dns_proxy_object` and `servers`.
        """
elif False:
    ServiceSettingServicesDnsSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesDnsSettingArgs:
    def __init__(__self__, *,
                 dns_proxy_object: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input['ServiceSettingServicesDnsSettingServersArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] dns_proxy_object: Dns proxy object
        :param pulumi.Input['ServiceSettingServicesDnsSettingServersArgs'] servers: Servers
               
               >  **Note:** You must specify exactly one of `dns_proxy_object` and `servers`.
        """
        if dns_proxy_object is not None:
            pulumi.set(__self__, "dns_proxy_object", dns_proxy_object)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter(name="dnsProxyObject")
    def dns_proxy_object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dns proxy object
        """
        return pulumi.get(self, "dns_proxy_object")

    @dns_proxy_object.setter
    def dns_proxy_object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_proxy_object", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input['ServiceSettingServicesDnsSettingServersArgs']]:
        """
        Servers

        >  **Note:** You must specify exactly one of `dns_proxy_object` and `servers`.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input['ServiceSettingServicesDnsSettingServersArgs']]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class ServiceSettingServicesDnsSettingServersArgsDict(TypedDict):
        primary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary
        """
        secondary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary
        """
elif False:
    ServiceSettingServicesDnsSettingServersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesDnsSettingServersArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] primary: Primary
        :param pulumi.Input[_builtins.str] secondary: Secondary
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class ServiceSettingServicesNtpServersArgsDict(TypedDict):
        primary_ntp_server: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerArgsDict']]
        """
        Primary ntp server
        """
        secondary_ntp_server: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerArgsDict']]
        """
        Secondary ntp server
        """
elif False:
    ServiceSettingServicesNtpServersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersArgs:
    def __init__(__self__, *,
                 primary_ntp_server: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerArgs']] = None,
                 secondary_ntp_server: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerArgs']] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerArgs'] primary_ntp_server: Primary ntp server
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerArgs'] secondary_ntp_server: Secondary ntp server
        """
        if primary_ntp_server is not None:
            pulumi.set(__self__, "primary_ntp_server", primary_ntp_server)
        if secondary_ntp_server is not None:
            pulumi.set(__self__, "secondary_ntp_server", secondary_ntp_server)

    @_builtins.property
    @pulumi.getter(name="primaryNtpServer")
    def primary_ntp_server(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerArgs']]:
        """
        Primary ntp server
        """
        return pulumi.get(self, "primary_ntp_server")

    @primary_ntp_server.setter
    def primary_ntp_server(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerArgs']]):
        pulumi.set(self, "primary_ntp_server", value)

    @_builtins.property
    @pulumi.getter(name="secondaryNtpServer")
    def secondary_ntp_server(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerArgs']]:
        """
        Secondary ntp server
        """
        return pulumi.get(self, "secondary_ntp_server")

    @secondary_ntp_server.setter
    def secondary_ntp_server(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerArgs']]):
        pulumi.set(self, "secondary_ntp_server", value)


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerArgsDict(TypedDict):
        authentication_type: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgsDict']]
        """
        Authentication type
        """
        ntp_server_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ntp server address
        """
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerArgs:
    def __init__(__self__, *,
                 authentication_type: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgs']] = None,
                 ntp_server_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgs'] authentication_type: Authentication type
        :param pulumi.Input[_builtins.str] ntp_server_address: Ntp server address
        """
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if ntp_server_address is not None:
            pulumi.set(__self__, "ntp_server_address", ntp_server_address)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgs']]:
        """
        Authentication type
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgs']]):
        pulumi.set(self, "authentication_type", value)

    @_builtins.property
    @pulumi.getter(name="ntpServerAddress")
    def ntp_server_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ntp server address
        """
        return pulumi.get(self, "ntp_server_address")

    @ntp_server_address.setter
    def ntp_server_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ntp_server_address", value)


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgsDict(TypedDict):
        autokey: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgsDict']]
        """
        Autokey
        """
        none: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        symmetric_key: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgsDict']]
        """
        Symmetric key

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeArgs:
    def __init__(__self__, *,
                 autokey: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgs']] = None,
                 none: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgs']] = None,
                 symmetric_key: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgs']] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgs'] autokey: Autokey
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgs'] symmetric_key: Symmetric key
               
               >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        if autokey is not None:
            pulumi.set(__self__, "autokey", autokey)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if symmetric_key is not None:
            pulumi.set(__self__, "symmetric_key", symmetric_key)

    @_builtins.property
    @pulumi.getter
    def autokey(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgs']]:
        """
        Autokey
        """
        return pulumi.get(self, "autokey")

    @autokey.setter
    def autokey(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgs']]):
        pulumi.set(self, "autokey", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter(name="symmetricKey")
    def symmetric_key(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgs']]:
        """
        Symmetric key

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        return pulumi.get(self, "symmetric_key")

    @symmetric_key.setter
    def symmetric_key(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgs']]):
        pulumi.set(self, "symmetric_key", value)


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgsDict(TypedDict):
        pass
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeAutokeyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgsDict(TypedDict):
        pass
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict']]
        """
        Algorithm
        """
        key_id: NotRequired[pulumi.Input[_builtins.float]]
        """
        Key id
        """
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs']] = None,
                 key_id: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs'] algorithm: Algorithm
        :param pulumi.Input[_builtins.float] key_id: Key id
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs']]:
        """
        Algorithm
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Key id
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict(TypedDict):
        md5: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict']]
        """
        Md5
        """
        sha1: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict']]
        """
        Sha1
        """
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs:
    def __init__(__self__, *,
                 md5: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args']] = None,
                 sha1: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args']] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args'] md5: Md5
        :param pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args'] sha1: Sha1
        """
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args']]:
        """
        Md5
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args']]):
        pulumi.set(self, "md5", value)

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args']]:
        """
        Sha1
        """
        return pulumi.get(self, "sha1")

    @sha1.setter
    def sha1(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args']]):
        pulumi.set(self, "sha1", value)


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict(TypedDict):
        authentication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication key
        """
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args:
    def __init__(__self__, *,
                 authentication_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_key: Authentication key
        """
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication key
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_key", value)


if not MYPY:
    class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict(TypedDict):
        authentication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication key
        """
elif False:
    ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersPrimaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args:
    def __init__(__self__, *,
                 authentication_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_key: Authentication key
        """
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication key
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_key", value)


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerArgsDict(TypedDict):
        authentication_type: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgsDict']]
        """
        Authentication type
        """
        ntp_server_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ntp server address
        """
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerArgs:
    def __init__(__self__, *,
                 authentication_type: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgs']] = None,
                 ntp_server_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgs'] authentication_type: Authentication type
        :param pulumi.Input[_builtins.str] ntp_server_address: Ntp server address
        """
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if ntp_server_address is not None:
            pulumi.set(__self__, "ntp_server_address", ntp_server_address)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgs']]:
        """
        Authentication type
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgs']]):
        pulumi.set(self, "authentication_type", value)

    @_builtins.property
    @pulumi.getter(name="ntpServerAddress")
    def ntp_server_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ntp server address
        """
        return pulumi.get(self, "ntp_server_address")

    @ntp_server_address.setter
    def ntp_server_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ntp_server_address", value)


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgsDict(TypedDict):
        autokey: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgsDict']]
        """
        Autokey
        """
        none: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        symmetric_key: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgsDict']]
        """
        Symmetric key

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeArgs:
    def __init__(__self__, *,
                 autokey: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgs']] = None,
                 none: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgs']] = None,
                 symmetric_key: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgs']] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgs'] autokey: Autokey
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgs'] symmetric_key: Symmetric key
               
               >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        if autokey is not None:
            pulumi.set(__self__, "autokey", autokey)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if symmetric_key is not None:
            pulumi.set(__self__, "symmetric_key", symmetric_key)

    @_builtins.property
    @pulumi.getter
    def autokey(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgs']]:
        """
        Autokey
        """
        return pulumi.get(self, "autokey")

    @autokey.setter
    def autokey(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgs']]):
        pulumi.set(self, "autokey", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter(name="symmetricKey")
    def symmetric_key(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgs']]:
        """
        Symmetric key

        >  **Note:** You must specify exactly one of `autokey`, `none`, and `symmetric_key`.
        """
        return pulumi.get(self, "symmetric_key")

    @symmetric_key.setter
    def symmetric_key(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgs']]):
        pulumi.set(self, "symmetric_key", value)


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgsDict(TypedDict):
        pass
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeAutokeyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgsDict(TypedDict):
        pass
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict']]
        """
        Algorithm
        """
        key_id: NotRequired[pulumi.Input[_builtins.float]]
        """
        Key id
        """
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs']] = None,
                 key_id: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs'] algorithm: Algorithm
        :param pulumi.Input[_builtins.float] key_id: Key id
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs']]:
        """
        Algorithm
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Key id
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict(TypedDict):
        md5: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict']]
        """
        Md5
        """
        sha1: NotRequired[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict']]
        """
        Sha1
        """
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmArgs:
    def __init__(__self__, *,
                 md5: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args']] = None,
                 sha1: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args']] = None):
        """
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args'] md5: Md5
        :param pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args'] sha1: Sha1
        """
        if md5 is not None:
            pulumi.set(__self__, "md5", md5)
        if sha1 is not None:
            pulumi.set(__self__, "sha1", sha1)

    @_builtins.property
    @pulumi.getter
    def md5(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args']]:
        """
        Md5
        """
        return pulumi.get(self, "md5")

    @md5.setter
    def md5(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args']]):
        pulumi.set(self, "md5", value)

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args']]:
        """
        Sha1
        """
        return pulumi.get(self, "sha1")

    @sha1.setter
    def sha1(self, value: Optional[pulumi.Input['ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args']]):
        pulumi.set(self, "sha1", value)


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict(TypedDict):
        authentication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication key
        """
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmMd5Args:
    def __init__(__self__, *,
                 authentication_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_key: Authentication key
        """
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication key
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_key", value)


if not MYPY:
    class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict(TypedDict):
        authentication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication key
        """
elif False:
    ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSettingServicesNtpServersSecondaryNtpServerAuthenticationTypeSymmetricKeyAlgorithmSha1Args:
    def __init__(__self__, *,
                 authentication_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_key: Authentication key
        """
        if authentication_key is not None:
            pulumi.set(__self__, "authentication_key", authentication_key)

    @_builtins.property
    @pulumi.getter(name="authenticationKey")
    def authentication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication key
        """
        return pulumi.get(self, "authentication_key")

    @authentication_key.setter
    def authentication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_key", value)


if not MYPY:
    class SessionSettingSessionSettingsArgsDict(TypedDict):
        accelerated_aging_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable accelerated aging
        """
        accelerated_aging_scaling_factor: NotRequired[pulumi.Input[_builtins.float]]
        """
        Accelerated aging scaling factor
        """
        accelerated_aging_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Accelerated aging threshold
        """
        config: NotRequired[pulumi.Input['SessionSettingSessionSettingsConfigArgsDict']]
        """
        Config
        """
        dhcp_bcast_session_on: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DHCP broadcast session
        """
        erspan: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable ERSPAN support
        """
        icmp_unreachable_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        ICMP unreachable packet rate (per second)
        """
        icmpv6_rate_limit: NotRequired[pulumi.Input['SessionSettingSessionSettingsIcmpv6RateLimitArgsDict']]
        """
        ICMPv6 rate limiting
        """
        ipv6_firewalling: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable IPv6 firewalling
        """
        jumbo_frame: NotRequired[pulumi.Input['SessionSettingSessionSettingsJumboFrameArgsDict']]
        """
        Enable jumbo frame support
        """
        max_pending_mcast_pkts_per_session: NotRequired[pulumi.Input[_builtins.float]]
        """
        Multicast route setup buffer size
        """
        multicast_route_setup_buffering: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Multicast route setup buffering
        """
        nat: NotRequired[pulumi.Input['SessionSettingSessionSettingsNatArgsDict']]
        """
        Nat
        """
        nat64: NotRequired[pulumi.Input['SessionSettingSessionSettingsNat64ArgsDict']]
        """
        Nat64
        """
        packet_buffer_protection_activate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Activate (%)
        """
        packet_buffer_protection_alert: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alert (%)
        """
        packet_buffer_protection_block_countdown: NotRequired[pulumi.Input[_builtins.float]]
        """
        Block countdown threshold (%)
        """
        packet_buffer_protection_block_duration_time: NotRequired[pulumi.Input[_builtins.float]]
        """
        Block duration (seconds)
        """
        packet_buffer_protection_block_hold_time: NotRequired[pulumi.Input[_builtins.float]]
        """
        Block hold time (seconds)
        """
        packet_buffer_protection_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable packet buffer protection
        """
        packet_buffer_protection_latency_activate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latency activate (milliseconds)
        """
        packet_buffer_protection_latency_alert: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latency alert (milliseconds)
        """
        packet_buffer_protection_latency_block_countdown: NotRequired[pulumi.Input[_builtins.float]]
        """
        Block countdown threshold (milliseconds)
        """
        packet_buffer_protection_latency_max_tolerate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latency max tolerate (milliseconds)
        """
        packet_buffer_protection_monitor_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Packet buffer protection monitor only
        """
        packet_buffer_protection_use_latency: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled latency-based activation
        """
elif False:
    SessionSettingSessionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionSettingSessionSettingsArgs:
    def __init__(__self__, *,
                 accelerated_aging_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 accelerated_aging_scaling_factor: Optional[pulumi.Input[_builtins.float]] = None,
                 accelerated_aging_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 config: Optional[pulumi.Input['SessionSettingSessionSettingsConfigArgs']] = None,
                 dhcp_bcast_session_on: Optional[pulumi.Input[_builtins.bool]] = None,
                 erspan: Optional[pulumi.Input[_builtins.bool]] = None,
                 icmp_unreachable_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 icmpv6_rate_limit: Optional[pulumi.Input['SessionSettingSessionSettingsIcmpv6RateLimitArgs']] = None,
                 ipv6_firewalling: Optional[pulumi.Input[_builtins.bool]] = None,
                 jumbo_frame: Optional[pulumi.Input['SessionSettingSessionSettingsJumboFrameArgs']] = None,
                 max_pending_mcast_pkts_per_session: Optional[pulumi.Input[_builtins.float]] = None,
                 multicast_route_setup_buffering: Optional[pulumi.Input[_builtins.bool]] = None,
                 nat: Optional[pulumi.Input['SessionSettingSessionSettingsNatArgs']] = None,
                 nat64: Optional[pulumi.Input['SessionSettingSessionSettingsNat64Args']] = None,
                 packet_buffer_protection_activate: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_alert: Optional[pulumi.Input[_builtins.int]] = None,
                 packet_buffer_protection_block_countdown: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_block_duration_time: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_block_hold_time: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 packet_buffer_protection_latency_activate: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_latency_alert: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_latency_block_countdown: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_latency_max_tolerate: Optional[pulumi.Input[_builtins.float]] = None,
                 packet_buffer_protection_monitor_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 packet_buffer_protection_use_latency: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] accelerated_aging_enable: Enable accelerated aging
        :param pulumi.Input[_builtins.float] accelerated_aging_scaling_factor: Accelerated aging scaling factor
        :param pulumi.Input[_builtins.float] accelerated_aging_threshold: Accelerated aging threshold
        :param pulumi.Input['SessionSettingSessionSettingsConfigArgs'] config: Config
        :param pulumi.Input[_builtins.bool] dhcp_bcast_session_on: Enable DHCP broadcast session
        :param pulumi.Input[_builtins.bool] erspan: Enable ERSPAN support
        :param pulumi.Input[_builtins.float] icmp_unreachable_rate: ICMP unreachable packet rate (per second)
        :param pulumi.Input['SessionSettingSessionSettingsIcmpv6RateLimitArgs'] icmpv6_rate_limit: ICMPv6 rate limiting
        :param pulumi.Input[_builtins.bool] ipv6_firewalling: Enable IPv6 firewalling
        :param pulumi.Input['SessionSettingSessionSettingsJumboFrameArgs'] jumbo_frame: Enable jumbo frame support
        :param pulumi.Input[_builtins.float] max_pending_mcast_pkts_per_session: Multicast route setup buffer size
        :param pulumi.Input[_builtins.bool] multicast_route_setup_buffering: Multicast route setup buffering
        :param pulumi.Input['SessionSettingSessionSettingsNatArgs'] nat: Nat
        :param pulumi.Input['SessionSettingSessionSettingsNat64Args'] nat64: Nat64
        :param pulumi.Input[_builtins.float] packet_buffer_protection_activate: Activate (%)
        :param pulumi.Input[_builtins.int] packet_buffer_protection_alert: Alert (%)
        :param pulumi.Input[_builtins.float] packet_buffer_protection_block_countdown: Block countdown threshold (%)
        :param pulumi.Input[_builtins.float] packet_buffer_protection_block_duration_time: Block duration (seconds)
        :param pulumi.Input[_builtins.float] packet_buffer_protection_block_hold_time: Block hold time (seconds)
        :param pulumi.Input[_builtins.bool] packet_buffer_protection_enable: Enable packet buffer protection
        :param pulumi.Input[_builtins.float] packet_buffer_protection_latency_activate: Latency activate (milliseconds)
        :param pulumi.Input[_builtins.float] packet_buffer_protection_latency_alert: Latency alert (milliseconds)
        :param pulumi.Input[_builtins.float] packet_buffer_protection_latency_block_countdown: Block countdown threshold (milliseconds)
        :param pulumi.Input[_builtins.float] packet_buffer_protection_latency_max_tolerate: Latency max tolerate (milliseconds)
        :param pulumi.Input[_builtins.bool] packet_buffer_protection_monitor_only: Packet buffer protection monitor only
        :param pulumi.Input[_builtins.bool] packet_buffer_protection_use_latency: Enabled latency-based activation
        """
        if accelerated_aging_enable is not None:
            pulumi.set(__self__, "accelerated_aging_enable", accelerated_aging_enable)
        if accelerated_aging_scaling_factor is not None:
            pulumi.set(__self__, "accelerated_aging_scaling_factor", accelerated_aging_scaling_factor)
        if accelerated_aging_threshold is not None:
            pulumi.set(__self__, "accelerated_aging_threshold", accelerated_aging_threshold)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if dhcp_bcast_session_on is not None:
            pulumi.set(__self__, "dhcp_bcast_session_on", dhcp_bcast_session_on)
        if erspan is not None:
            pulumi.set(__self__, "erspan", erspan)
        if icmp_unreachable_rate is not None:
            pulumi.set(__self__, "icmp_unreachable_rate", icmp_unreachable_rate)
        if icmpv6_rate_limit is not None:
            pulumi.set(__self__, "icmpv6_rate_limit", icmpv6_rate_limit)
        if ipv6_firewalling is not None:
            pulumi.set(__self__, "ipv6_firewalling", ipv6_firewalling)
        if jumbo_frame is not None:
            pulumi.set(__self__, "jumbo_frame", jumbo_frame)
        if max_pending_mcast_pkts_per_session is not None:
            pulumi.set(__self__, "max_pending_mcast_pkts_per_session", max_pending_mcast_pkts_per_session)
        if multicast_route_setup_buffering is not None:
            pulumi.set(__self__, "multicast_route_setup_buffering", multicast_route_setup_buffering)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat64 is not None:
            pulumi.set(__self__, "nat64", nat64)
        if packet_buffer_protection_activate is not None:
            pulumi.set(__self__, "packet_buffer_protection_activate", packet_buffer_protection_activate)
        if packet_buffer_protection_alert is not None:
            pulumi.set(__self__, "packet_buffer_protection_alert", packet_buffer_protection_alert)
        if packet_buffer_protection_block_countdown is not None:
            pulumi.set(__self__, "packet_buffer_protection_block_countdown", packet_buffer_protection_block_countdown)
        if packet_buffer_protection_block_duration_time is not None:
            pulumi.set(__self__, "packet_buffer_protection_block_duration_time", packet_buffer_protection_block_duration_time)
        if packet_buffer_protection_block_hold_time is not None:
            pulumi.set(__self__, "packet_buffer_protection_block_hold_time", packet_buffer_protection_block_hold_time)
        if packet_buffer_protection_enable is not None:
            pulumi.set(__self__, "packet_buffer_protection_enable", packet_buffer_protection_enable)
        if packet_buffer_protection_latency_activate is not None:
            pulumi.set(__self__, "packet_buffer_protection_latency_activate", packet_buffer_protection_latency_activate)
        if packet_buffer_protection_latency_alert is not None:
            pulumi.set(__self__, "packet_buffer_protection_latency_alert", packet_buffer_protection_latency_alert)
        if packet_buffer_protection_latency_block_countdown is not None:
            pulumi.set(__self__, "packet_buffer_protection_latency_block_countdown", packet_buffer_protection_latency_block_countdown)
        if packet_buffer_protection_latency_max_tolerate is not None:
            pulumi.set(__self__, "packet_buffer_protection_latency_max_tolerate", packet_buffer_protection_latency_max_tolerate)
        if packet_buffer_protection_monitor_only is not None:
            pulumi.set(__self__, "packet_buffer_protection_monitor_only", packet_buffer_protection_monitor_only)
        if packet_buffer_protection_use_latency is not None:
            pulumi.set(__self__, "packet_buffer_protection_use_latency", packet_buffer_protection_use_latency)

    @_builtins.property
    @pulumi.getter(name="acceleratedAgingEnable")
    def accelerated_aging_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable accelerated aging
        """
        return pulumi.get(self, "accelerated_aging_enable")

    @accelerated_aging_enable.setter
    def accelerated_aging_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accelerated_aging_enable", value)

    @_builtins.property
    @pulumi.getter(name="acceleratedAgingScalingFactor")
    def accelerated_aging_scaling_factor(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Accelerated aging scaling factor
        """
        return pulumi.get(self, "accelerated_aging_scaling_factor")

    @accelerated_aging_scaling_factor.setter
    def accelerated_aging_scaling_factor(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "accelerated_aging_scaling_factor", value)

    @_builtins.property
    @pulumi.getter(name="acceleratedAgingThreshold")
    def accelerated_aging_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Accelerated aging threshold
        """
        return pulumi.get(self, "accelerated_aging_threshold")

    @accelerated_aging_threshold.setter
    def accelerated_aging_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "accelerated_aging_threshold", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['SessionSettingSessionSettingsConfigArgs']]:
        """
        Config
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['SessionSettingSessionSettingsConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter(name="dhcpBcastSessionOn")
    def dhcp_bcast_session_on(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DHCP broadcast session
        """
        return pulumi.get(self, "dhcp_bcast_session_on")

    @dhcp_bcast_session_on.setter
    def dhcp_bcast_session_on(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dhcp_bcast_session_on", value)

    @_builtins.property
    @pulumi.getter
    def erspan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable ERSPAN support
        """
        return pulumi.get(self, "erspan")

    @erspan.setter
    def erspan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "erspan", value)

    @_builtins.property
    @pulumi.getter(name="icmpUnreachableRate")
    def icmp_unreachable_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        ICMP unreachable packet rate (per second)
        """
        return pulumi.get(self, "icmp_unreachable_rate")

    @icmp_unreachable_rate.setter
    def icmp_unreachable_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "icmp_unreachable_rate", value)

    @_builtins.property
    @pulumi.getter(name="icmpv6RateLimit")
    def icmpv6_rate_limit(self) -> Optional[pulumi.Input['SessionSettingSessionSettingsIcmpv6RateLimitArgs']]:
        """
        ICMPv6 rate limiting
        """
        return pulumi.get(self, "icmpv6_rate_limit")

    @icmpv6_rate_limit.setter
    def icmpv6_rate_limit(self, value: Optional[pulumi.Input['SessionSettingSessionSettingsIcmpv6RateLimitArgs']]):
        pulumi.set(self, "icmpv6_rate_limit", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Firewalling")
    def ipv6_firewalling(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable IPv6 firewalling
        """
        return pulumi.get(self, "ipv6_firewalling")

    @ipv6_firewalling.setter
    def ipv6_firewalling(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_firewalling", value)

    @_builtins.property
    @pulumi.getter(name="jumboFrame")
    def jumbo_frame(self) -> Optional[pulumi.Input['SessionSettingSessionSettingsJumboFrameArgs']]:
        """
        Enable jumbo frame support
        """
        return pulumi.get(self, "jumbo_frame")

    @jumbo_frame.setter
    def jumbo_frame(self, value: Optional[pulumi.Input['SessionSettingSessionSettingsJumboFrameArgs']]):
        pulumi.set(self, "jumbo_frame", value)

    @_builtins.property
    @pulumi.getter(name="maxPendingMcastPktsPerSession")
    def max_pending_mcast_pkts_per_session(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Multicast route setup buffer size
        """
        return pulumi.get(self, "max_pending_mcast_pkts_per_session")

    @max_pending_mcast_pkts_per_session.setter
    def max_pending_mcast_pkts_per_session(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_pending_mcast_pkts_per_session", value)

    @_builtins.property
    @pulumi.getter(name="multicastRouteSetupBuffering")
    def multicast_route_setup_buffering(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Multicast route setup buffering
        """
        return pulumi.get(self, "multicast_route_setup_buffering")

    @multicast_route_setup_buffering.setter
    def multicast_route_setup_buffering(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multicast_route_setup_buffering", value)

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input['SessionSettingSessionSettingsNatArgs']]:
        """
        Nat
        """
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input['SessionSettingSessionSettingsNatArgs']]):
        pulumi.set(self, "nat", value)

    @_builtins.property
    @pulumi.getter
    def nat64(self) -> Optional[pulumi.Input['SessionSettingSessionSettingsNat64Args']]:
        """
        Nat64
        """
        return pulumi.get(self, "nat64")

    @nat64.setter
    def nat64(self, value: Optional[pulumi.Input['SessionSettingSessionSettingsNat64Args']]):
        pulumi.set(self, "nat64", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionActivate")
    def packet_buffer_protection_activate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Activate (%)
        """
        return pulumi.get(self, "packet_buffer_protection_activate")

    @packet_buffer_protection_activate.setter
    def packet_buffer_protection_activate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_activate", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionAlert")
    def packet_buffer_protection_alert(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alert (%)
        """
        return pulumi.get(self, "packet_buffer_protection_alert")

    @packet_buffer_protection_alert.setter
    def packet_buffer_protection_alert(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "packet_buffer_protection_alert", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionBlockCountdown")
    def packet_buffer_protection_block_countdown(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Block countdown threshold (%)
        """
        return pulumi.get(self, "packet_buffer_protection_block_countdown")

    @packet_buffer_protection_block_countdown.setter
    def packet_buffer_protection_block_countdown(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_block_countdown", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionBlockDurationTime")
    def packet_buffer_protection_block_duration_time(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Block duration (seconds)
        """
        return pulumi.get(self, "packet_buffer_protection_block_duration_time")

    @packet_buffer_protection_block_duration_time.setter
    def packet_buffer_protection_block_duration_time(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_block_duration_time", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionBlockHoldTime")
    def packet_buffer_protection_block_hold_time(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Block hold time (seconds)
        """
        return pulumi.get(self, "packet_buffer_protection_block_hold_time")

    @packet_buffer_protection_block_hold_time.setter
    def packet_buffer_protection_block_hold_time(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_block_hold_time", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionEnable")
    def packet_buffer_protection_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable packet buffer protection
        """
        return pulumi.get(self, "packet_buffer_protection_enable")

    @packet_buffer_protection_enable.setter
    def packet_buffer_protection_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "packet_buffer_protection_enable", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionLatencyActivate")
    def packet_buffer_protection_latency_activate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latency activate (milliseconds)
        """
        return pulumi.get(self, "packet_buffer_protection_latency_activate")

    @packet_buffer_protection_latency_activate.setter
    def packet_buffer_protection_latency_activate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_latency_activate", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionLatencyAlert")
    def packet_buffer_protection_latency_alert(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latency alert (milliseconds)
        """
        return pulumi.get(self, "packet_buffer_protection_latency_alert")

    @packet_buffer_protection_latency_alert.setter
    def packet_buffer_protection_latency_alert(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_latency_alert", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionLatencyBlockCountdown")
    def packet_buffer_protection_latency_block_countdown(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Block countdown threshold (milliseconds)
        """
        return pulumi.get(self, "packet_buffer_protection_latency_block_countdown")

    @packet_buffer_protection_latency_block_countdown.setter
    def packet_buffer_protection_latency_block_countdown(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_latency_block_countdown", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionLatencyMaxTolerate")
    def packet_buffer_protection_latency_max_tolerate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latency max tolerate (milliseconds)
        """
        return pulumi.get(self, "packet_buffer_protection_latency_max_tolerate")

    @packet_buffer_protection_latency_max_tolerate.setter
    def packet_buffer_protection_latency_max_tolerate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "packet_buffer_protection_latency_max_tolerate", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionMonitorOnly")
    def packet_buffer_protection_monitor_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Packet buffer protection monitor only
        """
        return pulumi.get(self, "packet_buffer_protection_monitor_only")

    @packet_buffer_protection_monitor_only.setter
    def packet_buffer_protection_monitor_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "packet_buffer_protection_monitor_only", value)

    @_builtins.property
    @pulumi.getter(name="packetBufferProtectionUseLatency")
    def packet_buffer_protection_use_latency(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled latency-based activation
        """
        return pulumi.get(self, "packet_buffer_protection_use_latency")

    @packet_buffer_protection_use_latency.setter
    def packet_buffer_protection_use_latency(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "packet_buffer_protection_use_latency", value)


if not MYPY:
    class SessionSettingSessionSettingsConfigArgsDict(TypedDict):
        rematch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Rematch all sessions on config policy change
        """
elif False:
    SessionSettingSessionSettingsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionSettingSessionSettingsConfigArgs:
    def __init__(__self__, *,
                 rematch: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] rematch: Rematch all sessions on config policy change
        """
        if rematch is not None:
            pulumi.set(__self__, "rematch", rematch)

    @_builtins.property
    @pulumi.getter
    def rematch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Rematch all sessions on config policy change
        """
        return pulumi.get(self, "rematch")

    @rematch.setter
    def rematch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rematch", value)


if not MYPY:
    class SessionSettingSessionSettingsIcmpv6RateLimitArgsDict(TypedDict):
        bucket_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        ICMPv6 token bucket size
        """
        packet_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        ICMPv6 error packet pate (per second)
        """
elif False:
    SessionSettingSessionSettingsIcmpv6RateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionSettingSessionSettingsIcmpv6RateLimitArgs:
    def __init__(__self__, *,
                 bucket_size: Optional[pulumi.Input[_builtins.int]] = None,
                 packet_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] bucket_size: ICMPv6 token bucket size
        :param pulumi.Input[_builtins.int] packet_rate: ICMPv6 error packet pate (per second)
        """
        if bucket_size is not None:
            pulumi.set(__self__, "bucket_size", bucket_size)
        if packet_rate is not None:
            pulumi.set(__self__, "packet_rate", packet_rate)

    @_builtins.property
    @pulumi.getter(name="bucketSize")
    def bucket_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        ICMPv6 token bucket size
        """
        return pulumi.get(self, "bucket_size")

    @bucket_size.setter
    def bucket_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bucket_size", value)

    @_builtins.property
    @pulumi.getter(name="packetRate")
    def packet_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        ICMPv6 error packet pate (per second)
        """
        return pulumi.get(self, "packet_rate")

    @packet_rate.setter
    def packet_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "packet_rate", value)


if not MYPY:
    class SessionSettingSessionSettingsJumboFrameArgsDict(TypedDict):
        mtu: NotRequired[pulumi.Input[_builtins.int]]
        """
        Global MTU
        """
elif False:
    SessionSettingSessionSettingsJumboFrameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionSettingSessionSettingsJumboFrameArgs:
    def __init__(__self__, *,
                 mtu: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] mtu: Global MTU
        """
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Global MTU
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mtu", value)


if not MYPY:
    class SessionSettingSessionSettingsNat64ArgsDict(TypedDict):
        ipv6_min_network_mtu: NotRequired[pulumi.Input[_builtins.int]]
        """
        NAT64 IPv6 minimum network MTU
        """
elif False:
    SessionSettingSessionSettingsNat64ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionSettingSessionSettingsNat64Args:
    def __init__(__self__, *,
                 ipv6_min_network_mtu: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] ipv6_min_network_mtu: NAT64 IPv6 minimum network MTU
        """
        if ipv6_min_network_mtu is not None:
            pulumi.set(__self__, "ipv6_min_network_mtu", ipv6_min_network_mtu)

    @_builtins.property
    @pulumi.getter(name="ipv6MinNetworkMtu")
    def ipv6_min_network_mtu(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        NAT64 IPv6 minimum network MTU
        """
        return pulumi.get(self, "ipv6_min_network_mtu")

    @ipv6_min_network_mtu.setter
    def ipv6_min_network_mtu(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_min_network_mtu", value)


if not MYPY:
    class SessionSettingSessionSettingsNatArgsDict(TypedDict):
        dipp_oversub: NotRequired[pulumi.Input[_builtins.str]]
        """
        NAT oversubscription rate
        """
elif False:
    SessionSettingSessionSettingsNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionSettingSessionSettingsNatArgs:
    def __init__(__self__, *,
                 dipp_oversub: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dipp_oversub: NAT oversubscription rate
        """
        if dipp_oversub is not None:
            pulumi.set(__self__, "dipp_oversub", dipp_oversub)

    @_builtins.property
    @pulumi.getter(name="dippOversub")
    def dipp_oversub(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        NAT oversubscription rate
        """
        return pulumi.get(self, "dipp_oversub")

    @dipp_oversub.setter
    def dipp_oversub(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dipp_oversub", value)


if not MYPY:
    class SessionTimeoutSessionTimeoutsArgsDict(TypedDict):
        timeout_captive_portal: NotRequired[pulumi.Input[_builtins.int]]
        """
        Captive Portal (seconds)
        """
        timeout_default: NotRequired[pulumi.Input[_builtins.int]]
        """
        Default timeout (seconds)
        """
        timeout_discard_default: NotRequired[pulumi.Input[_builtins.int]]
        """
        Discard default (seconds)
        """
        timeout_discard_tcp: NotRequired[pulumi.Input[_builtins.int]]
        """
        Discard TCP (seconds)
        """
        timeout_discard_udp: NotRequired[pulumi.Input[_builtins.int]]
        """
        Discard UDP (seconds)
        """
        timeout_icmp: NotRequired[pulumi.Input[_builtins.int]]
        """
        ICMP (seconds)
        """
        timeout_scan: NotRequired[pulumi.Input[_builtins.int]]
        """
        Scan (seconds)
        """
        timeout_tcp: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP (seconds)
        """
        timeout_tcp_half_closed: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP Half Closed (seconds)
        """
        timeout_tcp_time_wait: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP Time Wait (seconds)
        """
        timeout_tcp_unverified_rst: NotRequired[pulumi.Input[_builtins.int]]
        """
        Unverified RST (seconds)
        """
        timeout_tcphandshake: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP handshake (seconds)
        """
        timeout_tcpinit: NotRequired[pulumi.Input[_builtins.int]]
        """
        TCP init (seconds)
        """
        timeout_udp: NotRequired[pulumi.Input[_builtins.int]]
        """
        UDP (seconds)
        """
elif False:
    SessionTimeoutSessionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionTimeoutSessionTimeoutsArgs:
    def __init__(__self__, *,
                 timeout_captive_portal: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_default: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_discard_default: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_discard_tcp: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_discard_udp: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_icmp: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_scan: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_tcp: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_tcp_half_closed: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_tcp_time_wait: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_tcp_unverified_rst: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_tcphandshake: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_tcpinit: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_udp: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] timeout_captive_portal: Captive Portal (seconds)
        :param pulumi.Input[_builtins.int] timeout_default: Default timeout (seconds)
        :param pulumi.Input[_builtins.int] timeout_discard_default: Discard default (seconds)
        :param pulumi.Input[_builtins.int] timeout_discard_tcp: Discard TCP (seconds)
        :param pulumi.Input[_builtins.int] timeout_discard_udp: Discard UDP (seconds)
        :param pulumi.Input[_builtins.int] timeout_icmp: ICMP (seconds)
        :param pulumi.Input[_builtins.int] timeout_scan: Scan (seconds)
        :param pulumi.Input[_builtins.int] timeout_tcp: TCP (seconds)
        :param pulumi.Input[_builtins.int] timeout_tcp_half_closed: TCP Half Closed (seconds)
        :param pulumi.Input[_builtins.int] timeout_tcp_time_wait: TCP Time Wait (seconds)
        :param pulumi.Input[_builtins.int] timeout_tcp_unverified_rst: Unverified RST (seconds)
        :param pulumi.Input[_builtins.int] timeout_tcphandshake: TCP handshake (seconds)
        :param pulumi.Input[_builtins.int] timeout_tcpinit: TCP init (seconds)
        :param pulumi.Input[_builtins.int] timeout_udp: UDP (seconds)
        """
        if timeout_captive_portal is not None:
            pulumi.set(__self__, "timeout_captive_portal", timeout_captive_portal)
        if timeout_default is not None:
            pulumi.set(__self__, "timeout_default", timeout_default)
        if timeout_discard_default is not None:
            pulumi.set(__self__, "timeout_discard_default", timeout_discard_default)
        if timeout_discard_tcp is not None:
            pulumi.set(__self__, "timeout_discard_tcp", timeout_discard_tcp)
        if timeout_discard_udp is not None:
            pulumi.set(__self__, "timeout_discard_udp", timeout_discard_udp)
        if timeout_icmp is not None:
            pulumi.set(__self__, "timeout_icmp", timeout_icmp)
        if timeout_scan is not None:
            pulumi.set(__self__, "timeout_scan", timeout_scan)
        if timeout_tcp is not None:
            pulumi.set(__self__, "timeout_tcp", timeout_tcp)
        if timeout_tcp_half_closed is not None:
            pulumi.set(__self__, "timeout_tcp_half_closed", timeout_tcp_half_closed)
        if timeout_tcp_time_wait is not None:
            pulumi.set(__self__, "timeout_tcp_time_wait", timeout_tcp_time_wait)
        if timeout_tcp_unverified_rst is not None:
            pulumi.set(__self__, "timeout_tcp_unverified_rst", timeout_tcp_unverified_rst)
        if timeout_tcphandshake is not None:
            pulumi.set(__self__, "timeout_tcphandshake", timeout_tcphandshake)
        if timeout_tcpinit is not None:
            pulumi.set(__self__, "timeout_tcpinit", timeout_tcpinit)
        if timeout_udp is not None:
            pulumi.set(__self__, "timeout_udp", timeout_udp)

    @_builtins.property
    @pulumi.getter(name="timeoutCaptivePortal")
    def timeout_captive_portal(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Captive Portal (seconds)
        """
        return pulumi.get(self, "timeout_captive_portal")

    @timeout_captive_portal.setter
    def timeout_captive_portal(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_captive_portal", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDefault")
    def timeout_default(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Default timeout (seconds)
        """
        return pulumi.get(self, "timeout_default")

    @timeout_default.setter
    def timeout_default(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_default", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDiscardDefault")
    def timeout_discard_default(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Discard default (seconds)
        """
        return pulumi.get(self, "timeout_discard_default")

    @timeout_discard_default.setter
    def timeout_discard_default(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_discard_default", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDiscardTcp")
    def timeout_discard_tcp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Discard TCP (seconds)
        """
        return pulumi.get(self, "timeout_discard_tcp")

    @timeout_discard_tcp.setter
    def timeout_discard_tcp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_discard_tcp", value)

    @_builtins.property
    @pulumi.getter(name="timeoutDiscardUdp")
    def timeout_discard_udp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Discard UDP (seconds)
        """
        return pulumi.get(self, "timeout_discard_udp")

    @timeout_discard_udp.setter
    def timeout_discard_udp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_discard_udp", value)

    @_builtins.property
    @pulumi.getter(name="timeoutIcmp")
    def timeout_icmp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        ICMP (seconds)
        """
        return pulumi.get(self, "timeout_icmp")

    @timeout_icmp.setter
    def timeout_icmp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_icmp", value)

    @_builtins.property
    @pulumi.getter(name="timeoutScan")
    def timeout_scan(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Scan (seconds)
        """
        return pulumi.get(self, "timeout_scan")

    @timeout_scan.setter
    def timeout_scan(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_scan", value)

    @_builtins.property
    @pulumi.getter(name="timeoutTcp")
    def timeout_tcp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP (seconds)
        """
        return pulumi.get(self, "timeout_tcp")

    @timeout_tcp.setter
    def timeout_tcp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_tcp", value)

    @_builtins.property
    @pulumi.getter(name="timeoutTcpHalfClosed")
    def timeout_tcp_half_closed(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP Half Closed (seconds)
        """
        return pulumi.get(self, "timeout_tcp_half_closed")

    @timeout_tcp_half_closed.setter
    def timeout_tcp_half_closed(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_tcp_half_closed", value)

    @_builtins.property
    @pulumi.getter(name="timeoutTcpTimeWait")
    def timeout_tcp_time_wait(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP Time Wait (seconds)
        """
        return pulumi.get(self, "timeout_tcp_time_wait")

    @timeout_tcp_time_wait.setter
    def timeout_tcp_time_wait(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_tcp_time_wait", value)

    @_builtins.property
    @pulumi.getter(name="timeoutTcpUnverifiedRst")
    def timeout_tcp_unverified_rst(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Unverified RST (seconds)
        """
        return pulumi.get(self, "timeout_tcp_unverified_rst")

    @timeout_tcp_unverified_rst.setter
    def timeout_tcp_unverified_rst(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_tcp_unverified_rst", value)

    @_builtins.property
    @pulumi.getter(name="timeoutTcphandshake")
    def timeout_tcphandshake(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP handshake (seconds)
        """
        return pulumi.get(self, "timeout_tcphandshake")

    @timeout_tcphandshake.setter
    def timeout_tcphandshake(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_tcphandshake", value)

    @_builtins.property
    @pulumi.getter(name="timeoutTcpinit")
    def timeout_tcpinit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TCP init (seconds)
        """
        return pulumi.get(self, "timeout_tcpinit")

    @timeout_tcpinit.setter
    def timeout_tcpinit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_tcpinit", value)

    @_builtins.property
    @pulumi.getter(name="timeoutUdp")
    def timeout_udp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        UDP (seconds)
        """
        return pulumi.get(self, "timeout_udp")

    @timeout_udp.setter
    def timeout_udp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_udp", value)


if not MYPY:
    class SiteMemberArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The mode of the remote network
        """
        name: pulumi.Input[_builtins.str]
        """
        The member name
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the remote network
        """
        remote_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The remote network name
        """
elif False:
    SiteMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteMemberArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The mode of the remote network
        :param pulumi.Input[_builtins.str] name: The member name
        :param pulumi.Input[_builtins.str] id: UUID of the remote network
        :param pulumi.Input[_builtins.str] remote_network: The remote network name
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if remote_network is not None:
            pulumi.set(__self__, "remote_network", remote_network)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The mode of the remote network
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The member name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the remote network
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="remoteNetwork")
    def remote_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The remote network name
        """
        return pulumi.get(self, "remote_network")

    @remote_network.setter
    def remote_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_network", value)


if not MYPY:
    class SiteQosArgsDict(TypedDict):
        backup_cir: NotRequired[pulumi.Input[_builtins.float]]
        """
        The backup CIR in Mbps. This is distributed equally for all tunnels in the site.
        """
        cir: NotRequired[pulumi.Input[_builtins.float]]
        """
        The CIR in Mbps. This is distributed equally for all tunnels in the site.
        """
        profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the site QoS profile
        """
elif False:
    SiteQosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteQosArgs:
    def __init__(__self__, *,
                 backup_cir: Optional[pulumi.Input[_builtins.float]] = None,
                 cir: Optional[pulumi.Input[_builtins.float]] = None,
                 profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] backup_cir: The backup CIR in Mbps. This is distributed equally for all tunnels in the site.
        :param pulumi.Input[_builtins.float] cir: The CIR in Mbps. This is distributed equally for all tunnels in the site.
        :param pulumi.Input[_builtins.str] profile: The name of the site QoS profile
        """
        if backup_cir is not None:
            pulumi.set(__self__, "backup_cir", backup_cir)
        if cir is not None:
            pulumi.set(__self__, "cir", cir)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="backupCir")
    def backup_cir(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The backup CIR in Mbps. This is distributed equally for all tunnels in the site.
        """
        return pulumi.get(self, "backup_cir")

    @backup_cir.setter
    def backup_cir(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "backup_cir", value)

    @_builtins.property
    @pulumi.getter
    def cir(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The CIR in Mbps. This is distributed equally for all tunnels in the site.
        """
        return pulumi.get(self, "cir")

    @cir.setter
    def cir(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cir", value)

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the site QoS profile
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class SyslogServerProfileFormatArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input[_builtins.str]]
        """
        Auth
        """
        config: NotRequired[pulumi.Input[_builtins.str]]
        """
        Config
        """
        correlation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Correlation
        """
        data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data
        """
        decryption: NotRequired[pulumi.Input[_builtins.str]]
        """
        Decryption
        """
        escaping: NotRequired[pulumi.Input['SyslogServerProfileFormatEscapingArgsDict']]
        """
        Escaping
        """
        globalprotect: NotRequired[pulumi.Input[_builtins.str]]
        """
        Globalprotect
        """
        gtp: NotRequired[pulumi.Input[_builtins.str]]
        """
        Gtp
        """
        hip_match: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hip match
        """
        iptag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Iptag
        """
        sctp: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sctp
        """
        system: NotRequired[pulumi.Input[_builtins.str]]
        """
        System
        """
        threat: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threat
        """
        traffic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Traffic
        """
        tunnel: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tunnel
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Url
        """
        userid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Userid
        """
        wildfire: NotRequired[pulumi.Input[_builtins.str]]
        """
        Wildfire
        """
elif False:
    SyslogServerProfileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogServerProfileFormatArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[_builtins.str]] = None,
                 config: Optional[pulumi.Input[_builtins.str]] = None,
                 correlation: Optional[pulumi.Input[_builtins.str]] = None,
                 data: Optional[pulumi.Input[_builtins.str]] = None,
                 decryption: Optional[pulumi.Input[_builtins.str]] = None,
                 escaping: Optional[pulumi.Input['SyslogServerProfileFormatEscapingArgs']] = None,
                 globalprotect: Optional[pulumi.Input[_builtins.str]] = None,
                 gtp: Optional[pulumi.Input[_builtins.str]] = None,
                 hip_match: Optional[pulumi.Input[_builtins.str]] = None,
                 iptag: Optional[pulumi.Input[_builtins.str]] = None,
                 sctp: Optional[pulumi.Input[_builtins.str]] = None,
                 system: Optional[pulumi.Input[_builtins.str]] = None,
                 threat: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic: Optional[pulumi.Input[_builtins.str]] = None,
                 tunnel: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 userid: Optional[pulumi.Input[_builtins.str]] = None,
                 wildfire: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth: Auth
        :param pulumi.Input[_builtins.str] config: Config
        :param pulumi.Input[_builtins.str] correlation: Correlation
        :param pulumi.Input[_builtins.str] data: Data
        :param pulumi.Input[_builtins.str] decryption: Decryption
        :param pulumi.Input['SyslogServerProfileFormatEscapingArgs'] escaping: Escaping
        :param pulumi.Input[_builtins.str] globalprotect: Globalprotect
        :param pulumi.Input[_builtins.str] gtp: Gtp
        :param pulumi.Input[_builtins.str] hip_match: Hip match
        :param pulumi.Input[_builtins.str] iptag: Iptag
        :param pulumi.Input[_builtins.str] sctp: Sctp
        :param pulumi.Input[_builtins.str] system: System
        :param pulumi.Input[_builtins.str] threat: Threat
        :param pulumi.Input[_builtins.str] traffic: Traffic
        :param pulumi.Input[_builtins.str] tunnel: Tunnel
        :param pulumi.Input[_builtins.str] url: Url
        :param pulumi.Input[_builtins.str] userid: Userid
        :param pulumi.Input[_builtins.str] wildfire: Wildfire
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if correlation is not None:
            pulumi.set(__self__, "correlation", correlation)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if decryption is not None:
            pulumi.set(__self__, "decryption", decryption)
        if escaping is not None:
            pulumi.set(__self__, "escaping", escaping)
        if globalprotect is not None:
            pulumi.set(__self__, "globalprotect", globalprotect)
        if gtp is not None:
            pulumi.set(__self__, "gtp", gtp)
        if hip_match is not None:
            pulumi.set(__self__, "hip_match", hip_match)
        if iptag is not None:
            pulumi.set(__self__, "iptag", iptag)
        if sctp is not None:
            pulumi.set(__self__, "sctp", sctp)
        if system is not None:
            pulumi.set(__self__, "system", system)
        if threat is not None:
            pulumi.set(__self__, "threat", threat)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if userid is not None:
            pulumi.set(__self__, "userid", userid)
        if wildfire is not None:
            pulumi.set(__self__, "wildfire", wildfire)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Auth
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Config
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def correlation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Correlation
        """
        return pulumi.get(self, "correlation")

    @correlation.setter
    def correlation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "correlation", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def decryption(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Decryption
        """
        return pulumi.get(self, "decryption")

    @decryption.setter
    def decryption(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "decryption", value)

    @_builtins.property
    @pulumi.getter
    def escaping(self) -> Optional[pulumi.Input['SyslogServerProfileFormatEscapingArgs']]:
        """
        Escaping
        """
        return pulumi.get(self, "escaping")

    @escaping.setter
    def escaping(self, value: Optional[pulumi.Input['SyslogServerProfileFormatEscapingArgs']]):
        pulumi.set(self, "escaping", value)

    @_builtins.property
    @pulumi.getter
    def globalprotect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Globalprotect
        """
        return pulumi.get(self, "globalprotect")

    @globalprotect.setter
    def globalprotect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "globalprotect", value)

    @_builtins.property
    @pulumi.getter
    def gtp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Gtp
        """
        return pulumi.get(self, "gtp")

    @gtp.setter
    def gtp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gtp", value)

    @_builtins.property
    @pulumi.getter(name="hipMatch")
    def hip_match(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hip match
        """
        return pulumi.get(self, "hip_match")

    @hip_match.setter
    def hip_match(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hip_match", value)

    @_builtins.property
    @pulumi.getter
    def iptag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Iptag
        """
        return pulumi.get(self, "iptag")

    @iptag.setter
    def iptag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iptag", value)

    @_builtins.property
    @pulumi.getter
    def sctp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sctp
        """
        return pulumi.get(self, "sctp")

    @sctp.setter
    def sctp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sctp", value)

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System
        """
        return pulumi.get(self, "system")

    @system.setter
    def system(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "system", value)

    @_builtins.property
    @pulumi.getter
    def threat(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threat
        """
        return pulumi.get(self, "threat")

    @threat.setter
    def threat(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threat", value)

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Traffic
        """
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tunnel
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tunnel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Url
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def userid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Userid
        """
        return pulumi.get(self, "userid")

    @userid.setter
    def userid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "userid", value)

    @_builtins.property
    @pulumi.getter
    def wildfire(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Wildfire
        """
        return pulumi.get(self, "wildfire")

    @wildfire.setter
    def wildfire(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wildfire", value)


if not MYPY:
    class SyslogServerProfileFormatEscapingArgsDict(TypedDict):
        escape_character: NotRequired[pulumi.Input[_builtins.str]]
        """
        Escape sequence delimiter
        """
        escaped_characters: NotRequired[pulumi.Input[_builtins.str]]
        """
        A list of all the characters to be escaped (without spaces).
        """
elif False:
    SyslogServerProfileFormatEscapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogServerProfileFormatEscapingArgs:
    def __init__(__self__, *,
                 escape_character: Optional[pulumi.Input[_builtins.str]] = None,
                 escaped_characters: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] escape_character: Escape sequence delimiter
        :param pulumi.Input[_builtins.str] escaped_characters: A list of all the characters to be escaped (without spaces).
        """
        if escape_character is not None:
            pulumi.set(__self__, "escape_character", escape_character)
        if escaped_characters is not None:
            pulumi.set(__self__, "escaped_characters", escaped_characters)

    @_builtins.property
    @pulumi.getter(name="escapeCharacter")
    def escape_character(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Escape sequence delimiter
        """
        return pulumi.get(self, "escape_character")

    @escape_character.setter
    def escape_character(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "escape_character", value)

    @_builtins.property
    @pulumi.getter(name="escapedCharacters")
    def escaped_characters(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A list of all the characters to be escaped (without spaces).
        """
        return pulumi.get(self, "escaped_characters")

    @escaped_characters.setter
    def escaped_characters(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "escaped_characters", value)


if not MYPY:
    class SyslogServerProfileServerArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[_builtins.str]]
        """
        Syslog facility
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Syslog format
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Syslog server name
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Syslog server port
        """
        server: NotRequired[pulumi.Input[_builtins.str]]
        """
        Syslog server address
        """
        transport: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transport protocol
        """
elif False:
    SyslogServerProfileServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyslogServerProfileServerArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 server: Optional[pulumi.Input[_builtins.str]] = None,
                 transport: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] facility: Syslog facility
        :param pulumi.Input[_builtins.str] format: Syslog format
        :param pulumi.Input[_builtins.str] name: Syslog server name
        :param pulumi.Input[_builtins.int] port: Syslog server port
        :param pulumi.Input[_builtins.str] server: Syslog server address
        :param pulumi.Input[_builtins.str] transport: Transport protocol
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Syslog facility
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "facility", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Syslog format
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Syslog server name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Syslog server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Syslog server address
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server", value)

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transport protocol
        """
        return pulumi.get(self, "transport")

    @transport.setter
    def transport(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transport", value)


if not MYPY:
    class TacacsServerProfileServerArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the TACACS+ server
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the TACACS+ server
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The TACACS+ server port
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The TACACS+ secret
        """
elif False:
    TacacsServerProfileServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TacacsServerProfileServerArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The IP address of the TACACS+ server
        :param pulumi.Input[_builtins.str] name: The name of the TACACS+ server
        :param pulumi.Input[_builtins.int] port: The TACACS+ server port
        :param pulumi.Input[_builtins.str] secret: The TACACS+ secret
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the TACACS+ server
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the TACACS+ server
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The TACACS+ server port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The TACACS+ secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class TcpSettingTcpArgsDict(TypedDict):
        allow_challenge_ack: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow arbitrary ACK in response to SYN?
        """
        asymmetric_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Asymmetric path action
        """
        bypass_exceed_oo_queue: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Forward segments exceeding TCP out-of-order queue?
        """
        check_timestamp_option: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop segments with null timestamp option?
        """
        drop_zero_flag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop segments without flag?
        """
        siptcp_cleartext_proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        SIP TCP cleartext action (`'0'` = Always Off, `'1'` = Always Enabled, `'2'` = Automatically enable proxy when needed)
        """
        strip_mptcp_option: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Strip MPTCP option?
        """
        tcp_retransmit_scan: NotRequired[pulumi.Input[_builtins.bool]]
        """
        TCP retransmit scan?
        """
        urgent_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Urgent data flag action
        """
elif False:
    TcpSettingTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpSettingTcpArgs:
    def __init__(__self__, *,
                 allow_challenge_ack: Optional[pulumi.Input[_builtins.bool]] = None,
                 asymmetric_path: Optional[pulumi.Input[_builtins.str]] = None,
                 bypass_exceed_oo_queue: Optional[pulumi.Input[_builtins.bool]] = None,
                 check_timestamp_option: Optional[pulumi.Input[_builtins.bool]] = None,
                 drop_zero_flag: Optional[pulumi.Input[_builtins.bool]] = None,
                 siptcp_cleartext_proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 strip_mptcp_option: Optional[pulumi.Input[_builtins.bool]] = None,
                 tcp_retransmit_scan: Optional[pulumi.Input[_builtins.bool]] = None,
                 urgent_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_challenge_ack: Allow arbitrary ACK in response to SYN?
        :param pulumi.Input[_builtins.str] asymmetric_path: Asymmetric path action
        :param pulumi.Input[_builtins.bool] bypass_exceed_oo_queue: Forward segments exceeding TCP out-of-order queue?
        :param pulumi.Input[_builtins.bool] check_timestamp_option: Drop segments with null timestamp option?
        :param pulumi.Input[_builtins.bool] drop_zero_flag: Drop segments without flag?
        :param pulumi.Input[_builtins.str] siptcp_cleartext_proxy: SIP TCP cleartext action (`'0'` = Always Off, `'1'` = Always Enabled, `'2'` = Automatically enable proxy when needed)
        :param pulumi.Input[_builtins.bool] strip_mptcp_option: Strip MPTCP option?
        :param pulumi.Input[_builtins.bool] tcp_retransmit_scan: TCP retransmit scan?
        :param pulumi.Input[_builtins.str] urgent_data: Urgent data flag action
        """
        if allow_challenge_ack is not None:
            pulumi.set(__self__, "allow_challenge_ack", allow_challenge_ack)
        if asymmetric_path is not None:
            pulumi.set(__self__, "asymmetric_path", asymmetric_path)
        if bypass_exceed_oo_queue is not None:
            pulumi.set(__self__, "bypass_exceed_oo_queue", bypass_exceed_oo_queue)
        if check_timestamp_option is not None:
            pulumi.set(__self__, "check_timestamp_option", check_timestamp_option)
        if drop_zero_flag is not None:
            pulumi.set(__self__, "drop_zero_flag", drop_zero_flag)
        if siptcp_cleartext_proxy is not None:
            pulumi.set(__self__, "siptcp_cleartext_proxy", siptcp_cleartext_proxy)
        if strip_mptcp_option is not None:
            pulumi.set(__self__, "strip_mptcp_option", strip_mptcp_option)
        if tcp_retransmit_scan is not None:
            pulumi.set(__self__, "tcp_retransmit_scan", tcp_retransmit_scan)
        if urgent_data is not None:
            pulumi.set(__self__, "urgent_data", urgent_data)

    @_builtins.property
    @pulumi.getter(name="allowChallengeAck")
    def allow_challenge_ack(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow arbitrary ACK in response to SYN?
        """
        return pulumi.get(self, "allow_challenge_ack")

    @allow_challenge_ack.setter
    def allow_challenge_ack(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_challenge_ack", value)

    @_builtins.property
    @pulumi.getter(name="asymmetricPath")
    def asymmetric_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Asymmetric path action
        """
        return pulumi.get(self, "asymmetric_path")

    @asymmetric_path.setter
    def asymmetric_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "asymmetric_path", value)

    @_builtins.property
    @pulumi.getter(name="bypassExceedOoQueue")
    def bypass_exceed_oo_queue(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Forward segments exceeding TCP out-of-order queue?
        """
        return pulumi.get(self, "bypass_exceed_oo_queue")

    @bypass_exceed_oo_queue.setter
    def bypass_exceed_oo_queue(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bypass_exceed_oo_queue", value)

    @_builtins.property
    @pulumi.getter(name="checkTimestampOption")
    def check_timestamp_option(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop segments with null timestamp option?
        """
        return pulumi.get(self, "check_timestamp_option")

    @check_timestamp_option.setter
    def check_timestamp_option(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "check_timestamp_option", value)

    @_builtins.property
    @pulumi.getter(name="dropZeroFlag")
    def drop_zero_flag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop segments without flag?
        """
        return pulumi.get(self, "drop_zero_flag")

    @drop_zero_flag.setter
    def drop_zero_flag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_zero_flag", value)

    @_builtins.property
    @pulumi.getter(name="siptcpCleartextProxy")
    def siptcp_cleartext_proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SIP TCP cleartext action (`'0'` = Always Off, `'1'` = Always Enabled, `'2'` = Automatically enable proxy when needed)
        """
        return pulumi.get(self, "siptcp_cleartext_proxy")

    @siptcp_cleartext_proxy.setter
    def siptcp_cleartext_proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "siptcp_cleartext_proxy", value)

    @_builtins.property
    @pulumi.getter(name="stripMptcpOption")
    def strip_mptcp_option(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Strip MPTCP option?
        """
        return pulumi.get(self, "strip_mptcp_option")

    @strip_mptcp_option.setter
    def strip_mptcp_option(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strip_mptcp_option", value)

    @_builtins.property
    @pulumi.getter(name="tcpRetransmitScan")
    def tcp_retransmit_scan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        TCP retransmit scan?
        """
        return pulumi.get(self, "tcp_retransmit_scan")

    @tcp_retransmit_scan.setter
    def tcp_retransmit_scan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tcp_retransmit_scan", value)

    @_builtins.property
    @pulumi.getter(name="urgentData")
    def urgent_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Urgent data flag action
        """
        return pulumi.get(self, "urgent_data")

    @urgent_data.setter
    def urgent_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "urgent_data", value)


if not MYPY:
    class TlsServiceProfileProtocolSettingsArgsDict(TypedDict):
        auth_algo_sha1: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow SHA1 authentication?
        """
        auth_algo_sha256: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow SHA256 authentication?
        """
        auth_algo_sha384: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow SHA384 authentication?
        """
        enc_algo_aes128_cbc: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow AES-128-CBC algorithm?
        """
        enc_algo_aes128_gcm: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow AES-128-GCM algorithm?
        """
        enc_algo_aes256_cbc: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow AES-256-CBC algorithm?
        """
        enc_algo_aes256_gcm: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow algorithm AES-256-GCM
        """
        keyxchg_algo_dhe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow DHE algorithm?
        """
        keyxchg_algo_ecdhe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow ECDHE algorithm?
        """
        keyxchg_algo_rsa: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow RSA algorithm?
        """
        max_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum TLS version
        """
        min_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum TLS version
        """
elif False:
    TlsServiceProfileProtocolSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsServiceProfileProtocolSettingsArgs:
    def __init__(__self__, *,
                 auth_algo_sha1: Optional[pulumi.Input[_builtins.bool]] = None,
                 auth_algo_sha256: Optional[pulumi.Input[_builtins.bool]] = None,
                 auth_algo_sha384: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes128_cbc: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes128_gcm: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes256_cbc: Optional[pulumi.Input[_builtins.bool]] = None,
                 enc_algo_aes256_gcm: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyxchg_algo_dhe: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyxchg_algo_ecdhe: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyxchg_algo_rsa: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_version: Optional[pulumi.Input[_builtins.str]] = None,
                 min_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] auth_algo_sha1: Allow SHA1 authentication?
        :param pulumi.Input[_builtins.bool] auth_algo_sha256: Allow SHA256 authentication?
        :param pulumi.Input[_builtins.bool] auth_algo_sha384: Allow SHA384 authentication?
        :param pulumi.Input[_builtins.bool] enc_algo_aes128_cbc: Allow AES-128-CBC algorithm?
        :param pulumi.Input[_builtins.bool] enc_algo_aes128_gcm: Allow AES-128-GCM algorithm?
        :param pulumi.Input[_builtins.bool] enc_algo_aes256_cbc: Allow AES-256-CBC algorithm?
        :param pulumi.Input[_builtins.bool] enc_algo_aes256_gcm: Allow algorithm AES-256-GCM
        :param pulumi.Input[_builtins.bool] keyxchg_algo_dhe: Allow DHE algorithm?
        :param pulumi.Input[_builtins.bool] keyxchg_algo_ecdhe: Allow ECDHE algorithm?
        :param pulumi.Input[_builtins.bool] keyxchg_algo_rsa: Allow RSA algorithm?
        :param pulumi.Input[_builtins.str] max_version: Maximum TLS version
        :param pulumi.Input[_builtins.str] min_version: Minimum TLS version
        """
        if auth_algo_sha1 is not None:
            pulumi.set(__self__, "auth_algo_sha1", auth_algo_sha1)
        if auth_algo_sha256 is not None:
            pulumi.set(__self__, "auth_algo_sha256", auth_algo_sha256)
        if auth_algo_sha384 is not None:
            pulumi.set(__self__, "auth_algo_sha384", auth_algo_sha384)
        if enc_algo_aes128_cbc is not None:
            pulumi.set(__self__, "enc_algo_aes128_cbc", enc_algo_aes128_cbc)
        if enc_algo_aes128_gcm is not None:
            pulumi.set(__self__, "enc_algo_aes128_gcm", enc_algo_aes128_gcm)
        if enc_algo_aes256_cbc is not None:
            pulumi.set(__self__, "enc_algo_aes256_cbc", enc_algo_aes256_cbc)
        if enc_algo_aes256_gcm is not None:
            pulumi.set(__self__, "enc_algo_aes256_gcm", enc_algo_aes256_gcm)
        if keyxchg_algo_dhe is not None:
            pulumi.set(__self__, "keyxchg_algo_dhe", keyxchg_algo_dhe)
        if keyxchg_algo_ecdhe is not None:
            pulumi.set(__self__, "keyxchg_algo_ecdhe", keyxchg_algo_ecdhe)
        if keyxchg_algo_rsa is not None:
            pulumi.set(__self__, "keyxchg_algo_rsa", keyxchg_algo_rsa)
        if max_version is not None:
            pulumi.set(__self__, "max_version", max_version)
        if min_version is not None:
            pulumi.set(__self__, "min_version", min_version)

    @_builtins.property
    @pulumi.getter(name="authAlgoSha1")
    def auth_algo_sha1(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow SHA1 authentication?
        """
        return pulumi.get(self, "auth_algo_sha1")

    @auth_algo_sha1.setter
    def auth_algo_sha1(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_sha1", value)

    @_builtins.property
    @pulumi.getter(name="authAlgoSha256")
    def auth_algo_sha256(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow SHA256 authentication?
        """
        return pulumi.get(self, "auth_algo_sha256")

    @auth_algo_sha256.setter
    def auth_algo_sha256(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_sha256", value)

    @_builtins.property
    @pulumi.getter(name="authAlgoSha384")
    def auth_algo_sha384(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow SHA384 authentication?
        """
        return pulumi.get(self, "auth_algo_sha384")

    @auth_algo_sha384.setter
    def auth_algo_sha384(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auth_algo_sha384", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes128Cbc")
    def enc_algo_aes128_cbc(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow AES-128-CBC algorithm?
        """
        return pulumi.get(self, "enc_algo_aes128_cbc")

    @enc_algo_aes128_cbc.setter
    def enc_algo_aes128_cbc(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes128_cbc", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes128Gcm")
    def enc_algo_aes128_gcm(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow AES-128-GCM algorithm?
        """
        return pulumi.get(self, "enc_algo_aes128_gcm")

    @enc_algo_aes128_gcm.setter
    def enc_algo_aes128_gcm(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes128_gcm", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes256Cbc")
    def enc_algo_aes256_cbc(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow AES-256-CBC algorithm?
        """
        return pulumi.get(self, "enc_algo_aes256_cbc")

    @enc_algo_aes256_cbc.setter
    def enc_algo_aes256_cbc(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes256_cbc", value)

    @_builtins.property
    @pulumi.getter(name="encAlgoAes256Gcm")
    def enc_algo_aes256_gcm(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow algorithm AES-256-GCM
        """
        return pulumi.get(self, "enc_algo_aes256_gcm")

    @enc_algo_aes256_gcm.setter
    def enc_algo_aes256_gcm(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enc_algo_aes256_gcm", value)

    @_builtins.property
    @pulumi.getter(name="keyxchgAlgoDhe")
    def keyxchg_algo_dhe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow DHE algorithm?
        """
        return pulumi.get(self, "keyxchg_algo_dhe")

    @keyxchg_algo_dhe.setter
    def keyxchg_algo_dhe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keyxchg_algo_dhe", value)

    @_builtins.property
    @pulumi.getter(name="keyxchgAlgoEcdhe")
    def keyxchg_algo_ecdhe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow ECDHE algorithm?
        """
        return pulumi.get(self, "keyxchg_algo_ecdhe")

    @keyxchg_algo_ecdhe.setter
    def keyxchg_algo_ecdhe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keyxchg_algo_ecdhe", value)

    @_builtins.property
    @pulumi.getter(name="keyxchgAlgoRsa")
    def keyxchg_algo_rsa(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow RSA algorithm?
        """
        return pulumi.get(self, "keyxchg_algo_rsa")

    @keyxchg_algo_rsa.setter
    def keyxchg_algo_rsa(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keyxchg_algo_rsa", value)

    @_builtins.property
    @pulumi.getter(name="maxVersion")
    def max_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum TLS version
        """
        return pulumi.get(self, "max_version")

    @max_version.setter
    def max_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_version", value)

    @_builtins.property
    @pulumi.getter(name="minVersion")
    def min_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum TLS version
        """
        return pulumi.get(self, "min_version")

    @min_version.setter
    def min_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_version", value)


if not MYPY:
    class TrafficSteeringRuleActionArgsDict(TypedDict):
        forward: NotRequired[pulumi.Input['TrafficSteeringRuleActionForwardArgsDict']]
        """
        Forward
        """
elif False:
    TrafficSteeringRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficSteeringRuleActionArgs:
    def __init__(__self__, *,
                 forward: Optional[pulumi.Input['TrafficSteeringRuleActionForwardArgs']] = None):
        """
        :param pulumi.Input['TrafficSteeringRuleActionForwardArgs'] forward: Forward
        """
        if forward is not None:
            pulumi.set(__self__, "forward", forward)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input['TrafficSteeringRuleActionForwardArgs']]:
        """
        Forward
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input['TrafficSteeringRuleActionForwardArgs']]):
        pulumi.set(self, "forward", value)


if not MYPY:
    class TrafficSteeringRuleActionForwardArgsDict(TypedDict):
        forward: NotRequired[pulumi.Input['TrafficSteeringRuleActionForwardForwardArgsDict']]
        """
        Forward
        """
        no_pbf: NotRequired[pulumi.Input['TrafficSteeringRuleActionForwardNoPbfArgsDict']]
        """
        No pbf
        """
elif False:
    TrafficSteeringRuleActionForwardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficSteeringRuleActionForwardArgs:
    def __init__(__self__, *,
                 forward: Optional[pulumi.Input['TrafficSteeringRuleActionForwardForwardArgs']] = None,
                 no_pbf: Optional[pulumi.Input['TrafficSteeringRuleActionForwardNoPbfArgs']] = None):
        """
        :param pulumi.Input['TrafficSteeringRuleActionForwardForwardArgs'] forward: Forward
        :param pulumi.Input['TrafficSteeringRuleActionForwardNoPbfArgs'] no_pbf: No pbf
        """
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if no_pbf is not None:
            pulumi.set(__self__, "no_pbf", no_pbf)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input['TrafficSteeringRuleActionForwardForwardArgs']]:
        """
        Forward
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input['TrafficSteeringRuleActionForwardForwardArgs']]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter(name="noPbf")
    def no_pbf(self) -> Optional[pulumi.Input['TrafficSteeringRuleActionForwardNoPbfArgs']]:
        """
        No pbf
        """
        return pulumi.get(self, "no_pbf")

    @no_pbf.setter
    def no_pbf(self, value: Optional[pulumi.Input['TrafficSteeringRuleActionForwardNoPbfArgs']]):
        pulumi.set(self, "no_pbf", value)


if not MYPY:
    class TrafficSteeringRuleActionForwardForwardArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target
        """
elif False:
    TrafficSteeringRuleActionForwardForwardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficSteeringRuleActionForwardForwardArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target: Target
        """
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class TrafficSteeringRuleActionForwardNoPbfArgsDict(TypedDict):
        pass
elif False:
    TrafficSteeringRuleActionForwardNoPbfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficSteeringRuleActionForwardNoPbfArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class TunnelInterfaceIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Tunnel Interface IP address(es)
        """
elif False:
    TunnelInterfaceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelInterfaceIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Tunnel Interface IP address(es)
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Tunnel Interface IP address(es)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TunnelInterfaceIpv6ArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TunnelInterfaceIpv6AddressArgsDict']]]]
        """
        IPv6 Address Parent
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable IPv6
        """
        interface_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interface ID
        """
elif False:
    TunnelInterfaceIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelInterfaceIpv6Args:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelInterfaceIpv6AddressArgs']]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 interface_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TunnelInterfaceIpv6AddressArgs']]] addresses: IPv6 Address Parent
        :param pulumi.Input[_builtins.bool] enabled: Enable IPv6
        :param pulumi.Input[_builtins.str] interface_id: Interface ID
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interface_id is not None:
            pulumi.set(__self__, "interface_id", interface_id)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TunnelInterfaceIpv6AddressArgs']]]]:
        """
        IPv6 Address Parent
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelInterfaceIpv6AddressArgs']]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable IPv6
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interface ID
        """
        return pulumi.get(self, "interface_id")

    @interface_id.setter
    def interface_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface_id", value)


if not MYPY:
    class TunnelInterfaceIpv6AddressArgsDict(TypedDict):
        anycast: NotRequired[pulumi.Input['TunnelInterfaceIpv6AddressAnycastArgsDict']]
        """
        Anycast
        """
        enable_on_interface: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Address on Interface
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv6 Address
        """
        prefix: NotRequired[pulumi.Input['TunnelInterfaceIpv6AddressPrefixArgsDict']]
        """
        Use interface ID as host portion
        """
elif False:
    TunnelInterfaceIpv6AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelInterfaceIpv6AddressArgs:
    def __init__(__self__, *,
                 anycast: Optional[pulumi.Input['TunnelInterfaceIpv6AddressAnycastArgs']] = None,
                 enable_on_interface: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input['TunnelInterfaceIpv6AddressPrefixArgs']] = None):
        """
        :param pulumi.Input['TunnelInterfaceIpv6AddressAnycastArgs'] anycast: Anycast
        :param pulumi.Input[_builtins.bool] enable_on_interface: Enable Address on Interface
        :param pulumi.Input[_builtins.str] name: IPv6 Address
        :param pulumi.Input['TunnelInterfaceIpv6AddressPrefixArgs'] prefix: Use interface ID as host portion
        """
        if anycast is not None:
            pulumi.set(__self__, "anycast", anycast)
        if enable_on_interface is not None:
            pulumi.set(__self__, "enable_on_interface", enable_on_interface)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def anycast(self) -> Optional[pulumi.Input['TunnelInterfaceIpv6AddressAnycastArgs']]:
        """
        Anycast
        """
        return pulumi.get(self, "anycast")

    @anycast.setter
    def anycast(self, value: Optional[pulumi.Input['TunnelInterfaceIpv6AddressAnycastArgs']]):
        pulumi.set(self, "anycast", value)

    @_builtins.property
    @pulumi.getter(name="enableOnInterface")
    def enable_on_interface(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Address on Interface
        """
        return pulumi.get(self, "enable_on_interface")

    @enable_on_interface.setter
    def enable_on_interface(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_on_interface", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv6 Address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input['TunnelInterfaceIpv6AddressPrefixArgs']]:
        """
        Use interface ID as host portion
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input['TunnelInterfaceIpv6AddressPrefixArgs']]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class TunnelInterfaceIpv6AddressAnycastArgsDict(TypedDict):
        pass
elif False:
    TunnelInterfaceIpv6AddressAnycastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelInterfaceIpv6AddressAnycastArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class TunnelInterfaceIpv6AddressPrefixArgsDict(TypedDict):
        pass
elif False:
    TunnelInterfaceIpv6AddressPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelInterfaceIpv6AddressPrefixArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UpdateScheduleUpdateScheduleArgsDict(TypedDict):
        anti_virus: pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusArgsDict']
        """
        Anti virus
        """
        threats: pulumi.Input['UpdateScheduleUpdateScheduleThreatsArgsDict']
        """
        Threats
        """
        wildfire: pulumi.Input['UpdateScheduleUpdateScheduleWildfireArgsDict']
        """
        Wildfire
        """
elif False:
    UpdateScheduleUpdateScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleArgs:
    def __init__(__self__, *,
                 anti_virus: pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusArgs'],
                 threats: pulumi.Input['UpdateScheduleUpdateScheduleThreatsArgs'],
                 wildfire: pulumi.Input['UpdateScheduleUpdateScheduleWildfireArgs']):
        """
        :param pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusArgs'] anti_virus: Anti virus
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsArgs'] threats: Threats
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireArgs'] wildfire: Wildfire
        """
        pulumi.set(__self__, "anti_virus", anti_virus)
        pulumi.set(__self__, "threats", threats)
        pulumi.set(__self__, "wildfire", wildfire)

    @_builtins.property
    @pulumi.getter(name="antiVirus")
    def anti_virus(self) -> pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusArgs']:
        """
        Anti virus
        """
        return pulumi.get(self, "anti_virus")

    @anti_virus.setter
    def anti_virus(self, value: pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusArgs']):
        pulumi.set(self, "anti_virus", value)

    @_builtins.property
    @pulumi.getter
    def threats(self) -> pulumi.Input['UpdateScheduleUpdateScheduleThreatsArgs']:
        """
        Threats
        """
        return pulumi.get(self, "threats")

    @threats.setter
    def threats(self, value: pulumi.Input['UpdateScheduleUpdateScheduleThreatsArgs']):
        pulumi.set(self, "threats", value)

    @_builtins.property
    @pulumi.getter
    def wildfire(self) -> pulumi.Input['UpdateScheduleUpdateScheduleWildfireArgs']:
        """
        Wildfire
        """
        return pulumi.get(self, "wildfire")

    @wildfire.setter
    def wildfire(self, value: pulumi.Input['UpdateScheduleUpdateScheduleWildfireArgs']):
        pulumi.set(self, "wildfire", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleAntiVirusArgsDict(TypedDict):
        recurring: pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringArgsDict']
        """
        Recurring
        """
elif False:
    UpdateScheduleUpdateScheduleAntiVirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleAntiVirusArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringArgs']):
        """
        :param pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringArgs'] recurring: Recurring
        """
        pulumi.set(__self__, "recurring", recurring)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringArgs']:
        """
        Recurring
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringArgs']):
        pulumi.set(self, "recurring", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleAntiVirusRecurringArgsDict(TypedDict):
        sync_to_peer: pulumi.Input[_builtins.bool]
        """
        Sync to peer
        """
        daily: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgsDict']]
        """
        Daily
        """
        hourly: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgsDict']]
        """
        Hourly

        >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
        none: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold
        """
        weekly: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgsDict']]
        """
        Weekly

        >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
elif False:
    UpdateScheduleUpdateScheduleAntiVirusRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleAntiVirusRecurringArgs:
    def __init__(__self__, *,
                 sync_to_peer: pulumi.Input[_builtins.bool],
                 daily: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgs']] = None,
                 hourly: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgs']] = None,
                 none: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgs']] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 weekly: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] sync_to_peer: Sync to peer
        :param pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgs'] daily: Daily
        :param pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgs'] hourly: Hourly
               
               >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        :param pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        :param pulumi.Input[_builtins.int] threshold: Threshold
        :param pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgs'] weekly: Weekly
               
               >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
        pulumi.set(__self__, "sync_to_peer", sync_to_peer)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter(name="syncToPeer")
    def sync_to_peer(self) -> pulumi.Input[_builtins.bool]:
        """
        Sync to peer
        """
        return pulumi.get(self, "sync_to_peer")

    @sync_to_peer.setter
    def sync_to_peer(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "sync_to_peer", value)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgs']]:
        """
        Daily
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgs']]:
        """
        Hourly

        >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgs']]:
        """
        Weekly

        >  **Note:** You must specify exactly one of `daily`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        At
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
elif False:
    UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleAntiVirusRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] at: At
        :param pulumi.Input[_builtins.str] action: Action
        """
        pulumi.set(__self__, "at", at)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.int]
        """
        At
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
elif False:
    UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleAntiVirusRecurringHourlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.int],
                 action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] at: At
        :param pulumi.Input[_builtins.str] action: Action
        """
        pulumi.set(__self__, "at", at)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.int]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgsDict(TypedDict):
        pass
elif False:
    UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleAntiVirusRecurringNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        at: NotRequired[pulumi.Input[_builtins.str]]
        """
        At
        """
        day_of_week: NotRequired[pulumi.Input[_builtins.str]]
        """
        Day of week
        """
elif False:
    UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleAntiVirusRecurringWeeklyArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 at: Optional[pulumi.Input[_builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.str] at: At
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if at is not None:
            pulumi.set(__self__, "at", at)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsArgsDict(TypedDict):
        recurring: pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringArgsDict']
        """
        Recurring
        """
elif False:
    UpdateScheduleUpdateScheduleThreatsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringArgs']):
        """
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringArgs'] recurring: Recurring
        """
        pulumi.set(__self__, "recurring", recurring)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringArgs']:
        """
        Recurring
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringArgs']):
        pulumi.set(self, "recurring", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsRecurringArgsDict(TypedDict):
        sync_to_peer: pulumi.Input[_builtins.bool]
        """
        Sync to peer
        """
        daily: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringDailyArgsDict']]
        """
        Daily
        """
        every30_mins: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgsDict']]
        """
        Every30 mins

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        hourly: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgsDict']]
        """
        Hourly

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        new_app_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        New app threshold
        """
        none: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold
        """
        weekly: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgsDict']]
        """
        Weekly

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
elif False:
    UpdateScheduleUpdateScheduleThreatsRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsRecurringArgs:
    def __init__(__self__, *,
                 sync_to_peer: pulumi.Input[_builtins.bool],
                 daily: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringDailyArgs']] = None,
                 every30_mins: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgs']] = None,
                 hourly: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgs']] = None,
                 new_app_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 none: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringNoneArgs']] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 weekly: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] sync_to_peer: Sync to peer
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringDailyArgs'] daily: Daily
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgs'] every30_mins: Every30 mins
               
               >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgs'] hourly: Hourly
               
               >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        :param pulumi.Input[_builtins.int] new_app_threshold: New app threshold
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        :param pulumi.Input[_builtins.int] threshold: Threshold
        :param pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgs'] weekly: Weekly
               
               >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        pulumi.set(__self__, "sync_to_peer", sync_to_peer)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if every30_mins is not None:
            pulumi.set(__self__, "every30_mins", every30_mins)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if new_app_threshold is not None:
            pulumi.set(__self__, "new_app_threshold", new_app_threshold)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter(name="syncToPeer")
    def sync_to_peer(self) -> pulumi.Input[_builtins.bool]:
        """
        Sync to peer
        """
        return pulumi.get(self, "sync_to_peer")

    @sync_to_peer.setter
    def sync_to_peer(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "sync_to_peer", value)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringDailyArgs']]:
        """
        Daily
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringDailyArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="every30Mins")
    def every30_mins(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgs']]:
        """
        Every30 mins

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "every30_mins")

    @every30_mins.setter
    def every30_mins(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgs']]):
        pulumi.set(self, "every30_mins", value)

    @_builtins.property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgs']]:
        """
        Hourly

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @_builtins.property
    @pulumi.getter(name="newAppThreshold")
    def new_app_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        New app threshold
        """
        return pulumi.get(self, "new_app_threshold")

    @new_app_threshold.setter
    def new_app_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "new_app_threshold", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgs']]:
        """
        Weekly

        >  **Note:** You must specify exactly one of `daily`, `every_30_mins`, `hourly`, `none`, and `weekly`.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsRecurringDailyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        At
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        disable_new_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable new content
        """
elif False:
    UpdateScheduleUpdateScheduleThreatsRecurringDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsRecurringDailyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_new_content: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] at: At
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.bool] disable_new_content: Disable new content
        """
        pulumi.set(__self__, "at", at)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if disable_new_content is not None:
            pulumi.set(__self__, "disable_new_content", disable_new_content)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="disableNewContent")
    def disable_new_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable new content
        """
        return pulumi.get(self, "disable_new_content")

    @disable_new_content.setter
    def disable_new_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_new_content", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        at: NotRequired[pulumi.Input[_builtins.int]]
        """
        At
        """
        disable_new_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable new content
        """
elif False:
    UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsRecurringEvery30MinsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 at: Optional[pulumi.Input[_builtins.int]] = None,
                 disable_new_content: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.int] at: At
        :param pulumi.Input[_builtins.bool] disable_new_content: Disable new content
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if at is not None:
            pulumi.set(__self__, "at", at)
        if disable_new_content is not None:
            pulumi.set(__self__, "disable_new_content", disable_new_content)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="disableNewContent")
    def disable_new_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable new content
        """
        return pulumi.get(self, "disable_new_content")

    @disable_new_content.setter
    def disable_new_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_new_content", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.float]
        """
        At
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        disable_new_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable new content
        """
elif False:
    UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsRecurringHourlyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.float],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_new_content: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.float] at: At
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.bool] disable_new_content: Disable new content
        """
        pulumi.set(__self__, "at", at)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if disable_new_content is not None:
            pulumi.set(__self__, "disable_new_content", disable_new_content)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.float]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="disableNewContent")
    def disable_new_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable new content
        """
        return pulumi.get(self, "disable_new_content")

    @disable_new_content.setter
    def disable_new_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_new_content", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsRecurringNoneArgsDict(TypedDict):
        pass
elif False:
    UpdateScheduleUpdateScheduleThreatsRecurringNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsRecurringNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgsDict(TypedDict):
        at: pulumi.Input[_builtins.str]
        """
        At
        """
        day_of_week: pulumi.Input[_builtins.str]
        """
        Day of week
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        disable_new_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable new content
        """
elif False:
    UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleThreatsRecurringWeeklyArgs:
    def __init__(__self__, *,
                 at: pulumi.Input[_builtins.str],
                 day_of_week: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_new_content: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] at: At
        :param pulumi.Input[_builtins.str] day_of_week: Day of week
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.bool] disable_new_content: Disable new content
        """
        pulumi.set(__self__, "at", at)
        pulumi.set(__self__, "day_of_week", day_of_week)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if disable_new_content is not None:
            pulumi.set(__self__, "disable_new_content", disable_new_content)

    @_builtins.property
    @pulumi.getter
    def at(self) -> pulumi.Input[_builtins.str]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        """
        Day of week
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="disableNewContent")
    def disable_new_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable new content
        """
        return pulumi.get(self, "disable_new_content")

    @disable_new_content.setter
    def disable_new_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_new_content", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireArgsDict(TypedDict):
        recurring: pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringArgsDict']
        """
        Recurring
        """
elif False:
    UpdateScheduleUpdateScheduleWildfireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireArgs:
    def __init__(__self__, *,
                 recurring: pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringArgs']):
        """
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringArgs'] recurring: Recurring
        """
        pulumi.set(__self__, "recurring", recurring)

    @_builtins.property
    @pulumi.getter
    def recurring(self) -> pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringArgs']:
        """
        Recurring
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringArgs']):
        pulumi.set(self, "recurring", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringArgsDict(TypedDict):
        every15_mins: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgsDict']]
        """
        Every15 mins
        """
        every30_mins: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgsDict']]
        """
        Every30 mins

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        every_hour: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgsDict']]
        """
        Every hour

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        every_min: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgsDict']]
        """
        Every min

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        none: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringNoneArgsDict']]
        """
        None

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        real_time: NotRequired[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgsDict']]
        """
        Real time

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringArgs:
    def __init__(__self__, *,
                 every15_mins: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgs']] = None,
                 every30_mins: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgs']] = None,
                 every_hour: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgs']] = None,
                 every_min: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgs']] = None,
                 none: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringNoneArgs']] = None,
                 real_time: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgs']] = None):
        """
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgs'] every15_mins: Every15 mins
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgs'] every30_mins: Every30 mins
               
               >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgs'] every_hour: Every hour
               
               >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgs'] every_min: Every min
               
               >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringNoneArgs'] none: None
               
               >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        :param pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgs'] real_time: Real time
               
               >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        if every15_mins is not None:
            pulumi.set(__self__, "every15_mins", every15_mins)
        if every30_mins is not None:
            pulumi.set(__self__, "every30_mins", every30_mins)
        if every_hour is not None:
            pulumi.set(__self__, "every_hour", every_hour)
        if every_min is not None:
            pulumi.set(__self__, "every_min", every_min)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if real_time is not None:
            pulumi.set(__self__, "real_time", real_time)

    @_builtins.property
    @pulumi.getter(name="every15Mins")
    def every15_mins(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgs']]:
        """
        Every15 mins
        """
        return pulumi.get(self, "every15_mins")

    @every15_mins.setter
    def every15_mins(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgs']]):
        pulumi.set(self, "every15_mins", value)

    @_builtins.property
    @pulumi.getter(name="every30Mins")
    def every30_mins(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgs']]:
        """
        Every30 mins

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        return pulumi.get(self, "every30_mins")

    @every30_mins.setter
    def every30_mins(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgs']]):
        pulumi.set(self, "every30_mins", value)

    @_builtins.property
    @pulumi.getter(name="everyHour")
    def every_hour(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgs']]:
        """
        Every hour

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        return pulumi.get(self, "every_hour")

    @every_hour.setter
    def every_hour(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgs']]):
        pulumi.set(self, "every_hour", value)

    @_builtins.property
    @pulumi.getter(name="everyMin")
    def every_min(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgs']]:
        """
        Every min

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        return pulumi.get(self, "every_min")

    @every_min.setter
    def every_min(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgs']]):
        pulumi.set(self, "every_min", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringNoneArgs']]:
        """
        None

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringNoneArgs']]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter(name="realTime")
    def real_time(self) -> Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgs']]:
        """
        Real time

        >  **Note:** You must specify exactly one of `every_15_mins`, `every_30_mins`, `every_hour`, `every_min`, `none`, and `real_time`.
        """
        return pulumi.get(self, "real_time")

    @real_time.setter
    def real_time(self, value: Optional[pulumi.Input['UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgs']]):
        pulumi.set(self, "real_time", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        at: NotRequired[pulumi.Input[_builtins.int]]
        """
        At
        """
        sync_to_peer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sync to peer
        """
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringEvery15MinsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 at: Optional[pulumi.Input[_builtins.int]] = None,
                 sync_to_peer: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.int] at: At
        :param pulumi.Input[_builtins.bool] sync_to_peer: Sync to peer
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if at is not None:
            pulumi.set(__self__, "at", at)
        if sync_to_peer is not None:
            pulumi.set(__self__, "sync_to_peer", sync_to_peer)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="syncToPeer")
    def sync_to_peer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sync to peer
        """
        return pulumi.get(self, "sync_to_peer")

    @sync_to_peer.setter
    def sync_to_peer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_to_peer", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        at: NotRequired[pulumi.Input[_builtins.int]]
        """
        At
        """
        sync_to_peer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sync to peer
        """
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringEvery30MinsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 at: Optional[pulumi.Input[_builtins.int]] = None,
                 sync_to_peer: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.int] at: At
        :param pulumi.Input[_builtins.bool] sync_to_peer: Sync to peer
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if at is not None:
            pulumi.set(__self__, "at", at)
        if sync_to_peer is not None:
            pulumi.set(__self__, "sync_to_peer", sync_to_peer)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="syncToPeer")
    def sync_to_peer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sync to peer
        """
        return pulumi.get(self, "sync_to_peer")

    @sync_to_peer.setter
    def sync_to_peer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_to_peer", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        at: NotRequired[pulumi.Input[_builtins.int]]
        """
        At
        """
        sync_to_peer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sync to peer
        """
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringEveryHourArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 at: Optional[pulumi.Input[_builtins.int]] = None,
                 sync_to_peer: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.int] at: At
        :param pulumi.Input[_builtins.bool] sync_to_peer: Sync to peer
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if at is not None:
            pulumi.set(__self__, "at", at)
        if sync_to_peer is not None:
            pulumi.set(__self__, "sync_to_peer", sync_to_peer)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        At
        """
        return pulumi.get(self, "at")

    @at.setter
    def at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "at", value)

    @_builtins.property
    @pulumi.getter(name="syncToPeer")
    def sync_to_peer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sync to peer
        """
        return pulumi.get(self, "sync_to_peer")

    @sync_to_peer.setter
    def sync_to_peer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_to_peer", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action
        """
        sync_to_peer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sync to peer
        """
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringEveryMinArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 sync_to_peer: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action
        :param pulumi.Input[_builtins.bool] sync_to_peer: Sync to peer
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if sync_to_peer is not None:
            pulumi.set(__self__, "sync_to_peer", sync_to_peer)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="syncToPeer")
    def sync_to_peer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sync to peer
        """
        return pulumi.get(self, "sync_to_peer")

    @sync_to_peer.setter
    def sync_to_peer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_to_peer", value)


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringNoneArgsDict(TypedDict):
        pass
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgsDict(TypedDict):
        pass
elif False:
    UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateScheduleUpdateScheduleWildfireRecurringRealTimeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UrlAccessProfileCredentialEnforcementArgsDict(TypedDict):
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Alert
        """
        allows: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allow
        """
        blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Block
        """
        continues: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Continue
        """
        log_severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log severity
        """
        mode: NotRequired[pulumi.Input['UrlAccessProfileCredentialEnforcementModeArgsDict']]
        """
        Mode
        """
elif False:
    UrlAccessProfileCredentialEnforcementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UrlAccessProfileCredentialEnforcementArgs:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allows: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 blocks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 continues: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_severity: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alerts: Alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allows: Allow
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] blocks: Block
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] continues: Continue
        :param pulumi.Input[_builtins.str] log_severity: Log severity
        :param pulumi.Input['UrlAccessProfileCredentialEnforcementModeArgs'] mode: Mode
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if continues is not None:
            pulumi.set(__self__, "continues", continues)
        if log_severity is not None:
            pulumi.set(__self__, "log_severity", log_severity)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Alert
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter
    def allows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allow
        """
        return pulumi.get(self, "allows")

    @allows.setter
    def allows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allows", value)

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Block
        """
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "blocks", value)

    @_builtins.property
    @pulumi.getter
    def continues(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Continue
        """
        return pulumi.get(self, "continues")

    @continues.setter
    def continues(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "continues", value)

    @_builtins.property
    @pulumi.getter(name="logSeverity")
    def log_severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log severity
        """
        return pulumi.get(self, "log_severity")

    @log_severity.setter
    def log_severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_severity", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeArgs']]:
        """
        Mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeArgs']]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class UrlAccessProfileCredentialEnforcementModeArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDisabledArgsDict']]
        """
        Disabled
        """
        domain_credentials: NotRequired[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgsDict']]
        """
        Domain credentials
        """
        group_mapping: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group mapping
        """
        ip_user: NotRequired[pulumi.Input['UrlAccessProfileCredentialEnforcementModeIpUserArgsDict']]
        """
        Ip user
        """
elif False:
    UrlAccessProfileCredentialEnforcementModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UrlAccessProfileCredentialEnforcementModeArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDisabledArgs']] = None,
                 domain_credentials: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgs']] = None,
                 group_mapping: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_user: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeIpUserArgs']] = None):
        """
        :param pulumi.Input['UrlAccessProfileCredentialEnforcementModeDisabledArgs'] disabled: Disabled
        :param pulumi.Input['UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgs'] domain_credentials: Domain credentials
        :param pulumi.Input[_builtins.str] group_mapping: Group mapping
        :param pulumi.Input['UrlAccessProfileCredentialEnforcementModeIpUserArgs'] ip_user: Ip user
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if domain_credentials is not None:
            pulumi.set(__self__, "domain_credentials", domain_credentials)
        if group_mapping is not None:
            pulumi.set(__self__, "group_mapping", group_mapping)
        if ip_user is not None:
            pulumi.set(__self__, "ip_user", ip_user)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDisabledArgs']]:
        """
        Disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="domainCredentials")
    def domain_credentials(self) -> Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgs']]:
        """
        Domain credentials
        """
        return pulumi.get(self, "domain_credentials")

    @domain_credentials.setter
    def domain_credentials(self, value: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgs']]):
        pulumi.set(self, "domain_credentials", value)

    @_builtins.property
    @pulumi.getter(name="groupMapping")
    def group_mapping(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group mapping
        """
        return pulumi.get(self, "group_mapping")

    @group_mapping.setter
    def group_mapping(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_mapping", value)

    @_builtins.property
    @pulumi.getter(name="ipUser")
    def ip_user(self) -> Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeIpUserArgs']]:
        """
        Ip user
        """
        return pulumi.get(self, "ip_user")

    @ip_user.setter
    def ip_user(self, value: Optional[pulumi.Input['UrlAccessProfileCredentialEnforcementModeIpUserArgs']]):
        pulumi.set(self, "ip_user", value)


if not MYPY:
    class UrlAccessProfileCredentialEnforcementModeDisabledArgsDict(TypedDict):
        pass
elif False:
    UrlAccessProfileCredentialEnforcementModeDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UrlAccessProfileCredentialEnforcementModeDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgsDict(TypedDict):
        pass
elif False:
    UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UrlAccessProfileCredentialEnforcementModeDomainCredentialsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UrlAccessProfileCredentialEnforcementModeIpUserArgsDict(TypedDict):
        pass
elif False:
    UrlAccessProfileCredentialEnforcementModeIpUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UrlAccessProfileCredentialEnforcementModeIpUserArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VlanInterfaceArpArgsDict(TypedDict):
        hw_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        MAC address
        """
        interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARP interface
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address
        """
elif False:
    VlanInterfaceArpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanInterfaceArpArgs:
    def __init__(__self__, *,
                 hw_address: Optional[pulumi.Input[_builtins.str]] = None,
                 interface: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hw_address: MAC address
        :param pulumi.Input[_builtins.str] interface: ARP interface
        :param pulumi.Input[_builtins.str] name: IP address
        """
        if hw_address is not None:
            pulumi.set(__self__, "hw_address", hw_address)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="hwAddress")
    def hw_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MAC address
        """
        return pulumi.get(self, "hw_address")

    @hw_address.setter
    def hw_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hw_address", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARP interface
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VlanInterfaceDdnsConfigArgsDict(TypedDict):
        ddns_cert_profile: pulumi.Input[_builtins.str]
        """
        Certificate profile
        """
        ddns_hostname: pulumi.Input[_builtins.str]
        """
        Ddns hostname
        """
        ddns_vendor: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_vendor_config: pulumi.Input[_builtins.str]
        """
        DDNS vendor
        """
        ddns_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DDNS?
        """
        ddns_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP to register (static only)
        """
        ddns_update_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Update interval (days)
        """
elif False:
    VlanInterfaceDdnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanInterfaceDdnsConfigArgs:
    def __init__(__self__, *,
                 ddns_cert_profile: pulumi.Input[_builtins.str],
                 ddns_hostname: pulumi.Input[_builtins.str],
                 ddns_vendor: pulumi.Input[_builtins.str],
                 ddns_vendor_config: pulumi.Input[_builtins.str],
                 ddns_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ddns_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ddns_update_interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ddns_cert_profile: Certificate profile
        :param pulumi.Input[_builtins.str] ddns_hostname: Ddns hostname
        :param pulumi.Input[_builtins.str] ddns_vendor: DDNS vendor
        :param pulumi.Input[_builtins.str] ddns_vendor_config: DDNS vendor
        :param pulumi.Input[_builtins.bool] ddns_enabled: Enable DDNS?
        :param pulumi.Input[_builtins.str] ddns_ip: IP to register (static only)
        :param pulumi.Input[_builtins.int] ddns_update_interval: Update interval (days)
        """
        pulumi.set(__self__, "ddns_cert_profile", ddns_cert_profile)
        pulumi.set(__self__, "ddns_hostname", ddns_hostname)
        pulumi.set(__self__, "ddns_vendor", ddns_vendor)
        pulumi.set(__self__, "ddns_vendor_config", ddns_vendor_config)
        if ddns_enabled is not None:
            pulumi.set(__self__, "ddns_enabled", ddns_enabled)
        if ddns_ip is not None:
            pulumi.set(__self__, "ddns_ip", ddns_ip)
        if ddns_update_interval is not None:
            pulumi.set(__self__, "ddns_update_interval", ddns_update_interval)

    @_builtins.property
    @pulumi.getter(name="ddnsCertProfile")
    def ddns_cert_profile(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate profile
        """
        return pulumi.get(self, "ddns_cert_profile")

    @ddns_cert_profile.setter
    def ddns_cert_profile(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_cert_profile", value)

    @_builtins.property
    @pulumi.getter(name="ddnsHostname")
    def ddns_hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Ddns hostname
        """
        return pulumi.get(self, "ddns_hostname")

    @ddns_hostname.setter
    def ddns_hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_hostname", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendor")
    def ddns_vendor(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor")

    @ddns_vendor.setter
    def ddns_vendor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor", value)

    @_builtins.property
    @pulumi.getter(name="ddnsVendorConfig")
    def ddns_vendor_config(self) -> pulumi.Input[_builtins.str]:
        """
        DDNS vendor
        """
        return pulumi.get(self, "ddns_vendor_config")

    @ddns_vendor_config.setter
    def ddns_vendor_config(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ddns_vendor_config", value)

    @_builtins.property
    @pulumi.getter(name="ddnsEnabled")
    def ddns_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DDNS?
        """
        return pulumi.get(self, "ddns_enabled")

    @ddns_enabled.setter
    def ddns_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ddns_enabled", value)

    @_builtins.property
    @pulumi.getter(name="ddnsIp")
    def ddns_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP to register (static only)
        """
        return pulumi.get(self, "ddns_ip")

    @ddns_ip.setter
    def ddns_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddns_ip", value)

    @_builtins.property
    @pulumi.getter(name="ddnsUpdateInterval")
    def ddns_update_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Update interval (days)
        """
        return pulumi.get(self, "ddns_update_interval")

    @ddns_update_interval.setter
    def ddns_update_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ddns_update_interval", value)


if not MYPY:
    class VlanInterfaceDhcpClientArgsDict(TypedDict):
        create_default_route: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically create default route pointing to default gateway provided by server
        """
        default_route_metric: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metric of the default route created
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable DHCP?
        """
        send_hostname: NotRequired[pulumi.Input['VlanInterfaceDhcpClientSendHostnameArgsDict']]
        """
        Send hostname
        """
elif False:
    VlanInterfaceDhcpClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanInterfaceDhcpClientArgs:
    def __init__(__self__, *,
                 create_default_route: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_route_metric: Optional[pulumi.Input[_builtins.int]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_hostname: Optional[pulumi.Input['VlanInterfaceDhcpClientSendHostnameArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] create_default_route: Automatically create default route pointing to default gateway provided by server
        :param pulumi.Input[_builtins.int] default_route_metric: Metric of the default route created
        :param pulumi.Input[_builtins.bool] enable: Enable DHCP?
        :param pulumi.Input['VlanInterfaceDhcpClientSendHostnameArgs'] send_hostname: Send hostname
        """
        if create_default_route is not None:
            pulumi.set(__self__, "create_default_route", create_default_route)
        if default_route_metric is not None:
            pulumi.set(__self__, "default_route_metric", default_route_metric)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if send_hostname is not None:
            pulumi.set(__self__, "send_hostname", send_hostname)

    @_builtins.property
    @pulumi.getter(name="createDefaultRoute")
    def create_default_route(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically create default route pointing to default gateway provided by server
        """
        return pulumi.get(self, "create_default_route")

    @create_default_route.setter
    def create_default_route(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_default_route", value)

    @_builtins.property
    @pulumi.getter(name="defaultRouteMetric")
    def default_route_metric(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metric of the default route created
        """
        return pulumi.get(self, "default_route_metric")

    @default_route_metric.setter
    def default_route_metric(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_route_metric", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable DHCP?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="sendHostname")
    def send_hostname(self) -> Optional[pulumi.Input['VlanInterfaceDhcpClientSendHostnameArgs']]:
        """
        Send hostname
        """
        return pulumi.get(self, "send_hostname")

    @send_hostname.setter
    def send_hostname(self, value: Optional[pulumi.Input['VlanInterfaceDhcpClientSendHostnameArgs']]):
        pulumi.set(self, "send_hostname", value)


if not MYPY:
    class VlanInterfaceDhcpClientSendHostnameArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set interface hostname
        """
elif False:
    VlanInterfaceDhcpClientSendHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanInterfaceDhcpClientSendHostnameArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable
        :param pulumi.Input[_builtins.str] hostname: Set interface hostname
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set interface hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class VlanInterfaceIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        VLAN Interface IP address(es)
        """
elif False:
    VlanInterfaceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanInterfaceIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: VLAN Interface IP address(es)
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        VLAN Interface IP address(es)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VpnSettingVpnArgsDict(TypedDict):
        ikev2: NotRequired[pulumi.Input['VpnSettingVpnIkev2ArgsDict']]
        """
        Ikev2
        """
elif False:
    VpnSettingVpnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnSettingVpnArgs:
    def __init__(__self__, *,
                 ikev2: Optional[pulumi.Input['VpnSettingVpnIkev2Args']] = None):
        """
        :param pulumi.Input['VpnSettingVpnIkev2Args'] ikev2: Ikev2
        """
        if ikev2 is not None:
            pulumi.set(__self__, "ikev2", ikev2)

    @_builtins.property
    @pulumi.getter
    def ikev2(self) -> Optional[pulumi.Input['VpnSettingVpnIkev2Args']]:
        """
        Ikev2
        """
        return pulumi.get(self, "ikev2")

    @ikev2.setter
    def ikev2(self, value: Optional[pulumi.Input['VpnSettingVpnIkev2Args']]):
        pulumi.set(self, "ikev2", value)


if not MYPY:
    class VpnSettingVpnIkev2ArgsDict(TypedDict):
        certificate_cache_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum cached certificates
        """
        cookie_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Cookie activation threshold
        """
        max_half_opened_sa: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum half-opened SA
        """
elif False:
    VpnSettingVpnIkev2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnSettingVpnIkev2Args:
    def __init__(__self__, *,
                 certificate_cache_size: Optional[pulumi.Input[_builtins.int]] = None,
                 cookie_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 max_half_opened_sa: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] certificate_cache_size: Maximum cached certificates
        :param pulumi.Input[_builtins.int] cookie_threshold: Cookie activation threshold
        :param pulumi.Input[_builtins.int] max_half_opened_sa: Maximum half-opened SA
        """
        if certificate_cache_size is not None:
            pulumi.set(__self__, "certificate_cache_size", certificate_cache_size)
        if cookie_threshold is not None:
            pulumi.set(__self__, "cookie_threshold", cookie_threshold)
        if max_half_opened_sa is not None:
            pulumi.set(__self__, "max_half_opened_sa", max_half_opened_sa)

    @_builtins.property
    @pulumi.getter(name="certificateCacheSize")
    def certificate_cache_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum cached certificates
        """
        return pulumi.get(self, "certificate_cache_size")

    @certificate_cache_size.setter
    def certificate_cache_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "certificate_cache_size", value)

    @_builtins.property
    @pulumi.getter(name="cookieThreshold")
    def cookie_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Cookie activation threshold
        """
        return pulumi.get(self, "cookie_threshold")

    @cookie_threshold.setter
    def cookie_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cookie_threshold", value)

    @_builtins.property
    @pulumi.getter(name="maxHalfOpenedSa")
    def max_half_opened_sa(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum half-opened SA
        """
        return pulumi.get(self, "max_half_opened_sa")

    @max_half_opened_sa.setter
    def max_half_opened_sa(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_half_opened_sa", value)


if not MYPY:
    class VulnerabilityProtectionProfileRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionArgsDict']]
        """
        vulnerability profiles threat exception default action
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Category
        """
        cves: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Cve
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        packet_capture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Packet capture
        """
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Severity
        """
        threat_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threat name
        """
        vendor_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Vendor id
        """
elif False:
    VulnerabilityProtectionProfileRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionArgs']] = None,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 cves: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 packet_capture: Optional[pulumi.Input[_builtins.str]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 threat_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vendor_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionArgs'] action: vulnerability profiles threat exception default action
        :param pulumi.Input[_builtins.str] category: Category
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cves: Cve
        :param pulumi.Input[_builtins.str] host: Host
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] packet_capture: Packet capture
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] severities: Severity
        :param pulumi.Input[_builtins.str] threat_name: Threat name
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] vendor_ids: Vendor id
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if cves is not None:
            pulumi.set(__self__, "cves", cves)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packet_capture is not None:
            pulumi.set(__self__, "packet_capture", packet_capture)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if threat_name is not None:
            pulumi.set(__self__, "threat_name", threat_name)
        if vendor_ids is not None:
            pulumi.set(__self__, "vendor_ids", vendor_ids)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionArgs']]:
        """
        vulnerability profiles threat exception default action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Category
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def cves(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Cve
        """
        return pulumi.get(self, "cves")

    @cves.setter
    def cves(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cves", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="packetCapture")
    def packet_capture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Packet capture
        """
        return pulumi.get(self, "packet_capture")

    @packet_capture.setter
    def packet_capture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packet_capture", value)

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Severity
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "severities", value)

    @_builtins.property
    @pulumi.getter(name="threatName")
    def threat_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threat name
        """
        return pulumi.get(self, "threat_name")

    @threat_name.setter
    def threat_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threat_name", value)

    @_builtins.property
    @pulumi.getter(name="vendorIds")
    def vendor_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Vendor id
        """
        return pulumi.get(self, "vendor_ids")

    @vendor_ids.setter
    def vendor_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "vendor_ids", value)


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        block_ip: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionBlockIpArgsDict']]
        """
        vulnerability protection block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        default: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionDefaultArgsDict']]
        """
        Default

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        drop: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionDropArgsDict']]
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_both: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetBothArgsDict']]
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_client: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetClientArgsDict']]
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_server: NotRequired[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetServerArgsDict']]
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
elif False:
    VulnerabilityProtectionProfileRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionAllowArgs']] = None,
                 block_ip: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionBlockIpArgs']] = None,
                 default: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionDefaultArgs']] = None,
                 drop: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionDropArgs']] = None,
                 reset_both: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetBothArgs']] = None,
                 reset_client: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetClientArgs']] = None,
                 reset_server: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetServerArgs']] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionAlertArgs'] alert: Alert
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionBlockIpArgs'] block_ip: vulnerability protection block ip
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionDefaultArgs'] default: Default
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionDropArgs'] drop: Drop
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionResetBothArgs'] reset_both: Reset both
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionResetClientArgs'] reset_client: Reset client
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileRuleActionResetServerArgs'] reset_server: Reset server
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if reset_both is not None:
            pulumi.set(__self__, "reset_both", reset_both)
        if reset_client is not None:
            pulumi.set(__self__, "reset_client", reset_client)
        if reset_server is not None:
            pulumi.set(__self__, "reset_server", reset_server)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionBlockIpArgs']]:
        """
        vulnerability protection block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionDefaultArgs']]:
        """
        Default

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionDefaultArgs']]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionDropArgs']]:
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionDropArgs']]):
        pulumi.set(self, "drop", value)

    @_builtins.property
    @pulumi.getter(name="resetBoth")
    def reset_both(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetBothArgs']]:
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_both")

    @reset_both.setter
    def reset_both(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetBothArgs']]):
        pulumi.set(self, "reset_both", value)

    @_builtins.property
    @pulumi.getter(name="resetClient")
    def reset_client(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetClientArgs']]:
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_client")

    @reset_client.setter
    def reset_client(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetClientArgs']]):
        pulumi.set(self, "reset_client", value)

    @_builtins.property
    @pulumi.getter(name="resetServer")
    def reset_server(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetServerArgs']]:
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_server")

    @reset_server.setter
    def reset_server(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileRuleActionResetServerArgs']]):
        pulumi.set(self, "reset_server", value)


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionAlertArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionAllowArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionBlockIpArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    VulnerabilityProtectionProfileRuleActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionDefaultArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionDefaultArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionDropArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionDropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionDropArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionResetBothArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionResetBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionResetBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionResetClientArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionResetClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionResetClientArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileRuleActionResetServerArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileRuleActionResetServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileRuleActionResetServerArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionArgsDict']]
        """
        vulnerability threat exception default action
        """
        exempt_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionExemptIpArgsDict']]]]
        """
        Exempt ip
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes
        """
        packet_capture: NotRequired[pulumi.Input[_builtins.str]]
        """
        Packet capture
        """
        time_attribute: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgsDict']]
        """
        vulnerability time attribute
        """
elif False:
    VulnerabilityProtectionProfileThreatExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionArgs']] = None,
                 exempt_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionExemptIpArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 packet_capture: Optional[pulumi.Input[_builtins.str]] = None,
                 time_attribute: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgs']] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionArgs'] action: vulnerability threat exception default action
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionExemptIpArgs']]] exempt_ips: Exempt ip
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] notes: Notes
        :param pulumi.Input[_builtins.str] packet_capture: Packet capture
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgs'] time_attribute: vulnerability time attribute
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if exempt_ips is not None:
            pulumi.set(__self__, "exempt_ips", exempt_ips)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if packet_capture is not None:
            pulumi.set(__self__, "packet_capture", packet_capture)
        if time_attribute is not None:
            pulumi.set(__self__, "time_attribute", time_attribute)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionArgs']]:
        """
        vulnerability threat exception default action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="exemptIps")
    def exempt_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionExemptIpArgs']]]]:
        """
        Exempt ip
        """
        return pulumi.get(self, "exempt_ips")

    @exempt_ips.setter
    def exempt_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionExemptIpArgs']]]]):
        pulumi.set(self, "exempt_ips", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="packetCapture")
    def packet_capture(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Packet capture
        """
        return pulumi.get(self, "packet_capture")

    @packet_capture.setter
    def packet_capture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "packet_capture", value)

    @_builtins.property
    @pulumi.getter(name="timeAttribute")
    def time_attribute(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgs']]:
        """
        vulnerability time attribute
        """
        return pulumi.get(self, "time_attribute")

    @time_attribute.setter
    def time_attribute(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgs']]):
        pulumi.set(self, "time_attribute", value)


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        block_ip: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgsDict']]
        """
        vulnerability protection threat exception block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        default: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDefaultArgsDict']]
        """
        Default

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        drop: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDropArgsDict']]
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_both: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetBothArgsDict']]
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_client: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetClientArgsDict']]
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_server: NotRequired[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetServerArgsDict']]
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAllowArgs']] = None,
                 block_ip: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgs']] = None,
                 default: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDefaultArgs']] = None,
                 drop: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDropArgs']] = None,
                 reset_both: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetBothArgs']] = None,
                 reset_client: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetClientArgs']] = None,
                 reset_server: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetServerArgs']] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAlertArgs'] alert: Alert
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgs'] block_ip: vulnerability protection threat exception block ip
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDefaultArgs'] default: Default
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDropArgs'] drop: Drop
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetBothArgs'] reset_both: Reset both
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetClientArgs'] reset_client: Reset client
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetServerArgs'] reset_server: Reset server
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if reset_both is not None:
            pulumi.set(__self__, "reset_both", reset_both)
        if reset_client is not None:
            pulumi.set(__self__, "reset_client", reset_client)
        if reset_server is not None:
            pulumi.set(__self__, "reset_server", reset_server)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgs']]:
        """
        vulnerability protection threat exception block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDefaultArgs']]:
        """
        Default

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDefaultArgs']]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDropArgs']]:
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionDropArgs']]):
        pulumi.set(self, "drop", value)

    @_builtins.property
    @pulumi.getter(name="resetBoth")
    def reset_both(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetBothArgs']]:
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_both")

    @reset_both.setter
    def reset_both(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetBothArgs']]):
        pulumi.set(self, "reset_both", value)

    @_builtins.property
    @pulumi.getter(name="resetClient")
    def reset_client(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetClientArgs']]:
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_client")

    @reset_client.setter
    def reset_client(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetClientArgs']]):
        pulumi.set(self, "reset_client", value)

    @_builtins.property
    @pulumi.getter(name="resetServer")
    def reset_server(self) -> Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetServerArgs']]:
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `default`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_server")

    @reset_server.setter
    def reset_server(self, value: Optional[pulumi.Input['VulnerabilityProtectionProfileThreatExceptionActionResetServerArgs']]):
        pulumi.set(self, "reset_server", value)


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionAlertArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionAllowArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionDefaultArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionDefaultArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionDropArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionDropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionDropArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionResetBothArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionResetBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionResetBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionResetClientArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionResetClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionResetClientArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionActionResetServerArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionProfileThreatExceptionActionResetServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionActionResetServerArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionExemptIpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
elif False:
    VulnerabilityProtectionProfileThreatExceptionExemptIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionExemptIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionProfileThreatExceptionTimeAttributeArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Interval
        :param pulumi.Input[_builtins.int] threshold: Threshold
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class VulnerabilityProtectionSignatureAffectedHostArgsDict(TypedDict):
        client: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Client
        """
        server: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Server

        >  **Note:** You must specify exactly one of `client` and `server`.
        """
elif False:
    VulnerabilityProtectionSignatureAffectedHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureAffectedHostArgs:
    def __init__(__self__, *,
                 client: Optional[pulumi.Input[_builtins.bool]] = None,
                 server: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] client: Client
        :param pulumi.Input[_builtins.bool] server: Server
               
               >  **Note:** You must specify exactly one of `client` and `server`.
        """
        if client is not None:
            pulumi.set(__self__, "client", client)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Client
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "client", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Server

        >  **Note:** You must specify exactly one of `client` and `server`.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAllowArgsDict']]
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        block_ip: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionBlockIpArgsDict']]
        """
        vulnerability protection bugtraq block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        drop: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionDropArgsDict']]
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_both: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetBothArgsDict']]
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_client: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetClientArgsDict']]
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        reset_server: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetServerArgsDict']]
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
elif False:
    VulnerabilityProtectionSignatureDefaultActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAllowArgs']] = None,
                 block_ip: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionBlockIpArgs']] = None,
                 drop: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionDropArgs']] = None,
                 reset_both: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetBothArgs']] = None,
                 reset_client: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetClientArgs']] = None,
                 reset_server: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetServerArgs']] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAlertArgs'] alert: Alert
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAllowArgs'] allow: Allow
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionBlockIpArgs'] block_ip: vulnerability protection bugtraq block ip
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionDropArgs'] drop: Drop
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetBothArgs'] reset_both: Reset both
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetClientArgs'] reset_client: Reset client
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        :param pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetServerArgs'] reset_server: Reset server
               
               >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)
        if reset_both is not None:
            pulumi.set(__self__, "reset_both", reset_both)
        if reset_client is not None:
            pulumi.set(__self__, "reset_client", reset_client)
        if reset_server is not None:
            pulumi.set(__self__, "reset_server", reset_server)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAllowArgs']]:
        """
        Allow

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionBlockIpArgs']]:
        """
        vulnerability protection bugtraq block ip

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)

    @_builtins.property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionDropArgs']]:
        """
        Drop

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionDropArgs']]):
        pulumi.set(self, "drop", value)

    @_builtins.property
    @pulumi.getter(name="resetBoth")
    def reset_both(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetBothArgs']]:
        """
        Reset both

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_both")

    @reset_both.setter
    def reset_both(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetBothArgs']]):
        pulumi.set(self, "reset_both", value)

    @_builtins.property
    @pulumi.getter(name="resetClient")
    def reset_client(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetClientArgs']]:
        """
        Reset client

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_client")

    @reset_client.setter
    def reset_client(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetClientArgs']]):
        pulumi.set(self, "reset_client", value)

    @_builtins.property
    @pulumi.getter(name="resetServer")
    def reset_server(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetServerArgs']]:
        """
        Reset server

        >  **Note:** You must specify exactly one of `alert`, `allow`, `block_ip`, `drop`, `reset_both`, `reset_client`, and `reset_server`.
        """
        return pulumi.get(self, "reset_server")

    @reset_server.setter
    def reset_server(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureDefaultActionResetServerArgs']]):
        pulumi.set(self, "reset_server", value)


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionAlertArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionSignatureDefaultActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionAllowArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionSignatureDefaultActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionBlockIpArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Duration
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    VulnerabilityProtectionSignatureDefaultActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionDropArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionSignatureDefaultActionDropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionDropArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionResetBothArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionSignatureDefaultActionResetBothArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionResetBothArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionResetClientArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionSignatureDefaultActionResetClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionResetClientArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionSignatureDefaultActionResetServerArgsDict(TypedDict):
        pass
elif False:
    VulnerabilityProtectionSignatureDefaultActionResetServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureDefaultActionResetServerArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureArgsDict(TypedDict):
        combination: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationArgsDict']]
        """
        vulnerability protection signature combination object
        """
        standards: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardArgsDict']]]]
        """
        vulnerability protection signature standard array

        >  **Note:** You must specify exactly one of `combination` and `standard`.
        """
elif False:
    VulnerabilityProtectionSignatureSignatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureArgs:
    def __init__(__self__, *,
                 combination: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationArgs']] = None,
                 standards: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardArgs']]]] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationArgs'] combination: vulnerability protection signature combination object
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardArgs']]] standards: vulnerability protection signature standard array
               
               >  **Note:** You must specify exactly one of `combination` and `standard`.
        """
        if combination is not None:
            pulumi.set(__self__, "combination", combination)
        if standards is not None:
            pulumi.set(__self__, "standards", standards)

    @_builtins.property
    @pulumi.getter
    def combination(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationArgs']]:
        """
        vulnerability protection signature combination object
        """
        return pulumi.get(self, "combination")

    @combination.setter
    def combination(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationArgs']]):
        pulumi.set(self, "combination", value)

    @_builtins.property
    @pulumi.getter
    def standards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardArgs']]]]:
        """
        vulnerability protection signature standard array

        >  **Note:** You must specify exactly one of `combination` and `standard`.
        """
        return pulumi.get(self, "standards")

    @standards.setter
    def standards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardArgs']]]]):
        pulumi.set(self, "standards", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureCombinationArgsDict(TypedDict):
        and_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgsDict']]]]
        """
        vulnerability protection signature combination object and condition
        """
        order_free: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Order free
        """
        time_attribute: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgsDict']]
        """
        Time attribute
        """
elif False:
    VulnerabilityProtectionSignatureSignatureCombinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureCombinationArgs:
    def __init__(__self__, *,
                 and_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgs']]]] = None,
                 order_free: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_attribute: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgs']]] and_conditions: vulnerability protection signature combination object and condition
        :param pulumi.Input[_builtins.bool] order_free: Order free
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgs'] time_attribute: Time attribute
        """
        if and_conditions is not None:
            pulumi.set(__self__, "and_conditions", and_conditions)
        if order_free is not None:
            pulumi.set(__self__, "order_free", order_free)
        if time_attribute is not None:
            pulumi.set(__self__, "time_attribute", time_attribute)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgs']]]]:
        """
        vulnerability protection signature combination object and condition
        """
        return pulumi.get(self, "and_conditions")

    @and_conditions.setter
    def and_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgs']]]]):
        pulumi.set(self, "and_conditions", value)

    @_builtins.property
    @pulumi.getter(name="orderFree")
    def order_free(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Order free
        """
        return pulumi.get(self, "order_free")

    @order_free.setter
    def order_free(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order_free", value)

    @_builtins.property
    @pulumi.getter(name="timeAttribute")
    def time_attribute(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgs']]:
        """
        Time attribute
        """
        return pulumi.get(self, "time_attribute")

    @time_attribute.setter
    def time_attribute(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgs']]):
        pulumi.set(self, "time_attribute", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        or_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgsDict']]]]
        """
        vulnerability protection signature combination object and condition object or condition
        """
elif False:
    VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureCombinationAndConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 or_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgs']]] or_conditions: vulnerability protection signature combination object and condition object or condition
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if or_conditions is not None:
            pulumi.set(__self__, "or_conditions", or_conditions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgs']]]]:
        """
        vulnerability protection signature combination object and condition object or condition
        """
        return pulumi.get(self, "or_conditions")

    @or_conditions.setter
    def or_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgs']]]]):
        pulumi.set(self, "or_conditions", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        threat_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Threat id
        """
elif False:
    VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 threat_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] threat_id: Threat id
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if threat_id is not None:
            pulumi.set(__self__, "threat_id", threat_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="threatId")
    def threat_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Threat id
        """
        return pulumi.get(self, "threat_id")

    @threat_id.setter
    def threat_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threat_id", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold
        """
        track_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Track by
        """
elif False:
    VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 track_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Interval
        :param pulumi.Input[_builtins.int] threshold: Threshold
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if track_by is not None:
            pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        and_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionArgsDict']]]]
        """
        vulnerability protection signature standard object and condition
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment
        """
        order_free: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Order free
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 and_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionArgs']]]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 order_free: Optional[pulumi.Input[_builtins.bool]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionArgs']]] and_conditions: vulnerability protection signature standard object and condition
        :param pulumi.Input[_builtins.str] comment: Comment
        :param pulumi.Input[_builtins.bool] order_free: Order free
        :param pulumi.Input[_builtins.str] scope: Scope
        """
        pulumi.set(__self__, "name", name)
        if and_conditions is not None:
            pulumi.set(__self__, "and_conditions", and_conditions)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if order_free is not None:
            pulumi.set(__self__, "order_free", order_free)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionArgs']]]]:
        """
        vulnerability protection signature standard object and condition
        """
        return pulumi.get(self, "and_conditions")

    @and_conditions.setter
    def and_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionArgs']]]]):
        pulumi.set(self, "and_conditions", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="orderFree")
    def order_free(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Order free
        """
        return pulumi.get(self, "order_free")

    @order_free.setter
    def order_free(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order_free", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        or_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgsDict']]]]
        """
        vulnerability protection signature standard object and condition object or condition
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 or_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgs']]] or_conditions: vulnerability protection signature standard object and condition object or condition
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if or_conditions is not None:
            pulumi.set(__self__, "or_conditions", or_conditions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgs']]]]:
        """
        vulnerability protection signature standard object and condition object or condition
        """
        return pulumi.get(self, "or_conditions")

    @or_conditions.setter
    def or_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgs']]]]):
        pulumi.set(self, "or_conditions", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        operator: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict']]
        """
        vulnerability protection signature standard object and condition object or condition object operators
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgs'] operator: vulnerability protection signature standard object and condition object or condition object operators
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgs']]:
        """
        vulnerability protection signature standard object and condition object or condition object operators
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgs']]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict(TypedDict):
        equal_to: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict']]
        """
        vulnerability protection signature standard object and condition object or condition object operators equal*to
        """
        greater_than: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict']]
        """
        vulnerability protection signature standard object and condition object or condition object operators greater*than
        """
        less_than: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict']]
        """
        vulnerability protection signature standard object and condition object or condition object operators less*than
        """
        pattern_match: NotRequired[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict']]
        """
        vulnerability protection signature standard object and condition object or condition object operators pattern match
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorArgs:
    def __init__(__self__, *,
                 equal_to: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs']] = None,
                 greater_than: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs']] = None,
                 less_than: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs']] = None,
                 pattern_match: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs']] = None):
        """
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs'] equal_to: vulnerability protection signature standard object and condition object or condition object operators equal*to
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs'] greater_than: vulnerability protection signature standard object and condition object or condition object operators greater*than
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs'] less_than: vulnerability protection signature standard object and condition object or condition object operators less*than
        :param pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs'] pattern_match: vulnerability protection signature standard object and condition object or condition object operators pattern match
        """
        if equal_to is not None:
            pulumi.set(__self__, "equal_to", equal_to)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if pattern_match is not None:
            pulumi.set(__self__, "pattern_match", pattern_match)

    @_builtins.property
    @pulumi.getter(name="equalTo")
    def equal_to(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs']]:
        """
        vulnerability protection signature standard object and condition object or condition object operators equal*to
        """
        return pulumi.get(self, "equal_to")

    @equal_to.setter
    def equal_to(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs']]):
        pulumi.set(self, "equal_to", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs']]:
        """
        vulnerability protection signature standard object and condition object or condition object operators greater*than
        """
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs']]):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs']]:
        """
        vulnerability protection signature standard object and condition object or condition object operators less*than
        """
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs']]):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter(name="patternMatch")
    def pattern_match(self) -> Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs']]:
        """
        vulnerability protection signature standard object and condition object or condition object operators pattern match
        """
        return pulumi.get(self, "pattern_match")

    @pattern_match.setter
    def pattern_match(self, value: Optional[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs']]):
        pulumi.set(self, "pattern_match", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Negate
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict']]]]
        """
        vulnerability protection signature standard object and condition object or condition object operators equal*to qualifier array
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.bool] negate: Negate
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]] qualifiers: vulnerability protection signature standard object and condition object or condition object operators equal*to qualifier array
        :param pulumi.Input[_builtins.int] value: Value
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Negate
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]]]:
        """
        vulnerability protection signature standard object and condition object or condition object operators equal*to qualifier array
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict']]]]
        """
        vulnerability protection signature standard object and condition object or condition object operators greater*than qualifier
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]] qualifiers: vulnerability protection signature standard object and condition object or condition object operators greater*than qualifier
        :param pulumi.Input[_builtins.int] value: Value
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]]:
        """
        vulnerability protection signature standard object and condition object or condition object operators greater*than qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict']]]]
        """
        vulnerability protection signature standard object and condition object or condition object operators less*than array
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]] qualifiers: vulnerability protection signature standard object and condition object or condition object operators less*than array
        :param pulumi.Input[_builtins.int] value: Value
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]]]:
        """
        vulnerability protection signature standard object and condition object or condition object operators less*than array
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict(TypedDict):
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Context
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Negate
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        Pattern
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict']]]]
        """
        vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] context: Context
        :param pulumi.Input[_builtins.bool] negate: Negate
        :param pulumi.Input[_builtins.str] pattern: Pattern
        :param pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]] qualifiers: vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Context
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Negate
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]]:
        """
        vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs']]]]):
        pulumi.set(self, "qualifiers", value)


if not MYPY:
    class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value
        """
elif False:
    VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] value: Value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WildfireAntiVirusProfileMlavExceptionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description
        """
        filename: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filename
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    WildfireAntiVirusProfileMlavExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WildfireAntiVirusProfileMlavExceptionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 filename: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description
        :param pulumi.Input[_builtins.str] filename: Filename
        :param pulumi.Input[_builtins.str] name: Name
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filename
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filename", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WildfireAntiVirusProfileRuleArgsDict(TypedDict):
        analysis: NotRequired[pulumi.Input[_builtins.str]]
        """
        Analysis
        """
        applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Application
        """
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Direction
        """
        file_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        File type
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
elif False:
    WildfireAntiVirusProfileRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WildfireAntiVirusProfileRuleArgs:
    def __init__(__self__, *,
                 analysis: Optional[pulumi.Input[_builtins.str]] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] analysis: Analysis
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] applications: Application
        :param pulumi.Input[_builtins.str] direction: Direction
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] file_types: File type
        :param pulumi.Input[_builtins.str] name: Name
        """
        if analysis is not None:
            pulumi.set(__self__, "analysis", analysis)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def analysis(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Analysis
        """
        return pulumi.get(self, "analysis")

    @analysis.setter
    def analysis(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "analysis", value)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Application
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "applications", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Direction
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        File type
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "file_types", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WildfireAntiVirusProfileThreatExceptionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notes
        """
elif False:
    WildfireAntiVirusProfileThreatExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WildfireAntiVirusProfileThreatExceptionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] notes: Notes
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notes
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)


if not MYPY:
    class ZoneDeviceAclArgsDict(TypedDict):
        exclude_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Exclude list
        """
        include_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Include list
        """
elif False:
    ZoneDeviceAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDeviceAclArgs:
    def __init__(__self__, *,
                 exclude_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_lists: Exclude list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_lists: Include list
        """
        if exclude_lists is not None:
            pulumi.set(__self__, "exclude_lists", exclude_lists)
        if include_lists is not None:
            pulumi.set(__self__, "include_lists", include_lists)

    @_builtins.property
    @pulumi.getter(name="excludeLists")
    def exclude_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Exclude list
        """
        return pulumi.get(self, "exclude_lists")

    @exclude_lists.setter
    def exclude_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_lists", value)

    @_builtins.property
    @pulumi.getter(name="includeLists")
    def include_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Include list
        """
        return pulumi.get(self, "include_lists")

    @include_lists.setter
    def include_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_lists", value)


if not MYPY:
    class ZoneNetworkArgsDict(TypedDict):
        enable_packet_buffer_protection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable packet buffer protection
        """
        externals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        External
        """
        layer2s: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Layer2
        """
        layer3s: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Layer3
        """
        log_setting: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log setting
        """
        taps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tap
        """
        tunnel: NotRequired[pulumi.Input['ZoneNetworkTunnelArgsDict']]
        """
        Tunnel
        """
        virtual_wires: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Virtual wire
        """
        zone_protection_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Zone protection profile
        """
elif False:
    ZoneNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneNetworkArgs:
    def __init__(__self__, *,
                 enable_packet_buffer_protection: Optional[pulumi.Input[_builtins.bool]] = None,
                 externals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 layer2s: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 layer3s: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_setting: Optional[pulumi.Input[_builtins.str]] = None,
                 taps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tunnel: Optional[pulumi.Input['ZoneNetworkTunnelArgs']] = None,
                 virtual_wires: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 zone_protection_profile: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_packet_buffer_protection: Enable packet buffer protection
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] externals: External
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] layer2s: Layer2
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] layer3s: Layer3
        :param pulumi.Input[_builtins.str] log_setting: Log setting
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] taps: Tap
        :param pulumi.Input['ZoneNetworkTunnelArgs'] tunnel: Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] virtual_wires: Virtual wire
        :param pulumi.Input[_builtins.str] zone_protection_profile: Zone protection profile
        """
        if enable_packet_buffer_protection is not None:
            pulumi.set(__self__, "enable_packet_buffer_protection", enable_packet_buffer_protection)
        if externals is not None:
            pulumi.set(__self__, "externals", externals)
        if layer2s is not None:
            pulumi.set(__self__, "layer2s", layer2s)
        if layer3s is not None:
            pulumi.set(__self__, "layer3s", layer3s)
        if log_setting is not None:
            pulumi.set(__self__, "log_setting", log_setting)
        if taps is not None:
            pulumi.set(__self__, "taps", taps)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)
        if virtual_wires is not None:
            pulumi.set(__self__, "virtual_wires", virtual_wires)
        if zone_protection_profile is not None:
            pulumi.set(__self__, "zone_protection_profile", zone_protection_profile)

    @_builtins.property
    @pulumi.getter(name="enablePacketBufferProtection")
    def enable_packet_buffer_protection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable packet buffer protection
        """
        return pulumi.get(self, "enable_packet_buffer_protection")

    @enable_packet_buffer_protection.setter
    def enable_packet_buffer_protection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_packet_buffer_protection", value)

    @_builtins.property
    @pulumi.getter
    def externals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        External
        """
        return pulumi.get(self, "externals")

    @externals.setter
    def externals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "externals", value)

    @_builtins.property
    @pulumi.getter
    def layer2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Layer2
        """
        return pulumi.get(self, "layer2s")

    @layer2s.setter
    def layer2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "layer2s", value)

    @_builtins.property
    @pulumi.getter
    def layer3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Layer3
        """
        return pulumi.get(self, "layer3s")

    @layer3s.setter
    def layer3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "layer3s", value)

    @_builtins.property
    @pulumi.getter(name="logSetting")
    def log_setting(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log setting
        """
        return pulumi.get(self, "log_setting")

    @log_setting.setter
    def log_setting(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_setting", value)

    @_builtins.property
    @pulumi.getter
    def taps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tap
        """
        return pulumi.get(self, "taps")

    @taps.setter
    def taps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "taps", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input['ZoneNetworkTunnelArgs']]:
        """
        Tunnel
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input['ZoneNetworkTunnelArgs']]):
        pulumi.set(self, "tunnel", value)

    @_builtins.property
    @pulumi.getter(name="virtualWires")
    def virtual_wires(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Virtual wire
        """
        return pulumi.get(self, "virtual_wires")

    @virtual_wires.setter
    def virtual_wires(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "virtual_wires", value)

    @_builtins.property
    @pulumi.getter(name="zoneProtectionProfile")
    def zone_protection_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Zone protection profile
        """
        return pulumi.get(self, "zone_protection_profile")

    @zone_protection_profile.setter
    def zone_protection_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_protection_profile", value)


if not MYPY:
    class ZoneNetworkTunnelArgsDict(TypedDict):
        pass
elif False:
    ZoneNetworkTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneNetworkTunnelArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZoneProtectionProfileFloodArgsDict(TypedDict):
        icmp: NotRequired[pulumi.Input['ZoneProtectionProfileFloodIcmpArgsDict']]
        """
        Icmp
        """
        icmpv6: NotRequired[pulumi.Input['ZoneProtectionProfileFloodIcmpv6ArgsDict']]
        """
        Icmpv6
        """
        other_ip: NotRequired[pulumi.Input['ZoneProtectionProfileFloodOtherIpArgsDict']]
        """
        Other ip
        """
        sctp_init: NotRequired[pulumi.Input['ZoneProtectionProfileFloodSctpInitArgsDict']]
        """
        Sctp init
        """
        tcp_syn: NotRequired[pulumi.Input['ZoneProtectionProfileFloodTcpSynArgsDict']]
        """
        Tcp syn
        """
        udp: NotRequired[pulumi.Input['ZoneProtectionProfileFloodUdpArgsDict']]
        """
        Udp
        """
elif False:
    ZoneProtectionProfileFloodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodArgs:
    def __init__(__self__, *,
                 icmp: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpArgs']] = None,
                 icmpv6: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpv6Args']] = None,
                 other_ip: Optional[pulumi.Input['ZoneProtectionProfileFloodOtherIpArgs']] = None,
                 sctp_init: Optional[pulumi.Input['ZoneProtectionProfileFloodSctpInitArgs']] = None,
                 tcp_syn: Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynArgs']] = None,
                 udp: Optional[pulumi.Input['ZoneProtectionProfileFloodUdpArgs']] = None):
        """
        :param pulumi.Input['ZoneProtectionProfileFloodIcmpArgs'] icmp: Icmp
        :param pulumi.Input['ZoneProtectionProfileFloodIcmpv6Args'] icmpv6: Icmpv6
        :param pulumi.Input['ZoneProtectionProfileFloodOtherIpArgs'] other_ip: Other ip
        :param pulumi.Input['ZoneProtectionProfileFloodSctpInitArgs'] sctp_init: Sctp init
        :param pulumi.Input['ZoneProtectionProfileFloodTcpSynArgs'] tcp_syn: Tcp syn
        :param pulumi.Input['ZoneProtectionProfileFloodUdpArgs'] udp: Udp
        """
        if icmp is not None:
            pulumi.set(__self__, "icmp", icmp)
        if icmpv6 is not None:
            pulumi.set(__self__, "icmpv6", icmpv6)
        if other_ip is not None:
            pulumi.set(__self__, "other_ip", other_ip)
        if sctp_init is not None:
            pulumi.set(__self__, "sctp_init", sctp_init)
        if tcp_syn is not None:
            pulumi.set(__self__, "tcp_syn", tcp_syn)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter
    def icmp(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpArgs']]:
        """
        Icmp
        """
        return pulumi.get(self, "icmp")

    @icmp.setter
    def icmp(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpArgs']]):
        pulumi.set(self, "icmp", value)

    @_builtins.property
    @pulumi.getter
    def icmpv6(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpv6Args']]:
        """
        Icmpv6
        """
        return pulumi.get(self, "icmpv6")

    @icmpv6.setter
    def icmpv6(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpv6Args']]):
        pulumi.set(self, "icmpv6", value)

    @_builtins.property
    @pulumi.getter(name="otherIp")
    def other_ip(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodOtherIpArgs']]:
        """
        Other ip
        """
        return pulumi.get(self, "other_ip")

    @other_ip.setter
    def other_ip(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodOtherIpArgs']]):
        pulumi.set(self, "other_ip", value)

    @_builtins.property
    @pulumi.getter(name="sctpInit")
    def sctp_init(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodSctpInitArgs']]:
        """
        Sctp init
        """
        return pulumi.get(self, "sctp_init")

    @sctp_init.setter
    def sctp_init(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodSctpInitArgs']]):
        pulumi.set(self, "sctp_init", value)

    @_builtins.property
    @pulumi.getter(name="tcpSyn")
    def tcp_syn(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynArgs']]:
        """
        Tcp syn
        """
        return pulumi.get(self, "tcp_syn")

    @tcp_syn.setter
    def tcp_syn(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynArgs']]):
        pulumi.set(self, "tcp_syn", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodUdpArgs']]:
        """
        Udp
        """
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class ZoneProtectionProfileFloodIcmpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable protection against ICMP floods?
        """
        red: NotRequired[pulumi.Input['ZoneProtectionProfileFloodIcmpRedArgsDict']]
        """
        Red
        """
elif False:
    ZoneProtectionProfileFloodIcmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodIcmpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable protection against ICMP floods?
        :param pulumi.Input['ZoneProtectionProfileFloodIcmpRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable protection against ICMP floods?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class ZoneProtectionProfileFloodIcmpRedArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        The number of ICMP packets (not matching an existing session) that the zone receives per second before subsequent ICMP packets are dropped.
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        The number of ICMP echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        The maximum number of ICMP packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
elif False:
    ZoneProtectionProfileFloodIcmpRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodIcmpRedArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: The number of ICMP packets (not matching an existing session) that the zone receives per second before subsequent ICMP packets are dropped.
        :param pulumi.Input[_builtins.int] alarm_rate: The number of ICMP echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
        :param pulumi.Input[_builtins.int] maximal_rate: The maximum number of ICMP packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of ICMP packets (not matching an existing session) that the zone receives per second before subsequent ICMP packets are dropped.
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of ICMP echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of ICMP packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileFloodIcmpv6ArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable protection against ICMPv6 floods?
        """
        red: NotRequired[pulumi.Input['ZoneProtectionProfileFloodIcmpv6RedArgsDict']]
        """
        Red
        """
elif False:
    ZoneProtectionProfileFloodIcmpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodIcmpv6Args:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpv6RedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable protection against ICMPv6 floods?
        :param pulumi.Input['ZoneProtectionProfileFloodIcmpv6RedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable protection against ICMPv6 floods?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpv6RedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodIcmpv6RedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class ZoneProtectionProfileFloodIcmpv6RedArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        The number of ICMPv6 packets (not matching an existing session) that the zone receives per second before subsequent ICMPv6 packets are dropped.
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        The number of ICMPv6 echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        The maximum number of ICMPv6 packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
elif False:
    ZoneProtectionProfileFloodIcmpv6RedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodIcmpv6RedArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: The number of ICMPv6 packets (not matching an existing session) that the zone receives per second before subsequent ICMPv6 packets are dropped.
        :param pulumi.Input[_builtins.int] alarm_rate: The number of ICMPv6 echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
        :param pulumi.Input[_builtins.int] maximal_rate: The maximum number of ICMPv6 packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of ICMPv6 packets (not matching an existing session) that the zone receives per second before subsequent ICMPv6 packets are dropped.
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of ICMPv6 echo requests (pings not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of ICMPv6 packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileFloodOtherIpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable protection against other IP (non-TCP, non-ICMP, non-ICMPv6, non-SCTP, and non-UDP) floods?
        """
        red: NotRequired[pulumi.Input['ZoneProtectionProfileFloodOtherIpRedArgsDict']]
        """
        Red
        """
elif False:
    ZoneProtectionProfileFloodOtherIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodOtherIpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['ZoneProtectionProfileFloodOtherIpRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable protection against other IP (non-TCP, non-ICMP, non-ICMPv6, non-SCTP, and non-UDP) floods?
        :param pulumi.Input['ZoneProtectionProfileFloodOtherIpRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable protection against other IP (non-TCP, non-ICMP, non-ICMPv6, non-SCTP, and non-UDP) floods?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodOtherIpRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodOtherIpRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class ZoneProtectionProfileFloodOtherIpRedArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        Activate rate
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        Alarm rate
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        Maximal rate
        """
elif False:
    ZoneProtectionProfileFloodOtherIpRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodOtherIpRedArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: Activate rate
        :param pulumi.Input[_builtins.int] alarm_rate: Alarm rate
        :param pulumi.Input[_builtins.int] maximal_rate: Maximal rate
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        Activate rate
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        Alarm rate
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        Maximal rate
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileFloodSctpInitArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable protection against floods of Stream Control Transmission Protocol (SCTP) packets that contain an Initiation (INIT) chunk?
        """
        red: NotRequired[pulumi.Input['ZoneProtectionProfileFloodSctpInitRedArgsDict']]
        """
        Red
        """
elif False:
    ZoneProtectionProfileFloodSctpInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodSctpInitArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['ZoneProtectionProfileFloodSctpInitRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable protection against floods of Stream Control Transmission Protocol (SCTP) packets that contain an Initiation (INIT) chunk?
        :param pulumi.Input['ZoneProtectionProfileFloodSctpInitRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable protection against floods of Stream Control Transmission Protocol (SCTP) packets that contain an Initiation (INIT) chunk?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodSctpInitRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodSctpInitRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class ZoneProtectionProfileFloodSctpInitRedArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        The number of SCTP INIT packets (not matching an existing session) that the zone receives per second before subsequent SCTP INIT packets are dropped.
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        The number of SCTP INIT packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        The maximum number of SCTP INIT packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
elif False:
    ZoneProtectionProfileFloodSctpInitRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodSctpInitRedArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: The number of SCTP INIT packets (not matching an existing session) that the zone receives per second before subsequent SCTP INIT packets are dropped.
        :param pulumi.Input[_builtins.int] alarm_rate: The number of SCTP INIT packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
        :param pulumi.Input[_builtins.int] maximal_rate: The maximum number of SCTP INIT packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of SCTP INIT packets (not matching an existing session) that the zone receives per second before subsequent SCTP INIT packets are dropped.
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of SCTP INIT packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of SCTP INIT packets (not matching an existing session) that the zone receives per second before packets exceeding the maximum are dropped.
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileFloodTcpSynArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable protection against SYN floods?
        """
        red: NotRequired[pulumi.Input['ZoneProtectionProfileFloodTcpSynRedArgsDict']]
        """
        Red
        """
        syn_cookies: NotRequired[pulumi.Input['ZoneProtectionProfileFloodTcpSynSynCookiesArgsDict']]
        """
        Syn cookies
        """
elif False:
    ZoneProtectionProfileFloodTcpSynArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodTcpSynArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynRedArgs']] = None,
                 syn_cookies: Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynSynCookiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable protection against SYN floods?
        :param pulumi.Input['ZoneProtectionProfileFloodTcpSynRedArgs'] red: Red
        :param pulumi.Input['ZoneProtectionProfileFloodTcpSynSynCookiesArgs'] syn_cookies: Syn cookies
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)
        if syn_cookies is not None:
            pulumi.set(__self__, "syn_cookies", syn_cookies)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable protection against SYN floods?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynRedArgs']]):
        pulumi.set(self, "red", value)

    @_builtins.property
    @pulumi.getter(name="synCookies")
    def syn_cookies(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynSynCookiesArgs']]:
        """
        Syn cookies
        """
        return pulumi.get(self, "syn_cookies")

    @syn_cookies.setter
    def syn_cookies(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodTcpSynSynCookiesArgs']]):
        pulumi.set(self, "syn_cookies", value)


if not MYPY:
    class ZoneProtectionProfileFloodTcpSynRedArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        When the flow exceeds the `activate_rate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        When the flow exceeds the `alert_rate`` threshold, an alarm is generated.
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        When the flow exceeds the `maximal_rate` threshold, 100% of incoming SYN packets are dropped.
        """
elif False:
    ZoneProtectionProfileFloodTcpSynRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodTcpSynRedArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: When the flow exceeds the `activate_rate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
        :param pulumi.Input[_builtins.int] alarm_rate: When the flow exceeds the `alert_rate`` threshold, an alarm is generated.
        :param pulumi.Input[_builtins.int] maximal_rate: When the flow exceeds the `maximal_rate` threshold, 100% of incoming SYN packets are dropped.
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        When the flow exceeds the `activate_rate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        When the flow exceeds the `alert_rate`` threshold, an alarm is generated.
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        When the flow exceeds the `maximal_rate` threshold, 100% of incoming SYN packets are dropped.
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileFloodTcpSynSynCookiesArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        When the flow exceeds the `activate_rate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        When the flow exceeds the `alert_rate`` threshold, an alarm is generated.
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        When the flow exceeds the `maximal_rate` threshold, 100% of incoming SYN packets are dropped.
        """
elif False:
    ZoneProtectionProfileFloodTcpSynSynCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodTcpSynSynCookiesArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: When the flow exceeds the `activate_rate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
        :param pulumi.Input[_builtins.int] alarm_rate: When the flow exceeds the `alert_rate`` threshold, an alarm is generated.
        :param pulumi.Input[_builtins.int] maximal_rate: When the flow exceeds the `maximal_rate` threshold, 100% of incoming SYN packets are dropped.
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        When the flow exceeds the `activate_rate`` threshold, the firewall drops individual SYN packets randomly to restrict the flow.
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        When the flow exceeds the `alert_rate`` threshold, an alarm is generated.
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        When the flow exceeds the `maximal_rate` threshold, 100% of incoming SYN packets are dropped.
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileFloodUdpArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable protection against UDP floods?
        """
        red: NotRequired[pulumi.Input['ZoneProtectionProfileFloodUdpRedArgsDict']]
        """
        Red
        """
elif False:
    ZoneProtectionProfileFloodUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodUdpArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 red: Optional[pulumi.Input['ZoneProtectionProfileFloodUdpRedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Enable protection against UDP floods?
        :param pulumi.Input['ZoneProtectionProfileFloodUdpRedArgs'] red: Red
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable protection against UDP floods?
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input['ZoneProtectionProfileFloodUdpRedArgs']]:
        """
        Red
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input['ZoneProtectionProfileFloodUdpRedArgs']]):
        pulumi.set(self, "red", value)


if not MYPY:
    class ZoneProtectionProfileFloodUdpRedArgsDict(TypedDict):
        activate_rate: pulumi.Input[_builtins.int]
        """
        The number of UDP packets (not matching an existing session) that the zone receives per second that triggers random dropping of UDP packets.
        """
        alarm_rate: pulumi.Input[_builtins.int]
        """
        The number of UDP packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        maximal_rate: pulumi.Input[_builtins.int]
        """
        The maximum number of UDP packets (not matching an existing session) the zone receives per second before packets exceeding the maximum are dropped.
        """
elif False:
    ZoneProtectionProfileFloodUdpRedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileFloodUdpRedArgs:
    def __init__(__self__, *,
                 activate_rate: pulumi.Input[_builtins.int],
                 alarm_rate: pulumi.Input[_builtins.int],
                 maximal_rate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] activate_rate: The number of UDP packets (not matching an existing session) that the zone receives per second that triggers random dropping of UDP packets.
        :param pulumi.Input[_builtins.int] alarm_rate: The number of UDP packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
        :param pulumi.Input[_builtins.int] maximal_rate: The maximum number of UDP packets (not matching an existing session) the zone receives per second before packets exceeding the maximum are dropped.
        """
        pulumi.set(__self__, "activate_rate", activate_rate)
        pulumi.set(__self__, "alarm_rate", alarm_rate)
        pulumi.set(__self__, "maximal_rate", maximal_rate)

    @_builtins.property
    @pulumi.getter(name="activateRate")
    def activate_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of UDP packets (not matching an existing session) that the zone receives per second that triggers random dropping of UDP packets.
        """
        return pulumi.get(self, "activate_rate")

    @activate_rate.setter
    def activate_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "activate_rate", value)

    @_builtins.property
    @pulumi.getter(name="alarmRate")
    def alarm_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The number of UDP packets (not matching an existing session) that the zone receives per second that triggers an attack alarm.
        """
        return pulumi.get(self, "alarm_rate")

    @alarm_rate.setter
    def alarm_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "alarm_rate", value)

    @_builtins.property
    @pulumi.getter(name="maximalRate")
    def maximal_rate(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of UDP packets (not matching an existing session) the zone receives per second before packets exceeding the maximum are dropped.
        """
        return pulumi.get(self, "maximal_rate")

    @maximal_rate.setter
    def maximal_rate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximal_rate", value)


if not MYPY:
    class ZoneProtectionProfileIpv6ArgsDict(TypedDict):
        anycast_source: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that contain an anycast source address.
        """
        filter_ext_hdr: NotRequired[pulumi.Input['ZoneProtectionProfileIpv6FilterExtHdrArgsDict']]
        """
        Filter ext hdr
        """
        icmpv6_too_big_small_mtu_discard: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that contain a Packet Too Big ICMPv6 message when the maximum transmission unit (MTU) is less than 1,280 bytes.
        """
        ignore_inv_pkt: NotRequired[pulumi.Input['ZoneProtectionProfileIpv6IgnoreInvPktArgsDict']]
        """
        Ignore inv pkt
        """
        ipv4_compatible_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that are defined as an RFC 4291 IPv4-Compatible IPv6 address.
        """
        needless_fragment_hdr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets with the last fragment flag (M=0) and offset of zero.
        """
        options_invalid_ipv6_discard: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that contain invalid IPv6 options in an extension header.
        """
        reserved_field_set_discard: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that have a header with a reserved field not set to zero.
        """
        routing_header0: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 0 routing header.
        """
        routing_header1: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 1 routing header.
        """
        routing_header253: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 253 routing header.
        """
        routing_header254: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 254 routing header.
        """
        routing_header255: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 255 routing header.
        """
        routing_header3: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 3 routing header.
        """
        routing_header4252: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Drop packets with type 4 to type 252 routing header.
        """
elif False:
    ZoneProtectionProfileIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileIpv6Args:
    def __init__(__self__, *,
                 anycast_source: Optional[pulumi.Input[_builtins.bool]] = None,
                 filter_ext_hdr: Optional[pulumi.Input['ZoneProtectionProfileIpv6FilterExtHdrArgs']] = None,
                 icmpv6_too_big_small_mtu_discard: Optional[pulumi.Input[_builtins.bool]] = None,
                 ignore_inv_pkt: Optional[pulumi.Input['ZoneProtectionProfileIpv6IgnoreInvPktArgs']] = None,
                 ipv4_compatible_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 needless_fragment_hdr: Optional[pulumi.Input[_builtins.bool]] = None,
                 options_invalid_ipv6_discard: Optional[pulumi.Input[_builtins.bool]] = None,
                 reserved_field_set_discard: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header0: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header1: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header253: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header254: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header255: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header3: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_header4252: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] anycast_source: Discard IPv6 packets that contain an anycast source address.
        :param pulumi.Input['ZoneProtectionProfileIpv6FilterExtHdrArgs'] filter_ext_hdr: Filter ext hdr
        :param pulumi.Input[_builtins.bool] icmpv6_too_big_small_mtu_discard: Discard IPv6 packets that contain a Packet Too Big ICMPv6 message when the maximum transmission unit (MTU) is less than 1,280 bytes.
        :param pulumi.Input['ZoneProtectionProfileIpv6IgnoreInvPktArgs'] ignore_inv_pkt: Ignore inv pkt
        :param pulumi.Input[_builtins.bool] ipv4_compatible_address: Discard IPv6 packets that are defined as an RFC 4291 IPv4-Compatible IPv6 address.
        :param pulumi.Input[_builtins.bool] needless_fragment_hdr: Discard IPv6 packets with the last fragment flag (M=0) and offset of zero.
        :param pulumi.Input[_builtins.bool] options_invalid_ipv6_discard: Discard IPv6 packets that contain invalid IPv6 options in an extension header.
        :param pulumi.Input[_builtins.bool] reserved_field_set_discard: Discard IPv6 packets that have a header with a reserved field not set to zero.
        :param pulumi.Input[_builtins.bool] routing_header0: Drop packets with type 0 routing header.
        :param pulumi.Input[_builtins.bool] routing_header1: Drop packets with type 1 routing header.
        :param pulumi.Input[_builtins.bool] routing_header253: Drop packets with type 253 routing header.
        :param pulumi.Input[_builtins.bool] routing_header254: Drop packets with type 254 routing header.
        :param pulumi.Input[_builtins.bool] routing_header255: Drop packets with type 255 routing header.
        :param pulumi.Input[_builtins.bool] routing_header3: Drop packets with type 3 routing header.
        :param pulumi.Input[_builtins.bool] routing_header4252: Drop packets with type 4 to type 252 routing header.
        """
        if anycast_source is not None:
            pulumi.set(__self__, "anycast_source", anycast_source)
        if filter_ext_hdr is not None:
            pulumi.set(__self__, "filter_ext_hdr", filter_ext_hdr)
        if icmpv6_too_big_small_mtu_discard is not None:
            pulumi.set(__self__, "icmpv6_too_big_small_mtu_discard", icmpv6_too_big_small_mtu_discard)
        if ignore_inv_pkt is not None:
            pulumi.set(__self__, "ignore_inv_pkt", ignore_inv_pkt)
        if ipv4_compatible_address is not None:
            pulumi.set(__self__, "ipv4_compatible_address", ipv4_compatible_address)
        if needless_fragment_hdr is not None:
            pulumi.set(__self__, "needless_fragment_hdr", needless_fragment_hdr)
        if options_invalid_ipv6_discard is not None:
            pulumi.set(__self__, "options_invalid_ipv6_discard", options_invalid_ipv6_discard)
        if reserved_field_set_discard is not None:
            pulumi.set(__self__, "reserved_field_set_discard", reserved_field_set_discard)
        if routing_header0 is not None:
            pulumi.set(__self__, "routing_header0", routing_header0)
        if routing_header1 is not None:
            pulumi.set(__self__, "routing_header1", routing_header1)
        if routing_header253 is not None:
            pulumi.set(__self__, "routing_header253", routing_header253)
        if routing_header254 is not None:
            pulumi.set(__self__, "routing_header254", routing_header254)
        if routing_header255 is not None:
            pulumi.set(__self__, "routing_header255", routing_header255)
        if routing_header3 is not None:
            pulumi.set(__self__, "routing_header3", routing_header3)
        if routing_header4252 is not None:
            pulumi.set(__self__, "routing_header4252", routing_header4252)

    @_builtins.property
    @pulumi.getter(name="anycastSource")
    def anycast_source(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that contain an anycast source address.
        """
        return pulumi.get(self, "anycast_source")

    @anycast_source.setter
    def anycast_source(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "anycast_source", value)

    @_builtins.property
    @pulumi.getter(name="filterExtHdr")
    def filter_ext_hdr(self) -> Optional[pulumi.Input['ZoneProtectionProfileIpv6FilterExtHdrArgs']]:
        """
        Filter ext hdr
        """
        return pulumi.get(self, "filter_ext_hdr")

    @filter_ext_hdr.setter
    def filter_ext_hdr(self, value: Optional[pulumi.Input['ZoneProtectionProfileIpv6FilterExtHdrArgs']]):
        pulumi.set(self, "filter_ext_hdr", value)

    @_builtins.property
    @pulumi.getter(name="icmpv6TooBigSmallMtuDiscard")
    def icmpv6_too_big_small_mtu_discard(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that contain a Packet Too Big ICMPv6 message when the maximum transmission unit (MTU) is less than 1,280 bytes.
        """
        return pulumi.get(self, "icmpv6_too_big_small_mtu_discard")

    @icmpv6_too_big_small_mtu_discard.setter
    def icmpv6_too_big_small_mtu_discard(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "icmpv6_too_big_small_mtu_discard", value)

    @_builtins.property
    @pulumi.getter(name="ignoreInvPkt")
    def ignore_inv_pkt(self) -> Optional[pulumi.Input['ZoneProtectionProfileIpv6IgnoreInvPktArgs']]:
        """
        Ignore inv pkt
        """
        return pulumi.get(self, "ignore_inv_pkt")

    @ignore_inv_pkt.setter
    def ignore_inv_pkt(self, value: Optional[pulumi.Input['ZoneProtectionProfileIpv6IgnoreInvPktArgs']]):
        pulumi.set(self, "ignore_inv_pkt", value)

    @_builtins.property
    @pulumi.getter(name="ipv4CompatibleAddress")
    def ipv4_compatible_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that are defined as an RFC 4291 IPv4-Compatible IPv6 address.
        """
        return pulumi.get(self, "ipv4_compatible_address")

    @ipv4_compatible_address.setter
    def ipv4_compatible_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv4_compatible_address", value)

    @_builtins.property
    @pulumi.getter(name="needlessFragmentHdr")
    def needless_fragment_hdr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets with the last fragment flag (M=0) and offset of zero.
        """
        return pulumi.get(self, "needless_fragment_hdr")

    @needless_fragment_hdr.setter
    def needless_fragment_hdr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "needless_fragment_hdr", value)

    @_builtins.property
    @pulumi.getter(name="optionsInvalidIpv6Discard")
    def options_invalid_ipv6_discard(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that contain invalid IPv6 options in an extension header.
        """
        return pulumi.get(self, "options_invalid_ipv6_discard")

    @options_invalid_ipv6_discard.setter
    def options_invalid_ipv6_discard(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "options_invalid_ipv6_discard", value)

    @_builtins.property
    @pulumi.getter(name="reservedFieldSetDiscard")
    def reserved_field_set_discard(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that have a header with a reserved field not set to zero.
        """
        return pulumi.get(self, "reserved_field_set_discard")

    @reserved_field_set_discard.setter
    def reserved_field_set_discard(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reserved_field_set_discard", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader0")
    def routing_header0(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 0 routing header.
        """
        return pulumi.get(self, "routing_header0")

    @routing_header0.setter
    def routing_header0(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header0", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader1")
    def routing_header1(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 1 routing header.
        """
        return pulumi.get(self, "routing_header1")

    @routing_header1.setter
    def routing_header1(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header1", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader253")
    def routing_header253(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 253 routing header.
        """
        return pulumi.get(self, "routing_header253")

    @routing_header253.setter
    def routing_header253(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header253", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader254")
    def routing_header254(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 254 routing header.
        """
        return pulumi.get(self, "routing_header254")

    @routing_header254.setter
    def routing_header254(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header254", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader255")
    def routing_header255(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 255 routing header.
        """
        return pulumi.get(self, "routing_header255")

    @routing_header255.setter
    def routing_header255(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header255", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader3")
    def routing_header3(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 3 routing header.
        """
        return pulumi.get(self, "routing_header3")

    @routing_header3.setter
    def routing_header3(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header3", value)

    @_builtins.property
    @pulumi.getter(name="routingHeader4252")
    def routing_header4252(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Drop packets with type 4 to type 252 routing header.
        """
        return pulumi.get(self, "routing_header4252")

    @routing_header4252.setter
    def routing_header4252(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_header4252", value)


if not MYPY:
    class ZoneProtectionProfileIpv6FilterExtHdrArgsDict(TypedDict):
        dest_option_hdr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that contain the Destination Options extension, which contains options intended only for the destination of the packet.
        """
        hop_by_hop_hdr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that contain the Hop-by-Hop Options extension header.
        """
        routing_hdr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Discard IPv6 packets that contain the Routing extension header, which directs packets to one or more intermediate nodes on its way to its destination.
        """
elif False:
    ZoneProtectionProfileIpv6FilterExtHdrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileIpv6FilterExtHdrArgs:
    def __init__(__self__, *,
                 dest_option_hdr: Optional[pulumi.Input[_builtins.bool]] = None,
                 hop_by_hop_hdr: Optional[pulumi.Input[_builtins.bool]] = None,
                 routing_hdr: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] dest_option_hdr: Discard IPv6 packets that contain the Destination Options extension, which contains options intended only for the destination of the packet.
        :param pulumi.Input[_builtins.bool] hop_by_hop_hdr: Discard IPv6 packets that contain the Hop-by-Hop Options extension header.
        :param pulumi.Input[_builtins.bool] routing_hdr: Discard IPv6 packets that contain the Routing extension header, which directs packets to one or more intermediate nodes on its way to its destination.
        """
        if dest_option_hdr is not None:
            pulumi.set(__self__, "dest_option_hdr", dest_option_hdr)
        if hop_by_hop_hdr is not None:
            pulumi.set(__self__, "hop_by_hop_hdr", hop_by_hop_hdr)
        if routing_hdr is not None:
            pulumi.set(__self__, "routing_hdr", routing_hdr)

    @_builtins.property
    @pulumi.getter(name="destOptionHdr")
    def dest_option_hdr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that contain the Destination Options extension, which contains options intended only for the destination of the packet.
        """
        return pulumi.get(self, "dest_option_hdr")

    @dest_option_hdr.setter
    def dest_option_hdr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dest_option_hdr", value)

    @_builtins.property
    @pulumi.getter(name="hopByHopHdr")
    def hop_by_hop_hdr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that contain the Hop-by-Hop Options extension header.
        """
        return pulumi.get(self, "hop_by_hop_hdr")

    @hop_by_hop_hdr.setter
    def hop_by_hop_hdr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hop_by_hop_hdr", value)

    @_builtins.property
    @pulumi.getter(name="routingHdr")
    def routing_hdr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Discard IPv6 packets that contain the Routing extension header, which directs packets to one or more intermediate nodes on its way to its destination.
        """
        return pulumi.get(self, "routing_hdr")

    @routing_hdr.setter
    def routing_hdr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "routing_hdr", value)


if not MYPY:
    class ZoneProtectionProfileIpv6IgnoreInvPktArgsDict(TypedDict):
        dest_unreach: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Require an explicit Security policy match for Destination Unreachable ICMPv6 messages, even when the message is associated with an existing session.
        """
        param_problem: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Require an explicit Security policy match for Parameter Problem ICMPv6 messages, even when the message is associated with an existing session.
        """
        pkt_too_big: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Require an explicit Security policy match for Packet Too Big ICMPv6 messages, even when the message is associated with an existing session.
        """
        redirect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Require an explicit Security policy match for Redirect Message ICMPv6 messages, even when the message is associated with an existing session.
        """
        time_exceeded: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Require an explicit Security policy match for Time Exceeded ICMPv6 messages, even when the message is associated with an existing session.
        """
elif False:
    ZoneProtectionProfileIpv6IgnoreInvPktArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileIpv6IgnoreInvPktArgs:
    def __init__(__self__, *,
                 dest_unreach: Optional[pulumi.Input[_builtins.bool]] = None,
                 param_problem: Optional[pulumi.Input[_builtins.bool]] = None,
                 pkt_too_big: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_exceeded: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] dest_unreach: Require an explicit Security policy match for Destination Unreachable ICMPv6 messages, even when the message is associated with an existing session.
        :param pulumi.Input[_builtins.bool] param_problem: Require an explicit Security policy match for Parameter Problem ICMPv6 messages, even when the message is associated with an existing session.
        :param pulumi.Input[_builtins.bool] pkt_too_big: Require an explicit Security policy match for Packet Too Big ICMPv6 messages, even when the message is associated with an existing session.
        :param pulumi.Input[_builtins.bool] redirect: Require an explicit Security policy match for Redirect Message ICMPv6 messages, even when the message is associated with an existing session.
        :param pulumi.Input[_builtins.bool] time_exceeded: Require an explicit Security policy match for Time Exceeded ICMPv6 messages, even when the message is associated with an existing session.
        """
        if dest_unreach is not None:
            pulumi.set(__self__, "dest_unreach", dest_unreach)
        if param_problem is not None:
            pulumi.set(__self__, "param_problem", param_problem)
        if pkt_too_big is not None:
            pulumi.set(__self__, "pkt_too_big", pkt_too_big)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if time_exceeded is not None:
            pulumi.set(__self__, "time_exceeded", time_exceeded)

    @_builtins.property
    @pulumi.getter(name="destUnreach")
    def dest_unreach(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Require an explicit Security policy match for Destination Unreachable ICMPv6 messages, even when the message is associated with an existing session.
        """
        return pulumi.get(self, "dest_unreach")

    @dest_unreach.setter
    def dest_unreach(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dest_unreach", value)

    @_builtins.property
    @pulumi.getter(name="paramProblem")
    def param_problem(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Require an explicit Security policy match for Parameter Problem ICMPv6 messages, even when the message is associated with an existing session.
        """
        return pulumi.get(self, "param_problem")

    @param_problem.setter
    def param_problem(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "param_problem", value)

    @_builtins.property
    @pulumi.getter(name="pktTooBig")
    def pkt_too_big(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Require an explicit Security policy match for Packet Too Big ICMPv6 messages, even when the message is associated with an existing session.
        """
        return pulumi.get(self, "pkt_too_big")

    @pkt_too_big.setter
    def pkt_too_big(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pkt_too_big", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Require an explicit Security policy match for Redirect Message ICMPv6 messages, even when the message is associated with an existing session.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "redirect", value)

    @_builtins.property
    @pulumi.getter(name="timeExceeded")
    def time_exceeded(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Require an explicit Security policy match for Time Exceeded ICMPv6 messages, even when the message is associated with an existing session.
        """
        return pulumi.get(self, "time_exceeded")

    @time_exceeded.setter
    def time_exceeded(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "time_exceeded", value)


if not MYPY:
    class ZoneProtectionProfileL2SecGroupTagProtectionArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileL2SecGroupTagProtectionTagArgsDict']]]]
        """
        Tags
        """
elif False:
    ZoneProtectionProfileL2SecGroupTagProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileL2SecGroupTagProtectionArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileL2SecGroupTagProtectionTagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileL2SecGroupTagProtectionTagArgs']]] tags: Tags
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileL2SecGroupTagProtectionTagArgs']]]]:
        """
        Tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileL2SecGroupTagProtectionTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ZoneProtectionProfileL2SecGroupTagProtectionTagArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name for the list of Security Group Tags (SGTs).
        """
        tag: pulumi.Input[_builtins.str]
        """
        The Layer 2 SGTs in headers of packets that you want to exclude (drop) when the SGT matches this list in the Zone Protection profile applied to a zone (range is 0 to 65,535).
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable this exclude list for Ethernet SGT protection.
        """
elif False:
    ZoneProtectionProfileL2SecGroupTagProtectionTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileL2SecGroupTagProtectionTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 tag: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name for the list of Security Group Tags (SGTs).
        :param pulumi.Input[_builtins.str] tag: The Layer 2 SGTs in headers of packets that you want to exclude (drop) when the SGT matches this list in the Zone Protection profile applied to a zone (range is 0 to 65,535).
        :param pulumi.Input[_builtins.bool] enable: Enable this exclude list for Ethernet SGT protection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tag", tag)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for the list of Security Group Tags (SGTs).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> pulumi.Input[_builtins.str]:
        """
        The Layer 2 SGTs in headers of packets that you want to exclude (drop) when the SGT matches this list in the Zone Protection profile applied to a zone (range is 0 to 65,535).
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable this exclude list for Ethernet SGT protection.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class ZoneProtectionProfileNonIpProtocolArgsDict(TypedDict):
        list_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify the type of list you are creating for protocol protection:
        * Include ListOnly the protocols on the list are allowedin addition to IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), and VLAN tagged frames (0x8100). All other protocols are implicitly denied (blocked).
        * Exclude ListOnly the protocols on the list are denied; all other protocols are implicitly allowed. You cannot exclude IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), or VLAN tagged frames (0x8100).
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileNonIpProtocolProtocolArgsDict']]]]
        """
        Protocol
        """
elif False:
    ZoneProtectionProfileNonIpProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileNonIpProtocolArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[_builtins.str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileNonIpProtocolProtocolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] list_type: Specify the type of list you are creating for protocol protection:
               * Include ListOnly the protocols on the list are allowedin addition to IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), and VLAN tagged frames (0x8100). All other protocols are implicitly denied (blocked).
               * Exclude ListOnly the protocols on the list are denied; all other protocols are implicitly allowed. You cannot exclude IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), or VLAN tagged frames (0x8100).
        :param pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileNonIpProtocolProtocolArgs']]] protocols: Protocol
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)

    @_builtins.property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the type of list you are creating for protocol protection:
        * Include ListOnly the protocols on the list are allowedin addition to IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), and VLAN tagged frames (0x8100). All other protocols are implicitly denied (blocked).
        * Exclude ListOnly the protocols on the list are denied; all other protocols are implicitly allowed. You cannot exclude IPv4 (0x0800), IPv6 (0x86DD), ARP (0x0806), or VLAN tagged frames (0x8100).
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "list_type", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileNonIpProtocolProtocolArgs']]]]:
        """
        Protocol
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZoneProtectionProfileNonIpProtocolProtocolArgs']]]]):
        pulumi.set(self, "protocols", value)


if not MYPY:
    class ZoneProtectionProfileNonIpProtocolProtocolArgsDict(TypedDict):
        ether_type: pulumi.Input[_builtins.str]
        """
        Enter an Ethertype code (protocol) preceded by 0x to indicate hexadecimal (range is 0x0000 to 0xFFFF). A list can have a maximum of 64 Ethertypes. Some sources of Ethertype codes are:
        * [IEEE hexadecimal Ethertype](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml)
        * [standards.ieee.org/develop/regauth/ethertype/eth.txt](https://standards-oui.ieee.org/ethertype/eth.txt)
        * [www.cavebear.com/archive/cavebear/Ethernet/type.html](https://www.cavebear.com/archive/cavebear/Ethernet/type.html)
        """
        name: pulumi.Input[_builtins.str]
        """
        Enter the protocol name that corresponds to the Ethertype code you are adding to the list. The firewall does not verify that the protocol name matches the Ethertype code but the Ethertype code does determine the protocol filter.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the Ethertype code on the list.
        """
elif False:
    ZoneProtectionProfileNonIpProtocolProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileNonIpProtocolProtocolArgs:
    def __init__(__self__, *,
                 ether_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] ether_type: Enter an Ethertype code (protocol) preceded by 0x to indicate hexadecimal (range is 0x0000 to 0xFFFF). A list can have a maximum of 64 Ethertypes. Some sources of Ethertype codes are:
               * [IEEE hexadecimal Ethertype](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml)
               * [standards.ieee.org/develop/regauth/ethertype/eth.txt](https://standards-oui.ieee.org/ethertype/eth.txt)
               * [www.cavebear.com/archive/cavebear/Ethernet/type.html](https://www.cavebear.com/archive/cavebear/Ethernet/type.html)
        :param pulumi.Input[_builtins.str] name: Enter the protocol name that corresponds to the Ethertype code you are adding to the list. The firewall does not verify that the protocol name matches the Ethertype code but the Ethertype code does determine the protocol filter.
        :param pulumi.Input[_builtins.bool] enable: Enable the Ethertype code on the list.
        """
        pulumi.set(__self__, "ether_type", ether_type)
        pulumi.set(__self__, "name", name)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter(name="etherType")
    def ether_type(self) -> pulumi.Input[_builtins.str]:
        """
        Enter an Ethertype code (protocol) preceded by 0x to indicate hexadecimal (range is 0x0000 to 0xFFFF). A list can have a maximum of 64 Ethertypes. Some sources of Ethertype codes are:
        * [IEEE hexadecimal Ethertype](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml)
        * [standards.ieee.org/develop/regauth/ethertype/eth.txt](https://standards-oui.ieee.org/ethertype/eth.txt)
        * [www.cavebear.com/archive/cavebear/Ethernet/type.html](https://www.cavebear.com/archive/cavebear/Ethernet/type.html)
        """
        return pulumi.get(self, "ether_type")

    @ether_type.setter
    def ether_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ether_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Enter the protocol name that corresponds to the Ethertype code you are adding to the list. The firewall does not verify that the protocol name matches the Ethertype code but the Ethertype code does determine the protocol filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the Ethertype code on the list.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class ZoneProtectionProfileScanArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The threat ID number.  These can be found in [Palo Alto Networks ThreatVault](https://threatvault.paloaltonetworks.com).
        * "8001" - TCP Port Scan
        * "8002" - Host Sweep
        * "8003" - UDP Port Scan
        * "8006" - Port Scan
        """
        action: NotRequired[pulumi.Input['ZoneProtectionProfileScanActionArgsDict']]
        """
        Action
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Interval
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold
        """
elif False:
    ZoneProtectionProfileScanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input['ZoneProtectionProfileScanActionArgs']] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The threat ID number.  These can be found in [Palo Alto Networks ThreatVault](https://threatvault.paloaltonetworks.com).
               * "8001" - TCP Port Scan
               * "8002" - Host Sweep
               * "8003" - UDP Port Scan
               * "8006" - Port Scan
        :param pulumi.Input['ZoneProtectionProfileScanActionArgs'] action: Action
        :param pulumi.Input[_builtins.int] interval: Interval
        :param pulumi.Input[_builtins.int] threshold: Threshold
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The threat ID number.  These can be found in [Palo Alto Networks ThreatVault](https://threatvault.paloaltonetworks.com).
        * "8001" - TCP Port Scan
        * "8002" - Host Sweep
        * "8003" - UDP Port Scan
        * "8006" - Port Scan
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['ZoneProtectionProfileScanActionArgs']]:
        """
        Action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['ZoneProtectionProfileScanActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ZoneProtectionProfileScanActionArgsDict(TypedDict):
        alert: NotRequired[pulumi.Input['ZoneProtectionProfileScanActionAlertArgsDict']]
        """
        Alert
        """
        allow: NotRequired[pulumi.Input['ZoneProtectionProfileScanActionAllowArgsDict']]
        """
        Allow
        """
        block: NotRequired[pulumi.Input['ZoneProtectionProfileScanActionBlockArgsDict']]
        """
        Block
        """
        block_ip: NotRequired[pulumi.Input['ZoneProtectionProfileScanActionBlockIpArgsDict']]
        """
        Block ip
        """
elif False:
    ZoneProtectionProfileScanActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanActionArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['ZoneProtectionProfileScanActionAlertArgs']] = None,
                 allow: Optional[pulumi.Input['ZoneProtectionProfileScanActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['ZoneProtectionProfileScanActionBlockArgs']] = None,
                 block_ip: Optional[pulumi.Input['ZoneProtectionProfileScanActionBlockIpArgs']] = None):
        """
        :param pulumi.Input['ZoneProtectionProfileScanActionAlertArgs'] alert: Alert
        :param pulumi.Input['ZoneProtectionProfileScanActionAllowArgs'] allow: Allow
        :param pulumi.Input['ZoneProtectionProfileScanActionBlockArgs'] block: Block
        :param pulumi.Input['ZoneProtectionProfileScanActionBlockIpArgs'] block_ip: Block ip
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if block_ip is not None:
            pulumi.set(__self__, "block_ip", block_ip)

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['ZoneProtectionProfileScanActionAlertArgs']]:
        """
        Alert
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['ZoneProtectionProfileScanActionAlertArgs']]):
        pulumi.set(self, "alert", value)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['ZoneProtectionProfileScanActionAllowArgs']]:
        """
        Allow
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['ZoneProtectionProfileScanActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['ZoneProtectionProfileScanActionBlockArgs']]:
        """
        Block
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['ZoneProtectionProfileScanActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter(name="blockIp")
    def block_ip(self) -> Optional[pulumi.Input['ZoneProtectionProfileScanActionBlockIpArgs']]:
        """
        Block ip
        """
        return pulumi.get(self, "block_ip")

    @block_ip.setter
    def block_ip(self, value: Optional[pulumi.Input['ZoneProtectionProfileScanActionBlockIpArgs']]):
        pulumi.set(self, "block_ip", value)


if not MYPY:
    class ZoneProtectionProfileScanActionAlertArgsDict(TypedDict):
        pass
elif False:
    ZoneProtectionProfileScanActionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanActionAlertArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZoneProtectionProfileScanActionAllowArgsDict(TypedDict):
        pass
elif False:
    ZoneProtectionProfileScanActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZoneProtectionProfileScanActionBlockArgsDict(TypedDict):
        pass
elif False:
    ZoneProtectionProfileScanActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanActionBlockArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZoneProtectionProfileScanActionBlockIpArgsDict(TypedDict):
        duration: pulumi.Input[_builtins.int]
        """
        Duration
        """
        track_by: pulumi.Input[_builtins.str]
        """
        Track by
        """
elif False:
    ZoneProtectionProfileScanActionBlockIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanActionBlockIpArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[_builtins.int],
                 track_by: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] duration: Duration
        :param pulumi.Input[_builtins.str] track_by: Track by
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "track_by", track_by)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.int]:
        """
        Duration
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="trackBy")
    def track_by(self) -> pulumi.Input[_builtins.str]:
        """
        Track by
        """
        return pulumi.get(self, "track_by")

    @track_by.setter
    def track_by(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "track_by", value)


if not MYPY:
    class ZoneProtectionProfileScanWhiteListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A descriptive name for the address to exclude.
        """
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv4
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ipv6
        """
elif False:
    ZoneProtectionProfileScanWhiteListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneProtectionProfileScanWhiteListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A descriptive name for the address to exclude.
        :param pulumi.Input[_builtins.str] ipv4: Ipv4
        :param pulumi.Input[_builtins.str] ipv6: Ipv6
        """
        pulumi.set(__self__, "name", name)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A descriptive name for the address to exclude.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv4
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ipv6
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZoneUserAclArgsDict(TypedDict):
        exclude_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Exclude list
        """
        include_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Include list
        """
elif False:
    ZoneUserAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneUserAclArgs:
    def __init__(__self__, *,
                 exclude_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_lists: Exclude list
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_lists: Include list
        """
        if exclude_lists is not None:
            pulumi.set(__self__, "exclude_lists", exclude_lists)
        if include_lists is not None:
            pulumi.set(__self__, "include_lists", include_lists)

    @_builtins.property
    @pulumi.getter(name="excludeLists")
    def exclude_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Exclude list
        """
        return pulumi.get(self, "exclude_lists")

    @exclude_lists.setter
    def exclude_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_lists", value)

    @_builtins.property
    @pulumi.getter(name="includeLists")
    def include_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Include list
        """
        return pulumi.get(self, "include_lists")

    @include_lists.setter
    def include_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_lists", value)


