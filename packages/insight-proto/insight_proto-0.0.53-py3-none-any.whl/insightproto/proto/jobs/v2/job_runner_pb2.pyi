"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import timestamp_pb2 as _timestamp_pb2
from google.protobuf.internal import containers as _containers
from insightproto.proto.common.v1 import common_pb2 as _common_pb2
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

@_typing.final
class ChatBlock(_message.Message):
    """ChatBlock is a wrapper of a chat message used to include the metadata and other data needed for auth/isolation"""

    DESCRIPTOR: _descriptor.Descriptor

    ORG_FIELD_NUMBER: _builtins.int
    CONVERSATION_ID_FIELD_NUMBER: _builtins.int
    RESPONSE_ID_FIELD_NUMBER: _builtins.int
    MSGS_FIELD_NUMBER: _builtins.int
    END_FIELD_NUMBER: _builtins.int
    CONTEXT_FIELD_NUMBER: _builtins.int
    conversation_id: _builtins.str
    """unique conversation/session identifier"""
    response_id: _builtins.str
    """the response id for tracking this specific response"""
    end: _builtins.bool
    """used to mark this as the last block and the completion should execute"""
    @_builtins.property
    def org(self) -> _common_pb2.Organisation:
        """The owner organisation"""

    @_builtins.property
    def msgs(self) -> _containers.RepeatedCompositeFieldContainer[Global___ChatMessage]:
        """the chat msgs in this block"""

    @_builtins.property
    def context(self) -> Global___ChatContext:
        """graph context to provide the AI with relevant system architecture data"""

    def __init__(
        self,
        *,
        org: _common_pb2.Organisation | None = ...,
        conversation_id: _builtins.str = ...,
        response_id: _builtins.str = ...,
        msgs: _abc.Iterable[Global___ChatMessage] | None = ...,
        end: _builtins.bool = ...,
        context: Global___ChatContext | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["context", b"context", "org", b"org"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["context", b"context", "conversation_id", b"conversation_id", "end", b"end", "msgs", b"msgs", "org", b"org", "response_id", b"response_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ChatBlock: _TypeAlias = ChatBlock  # noqa: Y015

@_typing.final
class ChatMessage(_message.Message):
    """ChatMessage represents a single message in a chat conversation"""

    DESCRIPTOR: _descriptor.Descriptor

    TIMESTAMP_FIELD_NUMBER: _builtins.int
    SEQUENCE_FIELD_NUMBER: _builtins.int
    HUMAN_FIELD_NUMBER: _builtins.int
    AI_FIELD_NUMBER: _builtins.int
    TOOL_FIELD_NUMBER: _builtins.int
    sequence: _builtins.int
    """this is the position of the message"""
    @_builtins.property
    def timestamp(self) -> _timestamp_pb2.Timestamp:
        """timestamp when message was sent"""

    @_builtins.property
    def human(self) -> Global___HumanMessage:
        """we need one of the message types
        we do not use 'one_of' as that is hard to serialise
        """

    @_builtins.property
    def ai(self) -> Global___AIMessage: ...
    @_builtins.property
    def tool(self) -> Global___ToolMessage: ...
    def __init__(
        self,
        *,
        timestamp: _timestamp_pb2.Timestamp | None = ...,
        sequence: _builtins.int = ...,
        human: Global___HumanMessage | None = ...,
        ai: Global___AIMessage | None = ...,
        tool: Global___ToolMessage | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_ai", b"_ai", "_human", b"_human", "_tool", b"_tool", "ai", b"ai", "human", b"human", "timestamp", b"timestamp", "tool", b"tool"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_ai", b"_ai", "_human", b"_human", "_tool", b"_tool", "ai", b"ai", "human", b"human", "sequence", b"sequence", "timestamp", b"timestamp", "tool", b"tool"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__ai: _TypeAlias = _typing.Literal["ai"]  # noqa: Y015
    _WhichOneofArgType__ai: _TypeAlias = _typing.Literal["_ai", b"_ai"]  # noqa: Y015
    _WhichOneofReturnType__human: _TypeAlias = _typing.Literal["human"]  # noqa: Y015
    _WhichOneofArgType__human: _TypeAlias = _typing.Literal["_human", b"_human"]  # noqa: Y015
    _WhichOneofReturnType__tool: _TypeAlias = _typing.Literal["tool"]  # noqa: Y015
    _WhichOneofArgType__tool: _TypeAlias = _typing.Literal["_tool", b"_tool"]  # noqa: Y015
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__ai) -> _WhichOneofReturnType__ai | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__human) -> _WhichOneofReturnType__human | None: ...
    @_typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__tool) -> _WhichOneofReturnType__tool | None: ...

Global___ChatMessage: _TypeAlias = ChatMessage  # noqa: Y015

@_typing.final
class HumanMessage(_message.Message):
    """HumanMessage for now can only be a text input"""

    DESCRIPTOR: _descriptor.Descriptor

    CONTENT_FIELD_NUMBER: _builtins.int
    content: _builtins.str
    """the text input"""
    def __init__(
        self,
        *,
        content: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["content", b"content"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___HumanMessage: _TypeAlias = HumanMessage  # noqa: Y015

@_typing.final
class AIMessage(_message.Message):
    """AIMessage is the response from an AI, it can be text + thoughts (optional), with optional tools"""

    DESCRIPTOR: _descriptor.Descriptor

    CONTENT_FIELD_NUMBER: _builtins.int
    TOOL_CALLS_FIELD_NUMBER: _builtins.int
    THINKING_BLOCKS_FIELD_NUMBER: _builtins.int
    content: _builtins.str
    """the test response"""
    @_builtins.property
    def tool_calls(self) -> _containers.RepeatedCompositeFieldContainer[Global___ToolCall]:
        """the tool calls sent"""

    @_builtins.property
    def thinking_blocks(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """the thinking or reasoning blocks"""

    def __init__(
        self,
        *,
        content: _builtins.str | None = ...,
        tool_calls: _abc.Iterable[Global___ToolCall] | None = ...,
        thinking_blocks: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_content", b"_content", "content", b"content"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_content", b"_content", "content", b"content", "thinking_blocks", b"thinking_blocks", "tool_calls", b"tool_calls"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__content: _TypeAlias = _typing.Literal["content"]  # noqa: Y015
    _WhichOneofArgType__content: _TypeAlias = _typing.Literal["_content", b"_content"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__content) -> _WhichOneofReturnType__content | None: ...

Global___AIMessage: _TypeAlias = AIMessage  # noqa: Y015

@_typing.final
class ToolCall(_message.Message):
    """ToolCall represents the call for a tool invocation"""

    DESCRIPTOR: _descriptor.Descriptor

    TOOL_CALL_ID_FIELD_NUMBER: _builtins.int
    NAME_FIELD_NUMBER: _builtins.int
    ARGS_FIELD_NUMBER: _builtins.int
    tool_call_id: _builtins.str
    """the tool call id"""
    name: _builtins.str
    """the tool name"""
    args: _builtins.str
    """the args serialised as a json string"""
    def __init__(
        self,
        *,
        tool_call_id: _builtins.str = ...,
        name: _builtins.str = ...,
        args: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["args", b"args", "name", b"name", "tool_call_id", b"tool_call_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolCall: _TypeAlias = ToolCall  # noqa: Y015

@_typing.final
class ToolMessage(_message.Message):
    """ToolMessage is a result of a tool call"""

    DESCRIPTOR: _descriptor.Descriptor

    CONTENT_FIELD_NUMBER: _builtins.int
    TOOL_CALL_ID_FIELD_NUMBER: _builtins.int
    content: _builtins.str
    """the result of the tool call"""
    tool_call_id: _builtins.str
    """the tool call id to match to"""
    def __init__(
        self,
        *,
        content: _builtins.str = ...,
        tool_call_id: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["content", b"content", "tool_call_id", b"tool_call_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ToolMessage: _TypeAlias = ToolMessage  # noqa: Y015

@_typing.final
class ChatContext(_message.Message):
    """ChatContext is the graph state visible to the user during chat
    This tells the AI what the user is currently looking at in the graph UI
    """

    DESCRIPTOR: _descriptor.Descriptor

    NODES_FIELD_NUMBER: _builtins.int
    EDGES_FIELD_NUMBER: _builtins.int
    GRAPH_SUMMARY_FIELD_NUMBER: _builtins.int
    graph_summary: _builtins.str
    """Optional natural language summary of what the user is viewing"""
    @_builtins.property
    def nodes(self) -> _containers.RepeatedCompositeFieldContainer[Global___GraphNode]:
        """Nodes currently visible in the user's graph view"""

    @_builtins.property
    def edges(self) -> _containers.RepeatedCompositeFieldContainer[Global___GraphEdge]:
        """Edges/relationships visible in the user's graph view"""

    def __init__(
        self,
        *,
        nodes: _abc.Iterable[Global___GraphNode] | None = ...,
        edges: _abc.Iterable[Global___GraphEdge] | None = ...,
        graph_summary: _builtins.str = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["edges", b"edges", "graph_summary", b"graph_summary", "nodes", b"nodes"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ChatContext: _TypeAlias = ChatContext  # noqa: Y015

@_typing.final
class GraphNode(_message.Message):
    """GraphNode represents a single node from the knowledge graph"""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class PropertiesEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    NODE_ID_FIELD_NUMBER: _builtins.int
    LABEL_FIELD_NUMBER: _builtins.int
    ID_FIELD_NUMBER: _builtins.int
    DISPLAY_NAME_FIELD_NUMBER: _builtins.int
    SUMMARY_FIELD_NUMBER: _builtins.int
    PROPERTIES_FIELD_NUMBER: _builtins.int
    SELECTED_FIELD_NUMBER: _builtins.int
    node_id: _builtins.str
    """Unique identifier for this node (Neo4j internal ID or UUID)"""
    label: _builtins.str
    """The node label/type e.g., "Service", "Class", "Function", "Repo" """
    id: _builtins.str
    """Opentrace id for the item"""
    display_name: _builtins.str
    """Human-readable name displayed to the user"""
    summary: _builtins.str
    """Brief summary of what this node represents/does (AI-friendly)"""
    selected: _builtins.bool
    """Whether the user has explicitly selected this node in the UI"""
    @_builtins.property
    def properties(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
        """Key properties as key-value pairs (filtered to relevant attributes)"""

    def __init__(
        self,
        *,
        node_id: _builtins.str = ...,
        label: _builtins.str = ...,
        id: _builtins.str = ...,
        display_name: _builtins.str = ...,
        summary: _builtins.str = ...,
        properties: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        selected: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["display_name", b"display_name", "id", b"id", "label", b"label", "node_id", b"node_id", "properties", b"properties", "selected", b"selected", "summary", b"summary"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GraphNode: _TypeAlias = GraphNode  # noqa: Y015

@_typing.final
class GraphEdge(_message.Message):
    """GraphEdge represents a relationship between two nodes"""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class PropertiesEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str = ...,
            value: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    EDGE_ID_FIELD_NUMBER: _builtins.int
    SOURCE_ID_FIELD_NUMBER: _builtins.int
    TARGET_ID_FIELD_NUMBER: _builtins.int
    RELATIONSHIP_TYPE_FIELD_NUMBER: _builtins.int
    SUMMARY_FIELD_NUMBER: _builtins.int
    PROPERTIES_FIELD_NUMBER: _builtins.int
    CONFIDENCE_FIELD_NUMBER: _builtins.int
    SELECTED_FIELD_NUMBER: _builtins.int
    edge_id: _builtins.str
    """The id of the db item"""
    source_id: _builtins.str
    """The node_id of the source/origin node"""
    target_id: _builtins.str
    """The node_id of the target/destination node"""
    relationship_type: _builtins.str
    """The relationship type e.g., "calls", "depends_on", "defined_in" """
    summary: _builtins.str
    """Optional summary of the relationship for additional context"""
    confidence: _builtins.float
    """Confidence score of this relationship (0.0 to 1.0)"""
    selected: _builtins.bool
    """Whether the user has explicitly selected this edge in the UI"""
    @_builtins.property
    def properties(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
        """Key properties as key-value pairs (filtered to relevant attributes)"""

    def __init__(
        self,
        *,
        edge_id: _builtins.str = ...,
        source_id: _builtins.str = ...,
        target_id: _builtins.str = ...,
        relationship_type: _builtins.str = ...,
        summary: _builtins.str = ...,
        properties: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        confidence: _builtins.float = ...,
        selected: _builtins.bool = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["confidence", b"confidence", "edge_id", b"edge_id", "properties", b"properties", "relationship_type", b"relationship_type", "selected", b"selected", "source_id", b"source_id", "summary", b"summary", "target_id", b"target_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___GraphEdge: _TypeAlias = GraphEdge  # noqa: Y015
