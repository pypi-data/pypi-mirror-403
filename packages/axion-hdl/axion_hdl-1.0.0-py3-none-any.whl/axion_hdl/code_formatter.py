"""
Code Formatter Module

Utilities for formatting generated code (VHDL, C, documentation).
Provides consistent code styling and formatting functions.
"""

from typing import List, Optional


class CodeFormatter:
    """
    Code formatting utilities for various output formats.
    
    Features:
    - VHDL code formatting and indentation
    - C/C++ code formatting
    - Markdown documentation formatting
    - Comment generation
    """
    
    @staticmethod
    def format_vhdl_entity_port(
        name: str,
        direction: str,
        type_str: str,
        is_last: bool = False,
        indent: int = 8
    ) -> str:
        """
        Format a VHDL entity port declaration.
        
        Args:
            name: Port name
            direction: Port direction (in, out, inout)
            type_str: Port type
            is_last: Whether this is the last port
            indent: Indentation spaces
            
        Returns:
            Formatted port declaration line
        """
        terminator = "" if is_last else ";"
        spaces = " " * indent
        return f"{spaces}{name:<20} : {direction:<6} {type_str}{terminator}"
    
    @staticmethod
    def format_vhdl_signal(
        name: str,
        type_str: str,
        default_value: Optional[str] = None,
        comment: Optional[str] = None,
        indent: int = 4
    ) -> str:
        """
        Format a VHDL signal declaration.
        
        Args:
            name: Signal name
            type_str: Signal type
            default_value: Default value (optional)
            comment: Inline comment (optional)
            indent: Indentation spaces
            
        Returns:
            Formatted signal declaration
        """
        spaces = " " * indent
        decl = f"{spaces}signal {name:<20} : {type_str}"
        
        if default_value:
            decl += f" := {default_value}"
        
        decl += ";"
        
        if comment:
            decl += f"  -- {comment}"
        
        return decl
    
    @staticmethod
    def format_vhdl_comment_block(
        lines: List[str],
        width: int = 80,
        char: str = '-'
    ) -> List[str]:
        """
        Format a VHDL comment block with border.
        
        Args:
            lines: Comment lines
            width: Total width of block
            char: Border character
            
        Returns:
            List of formatted comment lines
        """
        result = [char * width]
        
        for line in lines:
            if line:
                result.append(f"-- {line}")
            else:
                result.append("--")
        
        result.append(char * width)
        return result
    
    @staticmethod
    def format_vhdl_header(
        filename: str,
        description: str,
        additional_info: Optional[List[str]] = None,
        width: int = 80
    ) -> List[str]:
        """
        Format a standard VHDL file header.
        
        Args:
            filename: File name
            description: File description
            additional_info: Additional info lines
            width: Header width
            
        Returns:
            List of formatted header lines
        """
        lines = [
            f"File: {filename}",
            f"Description: {description}",
            "Generated by Axion HDL"
        ]
        
        if additional_info:
            lines.append("")
            lines.extend(additional_info)
        
        return CodeFormatter.format_vhdl_comment_block(lines, width)
    
    @staticmethod
    def format_c_macro(
        name: str,
        value: str,
        comment: Optional[str] = None,
        align_value: int = 40
    ) -> str:
        """
        Format a C preprocessor macro definition.
        
        Args:
            name: Macro name
            value: Macro value
            comment: Inline comment
            align_value: Column for value alignment
            
        Returns:
            Formatted macro definition
        """
        macro = f"#define {name}"
        padding = max(1, align_value - len(macro))
        macro += " " * padding + value
        
        if comment:
            macro += f"  /* {comment} */"
        
        return macro
    
    @staticmethod
    def format_c_header(
        filename: str,
        description: str,
        guard_name: str,
        additional_info: Optional[List[str]] = None
    ) -> List[str]:
        """
        Format a standard C header file header.
        
        Args:
            filename: File name
            description: File description
            guard_name: Include guard name
            additional_info: Additional info lines
            
        Returns:
            List of formatted header lines
        """
        lines = [
            "/**",
            f" * @file {filename}",
            f" * @brief {description}",
            " * @note Generated by Axion HDL",
            " */"
        ]
        
        if additional_info:
            lines.insert(-1, " *")
            for info in additional_info:
                lines.insert(-1, f" * {info}")
        
        lines.extend([
            "",
            f"#ifndef {guard_name}",
            f"#define {guard_name}",
            ""
        ])
        
        return lines
    
    @staticmethod
    def format_c_footer(guard_name: str) -> List[str]:
        """
        Format C header file footer with guard close.
        
        Args:
            guard_name: Include guard name
            
        Returns:
            List of formatted footer lines
        """
        return [
            "",
            f"#endif /* {guard_name} */",
            ""
        ]
    
    @staticmethod
    def format_markdown_table(
        headers: List[str],
        rows: List[List[str]],
        alignments: Optional[List[str]] = None
    ) -> List[str]:
        """
        Format a Markdown table.
        
        Args:
            headers: Column headers
            rows: Table rows (each row is list of column values)
            alignments: Column alignments ('left', 'center', 'right')
            
        Returns:
            List of formatted table lines
        """
        if not headers or not rows:
            return []
        
        # Calculate column widths
        widths = [len(h) for h in headers]
        for row in rows:
            for i, cell in enumerate(row):
                if i < len(widths):
                    widths[i] = max(widths[i], len(str(cell)))
        
        # Format header
        lines = []
        header_line = "| " + " | ".join(
            h.ljust(w) for h, w in zip(headers, widths)
        ) + " |"
        lines.append(header_line)
        
        # Format separator
        if alignments is None:
            alignments = ['left'] * len(headers)
        
        sep_parts = []
        for width, align in zip(widths, alignments):
            if align == 'center':
                sep_parts.append(':' + '-' * (width - 2) + ':')
            elif align == 'right':
                sep_parts.append('-' * (width - 1) + ':')
            else:  # left
                sep_parts.append('-' * width)
        
        separator = "| " + " | ".join(sep_parts) + " |"
        lines.append(separator)
        
        # Format rows
        for row in rows:
            # Pad row to match header length
            padded_row = list(row) + [''] * (len(headers) - len(row))
            row_line = "| " + " | ".join(
                str(cell).ljust(w) for cell, w in zip(padded_row, widths)
            ) + " |"
            lines.append(row_line)
        
        return lines
    
    @staticmethod
    def format_markdown_header(
        title: str,
        level: int = 1,
        add_anchor: bool = False
    ) -> str:
        """
        Format a Markdown header.
        
        Args:
            title: Header title
            level: Header level (1-6)
            add_anchor: Add anchor link
            
        Returns:
            Formatted header line
        """
        level = max(1, min(6, level))
        header = "#" * level + " " + title
        
        if add_anchor:
            anchor = title.lower().replace(' ', '-')
            anchor = ''.join(c for c in anchor if c.isalnum() or c == '-')
            header += f" {{#{anchor}}}"
        
        return header
    
    @staticmethod
    def format_markdown_code_block(
        code: str,
        language: str = ""
    ) -> List[str]:
        """
        Format a Markdown code block.
        
        Args:
            code: Code content
            language: Language identifier for syntax highlighting
            
        Returns:
            List of formatted code block lines
        """
        lines = [f"```{language}"]
        lines.extend(code.split('\n'))
        lines.append("```")
        return lines
    
    @staticmethod
    def indent_lines(
        lines: List[str],
        indent: int = 4,
        skip_empty: bool = True
    ) -> List[str]:
        """
        Indent a list of lines.
        
        Args:
            lines: Lines to indent
            indent: Number of spaces
            skip_empty: Don't indent empty lines
            
        Returns:
            List of indented lines
        """
        spaces = " " * indent
        result = []
        
        for line in lines:
            if skip_empty and not line.strip():
                result.append(line)
            else:
                result.append(spaces + line)
        
        return result
    
    @staticmethod
    def wrap_text(
        text: str,
        width: int = 80,
        indent: int = 0,
        subsequent_indent: int = 0
    ) -> List[str]:
        """
        Wrap text to specified width.
        
        Args:
            text: Text to wrap
            width: Maximum line width
            indent: First line indentation
            subsequent_indent: Subsequent line indentation
            
        Returns:
            List of wrapped lines
        """
        import textwrap
        
        wrapped = textwrap.fill(
            text,
            width=width,
            initial_indent=' ' * indent,
            subsequent_indent=' ' * subsequent_indent
        )
        
        return wrapped.split('\n')
