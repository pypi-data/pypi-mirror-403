"""
jFUSE Model Configuration.

Pydantic schema and configuration adapter for jFUSE (JAX-based FUSE) model settings.
jFUSE is a JAX-based implementation of the Framework for Understanding Structural Errors
(FUSE) model that supports automatic differentiation for gradient-based calibration.
"""

from typing import Dict, Any, List, Literal, Optional
from pydantic import BaseModel, Field, field_validator

from symfluence.models.base.base_config import AutoGeneratedConfigAdapter


# Default calibration parameters for jFUSE prms_gradient config (14 parameters)
# These parameters all have non-zero gradients with prms_gradient model structure
DEFAULT_CALIBRATION_PARAMS = [
    "S1_max",     # Upper storage capacity
    "S2_max",     # Lower storage capacity
    "ku",         # Upper layer drainage coefficient
    "ki",         # Interflow coefficient
    "ks",         # Baseflow coefficient (requires NONLINEAR baseflow)
    "n",          # Baseflow exponent (requires NONLINEAR baseflow)
    "Ac_max",     # Max saturated area fraction
    "b",          # Surface runoff shape parameter (UZ_PARETO)
    "f_rchr",     # Recharge fraction
    "T_rain",     # Rain/snow threshold temperature
    "T_melt",     # Snowmelt threshold temperature
    "MFMAX",      # Maximum melt factor
    "MFMIN",      # Minimum melt factor
    "smooth_frac",  # Overflow smoothing fraction
]


class JFUSEConfig(BaseModel):
    """
    jFUSE model configuration schema.

    Defines all configurable aspects of the jFUSE model including model structure,
    runtime options, calibration settings, and routing configuration.

    jFUSE supports multiple model structures (PRMS, Sacramento, TOPMODEL, VIC)
    and both lumped and distributed spatial modes with Muskingum-Cunge routing.
    """

    # =========================================================================
    # Model Structure Configuration
    # =========================================================================
    model_config_name: Literal['prms', 'prms_gradient', 'max_gradient', 'sacramento', 'topmodel', 'vic'] = Field(
        default='prms_gradient',
        description="jFUSE model structure. 'prms_gradient' (default) and 'max_gradient' are optimized for gradient-based calibration (ADAM/LBFGS)."
    )

    enable_snow: bool = Field(
        default=True,
        description="Enable snow accumulation and melt processes."
    )

    # =========================================================================
    # Spatial Configuration
    # =========================================================================
    spatial_mode: Literal['lumped', 'distributed', 'auto'] = Field(
        default='auto',
        description="Spatial modeling mode. 'auto' infers from domain definition."
    )

    n_hrus: int = Field(
        default=1,
        ge=1,
        description="Number of Hydrological Response Units (for distributed mode)."
    )

    enable_routing: bool = Field(
        default=False,
        description="Enable Muskingum-Cunge routing for distributed mode."
    )

    # =========================================================================
    # Runtime Configuration
    # =========================================================================
    warmup_days: int = Field(
        default=365,
        ge=0,
        description="Number of warmup days for model spinup."
    )

    timestep_days: float = Field(
        default=1.0,
        ge=0.01,
        le=1.0,
        description="Model timestep in days. Default is 1.0 (daily)."
    )

    jit_compile: bool = Field(
        default=True,
        description="JIT compile model for faster execution (JAX)."
    )

    use_gpu: bool = Field(
        default=False,
        description="Use GPU acceleration (requires JAX with CUDA support)."
    )

    # =========================================================================
    # Calibration Configuration
    # =========================================================================
    params_to_calibrate: str = Field(
        default='S1_max,S2_max,ku,ki,ks,n,Ac_max,b,f_rchr,T_rain,T_melt,MFMAX,MFMIN,smooth_frac',
        description="Comma-separated list of parameters to calibrate. Default set matches prms_gradient config for full gradient support."
    )

    routing_params_to_calibrate: str = Field(
        default='',
        description="Comma-separated list of routing parameters to calibrate (optional)."
    )

    use_gradient_calibration: bool = Field(
        default=True,
        description="Use gradient-based optimization (requires JAX). Falls back to evolutionary if False."
    )

    calibration_metric: Literal['KGE', 'NSE'] = Field(
        default='KGE',
        description="Objective function for calibration."
    )

    # =========================================================================
    # Input/Output Paths
    # =========================================================================
    forcing_file: Optional[str] = Field(
        default=None,
        description="Path to forcing data file (NetCDF or CSV)."
    )

    network_file: Optional[str] = Field(
        default=None,
        description="Path to river network file (required for distributed mode with routing)."
    )

    # =========================================================================
    # Initial State Values
    # =========================================================================
    initial_s1: float = Field(
        default=0.0,
        ge=0.0,
        description="Initial upper storage (mm)."
    )

    initial_s2: float = Field(
        default=50.0,
        ge=0.0,
        description="Initial lower storage (mm)."
    )

    initial_snow: float = Field(
        default=0.0,
        ge=0.0,
        description="Initial snow storage (mm SWE)."
    )

    # =========================================================================
    # Routing Configuration (for distributed mode)
    # =========================================================================
    routing_substep_method: Literal['fixed', 'adaptive'] = Field(
        default='adaptive',
        description="Sub-stepping method for Muskingum-Cunge routing stability."
    )

    routing_max_substeps: int = Field(
        default=10,
        ge=1,
        le=100,
        description="Maximum number of sub-timesteps for Muskingum-Cunge routing stability."
    )

    default_mannings_n: float = Field(
        default=0.035,
        ge=0.01,
        le=0.2,
        description="Default Manning's n roughness coefficient for channel routing."
    )

    default_channel_slope: float = Field(
        default=0.001,
        ge=0.00001,
        le=0.1,
        description="Default channel slope (m/m) when not available from data."
    )

    # =========================================================================
    # Output Configuration
    # =========================================================================
    save_states: bool = Field(
        default=False,
        description="Save internal state variables (storages, etc.) to output."
    )

    output_frequency: Literal['daily', 'timestep'] = Field(
        default='daily',
        description="Output frequency. 'timestep' preserves sub-daily resolution if available."
    )

    @field_validator('params_to_calibrate')
    @classmethod
    def validate_params(cls, v: str) -> str:
        """Validate that parameter names are recognized."""
        # Late import to avoid circular dependency
        try:
            from jfuse import PARAM_BOUNDS
            param_list = [p.strip() for p in v.split(',') if p.strip()]
            invalid = [p for p in param_list if p not in PARAM_BOUNDS]
            if invalid:
                # Log warning but don't fail - jFUSE may not be installed
                import logging
                logging.getLogger(__name__).warning(
                    f"Unknown jFUSE parameters: {invalid}. Valid parameters will be checked at runtime."
                )
        except ImportError:
            # jFUSE not installed, skip validation
            pass
        return v

    def get_calibration_params(self) -> List[str]:
        """Get list of parameters to calibrate."""
        return [p.strip() for p in self.params_to_calibrate.split(',') if p.strip()]

    def get_routing_calibration_params(self) -> List[str]:
        """Get list of routing parameters to calibrate."""
        if not self.routing_params_to_calibrate:
            return []
        return [p.strip() for p in self.routing_params_to_calibrate.split(',') if p.strip()]

    model_config = {'extra': 'forbid'}


class JFUSEConfigAdapter(AutoGeneratedConfigAdapter):
    """
    Configuration adapter for jFUSE model.

    Maps between config dictionary keys and JFUSEConfig schema.
    Uses AutoGeneratedConfigAdapter pattern for automatic field mapping.
    """

    MODEL_NAME = "JFUSE"
    CONFIG_PREFIX = "JFUSE_"

    @classmethod
    def get_config_schema(cls) -> type:
        """Return the Pydantic config schema class."""
        return JFUSEConfig

    @classmethod
    def get_defaults(cls) -> Dict[str, Any]:
        """Get default values for jFUSE configuration."""
        return {
            'JFUSE_MODEL_CONFIG_NAME': 'prms_gradient',
            'JFUSE_ENABLE_SNOW': True,
            'JFUSE_SPATIAL_MODE': 'auto',
            'JFUSE_N_HRUS': 1,
            'JFUSE_ENABLE_ROUTING': False,
            'JFUSE_WARMUP_DAYS': 365,
            'JFUSE_TIMESTEP_DAYS': 1.0,
            'JFUSE_JIT_COMPILE': True,
            'JFUSE_USE_GPU': False,
            'JFUSE_PARAMS_TO_CALIBRATE': 'S1_max,S2_max,ku,ki,ks,n,Ac_max,b,f_rchr,T_rain,T_melt,MFMAX,MFMIN,smooth_frac',
            'JFUSE_ROUTING_PARAMS_TO_CALIBRATE': '',
            'JFUSE_USE_GRADIENT_CALIBRATION': True,
            'JFUSE_CALIBRATION_METRIC': 'KGE',
            'JFUSE_INITIAL_S1': 0.0,
            'JFUSE_INITIAL_S2': 50.0,
            'JFUSE_INITIAL_SNOW': 0.0,
            'JFUSE_ROUTING_SUBSTEP_METHOD': 'adaptive',
            'JFUSE_ROUTING_MAX_SUBSTEPS': 10,
            'JFUSE_DEFAULT_MANNINGS_N': 0.035,
            'JFUSE_DEFAULT_CHANNEL_SLOPE': 0.001,
            'JFUSE_SAVE_STATES': False,
            'JFUSE_OUTPUT_FREQUENCY': 'daily',
        }

    @classmethod
    def get_field_transformers(cls) -> Dict[str, tuple]:
        """Get field transformation functions."""
        return {
            'JFUSE_MODEL_CONFIG_NAME': ('model_config_name', str),
            'JFUSE_ENABLE_SNOW': ('enable_snow', bool),
            'JFUSE_SPATIAL_MODE': ('spatial_mode', str),
            'JFUSE_N_HRUS': ('n_hrus', int),
            'JFUSE_ENABLE_ROUTING': ('enable_routing', bool),
            'JFUSE_WARMUP_DAYS': ('warmup_days', int),
            'JFUSE_TIMESTEP_DAYS': ('timestep_days', float),
            'JFUSE_JIT_COMPILE': ('jit_compile', bool),
            'JFUSE_USE_GPU': ('use_gpu', bool),
            'JFUSE_PARAMS_TO_CALIBRATE': ('params_to_calibrate', str),
            'JFUSE_ROUTING_PARAMS_TO_CALIBRATE': ('routing_params_to_calibrate', str),
            'JFUSE_USE_GRADIENT_CALIBRATION': ('use_gradient_calibration', bool),
            'JFUSE_CALIBRATION_METRIC': ('calibration_metric', str),
            'JFUSE_FORCING_FILE': ('forcing_file', str),
            'JFUSE_NETWORK_FILE': ('network_file', str),
            'JFUSE_INITIAL_S1': ('initial_s1', float),
            'JFUSE_INITIAL_S2': ('initial_s2', float),
            'JFUSE_INITIAL_SNOW': ('initial_snow', float),
            'JFUSE_ROUTING_SUBSTEP_METHOD': ('routing_substep_method', str),
            'JFUSE_ROUTING_MAX_SUBSTEPS': ('routing_max_substeps', int),
            'JFUSE_DEFAULT_MANNINGS_N': ('default_mannings_n', float),
            'JFUSE_DEFAULT_CHANNEL_SLOPE': ('default_channel_slope', float),
            'JFUSE_SAVE_STATES': ('save_states', bool),
            'JFUSE_OUTPUT_FREQUENCY': ('output_frequency', str),
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> JFUSEConfig:
        """
        Create JFUSEConfig from a configuration dictionary.

        Args:
            config_dict: Dictionary with JFUSE_* keys

        Returns:
            JFUSEConfig instance
        """
        transformers = cls.get_field_transformers()
        defaults = cls.get_defaults()

        kwargs = {}
        for config_key, (field_name, field_type) in transformers.items():
            value = config_dict.get(config_key, defaults.get(config_key))
            if value is not None:
                try:
                    kwargs[field_name] = field_type(value)
                except (ValueError, TypeError):
                    kwargs[field_name] = value

        return JFUSEConfig(**kwargs)

    @classmethod
    def to_dict(cls, config: JFUSEConfig) -> Dict[str, Any]:
        """
        Convert JFUSEConfig to configuration dictionary.

        Args:
            config: JFUSEConfig instance

        Returns:
            Dictionary with JFUSE_* keys
        """
        transformers = cls.get_field_transformers()
        result = {}

        for config_key, (field_name, _) in transformers.items():
            if hasattr(config, field_name):
                result[config_key] = getattr(config, field_name)

        return result
