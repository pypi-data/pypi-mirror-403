"""
cFUSE Model Configuration.

Pydantic schema and configuration adapter for cFUSE (differentiable FUSE) model settings.
cFUSE is a PyTorch/Enzyme AD implementation of the Framework for Understanding Structural
Errors (FUSE) model that supports automatic differentiation for gradient-based calibration.
"""

from typing import Dict, Any, List, Literal, Optional
from pydantic import BaseModel, Field, field_validator

from symfluence.models.base.base_config import AutoGeneratedConfigAdapter


# Default calibration parameters for cFUSE with prms config (14 parameters)
# Aligned with jFUSE defaults for consistency across FUSE implementations
DEFAULT_CALIBRATION_PARAMS = [
    "S1_max",     # Upper storage capacity
    "S2_max",     # Lower storage capacity
    "ku",         # Upper layer drainage coefficient
    "ki",         # Interflow coefficient
    "ks",         # Baseflow coefficient
    "n",          # Baseflow exponent
    "Ac_max",     # Max saturated area fraction
    "b",          # Surface runoff shape parameter
    "f_rchr",     # Recharge fraction
    "T_rain",     # Rain/snow threshold temperature
    "T_melt",     # Snowmelt threshold temperature
    "MFMAX",      # Maximum melt factor
    "MFMIN",      # Minimum melt factor
    "smooth_frac",  # Overflow smoothing fraction
]


class CFUSEConfig(BaseModel):
    """
    cFUSE model configuration schema.

    Defines all configurable aspects of the cFUSE model including model structure,
    runtime options, calibration settings, and gradient computation configuration.

    cFUSE supports multiple model structures (PRMS, Sacramento, TOPMODEL, VIC)
    and both lumped and distributed spatial modes with native gradient support.
    """

    # =========================================================================
    # Model Structure Configuration
    # =========================================================================
    model_structure: Literal['prms', 'sacramento', 'topmodel', 'vic', 'arno'] = Field(
        default='prms',
        description="cFUSE model structure preset. 'prms' (default) provides good gradient support for ADAM/LBFGS calibration."
    )

    enable_snow: bool = Field(
        default=True,
        description="Enable snow accumulation and melt processes."
    )

    # =========================================================================
    # Spatial Configuration
    # =========================================================================
    spatial_mode: Literal['lumped', 'distributed', 'auto'] = Field(
        default='auto',
        description="Spatial modeling mode. 'auto' infers from domain definition."
    )

    n_hrus: int = Field(
        default=1,
        ge=1,
        description="Number of Hydrological Response Units (for distributed mode)."
    )

    enable_routing: bool = Field(
        default=False,
        description="Enable flow routing for distributed mode."
    )

    # =========================================================================
    # Runtime Configuration
    # =========================================================================
    warmup_days: int = Field(
        default=365,
        ge=0,
        description="Number of warmup days for model spinup."
    )

    timestep_days: float = Field(
        default=1.0,
        ge=0.01,
        le=1.0,
        description="Model timestep in days. Default is 1.0 (daily)."
    )

    # =========================================================================
    # Gradient Computation Configuration
    # =========================================================================
    use_native_gradients: bool = Field(
        default=True,
        description="Use Enzyme AD for gradient computation if available. Falls back to numerical if False."
    )

    device: Literal['cpu', 'cuda'] = Field(
        default='cpu',
        description="PyTorch device for computation. 'cuda' requires GPU support."
    )

    # =========================================================================
    # Calibration Configuration
    # =========================================================================
    params_to_calibrate: str = Field(
        default='S1_max,S2_max,ku,ki,ks,n,Ac_max,b,f_rchr,T_rain,T_melt,MFMAX,MFMIN,smooth_frac',
        description="Comma-separated list of parameters to calibrate. Default set aligned with jFUSE for consistency."
    )

    use_gradient_calibration: bool = Field(
        default=True,
        description="Use gradient-based optimization (requires PyTorch). Falls back to evolutionary if False."
    )

    calibration_metric: Literal['KGE', 'NSE'] = Field(
        default='KGE',
        description="Objective function for calibration."
    )

    spatial_params: bool = Field(
        default=False,
        description="Enable spatially-varying parameters (per-HRU calibration)."
    )

    # =========================================================================
    # Input/Output Paths
    # =========================================================================
    forcing_file: Optional[str] = Field(
        default=None,
        description="Path to forcing data file (NetCDF or CSV)."
    )

    network_file: Optional[str] = Field(
        default=None,
        description="Path to river network file (required for distributed mode with routing)."
    )

    # =========================================================================
    # Initial State Values
    # =========================================================================
    initial_s1: float = Field(
        default=50.0,
        ge=0.0,
        description="Initial upper storage (mm)."
    )

    initial_s2: float = Field(
        default=200.0,
        ge=0.0,
        description="Initial lower storage (mm)."
    )

    initial_snow: float = Field(
        default=0.0,
        ge=0.0,
        description="Initial snow storage (mm SWE)."
    )

    # =========================================================================
    # Output Configuration
    # =========================================================================
    save_states: bool = Field(
        default=False,
        description="Save internal state variables (storages, etc.) to output."
    )

    output_frequency: Literal['daily', 'timestep'] = Field(
        default='daily',
        description="Output frequency. 'timestep' preserves sub-daily resolution if available."
    )

    @field_validator('params_to_calibrate')
    @classmethod
    def validate_params(cls, v: str) -> str:
        """Validate that parameter names are recognized."""
        # Late import to avoid circular dependency
        try:
            from cfuse import PARAM_BOUNDS
            param_list = [p.strip() for p in v.split(',') if p.strip()]
            invalid = [p for p in param_list if p not in PARAM_BOUNDS]
            if invalid:
                # Log warning but don't fail - cFUSE may not be installed
                import logging
                logging.getLogger(__name__).warning(
                    f"Unknown cFUSE parameters: {invalid}. Valid parameters will be checked at runtime."
                )
        except ImportError:
            # cFUSE not installed, skip validation
            pass
        return v

    def get_calibration_params(self) -> List[str]:
        """Get list of parameters to calibrate."""
        return [p.strip() for p in self.params_to_calibrate.split(',') if p.strip()]

    model_config = {'extra': 'forbid'}


class CFUSEConfigAdapter(AutoGeneratedConfigAdapter):
    """
    Configuration adapter for cFUSE model.

    Maps between config dictionary keys and CFUSEConfig schema.
    Uses AutoGeneratedConfigAdapter pattern for automatic field mapping.
    """

    MODEL_NAME = "CFUSE"
    CONFIG_PREFIX = "CFUSE_"

    @classmethod
    def get_config_schema(cls) -> type:
        """Return the Pydantic config schema class."""
        return CFUSEConfig

    @classmethod
    def get_defaults(cls) -> Dict[str, Any]:
        """Get default values for cFUSE configuration."""
        return {
            'CFUSE_MODEL_STRUCTURE': 'prms',
            'CFUSE_ENABLE_SNOW': True,
            'CFUSE_SPATIAL_MODE': 'auto',
            'CFUSE_N_HRUS': 1,
            'CFUSE_ENABLE_ROUTING': False,
            'CFUSE_WARMUP_DAYS': 365,
            'CFUSE_TIMESTEP_DAYS': 1.0,
            'CFUSE_USE_NATIVE_GRADIENTS': True,
            'CFUSE_DEVICE': 'cpu',
            'CFUSE_PARAMS_TO_CALIBRATE': 'S1_max,S2_max,ku,ki,ks,n,Ac_max,b,f_rchr,T_rain,T_melt,MFMAX,MFMIN,smooth_frac',
            'CFUSE_USE_GRADIENT_CALIBRATION': True,
            'CFUSE_CALIBRATION_METRIC': 'KGE',
            'CFUSE_SPATIAL_PARAMS': False,
            'CFUSE_INITIAL_S1': 50.0,
            'CFUSE_INITIAL_S2': 200.0,
            'CFUSE_INITIAL_SNOW': 0.0,
            'CFUSE_SAVE_STATES': False,
            'CFUSE_OUTPUT_FREQUENCY': 'daily',
        }

    @classmethod
    def get_field_transformers(cls) -> Dict[str, tuple]:
        """Get field transformation functions."""
        return {
            'CFUSE_MODEL_STRUCTURE': ('model_structure', str),
            'CFUSE_ENABLE_SNOW': ('enable_snow', bool),
            'CFUSE_SPATIAL_MODE': ('spatial_mode', str),
            'CFUSE_N_HRUS': ('n_hrus', int),
            'CFUSE_ENABLE_ROUTING': ('enable_routing', bool),
            'CFUSE_WARMUP_DAYS': ('warmup_days', int),
            'CFUSE_TIMESTEP_DAYS': ('timestep_days', float),
            'CFUSE_USE_NATIVE_GRADIENTS': ('use_native_gradients', bool),
            'CFUSE_DEVICE': ('device', str),
            'CFUSE_PARAMS_TO_CALIBRATE': ('params_to_calibrate', str),
            'CFUSE_USE_GRADIENT_CALIBRATION': ('use_gradient_calibration', bool),
            'CFUSE_CALIBRATION_METRIC': ('calibration_metric', str),
            'CFUSE_SPATIAL_PARAMS': ('spatial_params', bool),
            'CFUSE_FORCING_FILE': ('forcing_file', str),
            'CFUSE_NETWORK_FILE': ('network_file', str),
            'CFUSE_INITIAL_S1': ('initial_s1', float),
            'CFUSE_INITIAL_S2': ('initial_s2', float),
            'CFUSE_INITIAL_SNOW': ('initial_snow', float),
            'CFUSE_SAVE_STATES': ('save_states', bool),
            'CFUSE_OUTPUT_FREQUENCY': ('output_frequency', str),
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> CFUSEConfig:
        """
        Create CFUSEConfig from a configuration dictionary.

        Args:
            config_dict: Dictionary with CFUSE_* keys

        Returns:
            CFUSEConfig instance
        """
        transformers = cls.get_field_transformers()
        defaults = cls.get_defaults()

        kwargs = {}
        for config_key, (field_name, field_type) in transformers.items():
            value = config_dict.get(config_key, defaults.get(config_key))
            if value is not None:
                try:
                    kwargs[field_name] = field_type(value)
                except (ValueError, TypeError):
                    kwargs[field_name] = value

        return CFUSEConfig(**kwargs)

    @classmethod
    def to_dict(cls, config: CFUSEConfig) -> Dict[str, Any]:
        """
        Convert CFUSEConfig to configuration dictionary.

        Args:
            config: CFUSEConfig instance

        Returns:
            Dictionary with CFUSE_* keys
        """
        transformers = cls.get_field_transformers()
        result = {}

        for config_key, (field_name, _) in transformers.items():
            if hasattr(config, field_name):
                result[config_key] = getattr(config, field_name)

        return result
