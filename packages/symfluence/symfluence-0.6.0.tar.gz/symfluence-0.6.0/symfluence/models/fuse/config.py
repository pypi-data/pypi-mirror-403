"""
FUSE Model Configuration.

Provides configuration schema, defaults, transformers, and validation
for the Framework for Understanding Structural Errors (FUSE).

This module registers FUSE-specific configuration components with the
ModelRegistry, enabling the core config system to remain model-agnostic.

PHASE 2 REFACTORING: This adapter now uses AutoGeneratedConfigAdapter
to auto-generate defaults and transformers from Pydantic Field declarations.
All defaults are maintained in FUSEConfig (model_configs.py) for single
source of truth.
"""

from typing import Dict, Any
from symfluence.models.base import AutoGeneratedConfigAdapter, ConfigValidationError
from symfluence.core.config.models.model_configs import FUSEConfig


# ============================================================================
# FUSE Config Adapter
# ============================================================================

class FUSEConfigAdapter(AutoGeneratedConfigAdapter):
    """
    Configuration adapter for FUSE model with auto-generated defaults and transformers.

    Defaults and transformers are automatically extracted from FUSEConfig
    Pydantic model. Only custom validation logic is implemented here.

    This reduces boilerplate from ~140 lines to ~80 lines while maintaining
    all functionality. All defaults are now in FUSEConfig Field declarations.

    Example:
        >>> from symfluence.models.registry import ModelRegistry
        >>> adapter = ModelRegistry.get_config_adapter('FUSE')
        >>> defaults = adapter.get_defaults()  # Auto-generated from FUSEConfig
        >>> schema = adapter.get_config_schema()
    """

    def __init__(self, model_name: str = 'FUSE'):
        super().__init__(model_name)

    def get_config_schema(self):
        """Return FUSE Pydantic configuration schema."""
        return FUSEConfig

    def validate(self, config: Dict[str, Any]) -> None:
        """
        Validate FUSE-specific configuration.

        Args:
            config: Configuration dictionary (flat format with uppercase keys)

        Raises:
            ConfigValidationError: If configuration is invalid
        """
        # Check required fields
        required_fields = self.get_required_keys()
        missing_fields = []

        for field in required_fields:
            value = config.get(field)
            if value is None or value == '' or value == 'None':
                missing_fields.append(field)

        if missing_fields:
            raise ConfigValidationError(
                "FUSE configuration incomplete. Missing required fields:\n"
                + "\n".join(f"  • {field}" for field in missing_fields)
            )

        # Validate spatial mode
        spatial_mode = config.get('FUSE_SPATIAL_MODE', 'lumped')
        valid_modes = ['lumped', 'semi_distributed', 'distributed']
        if spatial_mode not in valid_modes:
            raise ConfigValidationError(
                f"Invalid FUSE_SPATIAL_MODE '{spatial_mode}'. "
                f"Must be one of: {', '.join(valid_modes)}"
            )

        # Validate routing requirements for distributed mode
        if spatial_mode in ['semi_distributed', 'distributed']:
            routing_model = config.get('ROUTING_MODEL', 'none')
            if routing_model == 'none':
                raise ConfigValidationError(
                    f"FUSE_SPATIAL_MODE='{spatial_mode}' requires ROUTING_MODEL "
                    f"to be set (e.g., 'mizuRoute')"
                )

        # Validate mizuRoute requirements if routing is enabled
        routing_model = config.get('ROUTING_MODEL', '').upper()
        if routing_model == 'MIZUROUTE':
            # Check canonical keys, with fallback to deprecated aliases
            mizu_checks = [
                ('MIZUROUTE_INSTALL_PATH', 'INSTALL_PATH_MIZUROUTE'),
                ('MIZUROUTE_EXE', 'EXE_NAME_MIZUROUTE'),
            ]
            mizu_missing = []
            for canonical, deprecated in mizu_checks:
                value = config.get(canonical) or config.get(deprecated)
                if not value or value in ['', 'None']:
                    mizu_missing.append(canonical)
            if mizu_missing:
                raise ConfigValidationError(
                    "mizuRoute routing enabled but configuration incomplete:\n"
                    + "\n".join(f"  • {field}" for field in mizu_missing)
                )

    def get_required_keys(self) -> list:
        """Get list of required configuration keys for FUSE."""
        return [
            'FUSE_EXE',
            'SETTINGS_FUSE_PATH',
        ]

    def get_conditional_requirements(self) -> Dict[str, Dict[str, list]]:
        """Get conditional requirements based on other config values."""
        return {
            'ROUTING_MODEL': {
                'mizuRoute': ['MIZUROUTE_INSTALL_PATH', 'MIZUROUTE_EXE'],
                'MIZUROUTE': ['MIZUROUTE_INSTALL_PATH', 'MIZUROUTE_EXE'],
                'none': [],
            },
            'FUSE_SPATIAL_MODE': {
                'distributed': ['ROUTING_MODEL'],
                'semi_distributed': ['ROUTING_MODEL'],
                'lumped': [],
            },
        }
