# serializer version: 1
# name: test_cdk_snapshots[scenario_0][scenario_0-Strands-custom auth; stm+ltm memory; custom headers]
  dict({
    'cdk': None,
    'cdk/bin': None,
    'cdk/bin/cdk.ts': '''
      #!/usr/bin/env node
      import * as cdk from 'aws-cdk-lib';
      import { BaseStackProps } from '../lib/types';
      import {
        DockerImageStack,
        AgentCoreStack
      } from '../lib/stacks';
      
      const app = new cdk.App();
      const deploymentProps: BaseStackProps = {
        appName: "testProj",
        /* If you don't specify 'env', this stack will be environment-agnostic.
         * Account/Region-dependent features and context lookups will not work,
         * but a single synthesized template can be deployed anywhere. */
      
        /* Uncomment the next line to specialize this stack for the AWS Account
         * and Region that are implied by the current CLI configuration. */
        // env: { account: process.env.CDK_DEFAULT_ACCOUNT, region: process.env.CDK_DEFAULT_REGION },
      
        /* Uncomment the next line if you know exactly what Account and Region you
         * want to deploy the stack to. */
        // env: { account: '123456789012', region: 'us-east-1' },
      
        /* For more information, see https://docs.aws.amazon.com/cdk/latest/guide/environments.html */
      }
      const dockerImageStack = new DockerImageStack(app, `testProj-DockerImageStack`, deploymentProps);
      const agentCoreStack = new AgentCoreStack(app, `testProj-AgentCoreStack`, {
        ...deploymentProps,
        imageUri: dockerImageStack.imageUri
      });
      agentCoreStack.addDependency(dockerImageStack);
    ''',
    'cdk/cdk.json': '''
      {
        "app": "npx ts-node --prefer-ts-exts bin/cdk.ts",
        "watch": {
          "include": [
            "**"
          ],
          "exclude": [
            "README.md",
            "cdk*.json",
            "**/*.d.ts",
            "**/*.js",
            "tsconfig.json",
            "package*.json",
            "yarn.lock",
            "node_modules",
            "test"
          ]
        },
        "context": {
          "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
          "@aws-cdk/core:checkSecretUsage": true,
          "@aws-cdk/core:target-partitions": [
            "aws",
            "aws-cn"
          ],
          "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
          "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
          "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
          "@aws-cdk/aws-iam:minimizePolicies": true,
          "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
          "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
          "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
          "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
          "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
          "@aws-cdk/core:enablePartitionLiterals": true,
          "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
          "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
          "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
          "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
          "@aws-cdk/aws-route53-patters:useCertificate": true,
          "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
          "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
          "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
          "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
          "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
          "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
          "@aws-cdk/aws-redshift:columnId": true,
          "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
          "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
          "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
          "@aws-cdk/aws-kms:aliasNameRef": true,
          "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
          "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
          "@aws-cdk/aws-efs:denyAnonymousAccess": true,
          "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
          "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
          "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
          "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
          "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
          "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
          "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
          "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
          "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
          "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
          "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
          "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
          "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
          "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
          "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
          "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
          "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
          "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
          "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
          "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
          "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
          "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
          "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
          "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
          "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
          "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
          "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
          "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
          "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
          "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true
        }
      }
    ''',
    'cdk/lib': None,
    'cdk/lib/stacks': None,
    'cdk/lib/stacks/agentcore-stack.ts': '''
      import * as cdk from 'aws-cdk-lib/core';
      import { Construct } from 'constructs/lib/construct';
      import * as bedrockagentcore from 'aws-cdk-lib/aws-bedrockagentcore';
      import * as iam from 'aws-cdk-lib/aws-iam';
      import * as lambda from 'aws-cdk-lib/aws-lambda'
      import * as cognito from 'aws-cdk-lib/aws-cognito';
      import { BaseStackProps } from '../types';
      import * as path from 'path';
      
      export interface AgentCoreStackProps extends BaseStackProps {
          imageUri: string
      }
      
      export class AgentCoreStack extends cdk.Stack {
          readonly agentCoreRuntime: bedrockagentcore.CfnRuntime;
          readonly agentCoreGateway: bedrockagentcore.CfnGateway;
          readonly agentCoreMemory: bedrockagentcore.CfnMemory;
          readonly mcpLambda: lambda.Function;
      
          constructor(scope: Construct, id: string, props: AgentCoreStackProps) {
              super(scope, id, props);
      
              const region = cdk.Stack.of(this).region;
              const accountId = cdk.Stack.of(this).account;
      
              /*****************************
              * AgentCore Gateway
              ******************************/
      
              this.mcpLambda = new lambda.Function(this, `${props.appName}-McpLambda`, {
                  runtime: lambda.Runtime.PYTHON_3_12,
                  handler: "handler.lambda_handler",
                  code: lambda.AssetCode.fromAsset(path.join(__dirname, '../../../mcp/lambda'))
              });
      
              const agentCoreGatewayRole = new iam.Role(this, `${props.appName}-AgentCoreGatewayRole`, {
                  assumedBy: new iam.ServicePrincipal('bedrock-agentcore.amazonaws.com'),
                  description: 'IAM role for Bedrock AgentCore Runtime',
              });
      
              this.mcpLambda.grantInvoke(agentCoreGatewayRole);
      
              // Create gateway resource
              // Cognito resources
              const cognitoUserPool = new cognito.UserPool(this, `${props.appName}-CognitoUserPool`);
      
              // create resource server to work with client credentials auth flow
              const cognitoResourceServerScope = {
                  scopeName: 'basic',
                  scopeDescription: 'Basic access to testProj',
              };
      
              const cognitoResourceServer = cognitoUserPool.addResourceServer(`${props.appName}-CognitoResourceServer`, {
                  identifier: `${props.appName}-CognitoResourceServer`,
                  scopes: [cognitoResourceServerScope],
              });
      
              const cognitoAppClient = new cognito.UserPoolClient(this, `${props.appName}-CognitoAppClient`, {
                  userPool: cognitoUserPool,
                  generateSecret: true,
                  oAuth: {
                      flows: {
                          clientCredentials: true,
                      },
                      scopes: [cognito.OAuthScope.resourceServer(cognitoResourceServer, cognitoResourceServerScope)],
                  },
                  supportedIdentityProviders: [cognito.UserPoolClientIdentityProvider.COGNITO],
              });
              const cognitoDomain = cognitoUserPool.addDomain(`${props.appName}-CognitoDomain`, {
                  cognitoDomain: {
                      domainPrefix: `${props.appName.toLowerCase()}-${region}`,
                  },
              });
              const cognitoTokenUrl = cognitoDomain.baseUrl() + '/oauth2/token';
      
              this.agentCoreGateway = new bedrockagentcore.CfnGateway(this, `${props.appName}-AgentCoreGateway`, {
                  name: `${props.appName}-Gateway`,
                  protocolType: "MCP",
                  roleArn: agentCoreGatewayRole.roleArn,
                  authorizerType: "CUSTOM_JWT",
                  authorizerConfiguration: {
                      customJwtAuthorizer: {
                      discoveryUrl:
                          'https://cognito-idp.' +
                          region +
                          '.amazonaws.com/' +
                          cognitoUserPool.userPoolId +
                          '/.well-known/openid-configuration',
                      allowedClients: [cognitoAppClient.userPoolClientId],
                      },
                  },
              });
      
              new bedrockagentcore.CfnGatewayTarget(this, `${props.appName}-AgentCoreGatewayLambdaTarget`, {
                  name: `${props.appName}-Target`,
                  gatewayIdentifier: this.agentCoreGateway.attrGatewayIdentifier,
                  credentialProviderConfigurations: [
                      {
                          credentialProviderType: "GATEWAY_IAM_ROLE",
                      },
                  ],
                  targetConfiguration: {
                      mcp: {
                          lambda: {
                              lambdaArn: this.mcpLambda.functionArn,
                              toolSchema: {
                                  inlinePayload: [
                                      {
                                          name: "placeholder_tool",
                                          description: "No-op tool that demonstrates passing arguments",
                                          inputSchema: {
                                              type: "object",
                                              properties: {
                                                  string_param: { type: 'string', description: 'Example string parameter' },
                                                  int_param: { type: 'integer', description: 'Example integer parameter' },
                                                  float_array_param: {
                                                      type: 'array',
                                                      description: 'Example float array parameter',
                                                      items: {
                                                          type: 'number',
                                                      }
                                                  }
                                              },
                                              required: []
                                          }
                                      }
                                  ]
                              }
                          }
                      }
                  }
              })
              
              /*****************************
              * AgentCore Memory
              ******************************/
      
              this.agentCoreMemory = new bedrockagentcore.CfnMemory(this, `${props.appName}-AgentCoreMemory`, {
                  name: "testProj_Memory",
                  eventExpiryDuration: 30,
                  description: "Memory resource with 30 days event expiry",
                  memoryStrategies: [
                      // can take a built-in strategy from https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/built-in-strategies.html or define a custom one
                  ],
              });
              
              /*****************************
              * AgentCore Runtime
              ******************************/
      
              // taken from https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html#runtime-permissions-execution
              const runtimePolicy = new iam.PolicyDocument({
                  statements: [
                      new iam.PolicyStatement({
                          sid: 'ECRImageAccess',
                          effect: iam.Effect.ALLOW,
                          actions: ['ecr:BatchGetImage', 'ecr:GetDownloadUrlForLayer'],
                          resources: [
                              `arn:aws:ecr:${region}:${accountId}:repository/*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['logs:DescribeLogStreams', 'logs:CreateLogGroup'],
                          resources: [
                              `arn:aws:logs:${region}:${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['logs:DescribeLogGroups'],
                          resources: [
                              `arn:aws:logs:${region}:${accountId}:log-group:*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['logs:CreateLogStream', 'logs:PutLogEvents'],
                          resources: [
                              `arn:aws:logs:${region}:${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          sid: 'ECRTokenAccess',
                          effect: iam.Effect.ALLOW,
                          actions: ['ecr:GetAuthorizationToken'],
                          resources: ['*'],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: [
                              'xray:PutTraceSegments',
                              'xray:PutTelemetryRecords',
                              'xray:GetSamplingRules',
                              'xray:GetSamplingTargets',
                          ],
                      resources: ['*'],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['cloudwatch:PutMetricData'],
                          resources: ['*'],
                          conditions: {
                              StringEquals: { 'cloudwatch:namespace': 'bedrock-agentcore' },
                          },
                      }),
                      new iam.PolicyStatement({
                          sid: 'GetAgentAccessToken',
                          effect: iam.Effect.ALLOW,
                          actions: [
                              'bedrock-agentcore:GetWorkloadAccessToken',
                              'bedrock-agentcore:GetWorkloadAccessTokenForJWT',
                              'bedrock-agentcore:GetWorkloadAccessTokenForUserId',
                          ],
                          resources: [
                              `arn:aws:bedrock-agentcore:${region}:${accountId}:workload-identity-directory/default`,
                              `arn:aws:bedrock-agentcore:${region}:${accountId}:workload-identity-directory/default/workload-identity/agentName-*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          sid: 'BedrockModelInvocation',
                          effect: iam.Effect.ALLOW,
                          actions: ['bedrock:InvokeModel', 'bedrock:InvokeModelWithResponseStream'],
                          resources: [
                              `arn:aws:bedrock:*::foundation-model/*`,
                              `arn:aws:bedrock:${region}:${accountId}:*`,
                          ],
                      }),
                  ],
              });
      
              const runtimeRole = new iam.Role(this, `${props.appName}-AgentCoreRuntimeRole`, {
                  assumedBy: new iam.ServicePrincipal('bedrock-agentcore.amazonaws.com'),
                  description: 'IAM role for Bedrock AgentCore Runtime',
                  inlinePolicies: {
                      RuntimeAccessPolicy: runtimePolicy
                  }
              });
      
              this.agentCoreRuntime = new bedrockagentcore.CfnRuntime(this, `${props.appName}-AgentCoreRuntime`, {
                  agentRuntimeArtifact: {
                      containerConfiguration: {
                          containerUri: props.imageUri
                      }
                  },
                  agentRuntimeName: "testProj_Agent",
                  protocolConfiguration: "HTTP",
                  networkConfiguration: {
                      networkMode: "PUBLIC"
                  },
                  roleArn: runtimeRole.roleArn,
                  environmentVariables: {
                      "AWS_REGION": region,
                      "GATEWAY_URL": this.agentCoreGateway.attrGatewayUrl,
                      
                      "MEMORY_ID":  this.agentCoreMemory.attrMemoryId,
                      "COGNITO_CLIENT_ID": cognitoAppClient.userPoolClientId,
                      "COGNITO_CLIENT_SECRET": cognitoAppClient.userPoolClientSecret.unsafeUnwrap(), // alternatives to consider: agentcore identity (no cdk constructs yet) or secrets manager
                      "COGNITO_TOKEN_URL": cognitoTokenUrl,
                      "COGNITO_SCOPE": `${cognitoResourceServer.userPoolResourceServerId}/${cognitoResourceServerScope.scopeName}`
                  }
              });
      
              // DEFAULT endpoint always points to newest published version. Optionally, can use these versioned endpoints below
              // https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/agent-runtime-versioning.html
              void new bedrockagentcore.CfnRuntimeEndpoint(this, `${props.appName}-AgentCoreRuntimeProdEndpoint`, {
                  agentRuntimeId: this.agentCoreRuntime.attrAgentRuntimeId,
                  agentRuntimeVersion: "1",
                  name: "PROD"
              });
      
              void new bedrockagentcore.CfnRuntimeEndpoint(this, `${props.appName}-AgentCoreRuntimeDevEndpoint`, {
                  agentRuntimeId: this.agentCoreRuntime.attrAgentRuntimeId,
                  agentRuntimeVersion: "1",
                  name: "DEV"
              });
          }
      }
    ''',
    'cdk/lib/stacks/docker-image-stack.ts': '''
      import * as cdk from 'aws-cdk-lib/core';
      import { Construct } from 'constructs/lib/construct';
      import * as ecr_assets from 'aws-cdk-lib/aws-ecr-assets'
      import { BaseStackProps } from '../types';
      import * as path from 'path';
      
      export interface DockerImageStackProps extends BaseStackProps {}
      
      export class DockerImageStack extends cdk.Stack {
          readonly imageUri: string
      
          constructor(scope: Construct, id: string, props: DockerImageStackProps) {
              super(scope, id, props);
      
              const asset = new ecr_assets.DockerImageAsset(this, `${props.appName}-AppImage`, {
                  directory: path.join(__dirname, "../../../"), // path to root of the project
              });
      
              this.imageUri = asset.imageUri;
              new cdk.CfnOutput(this, 'ImageUri', { value: this.imageUri });
          }
      }
    ''',
    'cdk/lib/stacks/index.ts': '''
      export * from './docker-image-stack';
      export * from './agentcore-stack';
    ''',
    'cdk/lib/test': None,
    'cdk/lib/test/cdk.test.ts': '''
      // import * as cdk from 'aws-cdk-lib';
      // import { Template } from 'aws-cdk-lib/assertions';
      // import * as Cdk from '../lib/cdk-stack';
      
      // example test. To run these tests, uncomment this file along with the
      // example resource in lib/cdk-stack.ts
      test('SQS Queue Created', () => {
      //   const app = new cdk.App();
      //     // WHEN
      //   const stack = new Cdk.CdkStack(app, 'MyTestStack');
      //     // THEN
      //   const template = Template.fromStack(stack);
      
      //   template.hasResourceProperties('AWS::SQS::Queue', {
      //     VisibilityTimeout: 300
      //   });
      });
    ''',
    'cdk/lib/types.ts': '''
      import * as cdk from 'aws-cdk-lib/core'
      
      export interface BaseStackProps extends cdk.StackProps {
          appName: string
      }
    ''',
    'cdk/package.json': '''
      {
        "name": "cdk",
        "version": "0.1.0",
        "bin": {
          "cdk": "bin/cdk.js"
        },
        "engines": {
          "node": ">=18.0.0"
        },
        "scripts": {
          "build": "tsc",
          "watch": "tsc -w",
          "test": "jest",
          "cdk": "cdk",
          "cdk:deploy": "cdk deploy --all",
          "cdk:deploy:ci": "cdk deploy --all --require-approval never"
        },
        "devDependencies": {
          "@types/jest": "^29.5.14",
          "@types/node": "22.7.9",
          "aws-cdk": "^2.1031.1",
          "jest": "^29.7.0",
          "ts-jest": "^29.2.5",
          "ts-node": "^10.9.2",
          "typescript": "~5.6.3"
        },
        "dependencies": {
          "aws-cdk-lib": "^2.226.0",
          "constructs": "^10.4.3"
        }
      }
    ''',
    'cdk/tsconfig.json': '''
      {
        "compilerOptions": {
          "target": "ES2020",
          "module": "commonjs",
          "lib": [
            "es2020",
            "dom"
          ],
          "declaration": true,
          "strict": true,
          "noImplicitAny": true,
          "strictNullChecks": true,
          "noImplicitThis": true,
          "alwaysStrict": true,
          "noUnusedLocals": false,
          "noUnusedParameters": false,
          "noImplicitReturns": true,
          "noFallthroughCasesInSwitch": false,
          "inlineSourceMap": true,
          "inlineSources": true,
          "experimentalDecorators": true,
          "strictPropertyInitialization": false,
          "typeRoots": [
            "./node_modules/@types"
          ]
        },
        "exclude": [
          "node_modules",
          "cdk.out"
        ]
      }
    ''',
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              â†’ e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/main.py': '''
      import os
      from strands import Agent, tool
      from strands_tools.code_interpreter import AgentCoreCodeInterpreter
      from bedrock_agentcore import BedrockAgentCoreApp
      from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig
      from bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager
      from .mcp_client.client import get_streamable_http_mcp_client
      from .model.load import load_model
      
      MEMORY_ID = os.getenv("BEDROCK_AGENTCORE_MEMORY_ID")
      REGION = os.getenv("AWS_REGION")
      
      if os.getenv("LOCAL_DEV") == "1":
          # In local dev, instantiate dummy MCP client so the code runs without deploying
          from contextlib import nullcontext
          from types import SimpleNamespace
          strands_mcp_client = nullcontext(SimpleNamespace(list_tools_sync=lambda: []))
      else:
          # Import AgentCore Gateway as Streamable HTTP MCP Client
          strands_mcp_client = get_streamable_http_mcp_client()
      
      # Define a simple function tool
      @tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      log = app.logger
      
      @app.entrypoint
      async def invoke(payload, context):
          session_id = getattr(context, 'session_id', 'default')
      
          # Configure memory if available
          session_manager = None
          if MEMORY_ID:
              session_manager = AgentCoreMemorySessionManager(
                  AgentCoreMemoryConfig(
                      memory_id=MEMORY_ID,
                      session_id=session_id,
                      actor_id="quickstart-user",
                      retrieval_config={
                          "/users/quickstart-user/facts": RetrievalConfig(top_k=3, relevance_score=0.5),
                          "/users/quickstart-user/preferences": RetrievalConfig(top_k=3, relevance_score=0.5)
                      }
                  ),
                  REGION
              )
          else:
              log.warning("MEMORY_ID is not set. Skipping memory session manager initialization.")
      
      
          # Create code interpreter
          code_interpreter = AgentCoreCodeInterpreter(
              region=REGION,
              session_name=session_id,
              auto_create=True,
              persist_sessions=True
          )
      
          with strands_mcp_client as client:
              # Get MCP Tools
              tools = client.list_tools_sync()
      
              # Create agent
              agent = Agent(
                  model=load_model(),
                  session_manager=session_manager,
                  system_prompt="""
                      You are a helpful assistant with code execution capabilities. Use tools when appropriate.
                  """,
                  tools=[code_interpreter.code_interpreter, add_numbers] + tools
              )
      
              # Execute and format response
              stream = agent.stream_async(payload.get("prompt"))
      
              async for event in stream:
                  # Handle Text parts of the response
                  if "data" in event and isinstance(event["data"], str):
                      yield event["data"]
      
                  # Implement additional handling for other events
                  # if "toolUse" in event:
                  #   # Process toolUse
      
                  # Handle end of stream
                  # if "result" in event:
                  #    yield(format_response(event["result"]))
      
      def format_response(result) -> str:
          """Extract code from metrics and format with LLM response."""
          parts = []
      
          # Extract executed code from metrics
          try:
              tool_metrics = result.metrics.tool_metrics.get('code_interpreter')
              if tool_metrics and hasattr(tool_metrics, 'tool'):
                  action = tool_metrics.tool['input']['code_interpreter_input']['action']
                  if 'code' in action:
                      parts.append(f"## Executed Code:\n```{action.get('language', 'python')}\n{action['code']}\n```\n---\n")
          except (AttributeError, KeyError):
              pass  # No code to extract
      
          # Add LLM response
          parts.append(f"## ðŸ“Š Result:\n{str(result)}")
          return "\n".join(parts)
      
      if __name__ == "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from mcp.client.streamable_http import streamablehttp_client
      from strands.tools.mcp.mcp_client import MCPClient
      import requests
      
      COGNITO_TOKEN_URL = os.getenv("COGNITO_TOKEN_URL")
      COGNITO_CLIENT_ID = os.getenv("COGNITO_CLIENT_ID")
      COGNITO_CLIENT_SECRET = os.getenv("COGNITO_CLIENT_SECRET")
      COGNITO_SCOPE = os.getenv("COGNITO_SCOPE")
      
      def _get_access_token():
          """
          Make a POST request to the Cognito OAuth token URL using client credentials.
          """
          response = requests.post(
              COGNITO_TOKEN_URL,
              auth=(COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET),
              data={
                  "grant_type": "client_credentials",
                  "scope": COGNITO_SCOPE,
              },
              headers={"Content-Type": "application/x-www-form-urlencoded"},
          )
          return response.json()["access_token"]
      
      
      def get_streamable_http_mcp_client() -> MCPClient:
          """
          Returns an MCP Client for AgentCore Gateway compatible with Strands
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MCPClient(lambda: streamablehttp_client(gateway_url, headers={"Authorization": f"Bearer {access_token}"}))
    ''',
    'src/model': None,
    'src/model/load.py': '''
      from strands.models import BedrockModel
      
      # Uses global inference profile for Claude Sonnet 4.5
      # https://docs.aws.amazon.com/bedrock/latest/userguide/inference-profiles-support.html
      MODEL_ID = "global.anthropic.claude-sonnet-4-5-20250929-v1:0"
      
      def load_model() -> BedrockModel:
          """
          Get Bedrock model client.
          Uses IAM authentication via the execution role.
          """
          return BedrockModel(model_id=MODEL_ID)
    ''',
  })
# ---
# name: test_cdk_snapshots[scenario_1][scenario_1-OpenAIAgents-default settings; stm memory]
  dict({
    'cdk': None,
    'cdk/bin': None,
    'cdk/bin/cdk.ts': '''
      #!/usr/bin/env node
      import * as cdk from 'aws-cdk-lib';
      import { BaseStackProps } from '../lib/types';
      import {
        DockerImageStack,
        AgentCoreStack
      } from '../lib/stacks';
      
      const app = new cdk.App();
      const deploymentProps: BaseStackProps = {
        appName: "testProj",
        /* If you don't specify 'env', this stack will be environment-agnostic.
         * Account/Region-dependent features and context lookups will not work,
         * but a single synthesized template can be deployed anywhere. */
      
        /* Uncomment the next line to specialize this stack for the AWS Account
         * and Region that are implied by the current CLI configuration. */
        // env: { account: process.env.CDK_DEFAULT_ACCOUNT, region: process.env.CDK_DEFAULT_REGION },
      
        /* Uncomment the next line if you know exactly what Account and Region you
         * want to deploy the stack to. */
        // env: { account: '123456789012', region: 'us-east-1' },
      
        /* For more information, see https://docs.aws.amazon.com/cdk/latest/guide/environments.html */
      }
      const dockerImageStack = new DockerImageStack(app, `testProj-DockerImageStack`, deploymentProps);
      const agentCoreStack = new AgentCoreStack(app, `testProj-AgentCoreStack`, {
        ...deploymentProps,
        imageUri: dockerImageStack.imageUri
      });
      agentCoreStack.addDependency(dockerImageStack);
    ''',
    'cdk/cdk.json': '''
      {
        "app": "npx ts-node --prefer-ts-exts bin/cdk.ts",
        "watch": {
          "include": [
            "**"
          ],
          "exclude": [
            "README.md",
            "cdk*.json",
            "**/*.d.ts",
            "**/*.js",
            "tsconfig.json",
            "package*.json",
            "yarn.lock",
            "node_modules",
            "test"
          ]
        },
        "context": {
          "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
          "@aws-cdk/core:checkSecretUsage": true,
          "@aws-cdk/core:target-partitions": [
            "aws",
            "aws-cn"
          ],
          "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
          "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
          "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
          "@aws-cdk/aws-iam:minimizePolicies": true,
          "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
          "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
          "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
          "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
          "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
          "@aws-cdk/core:enablePartitionLiterals": true,
          "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
          "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
          "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
          "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
          "@aws-cdk/aws-route53-patters:useCertificate": true,
          "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
          "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
          "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
          "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
          "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
          "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
          "@aws-cdk/aws-redshift:columnId": true,
          "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
          "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
          "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
          "@aws-cdk/aws-kms:aliasNameRef": true,
          "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
          "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
          "@aws-cdk/aws-efs:denyAnonymousAccess": true,
          "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
          "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
          "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
          "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
          "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
          "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
          "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
          "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
          "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
          "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
          "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
          "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
          "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
          "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
          "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
          "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
          "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
          "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
          "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
          "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
          "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
          "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
          "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
          "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
          "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
          "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
          "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
          "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
          "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
          "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true
        }
      }
    ''',
    'cdk/lib': None,
    'cdk/lib/stacks': None,
    'cdk/lib/stacks/agentcore-stack.ts': '''
      import * as cdk from 'aws-cdk-lib/core';
      import { Construct } from 'constructs/lib/construct';
      import * as bedrockagentcore from 'aws-cdk-lib/aws-bedrockagentcore';
      import * as iam from 'aws-cdk-lib/aws-iam';
      import * as lambda from 'aws-cdk-lib/aws-lambda'
      import * as cognito from 'aws-cdk-lib/aws-cognito';
      import { BaseStackProps } from '../types';
      import * as path from 'path';
      
      export interface AgentCoreStackProps extends BaseStackProps {
          imageUri: string
      }
      
      export class AgentCoreStack extends cdk.Stack {
          readonly agentCoreRuntime: bedrockagentcore.CfnRuntime;
          readonly agentCoreGateway: bedrockagentcore.CfnGateway;
          readonly agentCoreMemory: bedrockagentcore.CfnMemory;
          readonly mcpLambda: lambda.Function;
      
          constructor(scope: Construct, id: string, props: AgentCoreStackProps) {
              super(scope, id, props);
      
              const region = cdk.Stack.of(this).region;
              const accountId = cdk.Stack.of(this).account;
      
              /*****************************
              * AgentCore Gateway
              ******************************/
      
              this.mcpLambda = new lambda.Function(this, `${props.appName}-McpLambda`, {
                  runtime: lambda.Runtime.PYTHON_3_12,
                  handler: "handler.lambda_handler",
                  code: lambda.AssetCode.fromAsset(path.join(__dirname, '../../../mcp/lambda'))
              });
      
              const agentCoreGatewayRole = new iam.Role(this, `${props.appName}-AgentCoreGatewayRole`, {
                  assumedBy: new iam.ServicePrincipal('bedrock-agentcore.amazonaws.com'),
                  description: 'IAM role for Bedrock AgentCore Runtime',
              });
      
              this.mcpLambda.grantInvoke(agentCoreGatewayRole);
      
              // Create gateway resource
              // Cognito resources
              const cognitoUserPool = new cognito.UserPool(this, `${props.appName}-CognitoUserPool`);
      
              // create resource server to work with client credentials auth flow
              const cognitoResourceServerScope = {
                  scopeName: 'basic',
                  scopeDescription: 'Basic access to testProj',
              };
      
              const cognitoResourceServer = cognitoUserPool.addResourceServer(`${props.appName}-CognitoResourceServer`, {
                  identifier: `${props.appName}-CognitoResourceServer`,
                  scopes: [cognitoResourceServerScope],
              });
      
              const cognitoAppClient = new cognito.UserPoolClient(this, `${props.appName}-CognitoAppClient`, {
                  userPool: cognitoUserPool,
                  generateSecret: true,
                  oAuth: {
                      flows: {
                          clientCredentials: true,
                      },
                      scopes: [cognito.OAuthScope.resourceServer(cognitoResourceServer, cognitoResourceServerScope)],
                  },
                  supportedIdentityProviders: [cognito.UserPoolClientIdentityProvider.COGNITO],
              });
              const cognitoDomain = cognitoUserPool.addDomain(`${props.appName}-CognitoDomain`, {
                  cognitoDomain: {
                      domainPrefix: `${props.appName.toLowerCase()}-${region}`,
                  },
              });
              const cognitoTokenUrl = cognitoDomain.baseUrl() + '/oauth2/token';
      
              this.agentCoreGateway = new bedrockagentcore.CfnGateway(this, `${props.appName}-AgentCoreGateway`, {
                  name: `${props.appName}-Gateway`,
                  protocolType: "MCP",
                  roleArn: agentCoreGatewayRole.roleArn,
                  authorizerType: "CUSTOM_JWT",
                  authorizerConfiguration: {
                      customJwtAuthorizer: {
                      discoveryUrl:
                          'https://cognito-idp.' +
                          region +
                          '.amazonaws.com/' +
                          cognitoUserPool.userPoolId +
                          '/.well-known/openid-configuration',
                      allowedClients: [cognitoAppClient.userPoolClientId],
                      },
                  },
              });
      
              new bedrockagentcore.CfnGatewayTarget(this, `${props.appName}-AgentCoreGatewayLambdaTarget`, {
                  name: `${props.appName}-Target`,
                  gatewayIdentifier: this.agentCoreGateway.attrGatewayIdentifier,
                  credentialProviderConfigurations: [
                      {
                          credentialProviderType: "GATEWAY_IAM_ROLE",
                      },
                  ],
                  targetConfiguration: {
                      mcp: {
                          lambda: {
                              lambdaArn: this.mcpLambda.functionArn,
                              toolSchema: {
                                  inlinePayload: [
                                      {
                                          name: "placeholder_tool",
                                          description: "No-op tool that demonstrates passing arguments",
                                          inputSchema: {
                                              type: "object",
                                              properties: {
                                                  string_param: { type: 'string', description: 'Example string parameter' },
                                                  int_param: { type: 'integer', description: 'Example integer parameter' },
                                                  float_array_param: {
                                                      type: 'array',
                                                      description: 'Example float array parameter',
                                                      items: {
                                                          type: 'number',
                                                      }
                                                  }
                                              },
                                              required: []
                                          }
                                      }
                                  ]
                              }
                          }
                      }
                  }
              })
              
              /*****************************
              * AgentCore Memory
              ******************************/
      
              this.agentCoreMemory = new bedrockagentcore.CfnMemory(this, `${props.appName}-AgentCoreMemory`, {
                  name: "testProj_Memory",
                  eventExpiryDuration: 30,
                  description: "Memory resource with 30 days event expiry",
                  memoryStrategies: [
                      // can take a built-in strategy from https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/built-in-strategies.html or define a custom one
                  ],
              });
              
              /*****************************
              * AgentCore Runtime
              ******************************/
      
              // taken from https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html#runtime-permissions-execution
              const runtimePolicy = new iam.PolicyDocument({
                  statements: [
                      new iam.PolicyStatement({
                          sid: 'ECRImageAccess',
                          effect: iam.Effect.ALLOW,
                          actions: ['ecr:BatchGetImage', 'ecr:GetDownloadUrlForLayer'],
                          resources: [
                              `arn:aws:ecr:${region}:${accountId}:repository/*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['logs:DescribeLogStreams', 'logs:CreateLogGroup'],
                          resources: [
                              `arn:aws:logs:${region}:${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['logs:DescribeLogGroups'],
                          resources: [
                              `arn:aws:logs:${region}:${accountId}:log-group:*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['logs:CreateLogStream', 'logs:PutLogEvents'],
                          resources: [
                              `arn:aws:logs:${region}:${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          sid: 'ECRTokenAccess',
                          effect: iam.Effect.ALLOW,
                          actions: ['ecr:GetAuthorizationToken'],
                          resources: ['*'],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: [
                              'xray:PutTraceSegments',
                              'xray:PutTelemetryRecords',
                              'xray:GetSamplingRules',
                              'xray:GetSamplingTargets',
                          ],
                      resources: ['*'],
                      }),
                      new iam.PolicyStatement({
                          effect: iam.Effect.ALLOW,
                          actions: ['cloudwatch:PutMetricData'],
                          resources: ['*'],
                          conditions: {
                              StringEquals: { 'cloudwatch:namespace': 'bedrock-agentcore' },
                          },
                      }),
                      new iam.PolicyStatement({
                          sid: 'GetAgentAccessToken',
                          effect: iam.Effect.ALLOW,
                          actions: [
                              'bedrock-agentcore:GetWorkloadAccessToken',
                              'bedrock-agentcore:GetWorkloadAccessTokenForJWT',
                              'bedrock-agentcore:GetWorkloadAccessTokenForUserId',
                          ],
                          resources: [
                              `arn:aws:bedrock-agentcore:${region}:${accountId}:workload-identity-directory/default`,
                              `arn:aws:bedrock-agentcore:${region}:${accountId}:workload-identity-directory/default/workload-identity/agentName-*`,
                          ],
                      }),
                      new iam.PolicyStatement({
                          sid: 'BedrockModelInvocation',
                          effect: iam.Effect.ALLOW,
                          actions: ['bedrock:InvokeModel', 'bedrock:InvokeModelWithResponseStream'],
                          resources: [
                              `arn:aws:bedrock:*::foundation-model/*`,
                              `arn:aws:bedrock:${region}:${accountId}:*`,
                          ],
                      }),
                  ],
              });
      
              const runtimeRole = new iam.Role(this, `${props.appName}-AgentCoreRuntimeRole`, {
                  assumedBy: new iam.ServicePrincipal('bedrock-agentcore.amazonaws.com'),
                  description: 'IAM role for Bedrock AgentCore Runtime',
                  inlinePolicies: {
                      RuntimeAccessPolicy: runtimePolicy
                  }
              });
      
              this.agentCoreRuntime = new bedrockagentcore.CfnRuntime(this, `${props.appName}-AgentCoreRuntime`, {
                  agentRuntimeArtifact: {
                      containerConfiguration: {
                          containerUri: props.imageUri
                      }
                  },
                  agentRuntimeName: "testProj_Agent",
                  protocolConfiguration: "HTTP",
                  networkConfiguration: {
                      networkMode: "PUBLIC"
                  },
                  roleArn: runtimeRole.roleArn,
                  environmentVariables: {
                      "AWS_REGION": region,
                      "GATEWAY_URL": this.agentCoreGateway.attrGatewayUrl,
                      
                      "MEMORY_ID":  this.agentCoreMemory.attrMemoryId,
                      "COGNITO_CLIENT_ID": cognitoAppClient.userPoolClientId,
                      "COGNITO_CLIENT_SECRET": cognitoAppClient.userPoolClientSecret.unsafeUnwrap(), // alternatives to consider: agentcore identity (no cdk constructs yet) or secrets manager
                      "COGNITO_TOKEN_URL": cognitoTokenUrl,
                      "COGNITO_SCOPE": `${cognitoResourceServer.userPoolResourceServerId}/${cognitoResourceServerScope.scopeName}`
                  }
              });
      
              // DEFAULT endpoint always points to newest published version. Optionally, can use these versioned endpoints below
              // https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/agent-runtime-versioning.html
              void new bedrockagentcore.CfnRuntimeEndpoint(this, `${props.appName}-AgentCoreRuntimeProdEndpoint`, {
                  agentRuntimeId: this.agentCoreRuntime.attrAgentRuntimeId,
                  agentRuntimeVersion: "1",
                  name: "PROD"
              });
      
              void new bedrockagentcore.CfnRuntimeEndpoint(this, `${props.appName}-AgentCoreRuntimeDevEndpoint`, {
                  agentRuntimeId: this.agentCoreRuntime.attrAgentRuntimeId,
                  agentRuntimeVersion: "1",
                  name: "DEV"
              });
          }
      }
    ''',
    'cdk/lib/stacks/docker-image-stack.ts': '''
      import * as cdk from 'aws-cdk-lib/core';
      import { Construct } from 'constructs/lib/construct';
      import * as ecr_assets from 'aws-cdk-lib/aws-ecr-assets'
      import { BaseStackProps } from '../types';
      import * as path from 'path';
      
      export interface DockerImageStackProps extends BaseStackProps {}
      
      export class DockerImageStack extends cdk.Stack {
          readonly imageUri: string
      
          constructor(scope: Construct, id: string, props: DockerImageStackProps) {
              super(scope, id, props);
      
              const asset = new ecr_assets.DockerImageAsset(this, `${props.appName}-AppImage`, {
                  directory: path.join(__dirname, "../../../"), // path to root of the project
              });
      
              this.imageUri = asset.imageUri;
              new cdk.CfnOutput(this, 'ImageUri', { value: this.imageUri });
          }
      }
    ''',
    'cdk/lib/stacks/index.ts': '''
      export * from './docker-image-stack';
      export * from './agentcore-stack';
    ''',
    'cdk/lib/test': None,
    'cdk/lib/test/cdk.test.ts': '''
      // import * as cdk from 'aws-cdk-lib';
      // import { Template } from 'aws-cdk-lib/assertions';
      // import * as Cdk from '../lib/cdk-stack';
      
      // example test. To run these tests, uncomment this file along with the
      // example resource in lib/cdk-stack.ts
      test('SQS Queue Created', () => {
      //   const app = new cdk.App();
      //     // WHEN
      //   const stack = new Cdk.CdkStack(app, 'MyTestStack');
      //     // THEN
      //   const template = Template.fromStack(stack);
      
      //   template.hasResourceProperties('AWS::SQS::Queue', {
      //     VisibilityTimeout: 300
      //   });
      });
    ''',
    'cdk/lib/types.ts': '''
      import * as cdk from 'aws-cdk-lib/core'
      
      export interface BaseStackProps extends cdk.StackProps {
          appName: string
      }
    ''',
    'cdk/package.json': '''
      {
        "name": "cdk",
        "version": "0.1.0",
        "bin": {
          "cdk": "bin/cdk.js"
        },
        "engines": {
          "node": ">=18.0.0"
        },
        "scripts": {
          "build": "tsc",
          "watch": "tsc -w",
          "test": "jest",
          "cdk": "cdk",
          "cdk:deploy": "cdk deploy --all",
          "cdk:deploy:ci": "cdk deploy --all --require-approval never"
        },
        "devDependencies": {
          "@types/jest": "^29.5.14",
          "@types/node": "22.7.9",
          "aws-cdk": "^2.1031.1",
          "jest": "^29.7.0",
          "ts-jest": "^29.2.5",
          "ts-node": "^10.9.2",
          "typescript": "~5.6.3"
        },
        "dependencies": {
          "aws-cdk-lib": "^2.226.0",
          "constructs": "^10.4.3"
        }
      }
    ''',
    'cdk/tsconfig.json': '''
      {
        "compilerOptions": {
          "target": "ES2020",
          "module": "commonjs",
          "lib": [
            "es2020",
            "dom"
          ],
          "declaration": true,
          "strict": true,
          "noImplicitAny": true,
          "strictNullChecks": true,
          "noImplicitThis": true,
          "alwaysStrict": true,
          "noUnusedLocals": false,
          "noUnusedParameters": false,
          "noImplicitReturns": true,
          "noFallthroughCasesInSwitch": false,
          "inlineSourceMap": true,
          "inlineSources": true,
          "experimentalDecorators": true,
          "strictPropertyInitialization": false,
          "typeRoots": [
            "./node_modules/@types"
          ]
        },
        "exclude": [
          "node_modules",
          "cdk.out"
        ]
      }
    ''',
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              â†’ e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/main.py': '''
      import os
      from agents import Agent, Runner, function_tool
      from bedrock_agentcore.runtime import BedrockAgentCoreApp
      from mcp_client.client import get_streamable_http_mcp_client
      from model.load import load_model
      
      if os.getenv("LOCAL_DEV") == "1":
          from contextlib import nullcontext
          mcp_server = nullcontext(None)
      else:
          # Import AgentCore Gateway as Streamable HTTP MCP Server
          mcp_server = get_streamable_http_mcp_client()
      
      # Set environment variables for model authentication
      load_model()
      
      # Define a simple function tool
      @function_tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      logger = app.logger
      
      # Define an Agent with tools
      async def main(query):
          try:
              async with mcp_server as server:
                  active_servers = [server] if server else []
                  # Currently defaults to GPT-4.1
                  # https://openai.github.io/openai-agents-python/models/
                  agent = Agent(
                      name="testProj_Agent",
                      mcp_servers=active_servers,
                      tools=[add_numbers]
                  )
                  result = await Runner.run(agent, query)
                  return result
          except Exception as e:
              logger.error(f"Error during agent execution: {e}", exc_info=True)
              raise e
      
      @app.entrypoint
      async def agent_invocation(payload, context):
          # assume payload input is structured as { "prompt": "<user input>" }
      
          # Process the user prompt
          prompt = payload.get("prompt", "What is Agentic AI?")
      
          # Run the agent
          result = await main(prompt)
      
          # Return result
          return {"result": result.final_output}
      
      
      if __name__== "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from agents.mcp import MCPServerStreamableHttp
      import requests
      
      COGNITO_TOKEN_URL = os.getenv("COGNITO_TOKEN_URL")
      COGNITO_CLIENT_ID = os.getenv("COGNITO_CLIENT_ID")
      COGNITO_CLIENT_SECRET = os.getenv("COGNITO_CLIENT_SECRET")
      COGNITO_SCOPE = os.getenv("COGNITO_SCOPE")
      
      def _get_access_token():
          """
          Make a POST request to the Cognito OAuth token URL using client credentials.
          """
          response = requests.post(
              COGNITO_TOKEN_URL,
              auth=(COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET),
              data={
                  "grant_type": "client_credentials",
                  "scope": COGNITO_SCOPE,
              },
              headers={"Content-Type": "application/x-www-form-urlencoded"},
          )
          return response.json()["access_token"]
      
      
      def get_streamable_http_mcp_client() -> MCPServerStreamableHttp:
          """
          Returns an MCP Client for AgentCore Gateway compatible with OpenAI Agents SDK
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MCPServerStreamableHttp(
              name="AgentCore Gateway MCP",
              params={
                  "url": gateway_url,
                  "headers": {
                      "Authorization": f"Bearer {access_token}"
                  }
              }
          )
    ''',
    'src/model': None,
    'src/model/load.py': '''
      import os
      
      def _get_api_key() -> str:
          """Provide API key"""
          raise NotImplementedError("API key retrieval isn't implemented. Complete _get_api_key() in model/load.py.")
      
      def load_model() -> None:
          """
          Set up OpenAI API key authentication.
          Uses AgentCore Identity for API key management in deployed environments,
          and falls back to .env file for local development.
          Sets the OPENAI_API_KEY environment variable for the OpenAI Agents SDK.
          """
          api_key = _get_api_key()
          os.environ["OPENAI_API_KEY"] = api_key if api_key else ""
    ''',
  })
# ---
# name: test_terraform_snapshots[scenario_0][scenario_0-Strands-custom auth; stm+ltm memory; custom headers]
  dict({
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              â†’ e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/main.py': '''
      import os
      from strands import Agent, tool
      from strands_tools.code_interpreter import AgentCoreCodeInterpreter
      from bedrock_agentcore import BedrockAgentCoreApp
      from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig
      from bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager
      from .mcp_client.client import get_streamable_http_mcp_client
      from .model.load import load_model
      
      MEMORY_ID = os.getenv("BEDROCK_AGENTCORE_MEMORY_ID")
      REGION = os.getenv("AWS_REGION")
      
      if os.getenv("LOCAL_DEV") == "1":
          # In local dev, instantiate dummy MCP client so the code runs without deploying
          from contextlib import nullcontext
          from types import SimpleNamespace
          strands_mcp_client = nullcontext(SimpleNamespace(list_tools_sync=lambda: []))
      else:
          # Import AgentCore Gateway as Streamable HTTP MCP Client
          strands_mcp_client = get_streamable_http_mcp_client()
      
      # Define a simple function tool
      @tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      log = app.logger
      
      @app.entrypoint
      async def invoke(payload, context):
          session_id = getattr(context, 'session_id', 'default')
      
          # Configure memory if available
          session_manager = None
          if MEMORY_ID:
              session_manager = AgentCoreMemorySessionManager(
                  AgentCoreMemoryConfig(
                      memory_id=MEMORY_ID,
                      session_id=session_id,
                      actor_id="quickstart-user",
                      retrieval_config={
                          "/users/quickstart-user/facts": RetrievalConfig(top_k=3, relevance_score=0.5),
                          "/users/quickstart-user/preferences": RetrievalConfig(top_k=3, relevance_score=0.5)
                      }
                  ),
                  REGION
              )
          else:
              log.warning("MEMORY_ID is not set. Skipping memory session manager initialization.")
      
      
          # Create code interpreter
          code_interpreter = AgentCoreCodeInterpreter(
              region=REGION,
              session_name=session_id,
              auto_create=True,
              persist_sessions=True
          )
      
          with strands_mcp_client as client:
              # Get MCP Tools
              tools = client.list_tools_sync()
      
              # Create agent
              agent = Agent(
                  model=load_model(),
                  session_manager=session_manager,
                  system_prompt="""
                      You are a helpful assistant with code execution capabilities. Use tools when appropriate.
                  """,
                  tools=[code_interpreter.code_interpreter, add_numbers] + tools
              )
      
              # Execute and format response
              stream = agent.stream_async(payload.get("prompt"))
      
              async for event in stream:
                  # Handle Text parts of the response
                  if "data" in event and isinstance(event["data"], str):
                      yield event["data"]
      
                  # Implement additional handling for other events
                  # if "toolUse" in event:
                  #   # Process toolUse
      
                  # Handle end of stream
                  # if "result" in event:
                  #    yield(format_response(event["result"]))
      
      def format_response(result) -> str:
          """Extract code from metrics and format with LLM response."""
          parts = []
      
          # Extract executed code from metrics
          try:
              tool_metrics = result.metrics.tool_metrics.get('code_interpreter')
              if tool_metrics and hasattr(tool_metrics, 'tool'):
                  action = tool_metrics.tool['input']['code_interpreter_input']['action']
                  if 'code' in action:
                      parts.append(f"## Executed Code:\n```{action.get('language', 'python')}\n{action['code']}\n```\n---\n")
          except (AttributeError, KeyError):
              pass  # No code to extract
      
          # Add LLM response
          parts.append(f"## ðŸ“Š Result:\n{str(result)}")
          return "\n".join(parts)
      
      if __name__ == "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from mcp.client.streamable_http import streamablehttp_client
      from strands.tools.mcp.mcp_client import MCPClient
      import requests
      
      COGNITO_TOKEN_URL = os.getenv("COGNITO_TOKEN_URL")
      COGNITO_CLIENT_ID = os.getenv("COGNITO_CLIENT_ID")
      COGNITO_CLIENT_SECRET = os.getenv("COGNITO_CLIENT_SECRET")
      COGNITO_SCOPE = os.getenv("COGNITO_SCOPE")
      
      def _get_access_token():
          """
          Make a POST request to the Cognito OAuth token URL using client credentials.
          """
          response = requests.post(
              COGNITO_TOKEN_URL,
              auth=(COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET),
              data={
                  "grant_type": "client_credentials",
                  "scope": COGNITO_SCOPE,
              },
              headers={"Content-Type": "application/x-www-form-urlencoded"},
          )
          return response.json()["access_token"]
      
      
      def get_streamable_http_mcp_client() -> MCPClient:
          """
          Returns an MCP Client for AgentCore Gateway compatible with Strands
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MCPClient(lambda: streamablehttp_client(gateway_url, headers={"Authorization": f"Bearer {access_token}"}))
    ''',
    'src/model': None,
    'src/model/load.py': '''
      from strands.models import BedrockModel
      
      # Uses global inference profile for Claude Sonnet 4.5
      # https://docs.aws.amazon.com/bedrock/latest/userguide/inference-profiles-support.html
      MODEL_ID = "global.anthropic.claude-sonnet-4-5-20250929-v1:0"
      
      def load_model() -> BedrockModel:
          """
          Get Bedrock model client.
          Uses IAM authentication via the execution role.
          """
          return BedrockModel(model_id=MODEL_ID)
    ''',
    'terraform': None,
  })
# ---
# name: test_terraform_snapshots[scenario_1][scenario_1-OpenAIAgents-default settings; stm memory]
  dict({
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              â†’ e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/main.py': '''
      import os
      from agents import Agent, Runner, function_tool
      from bedrock_agentcore.runtime import BedrockAgentCoreApp
      from mcp_client.client import get_streamable_http_mcp_client
      from model.load import load_model
      
      if os.getenv("LOCAL_DEV") == "1":
          from contextlib import nullcontext
          mcp_server = nullcontext(None)
      else:
          # Import AgentCore Gateway as Streamable HTTP MCP Server
          mcp_server = get_streamable_http_mcp_client()
      
      # Set environment variables for model authentication
      load_model()
      
      # Define a simple function tool
      @function_tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      logger = app.logger
      
      # Define an Agent with tools
      async def main(query):
          try:
              async with mcp_server as server:
                  active_servers = [server] if server else []
                  # Currently defaults to GPT-4.1
                  # https://openai.github.io/openai-agents-python/models/
                  agent = Agent(
                      name="testProj_Agent",
                      mcp_servers=active_servers,
                      tools=[add_numbers]
                  )
                  result = await Runner.run(agent, query)
                  return result
          except Exception as e:
              logger.error(f"Error during agent execution: {e}", exc_info=True)
              raise e
      
      @app.entrypoint
      async def agent_invocation(payload, context):
          # assume payload input is structured as { "prompt": "<user input>" }
      
          # Process the user prompt
          prompt = payload.get("prompt", "What is Agentic AI?")
      
          # Run the agent
          result = await main(prompt)
      
          # Return result
          return {"result": result.final_output}
      
      
      if __name__== "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from agents.mcp import MCPServerStreamableHttp
      import requests
      
      COGNITO_TOKEN_URL = os.getenv("COGNITO_TOKEN_URL")
      COGNITO_CLIENT_ID = os.getenv("COGNITO_CLIENT_ID")
      COGNITO_CLIENT_SECRET = os.getenv("COGNITO_CLIENT_SECRET")
      COGNITO_SCOPE = os.getenv("COGNITO_SCOPE")
      
      def _get_access_token():
          """
          Make a POST request to the Cognito OAuth token URL using client credentials.
          """
          response = requests.post(
              COGNITO_TOKEN_URL,
              auth=(COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET),
              data={
                  "grant_type": "client_credentials",
                  "scope": COGNITO_SCOPE,
              },
              headers={"Content-Type": "application/x-www-form-urlencoded"},
          )
          return response.json()["access_token"]
      
      
      def get_streamable_http_mcp_client() -> MCPServerStreamableHttp:
          """
          Returns an MCP Client for AgentCore Gateway compatible with OpenAI Agents SDK
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MCPServerStreamableHttp(
              name="AgentCore Gateway MCP",
              params={
                  "url": gateway_url,
                  "headers": {
                      "Authorization": f"Bearer {access_token}"
                  }
              }
          )
    ''',
    'src/model': None,
    'src/model/load.py': '''
      import os
      
      def _get_api_key() -> str:
          """Provide API key"""
          raise NotImplementedError("API key retrieval isn't implemented. Complete _get_api_key() in model/load.py.")
      
      def load_model() -> None:
          """
          Set up OpenAI API key authentication.
          Uses AgentCore Identity for API key management in deployed environments,
          and falls back to .env file for local development.
          Sets the OPENAI_API_KEY environment variable for the OpenAI Agents SDK.
          """
          api_key = _get_api_key()
          os.environ["OPENAI_API_KEY"] = api_key if api_key else ""
    ''',
    'terraform': None,
  })
# ---
