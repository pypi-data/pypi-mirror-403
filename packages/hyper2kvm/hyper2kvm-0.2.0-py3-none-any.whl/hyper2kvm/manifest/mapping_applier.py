# SPDX-License-Identifier: LGPL-3.0-or-later
"""Mapping applier for network and storage batch migration transformations."""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any

from ..config.mapping_config import MACAddressPolicy, MappingConfig, NetworkMapping, StorageMapping
from ..core.logger import Log


class MappingApplier:
    """
    Applies network and storage mappings during VM conversion.

    This class provides utilities to transform source network/storage
    configurations to target KVM/libvirt equivalents based on mapping rules.
    """

    def __init__(
        self,
        mapping_config: MappingConfig,
        logger: logging.Logger | None = None,
    ):
        """
        Initialize mapping applier.

        Args:
            mapping_config: Combined network and storage mapping configuration
            logger: Logger instance
        """
        self.config = mapping_config
        self.logger = logger or logging.getLogger(__name__)

    def apply_network_mapping(
        self, source_network: str, source_mac: str | None = None
    ) -> dict[str, Any]:
        """
        Apply network mapping to transform source network to target configuration.

        Args:
            source_network: Source network name (e.g., "VM Network")
            source_mac: Source MAC address (optional)

        Returns:
            Dictionary with target network configuration:
            {
                "bridge": "br0",
                "mac": "52:54:00:12:34:56",
                "model": "virtio"
            }
        """
        network = self.config.network

        # Get target bridge
        target_bridge = network.get_target_bridge(source_network)
        if not target_bridge:
            # No mapping found, use default or source network name
            target_bridge = source_network
            Log.trace(
                self.logger,
                "ðŸŒ No network mapping for %r, using default: %s",
                source_network,
                target_bridge,
            )

        # Determine target MAC address
        target_mac = None
        if source_mac:
            if network.mac_address_policy == MACAddressPolicy.PRESERVE:
                target_mac = source_mac
                Log.trace(
                    self.logger, "ðŸŒ Preserving MAC address: %s", target_mac
                )
            elif network.mac_address_policy == MACAddressPolicy.CUSTOM:
                target_mac = network.get_target_mac(source_mac)
                if target_mac:
                    Log.trace(
                        self.logger,
                        "ðŸŒ Custom MAC mapping: %s -> %s",
                        source_mac,
                        target_mac,
                    )
                else:
                    # Custom policy but no override for this MAC
                    target_mac = source_mac
                    Log.trace(
                        self.logger,
                        "ðŸŒ No custom MAC override for %s, preserving",
                        source_mac,
                    )
            elif network.mac_address_policy == MACAddressPolicy.REGENERATE:
                # MAC will be regenerated by libvirt
                target_mac = None
                Log.trace(self.logger, "ðŸŒ MAC will be regenerated by libvirt")

        result = {
            "bridge": target_bridge,
            "mac": target_mac,
            "model": "virtio",  # Default to virtio for KVM
        }

        self.logger.debug(
            f"ðŸŒ Network mapping applied: {source_network} -> {result}"
        )

        return result

    def apply_storage_mapping(
        self, disk_id: str, default_output_dir: Path
    ) -> dict[str, Any]:
        """
        Apply storage mapping to determine disk output location and format.

        Args:
            disk_id: Disk identifier (e.g., "boot", "data", "disk0")
            default_output_dir: Default output directory if no mapping exists

        Returns:
            Dictionary with target storage configuration:
            {
                "output_path": Path("/var/lib/libvirt/images/boot"),
                "format": "qcow2",
                "pool": "vms"
            }
        """
        storage = self.config.storage

        # Get target output path
        output_path = storage.get_disk_output_path(disk_id)
        if not output_path:
            # No mapping found, use default output directory
            output_path = default_output_dir
            Log.trace(
                self.logger,
                "ðŸ’¾ No storage mapping for %r, using default: %s",
                disk_id,
                output_path,
            )
        else:
            Log.trace(
                self.logger,
                "ðŸ’¾ Storage mapping for %r: %s",
                disk_id,
                output_path,
            )

        # Get output format
        output_format = storage.get_output_format()

        result = {
            "output_path": output_path,
            "format": output_format,
            "pool": storage.default_pool,
            "preallocate": storage.preallocate,
        }

        self.logger.debug(
            f"ðŸ’¾ Storage mapping applied: {disk_id} -> {result['output_path']} ({result['format']})"
        )

        return result

    def apply_network_mappings_to_interfaces(
        self, interfaces: list[dict[str, Any]]
    ) -> list[dict[str, Any]]:
        """
        Apply network mappings to a list of network interfaces.

        Args:
            interfaces: List of interface dictionaries with source network info

        Returns:
            List of transformed interface configurations
        """
        if not interfaces:
            return []

        transformed = []
        for idx, iface in enumerate(interfaces):
            source_network = iface.get("network", "VM Network")
            source_mac = iface.get("mac")

            mapping = self.apply_network_mapping(source_network, source_mac)

            # Build transformed interface
            transformed_iface = {
                "type": "bridge",
                "source": {"bridge": mapping["bridge"]},
                "model": {"type": mapping["model"]},
            }

            # Add MAC if specified
            if mapping.get("mac"):
                transformed_iface["mac"] = {"address": mapping["mac"]}

            # Preserve any additional properties
            for key in ["vlan", "portgroup", "trust_guest_rx_filters"]:
                if key in iface:
                    transformed_iface[key] = iface[key]

            transformed.append(transformed_iface)

            self.logger.info(
                f"  Interface {idx}: {source_network} -> {mapping['bridge']}"
            )

        return transformed

    def apply_storage_mappings_to_disks(
        self, disks: list[dict[str, Any]], default_output_dir: Path
    ) -> list[dict[str, Any]]:
        """
        Apply storage mappings to a list of disk artifacts.

        Args:
            disks: List of disk dictionaries with source info
            default_output_dir: Default output directory

        Returns:
            List of transformed disk configurations
        """
        if not disks:
            return []

        transformed = []
        for disk in disks:
            disk_id = disk.get("id", disk.get("label", "unknown"))

            mapping = self.apply_storage_mapping(disk_id, default_output_dir)

            # Build transformed disk config
            transformed_disk = {
                "id": disk_id,
                "source_path": disk.get("source_path", disk.get("local_path")),
                "output_path": mapping["output_path"],
                "format": mapping["format"],
                "pool": mapping["pool"],
                "preallocate": mapping["preallocate"],
            }

            # Preserve additional properties
            for key in ["boot_order_hint", "disk_type", "label"]:
                if key in disk:
                    transformed_disk[key] = disk[key]

            transformed.append(transformed_disk)

            self.logger.info(
                f"  Disk {disk_id}: {mapping['output_path']} ({mapping['format']})"
            )

        return transformed

    def log_summary(self) -> None:
        """Log summary of configured mappings."""
        if self.config.has_network_mapping():
            self.logger.info("ðŸŒ Network mappings configured:")
            for src, dst in self.config.network.source_networks.items():
                self.logger.info(f"   {src} -> {dst}")
            self.logger.info(
                f"   MAC policy: {self.config.network.mac_address_policy.value}"
            )

        if self.config.has_storage_mapping():
            self.logger.info("ðŸ’¾ Storage mappings configured:")
            for disk_id, path in self.config.storage.disk_mappings.items():
                self.logger.info(f"   {disk_id} -> {path}")
            if self.config.storage.format_override:
                self.logger.info(
                    f"   Format override: {self.config.storage.format_override.value}"
                )

    @classmethod
    def from_manifest(
        cls, manifest: dict[str, Any], logger: logging.Logger | None = None
    ) -> MappingApplier | None:
        """
        Create MappingApplier from an Artifact Manifest v1.

        Args:
            manifest: Artifact Manifest dictionary
            logger: Logger instance

        Returns:
            MappingApplier instance if mappings are present, else None
        """
        mapping_config = MappingConfig.from_dict(manifest)

        # Only create applier if there are actual mappings
        if mapping_config.has_network_mapping() or mapping_config.has_storage_mapping():
            return cls(mapping_config, logger)

        return None
