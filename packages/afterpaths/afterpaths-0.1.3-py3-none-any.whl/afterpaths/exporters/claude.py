"""Claude Code exporter - writes to .claude/rules/ directory."""

import re
from datetime import datetime
from pathlib import Path

from .base import ExportResult, Rule, RuleExporter

# Category display names and filenames
CATEGORIES = {
    "dead_ends": ("Dead Ends: What Not to Try", "dead-ends.md"),
    "decisions": ("Decisions: Architectural Choices", "decisions.md"),
    "gotchas": ("Gotchas: Things to Watch For", "gotchas.md"),
    "patterns": ("Patterns: Techniques That Work", "patterns.md"),
}


class ClaudeExporter(RuleExporter):
    """Exports rules to .claude/rules/ for Claude Code.

    Creates separate markdown files per category that Claude Code
    automatically loads into context.
    """

    name = "claude"
    description = "Claude Code (.claude/rules/)"

    def detect(self, project_root: Path) -> bool:
        """Always available - Claude Code is our primary target."""
        return True

    def get_output_paths(self, project_root: Path) -> list[Path]:
        """Return paths for all category files."""
        rules_dir = project_root / ".claude" / "rules"
        return [rules_dir / filename for _, filename in CATEGORIES.values()]

    def export(self, rules: dict[str, list[Rule]], project_root: Path) -> ExportResult:
        """Write rules to .claude/rules/*.md files."""
        rules_dir = project_root / ".claude" / "rules"
        rules_dir.mkdir(parents=True, exist_ok=True)

        files_written = []
        total_rules = 0

        for category, (title, filename) in CATEGORIES.items():
            category_rules = rules.get(category, [])
            if not category_rules:
                continue

            file_path = rules_dir / filename
            content = self._format_category_file(title, category_rules)
            file_path.write_text(content)
            files_written.append(file_path)
            total_rules += len(category_rules)

        return ExportResult(
            target=self.name,
            files_written=files_written,
            rules_count=total_rules,
        )

    def load_existing(self, project_root: Path) -> dict[str, list[Rule]]:
        """Load existing rules from .claude/rules/ files."""
        rules_dir = project_root / ".claude" / "rules"
        if not rules_dir.exists():
            return {}

        existing = {}

        for category, (_, filename) in CATEGORIES.items():
            file_path = rules_dir / filename
            if file_path.exists():
                parsed = self._parse_rules_file(file_path, category)
                if parsed:
                    existing[category] = parsed

        return existing

    def _format_category_file(self, title: str, rules: list[Rule]) -> str:
        """Format rules into a markdown file."""
        # Count unique source sessions
        all_sessions = set()
        for rule in rules:
            all_sessions.update(rule.source_sessions)

        lines = [
            f"# {title}",
            "",
            f"> Auto-generated by `afterpaths distill` | Updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            f"> Sources: {len(all_sessions)} session(s)",
            "",
            "## Rules",
            "",
        ]

        for rule in rules:
            # Format source sessions (truncate to 8 chars each)
            sources = rule.source_sessions or ["unknown"]
            source_str = ", ".join(s[:8] for s in sources[:3])
            if len(sources) > 3:
                source_str += f" (+{len(sources) - 3} more)"

            lines.append(f"- **{rule.title}**: {rule.content}")
            lines.append(f"  _Source: {source_str}_")
            lines.append("")

        lines.extend([
            "---",
            "_Generated by afterpaths_",
        ])

        return "\n".join(lines)

    def _parse_rules_file(self, file_path: Path, category: str) -> list[Rule]:
        """Parse existing rules from a markdown file."""
        content = file_path.read_text()
        rules = []

        # Match rule pattern: - **Title**: Content\n  _Source: ..._
        pattern = r'-\s+\*\*([^*]+)\*\*:\s*(.+?)\n\s+_Source:\s*([^_]+)_'

        for match in re.finditer(pattern, content, re.MULTILINE):
            title = match.group(1).strip()
            rule_content = match.group(2).strip()
            source_str = match.group(3).strip()

            # Parse sources (handle "abc123, def456 (+2 more)" format)
            sources = []
            source_parts = source_str.replace("(+", "").replace("more)", "").split(",")
            for part in source_parts:
                part = part.strip()
                if part and not part.isdigit():
                    sources.append(part)

            rules.append(Rule(
                category=category,
                title=title,
                content=rule_content,
                source_sessions=sources,
            ))

        return rules
