"""LLM-powered session summarization focused on discoveries and learnings."""

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

from .sources.base import SessionEntry, SessionInfo
from .git_refs import extract_all_git_refs


@dataclass
class SummaryResult:
    """Result of session summarization with metadata."""

    content: str
    provider: str
    model: str
    input_tokens: int | None = None
    output_tokens: int | None = None

    def with_metadata_footer(self) -> str:
        """Return content with metadata footer appended."""
        tokens_info = ""
        if self.input_tokens or self.output_tokens:
            tokens_info = f" | Tokens: {self.input_tokens or '?'} in, {self.output_tokens or '?'} out"

        footer = f"\n\n---\n*Generated by {self.provider}/{self.model}{tokens_info}*"
        return self.content + footer


SUMMARIZATION_PROMPT = """Analyze this AI coding session transcript and extract a structured research log.

Your goal is to capture knowledge that would help someone (human or AI) working on this codebase in the future. Focus especially on:
- What was learned that wasn't obvious beforehand
- Approaches that failed and why (so others don't repeat them)
- Decisions made and the reasoning behind them
- Gotchas, edge cases, or surprises encountered
- Unresolved questions worth investigating

<transcript>
{transcript}
</transcript>

<session_metadata>
Project: {project}
Session duration: {duration}
Git refs detected: {git_refs}
Files modified: {files_modified}
</session_metadata>

{additional_context}

Produce a markdown research log with these sections. Skip any section that doesn't apply, but include at least Summary and one other section.

# [Descriptive title based on the main task/objective]

**Date:** {date} | **Duration:** {duration}
**Files:** {files_summary}
{git_refs_line}

## Summary
2-4 sentences: What was the goal? What was accomplished or explored?

## Discoveries
What was learned during this session? Include:
- Technical insights ("X works because Y")
- Codebase understanding ("The auth flow goes through Z")
- Tool/library behaviors ("Library X has quirk Y")
Format as bullet points. Be specific and actionable.

## Dead Ends
Approaches that were tried and abandoned. For each:
- What was attempted
- Why it didn't work
- How long was spent (if apparent)
This is crucial - it prevents repeating failed experiments.

## Decisions
Choices made during the session with rationale:
- **[Decision]** - Why this over alternatives

## Gotchas & Warnings
Specific things to watch out for in this codebase or domain:
- Edge cases encountered
- Non-obvious requirements
- Things that look right but aren't

## Open Questions
Unresolved items worth investigating later:
- Questions raised but not answered
- Areas that need more exploration
- Potential improvements identified but not implemented

---
Be concise but specific. Prefer concrete details over vague summaries. The goal is to create a searchable record that makes future work easier."""


UPDATE_PROMPT = """You are updating an existing research log summary based on a review of the original session transcript.

<existing_summary>
{existing_summary}
</existing_summary>

<transcript>
{transcript}
</transcript>

<session_metadata>
Project: {project}
Session duration: {duration}
Git refs detected: {git_refs}
Files modified: {files_modified}
</session_metadata>

{additional_context}

Review the existing summary against the transcript and improve it:
- Add any important discoveries, dead ends, or decisions that were missed
- Correct any inaccuracies
- Improve clarity or specificity where needed
- Remove anything that wasn't actually in the session

Keep the same markdown structure. If the existing summary is already good, make minimal changes.
Output the complete updated summary (not a diff)."""


def summarize_session(
    entries: list[SessionEntry],
    session: SessionInfo,
    additional_notes: str = "",
) -> SummaryResult:
    """Generate a structured summary from a session.

    Args:
        entries: Parsed session entries
        session: Session metadata
        additional_notes: Optional context from user

    Returns:
        SummaryResult with content and model metadata
    """
    from .llm import generate

    if not entries:
        return SummaryResult(
            content="# Empty Session\n\nNo conversation entries found.",
            provider="none",
            model="none",
        )

    # Prepare transcript
    transcript = format_transcript_for_summary(entries)

    # Extract metadata
    timestamps = [e.timestamp for e in entries if e.timestamp]
    duration = calculate_duration(timestamps)
    git_refs = extract_all_git_refs(entries)
    files_modified = extract_files_modified(entries)

    # Format metadata for prompt
    date_str = session.modified.strftime("%Y-%m-%d")
    duration_str = duration or "Unknown"

    git_refs_list = []
    if git_refs.get("branches"):
        git_refs_list.extend(f"branch:{b}" for b in sorted(git_refs["branches"])[:5])
    if git_refs.get("commits"):
        git_refs_list.extend(f"commit:{c}" for c in sorted(git_refs["commits"])[:5])
    git_refs_str = ", ".join(git_refs_list) if git_refs_list else "None detected"

    files_modified_list = sorted(files_modified)[:10]
    files_modified_str = ", ".join(Path(f).name for f in files_modified_list)
    if len(files_modified) > 10:
        files_modified_str += f" (+{len(files_modified) - 10} more)"
    if not files_modified_str:
        files_modified_str = "None detected"

    files_summary = f"{len(files_modified)} files modified" if files_modified else "Read-only session"
    git_refs_line = f"**Git refs:** {git_refs_str}" if git_refs_list else ""

    additional_context = ""
    if additional_notes:
        additional_context = f"<additional_context_from_user>\n{additional_notes}\n</additional_context_from_user>"

    # Build prompt
    prompt = SUMMARIZATION_PROMPT.format(
        transcript=transcript,
        project=session.project,
        duration=duration_str,
        git_refs=git_refs_str,
        files_modified=files_modified_str,
        date=date_str,
        files_summary=files_summary,
        git_refs_line=git_refs_line,
        additional_context=additional_context,
    )

    # Generate summary using configured LLM
    response = generate(prompt)

    return SummaryResult(
        content=response.content,
        provider=response.provider,
        model=response.model,
        input_tokens=response.input_tokens,
        output_tokens=response.output_tokens,
    )


def update_summary(
    entries: list[SessionEntry],
    session: SessionInfo,
    existing_summary: str,
    additional_notes: str = "",
) -> SummaryResult:
    """Update an existing summary by reviewing it against the transcript.

    Args:
        entries: Parsed session entries
        session: Session metadata
        existing_summary: The existing summary content to update
        additional_notes: Optional context from user

    Returns:
        SummaryResult with updated content and model metadata
    """
    from .llm import generate

    if not entries:
        return SummaryResult(
            content=existing_summary,
            provider="none",
            model="none",
        )

    # Prepare transcript
    transcript = format_transcript_for_summary(entries)

    # Extract metadata
    timestamps = [e.timestamp for e in entries if e.timestamp]
    duration = calculate_duration(timestamps)
    git_refs = extract_all_git_refs(entries)
    files_modified = extract_files_modified(entries)

    # Format metadata for prompt
    duration_str = duration or "Unknown"

    git_refs_list = []
    if git_refs.get("branches"):
        git_refs_list.extend(f"branch:{b}" for b in sorted(git_refs["branches"])[:5])
    if git_refs.get("commits"):
        git_refs_list.extend(f"commit:{c}" for c in sorted(git_refs["commits"])[:5])
    git_refs_str = ", ".join(git_refs_list) if git_refs_list else "None detected"

    files_modified_list = sorted(files_modified)[:10]
    files_modified_str = ", ".join(Path(f).name for f in files_modified_list)
    if len(files_modified) > 10:
        files_modified_str += f" (+{len(files_modified) - 10} more)"
    if not files_modified_str:
        files_modified_str = "None detected"

    additional_context = ""
    if additional_notes:
        additional_context = f"<update_instructions>\n{additional_notes}\n</update_instructions>"

    # Strip metadata footer from existing summary if present
    clean_summary = existing_summary
    if "\n---\n*Generated by" in clean_summary:
        clean_summary = clean_summary.split("\n---\n*Generated by")[0].strip()

    # Build prompt
    prompt = UPDATE_PROMPT.format(
        existing_summary=clean_summary,
        transcript=transcript,
        project=session.project,
        duration=duration_str,
        git_refs=git_refs_str,
        files_modified=files_modified_str,
        additional_context=additional_context,
    )

    # Generate updated summary using configured LLM
    response = generate(prompt)

    return SummaryResult(
        content=response.content,
        provider=response.provider,
        model=response.model,
        input_tokens=response.input_tokens,
        output_tokens=response.output_tokens,
    )


def format_transcript_for_summary(entries: list[SessionEntry], max_chars: int = 80000) -> str:
    """Format session entries into a readable transcript for summarization.

    Prioritizes user messages and assistant responses, truncates tool results.
    """
    lines = []

    for entry in entries:
        ts = entry.timestamp[:16] if entry.timestamp else ""

        if entry.role == "user":
            content = entry.content[:2000]
            if len(entry.content) > 2000:
                content += "..."
            lines.append(f"[{ts}] USER: {content}")

        elif entry.role == "assistant":
            if entry.tool_name:
                # Summarize tool calls
                tool_input_preview = ""
                if entry.tool_input:
                    if "file_path" in entry.tool_input:
                        tool_input_preview = f" -> {entry.tool_input['file_path']}"
                    elif "pattern" in entry.tool_input:
                        tool_input_preview = f" -> {entry.tool_input['pattern']}"
                    elif "command" in entry.tool_input:
                        cmd = entry.tool_input["command"][:100]
                        tool_input_preview = f" -> {cmd}"
                lines.append(f"[{ts}] TOOL: {entry.tool_name}{tool_input_preview}")
            else:
                content = entry.content[:2000]
                if len(entry.content) > 2000:
                    content += "..."
                lines.append(f"[{ts}] ASSISTANT: {content}")

        elif entry.role == "tool_result":
            # Heavily truncate tool results - they're often verbose
            preview = entry.content[:300]
            if len(entry.content) > 300:
                preview += f"... [{len(entry.content)} chars total]"
            lines.append(f"  <- {preview}")

    full_text = "\n".join(lines)

    # Truncate if too long, keeping beginning and end
    if len(full_text) > max_chars:
        half = max_chars // 2
        full_text = (
            full_text[:half]
            + "\n\n[... transcript truncated for length ...]\n\n"
            + full_text[-half:]
        )

    return full_text


def calculate_duration(timestamps: list[str]) -> str | None:
    """Calculate session duration from timestamps."""
    if len(timestamps) < 2:
        return None

    try:
        # Parse first and last timestamps
        start = datetime.fromisoformat(timestamps[0].replace("Z", "+00:00"))
        end = datetime.fromisoformat(timestamps[-1].replace("Z", "+00:00"))

        delta = end - start
        total_seconds = int(delta.total_seconds())

        if total_seconds < 60:
            return f"{total_seconds}s"

        hours, remainder = divmod(total_seconds, 3600)
        minutes, _ = divmod(remainder, 60)

        if hours:
            return f"{hours}h {minutes}m"
        return f"{minutes}m"

    except Exception:
        return None


def extract_files_modified(entries: list[SessionEntry]) -> set[str]:
    """Extract files that were modified (written/edited) in the session."""
    files = set()

    for entry in entries:
        if not entry.tool_name or not entry.tool_input:
            continue

        tool = entry.tool_name.lower()

        if tool in ("write", "edit"):
            file_path = entry.tool_input.get("file_path")
            if file_path:
                files.add(file_path)

        elif tool == "notebookedit":
            notebook_path = entry.tool_input.get("notebook_path")
            if notebook_path:
                files.add(notebook_path)

    return files
