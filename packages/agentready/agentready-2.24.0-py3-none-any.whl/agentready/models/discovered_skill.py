"""DiscoveredSkill model for patterns extracted from assessments."""

from dataclasses import dataclass, field

from .citation import Citation


@dataclass
class DiscoveredSkill:
    """Represents a pattern that could become a Claude Code skill.

    Attributes:
        skill_id: Unique identifier (lowercase-hyphen format, e.g., "setup-claude-md")
        name: Human-readable name (e.g., "Setup CLAUDE.md Configuration")
        description: Invocation-optimized description for SKILL.md frontmatter
        confidence: How confident we are in this pattern (0-100)
        source_attribute_id: ID of attribute this pattern came from
        reusability_score: How often this pattern appears (0-100)
        impact_score: Potential score improvement from applying this skill (0-100)
        pattern_summary: Human-readable pattern description
        code_examples: List of example implementations
        citations: Research sources supporting this pattern
    """

    skill_id: str
    name: str
    description: str
    confidence: float
    source_attribute_id: str
    reusability_score: float
    impact_score: float
    pattern_summary: str
    code_examples: list[str] = field(default_factory=list)
    citations: list[Citation] = field(default_factory=list)

    def __post_init__(self):
        """Validate discovered skill data after initialization."""
        if not self.skill_id:
            raise ValueError("Skill ID must be non-empty")

        # Validate skill_id format (lowercase-hyphen)
        if not self.skill_id.replace("-", "").replace("_", "").isalnum():
            raise ValueError(
                f"Skill ID must be lowercase alphanumeric with hyphens: {self.skill_id}"
            )

        if not self.name:
            raise ValueError("Skill name must be non-empty")

        if not self.description:
            raise ValueError("Skill description must be non-empty")

        if len(self.description) > 1024:
            raise ValueError(
                f"Skill description too long ({len(self.description)} chars, max 1024)"
            )

        if not 0.0 <= self.confidence <= 100.0:
            raise ValueError(
                f"Confidence must be in range [0.0, 100.0]: {self.confidence}"
            )

        if not 0.0 <= self.reusability_score <= 100.0:
            raise ValueError(
                f"Reusability score must be in range [0.0, 100.0]: {self.reusability_score}"
            )

        if not 0.0 <= self.impact_score <= 100.0:
            raise ValueError(
                f"Impact score must be in range [0.0, 100.0]: {self.impact_score}"
            )

        if not self.source_attribute_id:
            raise ValueError("Source attribute ID must be non-empty")

        if not self.pattern_summary:
            raise ValueError("Pattern summary must be non-empty")

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "skill_id": self.skill_id,
            "name": self.name,
            "description": self.description,
            "confidence": self.confidence,
            "source_attribute_id": self.source_attribute_id,
            "reusability_score": self.reusability_score,
            "impact_score": self.impact_score,
            "pattern_summary": self.pattern_summary,
            "code_examples": self.code_examples,
            "citations": [c.to_dict() for c in self.citations],
        }

    def to_skill_md(self) -> str:
        """Generate SKILL.md content from this discovered skill.

        Returns:
            Complete SKILL.md file content with frontmatter
        """
        # Build frontmatter
        frontmatter = f"""---
name: {self.skill_id}
description: {self.description}
---
"""

        # Build main content
        content = f"""# {self.name}

## When to Use This Skill

{self.pattern_summary}

## Instructions

{self._generate_instructions()}

## Examples

{self._generate_examples()}

## Best Practices

{self._generate_best_practices()}

## Citations

{self._generate_citations()}

---

**Generated by**: AgentReady Skill Generator
**Confidence**: {self.confidence}%
**Source Attribute**: {self.source_attribute_id}
**Reusability**: {self.reusability_score}%
**Impact**: +{self.impact_score} pts
"""

        return frontmatter + content

    def _generate_instructions(self) -> str:
        """Generate instructions section from pattern summary."""
        # This is a placeholder - will be enhanced with templates
        return """1. Review the pattern summary above
2. Apply the pattern to your repository
3. Verify the implementation matches the examples below
"""

    def _generate_examples(self) -> str:
        """Generate examples section from code_examples."""
        if not self.code_examples:
            return "_No examples available_"

        examples_md = ""
        for idx, example in enumerate(self.code_examples, 1):
            examples_md += f"\n### Example {idx}\n\n```\n{example}\n```\n"

        return examples_md.strip()

    def _generate_best_practices(self) -> str:
        """Generate best practices section."""
        # This is a placeholder - will be enhanced with templates
        return """- Follow the pattern consistently across your codebase
- Refer to the citations below for authoritative guidance
- Test the implementation after applying the pattern
"""

    def _generate_citations(self) -> str:
        """Generate citations section from citations list."""
        if not self.citations:
            return "_No citations available_"

        citations_md = ""
        for citation in self.citations:
            url_part = f" ([link]({citation.url}))" if citation.url else ""
            citations_md += f'- {citation.source}: "{citation.title}"{url_part}\n'
            citations_md += f"  - {citation.relevance}\n\n"

        return citations_md.strip()

    def to_github_issue(self) -> str:
        """Generate GitHub issue template content for this skill proposal.

        Returns:
            Markdown content for GitHub issue
        """
        return f"""---
name: Skill Proposal - {self.name}
about: Automatically generated skill proposal from AgentReady continuous learning
title: 'Skill Proposal: {self.name}'
labels: 'skill-proposal, enhancement, ai-agent'
assignees: ''
---

## Skill Proposal: {self.name}

**Skill ID**: `{self.skill_id}`
**Confidence**: {self.confidence}%
**Impact**: +{self.impact_score} pts
**Reusability**: {self.reusability_score}%
**Source Attribute**: {self.source_attribute_id}

---

## Description

{self.description}

---

## Pattern Summary

{self.pattern_summary}

---

## Proposed SKILL.md

```markdown
{self.to_skill_md()}
```

---

## Implementation Plan

- [ ] Review proposed skill for accuracy
- [ ] Test skill on 3-5 repositories
- [ ] Refine instructions based on testing
- [ ] Create final SKILL.md file
- [ ] Add to `~/.claude/skills/` or `.claude/skills/`
- [ ] Document skill in AgentReady catalog
- [ ] Update skill generator with learnings

---

## Code Examples from Assessment

{self._format_code_examples_for_issue()}

---

## Research Citations

{self._format_citations_for_issue()}

---

**Auto-generated by**: AgentReady Continuous Learning Loop
**Assessment Date**: {self._get_timestamp()}
"""

    def _format_code_examples_for_issue(self) -> str:
        """Format code examples for GitHub issue."""
        if not self.code_examples:
            return "_No code examples available_"

        examples_md = ""
        for idx, example in enumerate(self.code_examples, 1):
            examples_md += f"\n### Example {idx}\n\n```\n{example}\n```\n"

        return examples_md.strip()

    def _format_citations_for_issue(self) -> str:
        """Format citations with relevance for GitHub issue."""
        if not self.citations:
            return "_No citations available_"

        citations_md = ""
        for citation in self.citations:
            url_part = f" - [Link]({citation.url})" if citation.url else ""
            citations_md += f"\n### {citation.source}: {citation.title}{url_part}\n\n"
            citations_md += f"**Relevance**: {citation.relevance}\n"

        return citations_md.strip()

    def _get_timestamp(self) -> str:
        """Get current timestamp for issue metadata."""
        from datetime import datetime

        return datetime.now().isoformat()
