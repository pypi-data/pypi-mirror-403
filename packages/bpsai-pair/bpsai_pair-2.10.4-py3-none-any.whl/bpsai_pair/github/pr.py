"""
Pull Request management for PairCoder.

Provides task-linked PR creation, status tracking, and automation.
"""
from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any, Callable

from .client import GitHubService
from ..core.constants import extract_task_id

logger = logging.getLogger(__name__)


@dataclass
class PRInfo:
    """Pull request information."""

    number: int
    title: str
    url: str
    state: str  # open, closed, merged
    task_id: Optional[str] = None
    branch: Optional[str] = None
    base_branch: str = "main"
    draft: bool = False
    mergeable: Optional[bool] = None
    review_decision: Optional[str] = None  # APPROVED, CHANGES_REQUESTED, etc.
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    @classmethod
    def from_gh_json(cls, data: Dict[str, Any]) -> "PRInfo":
        """Create PRInfo from gh CLI JSON output.

        Args:
            data: JSON data from gh pr view/list

        Returns:
            PRInfo instance
        """
        # Extract task ID from title if present
        task_id = None
        title = data.get("title", "")
        task_id = extract_task_id(title)

        return cls(
            number=data.get("number", 0),
            title=title,
            url=data.get("url", data.get("html_url", "")),
            state=data.get("state", "open").lower(),
            task_id=task_id,
            branch=data.get("headRefName"),
            base_branch=data.get("baseRefName", "main"),
            draft=data.get("isDraft", False),
            mergeable=data.get("mergeable") == "MERGEABLE",
            review_decision=data.get("reviewDecision"),
        )

    def is_approved(self) -> bool:
        """Check if PR is approved."""
        return self.review_decision == "APPROVED"

    def is_ready_to_merge(self) -> bool:
        """Check if PR is ready to merge."""
        return (
            self.state == "open"
            and not self.draft
            and self.mergeable is True
            and self.is_approved()
        )


class PRManager:
    """Manager for task-linked pull requests."""

    # Template for PR body
    PR_BODY_TEMPLATE = """## Summary
{summary}

## Task
- **ID**: {task_id}
- **Title**: {task_title}
- **Plan**: {plan_id}

## Changes
{changes}

## Test Plan
{test_plan}

---
Generated by [PairCoder](https://github.com/bps-ai/paircoder)
"""

    def __init__(
        self,
        service: Optional[GitHubService] = None,
        project_root: Optional[Path] = None,
        paircoder_dir: Optional[Path] = None,
    ):
        """Initialize PR manager.

        Args:
            service: GitHub service (creates default if not provided)
            project_root: Project root directory
            paircoder_dir: Path to .paircoder directory
        """
        self.project_root = project_root or Path.cwd()
        self.service = service or GitHubService(project_root=self.project_root)
        self.paircoder_dir = paircoder_dir or (self.project_root / ".paircoder")

    def create_pr_for_task(
        self,
        task_id: str,
        summary: str,
        changes: Optional[str] = None,
        test_plan: Optional[str] = None,
        draft: bool = False,
        base: Optional[str] = None,
    ) -> Optional[PRInfo]:
        """Create a PR for a task.

        Args:
            task_id: Task ID (e.g., TASK-001)
            summary: Brief summary of changes
            changes: Detailed list of changes
            test_plan: Testing instructions
            draft: Create as draft PR
            base: Base branch (uses default if not provided)

        Returns:
            PRInfo if created successfully
        """
        # Try to get task info
        task_title = task_id
        plan_id = "unknown"

        try:
            from ..planning.parser import TaskParser
            parser = TaskParser(self.paircoder_dir / "tasks")
            task = parser.get_task_by_id(task_id)
            if task:
                task_title = task.title
                plan_id = task.plan_id or "unknown"
        except Exception as e:
            logger.warning(f"Could not load task info: {e}")

        # Build PR title and body
        title = f"[{task_id}] {task_title}"
        body = self.PR_BODY_TEMPLATE.format(
            summary=summary,
            task_id=task_id,
            task_title=task_title,
            plan_id=plan_id,
            changes=changes or "- See commits for detailed changes",
            test_plan=test_plan or "- [ ] Manual testing\n- [ ] Automated tests pass",
        )

        # Create PR
        result = self.service.client.create_pr(
            title=title,
            body=body,
            base=base,
            draft=draft,
            cwd=self.project_root,
        )

        if result:
            return PRInfo(
                number=result["number"],
                title=title,
                url=result["url"],
                state="open",
                task_id=task_id,
                draft=draft,
            )

        return None

    def get_pr_for_task(self, task_id: str) -> Optional[PRInfo]:
        """Get the PR associated with a task.

        Args:
            task_id: Task ID to search for

        Returns:
            PRInfo if found
        """
        # Search open PRs for task ID in title
        prs = self.service.client.list_prs(
            state="all",
            limit=100,
            cwd=self.project_root,
        )

        for pr_data in prs:
            title = pr_data.get("title", "")
            if task_id in title:
                # Get full PR info
                full_data = self.service.client.get_pr_status(
                    pr_number=pr_data["number"],
                    cwd=self.project_root,
                )
                if full_data:
                    pr_info = PRInfo.from_gh_json(full_data)
                    pr_info.task_id = task_id
                    return pr_info

        return None

    def get_pr_for_branch(self, branch: Optional[str] = None) -> Optional[PRInfo]:
        """Get PR for current or specified branch.

        Args:
            branch: Branch name (uses current if not provided)

        Returns:
            PRInfo if found
        """
        if branch is None:
            branch = self.service.get_current_branch()

        if not branch:
            return None

        # Get PR status for current branch
        status = self.service.client.get_pr_status(cwd=self.project_root)
        if status:
            return PRInfo.from_gh_json(status)

        return None

    def list_task_prs(
        self,
        plan_id: Optional[str] = None,
        state: str = "open",
    ) -> List[PRInfo]:
        """List PRs that are linked to tasks.

        Args:
            plan_id: Filter by plan ID
            state: PR state filter

        Returns:
            List of task-linked PRInfo objects
        """
        prs = self.service.client.list_prs(
            state=state,
            limit=100,
            cwd=self.project_root,
        )

        task_prs = []
        for pr_data in prs:
            pr_info = PRInfo.from_gh_json(pr_data)
            if pr_info.task_id:
                task_prs.append(pr_info)

        return task_prs

    def update_task_on_merge(
        self,
        pr_number: int,
        on_merge: Optional[Callable[[str], None]] = None,
    ) -> bool:
        """Update task status when PR is merged.

        Args:
            pr_number: PR number to check
            on_merge: Callback with task_id when merged

        Returns:
            True if task was updated
        """
        status = self.service.client.get_pr_status(
            pr_number=pr_number,
            cwd=self.project_root,
        )

        if not status:
            return False

        pr_info = PRInfo.from_gh_json(status)

        if pr_info.state == "merged" and pr_info.task_id:
            # Update task status to done
            try:
                from ..planning.parser import TaskParser
                from ..planning.models import TaskStatus

                parser = TaskParser(self.paircoder_dir / "tasks")
                task = parser.get_task_by_id(pr_info.task_id)
                if task:
                    task.status = TaskStatus.DONE
                    parser.save(task)
                    logger.info(f"Marked {pr_info.task_id} as done (PR #{pr_number} merged)")

                    if on_merge:
                        on_merge(pr_info.task_id)

                    return True
            except Exception as e:
                logger.error(f"Failed to update task: {e}")

        return False


class PRWorkflow:
    """Workflow automation for PRs."""

    def __init__(
        self,
        pr_manager: PRManager,
        auto_assign_next: bool = True,
    ):
        """Initialize PR workflow.

        Args:
            pr_manager: PR manager instance
            auto_assign_next: Auto-assign next task on merge
        """
        self.pr_manager = pr_manager
        self.auto_assign_next = auto_assign_next

    def on_task_complete(self, task_id: str) -> Optional[PRInfo]:
        """Handle task completion - create PR if on feature branch.

        Args:
            task_id: Completed task ID

        Returns:
            PRInfo if PR was created
        """
        branch = self.pr_manager.service.get_current_branch()
        if not branch:
            return None

        # Check if already on main
        default = self.pr_manager.service.client.get_default_branch(
            self.pr_manager.project_root
        )
        if branch == default:
            logger.info("On default branch, skipping PR creation")
            return None

        # Check if PR already exists
        existing = self.pr_manager.get_pr_for_branch(branch)
        if existing:
            logger.info(f"PR already exists: #{existing.number}")
            return existing

        # Create PR
        return self.pr_manager.create_pr_for_task(
            task_id=task_id,
            summary=f"Implementation of {task_id}",
        )

    def on_pr_merge(self, pr_number: int) -> Optional[str]:
        """Handle PR merge - update task and optionally assign next.

        Args:
            pr_number: Merged PR number

        Returns:
            Next task ID if assigned
        """
        next_task_id = None

        def on_merge(task_id: str):
            nonlocal next_task_id
            if self.auto_assign_next:
                try:
                    from ..planning.auto_assign import auto_assign_next
                    next_task = auto_assign_next(self.pr_manager.paircoder_dir)
                    if next_task:
                        next_task_id = next_task.id
                        logger.info(f"Auto-assigned next task: {next_task_id}")
                except Exception as e:
                    logger.error(f"Failed to auto-assign next task: {e}")

        self.pr_manager.update_task_on_merge(pr_number, on_merge)
        return next_task_id


def auto_create_pr_for_branch(
    project_root: Optional[Path] = None,
    paircoder_dir: Optional[Path] = None,
    draft: bool = True,
) -> Optional[PRInfo]:
    """Auto-create a draft PR when a feature branch is pushed.

    This function is designed to be called after a git push. It:
    1. Detects the current branch
    2. Extracts task ID from branch name (e.g., feature/TASK-001-description)
    3. Creates a draft PR if one doesn't exist

    Args:
        project_root: Project root directory
        paircoder_dir: Path to .paircoder directory
        draft: Create as draft PR (default True)

    Returns:
        PRInfo if PR was created, None otherwise
    """
    project_root = project_root or Path.cwd()
    paircoder_dir = paircoder_dir or (project_root / ".paircoder")

    manager = PRManager(project_root=project_root, paircoder_dir=paircoder_dir)

    # Get current branch
    branch = manager.service.get_current_branch()
    if not branch:
        logger.warning("Could not determine current branch")
        return None

    # Check if on main/default branch
    default_branch = manager.service.client.get_default_branch(project_root)
    if branch == default_branch:
        logger.info("On default branch, skipping PR creation")
        return None

    # Check if PR already exists for this branch
    existing = manager.get_pr_for_branch(branch)
    if existing:
        logger.info(f"PR already exists: #{existing.number}")
        return existing

    # Extract task ID from branch name
    # Patterns: feature/TASK-001-*, T18.1/*, REL-18-01-*, etc.
    task_id = extract_task_id(branch)

    if not task_id:
        logger.info(f"No task ID found in branch name: {branch}")
        return None

    # Create the PR
    logger.info(f"Creating draft PR for {task_id} on branch {branch}")
    return manager.create_pr_for_task(
        task_id=task_id,
        summary=f"Implementation of {task_id}",
        draft=draft,
    )


def archive_task_on_merge(
    pr_number: int,
    project_root: Optional[Path] = None,
    paircoder_dir: Optional[Path] = None,
) -> bool:
    """Archive a task when its associated PR is merged.

    Args:
        pr_number: PR number to check
        project_root: Project root directory
        paircoder_dir: Path to .paircoder directory

    Returns:
        True if task was archived
    """
    project_root = project_root or Path.cwd()
    paircoder_dir = paircoder_dir or (project_root / ".paircoder")

    manager = PRManager(project_root=project_root, paircoder_dir=paircoder_dir)

    # Get PR status
    status = manager.service.client.get_pr_status(
        pr_number=pr_number,
        cwd=project_root,
    )

    if not status:
        logger.warning(f"Could not get PR #{pr_number} status")
        return False

    pr_info = PRInfo.from_gh_json(status)

    if pr_info.state != "merged":
        logger.info(f"PR #{pr_number} is not merged (state: {pr_info.state})")
        return False

    if not pr_info.task_id:
        logger.info(f"PR #{pr_number} is not linked to a task")
        return False

    # Archive the task
    try:
        from ..tasks import TaskArchiver, TaskLifecycle

        archiver = TaskArchiver(project_root)
        lifecycle = TaskLifecycle(paircoder_dir / "tasks")

        # Find the task file
        task_file = None
        for f in (paircoder_dir / "tasks").rglob(f"{pr_info.task_id}.task.md"):
            task_file = f
            break

        if not task_file:
            # Look in root tasks directory
            task_file = paircoder_dir / "tasks" / f"{pr_info.task_id}.task.md"

        if not task_file.exists():
            logger.warning(f"Task file not found: {pr_info.task_id}")
            return False

        # Load and archive
        task = lifecycle.load_task(task_file)
        result = archiver.archive_batch([task], task.sprint or "merged")

        if result.archived:
            logger.info(f"Archived {pr_info.task_id} after PR #{pr_number} merge")
            return True
        else:
            logger.warning(f"Failed to archive {pr_info.task_id}: {result.errors}")
            return False

    except ImportError:
        logger.warning("Task archiver not available")
        return False
    except Exception as e:
        logger.error(f"Failed to archive task: {e}")
        return False


def check_and_archive_merged_prs(
    project_root: Optional[Path] = None,
    paircoder_dir: Optional[Path] = None,
    limit: int = 10,
) -> List[str]:
    """Check recent merged PRs and archive associated tasks.

    Args:
        project_root: Project root directory
        paircoder_dir: Path to .paircoder directory
        limit: Maximum PRs to check

    Returns:
        List of archived task IDs
    """
    project_root = project_root or Path.cwd()
    paircoder_dir = paircoder_dir or (project_root / ".paircoder")

    manager = PRManager(project_root=project_root, paircoder_dir=paircoder_dir)

    # Get recently merged PRs
    prs = manager.service.client.list_prs(
        state="closed",
        limit=limit,
        cwd=project_root,
    )

    archived = []
    for pr_data in prs:
        pr_info = PRInfo.from_gh_json(pr_data)

        # Check if merged (not just closed)
        if pr_info.state == "merged" and pr_info.task_id:
            # Check if task is already archived
            task_file = paircoder_dir / "tasks" / f"{pr_info.task_id}.task.md"
            if task_file.exists():
                if archive_task_on_merge(pr_info.number, project_root, paircoder_dir):
                    archived.append(pr_info.task_id)

    return archived
