"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .contents import Contents, ContentsTypedDict
from .country import Country
from .freshness import Freshness
from .language import Language
from .livecrawl import LiveCrawl
from .livecrawlformats import LiveCrawlFormats
from .safesearch import SafeSearch
from datetime import datetime
from pydantic import model_serializer
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict
from youdotcom.types import BaseModel, UNSET_SENTINEL
from youdotcom.utils import FieldMetadata, QueryParamMetadata


SEARCH_OP_SERVERS = [
    "https://ydc-index.io",
]


SearchFreshnessTypedDict = TypeAliasType(
    "SearchFreshnessTypedDict", Union[Freshness, str]
)
r"""Specifies the freshness of the results to return."""


SearchFreshness = TypeAliasType("SearchFreshness", Union[Freshness, str])
r"""Specifies the freshness of the results to return."""


SearchCountryTypedDict = TypeAliasType("SearchCountryTypedDict", Union[Country, str])
r"""The country code that determines the geographical focus of the web results."""


SearchCountry = TypeAliasType("SearchCountry", Union[Country, str])
r"""The country code that determines the geographical focus of the web results."""


SearchSafesearchTypedDict = TypeAliasType(
    "SearchSafesearchTypedDict", Union[SafeSearch, str]
)
r"""Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not."""


SearchSafesearch = TypeAliasType("SearchSafesearch", Union[SafeSearch, str])
r"""Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not."""


SearchLivecrawlTypedDict = TypeAliasType(
    "SearchLivecrawlTypedDict", Union[LiveCrawl, str]
)
r"""Indicates which section(s) of search results to livecrawl and return full page content."""


SearchLivecrawl = TypeAliasType("SearchLivecrawl", Union[LiveCrawl, str])
r"""Indicates which section(s) of search results to livecrawl and return full page content."""


SearchLivecrawlFormatsTypedDict = TypeAliasType(
    "SearchLivecrawlFormatsTypedDict", Union[LiveCrawlFormats, str]
)
r"""Indicates the format of the livecrawled content."""


SearchLivecrawlFormats = TypeAliasType(
    "SearchLivecrawlFormats", Union[LiveCrawlFormats, str]
)
r"""Indicates the format of the livecrawled content."""


class SearchRequestTypedDict(TypedDict):
    query: str
    r"""The search query used to retrieve relevant results from the web. You can also include [search operators](https://docs.you.com/search/search-operators) to refine your search."""
    count: NotRequired[int]
    r"""Specifies the maximum number of search results to return per section (the sections are `web` and `news`. See the JSON response to visualize them)."""
    freshness: NotRequired[SearchFreshnessTypedDict]
    r"""Specifies the freshness of the results to return."""
    offset: NotRequired[int]
    r"""Indicates the `offset` for pagination. The `offset` is calculated in multiples of `count`. For example, if `count = 5` and `offset = 1`, results 5–10 will be returned. Range `0 ≤ offset ≤ 9`."""
    country: NotRequired[SearchCountryTypedDict]
    r"""The country code that determines the geographical focus of the web results."""
    language: NotRequired[Language]
    r"""The language of the web results that will be returned (BCP 47 format)."""
    safesearch: NotRequired[SearchSafesearchTypedDict]
    r"""Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not."""
    livecrawl: NotRequired[SearchLivecrawlTypedDict]
    r"""Indicates which section(s) of search results to livecrawl and return full page content."""
    livecrawl_formats: NotRequired[SearchLivecrawlFormatsTypedDict]
    r"""Indicates the format of the livecrawled content."""


class SearchRequest(BaseModel):
    query: Annotated[
        str, FieldMetadata(query=QueryParamMetadata(style="form", explode=True))
    ] = "Your query"
    r"""The search query used to retrieve relevant results from the web. You can also include [search operators](https://docs.you.com/search/search-operators) to refine your search."""

    count: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Specifies the maximum number of search results to return per section (the sections are `web` and `news`. See the JSON response to visualize them)."""

    freshness: Annotated[
        Optional[SearchFreshness],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Specifies the freshness of the results to return."""

    offset: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the `offset` for pagination. The `offset` is calculated in multiples of `count`. For example, if `count = 5` and `offset = 1`, results 5–10 will be returned. Range `0 ≤ offset ≤ 9`."""

    country: Annotated[
        Optional[SearchCountry],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The country code that determines the geographical focus of the web results."""

    language: Annotated[
        Optional[Language],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = Language.EN
    r"""The language of the web results that will be returned (BCP 47 format)."""

    safesearch: Annotated[
        Optional[SearchSafesearch],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not."""

    livecrawl: Annotated[
        Optional[SearchLivecrawl],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates which section(s) of search results to livecrawl and return full page content."""

    livecrawl_formats: Annotated[
        Optional[SearchLivecrawlFormats],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Indicates the format of the livecrawled content."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "count",
                "freshness",
                "offset",
                "country",
                "language",
                "safesearch",
                "livecrawl",
                "livecrawl_formats",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class WebTypedDict(TypedDict):
    url: NotRequired[str]
    r"""The URL of the specific search result."""
    title: NotRequired[str]
    r"""The title or name of the search result."""
    description: NotRequired[str]
    r"""A brief description of the content of the search result."""
    snippets: NotRequired[List[str]]
    r"""An array of text snippets from the search result, providing a preview of the content."""
    thumbnail_url: NotRequired[str]
    r"""URL of the thumbnail."""
    page_age: NotRequired[datetime]
    r"""The age of the search result."""
    contents: NotRequired[ContentsTypedDict]
    r"""Contents of the page if livecrawl was enabled."""
    authors: NotRequired[List[str]]
    r"""An array of authors of the search result."""
    favicon_url: NotRequired[str]
    r"""The URL of the favicon of the search result's domain."""


class Web(BaseModel):
    url: Optional[str] = None
    r"""The URL of the specific search result."""

    title: Optional[str] = None
    r"""The title or name of the search result."""

    description: Optional[str] = None
    r"""A brief description of the content of the search result."""

    snippets: Optional[List[str]] = None
    r"""An array of text snippets from the search result, providing a preview of the content."""

    thumbnail_url: Optional[str] = None
    r"""URL of the thumbnail."""

    page_age: Optional[datetime] = None
    r"""The age of the search result."""

    contents: Optional[Contents] = None
    r"""Contents of the page if livecrawl was enabled."""

    authors: Optional[List[str]] = None
    r"""An array of authors of the search result."""

    favicon_url: Optional[str] = None
    r"""The URL of the favicon of the search result's domain."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "url",
                "title",
                "description",
                "snippets",
                "thumbnail_url",
                "page_age",
                "contents",
                "authors",
                "favicon_url",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class NewsTypedDict(TypedDict):
    title: NotRequired[str]
    r"""The title of the news result."""
    description: NotRequired[str]
    r"""A brief description of the content of the news result."""
    page_age: NotRequired[datetime]
    r"""UTC timestamp of the article's publication date."""
    thumbnail_url: NotRequired[str]
    r"""URL of the thumbnail."""
    url: NotRequired[str]
    r"""The URL of the news result."""
    contents: NotRequired[ContentsTypedDict]
    r"""Contents of the page if livecrawl was enabled."""


class News(BaseModel):
    title: Optional[str] = None
    r"""The title of the news result."""

    description: Optional[str] = None
    r"""A brief description of the content of the news result."""

    page_age: Optional[datetime] = None
    r"""UTC timestamp of the article's publication date."""

    thumbnail_url: Optional[str] = None
    r"""URL of the thumbnail."""

    url: Optional[str] = None
    r"""The URL of the news result."""

    contents: Optional[Contents] = None
    r"""Contents of the page if livecrawl was enabled."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["title", "description", "page_age", "thumbnail_url", "url", "contents"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResultsTypedDict(TypedDict):
    web: NotRequired[List[WebTypedDict]]
    news: NotRequired[List[NewsTypedDict]]


class Results(BaseModel):
    web: Optional[List[Web]] = None

    news: Optional[List[News]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["web", "news"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class MetadataTypedDict(TypedDict):
    search_uuid: NotRequired[str]
    query: NotRequired[str]
    r"""Returns the search query used to retrieve the results."""
    latency: NotRequired[float]


class Metadata(BaseModel):
    search_uuid: Optional[str] = None

    query: Optional[str] = None
    r"""Returns the search query used to retrieve the results."""

    latency: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["search_uuid", "query", "latency"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SearchResponseTypedDict(TypedDict):
    r"""A JSON object containing unified search results from web and news sources"""

    results: NotRequired[ResultsTypedDict]
    metadata: NotRequired[MetadataTypedDict]


class SearchResponse(BaseModel):
    r"""A JSON object containing unified search results from web and news sources"""

    results: Optional[Results] = None

    metadata: Optional[Metadata] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["results", "metadata"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
