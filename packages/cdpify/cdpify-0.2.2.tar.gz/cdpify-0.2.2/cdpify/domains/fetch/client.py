# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from cdpify.client import CDPClient

from .commands import (
    FetchCommand,
    ContinueRequestParams,
    ContinueResponseParams,
    ContinueWithAuthParams,
    EnableParams,
    FailRequestParams,
    FulfillRequestParams,
    GetResponseBodyParams,
    GetResponseBodyResult,
    TakeResponseBodyAsStreamParams,
    TakeResponseBodyAsStreamResult,
)

from .types import (
    AuthChallengeResponse,
    HeaderEntry,
    RequestId,
    RequestPattern,
)

if TYPE_CHECKING:
    from cdpify.domains import network


class FetchClient:
    def __init__(self, client: CDPClient) -> None:
        self._client = client

    async def disable(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Disables the fetch domain.
        """
        result = await self._client.send_raw(
            method=FetchCommand.DISABLE,
            params=None,
            session_id=session_id,
        )
        return result

    async def enable(
        self,
        *,
        patterns: list[RequestPattern] | None = None,
        handle_auth_requests: bool | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Enables issuing of requestPaused events. A request will be paused until client
        calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
        """
        params = EnableParams(
            patterns=patterns, handle_auth_requests=handle_auth_requests
        )

        result = await self._client.send_raw(
            method=FetchCommand.ENABLE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def fail_request(
        self,
        *,
        request_id: RequestId,
        error_reason: network.ErrorReason,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Causes the request to fail with specified reason.
        """
        params = FailRequestParams(request_id=request_id, error_reason=error_reason)

        result = await self._client.send_raw(
            method=FetchCommand.FAIL_REQUEST,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def fulfill_request(
        self,
        *,
        request_id: RequestId,
        response_code: int,
        response_headers: list[HeaderEntry] | None = None,
        binary_response_headers: str | None = None,
        body: str | None = None,
        response_phrase: str | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Provides response to the request.
        """
        params = FulfillRequestParams(
            request_id=request_id,
            response_code=response_code,
            response_headers=response_headers,
            binary_response_headers=binary_response_headers,
            body=body,
            response_phrase=response_phrase,
        )

        result = await self._client.send_raw(
            method=FetchCommand.FULFILL_REQUEST,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def continue_request(
        self,
        *,
        request_id: RequestId,
        url: str | None = None,
        method: str | None = None,
        post_data: str | None = None,
        headers: list[HeaderEntry] | None = None,
        intercept_response: bool | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Continues the request, optionally modifying some of its parameters.
        """
        params = ContinueRequestParams(
            request_id=request_id,
            url=url,
            method=method,
            post_data=post_data,
            headers=headers,
            intercept_response=intercept_response,
        )

        result = await self._client.send_raw(
            method=FetchCommand.CONTINUE_REQUEST,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def continue_with_auth(
        self,
        *,
        request_id: RequestId,
        auth_challenge_response: AuthChallengeResponse,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Continues a request supplying authChallengeResponse following authRequired
        event.
        """
        params = ContinueWithAuthParams(
            request_id=request_id, auth_challenge_response=auth_challenge_response
        )

        result = await self._client.send_raw(
            method=FetchCommand.CONTINUE_WITH_AUTH,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def continue_response(
        self,
        *,
        request_id: RequestId,
        response_code: int | None = None,
        response_phrase: str | None = None,
        response_headers: list[HeaderEntry] | None = None,
        binary_response_headers: str | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Continues loading of the paused response, optionally modifying the response
        headers. If either responseCode or headers are modified, all of them must be
        present.
        """
        params = ContinueResponseParams(
            request_id=request_id,
            response_code=response_code,
            response_phrase=response_phrase,
            response_headers=response_headers,
            binary_response_headers=binary_response_headers,
        )

        result = await self._client.send_raw(
            method=FetchCommand.CONTINUE_RESPONSE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def get_response_body(
        self,
        *,
        request_id: RequestId,
        session_id: str | None = None,
    ) -> GetResponseBodyResult:
        """
        Causes the body of the response to be received from the server and returned as
        a single string. May only be issued for a request that is paused in the Response
        stage and is mutually exclusive with takeResponseBodyForInterceptionAsStream.
        Calling other methods that affect the request or disabling fetch domain before
        body is received results in an undefined behavior. Note that the response body
        is not available for redirects. Requests paused in the _redirect received_ state
        may be differentiated by `responseCode` and presence of `location` response
        header, see comments to `requestPaused` for details.
        """
        params = GetResponseBodyParams(request_id=request_id)

        result = await self._client.send_raw(
            method=FetchCommand.GET_RESPONSE_BODY,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetResponseBodyResult.from_cdp(result)

    async def take_response_body_as_stream(
        self,
        *,
        request_id: RequestId,
        session_id: str | None = None,
    ) -> TakeResponseBodyAsStreamResult:
        """
        Returns a handle to the stream representing the response body. The request must
        be paused in the HeadersReceived stage. Note that after this command the request
        can't be continued as is -- client either needs to cancel it or to provide the
        response body. The stream only supports sequential read, IO.read will fail if
        the position is specified. This method is mutually exclusive with
        getResponseBody. Calling other methods that affect the request or disabling
        fetch domain before body is received results in an undefined behavior.
        """
        params = TakeResponseBodyAsStreamParams(request_id=request_id)

        result = await self._client.send_raw(
            method=FetchCommand.TAKE_RESPONSE_BODY_AS_STREAM,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return TakeResponseBodyAsStreamResult.from_cdp(result)
