# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

from __future__ import annotations

from typing import Any, Literal, TYPE_CHECKING
from dataclasses import dataclass
from cdpify.shared.models import CDPModel

if TYPE_CHECKING:
    from cdpify.domains import io, network, runtime, security

"""
Resource type as it was perceived by the rendering engine.
"""
ResourceType = Literal[
    "Document",
    "Stylesheet",
    "Image",
    "Media",
    "Font",
    "Script",
    "TextTrack",
    "XHR",
    "Fetch",
    "Prefetch",
    "EventSource",
    "WebSocket",
    "Manifest",
    "SignedExchange",
    "Ping",
    "CSPViolationReport",
    "Preflight",
    "FedCM",
    "Other",
]

"""
Unique loader identifier.
"""
LoaderId = str

"""
Unique network request identifier. Note that this does not identify individual HTTP
requests that are part of a network request.
"""
RequestId = str

"""
Unique intercepted request identifier.
"""
InterceptionId = str

"""
Network level fetch failure reason.
"""
ErrorReason = Literal[
    "Failed",
    "Aborted",
    "TimedOut",
    "AccessDenied",
    "ConnectionClosed",
    "ConnectionReset",
    "ConnectionRefused",
    "ConnectionAborted",
    "ConnectionFailed",
    "NameNotResolved",
    "InternetDisconnected",
    "AddressUnreachable",
    "BlockedByClient",
    "BlockedByResponse",
]

"""
UTC time in seconds, counted from January 1, 1970.
"""
TimeSinceEpoch = float

"""
Monotonically increasing time in seconds since an arbitrary point in the past.
"""
MonotonicTime = float

"""
Request / response headers as keys / values of JSON object.
"""
Headers = dict[str, Any]

"""
The underlying connection technology that the browser is supposedly using.
"""
ConnectionType = Literal[
    "none",
    "cellular2g",
    "cellular3g",
    "cellular4g",
    "bluetooth",
    "ethernet",
    "wifi",
    "wimax",
    "other",
]

"""
Represents the cookie's 'SameSite' status:
https://tools.ietf.org/html/draft-west-first-party-cookies
"""
CookieSameSite = Literal["Strict", "Lax", "None"]

"""
Represents the cookie's 'Priority' status:
https://tools.ietf.org/html/draft-west-cookie-priority-00
"""
CookiePriority = Literal["Low", "Medium", "High"]

"""
Represents the source scheme of the origin that originally set the cookie. A value of
"Unset" allows protocol clients to emulate legacy cookie scope for the scheme. This is a
temporary ability and it will be removed in the future.
"""
CookieSourceScheme = Literal["Unset", "NonSecure", "Secure"]


@dataclass(kw_only=True)
class ResourceTiming(CDPModel):
    """
    Timing information for the request.
    """

    request_time: float
    proxy_start: float
    proxy_end: float
    dns_start: float
    dns_end: float
    connect_start: float
    connect_end: float
    ssl_start: float
    ssl_end: float
    worker_start: float
    worker_ready: float
    worker_fetch_start: float
    worker_respond_with_settled: float
    worker_router_evaluation_start: float | None | None = None
    worker_cache_lookup_start: float | None | None = None
    send_start: float
    send_end: float
    push_start: float
    push_end: float
    receive_headers_start: float
    receive_headers_end: float


"""
Loading priority of a resource request.
"""
ResourcePriority = Literal["VeryLow", "Low", "Medium", "High", "VeryHigh"]

"""
The render blocking behavior of a resource request.
"""
RenderBlockingBehavior = Literal[
    "Blocking",
    "InBodyParserBlocking",
    "NonBlocking",
    "NonBlockingDynamic",
    "PotentiallyBlocking",
]


@dataclass(kw_only=True)
class PostDataEntry(CDPModel):
    """
    Post data entry for HTTP request
    """

    bytes: str | None | None = None


@dataclass(kw_only=True)
class Request(CDPModel):
    """
    HTTP request data.
    """

    url: str
    url_fragment: str | None | None = None
    method: str
    headers: Headers
    post_data: str | None | None = None
    has_post_data: bool | None | None = None
    post_data_entries: list[PostDataEntry] | None | None = None
    mixed_content_type: security.MixedContentType | None = None
    initial_priority: ResourcePriority
    referrer_policy: Literal[
        "unsafe-url",
        "no-referrer-when-downgrade",
        "no-referrer",
        "origin",
        "origin-when-cross-origin",
        "same-origin",
        "strict-origin",
        "strict-origin-when-cross-origin",
    ]
    is_link_preload: bool | None | None = None
    trust_token_params: TrustTokenParams | None | None = None
    is_same_site: bool | None | None = None
    is_ad_related: bool | None | None = None


@dataclass(kw_only=True)
class SignedCertificateTimestamp(CDPModel):
    """
    Details of a signed certificate timestamp (SCT).
    """

    status: str
    origin: str
    log_description: str
    log_id: str
    timestamp: float
    hash_algorithm: str
    signature_algorithm: str
    signature_data: str


@dataclass(kw_only=True)
class SecurityDetails(CDPModel):
    """
    Security details about a request.
    """

    protocol: str
    key_exchange: str
    key_exchange_group: str | None | None = None
    cipher: str
    mac: str | None | None = None
    certificate_id: security.CertificateId
    subject_name: str
    san_list: list[str]
    issuer: str
    valid_from: TimeSinceEpoch
    valid_to: TimeSinceEpoch
    signed_certificate_timestamp_list: list[SignedCertificateTimestamp]
    certificate_transparency_compliance: CertificateTransparencyCompliance
    server_signature_algorithm: int | None | None = None
    encrypted_client_hello: bool


"""
Whether the request complied with Certificate Transparency policy.
"""
CertificateTransparencyCompliance = Literal["unknown", "not-compliant", "compliant"]

"""
The reason why request was blocked.
"""
BlockedReason = Literal[
    "other",
    "csp",
    "mixed-content",
    "origin",
    "inspector",
    "integrity",
    "subresource-filter",
    "content-type",
    "coep-frame-resource-needs-coep-header",
    "coop-sandboxed-iframe-cannot-navigate-to-coop-page",
    "corp-not-same-origin",
    "corp-not-same-origin-after-defaulted-to-same-origin-by-coep",
    "corp-not-same-origin-after-defaulted-to-same-origin-by-dip",
    "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip",
    "corp-not-same-site",
    "sri-message-signature-mismatch",
]

"""
The reason why request was blocked.
"""
CorsError = Literal[
    "DisallowedByMode",
    "InvalidResponse",
    "WildcardOriginNotAllowed",
    "MissingAllowOriginHeader",
    "MultipleAllowOriginValues",
    "InvalidAllowOriginValue",
    "AllowOriginMismatch",
    "InvalidAllowCredentials",
    "CorsDisabledScheme",
    "PreflightInvalidStatus",
    "PreflightDisallowedRedirect",
    "PreflightWildcardOriginNotAllowed",
    "PreflightMissingAllowOriginHeader",
    "PreflightMultipleAllowOriginValues",
    "PreflightInvalidAllowOriginValue",
    "PreflightAllowOriginMismatch",
    "PreflightInvalidAllowCredentials",
    "PreflightMissingAllowExternal",
    "PreflightInvalidAllowExternal",
    "InvalidAllowMethodsPreflightResponse",
    "InvalidAllowHeadersPreflightResponse",
    "MethodDisallowedByPreflightResponse",
    "HeaderDisallowedByPreflightResponse",
    "RedirectContainsCredentials",
    "InsecurePrivateNetwork",
    "InvalidPrivateNetworkAccess",
    "NoCorsRedirectModeNotFollow",
    "LocalNetworkAccessPermissionDenied",
]


@dataclass(kw_only=True)
class CorsErrorStatus(CDPModel):
    cors_error: CorsError
    failed_parameter: str


"""
Source of serviceworker response.
"""
ServiceWorkerResponseSource = Literal[
    "cache-storage", "http-cache", "fallback-code", "network"
]


@dataclass(kw_only=True)
class TrustTokenParams(CDPModel):
    """
    Determines what type of Trust Token operation is executed and depending on the
    type, some additional parameters. The values are specified in
    third_party/blink/renderer/core/fetch/trust_token.idl.
    """

    operation: TrustTokenOperationType
    refresh_policy: Literal["UseCached", "Refresh"]
    issuers: list[str] | None | None = None


TrustTokenOperationType = Literal["Issuance", "Redemption", "Signing"]

"""
The reason why Chrome uses a specific transport protocol for HTTP semantics.
"""
AlternateProtocolUsage = Literal[
    "alternativeJobWonWithoutRace",
    "alternativeJobWonRace",
    "mainJobWonRace",
    "mappingMissing",
    "broken",
    "dnsAlpnH3JobWonWithoutRace",
    "dnsAlpnH3JobWonRace",
    "unspecifiedReason",
]

"""
Source of service worker router.
"""
ServiceWorkerRouterSource = Literal[
    "network",
    "cache",
    "fetch-event",
    "race-network-and-fetch-handler",
    "race-network-and-cache",
]


@dataclass(kw_only=True)
class ServiceWorkerRouterInfo(CDPModel):
    rule_id_matched: int | None | None = None
    matched_source_type: ServiceWorkerRouterSource | None | None = None
    actual_source_type: ServiceWorkerRouterSource | None | None = None


@dataclass(kw_only=True)
class Response(CDPModel):
    """
    HTTP response data.
    """

    url: str
    status: int
    status_text: str
    headers: Headers
    headers_text: str | None | None = None
    mime_type: str
    charset: str
    request_headers: Headers | None | None = None
    request_headers_text: str | None | None = None
    connection_reused: bool
    connection_id: float
    remote_ip_address: str | None | None = None
    remote_port: int | None | None = None
    from_disk_cache: bool | None | None = None
    from_service_worker: bool | None | None = None
    from_prefetch_cache: bool | None | None = None
    from_early_hints: bool | None | None = None
    service_worker_router_info: ServiceWorkerRouterInfo | None | None = None
    encoded_data_length: float
    timing: ResourceTiming | None | None = None
    service_worker_response_source: ServiceWorkerResponseSource | None | None = None
    response_time: TimeSinceEpoch | None | None = None
    cache_storage_cache_name: str | None | None = None
    protocol: str | None | None = None
    alternate_protocol_usage: AlternateProtocolUsage | None | None = None
    security_state: security.SecurityState
    security_details: SecurityDetails | None | None = None


@dataclass(kw_only=True)
class WebSocketRequest(CDPModel):
    """
    WebSocket request data.
    """

    headers: Headers


@dataclass(kw_only=True)
class WebSocketResponse(CDPModel):
    """
    WebSocket response data.
    """

    status: int
    status_text: str
    headers: Headers
    headers_text: str | None | None = None
    request_headers: Headers | None | None = None
    request_headers_text: str | None | None = None


@dataclass(kw_only=True)
class WebSocketFrame(CDPModel):
    """
    WebSocket message data. This represents an entire WebSocket message, not just a
    fragmented frame as the name suggests.
    """

    opcode: float
    mask: bool
    payload_data: str


@dataclass(kw_only=True)
class CachedResource(CDPModel):
    """
    Information about the cached resource.
    """

    url: str
    type: ResourceType
    response: Response | None | None = None
    body_size: float


@dataclass(kw_only=True)
class Initiator(CDPModel):
    """
    Information about the request initiator.
    """

    type: Literal[
        "parser", "script", "preload", "SignedExchange", "preflight", "FedCM", "other"
    ]
    stack: runtime.StackTrace | None = None
    url: str | None | None = None
    line_number: float | None | None = None
    column_number: float | None | None = None
    request_id: RequestId | None | None = None


@dataclass(kw_only=True)
class CookiePartitionKey(CDPModel):
    """
    cookiePartitionKey object The representation of the components of the key that are
    created by the cookiePartitionKey class contained in
    net/cookies/cookie_partition_key.h.
    """

    top_level_site: str
    has_cross_site_ancestor: bool


@dataclass(kw_only=True)
class Cookie(CDPModel):
    """
    Cookie object
    """

    name: str
    value: str
    domain: str
    path: str
    expires: float
    size: int
    http_only: bool
    secure: bool
    session: bool
    same_site: CookieSameSite | None | None = None
    priority: CookiePriority
    source_scheme: CookieSourceScheme
    source_port: int
    partition_key: CookiePartitionKey | None | None = None
    partition_key_opaque: bool | None | None = None


"""
Types of reasons why a cookie may not be stored from a response.
"""
SetCookieBlockedReason = Literal[
    "SecureOnly",
    "SameSiteStrict",
    "SameSiteLax",
    "SameSiteUnspecifiedTreatedAsLax",
    "SameSiteNoneInsecure",
    "UserPreferences",
    "ThirdPartyPhaseout",
    "ThirdPartyBlockedInFirstPartySet",
    "SyntaxError",
    "SchemeNotSupported",
    "OverwriteSecure",
    "InvalidDomain",
    "InvalidPrefix",
    "UnknownError",
    "SchemefulSameSiteStrict",
    "SchemefulSameSiteLax",
    "SchemefulSameSiteUnspecifiedTreatedAsLax",
    "NameValuePairExceedsMaxSize",
    "DisallowedCharacter",
    "NoCookieContent",
]

"""
Types of reasons why a cookie may not be sent with a request.
"""
CookieBlockedReason = Literal[
    "SecureOnly",
    "NotOnPath",
    "DomainMismatch",
    "SameSiteStrict",
    "SameSiteLax",
    "SameSiteUnspecifiedTreatedAsLax",
    "SameSiteNoneInsecure",
    "UserPreferences",
    "ThirdPartyPhaseout",
    "ThirdPartyBlockedInFirstPartySet",
    "UnknownError",
    "SchemefulSameSiteStrict",
    "SchemefulSameSiteLax",
    "SchemefulSameSiteUnspecifiedTreatedAsLax",
    "NameValuePairExceedsMaxSize",
    "PortMismatch",
    "SchemeMismatch",
    "AnonymousContext",
]

"""
Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the
request.
"""
CookieExemptionReason = Literal[
    "None",
    "UserSetting",
    "TPCDMetadata",
    "TPCDDeprecationTrial",
    "TopLevelTPCDDeprecationTrial",
    "TPCDHeuristics",
    "EnterprisePolicy",
    "StorageAccess",
    "TopLevelStorageAccess",
    "Scheme",
    "SameSiteNoneCookiesInSandbox",
]


@dataclass(kw_only=True)
class BlockedSetCookieWithReason(CDPModel):
    """
    A cookie which was not stored from a response with the corresponding reason.
    """

    blocked_reasons: list[SetCookieBlockedReason]
    cookie_line: str
    cookie: Cookie | None | None = None


@dataclass(kw_only=True)
class ExemptedSetCookieWithReason(CDPModel):
    """
    A cookie should have been blocked by 3PCD but is exempted and stored from a
    response with the corresponding reason. A cookie could only have at most one
    exemption reason.
    """

    exemption_reason: CookieExemptionReason
    cookie_line: str
    cookie: Cookie


@dataclass(kw_only=True)
class AssociatedCookie(CDPModel):
    """
    A cookie associated with the request which may or may not be sent with it. Includes
    the cookies itself and reasons for blocking or exemption.
    """

    cookie: Cookie
    blocked_reasons: list[CookieBlockedReason]
    exemption_reason: CookieExemptionReason | None | None = None


@dataclass(kw_only=True)
class CookieParam(CDPModel):
    """
    Cookie parameter object
    """

    name: str
    value: str
    url: str | None | None = None
    domain: str | None | None = None
    path: str | None | None = None
    secure: bool | None | None = None
    http_only: bool | None | None = None
    same_site: CookieSameSite | None | None = None
    expires: TimeSinceEpoch | None | None = None
    priority: CookiePriority | None | None = None
    source_scheme: CookieSourceScheme | None | None = None
    source_port: int | None | None = None
    partition_key: CookiePartitionKey | None | None = None


@dataclass(kw_only=True)
class AuthChallenge(CDPModel):
    """
    Authorization challenge for HTTP status code 401 or 407.
    """

    source: Literal["Server", "Proxy"] | None | None = None
    origin: str
    scheme: str
    realm: str


@dataclass(kw_only=True)
class AuthChallengeResponse(CDPModel):
    """
    Response to an AuthChallenge.
    """

    response: Literal["Default", "CancelAuth", "ProvideCredentials"]
    username: str | None | None = None
    password: str | None | None = None


"""
Stages of the interception to begin intercepting. Request will intercept before the
request is sent. Response will intercept after the response is received.
"""
InterceptionStage = Literal["Request", "HeadersReceived"]


@dataclass(kw_only=True)
class RequestPattern(CDPModel):
    """
    Request pattern for interception.
    """

    url_pattern: str | None | None = None
    resource_type: ResourceType | None | None = None
    interception_stage: InterceptionStage | None | None = None


@dataclass(kw_only=True)
class SignedExchangeSignature(CDPModel):
    """
    Information about a signed exchange signature.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    """

    label: str
    signature: str
    integrity: str
    cert_url: str | None | None = None
    cert_sha256: str | None | None = None
    validity_url: str
    date: int
    expires: int
    certificates: list[str] | None | None = None


@dataclass(kw_only=True)
class SignedExchangeHeader(CDPModel):
    """
    Information about a signed exchange header.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    """

    request_url: str
    response_code: int
    response_headers: Headers
    signatures: list[SignedExchangeSignature]
    header_integrity: str


"""
Field type for a signed exchange related error.
"""
SignedExchangeErrorField = Literal[
    "signatureSig",
    "signatureIntegrity",
    "signatureCertUrl",
    "signatureCertSha256",
    "signatureValidityUrl",
    "signatureTimestamps",
]


@dataclass(kw_only=True)
class SignedExchangeError(CDPModel):
    """
    Information about a signed exchange response.
    """

    message: str
    signature_index: int | None | None = None
    error_field: SignedExchangeErrorField | None | None = None


@dataclass(kw_only=True)
class SignedExchangeInfo(CDPModel):
    """
    Information about a signed exchange response.
    """

    outer_response: Response
    has_extra_info: bool
    header: SignedExchangeHeader | None | None = None
    security_details: SecurityDetails | None | None = None
    errors: list[SignedExchangeError] | None | None = None


"""
List of content encodings supported by the backend.
"""
ContentEncoding = Literal["deflate", "gzip", "br", "zstd"]


@dataclass(kw_only=True)
class NetworkConditions(CDPModel):
    url_pattern: str
    latency: float
    download_throughput: float
    upload_throughput: float
    connection_type: ConnectionType | None | None = None
    packet_loss: float | None | None = None
    packet_queue_length: int | None | None = None
    packet_reordering: bool | None | None = None


@dataclass(kw_only=True)
class BlockPattern(CDPModel):
    url_pattern: str
    block: bool


DirectSocketDnsQueryType = Literal["ipv4", "ipv6"]


@dataclass(kw_only=True)
class DirectTCPSocketOptions(CDPModel):
    no_delay: bool
    keep_alive_delay: float | None | None = None
    send_buffer_size: float | None | None = None
    receive_buffer_size: float | None | None = None
    dns_query_type: DirectSocketDnsQueryType | None | None = None


@dataclass(kw_only=True)
class DirectUDPSocketOptions(CDPModel):
    remote_addr: str | None | None = None
    remote_port: int | None | None = None
    local_addr: str | None | None = None
    local_port: int | None | None = None
    dns_query_type: DirectSocketDnsQueryType | None | None = None
    send_buffer_size: float | None | None = None
    receive_buffer_size: float | None | None = None
    multicast_loopback: bool | None | None = None
    multicast_time_to_live: int | None | None = None
    multicast_allow_address_sharing: bool | None | None = None


@dataclass(kw_only=True)
class DirectUDPMessage(CDPModel):
    data: str
    remote_addr: str | None | None = None
    remote_port: int | None | None = None


PrivateNetworkRequestPolicy = Literal[
    "Allow",
    "BlockFromInsecureToMorePrivate",
    "WarnFromInsecureToMorePrivate",
    "PermissionBlock",
    "PermissionWarn",
]

IPAddressSpace = Literal["Loopback", "Local", "Public", "Unknown"]


@dataclass(kw_only=True)
class ConnectTiming(CDPModel):
    request_time: float


@dataclass(kw_only=True)
class ClientSecurityState(CDPModel):
    initiator_is_secure_context: bool
    initiator_ip_address_space: IPAddressSpace
    private_network_request_policy: PrivateNetworkRequestPolicy


CrossOriginOpenerPolicyValue = Literal[
    "SameOrigin",
    "SameOriginAllowPopups",
    "RestrictProperties",
    "UnsafeNone",
    "SameOriginPlusCoep",
    "RestrictPropertiesPlusCoep",
    "NoopenerAllowPopups",
]


@dataclass(kw_only=True)
class CrossOriginOpenerPolicyStatus(CDPModel):
    value: CrossOriginOpenerPolicyValue
    report_only_value: CrossOriginOpenerPolicyValue
    reporting_endpoint: str | None | None = None
    report_only_reporting_endpoint: str | None | None = None


CrossOriginEmbedderPolicyValue = Literal["None", "Credentialless", "RequireCorp"]


@dataclass(kw_only=True)
class CrossOriginEmbedderPolicyStatus(CDPModel):
    value: CrossOriginEmbedderPolicyValue
    report_only_value: CrossOriginEmbedderPolicyValue
    reporting_endpoint: str | None | None = None
    report_only_reporting_endpoint: str | None | None = None


ContentSecurityPolicySource = Literal["HTTP", "Meta"]


@dataclass(kw_only=True)
class ContentSecurityPolicyStatus(CDPModel):
    effective_directives: str
    is_enforced: bool
    source: ContentSecurityPolicySource


@dataclass(kw_only=True)
class SecurityIsolationStatus(CDPModel):
    coop: CrossOriginOpenerPolicyStatus | None | None = None
    coep: CrossOriginEmbedderPolicyStatus | None | None = None
    csp: list[ContentSecurityPolicyStatus] | None | None = None


"""
The status of a Reporting API report.
"""
ReportStatus = Literal["Queued", "Pending", "MarkedForRemoval", "Success"]

ReportId = str


@dataclass(kw_only=True)
class ReportingApiReport(CDPModel):
    """
    An object representing a report generated by the Reporting API.
    """

    id: ReportId
    initiator_url: str
    destination: str
    type: str
    timestamp: network.TimeSinceEpoch
    depth: int
    completed_attempts: int
    body: dict[str, Any]
    status: ReportStatus


@dataclass(kw_only=True)
class ReportingApiEndpoint(CDPModel):
    url: str
    group_name: str


@dataclass(kw_only=True)
class DeviceBoundSessionKey(CDPModel):
    """
    Unique identifier for a device bound session.
    """

    site: str
    id: str


@dataclass(kw_only=True)
class DeviceBoundSessionWithUsage(CDPModel):
    """
    How a device bound session was used during a request.
    """

    session_key: DeviceBoundSessionKey
    usage: Literal[
        "NotInScope",
        "InScopeRefreshNotYetNeeded",
        "InScopeRefreshNotAllowed",
        "ProactiveRefreshNotPossible",
        "ProactiveRefreshAttempted",
        "Deferred",
    ]


@dataclass(kw_only=True)
class DeviceBoundSessionCookieCraving(CDPModel):
    """
    A device bound session's cookie craving.
    """

    name: str
    domain: str
    path: str
    secure: bool
    http_only: bool
    same_site: CookieSameSite | None | None = None


@dataclass(kw_only=True)
class DeviceBoundSessionUrlRule(CDPModel):
    """
    A device bound session's inclusion URL rule.
    """

    rule_type: Literal["Exclude", "Include"]
    host_pattern: str
    path_prefix: str


@dataclass(kw_only=True)
class DeviceBoundSessionInclusionRules(CDPModel):
    """
    A device bound session's inclusion rules.
    """

    origin: str
    include_site: bool
    url_rules: list[DeviceBoundSessionUrlRule]


@dataclass(kw_only=True)
class DeviceBoundSession(CDPModel):
    """
    A device bound session.
    """

    key: DeviceBoundSessionKey
    refresh_url: str
    inclusion_rules: DeviceBoundSessionInclusionRules
    cookie_cravings: list[DeviceBoundSessionCookieCraving]
    expiry_date: network.TimeSinceEpoch
    cached_challenge: str | None | None = None
    allowed_refresh_initiators: list[str]


"""
A unique identifier for a device bound session event.
"""
DeviceBoundSessionEventId = str

"""
A fetch result for a device bound session creation or refresh.
"""
DeviceBoundSessionFetchResult = Literal[
    "Success",
    "KeyError",
    "SigningError",
    "ServerRequestedTermination",
    "InvalidSessionId",
    "InvalidChallenge",
    "TooManyChallenges",
    "InvalidFetcherUrl",
    "InvalidRefreshUrl",
    "TransientHttpError",
    "ScopeOriginSameSiteMismatch",
    "RefreshUrlSameSiteMismatch",
    "MismatchedSessionId",
    "MissingScope",
    "NoCredentials",
    "SubdomainRegistrationWellKnownUnavailable",
    "SubdomainRegistrationUnauthorized",
    "SubdomainRegistrationWellKnownMalformed",
    "SessionProviderWellKnownUnavailable",
    "RelyingPartyWellKnownUnavailable",
    "FederatedKeyThumbprintMismatch",
    "InvalidFederatedSessionUrl",
    "InvalidFederatedKey",
    "TooManyRelyingOriginLabels",
    "BoundCookieSetForbidden",
    "NetError",
    "ProxyError",
    "EmptySessionConfig",
    "InvalidCredentialsConfig",
    "InvalidCredentialsType",
    "InvalidCredentialsEmptyName",
    "InvalidCredentialsCookie",
    "PersistentHttpError",
    "RegistrationAttemptedChallenge",
    "InvalidScopeOrigin",
    "ScopeOriginContainsPath",
    "RefreshInitiatorNotString",
    "RefreshInitiatorInvalidHostPattern",
    "InvalidScopeSpecification",
    "MissingScopeSpecificationType",
    "EmptyScopeSpecificationDomain",
    "EmptyScopeSpecificationPath",
    "InvalidScopeSpecificationType",
    "InvalidScopeIncludeSite",
    "MissingScopeIncludeSite",
    "FederatedNotAuthorizedByProvider",
    "FederatedNotAuthorizedByRelyingParty",
    "SessionProviderWellKnownMalformed",
    "SessionProviderWellKnownHasProviderOrigin",
    "RelyingPartyWellKnownMalformed",
    "RelyingPartyWellKnownHasRelyingOrigins",
    "InvalidFederatedSessionProviderSessionMissing",
    "InvalidFederatedSessionWrongProviderOrigin",
    "InvalidCredentialsCookieCreationTime",
    "InvalidCredentialsCookieName",
    "InvalidCredentialsCookieParsing",
    "InvalidCredentialsCookieUnpermittedAttribute",
    "InvalidCredentialsCookieInvalidDomain",
    "InvalidCredentialsCookiePrefix",
    "InvalidScopeRulePath",
    "InvalidScopeRuleHostPattern",
    "ScopeRuleOriginScopedHostPatternMismatch",
    "ScopeRuleSiteScopedHostPatternMismatch",
    "SigningQuotaExceeded",
    "InvalidConfigJson",
    "InvalidFederatedSessionProviderFailedToRestoreKey",
    "FailedToUnwrapKey",
    "SessionDeletedDuringRefresh",
]


@dataclass(kw_only=True)
class CreationEventDetails(CDPModel):
    """
    Session event details specific to creation.
    """

    fetch_result: DeviceBoundSessionFetchResult
    new_session: DeviceBoundSession | None | None = None


@dataclass(kw_only=True)
class RefreshEventDetails(CDPModel):
    """
    Session event details specific to refresh.
    """

    refresh_result: Literal[
        "Refreshed",
        "InitializedService",
        "Unreachable",
        "ServerError",
        "RefreshQuotaExceeded",
        "FatalError",
        "SigningQuotaExceeded",
    ]
    fetch_result: DeviceBoundSessionFetchResult | None | None = None
    new_session: DeviceBoundSession | None | None = None
    was_fully_proactive_refresh: bool


@dataclass(kw_only=True)
class TerminationEventDetails(CDPModel):
    """
    Session event details specific to termination.
    """

    deletion_reason: Literal[
        "Expired",
        "FailedToRestoreKey",
        "FailedToUnwrapKey",
        "StoragePartitionCleared",
        "ClearBrowsingData",
        "ServerRequested",
        "InvalidSessionParams",
        "RefreshFatalError",
    ]


@dataclass(kw_only=True)
class ChallengeEventDetails(CDPModel):
    """
    Session event details specific to challenges.
    """

    challenge_result: Literal[
        "Success", "NoSessionId", "NoSessionMatch", "CantSetBoundCookie"
    ]
    challenge: str


@dataclass(kw_only=True)
class LoadNetworkResourcePageResult(CDPModel):
    """
    An object providing the result of a network resource load.
    """

    success: bool
    net_error: float | None | None = None
    net_error_name: str | None | None = None
    http_status_code: float | None | None = None
    stream: io.StreamHandle | None = None
    headers: network.Headers | None = None


@dataclass(kw_only=True)
class LoadNetworkResourceOptions(CDPModel):
    """
    An options object that may be extended later to better support CORS, CORB and
    streaming.
    """

    disable_cache: bool
    include_credentials: bool
