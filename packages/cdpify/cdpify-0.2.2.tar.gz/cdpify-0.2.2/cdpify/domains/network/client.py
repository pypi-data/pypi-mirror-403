# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from cdpify.client import CDPClient

from cdpify.shared.decorators import deprecated

from .commands import (
    NetworkCommand,
    CanClearBrowserCacheResult,
    CanClearBrowserCookiesResult,
    CanEmulateNetworkConditionsResult,
    ConfigureDurableMessagesParams,
    ContinueInterceptedRequestParams,
    DeleteCookiesParams,
    EmulateNetworkConditionsByRuleParams,
    EmulateNetworkConditionsByRuleResult,
    EmulateNetworkConditionsParams,
    EnableDeviceBoundSessionsParams,
    EnableParams,
    EnableReportingApiParams,
    FetchSchemefulSiteParams,
    FetchSchemefulSiteResult,
    GetAllCookiesResult,
    GetCertificateParams,
    GetCertificateResult,
    GetCookiesParams,
    GetCookiesResult,
    GetRequestPostDataParams,
    GetRequestPostDataResult,
    GetResponseBodyForInterceptionParams,
    GetResponseBodyForInterceptionResult,
    GetResponseBodyParams,
    GetResponseBodyResult,
    GetSecurityIsolationStatusParams,
    GetSecurityIsolationStatusResult,
    LoadNetworkResourceParams,
    LoadNetworkResourceResult,
    OverrideNetworkStateParams,
    ReplayXHRParams,
    SearchInResponseBodyParams,
    SearchInResponseBodyResult,
    SetAcceptedEncodingsParams,
    SetAttachDebugStackParams,
    SetBlockedURLsParams,
    SetBypassServiceWorkerParams,
    SetCacheDisabledParams,
    SetCookieControlsParams,
    SetCookieParams,
    SetCookieResult,
    SetCookiesParams,
    SetExtraHTTPHeadersParams,
    SetRequestInterceptionParams,
    SetUserAgentOverrideParams,
    StreamResourceContentParams,
    StreamResourceContentResult,
    TakeResponseBodyForInterceptionAsStreamParams,
    TakeResponseBodyForInterceptionAsStreamResult,
)

from .types import (
    AuthChallengeResponse,
    BlockPattern,
    ConnectionType,
    ContentEncoding,
    CookieParam,
    CookiePartitionKey,
    CookiePriority,
    CookieSameSite,
    CookieSourceScheme,
    ErrorReason,
    Headers,
    InterceptionId,
    LoadNetworkResourceOptions,
    NetworkConditions,
    RequestId,
    RequestPattern,
    TimeSinceEpoch,
)

if TYPE_CHECKING:
    from cdpify.domains import emulation, page


class NetworkClient:
    def __init__(self, client: CDPClient) -> None:
        self._client = client

    async def set_accepted_encodings(
        self,
        *,
        encodings: list[ContentEncoding],
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Sets a list of content encodings that will be accepted. Empty list means no
        encoding is accepted.
        """
        params = SetAcceptedEncodingsParams(encodings=encodings)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_ACCEPTED_ENCODINGS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def clear_accepted_encodings_override(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Clears accepted encodings set by setAcceptedEncodings
        """
        result = await self._client.send_raw(
            method=NetworkCommand.CLEAR_ACCEPTED_ENCODINGS_OVERRIDE,
            params=None,
            session_id=session_id,
        )
        return result

    @deprecated()
    async def can_clear_browser_cache(
        self,
        session_id: str | None = None,
    ) -> CanClearBrowserCacheResult:
        """
        Tells whether clearing browser cache is supported.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.CAN_CLEAR_BROWSER_CACHE,
            params=None,
            session_id=session_id,
        )
        return CanClearBrowserCacheResult.from_cdp(result)

    @deprecated()
    async def can_clear_browser_cookies(
        self,
        session_id: str | None = None,
    ) -> CanClearBrowserCookiesResult:
        """
        Tells whether clearing browser cookies is supported.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.CAN_CLEAR_BROWSER_COOKIES,
            params=None,
            session_id=session_id,
        )
        return CanClearBrowserCookiesResult.from_cdp(result)

    @deprecated()
    async def can_emulate_network_conditions(
        self,
        session_id: str | None = None,
    ) -> CanEmulateNetworkConditionsResult:
        """
        Tells whether emulation of network conditions is supported.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.CAN_EMULATE_NETWORK_CONDITIONS,
            params=None,
            session_id=session_id,
        )
        return CanEmulateNetworkConditionsResult.from_cdp(result)

    async def clear_browser_cache(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Clears browser cache.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.CLEAR_BROWSER_CACHE,
            params=None,
            session_id=session_id,
        )
        return result

    async def clear_browser_cookies(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Clears browser cookies.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.CLEAR_BROWSER_COOKIES,
            params=None,
            session_id=session_id,
        )
        return result

    @deprecated()
    async def continue_intercepted_request(
        self,
        *,
        interception_id: InterceptionId,
        error_reason: ErrorReason | None = None,
        raw_response: str | None = None,
        url: str | None = None,
        method: str | None = None,
        post_data: str | None = None,
        headers: Headers | None = None,
        auth_challenge_response: AuthChallengeResponse | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Response to Network.requestIntercepted which either modifies the request to
        continue with any modifications, or blocks it, or completes it with the provided
        response bytes. If a network fetch occurs as a result which encounters a
        redirect an additional Network.requestIntercepted event will be sent with the
        same InterceptionId. Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest
        and Fetch.failRequest instead.
        """
        params = ContinueInterceptedRequestParams(
            interception_id=interception_id,
            error_reason=error_reason,
            raw_response=raw_response,
            url=url,
            method=method,
            post_data=post_data,
            headers=headers,
            auth_challenge_response=auth_challenge_response,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.CONTINUE_INTERCEPTED_REQUEST,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def delete_cookies(
        self,
        *,
        name: str,
        url: str | None = None,
        domain: str | None = None,
        path: str | None = None,
        partition_key: CookiePartitionKey | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Deletes browser cookies with matching name and url or domain/path/partitionKey
        pair.
        """
        params = DeleteCookiesParams(
            name=name, url=url, domain=domain, path=path, partition_key=partition_key
        )

        result = await self._client.send_raw(
            method=NetworkCommand.DELETE_COOKIES,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def disable(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Disables network tracking, prevents network events from being sent to the
        client.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.DISABLE,
            params=None,
            session_id=session_id,
        )
        return result

    @deprecated()
    async def emulate_network_conditions(
        self,
        *,
        offline: bool,
        latency: float,
        download_throughput: float,
        upload_throughput: float,
        connection_type: ConnectionType | None = None,
        packet_loss: float | None = None,
        packet_queue_length: int | None = None,
        packet_reordering: bool | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Activates emulation of network conditions. This command is deprecated in favor
        of the emulateNetworkConditionsByRule and overrideNetworkState commands, which
        can be used together to the same effect.
        """
        params = EmulateNetworkConditionsParams(
            offline=offline,
            latency=latency,
            download_throughput=download_throughput,
            upload_throughput=upload_throughput,
            connection_type=connection_type,
            packet_loss=packet_loss,
            packet_queue_length=packet_queue_length,
            packet_reordering=packet_reordering,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.EMULATE_NETWORK_CONDITIONS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def emulate_network_conditions_by_rule(
        self,
        *,
        offline: bool,
        matched_network_conditions: list[NetworkConditions],
        session_id: str | None = None,
    ) -> EmulateNetworkConditionsByRuleResult:
        """
        Activates emulation of network conditions for individual requests using URL
        match patterns. Unlike the deprecated Network.emulateNetworkConditions this
        method does not affect `navigator` state. Use Network.overrideNetworkState to
        explicitly modify `navigator` behavior.
        """
        params = EmulateNetworkConditionsByRuleParams(
            offline=offline, matched_network_conditions=matched_network_conditions
        )

        result = await self._client.send_raw(
            method=NetworkCommand.EMULATE_NETWORK_CONDITIONS_BY_RULE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return EmulateNetworkConditionsByRuleResult.from_cdp(result)

    async def override_network_state(
        self,
        *,
        offline: bool,
        latency: float,
        download_throughput: float,
        upload_throughput: float,
        connection_type: ConnectionType | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Override the state of navigator.onLine and navigator.connection.
        """
        params = OverrideNetworkStateParams(
            offline=offline,
            latency=latency,
            download_throughput=download_throughput,
            upload_throughput=upload_throughput,
            connection_type=connection_type,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.OVERRIDE_NETWORK_STATE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def enable(
        self,
        *,
        max_total_buffer_size: int | None = None,
        max_resource_buffer_size: int | None = None,
        max_post_data_size: int | None = None,
        report_direct_socket_traffic: bool | None = None,
        enable_durable_messages: bool | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Enables network tracking, network events will now be delivered to the client.
        """
        params = EnableParams(
            max_total_buffer_size=max_total_buffer_size,
            max_resource_buffer_size=max_resource_buffer_size,
            max_post_data_size=max_post_data_size,
            report_direct_socket_traffic=report_direct_socket_traffic,
            enable_durable_messages=enable_durable_messages,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.ENABLE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def configure_durable_messages(
        self,
        *,
        max_total_buffer_size: int | None = None,
        max_resource_buffer_size: int | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Configures storing response bodies outside of renderer, so that these survive a
        cross-process navigation. If maxTotalBufferSize is not set, durable messages are
        disabled.
        """
        params = ConfigureDurableMessagesParams(
            max_total_buffer_size=max_total_buffer_size,
            max_resource_buffer_size=max_resource_buffer_size,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.CONFIGURE_DURABLE_MESSAGES,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    @deprecated()
    async def get_all_cookies(
        self,
        session_id: str | None = None,
    ) -> GetAllCookiesResult:
        """
        Returns all browser cookies. Depending on the backend support, will return
        detailed cookie information in the `cookies` field. Deprecated. Use
        Storage.getCookies instead.
        """
        result = await self._client.send_raw(
            method=NetworkCommand.GET_ALL_COOKIES,
            params=None,
            session_id=session_id,
        )
        return GetAllCookiesResult.from_cdp(result)

    async def get_certificate(
        self,
        *,
        origin: str,
        session_id: str | None = None,
    ) -> GetCertificateResult:
        """
        Returns the DER-encoded certificate.
        """
        params = GetCertificateParams(origin=origin)

        result = await self._client.send_raw(
            method=NetworkCommand.GET_CERTIFICATE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetCertificateResult.from_cdp(result)

    async def get_cookies(
        self,
        *,
        urls: list[str] | None = None,
        session_id: str | None = None,
    ) -> GetCookiesResult:
        """
        Returns all browser cookies for the current URL. Depending on the backend
        support, will return detailed cookie information in the `cookies` field.
        """
        params = GetCookiesParams(urls=urls)

        result = await self._client.send_raw(
            method=NetworkCommand.GET_COOKIES,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetCookiesResult.from_cdp(result)

    async def get_response_body(
        self,
        *,
        request_id: RequestId,
        session_id: str | None = None,
    ) -> GetResponseBodyResult:
        """
        Returns content served for the given request.
        """
        params = GetResponseBodyParams(request_id=request_id)

        result = await self._client.send_raw(
            method=NetworkCommand.GET_RESPONSE_BODY,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetResponseBodyResult.from_cdp(result)

    async def get_request_post_data(
        self,
        *,
        request_id: RequestId,
        session_id: str | None = None,
    ) -> GetRequestPostDataResult:
        """
        Returns post data sent with the request. Returns an error when no data was sent
        with the request.
        """
        params = GetRequestPostDataParams(request_id=request_id)

        result = await self._client.send_raw(
            method=NetworkCommand.GET_REQUEST_POST_DATA,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetRequestPostDataResult.from_cdp(result)

    async def get_response_body_for_interception(
        self,
        *,
        interception_id: InterceptionId,
        session_id: str | None = None,
    ) -> GetResponseBodyForInterceptionResult:
        """
        Returns content served for the given currently intercepted request.
        """
        params = GetResponseBodyForInterceptionParams(interception_id=interception_id)

        result = await self._client.send_raw(
            method=NetworkCommand.GET_RESPONSE_BODY_FOR_INTERCEPTION,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetResponseBodyForInterceptionResult.from_cdp(result)

    async def take_response_body_for_interception_as_stream(
        self,
        *,
        interception_id: InterceptionId,
        session_id: str | None = None,
    ) -> TakeResponseBodyForInterceptionAsStreamResult:
        """
        Returns a handle to the stream representing the response body. Note that after
        this command, the intercepted request can't be continued as is -- you either
        need to cancel it or to provide the response body. The stream only supports
        sequential read, IO.read will fail if the position is specified.
        """
        params = TakeResponseBodyForInterceptionAsStreamParams(
            interception_id=interception_id
        )

        result = await self._client.send_raw(
            method=NetworkCommand.TAKE_RESPONSE_BODY_FOR_INTERCEPTION_AS_STREAM,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return TakeResponseBodyForInterceptionAsStreamResult.from_cdp(result)

    async def replay_xhr(
        self,
        *,
        request_id: RequestId,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        This method sends a new XMLHttpRequest which is identical to the original one.
        The following parameters should be identical: method, url, async, request body,
        extra headers, withCredentials attribute, user, password.
        """
        params = ReplayXHRParams(request_id=request_id)

        result = await self._client.send_raw(
            method=NetworkCommand.REPLAY_XHR,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def search_in_response_body(
        self,
        *,
        request_id: RequestId,
        query: str,
        case_sensitive: bool | None = None,
        is_regex: bool | None = None,
        session_id: str | None = None,
    ) -> SearchInResponseBodyResult:
        """
        Searches for given string in response content.
        """
        params = SearchInResponseBodyParams(
            request_id=request_id,
            query=query,
            case_sensitive=case_sensitive,
            is_regex=is_regex,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.SEARCH_IN_RESPONSE_BODY,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SearchInResponseBodyResult.from_cdp(result)

    async def set_blocked_ur_ls(
        self,
        *,
        url_patterns: list[BlockPattern] | None = None,
        urls: list[str] | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Blocks URLs from loading.
        """
        params = SetBlockedURLsParams(url_patterns=url_patterns, urls=urls)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_BLOCKED_UR_LS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_bypass_service_worker(
        self,
        *,
        bypass: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Toggles ignoring of service worker for each request.
        """
        params = SetBypassServiceWorkerParams(bypass=bypass)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_BYPASS_SERVICE_WORKER,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_cache_disabled(
        self,
        *,
        cache_disabled: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Toggles ignoring cache for each request. If `true`, cache will not be used.
        """
        params = SetCacheDisabledParams(cache_disabled=cache_disabled)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_CACHE_DISABLED,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_cookie(
        self,
        *,
        name: str,
        value: str,
        url: str | None = None,
        domain: str | None = None,
        path: str | None = None,
        secure: bool | None = None,
        http_only: bool | None = None,
        same_site: CookieSameSite | None = None,
        expires: TimeSinceEpoch | None = None,
        priority: CookiePriority | None = None,
        source_scheme: CookieSourceScheme | None = None,
        source_port: int | None = None,
        partition_key: CookiePartitionKey | None = None,
        session_id: str | None = None,
    ) -> SetCookieResult:
        """
        Sets a cookie with the given cookie data; may overwrite equivalent cookies if
        they exist.
        """
        params = SetCookieParams(
            name=name,
            value=value,
            url=url,
            domain=domain,
            path=path,
            secure=secure,
            http_only=http_only,
            same_site=same_site,
            expires=expires,
            priority=priority,
            source_scheme=source_scheme,
            source_port=source_port,
            partition_key=partition_key,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.SET_COOKIE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SetCookieResult.from_cdp(result)

    async def set_cookies(
        self,
        *,
        cookies: list[CookieParam],
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Sets given cookies.
        """
        params = SetCookiesParams(cookies=cookies)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_COOKIES,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_extra_http_headers(
        self,
        *,
        headers: Headers,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Specifies whether to always send extra HTTP headers with the requests from this
        page.
        """
        params = SetExtraHTTPHeadersParams(headers=headers)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_EXTRA_HTTP_HEADERS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_attach_debug_stack(
        self,
        *,
        enabled: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Specifies whether to attach a page script stack id in requests
        """
        params = SetAttachDebugStackParams(enabled=enabled)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_ATTACH_DEBUG_STACK,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    @deprecated()
    async def set_request_interception(
        self,
        *,
        patterns: list[RequestPattern],
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Sets the requests to intercept that match the provided patterns and optionally
        resource types. Deprecated, please use Fetch.enable instead.
        """
        params = SetRequestInterceptionParams(patterns=patterns)

        result = await self._client.send_raw(
            method=NetworkCommand.SET_REQUEST_INTERCEPTION,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_user_agent_override(
        self,
        *,
        user_agent: str,
        accept_language: str | None = None,
        platform: str | None = None,
        user_agent_metadata: emulation.UserAgentMetadata | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Allows overriding user agent with the given string.
        """
        params = SetUserAgentOverrideParams(
            user_agent=user_agent,
            accept_language=accept_language,
            platform=platform,
            user_agent_metadata=user_agent_metadata,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.SET_USER_AGENT_OVERRIDE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def stream_resource_content(
        self,
        *,
        request_id: RequestId,
        session_id: str | None = None,
    ) -> StreamResourceContentResult:
        """
        Enables streaming of the response for the given requestId. If enabled, the
        dataReceived event contains the data that was received during streaming.
        """
        params = StreamResourceContentParams(request_id=request_id)

        result = await self._client.send_raw(
            method=NetworkCommand.STREAM_RESOURCE_CONTENT,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return StreamResourceContentResult.from_cdp(result)

    async def get_security_isolation_status(
        self,
        *,
        frame_id: page.FrameId | None = None,
        session_id: str | None = None,
    ) -> GetSecurityIsolationStatusResult:
        """
        Returns information about the COEP/COOP isolation status.
        """
        params = GetSecurityIsolationStatusParams(frame_id=frame_id)

        result = await self._client.send_raw(
            method=NetworkCommand.GET_SECURITY_ISOLATION_STATUS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetSecurityIsolationStatusResult.from_cdp(result)

    async def enable_reporting_api(
        self,
        *,
        enable: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Enables tracking for the Reporting API, events generated by the Reporting API
        will now be delivered to the client. Enabling triggers 'reportingApiReportAdded'
        for all existing reports.
        """
        params = EnableReportingApiParams(enable=enable)

        result = await self._client.send_raw(
            method=NetworkCommand.ENABLE_REPORTING_API,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def enable_device_bound_sessions(
        self,
        *,
        enable: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Sets up tracking device bound sessions and fetching of initial set of sessions.
        """
        params = EnableDeviceBoundSessionsParams(enable=enable)

        result = await self._client.send_raw(
            method=NetworkCommand.ENABLE_DEVICE_BOUND_SESSIONS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def fetch_schemeful_site(
        self,
        *,
        origin: str,
        session_id: str | None = None,
    ) -> FetchSchemefulSiteResult:
        """
        Fetches the schemeful site for a specific origin.
        """
        params = FetchSchemefulSiteParams(origin=origin)

        result = await self._client.send_raw(
            method=NetworkCommand.FETCH_SCHEMEFUL_SITE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return FetchSchemefulSiteResult.from_cdp(result)

    async def load_network_resource(
        self,
        *,
        frame_id: page.FrameId | None = None,
        url: str,
        options: LoadNetworkResourceOptions,
        session_id: str | None = None,
    ) -> LoadNetworkResourceResult:
        """
        Fetches the resource and returns the content.
        """
        params = LoadNetworkResourceParams(frame_id=frame_id, url=url, options=options)

        result = await self._client.send_raw(
            method=NetworkCommand.LOAD_NETWORK_RESOURCE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return LoadNetworkResourceResult.from_cdp(result)

    async def set_cookie_controls(
        self,
        *,
        enable_third_party_cookie_restriction: bool,
        disable_third_party_cookie_metadata: bool,
        disable_third_party_cookie_heuristics: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Sets Controls for third-party cookie access Page reload is required before the
        new cookie behavior will be observed
        """
        params = SetCookieControlsParams(
            enable_third_party_cookie_restriction=enable_third_party_cookie_restriction,
            disable_third_party_cookie_metadata=disable_third_party_cookie_metadata,
            disable_third_party_cookie_heuristics=disable_third_party_cookie_heuristics,
        )

        result = await self._client.send_raw(
            method=NetworkCommand.SET_COOKIE_CONTROLS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result
