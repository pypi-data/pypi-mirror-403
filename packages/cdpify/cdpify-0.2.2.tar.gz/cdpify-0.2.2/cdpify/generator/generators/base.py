import re

from cdpify.generator.models import Parameter


class GeneratedFileHeaderMixin:
    def _header(self) -> str:
        return (
            "# This file is auto-generated by the CDP protocol generator.\n"
            "# Do not edit this file manually as your changes will be overwritten.\n"
            "# Generated from Chrome DevTools Protocol specifications."
        )


class BaseGenerator(GeneratedFileHeaderMixin):
    def __init__(self) -> None:
        self._cross_domain_refs: set[str] = set()
        self._uses_any: bool = False
        self._uses_literal: bool = False
        self._uses_type_checking: bool = False

    def _reset_tracking(self) -> None:
        self._cross_domain_refs.clear()
        self._uses_any = False
        self._uses_literal = False
        self._uses_type_checking = False

    def _track_type_usage(self, type_str: str) -> None:
        if "Any" in type_str:
            self._uses_any = True
        if "Literal" in type_str:
            self._uses_literal = True

        pattern = r"\b([a-z]+)\.([A-Z][a-zA-Z0-9]*)\b"
        matches = re.findall(pattern, type_str)

        for domain, type_name in matches:
            ref = f"{domain}.{type_name}"
            self._cross_domain_refs.add(ref)

    def _build_typing_imports(self) -> str:
        imports = []

        if self._uses_any:
            imports.append("Any")
        if self._uses_literal:
            imports.append("Literal")
        if self._uses_type_checking:
            imports.append("TYPE_CHECKING")

        if not imports:
            return ""

        return f"from typing import {', '.join(imports)}"

    def _build_cross_domain_imports(self, use_type_checking: bool = True) -> str:
        if not self._cross_domain_refs:
            return ""

        unique_domains = {ref.split(".")[0].lower() for ref in self._cross_domain_refs}
        domains_list = ", ".join(sorted(unique_domains))

        if use_type_checking:
            self._uses_type_checking = True
            return f"if TYPE_CHECKING:\n    from cdpify.domains import {domains_list}"

        lines = [
            f"from cdpify.domains import {domain}" for domain in sorted(unique_domains)
        ]
        return "\n".join(lines)


class TypeAwareGenerator(BaseGenerator):
    def __init__(self):
        super().__init__()
        self._local_type_refs: set[str] = set()

    def _reset_tracking(self):
        super()._reset_tracking()
        self._local_type_refs = set()

    def _scan_parameter(self, param: Parameter) -> None:
        self._scan_direct_ref(param)
        self._scan_array_items(param)

    def _scan_direct_ref(self, param: Parameter) -> None:
        if not param.ref:
            return

        if "." in param.ref:
            self._cross_domain_refs.add(param.ref)
        else:
            self._local_type_refs.add(param.ref)

    def _scan_array_items(self, param: Parameter) -> None:
        if param.type != "array" or not param.items:
            return

        ref = param.items.get("$ref")
        if not ref:
            return

        if "." in ref:
            self._cross_domain_refs.add(ref)
        else:
            self._local_type_refs.add(ref)

    def _build_type_imports(self) -> str:
        if not self._local_type_refs:
            return ""

        lines = ["from .types import ("]
        for type_name in sorted(self._local_type_refs):
            lines.append(f"    {type_name},")
        lines.append(")")

        return "\n".join(lines)
