# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Literal

if TYPE_CHECKING:
    from cdpify.client import CDPClient

from cdpify.shared.decorators import deprecated

from .commands import (
    DebuggerCommand,
    ContinueToLocationParams,
    DisassembleWasmModuleParams,
    DisassembleWasmModuleResult,
    EnableParams,
    EnableResult,
    EvaluateOnCallFrameParams,
    EvaluateOnCallFrameResult,
    GetPossibleBreakpointsParams,
    GetPossibleBreakpointsResult,
    GetScriptSourceParams,
    GetScriptSourceResult,
    GetStackTraceParams,
    GetStackTraceResult,
    GetWasmBytecodeParams,
    GetWasmBytecodeResult,
    NextWasmDisassemblyChunkParams,
    NextWasmDisassemblyChunkResult,
    PauseOnAsyncCallParams,
    RemoveBreakpointParams,
    RestartFrameParams,
    RestartFrameResult,
    ResumeParams,
    SearchInContentParams,
    SearchInContentResult,
    SetAsyncCallStackDepthParams,
    SetBlackboxExecutionContextsParams,
    SetBlackboxPatternsParams,
    SetBlackboxedRangesParams,
    SetBreakpointByUrlParams,
    SetBreakpointByUrlResult,
    SetBreakpointOnFunctionCallParams,
    SetBreakpointOnFunctionCallResult,
    SetBreakpointParams,
    SetBreakpointResult,
    SetBreakpointsActiveParams,
    SetInstrumentationBreakpointParams,
    SetInstrumentationBreakpointResult,
    SetPauseOnExceptionsParams,
    SetReturnValueParams,
    SetScriptSourceParams,
    SetScriptSourceResult,
    SetSkipAllPausesParams,
    SetVariableValueParams,
    StepIntoParams,
    StepOverParams,
)

from .types import (
    BreakpointId,
    CallFrameId,
    Location,
    LocationRange,
    ScriptPosition,
)

if TYPE_CHECKING:
    from cdpify.domains import runtime


class DebuggerClient:
    def __init__(self, client: CDPClient) -> None:
        self._client = client

    async def continue_to_location(
        self,
        *,
        location: Location,
        target_call_frames: Literal["any", "current"] | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Continues execution until specific location is reached.
        """
        params = ContinueToLocationParams(
            location=location, target_call_frames=target_call_frames
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.CONTINUE_TO_LOCATION,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def disable(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Disables debugger for given page.
        """
        result = await self._client.send_raw(
            method=DebuggerCommand.DISABLE,
            params=None,
            session_id=session_id,
        )
        return result

    async def enable(
        self,
        *,
        max_scripts_cache_size: float | None = None,
        session_id: str | None = None,
    ) -> EnableResult:
        """
        Enables debugger for the given page. Clients should not assume that the
        debugging has been enabled until the result for this command is received.
        """
        params = EnableParams(max_scripts_cache_size=max_scripts_cache_size)

        result = await self._client.send_raw(
            method=DebuggerCommand.ENABLE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return EnableResult.from_cdp(result)

    async def evaluate_on_call_frame(
        self,
        *,
        call_frame_id: CallFrameId,
        expression: str,
        object_group: str | None = None,
        include_command_line_api: bool | None = None,
        silent: bool | None = None,
        return_by_value: bool | None = None,
        generate_preview: bool | None = None,
        throw_on_side_effect: bool | None = None,
        timeout: runtime.TimeDelta | None = None,
        session_id: str | None = None,
    ) -> EvaluateOnCallFrameResult:
        """
        Evaluates expression on a given call frame.
        """
        params = EvaluateOnCallFrameParams(
            call_frame_id=call_frame_id,
            expression=expression,
            object_group=object_group,
            include_command_line_api=include_command_line_api,
            silent=silent,
            return_by_value=return_by_value,
            generate_preview=generate_preview,
            throw_on_side_effect=throw_on_side_effect,
            timeout=timeout,
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.EVALUATE_ON_CALL_FRAME,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return EvaluateOnCallFrameResult.from_cdp(result)

    async def get_possible_breakpoints(
        self,
        *,
        start: Location,
        end: Location | None = None,
        restrict_to_function: bool | None = None,
        session_id: str | None = None,
    ) -> GetPossibleBreakpointsResult:
        """
        Returns possible locations for breakpoint. scriptId in start and end range
        locations should be the same.
        """
        params = GetPossibleBreakpointsParams(
            start=start, end=end, restrict_to_function=restrict_to_function
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.GET_POSSIBLE_BREAKPOINTS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetPossibleBreakpointsResult.from_cdp(result)

    async def get_script_source(
        self,
        *,
        script_id: runtime.ScriptId,
        session_id: str | None = None,
    ) -> GetScriptSourceResult:
        """
        Returns source for the script with given id.
        """
        params = GetScriptSourceParams(script_id=script_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.GET_SCRIPT_SOURCE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetScriptSourceResult.from_cdp(result)

    async def disassemble_wasm_module(
        self,
        *,
        script_id: runtime.ScriptId,
        session_id: str | None = None,
    ) -> DisassembleWasmModuleResult:
        params = DisassembleWasmModuleParams(script_id=script_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.DISASSEMBLE_WASM_MODULE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return DisassembleWasmModuleResult.from_cdp(result)

    async def next_wasm_disassembly_chunk(
        self,
        *,
        stream_id: str,
        session_id: str | None = None,
    ) -> NextWasmDisassemblyChunkResult:
        """
        Disassemble the next chunk of lines for the module corresponding to the stream.
        If disassembly is complete, this API will invalidate the streamId and return an
        empty chunk. Any subsequent calls for the now invalid stream will return errors.
        """
        params = NextWasmDisassemblyChunkParams(stream_id=stream_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.NEXT_WASM_DISASSEMBLY_CHUNK,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return NextWasmDisassemblyChunkResult.from_cdp(result)

    @deprecated()
    async def get_wasm_bytecode(
        self,
        *,
        script_id: runtime.ScriptId,
        session_id: str | None = None,
    ) -> GetWasmBytecodeResult:
        """
        This command is deprecated. Use getScriptSource instead.
        """
        params = GetWasmBytecodeParams(script_id=script_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.GET_WASM_BYTECODE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetWasmBytecodeResult.from_cdp(result)

    async def get_stack_trace(
        self,
        *,
        stack_trace_id: runtime.StackTraceId,
        session_id: str | None = None,
    ) -> GetStackTraceResult:
        """
        Returns stack trace with given `stackTraceId`.
        """
        params = GetStackTraceParams(stack_trace_id=stack_trace_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.GET_STACK_TRACE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return GetStackTraceResult.from_cdp(result)

    async def pause(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Stops on the next JavaScript statement.
        """
        result = await self._client.send_raw(
            method=DebuggerCommand.PAUSE,
            params=None,
            session_id=session_id,
        )
        return result

    @deprecated()
    async def pause_on_async_call(
        self,
        *,
        parent_stack_trace_id: runtime.StackTraceId,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        params = PauseOnAsyncCallParams(parent_stack_trace_id=parent_stack_trace_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.PAUSE_ON_ASYNC_CALL,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def remove_breakpoint(
        self,
        *,
        breakpoint_id: BreakpointId,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Removes JavaScript breakpoint.
        """
        params = RemoveBreakpointParams(breakpoint_id=breakpoint_id)

        result = await self._client.send_raw(
            method=DebuggerCommand.REMOVE_BREAKPOINT,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def restart_frame(
        self,
        *,
        call_frame_id: CallFrameId,
        mode: Literal["StepInto"] | None = None,
        session_id: str | None = None,
    ) -> RestartFrameResult:
        """
        Restarts particular call frame from the beginning. The old, deprecated behavior
        of `restartFrame` is to stay paused and allow further CDP commands after a
        restart was scheduled. This can cause problems with restarting, so we now
        continue execution immediatly after it has been scheduled until we reach the
        beginning of the restarted frame. To stay back-wards compatible, `restartFrame`
        now expects a `mode` parameter to be present. If the `mode` parameter is
        missing, `restartFrame` errors out. The various return values are deprecated and
        `callFrames` is always empty. Use the call frames from the `Debugger#paused`
        events instead, that fires once V8 pauses at the beginning of the restarted
        function.
        """
        params = RestartFrameParams(call_frame_id=call_frame_id, mode=mode)

        result = await self._client.send_raw(
            method=DebuggerCommand.RESTART_FRAME,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return RestartFrameResult.from_cdp(result)

    async def resume(
        self,
        *,
        terminate_on_resume: bool | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Resumes JavaScript execution.
        """
        params = ResumeParams(terminate_on_resume=terminate_on_resume)

        result = await self._client.send_raw(
            method=DebuggerCommand.RESUME,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def search_in_content(
        self,
        *,
        script_id: runtime.ScriptId,
        query: str,
        case_sensitive: bool | None = None,
        is_regex: bool | None = None,
        session_id: str | None = None,
    ) -> SearchInContentResult:
        """
        Searches for given string in script content.
        """
        params = SearchInContentParams(
            script_id=script_id,
            query=query,
            case_sensitive=case_sensitive,
            is_regex=is_regex,
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.SEARCH_IN_CONTENT,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SearchInContentResult.from_cdp(result)

    async def set_async_call_stack_depth(
        self,
        *,
        max_depth: int,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Enables or disables async call stacks tracking.
        """
        params = SetAsyncCallStackDepthParams(max_depth=max_depth)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_ASYNC_CALL_STACK_DEPTH,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_blackbox_execution_contexts(
        self,
        *,
        unique_ids: list[str],
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Replace previous blackbox execution contexts with passed ones. Forces backend
        to skip stepping/pausing in scripts in these execution contexts. VM will try to
        leave blackboxed script by performing 'step in' several times, finally resorting
        to 'step out' if unsuccessful.
        """
        params = SetBlackboxExecutionContextsParams(unique_ids=unique_ids)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BLACKBOX_EXECUTION_CONTEXTS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_blackbox_patterns(
        self,
        *,
        patterns: list[str],
        skip_anonymous: bool | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Replace previous blackbox patterns with passed ones. Forces backend to skip
        stepping/pausing in scripts with url matching one of the patterns. VM will try
        to leave blackboxed script by performing 'step in' several times, finally
        resorting to 'step out' if unsuccessful.
        """
        params = SetBlackboxPatternsParams(
            patterns=patterns, skip_anonymous=skip_anonymous
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BLACKBOX_PATTERNS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_blackboxed_ranges(
        self,
        *,
        script_id: runtime.ScriptId,
        positions: list[ScriptPosition],
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Makes backend skip steps in the script in blackboxed ranges. VM will try leave
        blacklisted scripts by performing 'step in' several times, finally resorting to
        'step out' if unsuccessful. Positions array contains positions where blackbox
        state is changed. First interval isn't blackboxed. Array should be sorted.
        """
        params = SetBlackboxedRangesParams(script_id=script_id, positions=positions)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BLACKBOXED_RANGES,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_breakpoint(
        self,
        *,
        location: Location,
        condition: str | None = None,
        session_id: str | None = None,
    ) -> SetBreakpointResult:
        """
        Sets JavaScript breakpoint at a given location.
        """
        params = SetBreakpointParams(location=location, condition=condition)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BREAKPOINT,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SetBreakpointResult.from_cdp(result)

    async def set_instrumentation_breakpoint(
        self,
        *,
        instrumentation: Literal[
            "beforeScriptExecution", "beforeScriptWithSourceMapExecution"
        ],
        session_id: str | None = None,
    ) -> SetInstrumentationBreakpointResult:
        """
        Sets instrumentation breakpoint.
        """
        params = SetInstrumentationBreakpointParams(instrumentation=instrumentation)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_INSTRUMENTATION_BREAKPOINT,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SetInstrumentationBreakpointResult.from_cdp(result)

    async def set_breakpoint_by_url(
        self,
        *,
        line_number: int,
        url: str | None = None,
        url_regex: str | None = None,
        script_hash: str | None = None,
        column_number: int | None = None,
        condition: str | None = None,
        session_id: str | None = None,
    ) -> SetBreakpointByUrlResult:
        """
        Sets JavaScript breakpoint at given location specified either by URL or URL
        regex. Once this command is issued, all existing parsed scripts will have
        breakpoints resolved and returned in `locations` property. Further matching
        script parsing will result in subsequent `breakpointResolved` events issued.
        This logical breakpoint will survive page reloads.
        """
        params = SetBreakpointByUrlParams(
            line_number=line_number,
            url=url,
            url_regex=url_regex,
            script_hash=script_hash,
            column_number=column_number,
            condition=condition,
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BREAKPOINT_BY_URL,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SetBreakpointByUrlResult.from_cdp(result)

    async def set_breakpoint_on_function_call(
        self,
        *,
        object_id: runtime.RemoteObjectId,
        condition: str | None = None,
        session_id: str | None = None,
    ) -> SetBreakpointOnFunctionCallResult:
        """
        Sets JavaScript breakpoint before each call to the given function. If another
        function was created from the same source as a given one, calling it will also
        trigger the breakpoint.
        """
        params = SetBreakpointOnFunctionCallParams(
            object_id=object_id, condition=condition
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BREAKPOINT_ON_FUNCTION_CALL,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SetBreakpointOnFunctionCallResult.from_cdp(result)

    async def set_breakpoints_active(
        self,
        *,
        active: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Activates / deactivates all breakpoints on the page.
        """
        params = SetBreakpointsActiveParams(active=active)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_BREAKPOINTS_ACTIVE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_pause_on_exceptions(
        self,
        *,
        state: Literal["none", "caught", "uncaught", "all"],
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Defines pause on exceptions state. Can be set to stop on all exceptions,
        uncaught exceptions, or caught exceptions, no exceptions. Initial pause on
        exceptions state is `none`.
        """
        params = SetPauseOnExceptionsParams(state=state)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_PAUSE_ON_EXCEPTIONS,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_return_value(
        self,
        *,
        new_value: runtime.CallArgument,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Changes return value in top frame. Available only at return break position.
        """
        params = SetReturnValueParams(new_value=new_value)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_RETURN_VALUE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_script_source(
        self,
        *,
        script_id: runtime.ScriptId,
        script_source: str,
        dry_run: bool | None = None,
        allow_top_frame_editing: bool | None = None,
        session_id: str | None = None,
    ) -> SetScriptSourceResult:
        """
        Edits JavaScript source live. In general, functions that are currently on the
        stack can not be edited with a single exception: If the edited function is the
        top-most stack frame and that is the only activation of that function on the
        stack. In this case the live edit will be successful and a
        `Debugger.restartFrame` for the top-most function is automatically triggered.
        """
        params = SetScriptSourceParams(
            script_id=script_id,
            script_source=script_source,
            dry_run=dry_run,
            allow_top_frame_editing=allow_top_frame_editing,
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_SCRIPT_SOURCE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return SetScriptSourceResult.from_cdp(result)

    async def set_skip_all_pauses(
        self,
        *,
        skip: bool,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Makes page not interrupt on any pauses (breakpoint, exception, dom exception
        etc).
        """
        params = SetSkipAllPausesParams(skip=skip)

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_SKIP_ALL_PAUSES,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def set_variable_value(
        self,
        *,
        scope_number: int,
        variable_name: str,
        new_value: runtime.CallArgument,
        call_frame_id: CallFrameId,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Changes value of variable in a callframe. Object-based scopes are not supported
        and must be mutated manually.
        """
        params = SetVariableValueParams(
            scope_number=scope_number,
            variable_name=variable_name,
            new_value=new_value,
            call_frame_id=call_frame_id,
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.SET_VARIABLE_VALUE,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def step_into(
        self,
        *,
        break_on_async_call: bool | None = None,
        skip_list: list[LocationRange] | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Steps into the function call.
        """
        params = StepIntoParams(
            break_on_async_call=break_on_async_call, skip_list=skip_list
        )

        result = await self._client.send_raw(
            method=DebuggerCommand.STEP_INTO,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result

    async def step_out(
        self,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Steps out of the function call.
        """
        result = await self._client.send_raw(
            method=DebuggerCommand.STEP_OUT,
            params=None,
            session_id=session_id,
        )
        return result

    async def step_over(
        self,
        *,
        skip_list: list[LocationRange] | None = None,
        session_id: str | None = None,
    ) -> dict[str, Any]:
        """
        Steps over the statement.
        """
        params = StepOverParams(skip_list=skip_list)

        result = await self._client.send_raw(
            method=DebuggerCommand.STEP_OVER,
            params=params.to_cdp_params(),
            session_id=session_id,
        )
        return result
