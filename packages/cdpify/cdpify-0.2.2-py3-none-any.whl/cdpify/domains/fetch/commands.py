# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

from dataclasses import dataclass
from enum import StrEnum
from cdpify.shared.models import CDPModel

from .types import (
    AuthChallengeResponse,
    HeaderEntry,
    RequestId,
    RequestPattern,
)

from cdpify.domains import io
from cdpify.domains import network


class FetchCommand(StrEnum):
    DISABLE = "Fetch.disable"
    ENABLE = "Fetch.enable"
    FAIL_REQUEST = "Fetch.failRequest"
    FULFILL_REQUEST = "Fetch.fulfillRequest"
    CONTINUE_REQUEST = "Fetch.continueRequest"
    CONTINUE_WITH_AUTH = "Fetch.continueWithAuth"
    CONTINUE_RESPONSE = "Fetch.continueResponse"
    GET_RESPONSE_BODY = "Fetch.getResponseBody"
    TAKE_RESPONSE_BODY_AS_STREAM = "Fetch.takeResponseBodyAsStream"


@dataclass(kw_only=True)
class EnableParams(CDPModel):
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
    """

    patterns: list[RequestPattern] | None | None = None
    handle_auth_requests: bool | None | None = None


@dataclass(kw_only=True)
class FailRequestParams(CDPModel):
    """
    Causes the request to fail with specified reason.
    """

    request_id: RequestId
    error_reason: network.ErrorReason


@dataclass(kw_only=True)
class FulfillRequestParams(CDPModel):
    """
    Provides response to the request.
    """

    request_id: RequestId
    response_code: int
    response_headers: list[HeaderEntry] | None | None = None
    binary_response_headers: str | None | None = None
    body: str | None | None = None
    response_phrase: str | None | None = None


@dataclass(kw_only=True)
class ContinueRequestParams(CDPModel):
    """
    Continues the request, optionally modifying some of its parameters.
    """

    request_id: RequestId
    url: str | None | None = None
    method: str | None | None = None
    post_data: str | None | None = None
    headers: list[HeaderEntry] | None | None = None
    intercept_response: bool | None | None = None


@dataclass(kw_only=True)
class ContinueWithAuthParams(CDPModel):
    """
    Continues a request supplying authChallengeResponse following authRequired event.
    """

    request_id: RequestId
    auth_challenge_response: AuthChallengeResponse


@dataclass(kw_only=True)
class ContinueResponseParams(CDPModel):
    """
    Continues loading of the paused response, optionally modifying the response
    headers. If either responseCode or headers are modified, all of them must be
    present.
    """

    request_id: RequestId
    response_code: int | None | None = None
    response_phrase: str | None | None = None
    response_headers: list[HeaderEntry] | None | None = None
    binary_response_headers: str | None | None = None


@dataclass(kw_only=True)
class GetResponseBodyParams(CDPModel):
    """
    Causes the body of the response to be received from the server and returned as a
    single string. May only be issued for a request that is paused in the Response stage
    and is mutually exclusive with takeResponseBodyForInterceptionAsStream. Calling
    other methods that affect the request or disabling fetch domain before body is
    received results in an undefined behavior. Note that the response body is not
    available for redirects. Requests paused in the _redirect received_ state may be
    differentiated by `responseCode` and presence of `location` response header, see
    comments to `requestPaused` for details.
    """

    request_id: RequestId


@dataclass(kw_only=True)
class GetResponseBodyResult(CDPModel):
    body: str
    base64_encoded: bool


@dataclass(kw_only=True)
class TakeResponseBodyAsStreamParams(CDPModel):
    """
    Returns a handle to the stream representing the response body. The request must be
    paused in the HeadersReceived stage. Note that after this command the request can't
    be continued as is -- client either needs to cancel it or to provide the response
    body. The stream only supports sequential read, IO.read will fail if the position is
    specified. This method is mutually exclusive with getResponseBody. Calling other
    methods that affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    """

    request_id: RequestId


@dataclass(kw_only=True)
class TakeResponseBodyAsStreamResult(CDPModel):
    stream: io.StreamHandle
