#!/usr/bin/env python3
"""
Apply patch version upgrades from a generated report.
This script reads the JSON report and updates package.json or go.mod files accordingly.
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import List, Optional

from go_patch_it.core.files import restore_all_backups
from go_patch_it.core.git import gitignore_patterns
from go_patch_it.core.processing import apply_upgrades


def main(argv: Optional[List[str]] = None) -> int:
    """Main entry point for apply command. Returns exit code."""
    parser = argparse.ArgumentParser(
        description="Apply patch version upgrades from a generated report.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
    %(prog)s patch-upgrades.json
    %(prog)s --root /path/to/repo patch-upgrades.json
    %(prog)s --backup patch-upgrades.json
    %(prog)s --restore --root /path/to/repo

NOTES:
    - Automatically regenerates package-lock.json, yarn.lock, or go.sum files
    - Verifies builds with npm ci, yarn install --frozen-lockfile, or go mod verify
    - Use --restore to revert changes from .old backup files
    - Use --dry-run to preview changes without applying them
        """,
    )

    parser.add_argument(
        "upgrades_file",
        nargs="?",
        help="Path to the patch-upgrades.json file generated by go-patch-it --generate",
    )
    parser.add_argument(
        "-r",
        "--root",
        default=os.getcwd(),
        help="Repository root directory (default: current directory)",
    )
    parser.add_argument(
        "--backup",
        action="store_true",
        help="Create backups of package.json files before applying changes (default: False)",
    )
    parser.add_argument(
        "--restore",
        action="store_true",
        help="Restore files from .old backups instead of applying upgrades",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be changed without making any modifications (skips confirmation prompt)",
    )
    parser.add_argument(
        "-y",
        "--yes",
        action="store_true",
        help="Skip confirmation prompt and apply all upgrades automatically",
    )

    args = parser.parse_args(argv)

    # Handle --restore flag
    if args.restore:
        repo_root = Path(args.root).resolve()
        if not repo_root.exists():
            print(f"Error: Repository root does not exist: {repo_root}", file=sys.stderr)
            return 1

        # Add gitignore patterns before restore, automatically removed on exit
        with gitignore_patterns(repo_root):
            restored = restore_all_backups(repo_root)
            return 0 if restored > 0 else 1

    # Validate upgrades_file is provided when not using --restore
    if not args.upgrades_file:
        parser.error("upgrades_file is required when not using --restore")

    # Resolve paths
    repo_root = Path(args.root).resolve()
    upgrades_file = Path(args.upgrades_file)

    if not upgrades_file.is_absolute():
        # Try relative to current directory first, then relative to repo root
        if (Path.cwd() / upgrades_file).exists():
            upgrades_file = (Path.cwd() / upgrades_file).resolve()
        elif (repo_root / upgrades_file).exists():
            upgrades_file = (repo_root / upgrades_file).resolve()
        else:
            print(f"Error: Upgrades file not found: {args.upgrades_file}", file=sys.stderr)
            return 1

    # Validate repository root exists (package.json files are validated when applying upgrades)
    if not repo_root.exists():
        print(f"Error: Repository root does not exist: {repo_root}", file=sys.stderr)
        print("Please specify the correct repository root with --root", file=sys.stderr)
        return 1

    # Load upgrades
    try:
        with open(upgrades_file) as f:
            upgrades = json.load(f)
    except (OSError, json.JSONDecodeError) as e:
        print(f"Error reading upgrades file: {e}", file=sys.stderr)
        return 1

    if not isinstance(upgrades, list):
        print("Error: Invalid upgrades file format (expected JSON array)", file=sys.stderr)
        return 1

    if not upgrades:
        print("No upgrades to apply.")
        return 0

    # Validate that all upgrades are for the same package manager type
    locations = {u["location"] for u in upgrades}
    go_mod_files = {loc for loc in locations if loc.endswith("go.mod")}
    package_json_files = {loc for loc in locations if loc.endswith("package.json")}

    if go_mod_files and package_json_files:
        print(
            "Error: Upgrades file contains both go.mod and package.json files.",
            file=sys.stderr,
        )
        print(
            "Please generate separate upgrade files for Go modules and npm/yarn packages.",
            file=sys.stderr,
        )
        return 1

    print(f"Applying {len(upgrades)} upgrades from {upgrades_file}")
    print(f"Repository root: {repo_root}")
    print()

    # Confirm before applying
    file_type = "go.mod files" if go_mod_files else "package.json files"

    print(f"This will modify the following {file_type}:")
    for location in sorted(locations):
        print(f"  - {location}")
    print()

    # Skip confirmation prompt in dry-run mode or with --yes flag
    if not args.dry_run and not args.yes:
        response = input("Continue? [y/N]: ").strip().lower()
        if response != "y":
            print("Cancelled.")
            return 0
        print()

    # Add gitignore patterns before applying upgrades, automatically removed on exit
    with gitignore_patterns(repo_root):
        # Apply upgrades
        apply_upgrades(repo_root, upgrades, create_backups=args.backup, dry_run=args.dry_run)

    return 0


if __name__ == "__main__":
    sys.exit(main())
