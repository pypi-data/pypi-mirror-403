#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2025-2026 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

"""SPSDK NXP Image bootable image management commands.

This module provides CLI commands for creating, parsing, verifying and managing
bootable images, FCB (Flash Configuration Block), XMCD (External Memory
Configuration Data), and related components for NXP microcontrollers.
"""

import logging
import os
from typing import Optional

import click

from spsdk.apps.utils.common_cli_options import (
    CommandsTreeGroup,
    spsdk_config_option,
    spsdk_family_option,
    spsdk_output_option,
    spsdk_output_option_to_config,
)
from spsdk.apps.utils.utils import SPSDKAppError, print_files, print_verifier_to_console
from spsdk.exceptions import SPSDKError
from spsdk.image.bootable_image.bimg import BootableImage
from spsdk.image.fcb.fcb import FCB
from spsdk.image.mem_type import MemoryType
from spsdk.image.wic import replace_uboot
from spsdk.image.xmcd.xmcd import XMCD
from spsdk.utils.config import Config
from spsdk.utils.family import FamilyRevision
from spsdk.utils.misc import get_printable_path, load_binary, write_file
from spsdk.utils.verifier import Verifier

logger = logging.getLogger(__name__)


@click.group(name="bootable-image", cls=CommandsTreeGroup)
def bootable_image_group() -> None:
    """Group of bootable image utilities."""


@bootable_image_group.command(name="export", no_args_is_help=True)
@spsdk_output_option_to_config(
    key_output="output",
    key_output_format="output_format",
)
@spsdk_config_option(klass=BootableImage)
def bootable_image_export_command(config: Config) -> None:
    """Export merged boot image blocks into one bootable image.

    The configuration template files could be generated by subcommand 'get-templates'.
    """
    bootable_image_export(config)


def bootable_image_export(config: Config) -> None:
    """Export merged boot image blocks into one bootable image."""
    output = config.get_output_file_name("output")
    bimg_image = BootableImage.load_from_config(config)
    bimg_image_info = bimg_image.image_info()

    bimg_image_info.save_binary_image(output, file_format=config.get_str("output_format", "bin"))

    logger.info(
        f"Created Bootable Image:\n{str(bimg_image_info)}Format: {config.get_str('output_format', 'bin')}"
    )
    logger.info(f"Created Bootable Image memory map:\n{bimg_image_info.draw()}")
    if bimg_image.bootable_header_only:
        click.echo("It has been created just only bootable header due missing application info.")
    click.echo(f"Success. (Bootable Image: {get_printable_path(output)} created) ")

    if config.get("post_export"):
        exported_files = bimg_image.post_export(config.get("post_export"))
        if exported_files:
            click.echo("Performing post export")
            print_files(exported_files)


@bootable_image_group.command(name="parse", no_args_is_help=True)
@spsdk_family_option(families=BootableImage.get_supported_families())
@click.option(
    "-m",
    "--mem-type",
    type=click.Choice(
        [mem_type.label for mem_type in BootableImage.get_supported_memory_types()],
        case_sensitive=False,
    ),
    required=False,
    help="Select the chip used memory type.",
)
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True),
    required=True,
    help="Path to binary Bootable image to parse.",
)
@spsdk_output_option(directory=True)
def bootable_image_parse_command(
    family: FamilyRevision, mem_type: Optional[str], binary: str, output: str
) -> None:
    """Parse Bootable Image into YAML configuration and binary images."""
    memory = None
    if mem_type:
        memory = MemoryType.from_label(mem_type)
    bootable_image_parse(family, memory, binary, output)


def bootable_image_parse(
    family: FamilyRevision, mem_type: Optional[MemoryType], binary: str, output: str
) -> None:
    """Parse Bootable Image into YAML configuration and binary images."""
    data = load_binary(binary)
    if mem_type:
        preparsed = BootableImage.pre_parse_verify(data, family, mem_type)
        if preparsed.has_errors:
            click.echo("The image bases has error, it doesn't passed pre-parse check:")
            print_verifier_to_console(preparsed)
            raise SPSDKAppError("Pre-parsed check failed")

    bimg_image = BootableImage.parse(data, family=family, mem_type=mem_type)
    bimg_image_info = bimg_image.image_info()
    logger.info(f"Parsed Bootable image memory map: {bimg_image_info.draw()}")
    write_file(
        bimg_image.get_config_yaml(output),
        os.path.join(output, f"bootable_image_{family.name}_{bimg_image.mem_type.label}.yaml"),
    )
    click.echo(
        f"Success. (Bootable Image: {binary} has been parsed and stored into {get_printable_path(output)} .)"
    )


@bootable_image_group.command(name="get-templates", no_args_is_help=True)
@spsdk_family_option(families=BootableImage.get_supported_families())
@spsdk_output_option(directory=True, force=True)
@click.option(
    "-t",
    "--template",
    type=str,
    required=False,
    help="Specific template name (e.g., imx_boot_flash_all). "
    "If not specified, generates all memory type templates plus all extra templates.",
)
@click.option(
    "-b",
    "--board",
    type=str,
    required=False,
    help="Board name to use board-specific filenames (e.g., imx95-19x19-lpddr5-evk). "
    "Use 'list-boards' command to see available boards. "
    "If not specified with --template, generates templates for all boards.",
)
@click.option(
    "-i",
    "--input-dir",
    type=click.Path(file_okay=False, resolve_path=True),
    required=False,
    help="Input directory path to prepend to image filenames in generated configs. "
    "Directory will be created if it doesn't exist.",
)
def bootable_image_get_templates_command(
    family: FamilyRevision,
    output: str,
    template: Optional[str],
    board: Optional[str],
    input_dir: Optional[str],
) -> None:
    """Create template of configurations in YAML format.

    If --template is specified, generates a specific template structure.

    If --template is not specified, generates:
    - Standard templates for all memory types (legacy behavior)
    - All extra templates in sub folders, with board-specific variants

    The template files folder name is specified as argument of this command.
    """
    if template:
        # Generate specific template
        bootable_image_get_template_specific(
            family=family,
            output=output,
            template=template,
            board=board,
            input_dir=input_dir,
        )
    else:
        # Generate all templates
        bootable_image_get_all_templates(
            family=family,
            output=output,
            board=board,
            input_dir=input_dir,
        )


def bootable_image_get_template_specific(
    family: FamilyRevision,
    output: str,
    template: str,
    board: Optional[str],
    input_dir: Optional[str],
) -> None:
    """Generate a specific template with optional board configuration.

    :param family: Target chip family and revision.
    :param output: Output directory for generated templates.
    :param template: Template name to generate.
    :param board: Optional board name for board-specific filenames.
    :param input_dir: Optional input directory path.
    :raises SPSDKAppError: If template or board validation fails.
    """
    # Validate template exists
    available_templates = BootableImage.get_supported_templates(family)
    if not available_templates:
        raise SPSDKAppError(
            f"No templates available for family {family}. "
            "This family may not support template-based generation."
        )

    if template not in available_templates:
        raise SPSDKAppError(
            f"Template '{template}' not found for {family}. "
            f"Available templates: {', '.join(available_templates)}"
        )

    # Validate board if specified
    if board:
        supported_boards = BootableImage.get_supported_boards(family)
        if not supported_boards:
            raise SPSDKAppError(f"No boards defined for family {family}.")
        if board not in supported_boards:
            raise SPSDKAppError(
                f"Board '{board}' not found for {family}. "
                f"Available boards: {', '.join(supported_boards)}"
            )

    # Create input directory if specified and doesn't exist
    if not input_dir:
        input_dir = "inputs"

    os.makedirs(os.path.join(output, input_dir), exist_ok=True)
    click.echo(f"Creating input directory: {input_dir}")

    bootable_image_get_template(
        family=family,
        template=template,
        output=output,
        board=board,
        input_dir=input_dir,
    )


def bootable_image_get_all_templates(
    family: FamilyRevision,
    output: str,
    board: Optional[str],
    input_dir: Optional[str],
) -> None:
    """Generate all templates including standard and extra templates.

    Generates:
    1. Standard templates for all memory types in the root output directory
    2. Extra templates in sub folders, with board-specific variants if boards are defined

    :param family: Target chip family and revision.
    :param output: Output directory for generated templates.
    :param board: Optional specific board to generate templates for.
    :param input_dir: Optional input directory path.
    """
    click.echo(f"Generating all templates for {family}...\n")

    # 1. Generate standard memory type templates
    click.echo("Generating standard memory type templates...")
    bootable_image_get_templates(family, output)
    click.echo()

    # 2. Generate extra templates
    available_templates = BootableImage.get_supported_templates(family)

    if not available_templates:
        click.echo("No extra templates available for this family.")
        return

    click.echo(f"Generating {len(available_templates)} extra template(s)...\n")

    # Get supported boards
    supported_boards = BootableImage.get_supported_boards(family)

    # If specific board requested, only generate for that board
    if board:
        if not supported_boards:
            raise SPSDKAppError(f"No boards defined for family {family}.")
        if board not in supported_boards:
            raise SPSDKAppError(
                f"Board '{board}' not found for {family}. "
                f"Available boards: {', '.join(supported_boards)}"
            )
        boards_to_generate = [board]
    else:
        # Generate for all boards if boards are defined, otherwise generate generic
        boards_to_generate = supported_boards if supported_boards else []

    # Generate each template
    for template_name in available_templates:
        try:
            template_info = BootableImage.get_template_info(family, template_name)
            template_desc = template_info.get("description", "No description")

            click.echo(f"Template: {template_name}")
            click.echo(f"  Description: {template_desc}")

            # Generate for each board (or once if no boards)
            for board_name in boards_to_generate:
                # Create template-specific output directory
                if board_name:
                    template_output = os.path.join(output, template_name, board_name)
                    click.echo(f"  Generating for board: {board_name}")
                else:
                    template_output = os.path.join(output, template_name)
                    click.echo("  Generating generic template")

                os.makedirs(template_output, exist_ok=True)

                # Set input directory
                template_input_dir = input_dir if input_dir else "inputs"
                os.makedirs(os.path.join(template_output, template_input_dir), exist_ok=True)

                # Generate the template
                try:
                    generated_files = BootableImage.generate_extended_templates(
                        family=family,
                        template_name=template_name,
                        output_dir=template_output,
                        board=board_name,
                        input_dir=template_input_dir,
                    )

                    click.echo(
                        f"    Generated {len(generated_files)} file(s) in {get_printable_path(template_output)}"
                    )

                except SPSDKError as exc:
                    click.echo(f"    Error: {exc}", err=True)

            click.echo()

        except SPSDKError as exc:
            click.echo(f"  Error loading template '{template_name}': {exc}\n", err=True)

    # Print summary
    click.echo("=" * 80)
    click.echo("Template generation complete!")
    click.echo(f"\nGenerated templates in: {get_printable_path(output)}")
    click.echo("\nDirectory structure:")
    click.echo("  ├── Standard templates (bootimg_*.yaml)")
    if available_templates:
        click.echo("  └── Extra templates:")
        for template_name in available_templates:
            click.echo(f"      └── {template_name}/")
            if supported_boards and not board:
                for board_name in supported_boards:
                    click.echo(f"          └── {board_name}/")
                    click.echo("              ├── bootable_image.yaml")
                    click.echo("              ├── *.yaml (container configs)")
                    click.echo("              └── inputs/ (input files directory)")
            else:
                click.echo("          ├── bootable_image.yaml")
                click.echo("          ├── *.yaml (container configs)")
                click.echo("          └── inputs/ (input files directory)")


def bootable_image_get_templates(family: FamilyRevision, output: str) -> None:
    """Create template of configurations in YAML format from all memory types."""
    mem_types = BootableImage.get_supported_memory_types(family)
    for mem_type in mem_types:
        output_file = os.path.join(output, f"bootimg_{family.name}_{mem_type.label}.yaml")
        click.echo(f"Creating {get_printable_path(output_file)} template file.")
        write_file(BootableImage.get_config_template(family, mem_type), output_file)


def bootable_image_get_template(
    family: FamilyRevision,
    template: str,
    output: str,
    board: Optional[str] = None,
    input_dir: Optional[str] = None,
) -> None:
    """Generate bootable image template with AHAB containers."""
    try:
        # Check if template exists
        available_templates = BootableImage.get_supported_templates(family)
        if not available_templates:
            raise SPSDKAppError(
                f"No templates available for family {family}. "
                "This family may not support template-based generation."
            )

        if template not in available_templates:
            raise SPSDKAppError(
                f"Template '{template}' not found for {family}. "
                f"Available templates: {', '.join(available_templates)}"
            )

        # Create output directory if it doesn't exist
        os.makedirs(output, exist_ok=True)

        # Generate template files
        generated_files = BootableImage.generate_extended_templates(
            family=family,
            template_name=template,
            output_dir=output,
            board=board,
            input_dir=input_dir,
        )

        # Print success message
        template_info = BootableImage.get_template_info(family, template)
        click.echo(f"\nTemplate '{template}' generated successfully!")
        click.echo(f"Description: {template_info.get('description', 'N/A')}")
        if board:
            click.echo(f"Board: {board}")
        if input_dir:
            click.echo(f"Input directory: {input_dir}")
        click.echo(f"\nGenerated files in {get_printable_path(output)}:")
        for file_path in generated_files:
            click.echo(f"  - {os.path.basename(file_path)}")

        click.echo(
            f"\nTo create the bootable image, run:\n"
            f"  nxpimage bootable-image export -c {os.path.join(output, 'bootable_image.yaml')}"
        )

    except SPSDKError as exc:
        raise SPSDKAppError(str(exc)) from exc


@bootable_image_group.command(name="list-boards", no_args_is_help=True)
@spsdk_family_option(families=BootableImage.get_supported_families())
def bootable_image_list_boards_command(family: FamilyRevision) -> None:
    """List available boards for a family."""
    bootable_image_list_boards(family)


def bootable_image_list_boards(family: FamilyRevision) -> None:
    """List available boards for a family."""
    boards = BootableImage.get_supported_boards(family)

    if not boards:
        click.echo(f"No boards defined for family {family}.")
        return

    click.echo(f"\nAvailable boards for {family}:\n")
    for board_name in boards:
        try:
            board_filenames = BootableImage.get_board_filenames(family, board_name)
            click.echo(f"  {board_name}:")
            for image_type, filename in board_filenames.items():
                click.echo(f"    {image_type}: {filename}")
            click.echo()
        except SPSDKError as exc:
            click.echo(f"  {board_name}: Error loading board info - {exc}")


@bootable_image_group.command(name="list-templates", no_args_is_help=True)
@spsdk_family_option(families=BootableImage.get_supported_families())
def bootable_image_list_templates_command(family: FamilyRevision) -> None:
    """List available bootable image templates for a family."""
    bootable_image_list_templates(family)


def bootable_image_list_templates(family: FamilyRevision) -> None:
    """List available bootable image templates for a family."""
    templates = BootableImage.get_supported_templates(family)

    if not templates:
        click.echo(f"No templates available for family {family}.")
        return

    click.echo(f"\nAvailable templates for {family}:\n")
    for template_name in templates:
        try:
            template_info = BootableImage.get_template_info(family, template_name)
            description = template_info.get("description", "No description")
            mem_type = template_info.get("mem_type", "N/A")
            configs = template_info.get("configs", [])

            click.echo(f"  {template_name}:")
            click.echo(f"    Description: {description}")
            click.echo(f"    Memory Type: {mem_type}")
            click.echo(f"    Configurations: {len(configs)}")

            for config in configs:
                config_name = config.get("name", "unnamed")
                config_type = config.get("type", "unknown")
                containers = config.get("containers", [])

                click.echo(f"      - {config_name} ({config_type}):")

                for container in containers:
                    container_name = container.get("name", "unnamed")

                    # Check if it's a binary container or regular container
                    if "path" in container:
                        # Binary container
                        path = container.get("path", "N/A")
                        click.echo(f"          * {container_name}: Binary container from '{path}'")
                    elif "images" in container:
                        # Regular container with images
                        images = container.get("images", [])
                        images_str = ", ".join(images) if images else "no images"
                        click.echo(f"          * {container_name}: [{images_str}]")
                    else:
                        click.echo(f"          * {container_name}: Unknown container type")

            click.echo()

        except SPSDKError as exc:
            click.echo(f"  {template_name}: Error loading template - {exc}")


@bootable_image_group.command(name="verify", no_args_is_help=True)
@spsdk_family_option(families=BootableImage.get_supported_families())
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary bootable image to verify.",
)
@click.option(
    "-m",
    "--mem-type",
    type=click.Choice(
        [mem_type.label for mem_type in BootableImage.get_supported_memory_types()],
        case_sensitive=False,
    ),
    required=True,
    help="Select the chip used memory type.",
)
@click.option(
    "-p",
    "--problems",
    is_flag=True,
    default=False,
    help="Show just problems in image.",
)
def bootable_image_verify_command(
    family: FamilyRevision, binary: str, problems: bool, mem_type: str
) -> None:
    """Verify Bootable Image."""
    bootable_image_verify(
        family=family, binary=binary, problems=problems, mem_type=MemoryType.from_label(mem_type)
    )


def bootable_image_verify(
    family: FamilyRevision, binary: str, problems: bool, mem_type: MemoryType
) -> None:
    """Verify Bootable Image."""
    data = load_binary(binary)

    preparsed = BootableImage.pre_parse_verify(data, family, mem_type)
    if preparsed.has_errors:
        click.echo("The image bases has error, it doesn't passed pre-parse check:")
        print_verifier_to_console(preparsed)
        raise SPSDKAppError("Pre-parsed check failed")

    bimg_images = []
    bimg_images = BootableImage._parse_all(data, family=family, mem_type=mem_type, no_errors=False)
    verifiers: list[Verifier] = []
    found_good_image = False
    for img in bimg_images:
        ver = img.verify()
        verifiers.append(ver)
        if not ver.has_errors:
            found_good_image = True

    if not found_good_image and len(bimg_images):
        click.echo(
            "The binary has errors for all memory targets! All memory targets attempts will be printed.",
            err=True,
        )
    for img, ver in zip(bimg_images, verifiers):
        # Print also the images with errors detected in case that neither one is good
        print_image = not ver.has_errors or (ver.has_errors and not found_good_image)
        if print_image:
            click.echo("\n" + "=" * 120)
            click.echo(f"The result for: {img.mem_type.label}".center(120))
            click.echo("=" * 120 + "\n")
            print_verifier_to_console(ver)

    if not found_good_image:
        raise SPSDKAppError("Verify failed")


@bootable_image_group.group(name="fcb", cls=CommandsTreeGroup)
def fcb() -> None:  # pylint: disable=unused-argument
    """FCB (Flash Configuration Block) utilities."""


@fcb.command(name="export", no_args_is_help=True)
@spsdk_config_option(klass=FCB)
@spsdk_output_option()
def fcb_export_command(config: Config, output: str) -> None:
    """Export FCB Image from YAML/JSON configuration.

    The configuration template files could be generated by subcommand 'get-templates'.
    """
    fcb_export(config, output)


def fcb_export(config: Config, output: str) -> None:
    """Export FCB Image from YAML/JSON configuration."""
    fcb_image = FCB.load_from_config(config)
    fcb_data = fcb_image.export()
    write_file(fcb_data, output, mode="wb")

    logger.info(f"Created FCB Image:\n{str(fcb_image.registers.image_info())}")
    logger.info(f"Created FCB Image memory map:\n{fcb_image.registers.image_info().draw()}")
    click.echo(f"Success. (FCB: {output} created.)")


def fcb_mem_type_callback(
    ctx: click.Context, param: click.Option, value: Optional[str]
) -> MemoryType:
    """Dynamically set memory type choices based on selected family."""
    family = FamilyRevision(ctx.params["family"], ctx.params.get("revision", "latest"))
    supported_mem_types = FCB.get_supported_memory_types(family)
    # If value is None and we need to provide a default, get the first supported memory type
    if value is None:
        return supported_mem_types[0]

    supported_labels = [mem_type.label for mem_type in supported_mem_types]
    if value not in supported_labels:
        supported_str = ", ".join(supported_labels)
        raise click.BadParameter(
            f"Memory type '{value}' is not supported for family {family.name}. "
            f"Supported types: {supported_str}"
        )

    return MemoryType.from_label(value)


@fcb.command(name="parse", no_args_is_help=True)
@spsdk_family_option(families=FCB.get_supported_families())
@click.option(
    "-m",
    "--mem-type",
    type=click.Choice(
        [mem_type.label for mem_type in FCB.get_supported_memory_types()], case_sensitive=False
    ),
    required=False,  # The callback will provide default if needed
    help="Select the chip used memory type.",
    callback=fcb_mem_type_callback,
)
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary FCB image to parse.",
)
@spsdk_output_option()
def fcb_parse_command(
    family: FamilyRevision, mem_type: MemoryType, binary: str, output: str
) -> None:
    """Parse FCB Image into YAML configuration."""
    fcb_parse(family, mem_type, binary, output)


def fcb_parse(family: FamilyRevision, mem_type: MemoryType, binary: str, output: str) -> None:
    """Parse FCB Image into YAML configuration."""
    fcb_image = FCB.parse(load_binary(binary), family=family, mem_type=mem_type)
    logger.info(f"Parsed FCB image memory map: {fcb_image.registers.image_info().draw()}")
    write_file(fcb_image.get_config_yaml(), output)
    click.echo(f"Success. (FCB: {binary} has been parsed and stored into {output} .)")


@fcb.command(name="get-templates", no_args_is_help=True)
@spsdk_family_option(families=FCB.get_supported_families())
@spsdk_output_option(directory=True, force=True)
def fcb_get_templates_command(family: FamilyRevision, output: str) -> None:
    """Create template of configurations in YAML format for all memory types.

    The template files folder name is specified as argument of this command.
    """
    fcb_get_templates(family, output)


def fcb_get_templates(family: FamilyRevision, output_folder: str) -> None:
    """Create template of configurations in YAML format for all memory types."""
    mem_types = FCB.get_supported_memory_types(family)
    for mem_type in mem_types:
        output = os.path.join(output_folder, f"fcb_{family.name}_{mem_type.label}.yaml")
        click.echo(f"Creating {output} template file.")
        write_file(FCB.get_config_template(family, mem_type), output)


@bootable_image_group.group(name="xmcd", cls=CommandsTreeGroup)
def xmcd() -> None:  # pylint: disable=unused-argument
    """XMCD (External Memory Configuration Data) utilities."""


@xmcd.command(name="export", no_args_is_help=True)
@spsdk_config_option(klass=XMCD)
@spsdk_output_option()
def xmcd_export_command(config: Config, output: str) -> None:
    """Export XMCD Image from YAML/JSON configuration.

    The configuration template files could be generated by subcommand 'get-templates'.
    """
    xmcd_export(config, output)


def xmcd_export(config: Config, output: str) -> None:
    """Export XMCD Image from YAML/JSON configuration."""
    xmcd_image = XMCD.load_from_config(config)
    try:
        xmcd_image.verify().validate()
    except SPSDKError as exc:
        logger.info(f"XMCD validation failed:\n {exc}")
        raise SPSDKAppError("Loading of XMCD from configuration failed.") from exc
    xmcd_data = xmcd_image.export()
    write_file(xmcd_data, output, mode="wb")

    logger.info(f"Created XMCD :\n{str(xmcd_image.registers.image_info())}")
    logger.info(f"Created XMCD memory map:\n{xmcd_image.registers.image_info().draw()}")
    click.echo(f"Success. (XMCD: {output} created.)")


@xmcd.command(name="parse", no_args_is_help=True)
@spsdk_family_option(families=XMCD.get_supported_families())
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary XMCD image to parse.",
)
@spsdk_output_option()
def xmcd_parse_command(family: FamilyRevision, binary: str, output: str) -> None:
    """Parse XMCD Image into YAML configuration."""
    xmcd_parse(family, binary, output)


def xmcd_parse(family: FamilyRevision, binary: str, output: str) -> None:
    """Parse XMCD Image into YAML configuration."""
    xmcd_image = XMCD.parse(load_binary(binary), family=family)
    ver = xmcd_image.verify()
    if ver.has_errors:
        logger.info(f"XMCD validation failed:\n {ver.draw()}")
        raise SPSDKAppError("Parsing of XMCD binary failed.")
    logger.info(f"Parsed XMCD: {xmcd_image.registers.image_info().draw()}")
    write_file(xmcd_image.get_config_yaml(), output)
    click.echo(f"Success. (XMCD: {binary} has been parsed and stored into {output} .)")


@xmcd.command(name="get-templates", no_args_is_help=True)
@spsdk_family_option(families=XMCD.get_supported_families())
@spsdk_output_option(directory=True, force=True)
def xmcd_get_templates_command(family: FamilyRevision, output: str) -> None:
    """Create template of configurations in YAML format for all memory types.

    The template files folder name is specified as argument of this command.
    """
    xmcd_get_templates(family, output)


def xmcd_get_templates(family: FamilyRevision, output: str) -> None:
    """Create template of configurations in YAML format for all memory types."""
    mem_types = XMCD.get_supported_memory_types(family)
    for mem_type in mem_types:
        config_types = XMCD.get_supported_configuration_types(family, mem_type)
        for config_type in config_types:
            output_file = os.path.join(
                output, f"xmcd_{family.name}_{mem_type.label}_{config_type.label}.yaml"
            )
            write_file(
                XMCD.get_config_template(
                    family,
                    mem_type,
                    config_type,
                ),
                output_file,
            )
            click.echo(f"The template file has been created: {get_printable_path(output_file)}.")


@xmcd.command(name="verify", no_args_is_help=True)
@spsdk_family_option(families=XMCD.get_supported_families())
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary XMCD image to parse.",
)
@click.option(
    "-p",
    "--problems",
    is_flag=True,
    default=False,
    help="Show just problems in image.",
)
def xmcd_verify_command(family: FamilyRevision, binary: str, problems: bool) -> None:
    """Verify XMCD Image."""
    xmcd_verify(family=family, binary=binary, problems=problems)


def xmcd_verify(family: FamilyRevision, binary: str, problems: bool) -> None:
    """Verify XMCD Image."""
    preparsed = XMCD.pre_parse_verify(load_binary(binary), family)
    if preparsed.has_errors:
        click.echo("The image bases has error, it doesn't passed pre-parse check:")
        print_verifier_to_console(preparsed, problems)
        raise SPSDKAppError("Pre-parsed check failed")
    xmcd_image = XMCD.parse(load_binary(binary), family=family)
    verifier = xmcd_image.verify()
    print_verifier_to_console(verifier, problems)
    if problems:
        raise SPSDKAppError("Pre-parsed check failed")
    click.echo(xmcd_image.registers.image_info().draw())


@xmcd.command(name="crc-fuses-script", no_args_is_help=True)
@spsdk_family_option(families=XMCD.get_supported_families())
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary XMCD image.",
)
@spsdk_output_option(required=True)
def xmcd_crc_fuses_script_command(family: FamilyRevision, binary: str, output: str) -> None:
    """Generate XMCD CRC fuses script.

    Programming the CRC checksum to the fuse enables the integrity check of XMCD block.
    """
    xmcd_block = XMCD.parse(load_binary(binary), family=family)
    fuses_script = xmcd_block.create_crc_hash_fuses_script()
    write_file(fuses_script, output)
    click.echo(f"Success. (Created fuses script: {output} )")


@bootable_image_group.group(name="wic", cls=CommandsTreeGroup)
def wic() -> None:  # pylint: disable=unused-argument
    """WIC (Whole Image Creator) Yocto Linux image format."""


@wic.command(name="update-uboot", no_args_is_help=True)
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary WIC image.",
)
@click.option(
    "-u",
    "--uboot",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary U-Boot image.",
)
def replace_uboot_command(binary: str, uboot: str) -> None:
    """Replace U-Boot binary in WIC file."""
    address = replace_uboot(binary, uboot)
    click.echo(f"Replaced u-boot at address {hex(address)}")
