# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401, F403, F405

import builtins
import enum
import typing
__all__ = [
    "A1",
    "A2",
    "A3",
    "A4",
    "A5",
    "A6",
    "A7",
    "A8",
    "B1",
    "B2",
    "B3",
    "B4",
    "B5",
    "B6",
    "B7",
    "B8",
    "BB_EMPTY",
    "BB_FILES",
    "BB_FILE_A",
    "BB_FILE_B",
    "BB_FILE_C",
    "BB_FILE_D",
    "BB_FILE_E",
    "BB_FILE_F",
    "BB_FILE_G",
    "BB_FILE_H",
    "BB_FULL",
    "BB_RANKS",
    "BB_RANK_1",
    "BB_RANK_2",
    "BB_RANK_3",
    "BB_RANK_4",
    "BB_RANK_5",
    "BB_RANK_6",
    "BB_RANK_7",
    "BB_RANK_8",
    "BISHOP",
    "BLACK",
    "BLACK_BISHOP",
    "BLACK_KING",
    "BLACK_KNIGHT",
    "BLACK_PAWN",
    "BLACK_QUEEN",
    "BLACK_ROOK",
    "Bitboard",
    "Board",
    "BoardStatus",
    "C1",
    "C2",
    "C3",
    "C4",
    "C5",
    "C6",
    "C7",
    "C8",
    "COLORS",
    "Color",
    "D1",
    "D2",
    "D3",
    "D4",
    "D5",
    "D6",
    "D7",
    "D8",
    "E1",
    "E2",
    "E3",
    "E4",
    "E5",
    "E6",
    "E7",
    "E8",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "G1",
    "G2",
    "G3",
    "G4",
    "G5",
    "G6",
    "G7",
    "G8",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "H7",
    "H8",
    "KING",
    "KNIGHT",
    "Move",
    "MoveGenerator",
    "PAWN",
    "PIECES",
    "PIECE_TYPES",
    "Piece",
    "PieceType",
    "QUEEN",
    "ROOK",
    "SQUARES",
    "Square",
    "WHITE",
    "WHITE_BISHOP",
    "WHITE_KING",
    "WHITE_KNIGHT",
    "WHITE_PAWN",
    "WHITE_QUEEN",
    "WHITE_ROOK",
]

A1: Square
A2: Square
A3: Square
A4: Square
A5: Square
A6: Square
A7: Square
A8: Square
B1: Square
B2: Square
B3: Square
B4: Square
B5: Square
B6: Square
B7: Square
B8: Square
BB_EMPTY: Bitboard
BB_FILES: builtins.list[Bitboard]
BB_FILE_A: Bitboard
BB_FILE_B: Bitboard
BB_FILE_C: Bitboard
BB_FILE_D: Bitboard
BB_FILE_E: Bitboard
BB_FILE_F: Bitboard
BB_FILE_G: Bitboard
BB_FILE_H: Bitboard
BB_FULL: Bitboard
BB_RANKS: builtins.list[Bitboard]
BB_RANK_1: Bitboard
BB_RANK_2: Bitboard
BB_RANK_3: Bitboard
BB_RANK_4: Bitboard
BB_RANK_5: Bitboard
BB_RANK_6: Bitboard
BB_RANK_7: Bitboard
BB_RANK_8: Bitboard
BISHOP: PieceType
BLACK: Color
BLACK_BISHOP: Piece
BLACK_KING: Piece
BLACK_KNIGHT: Piece
BLACK_PAWN: Piece
BLACK_QUEEN: Piece
BLACK_ROOK: Piece
C1: Square
C2: Square
C3: Square
C4: Square
C5: Square
C6: Square
C7: Square
C8: Square
COLORS: builtins.list[Color]
D1: Square
D2: Square
D3: Square
D4: Square
D5: Square
D6: Square
D7: Square
D8: Square
E1: Square
E2: Square
E3: Square
E4: Square
E5: Square
E6: Square
E7: Square
E8: Square
F1: Square
F2: Square
F3: Square
F4: Square
F5: Square
F6: Square
F7: Square
F8: Square
G1: Square
G2: Square
G3: Square
G4: Square
G5: Square
G6: Square
G7: Square
G8: Square
H1: Square
H2: Square
H3: Square
H4: Square
H5: Square
H6: Square
H7: Square
H8: Square
KING: PieceType
KNIGHT: PieceType
PAWN: PieceType
PIECES: builtins.list[Piece]
PIECE_TYPES: builtins.list[PieceType]
QUEEN: PieceType
ROOK: PieceType
SQUARES: builtins.list[Square]
WHITE: Color
WHITE_BISHOP: Piece
WHITE_KING: Piece
WHITE_KNIGHT: Piece
WHITE_PAWN: Piece
WHITE_QUEEN: Piece
WHITE_ROOK: Piece
@typing.final
class Bitboard:
    r"""
    Bitboard class.
    Represents a 64-bit unsigned integer.
    Each bit represents a square on the chessboard.
    The least-significant bit represents a1, and the most-significant bit represents h8.
    Supports bitwise operations and iteration.
    Also supports comparison and equality.
    """
    def __new__(cls, bitboard_or_square: typing.Any) -> Bitboard:
        r"""
        Create a new Bitboard from a 64-bit integer or a square
        """
    @staticmethod
    def from_square(square: Square) -> Bitboard:
        r"""
        Create a new Bitboard from a square.
        
        ```python
        >>> rust_chess.Bitboard.from_square(rust_chess.E4)
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    @staticmethod
    def from_uint(bitboard: builtins.int) -> Bitboard:
        r"""
        Create a new Bitboard from an unsigned 64-bit integer.
        
        ```python
        >>> rust_chess.Bitboard.from_uint(7)
        X X X . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def to_square(self) -> Square:
        r"""
        Convert the Bitboard to a square.
        This grabs the least-significant square.
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb.to_square()
        e4
        >>> rust_chess.Bitboard(2351).to_square()
        a1
        ```
        """
    def to_uint(self) -> builtins.int:
        r"""
        Convert the Bitboard to an unsigned 64-bit integer.
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb.to_uint()
        268435456
        ```
        """
    def __int__(self) -> builtins.int:
        r"""
        Convert the Bitboard to an integer.
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> int(bb)
        268435456
        ```
        """
    def get_string(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        
        ```python```
        >>> bb = rust_chess.Bitboard(16961066976411648)
        >>> for line in bb.get_string().split("\n"):
        ...     print(line)
        . . . . . . . .
        . . . . . . . .
        . . X . . X . .
        . . X . . X . .
        . . . . . . . .
        . X . . . . X .
        . . X X X X . .
        . . . . . . . .
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        
        ```python```
        >>> bb = rust_chess.Bitboard(18643319766908928)
        >>> print(bb)
        . . . . . . . .
        . . . . . . . .
        . . X . . X . .
        . . X . . X . .
        . . . . . . . .
        . . X X X X . .
        . X . . . . X .
        . . . . . . . .
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        
        ```python```
        >>> bb = rust_chess.Bitboard(35465847671881728)
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . X . . X . .
        . . X . . X . .
        . . . . . . . .
        . . . . . . . .
        . X X X X X X .
        . . . . . . . .
        """
    def popcnt(self) -> builtins.int:
        r"""
        Count the number of squares in the Bitboard
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb.popcnt()
        1
        >>> rust_chess.Bitboard(0).popcnt()
        0
        >>> rust_chess.Board().get_all_bitboard().popcnt()
        32
        ```
        """
    def flip_vertical(self) -> Bitboard:
        r"""
        Flip a bitboard vertically.
        View it from the opponent's perspective.
        Useful for operations that rely on symmetry, like piece-square tables.
        
        ```python
        >>> bb = rust_chess.Bitboard(6781892917204992)
        >>> bb
        . . . . . . . .
        . . . X X . . .
        . . X X X X . .
        . X X X X X X .
        . . . X X . . .
        . . . X X . . .
        . . . X X . . .
        . . . . . . . .
        >>> bb.flip_vertical()
        . . . . . . . .
        . . . X X . . .
        . . . X X . . .
        . . . X X . . .
        . X X X X X X .
        . . X X X X . .
        . . . X X . . .
        . . . . . . . .
        ```
        """
    def __iter__(self) -> Bitboard:
        r"""
        Return an iterator of the bitboard.
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> list(bb)
        [e4]
        >>> list(rust_chess.Bitboard(1025))
        [a1, c2]
        ```
        """
    def __next__(self) -> typing.Optional[Square]:
        r"""
        Get the next square in the Bitboard.
        Removes the square from the Bitboard.
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> next(bb)
        e4
        >>> next(bb)
        Traceback (most recent call last):
        Exception: message
        ```
        TODO: Next on bb with multiple squares
        """
    def __richcmp__(self, other: typing.Any, op: int) -> builtins.bool:
        r"""
        Rich comparison operations for the Bitboard type.
        
        ```python
        >>> bb_e4 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb_e4_2 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb_d4 = rust_chess.Bitboard.from_square(rust_chess.D4)
        >>> bb_a2 = rust_chess.Bitboard.from_square(rust_chess.A2)
        >>> bb_f4 = rust_chess.Bitboard.from_square(rust_chess.F4)
        # Equality (==)
        >>> bb_e4 == bb_e4_2
        True
        >>> bb_e4 == bb_e4.to_uint()
        True
        >>> bb_e4.to_uint() == bb_e4
        True
        # Inequality (!=)
        >>> bb_e4 != bb_d4
        True
        >>> bb_e4 != bb_e4
        False
        >>> bb_e4 != bb_e4.to_uint()
        False
        >>> bb_e4.to_uint() != bb_e4
        False
        # Less than (<)
        >>> bb_a2 < bb_f4
        True
        >>> bb_a2.to_uint() < bb_f4
        True
        >>> bb_a2 < bb_f4.to_uint()
        True
        # Less than or equal (<=)
        >>> bb_e4 <= bb_e4_2
        True
        >>> bb_e4.to_uint() <= bb_e4_2
        True
        >>> bb_e4 <= bb_e4_2.to_uint()
        True
        # Greater than (>)
        >>> bb_f4 > bb_a2
        True
        >>> bb_f4.to_uint() > bb_a2
        True
        >>> bb_f4 > bb_a2.to_uint()
        True
        # Greater than or equal (>=)
        >>> bb_e4 >= bb_e4_2
        True
        >>> bb_e4.to_uint() >= bb_e4_2
        True
        >>> bb_e4 >= bb_e4_2.to_uint()
        True
        ```
        """
    def __invert__(self) -> Bitboard:
        r"""
        Bitwise NOT operation (~self).
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> ~bb
        X X X X X X X X
        X X X X X X X X
        X X X X X X X X
        X X X X . X X X
        X X X X X X X X
        X X X X X X X X
        X X X X X X X X
        X X X X X X X X
        ```
        """
    def __and__(self, other: typing.Any) -> Bitboard:
        r"""
        Bitwise AND operation (self & other).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.B2)
        >>> bb1 & bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> (bb1 & bb1) == (bb1 & bb1.to_uint())
        True
        >>> (bb1 & bb2).popcnt() == 0
        True
        >>> (bb1 & bb2) == (bb1 & bb2.to_uint())
        True
        ```
        """
    def __rand__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected bitwise AND operation (other & self).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.B2)
        >>> bb1 & bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> (bb1 & bb1) == (bb1.to_uint() & bb1)
        True
        >>> (bb2 & bb1).popcnt() == 0
        True
        >>> (bb2 & bb1) == (bb2.to_uint() & bb1)
        True
        ```
        """
    def __iand__(self, other: typing.Any) -> None:
        r"""
        In-place bitwise AND operation (self &= other).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.B2)
        >>> bb1 &= bb1
        >>> bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb1 &= bb1.to_uint()
        >>> bb1 == rust_chess.Bitboard.from_square(rust_chess.E4)
        True
        >>> bb1 &= bb2
        >>> bb1.popcnt() == 0
        True
        ```
        """
    def __or__(self, other: typing.Any) -> Bitboard:
        r"""
        Bitwise OR operation (self | other).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.D4)
        >>> bb1 | bb2
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . X X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> (bb1 | bb2) == (bb1 | bb2.to_uint())
        True
        ```
        """
    def __ror__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected bitwise OR operation (other | self).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.D4)
        >>> bb2 | bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . X X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> (bb2 | bb1) == (bb2.to_uint() | bb1)
        True
        ```
        """
    def __ior__(self, other: typing.Any) -> None:
        r"""
        In-place bitwise OR operation (self |= other).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.D4)
        >>> bb1 |= bb2
        >>> bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . X X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb1 |= bb2.to_uint()
        >>> bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . X X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def __xor__(self, other: typing.Any) -> Bitboard:
        r"""
        Bitwise XOR operation (self ^ other).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.B2)
        >>> bb1 ^ bb2
        . . . . . . . .
        . X . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> (bb1 ^ bb2) == (bb1 ^ bb2.to_uint())
        True
        ```
        """
    def __rxor__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected bitwise XOR operation (other ^ self).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.B2)
        >>> bb2 ^ bb1
        . . . . . . . .
        . X . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> (bb2 ^ bb1) == (bb2.to_uint() ^ bb1)
        True
        ```
        """
    def __ixor__(self, other: typing.Any) -> None:
        r"""
        In-place bitwise XOR operation (self ^= other).
        
        ```python
        >>> bb1 = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb2 = rust_chess.Bitboard.from_square(rust_chess.B2)
        >>> bb1 ^= bb2
        >>> bb1
        . . . . . . . .
        . X . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb1 ^= bb2.to_uint()
        >>> bb1
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def __lshift__(self, shift: builtins.int) -> Bitboard:
        r"""
        Left shift operation (self << shift).
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb << 2
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . X .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def __ilshift__(self, shift: builtins.int) -> None:
        r"""
        In-place left shift operation (self <<= shift).
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb <<= 2
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . X .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def __rshift__(self, shift: builtins.int) -> Bitboard:
        r"""
        Right shift operation (self >> shift).
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb >> 2
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . X . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def __irshift__(self, shift: builtins.int) -> None:
        r"""
        In-place right shift operation (self >>= shift).
        
        ```python
        >>> bb = rust_chess.Bitboard.from_square(rust_chess.E4)
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        >>> bb >>= 2
        >>> bb
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . X . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """

@typing.final
class Board:
    r"""
    Board class.
    Represents the state of a chess board.
    """
    @property
    def halfmove_clock(self) -> builtins.int:
        r"""
        Get the halfmove clock.
        
        ```python
        >>> rust_chess.Board().halfmove_clock
        0
        ```
        """
    @property
    def fullmove_number(self) -> builtins.int:
        r"""
        Get the fullmove number.
        
        ```python
        >>> rust_chess.Board().fullmove_number
        1
        ```
        """
    @property
    def turn(self) -> Color:
        r"""
        Get the current player to move.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.turn
        True
        >>> print(board.turn)
        WHITE
        
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.turn
        False
        >>> print(board.turn)
        BLACK
        ```
        """
    @property
    def en_passant(self) -> typing.Optional[Square]:
        r"""
        Get the en passant square, otherwise None.
        
        ```python
        >>> rust_chess.Board().en_passant
        
        >>> rust_chess.Board().en_passant == None
        True
        
        >>> board = rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4")
        >>> board.en_passant
        f6
        ```
        """
    def __new__(cls, fen: typing.Optional[builtins.str] = None) -> Board:
        r"""
        Create a new board from a FEN string, otherwise default to the starting position.
        
        ```python
        >>> rust_chess.Board()
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        >>> rust_chess.Board("rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2")
        rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2
        ```
        """
    def get_fen(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> rust_chess.Board().get_fen()
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> print(rust_chess.Board())
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> print(rust_chess.Board())
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    @staticmethod
    def from_fen(fen: builtins.str) -> Board:
        r"""
        Create a new board from a FEN string.
        
        ```python
        >>> rust_chess.Board.from_fen("rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2")
        rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2
        ```
        """
    def is_en_passant(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if a move is en passant.
        
        Assumes the move is legal.
        
        ```python
        >>> rust_chess.Board().is_en_passant(rust_chess.Move("e2e4"))
        False
        
        >>> board = rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4")
        >>> board.is_en_passant(rust_chess.Move("e5f6"))
        True
        ```
        """
    def is_capture(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if a move is a capture.
        
        Assumes the move is legal.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.is_capture(rust_chess.Move("e2e4"))
        False
        >>> board.make_move(rust_chess.Move("e2e4"))
        
        >>> board.make_move(rust_chess.Move("d7d5"))
        >>> board.is_capture(rust_chess.Move("e4d5"))
        True
        
        >>> ep_board = rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4")
        >>> ep_board.is_capture(rust_chess.Move("e5f6"))
        True
        ```
        """
    def get_piece_type_on(self, square: Square) -> typing.Optional[PieceType]:
        r"""
        Get the piece type on a square, otherwise None.
        Different than `get_piece_on` because it returns the piece type, which does not include color.
        
        ```python
        >>> rust_chess.Board().get_piece_type_on(rust_chess.A1)
        R
        >>> rust_chess.Board().get_piece_type_on(rust_chess.E8)
        K
        ```
        """
    def get_color_on(self, square: Square) -> typing.Optional[Color]:
        r"""
        Get the color of the piece on a square, otherwise None.
        
        ```python
        >>> rust_chess.Board().get_color_on(rust_chess.A1)
        True
        >>> print(rust_chess.Board().get_color_on(rust_chess.A1))
        WHITE
        >>> rust_chess.Board().get_color_on(rust_chess.E8)
        False
        >>> print(rust_chess.Board().get_color_on(rust_chess.E8))
        BLACK
        ```
        """
    def get_piece_on(self, square: Square) -> typing.Optional[Piece]:
        r"""
        Get the piece on a square (color-inclusive), otherwise None.
        Different than `get_piece_on` because it returns the piece, which includes color.
        
        ```python
        >>> rust_chess.Board().get_piece_on(rust_chess.A1)
        R
        >>> rust_chess.Board().get_piece_on(rust_chess.E8)
        k
        ```
        """
    def get_king_square(self, color: Color) -> Square:
        r"""
        Get the king square of a color
        
        ```python
        >>> rust_chess.Board().get_king_square(rust_chess.WHITE)
        e1
        >>> rust_chess.Board().get_king_square(rust_chess.BLACK)
        e8
        ```
        """
    def is_zeroing(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if a move is a capture or a pawn move.
        "Zeros" the halfmove clock (sets it to 0).
        
        Doesn't check legality.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.is_zeroing(rust_chess.Move("e2e4"))
        True
        >>> board.make_move(rust_chess.Move("e2e4"))
        
        >>> board.is_zeroing(rust_chess.Move("g8f6"))
        False
        >>> board.make_move(rust_chess.Move("d7d5"))
        
        >>> board.is_zeroing(rust_chess.Move("e4d5"))
        True
        ```
        """
    def is_legal_move(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if the move is legal (supposedly very slow according to the chess crate).
        Use this function for moves not generated by the move generator.
        `is_legal_quick` is faster for moves generated by the move generator.
        
        ```python
        >>> move = rust_chess.Move("e2e4")
        >>> rust_chess.Board().is_legal_move(move)
        True
        >>> ill_move = rust_chess.Move("e2e5")
        >>> rust_chess.Board().is_legal_move(ill_move)
        False
        ```
        """
    def is_legal_generator_move(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if the move generated by the generator is legal.
        Only use this function for moves generated by the move generator.
        You would want to use this when you have a psuedo-legal move (guarenteed by the generator).
        Slightly faster than using `is_legal_move` since it doesn't have to check as much stuff.
        
        ```python
        >>> board = rust_chess.Board()
        >>>
        ```
        """
    def make_null_move_new(self) -> typing.Optional[Board]:
        r"""
        Make a null move onto a new board.
        Returns None if the current player is in check.
        
        ```python
        >>> board = rust_chess.Board()
        >>> print(board)
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        >>> new_board = board.make_null_move_new()
        >>> print(new_board)
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR b KQkq - 1 1
        
        >>> board = rust_chess.Board("rnbqkbnr/ppppp1pp/5p2/7Q/8/4P3/PPPP1PPP/RNB1KBNR b KQkq - 1 2")
        >>> new_board = board.make_null_move_new()
        >>> print(new_board)
        None
        ```
        """
    def make_move(self, chess_move: Move, check_legality: builtins.bool = True) -> None:
        r"""
        Make a move onto the current board.
        
        Defaults to checking move legality, unless the optional legality parameter is `False`.
        Not checking move legality will provide a slight performance boost, but crash if the move is invalid.
        Checking legality will return an error if the move is illegal.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> print(board)
        rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1
        ```
        """
    def make_move_new(self, chess_move: Move, check_legality: builtins.bool = True) -> Board:
        r"""
        Make a move onto a new board.
        
        Defaults to checking move legality, unless the optional legality parameter is `False`.
        Not checking move legality will provide a slight performance boost, but crash if the move is invalid.
        Checking legality will return an error if the move is illegal.
        
        ```python
        >>> old_board = rust_chess.Board()
        >>> new_board = old_board.make_move_new(rust_chess.Move("e2e4"))
        >>> print(new_board)
        rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1
        >>> print(old_board)
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    def get_pinned_bitboard(self) -> Bitboard:
        r"""
        Get the bitboard of the side to move's pinned pieces.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.get_pinned_bitboard().popcnt()
        0
        
        board.make_move(rust_chess.Move("e2e4"))
        board.make_move(rust_chess.Move("d7d5"))
        board.make_move(rust_chess.Move("d1h5"))
        FIXME
        >>> board.get_pinned_bitboard().popcnt()
        1
        >>> board.get_pinned_bitboard()
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . X . .
        . . . . . . . .
        ```
        """
    def get_checkers_bitboard(self) -> Bitboard:
        r"""
        Get the bitboard of the pieces putting the side to move in check.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.get_checkers_bitboard().popcnt()
        0
        
        board.make_move(rust_chess.Move("e2e4"))
        board.make_move(rust_chess.Move("f2f3"))
        board.make_move(rust_chess.Move("d1h5"))
        FIXME
        >>> board.get_checkers_bitboard().popcnt()
        1
        >>> board.get_checkers_bitboard()
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . X
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def get_color_bitboard(self, color: Color) -> Bitboard:
        r"""
        Get the bitboard of all the pieces of a certain color.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.get_color_bitboard(rust_chess.WHITE).popcnt()
        16
        >>> board.get_color_bitboard(rust_chess.WHITE)
        X X X X X X X X
        X X X X . X X X
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def get_piece_type_bitboard(self, piece_type: PieceType) -> Bitboard:
        r"""
        Get the bitboard of all the pieces of a certain type.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.get_piece_type_bitboard(rust_chess.PAWN).popcnt()
        16
        >>> board.get_piece_type_bitboard(rust_chess.PAWN)
        . . . . . . . .
        X X X X . X X X
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        X X X X X X X X
        . . . . . . . .
        ```
        """
    def get_piece_bitboard(self, piece: Piece) -> Bitboard:
        r"""
        Get the bitboard of all the pieces of a certain color and type.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.get_piece_bitboard(rust_chess.WHITE_PAWN).popcnt()
        8
        >>> board.get_piece_bitboard(rust_chess.WHITE_PAWN)
        . . . . . . . .
        X X X X . X X X
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    def get_all_bitboard(self) -> Bitboard:
        r"""
        Get the bitboard of all the pieces.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.get_all_bitboard().popcnt()
        32
        >>> board.get_all_bitboard()
        X X X X X X X X
        X X X X . X X X
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        X X X X X X X X
        X X X X X X X X
        ```
        """
    def get_generator_num_remaining(self) -> builtins.int:
        r"""
        Get the number of moves remaining in the move generator.
        This is the number of remaining moves that can be generated.
        Does not consume any iterations.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.get_generator_num_remaining()
        20
        >>> next(board.generate_legal_moves())
        Move(a2, a3, None)
        >>> board.get_generator_num_remaining()
        19
        ```
        """
    def reset_move_generator(self) -> None:
        r"""
        Reset the move generator for the current board.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_legal_moves())
        20
        >>> list(board.generate_legal_moves())
        [Move(a2, a3, None), Move(a2, a4, None), ..., Move(g1, h3, None)]
        >>> len(board.generate_legal_moves())
        0
        >>> board.reset_move_generator()
        >>> len(board.generate_legal_moves())
        20
        ```
        """
    def remove_generator_move(self, chess_move: Move) -> None:
        r"""
        Remove a move from the move generator.
        Prevents the move from being generated.
        Updates the generator mask to exclude the move.
        Useful if you already have a certain move and don't need to generate it again.
        
        **WARNING**: using any form of `legal_move` or `legal_capture` generation
        will set the generator mask, invalidating any previous removals by this function.
        This also applies to setting the generator mask manually.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_moves())  # Legal moves by default
        20
        >>> move = rust_chess.Move("a2a3")
        >>> board.remove_generator_move(move)
        >>> len(board.generate_moves())
        19
        >>> move in board.generate_moves()  # Consumes generator moves
        False
        >>> len(board.generate_moves())
        0
        ```
        """
    def set_generator_mask(self, mask: Bitboard) -> None:
        r"""
        Sets the generator mask for the move generator.
        The mask is a bitboard that indicates what landing squares to generate moves for.
        Only squares in the mask will be considered when generating moves.
        See `remove_generator_mask` for the inverse (never generate bitboard moves).
        
        Moves that have already been iterated over will not be generated again, regardless of the mask value.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_moves())
        20
        >>> board.set_generator_mask(rust_chess.E4.to_bitboard())
        >>> len(board.generate_moves())
        1
        >>> board.generate_next_move()
        Move(e2, e4, None)
        ```
        """
    def remove_generator_mask(self, mask: Bitboard) -> None:
        r"""
        Removes the generator mask from the move generator.
        The mask is a bitboard that indicates what landing squares *not* to generate moves for.
        Only squares not in the mask will be considered when generating moves.
        See `set_generator_mask` for the inverse (only generate bitboard moves).
        
        You can remove moves, and then generate over all legal moves for example without regenerating the removed moves.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_moves())
        20
        >>> board.remove_generator_mask(rust_chess.E4.to_bitboard())
        >>> len(board.generate_moves())
        19
        >>> rust_chess.Move("e2e4") in board.generate_moves()
        False
        >>> len(board.generate_moves())
        0
        ```
        """
    def generate_next_move(self) -> typing.Optional[Move]:
        r"""
        Get the next remaining move in the generator.
        Updates the move generator to the next move.
        
        Unless the mask has been set, this will return the next legal move by default.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_moves())
        20
        >>> board.remove_generator_move(rust_chess.Move("a2a3"))
        >>> len(board.generate_moves())
        19
        >>> board.generate_next_move()
        Move(a2, a4, None)
        >>> len(board.generate_moves())
        18
        ```
        """
    def generate_next_legal_move(self) -> typing.Optional[Move]:
        r"""
        Get the next remaining legal move in the generator.
        Updates the move generator to the next legal move.
        
        Updates the generator mask to all legal moves.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_legal_moves())
        20
        >>> board.generate_next_legal_move()
        Move(a2, a3, None)
        >>> len(board.generate_legal_moves())
        19
        ```
        """
    def generate_next_legal_capture(self) -> typing.Optional[Move]:
        r"""
        Get the next remaining legal capture in the generator.
        Updates the move generator to the next move.
        
        Updates the generator mask to the enemy's squares (all legal captures).
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.make_move(rust_chess.Move("d7d5"))
        >>> len(board.generate_legal_moves())
        31
        >>> len(board.generate_legal_captures())
        1
        >>> board.generate_next_legal_capture()
        Move(e4, d5, None)
        >>> len(board.generate_legal_captures())
        0
        ```
        """
    def generate_moves(self) -> MoveGenerator:
        r"""
        Generate the next remaining moves for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        
        Unless the generator mask is set, this will generate the next legal moves by default.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_moves())
        20
        >>> board.set_generator_mask(rust_chess.Bitboard(11063835754496))
        >>> len(board.generate_moves())
        3
        >>> list(board.generate_moves())
        [Move(b2, b3, None), Move(d2, d3, None), Move(e2, e4, None)]
        >>> len(board.generate_moves())
        0
        ```
        """
    def generate_legal_moves(self) -> MoveGenerator:
        r"""
        Generate the next remaining legal moves for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        
        Will not iterate over the same moves already generated by `generate_legal_captures`.
        
        ```python
        >>> board = rust_chess.Board()
        >>> len(board.generate_legal_moves())
        20
        >>> list(board.generate_legal_moves())
        [Move(a2, a3, None), Move(a2, a4, None), ..., Move(g1, h3, None)]
        >>> len(board.generate_legal_moves())
        0
        >>> board.reset_move_generator()
        >>> len(board.generate_legal_moves())
        20
        ```
        """
    def generate_legal_captures(self) -> MoveGenerator:
        r"""
        Generate the next remaining legal captures for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        
        Can iterate over legal captures first and then legal moves without any duplicated moves.
        Useful for move ordering, in case you want to check captures first before generating other moves.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.make_move(rust_chess.Move("d7d5"))
        >>> len(board.generate_legal_moves())
        31
        >>> len(board.generate_legal_captures())
        1
        >>> next(board.generate_legal_captures())
        Move(e4, d5, None)
        >>> len(board.generate_legal_moves())
        30
        >>> len(board.generate_legal_captures())
        0
        ```
        """
    def is_fifty_moves(self) -> builtins.bool:
        r"""
        Checks if the halfmoves since the last pawn move or capture is >= 100
        and the game is ongoing (not checkmate or stalemate).
        
        This is a claimable draw according to FIDE rules.
        
        ```python
        >>> rust_chess.Board().is_fifty_moves()
        False
        >>> rust_chess.Board("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 100 1").is_fifty_moves()
        True
        ```
        """
    def is_seventy_five_moves(self) -> builtins.bool:
        r"""
        Checks if the halfmoves since the last pawn move or capture is >= 150
        and the game is ongoing (not checkmate or stalemate).
        
        This is an automatic draw according to FIDE rules.
        
        ```python
        >>> rust_chess.Board().is_seventy_five_moves()
        False
        >>> rust_chess.Board("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 150 1").is_seventy_five_moves()
        True
        ```
        """
    def is_insufficient_material(self) -> builtins.bool:
        r"""
        Checks if the side to move has insufficient material to checkmate the opponent.
        The cases where this is true are:
            1. K vs K
            2. K vs K + N
            3. K vs K + B
            4. K + B vs K + B with the bishops on the same color.
        
        ```python
        >>> rust_chess.Board().is_insufficient_material()
        False
        >>> rust_chess.Board("4k3/8/8/8/8/8/8/4K3 w - - 0 1").is_insufficient_material() # K vs K
        True
        >>> rust_chess.Board("4k3/8/8/8/5N2/8/8/4K3 w - - 0 1").is_insufficient_material() # K vs K + N
        True
        >>> rust_chess.Board("4k3/8/8/8/5B2/8/8/4K3 w - - 0 1").is_insufficient_material() # K vs K + B
        True
        >>> rust_chess.Board("4k3/8/8/5b2/5B2/8/8/4K3 w - - 0 1").is_insufficient_material() # K + B vs K + B different color
        False
        >>> rust_chess.Board("4k3/8/5b2/8/5B2/8/8/4K3 w - - 0 1").is_insufficient_material() # K + B vs K + B same color
        True
        ```
        """
    def is_threefold_repetition(self) -> builtins.bool:
        r"""
        Checks if the game is in a threefold repetition.
        
        This is a claimable draw according to FIDE rules.
        TODO: Currently not implementable due to no storage of past moves
        """
    def is_fivefold_repetition(self) -> builtins.bool:
        r"""
        Checks if the game is in a fivefold repetition.
        
        This is an automatic draw according to FIDE rules.
        TODO: Currently not implementable due to no storage of past moves
        """
    def is_check(self) -> builtins.bool:
        r"""
        Checks if the side to move is in check.
        
        ```python
        >>> rust_chess.Board().is_check()
        False
        >>> rust_chess.Board("rnb1kbnr/pppp1ppp/4p3/8/6Pq/5P2/PPPPP2P/RNBQKBNR w KQkq - 1 3").is_check()
        True
        ```
        """
    def is_stalemate(self) -> builtins.bool:
        r"""
        Checks if the side to move is in stalemate
        
        ```python
        >>> rust_chess.Board().is_stalemate()
        False
        ```
        TODO
        """
    def is_checkmate(self) -> builtins.bool:
        r"""
        Checks if the side to move is in checkmate
        
        ```python
        >>> rust_chess.Board().is_checkmate()
        False
        ```
        TODO
        """
    def get_status(self) -> BoardStatus:
        r"""
        Get the status of the board (ongoing, draw, or game-ending).
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.get_status()
        BoardStatus.ONGOING
        ```
        TODO
        """

@typing.final
class Color:
    r"""
    Color enum class.
    White is True, Black is False.
    
    ```python
    >>> color = rust_chess.WHITE
    
    >>> color
    True
    >>> print(color)
    WHITE
    >>> color == rust_chess.BLACK
    False
    >>> color == (not rust_chess.BLACK)
    True
    ```
    """
    def get_string(self) -> builtins.str:
        r"""
        Get the color as a string.
        
        ```python
        >>> rust_chess.WHITE.get_string()
        'WHITE'
        >>> rust_chess.BLACK.get_string()
        'BLACK'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the color as a string.
        
        ```python
        >>> print(rust_chess.WHITE)
        WHITE
        >>> print(rust_chess.BLACK)
        BLACK
        ```
        """
    def __bool__(self) -> builtins.bool:
        r"""
        Get the color as a boolean.
        
        ```python
        >>> bool(rust_chess.WHITE)
        True
        >>> bool(rust_chess.BLACK)
        False
        ```
        """
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str:
        r"""
        Get the color as a boolean string.
        
        ```python
        >>> rust_chess.WHITE
        True
        >>> rust_chess.BLACK
        False
        ```
        """
    def __richcmp__(self, other: typing.Any, op: int) -> builtins.bool:
        r"""
        Rich comparison operations for Color.
        
        Equality (==):
        ```python
        >>> rust_chess.WHITE == rust_chess.WHITE
        True
        >>> rust_chess.WHITE == True
        True
        >>> True == rust_chess.WHITE
        True
        ```
        
        Inequality (!=):
        ```python
        >>> rust_chess.WHITE != rust_chess.BLACK
        True
        >>> rust_chess.WHITE != False
        True
        >>> rust_chess.WHITE != True
        False
        >>> False != rust_chess.WHITE
        True
        >>> True != rust_chess.WHITE
        False
        ```
        """

@typing.final
class Move:
    r"""
    Move class.
    Represents a chess move.
    The move is represented as a source square, destination square, and optional promotion piece.
    
    ```python
    >>> move = rust_chess.Move(rust_chess.A4, rust_chess.B1)
    >>> move
    Move(a4, b1, None)
    >>> print(move)
    a4b1
    >>> rust_chess.Move("a2a1q")
    Move(a2, a1, Q)
    >>> move == rust_chess.Move.from_uci("a4b1")
    True
    >>> move.source
    a4
    >>> move.dest
    b1
    >>> move.promotion
    
    >>> move.promotion == None
    True
    ```
    """
    @property
    def source(self) -> Square:
        r"""
        Get the source square of the move.
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.source
        a2
        ```
        """
    @property
    def dest(self) -> Square:
        r"""
        Get the destination square of the move.
        
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.dest
        a4
        ```
        """
    @property
    def promotion(self) -> typing.Optional[PieceType]:
        r"""
        Get the promotion piece of the move, otherwise None.
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.promotion
        
        >>> move.promotion == None
        True
        >>> move = rust_chess.Move("g2g1q")
        >>> move.promotion
        Q
        ```
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, source_or_uci: typing.Any, dest: typing.Optional[Square] = None, promotion: typing.Optional[PieceType] = None) -> Move:
        r"""
        Create a new move from a source, destination, and optional promotion piece or UCI string.
        
        ```python
        >>> rust_chess.Move(rust_chess.A2, rust_chess.A4)
        Move(a2, a4, None)
        >>> rust_chess.Move("g2g1q")
        Move(g2, g1, Q)
        ```
        """
    @staticmethod
    def from_uci(uci: builtins.str) -> Move:
        r"""
        Create a new move from a UCI string (e.g. "e2e4").
        
        ```python
        >>> rust_chess.Move.from_uci("e2e4")
        Move(e2, e4, None)
        ```
        """
    def get_uci(self) -> builtins.str:
        r"""
        Get the UCI string representation of the move (e.g. "e2e4").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.get_uci()
        'a2a4'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the UCI string representation of the move (e.g. "e2e4").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> print(move)
        a2a4
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the internal representation of the move (e.g. "Move(e2, e4, None)").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.E2, rust_chess.E4)
        >>> move
        Move(e2, e4, None)
        ```
        """

@typing.final
class MoveGenerator:
    r"""
    Move iterator class for generating legal moves.
    Not intended for direct use.
    Use the `Board` class methods for generating moves.
    """
    def __iter__(self) -> MoveGenerator:
        r"""
        Return an iterator of the generator.
        
        The generator for a board saves state, regardless of how it is called.
        
        ```python
        >>> board = rust_chess.Board()
        >>> list(board.generate_legal_moves())
        [Move(a2, a3, None), Move(a2, a4, None), ..., Move(g1, h3, None)]
        >>> list(board.generate_legal_moves())
        []
        ```
        """
    def __next__(self) -> typing.Optional[Move]:
        r"""
        Get the next move in the generator.
        
        The generator for a board saves state, regardless of how it is called.
        
        ```python
        >>> board = rust_chess.Board()
        >>> moves = board.generate_legal_moves()
        >>> next(moves)
        Move(a2, a3, None)
        >>> next(board.generate_legal_moves())
        Move(a2, a4, None)
        ```
        """
    def __len__(self) -> builtins.int:
        r"""
        Get the length of the generator.
        
        Does not consume any iterations.
        
        ```python
        >>> board = rust_chess.Board()
        >>> moves = board.generate_legal_moves()
        >>> len(moves)
        20
        >>> next(moves)
        Move(a2, a3, None)
        >>> len(moves)
        19
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the type of the move generator.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.generate_legal_moves()
        MoveGenerator()
        ```
        """

@typing.final
class Piece:
    r"""
    Piece class.
    Represents a chess piece with a type and color.
    Uses the PieceType and Color classes.
    Supports comparison and equality.
    A white piece is considered less than a black piece of the same type.
    
    ```python
    >>> piece = rust_chess.WHITE_PAWN
    >>> piece
    P
    >>> piece.piece_type
    P
    >>> piece.color
    True
    ```
    TODO
    """
    @property
    def piece_type(self) -> PieceType:
        r"""
        Get the piece type of the piece
        TODO
        """
    @property
    def color(self) -> Color:
        r"""
        Get the color of the piece
        TODO
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, piece_type: PieceType, color_or_bool: typing.Any) -> Piece:
        r"""
        Create a new piece from a piece type and color
        """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the piece (0-5)
        """
    def get_string(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        White is uppercase and black is lowercase.
        
        ```python
        >>> rust_chess.WHITE_PAWN.get_string()
        'P'
        >>> rust_chess.BLACK_PAWN.get_string()
        'p'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        White is uppercase and black is lowercase.
        
        ```python
        >>> print(rust_chess.WHITE_PAWN)
        P
        >>> print(rust_chess.BLACK_PAWN)
        p
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        White is uppercase and black is lowercase.
        
        ```python
        >>> rust_chess.WHITE_PAWN
        P
        >>> rust_chess.BLACK_PAWN
        p
        ```
        """
    def get_unicode(self) -> builtins.str:
        r"""
        Convert the piece to a unicode string.
        White is hollow and black is full.
        
        ```python
        >>> rust_chess.WHITE_PAWN.get_unicode()
        ''
        >>> rust_chess.BLACK_PAWN.get_unicode()
        ''
        ```
        """

@typing.final
class PieceType:
    r"""
    Piece type enum class.
    Represents the different types of chess pieces.
    Indexing starts at 0 (PAWN) and ends at 5 (KING).
    Supports comparison and equality.
    Does not include color.
    
    `rust_chess` has constants for each piece type (e.g. PAWN, KNIGHT, etc.).
    
    ```python
    >>> piece = rust_chess.PAWN
    
    >>> print(piece)
    P
    >>> piece == rust_chess.PAWN
    True
    >>> piece == rust_chess.KNIGHT
    False
    >>> piece.get_index()
    0
    >>> piece < rust_chess.KNIGHT
    True
    ```
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the piece.
        Ranges from 0 (PAWN) to 5 (KING).
        
        ```python
        >>> rust_chess.BISHOP.get_index()
        2
        ```
        """
    def __index__(self) -> builtins.int:
        r"""
        Allow the piece type to be used as an index.
        Returns the index of the piece.
        
        ```python
        >>> arr = [1, 2, 3, 4, 5, 6]
        >>> arr[rust_chess.BISHOP]
        3
        ```
        """
    def get_string(self, color: Color = True) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter by default.
        If using the optional color parameter, white is uppercase and black is lowercase.
        
        ```python
        >>> rust_chess.PAWN.get_string()
        'P'
        >>> rust_chess.PAWN.get_string(rust_chess.BLACK)
        'p'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> print(rust_chess.PAWN)
        P
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> rust_chess.PAWN
        P
        ```
        """
    def get_unicode(self, color: Color = True) -> builtins.str:
        r"""
        Convert the piece to a unicode string.
        Returns the hollow unicode piece by default.
        If using the optional color parameter, white is hollow and black is full.
        
        ```python
        >>> rust_chess.PAWN.get_unicode()
        ''
        >>> rust_chess.PAWN.get_unicode(rust_chess.BLACK)
        ''
        ```
        """

@typing.final
class Square:
    r"""
    Square class.
    Represents a square on the chessboard.
    The square is represented as an integer (0-63) or a string (e.g. "e4").
    Supports comparison and equality.
    
    rust-chess has constants for each square (e.g. A1, B2, etc.).
    
    ```python
    >>> square = rust_chess.Square(0)
    >>> square
    a1
    >>> print(square)
    a1
    >>> square == rust_chess.Square("a1")
    True
    >>> square == rust_chess.A1
    True
    >>> square.get_index()
    0
    >>> rust_chess.A4 == 24
    True
    >>> rust_chess.G4.get_rank()
    3
    >>> rust_chess.G4.get_file()
    6
    TODO
    ```
    """
    def __new__(cls, square_index_or_name: typing.Any) -> Square:
        r"""
        Creates a new square from an integer (0-63) or a string (e.g. "e4").
        
        ```python
        >>> rust_chess.Square(0)
        a1
        >>> rust_chess.Square("e4")
        e4
        ```
        """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the square (0-63).
        Indexing starts at 0 (a1) and ends at 63 (h8).
        
        ```python
        >>> rust_chess.Square("e4").get_index()
        28
        ```
        """
    def __index__(self) -> builtins.int:
        r"""
        Get the index of the square as an integer for indexing.
        
        ```python
        >>> int(rust_chess.Square("e4"))
        28
        ```
        """
    def __int__(self) -> builtins.int:
        r"""
        Get the index of the square as an integer.
        
        ```python
        >>> arr = [1, 2, 3, 4, 5, 6]
        >>> arr[rust_chess.Square("a1")]
        1
        ```
        """
    def __hash__(self) -> builtins.int:
        r"""
        Hash the square based on its index.
        
        ```python
        >>> hash(rust_chess.E4)
        28
        ```
        """
    def flip(self) -> Square:
        r"""
        Flips a square (eg. A1 -> A8).
        
        ```python
        >>> rust_chess.A1.flip()
        a8
        >>> rust_chess.H8.flip()
        h1
        ```
        """
    def to_bitboard(self) -> Bitboard:
        r"""
        Convert a square to a bitboard.
        
        ```python
        >>> bitboard = rust_chess.E4.to_bitboard()
        >>> bitboard.popcnt()
        1
        >>> bitboard
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . X . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        . . . . . . . .
        ```
        """
    @staticmethod
    def from_index(index: builtins.int) -> Square:
        r"""
        Create a new square from an index.
        Indexing starts at 0 (a1) and ends at 63 (h8).
        
        ```python
        >>> rust_chess.Square.from_index(0)
        a1
        ```
        """
    @staticmethod
    def from_rank_file(rank: builtins.int, file: builtins.int) -> Square:
        r"""
        Create a new square from rank and file.
        Rank and file are 0-indexed (0-7).
        
        ```python
        >>> rust_chess.Square.from_rank_file(0, 3)
        d1
        ```
        """
    @staticmethod
    def from_file_rank(file: builtins.int, rank: builtins.int) -> Square:
        r"""
        Create a new square from file and rank.
        File and rank are 0-indexed (0-7).
        
        ```python
        >>> rust_chess.Square.from_file_rank(3, 0)
        d1
        ```
        """
    def get_name(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4").
        
        ```python
        >>> rust_chess.E4.get_name()
        'e4'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4"),
        
        ```python
        >>> print(rust_chess.E4)
        e4
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4").
        
        ```python
        >>> rust_chess.E4
        e4
        ```
        """
    def get_color(self) -> Color:
        r"""
        Get the color of the square on the chessboard.
        
        ```python
        >>> rust_chess.A1.get_color() == rust_chess.BLACK
        True
        >>> rust_chess.E4.get_color() == rust_chess.WHITE
        True
        ```
        """
    @staticmethod
    def from_name(square_name: builtins.str) -> Square:
        r"""
        Create a new square from a name (e.g. "e4").
        Not really needed since you can use the square constants.
        Could also just call the constructor with the name string.
        
        ```python
        >>> rust_chess.Square.from_name("d2")
        d2
        ```
        """
    def __richcmp__(self, other: typing.Any, op: int) -> builtins.bool:
        r"""
        Compare the square to another square or integer.
        
        ```python
        >>> rust_chess.Square("d2") == rust_chess.D2
        True
        >>> rust_chess.Square("d2") == 11
        True
        >>> rust_chess.G6 > rust_chess.D3
        True
        >>> rust_chess.G6 <= 56
        True
        ```
        """
    def get_rank(self) -> builtins.int:
        r"""
        Get the rank of the square as an integer (0-7).
        
        ```python
        >>> rust_chess.E4.get_rank()
        3
        ```
        """
    def get_file(self) -> builtins.int:
        r"""
        Get the file of the square as an integer (0-7).
        
        ```python
        >>> rust_chess.E4.get_file()
        4
        ```
        """
    def up(self) -> typing.Optional[Square]:
        r"""
        Returns the square above, otherwise None.
        
        ```python
        >>> rust_chess.H5.up()
        h6
        ```
        """
    def down(self) -> typing.Optional[Square]:
        r"""
        Returns the square below, otherwise None.
        
        ```python
        >>> rust_chess.H5.down()
        h4
        ```
        """
    def left(self) -> typing.Optional[Square]:
        r"""
        Returns the square to the left, otherwise None.
        
        ```python
        >>> rust_chess.H5.left()
        g5
        ```
        """
    def right(self) -> typing.Optional[Square]:
        r"""
        Returns the square to the right, otherwise None
        
        ```python
        >>> rust_chess.H5.right()
        
        >>> rust_chess.H5.right() == None
        True
        ```
        """

@typing.final
class BoardStatus(enum.Enum):
    r"""
    Board status enum class.
    Represents the status of a chess board.
    The status can be one of the following:
        Ongoing, seventy-five moves, five-fold repetition, insufficient material, stalemate, or checkmate.
    Supports comparison and equality.
    """
    ONGOING = ...
    SEVENTY_FIVE_MOVES = ...
    FIVE_FOLD_REPETITION = ...
    INSUFFICIENT_MATERIAL = ...
    STALEMATE = ...
    CHECKMATE = ...

