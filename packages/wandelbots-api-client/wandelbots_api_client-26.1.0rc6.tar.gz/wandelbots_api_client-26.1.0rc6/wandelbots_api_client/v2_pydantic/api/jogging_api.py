# coding: utf-8

"""
    Wandelbots NOVA API

    Interact with robots in an easy and intuitive way. 

    The version of the OpenAPI document: 2.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from furl import furl
import json
import humps
import re
import warnings
import websockets
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, AsyncGenerator, Callable, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from urllib.parse import quote

from pydantic import Field, StrictStr
from typing_extensions import Annotated
from wandelbots_api_client.v2_pydantic.models import ExecuteJoggingRequest
from wandelbots_api_client.v2_pydantic.models import ExecuteJoggingResponse

from wandelbots_api_client.v2_pydantic.api_client import ApiClient, RequestSerialized
from wandelbots_api_client.v2_pydantic.api_response import ApiResponse
from wandelbots_api_client.v2_pydantic.rest import RESTResponseType

class JoggingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def execute_jogging(self, cell: Annotated[StrictStr, Field(description="Unique identifier addressing a cell in all API calls. ")], controller: Annotated[StrictStr, Field(description="Unique identifier to address a controller in the cell.")], client_request_generator: Callable[[AsyncGenerator[ExecuteJoggingResponse, None]], AsyncGenerator[ExecuteJoggingRequest, None]]) -> None:  # noqa: E501
        """Execute Jogging  # noqa: E501

        <!-- theme: success -->  > Websocket endpoint  Provides execution control over a dynamically adaptable jogging motion for a motion group.  Jogging describes controlling a motion group by sending real-time commands to move either its joints or the TCP. The commands contain target velocities that may change at any time during execution, so the resulting motion cannot be computed upfront.  ### Preconditions  The motion group is not moved by any other endpoint.  ### Requests  #### 1. Send `InitializeJoggingRequest` to configure the jogging.  - Sets the robot controller mode to control mode. - Claims the motion group for jogging. For robotic arms, TCP is required to ensure that limits, including TCP limits, are respected.  #### 2. Send `JointVelocityRequest` or `TcpVelocityRequest` to start the jogging motion.  - Commands can only be processed in the cycle rate of the controller - Sending commands faster will not increase the responsiveness of the jogging motion, it will lead to dropped commands - It is recommended to couple sending commands with the [state stream](streamMotionGroupState), which can be subscribed to via nats as well.  #### 3. Change or stop the jogging motion  - Change the jogging direction and/or velocity during the jogging motion with `JointVelocityRequest` or `TcpVelocityRequest`. - To stop the jogging motion, send zero velocities via either request or `PauseJoggingRequest`.  ### Responses  - Each request is acknowledged with a corresponding response:   - `InitializeJoggingResponse` after `InitializeJoggingRequest`   - `JointVelocityResponse` after `JointVelocityRequest`   - `TcpVelocityResponse` after `TcpVelocityRequest`   - `PauseJoggingResponse` after `PauseJoggingRequest`   The responses confirm that the requests were received.   They do not signal that the operation was successful; check the [motion group state](streamMotionGroupState) for that. - `MovementErrorResponse` with error details is sent in case of an unexpected error, e.g., controller disconnects during jogging.  ### Tips and Tricks  - Ensure that the websocket connection remains open until the jogging motion is stopped to avoid unexpected stops.   # noqa: E501
        :param client_request_generator: An AsyncGenerator that yields request of type ExecuteJoggingRequest and takes an AsyncGenerator of ExecuteJoggingResponse as an input argument (required)
        :info All responses from the server will be yielded to client_request_generator through the (AsyncGenerator[ExecuteJoggingResponse, None])
        :type AsyncGenerator[ExecuteJoggingRequest, None]
        """
        def format_path_parameters(path):
            # Find all substrings that are enclosed in brackets
            bracket_contents = re.findall(r'\{(.*?)\}', path)

            # For each found substring, alter it to match the python variable name
            for content in bracket_contents:
                content = "{" + content + "}"
                modified_content = humps.dekebabize(content)
                path = path.replace(content, modified_content)

            return path

        async def iterate_responses(ws) -> AsyncGenerator[ExecuteJoggingResponse, None]:
            async for response in ws:
                if "Cancelled on the server side" in response:
                    break
                response_data = json.loads(response)
                if "result" not in response_data:
                    raise Exception(response_data)
                result_data = response_data["result"]
                if isinstance(result_data, list):
                    # Handle list of objects
                    import re
                    # Extract the base type from List[BaseType] pattern
                    return_type_str = "ExecuteJoggingResponse"
                    if return_type_str.startswith("List[") and return_type_str.endswith("]"):
                        base_type_name = return_type_str[5:-1]  # Remove "List[" and "]"
                        # Get the actual class from the module
                        base_type_class = globals().get(base_type_name)
                        if base_type_class and hasattr(base_type_class, 'model_validate'):
                            result_list = [base_type_class.model_validate(item) for item in result_data]
                            yield result_list
                        else:
                            yield result_data
                    else:
                        yield result_data
                else:
                    # Handle single object
                    yield ExecuteJoggingResponse.model_validate(result_data)


        path = format_path_parameters("/cells/{cell}/controllers/{controller}/execution/jogging")
        path = path.format(cell=cell,controller=controller,)

        headers = websockets.Headers()
        tmp_host = self.api_client.configuration.host
        if self.api_client.configuration.host.startswith("https://"):
            # Basic Auth
            if self.api_client.configuration.username:
                tmp_host = self.api_client.configuration.host.replace("https://", "")
                tmp_host = f"wss://{self.api_client.configuration.username}:{self.api_client.configuration.password}@{tmp_host}"

            # OAuth2
            elif self.api_client.configuration.access_token:
                tmp_host = self.api_client.configuration.host.replace("https://", "")
                tmp_host = f"wss://{tmp_host}"
                headers = websockets.Headers([
                    ("Authorization", f"Bearer {self.api_client.configuration.access_token}")
                ])
        else:
            tmp_host = tmp_host.replace("http://", "ws://")

        full_url = furl(tmp_host + path)

        async with websockets.connect(full_url.url, open_timeout=10, additional_headers=headers) as websocket:
            try:
                async for request in client_request_generator(iterate_responses(websocket)):
                    await websocket.send(request.model_dump_json(exclude_none=True))
            finally:
                await websocket.close()

