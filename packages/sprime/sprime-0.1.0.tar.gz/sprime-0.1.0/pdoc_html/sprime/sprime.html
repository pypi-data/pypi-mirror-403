<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sprime.sprime API documentation</title>
<meta name="description" content="sprime - A biomedical library for screening high-throughput screening data …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sprime.sprime</code></h1>
</header>
<section id="section-intro">
<p>sprime - A biomedical library for screening high-throughput screening data.</p>
<p>This module provides tools for analyzing dose-response curves and calculating
S' (S prime) values from quantitative high-throughput screening (QHTS) data.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprime.sprime.calculate_delta_s_prime"><code class="name flex">
<span>def <span class="ident">calculate_delta_s_prime</span></span>(<span>s_prime_data: <a title="sprime.sprime.ScreeningDataset" href="#sprime.sprime.ScreeningDataset">ScreeningDataset</a> | List[Dict],<br>reference_cell_line_names: str | List[str],<br>test_cell_line_names: str | List[str],<br>headings_one_to_one_in_ref_and_test: List[str] | None = None,<br>source_profile: Literal['ref', 'test'] = 'test') ‑> Dict[str, List[Dict]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_delta_s_prime(
    s_prime_data: Union[ScreeningDataset, List[Dict]],
    reference_cell_line_names: Union[str, List[str]],
    test_cell_line_names: Union[str, List[str]],
    headings_one_to_one_in_ref_and_test: Optional[List[str]] = None,
    source_profile: Literal[&#34;ref&#34;, &#34;test&#34;] = &#34;test&#34;,
) -&gt; Dict[str, List[Dict]]:
    &#34;&#34;&#34;
    Calculate delta S&#39; between reference and test cell lines.
    
    Matches original pseudo-code: delta_s_prime()
    
    Compound-level columns (MOA, drug targets, optional headings) auto-propagate;
    see ScreeningDataset.calculate_delta_s_prime for details.
    
    Args:
        s_prime_data: ScreeningDataset or list of dicts with S&#39; values
        reference_cell_line_names: Reference cell line name(s)
        test_cell_line_names: Test cell line name(s)
        headings_one_to_one_in_ref_and_test: Optional list of metadata headings
            that exist 1:1 in ref and test; included in output.
        source_profile: &#39;ref&#39; or &#39;test&#39;; which profile to use for compound-level values.
        
    Returns:
        Dictionary with keys for each reference cell line, containing
        lists of dicts with delta S&#39; and compound-level fields per combo.
    &#34;&#34;&#34;
    if isinstance(s_prime_data, ScreeningDataset):
        return s_prime_data.calculate_delta_s_prime(
            reference_cell_line_names,
            test_cell_line_names,
            headings_one_to_one_in_ref_and_test=headings_one_to_one_in_ref_and_test,
            source_profile=source_profile,
        )
    else:
        if not s_prime_data:
            return {}
        
        assay_name = s_prime_data[0].get(&#39;assay&#39;, &#39;Unknown&#39;)
        assay = Assay(name=assay_name)
        screening_dataset = ScreeningDataset(assay=assay)
        
        for row in s_prime_data:
            compound = Compound(
                name=row.get(&#39;compound_name&#39;, &#39;Unknown&#39;),
                drug_id=row.get(&#39;drug_id&#39;, &#39;&#39;),
                pubchem_sid=None,
                smiles=None
            )
            cell_line = CellLine(
                name=row.get(&#39;cell_line&#39;, &#39;&#39;),
                ref_id=None
            )
            
            hill_params = None
            if row.get(&#39;ec50&#39;) is not None:
                hill_params = HillCurveParams(
                    ec50=row.get(&#39;ec50&#39;),
                    upper=row.get(&#39;upper&#39;),
                    lower=row.get(&#39;lower&#39;),
                    hill_coefficient=row.get(&#39;hill_coefficient&#39;),
                    r_squared=row.get(&#39;r_squared&#39;)
                )
            
            profile = DoseResponseProfile(
                compound=compound,
                cell_line=cell_line,
                assay=assay,
                concentrations=None,
                responses=None,
                concentration_units=&#34;microM&#34;,
                hill_params=hill_params,
                s_prime=row.get(&#39;s_prime&#39;),
                rank=row.get(&#39;rank&#39;),
                metadata=None
            )
            
            if profile.s_prime is not None and profile.hill_params is not None:
                try:
                    screening_dataset.add_profile(profile)
                except ValueError:
                    continue
        
        return screening_dataset.calculate_delta_s_prime(
            reference_cell_line_names,
            test_cell_line_names,
            headings_one_to_one_in_ref_and_test=headings_one_to_one_in_ref_and_test,
            source_profile=source_profile,
        )</code></pre>
</details>
<div class="desc"><p>Calculate delta S' between reference and test cell lines.</p>
<p>Matches original pseudo-code: delta_s_prime()</p>
<p>Compound-level columns (MOA, drug targets, optional headings) auto-propagate;
see ScreeningDataset.calculate_delta_s_prime for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s_prime_data</code></strong></dt>
<dd>ScreeningDataset or list of dicts with S' values</dd>
<dt><strong><code>reference_cell_line_names</code></strong></dt>
<dd>Reference cell line name(s)</dd>
<dt><strong><code>test_cell_line_names</code></strong></dt>
<dd>Test cell line name(s)</dd>
<dt><strong><code>headings_one_to_one_in_ref_and_test</code></strong></dt>
<dd>Optional list of metadata headings
that exist 1:1 in ref and test; included in output.</dd>
<dt><strong><code>source_profile</code></strong></dt>
<dd>'ref' or 'test'; which profile to use for compound-level values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with keys for each reference cell line, containing
lists of dicts with delta S' and compound-level fields per combo.</p></div>
</dd>
<dt id="sprime.sprime.calculate_s_prime_from_params"><code class="name flex">
<span>def <span class="ident">calculate_s_prime_from_params</span></span>(<span>ac50: float, upper: float, lower: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_s_prime_from_params(ac50: float, upper: float, lower: float) -&gt; float:
    &#34;&#34;&#34;
    Calculate S&#39; from Hill curve parameters.
    
    Matches original pseudo-code: singleSPrime()
    
    Args:
        ac50: AC50 or EC50 value
        upper: Upper asymptote
        lower: Lower asymptote
        
    Returns:
        float: S&#39; value
    &#34;&#34;&#34;
    # S&#39; = asinh((Upper-Lower)/EC50)
    ratio = (upper - lower) / ac50
    return math.asinh(ratio)</code></pre>
</details>
<div class="desc"><p>Calculate S' from Hill curve parameters.</p>
<p>Matches original pseudo-code: singleSPrime()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ac50</code></strong></dt>
<dd>AC50 or EC50 value</dd>
<dt><strong><code>upper</code></strong></dt>
<dd>Upper asymptote</dd>
<dt><strong><code>lower</code></strong></dt>
<dd>Lower asymptote</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>S' value</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.convert_to_micromolar"><code class="name flex">
<span>def <span class="ident">convert_to_micromolar</span></span>(<span>concentrations: List[float], units: str) ‑> List[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_micromolar(concentrations: List[float], units: str) -&gt; List[float]:
    &#34;&#34;&#34;
    Convert concentration values to microMolar.
    
    Args:
        concentrations: List of concentration values
        units: Current units. Supported (case-insensitive), smallest to largest:
            fM (fm, femtom); pM (pm, picom); nM (nm, nanom);
            microM (µm, um, microm, micro); mM (mm, millim); M (m, mol).
        
    Returns:
        List of concentrations in microMolar
    &#34;&#34;&#34;
    units_lower = units.lower().strip()
    
    conversion_factors = {
        &#39;fm&#39;: 1e-9,
        &#39;femtom&#39;: 1e-9,
        &#39;pm&#39;: 1e-6,
        &#39;picom&#39;: 1e-6,
        &#39;nm&#39;: 0.001,
        &#39;nanom&#39;: 0.001,
        &#39;microm&#39;: 1.0,
        &#39;micro&#39;: 1.0,
        &#39;μm&#39;: 1.0,
        &#39;um&#39;: 1.0,
        &#39;mm&#39;: 1000.0,
        &#39;millim&#39;: 1000.0,
        &#39;m&#39;: 1000000.0,
        &#39;mol&#39;: 1000000.0,
    }
    
    factor = conversion_factors.get(units_lower, 1.0)
    return [c * factor for c in concentrations]</code></pre>
</details>
<div class="desc"><p>Convert concentration values to microMolar.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>concentrations</code></strong></dt>
<dd>List of concentration values</dd>
<dt><strong><code>units</code></strong></dt>
<dd>Current units. Supported (case-insensitive), smallest to largest:
fM (fm, femtom); pM (pm, picom); nM (nm, nanom);
microM (µm, um, microm, micro); mM (mm, millim); M (m, mol).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of concentrations in microMolar</p></div>
</dd>
<dt id="sprime.sprime.fit_hill_from_raw_data"><code class="name flex">
<span>def <span class="ident">fit_hill_from_raw_data</span></span>(<span>response_array: List[float],<br>concentration_array: List[float],<br>concentration_units: str = 'microM',<br>**hill_calc_params) ‑> <a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_hill_from_raw_data(
    response_array: List[float],
    concentration_array: List[float],
    concentration_units: str = &#34;microM&#34;,
    **hill_calc_params
) -&gt; HillCurveParams:
    &#34;&#34;&#34;
    Fit Hill curve from raw response and concentration arrays.
    
    Matches original pseudo-code: sigleHillFromRawData()
    
    Args:
        response_array: List of response values
        concentration_array: List of concentration values
        concentration_units: Units of concentration (default: &#39;microM&#39;)
        **hill_calc_params: Additional parameters for curve fitting
        
    Returns:
        HillCurveParams: Fitted curve parameters
    &#34;&#34;&#34;
    if hill_fitting is None:
        raise ImportError(
            &#34;Hill curve fitting requires scipy. &#34;
            &#34;Install with: pip install scipy&#34;
        )
    
    # Convert units if needed
    concentrations = convert_to_micromolar(concentration_array, concentration_units)
    
    # Fit using hill_fitting module
    return hill_fitting.fit_hill_curve(
        concentrations,
        response_array,
        **hill_calc_params
    )</code></pre>
</details>
<div class="desc"><p>Fit Hill curve from raw response and concentration arrays.</p>
<p>Matches original pseudo-code: sigleHillFromRawData()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response_array</code></strong></dt>
<dd>List of response values</dd>
<dt><strong><code>concentration_array</code></strong></dt>
<dd>List of concentration values</dd>
<dt><strong><code>concentration_units</code></strong></dt>
<dd>Units of concentration (default: 'microM')</dd>
<dt><strong><code>**hill_calc_params</code></strong></dt>
<dd>Additional parameters for curve fitting</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a></code></dt>
<dd>Fitted curve parameters</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.get_s_prime_from_data"><code class="name flex">
<span>def <span class="ident">get_s_prime_from_data</span></span>(<span>list_of_rows: List[Dict],<br>allow_overwrite_hill_coefficients: bool = False,<br>values_as: str = 'columns',<br>**fit_params) ‑> List[Dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_s_prime_from_data(
    list_of_rows: List[Dict],
    allow_overwrite_hill_coefficients: bool = False,
    values_as: str = &#34;columns&#34;,
    **fit_params
) -&gt; List[Dict]:
    &#34;&#34;&#34;
    Calculate S&#39; values from in-memory data structure.
    
    Matches original pseudo-code: getSPrimeFromData()
    Uses global reporting configuration for console/log output.
    
    Args:
        list_of_rows: List of dictionaries matching CSV row format
        allow_overwrite_hill_coefficients: If True, allow overwriting pre-calc
            Hill params (AC50, Upper, Lower, Hill, r2) with fitted values when
            both raw and pre-calc exist. Default False (raise). When True,
            overwrites are logged as warnings.
        values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
        **fit_params: Parameters for curve fitting (e.g. maxfev, bounds).
        
    Returns:
        List of dictionaries with S&#39; values and ranking
        
    Raises:
        ValueError: If required columns are missing or data is invalid
    &#34;&#34;&#34;
    if not list_of_rows:
        return []
    
    # Validate required columns exist (check first row keys)
    first_row_keys = list(list_of_rows[0].keys()) if list_of_rows else []
    if first_row_keys:
        _validate_required_columns(
            first_row_keys, source_name=&#34;in-memory data&#34;, values_as=values_as
        )
    
    # Create report (row numbers will be 0 for in-memory data)
    if ProcessingReport is not None:
        report = ProcessingReport()
    else:
        report = None
    
    # Create a temporary RawDataset by manually constructing profiles
    # We&#39;ll use the first row to infer assay name, or use a default
    assay_name = list_of_rows[0].get(&#39;Screen ID&#39;, list_of_rows[0].get(&#39;Assay&#39;, &#39;Unknown&#39;))
    assay = Assay(name=assay_name)
    raw_dataset = RawDataset(assay=assay)
    
    if report:
        report.total_rows = len(list_of_rows)
    
    reserved = _reserved_column_names(values_as, first_row_keys)
    compounds_seen = set()
    
    for row_idx, row in enumerate(list_of_rows):
        if report:
            report.rows_processed += 1
        
        # Check if row is fully blank
        is_fully_blank = not any(
            v.strip() if isinstance(v, str) else str(v).strip()
            for v in row.values() if v
        )
        
        if is_fully_blank:
            continue
        
        # Get cell line name early for use in warnings
        cell_line_name = row.get(&#39;Cell_Line&#39;, &#39;&#39;).strip()
        
        # Check for empty cell line - RAISE EXCEPTION
        if not cell_line_name:
            raise ValueError(
                f&#34;Row {row_idx + 1}: Missing required &#39;Cell_Line&#39; value in in-memory data. &#34;
                f&#34;All rows must have a cell line specified.&#34;
            )
        
        # Get compound info (Compound_ID required; NCGCID pass-through only)
        compound_name = row.get(&#39;Compound Name&#39;, &#39;&#39;).strip() or &#39;Unknown&#39;
        compound_id = row.get(&#39;Compound_ID&#39;, &#39;&#39;).strip()
        
        if not compound_id:
            raise ValueError(
                f&#34;Row {row_idx + 1}: Missing required &#39;Compound_ID&#39; value in in-memory data. &#34;
                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                f&#34;All rows must have a compound identifier.&#34;
            )
        
        # Track compound
        if report and compound_id not in compounds_seen:
            compounds_seen.add(compound_id)
            report.compounds_loaded += 1
        
        # Check for missing compound name
        if report and compound_name == &#39;Unknown&#39;:
            report.add_warning(
                row_number=0,
                category=&#34;DATA_QUALITY&#34;,
                message=&#34;Compound Name missing, using &#39;Unknown&#39;&#34;,
                drug_id=compound_id,
                cell_line=cell_line_name,
                field_name=&#34;Compound Name&#34;
            )
            report.missing_compound_names += 1
        
        compound = Compound(
            name=compound_name,
            drug_id=compound_id,
            pubchem_sid=row.get(&#39;pubchem_sid&#39;, &#39;&#39;).strip() or None,
            smiles=row.get(&#39;SMILES&#39;, &#39;&#39;).strip() or None
        )
        
        # Create CellLine (cell_line_name already defined above)
        cell_line = CellLine(
            name=cell_line_name,
            ref_id=row.get(&#39;Cell_Line_Ref_ID&#39;, &#39;&#39;).strip() or None
        )
        
        # Extract raw dose-response data (if present)
        concentrations = None
        responses = None
        
        if values_as == &#34;list&#34;:
            resp_key = next((k for k in row if k.lower() == &#39;responses&#39;), None)
            conc_key = next((k for k in row if k.lower() == &#39;concentrations&#39;), None)
            if resp_key and conc_key:
                resp_str = (row.get(resp_key) or &#39;&#39;).strip()
                conc_str = (row.get(conc_key) or &#39;&#39;).strip()
                if resp_str and conc_str:
                    responses = []
                    conc_parts = []
                    for part in resp_str.split(&#39;,&#39;):
                        t = part.strip()
                        if t:
                            try:
                                v = float(t)
                                if not (math.isnan(v) or math.isinf(v)):
                                    responses.append(v)
                            except (ValueError, TypeError):
                                pass
                    for part in conc_str.split(&#39;,&#39;):
                        t = part.strip()
                        if t:
                            try:
                                v = float(t)
                                if not (math.isnan(v) or math.isinf(v)):
                                    conc_parts.append(v)
                            except (ValueError, TypeError):
                                pass
                    if len(responses) == len(conc_parts) and len(responses) &gt;= 4:
                        units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                        if not units:
                            raise ValueError(
                                f&#34;Row {row_idx + 1}: Missing required &#39;Concentration_Units&#39; for raw data in in-memory data. &#34;
                                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}.&#34;
                            )
                        concentrations = convert_to_micromolar(conc_parts, units)
                    else:
                        if len(responses) != len(conc_parts):
                            raise ValueError(
                                f&#34;Row {row_idx + 1}: Responses and Concentrations length mismatch &#34;
                                f&#34;({len(responses)} vs {len(conc_parts)}) in in-memory data.&#34;
                            )
                        responses = None
                        concentrations = None
        
        else:
            data_cols = [k for k in row.keys() if k.startswith(&#39;Data&#39;) or k.startswith(&#39;DATA&#39;)]
            conc_cols = [k for k in row.keys() 
                        if (k.startswith(&#39;Conc&#39;) or k.startswith(&#39;CONC&#39;)) 
                        and &#39;Units&#39; not in k and &#39;units&#39; not in k]
            if data_cols and conc_cols:
                data_cols = sorted(data_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                conc_cols = sorted(conc_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                responses = []
                concentrations = []
                for data_col, conc_col in zip(data_cols, conc_cols):
                    try:
                        resp_val = row.get(data_col, &#39;&#39;) or &#39;&#39;
                        conc_val = row.get(conc_col, &#39;&#39;) or &#39;&#39;
                        resp_val = resp_val.strip() if isinstance(resp_val, str) else &#39;&#39;
                        conc_val = conc_val.strip() if isinstance(conc_val, str) else &#39;&#39;
                        if resp_val and conc_val:
                            responses.append(float(resp_val))
                            concentrations.append(float(conc_val))
                    except (ValueError, TypeError):
                        continue
                if concentrations and responses:
                    units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                    if not units:
                        raise ValueError(
                            f&#34;Row {row_idx + 1}: Missing required &#39;Concentration_Units&#39; for raw data in in-memory data. &#34;
                            f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}.&#34;
                        )
                    concentrations = convert_to_micromolar(concentrations, units)
                else:
                    concentrations = None
                    responses = None
        
        # Extract pre-calculated Hill params (if present)
        hill_params = None
        ac50 = row.get(&#39;AC50&#39;, &#39;&#39;).strip() or row.get(&#39;ec50&#39;, &#39;&#39;).strip()
        if ac50:
            try:
                hill_params = HillCurveParams(
                    ec50=float(ac50),
                    upper=float(row.get(&#39;Upper&#39;, row.get(&#39;Infinity&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                    lower=float(row.get(&#39;Lower&#39;, row.get(&#39;Zero&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                    hill_coefficient=_try_float(row.get(&#39;Hill_Slope&#39;, row.get(&#39;Hill&#39;, row.get(&#39;slope&#39;, &#39;&#39;)))),
                    r_squared=_try_float(row.get(&#39;r2&#39;, row.get(&#39;R²&#39;, &#39;&#39;)))
                )
            except (ValueError, TypeError):
                hill_params = None
        
        # Validate that row has either raw data or pre-calculated params
        has_raw_data = concentrations is not None and responses is not None and len(concentrations) &gt; 0
        has_precalc_params = hill_params is not None
        
        if not (has_raw_data or has_precalc_params):
            raise ValueError(
                f&#34;Row {row_idx + 1}: No dose-response data found for compound &#39;{compound_name}&#39; &#34;
                f&#34;(Compound_ID: {compound_id}) in cell line &#39;{cell_line_name}&#39; in in-memory data. &#34;
                f&#34;Row must have either: (1) raw data columns (DATA*/CONC*), or &#34;
                f&#34;(2) pre-calculated parameters (AC50/Upper/Lower).&#34;
            )
        
        # Pre-calculated S&#39; (if present)
        s_prime = _try_float(row.get(&#34;S&#39;&#34;, row.get(&#39;S Prime&#39;, &#39;&#39;)))
        rank = _try_int(row.get(&#39;Rank&#39;, &#39;&#39;))
        
        # Extract metadata: generic pass-through (all non-reserved columns, exact header, value as-is)
        metadata = {}
        for col in row.keys():
            if col in reserved:
                continue
            raw = row.get(col, &#34;&#34;)
            raw = raw if isinstance(raw, str) else str(raw)
            metadata[col] = raw
        
        # Create profile
        profile = DoseResponseProfile(
            compound=compound,
            cell_line=cell_line,
            assay=assay,
            concentrations=concentrations,
            responses=responses,
            concentration_units=&#34;microM&#34;,
            hill_params=hill_params,
            s_prime=s_prime,
            rank=rank,
            metadata=metadata if metadata else None
        )
        
        raw_dataset.add_profile(profile)
        if report:
            report.profiles_created += 1
    
    # Process to ScreeningDataset (reuses same report)
    screening_dataset, process_report = raw_dataset.to_screening_dataset(
        report=report,
        allow_overwrite_hill_coefficients=allow_overwrite_hill_coefficients,
        **fit_params
    )
    
    # Print and write log based on global config
    if report and ReportingConfig is not None:
        report.print_console_summary()
        report.write_log_file()
    
    # Add ranking
    profiles = list(screening_dataset.profiles)
    profiles.sort(key=lambda p: p.s_prime if p.s_prime is not None else float(&#39;-inf&#39;), reverse=True)
    
    for rank, profile in enumerate(profiles, start=1):
        profile.rank = rank
    
    return screening_dataset.to_dict_list()</code></pre>
</details>
<div class="desc"><p>Calculate S' values from in-memory data structure.</p>
<p>Matches original pseudo-code: getSPrimeFromData()
Uses global reporting configuration for console/log output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_of_rows</code></strong></dt>
<dd>List of dictionaries matching CSV row format</dd>
<dt><strong><code>allow_overwrite_hill_coefficients</code></strong></dt>
<dd>If True, allow overwriting pre-calc
Hill params (AC50, Upper, Lower, Hill, r2) with fitted values when
both raw and pre-calc exist. Default False (raise). When True,
overwrites are logged as warnings.</dd>
<dt><strong><code>values_as</code></strong></dt>
<dd>"columns" (DATA<em>/CONC</em>) or "list" (Responses, Concentrations)</dd>
<dt><strong><code>**fit_params</code></strong></dt>
<dd>Parameters for curve fitting (e.g. maxfev, bounds).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of dictionaries with S' values and ranking</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required columns are missing or data is invalid</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.get_s_primes_from_file"><code class="name flex">
<span>def <span class="ident">get_s_primes_from_file</span></span>(<span>filepath: str | pathlib.Path,<br>allow_overwrite_hill_coefficients: bool = False,<br>values_as: str = 'columns',<br>**fit_params) ‑> List[Dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_s_primes_from_file(
    filepath: Union[str, Path],
    allow_overwrite_hill_coefficients: bool = False,
    values_as: str = &#34;columns&#34;,
    **fit_params
) -&gt; List[Dict]:
    &#34;&#34;&#34;
    Load CSV and calculate S&#39; values for all compounds.
    
    Matches original pseudo-code: getSPrimesFromFile()
    Uses global reporting configuration for console/log output.
    
    Args:
        filepath: Path to CSV file
        allow_overwrite_hill_coefficients: If True, allow overwriting pre-calc
            Hill params (AC50, Upper, Lower, Hill, r2) with fitted values when
            both raw and pre-calc exist. Default False (raise). When True,
            overwrites are logged as warnings.
        values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
        **fit_params: Parameters for curve fitting (e.g. maxfev, bounds).
        
    Returns:
        List of dictionaries with S&#39; values and ranking
    &#34;&#34;&#34;
    # Create single report that accumulates both load and process warnings
    if ProcessingReport is not None:
        report = ProcessingReport()
        report.input_filepath = Path(filepath)
    else:
        report = None
    
    # Load
    raw_dataset, load_report = RawDataset.load_from_file(
        filepath, report=report, values_as=values_as
    )
    
    # Process (reuses same report)
    screening_dataset, process_report = raw_dataset.to_screening_dataset(
        report=report,
        allow_overwrite_hill_coefficients=allow_overwrite_hill_coefficients,
        **fit_params
    )
    
    # Print and write log based on global config
    if report and ReportingConfig is not None:
        report.print_console_summary()
        report.write_log_file()
    
    # Add ranking
    profiles = list(screening_dataset.profiles)
    profiles.sort(key=lambda p: p.s_prime if p.s_prime is not None else float(&#39;-inf&#39;), reverse=True)
    
    for rank, profile in enumerate(profiles, start=1):
        profile.rank = rank
    
    return screening_dataset.to_dict_list()</code></pre>
</details>
<div class="desc"><p>Load CSV and calculate S' values for all compounds.</p>
<p>Matches original pseudo-code: getSPrimesFromFile()
Uses global reporting configuration for console/log output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to CSV file</dd>
<dt><strong><code>allow_overwrite_hill_coefficients</code></strong></dt>
<dd>If True, allow overwriting pre-calc
Hill params (AC50, Upper, Lower, Hill, r2) with fitted values when
both raw and pre-calc exist. Default False (raise). When True,
overwrites are logged as warnings.</dd>
<dt><strong><code>values_as</code></strong></dt>
<dd>"columns" (DATA<em>/CONC</em>) or "list" (Responses, Concentrations)</dd>
<dt><strong><code>**fit_params</code></strong></dt>
<dd>Parameters for curve fitting (e.g. maxfev, bounds).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of dictionaries with S' values and ranking</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sprime.sprime.Assay"><code class="flex name class">
<span>class <span class="ident">Assay</span></span>
<span>(</span><span>name: str,<br>description: str | None = None,<br>screen_id: str | None = None,<br>readout_type: str | None = None,<br>time_profile: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Assay:
    &#34;&#34;&#34;
    Represents a standardized biological assay procedure.
    
    Attributes:
        name: Assay name or identifier
        description: Assay description (optional)
        screen_id: Screen ID from data (e.g., &#39;HTS002&#39;) (optional)
        readout_type: Type of measurement (e.g., &#39;activity&#39;, &#39;luminescence&#39;) (optional)
        time_profile: Time point if applicable (e.g., &#39;24Hr&#39;, &#39;48Hr&#39;, &#39;4Day&#39;) (optional)
    &#34;&#34;&#34;
    name: str
    description: Optional[str] = None
    screen_id: Optional[str] = None
    readout_type: Optional[str] = None
    time_profile: Optional[str] = None
    
    def __repr__(self):
        return f&#34;Assay({self.name})&#34;</code></pre>
</details>
<div class="desc"><p>Represents a standardized biological assay procedure.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Assay name or identifier</dd>
<dt><strong><code>description</code></strong></dt>
<dd>Assay description (optional)</dd>
<dt><strong><code>screen_id</code></strong></dt>
<dd>Screen ID from data (e.g., 'HTS002') (optional)</dd>
<dt><strong><code>readout_type</code></strong></dt>
<dd>Type of measurement (e.g., 'activity', 'luminescence') (optional)</dd>
<dt><strong><code>time_profile</code></strong></dt>
<dd>Time point if applicable (e.g., '24Hr', '48Hr', '4Day') (optional)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.Assay.description"><code class="name">var <span class="ident">description</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Assay.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Assay.readout_type"><code class="name">var <span class="ident">readout_type</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Assay.screen_id"><code class="name">var <span class="ident">screen_id</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Assay.time_profile"><code class="name">var <span class="ident">time_profile</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.CellLine"><code class="flex name class">
<span>class <span class="ident">CellLine</span></span>
<span>(</span><span>name: str, ref_id: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class CellLine:
    &#34;&#34;&#34;
    Represents a cell line/clone.
    
    Attributes:
        name: Cell line name (e.g., &#39;ipNF96.11C&#39;, &#39;LS513_LARGE_INTESTINE&#39;)
        ref_id: Reference identifier (e.g., &#39;ACH-000007&#39;, &#39;depmap_id&#39;) (optional)
    &#34;&#34;&#34;
    name: str
    ref_id: Optional[str] = None
    
    def __repr__(self):
        return f&#34;CellLine({self.name})&#34;</code></pre>
</details>
<div class="desc"><p>Represents a cell line/clone.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Cell line name (e.g., 'ipNF96.11C', 'LS513_LARGE_INTESTINE')</dd>
<dt><strong><code>ref_id</code></strong></dt>
<dd>Reference identifier (e.g., 'ACH-000007', 'depmap_id') (optional)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.CellLine.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.CellLine.ref_id"><code class="name">var <span class="ident">ref_id</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.Compound"><code class="flex name class">
<span>class <span class="ident">Compound</span></span>
<span>(</span><span>name: str,<br>drug_id: str,<br>pubchem_sid: str | None = None,<br>smiles: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Compound:
    &#34;&#34;&#34;
    Represents a chemical compound/drug entity.
    
    Attributes:
        name: Compound name
        drug_id: Unique compound identifier (from Compound_ID column)
        pubchem_sid: PubChem substance identifier (optional)
        smiles: SMILES notation of chemical structure (optional)
    &#34;&#34;&#34;
    name: str
    drug_id: str
    pubchem_sid: Optional[str] = None
    smiles: Optional[str] = None
    
    def __repr__(self):
        return f&#34;Compound({self.name}, id={self.drug_id})&#34;</code></pre>
</details>
<div class="desc"><p>Represents a chemical compound/drug entity.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Compound name</dd>
<dt><strong><code>drug_id</code></strong></dt>
<dd>Unique compound identifier (from Compound_ID column)</dd>
<dt><strong><code>pubchem_sid</code></strong></dt>
<dd>PubChem substance identifier (optional)</dd>
<dt><strong><code>smiles</code></strong></dt>
<dd>SMILES notation of chemical structure (optional)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.Compound.drug_id"><code class="name">var <span class="ident">drug_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Compound.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Compound.pubchem_sid"><code class="name">var <span class="ident">pubchem_sid</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.Compound.smiles"><code class="name">var <span class="ident">smiles</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.DoseResponseProfile"><code class="flex name class">
<span>class <span class="ident">DoseResponseProfile</span></span>
<span>(</span><span>compound: <a title="sprime.sprime.Compound" href="#sprime.sprime.Compound">Compound</a>,<br>cell_line: <a title="sprime.sprime.CellLine" href="#sprime.sprime.CellLine">CellLine</a>,<br>assay: <a title="sprime.sprime.Assay" href="#sprime.sprime.Assay">Assay</a>,<br>concentrations: List[float] | None = None,<br>responses: List[float] | None = None,<br>concentration_units: str = 'microM',<br>hill_params: <a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a> | None = None,<br>s_prime: float | None = None,<br>rank: int | None = None,<br>metadata: Dict[str, str] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DoseResponseProfile:
    &#34;&#34;&#34;
    Represents a dose-response profile for one Compound-CellLine pair in one Assay.
    
    Contains raw data, fitted curve parameters, and calculated S&#39; value.
    
    Attributes:
        compound: Compound entity
        cell_line: CellLine entity
        assay: Assay entity
        concentrations: Raw concentration values (list of floats) (optional)
        responses: Raw response values (list of floats) (optional)
        concentration_units: Units for concentrations (default: &#39;microM&#39;)
        hill_params: Fitted Hill curve parameters (optional)
        s_prime: Calculated S&#39; value (optional)
        rank: Rank of S&#39; value (optional)
        metadata: Additional metadata from CSV (e.g., MOA, drug targets) (optional)
    &#34;&#34;&#34;
    compound: Compound
    cell_line: CellLine
    assay: Assay
    
    # Raw data
    concentrations: Optional[List[float]] = None
    responses: Optional[List[float]] = None
    concentration_units: str = &#34;microM&#34;
    
    # Fitted parameters
    hill_params: Optional[HillCurveParams] = None
    
    # Results
    s_prime: Optional[float] = None
    rank: Optional[int] = None
    
    # Additional metadata
    metadata: Optional[Dict[str, str]] = None
    
    def fit_hill_curve(self, **fit_params) -&gt; HillCurveParams:
        &#34;&#34;&#34;
        Fit four-parameter Hill equation to raw dose-response data.
        
        Updates self.hill_params with fitted parameters.
        
        Args:
            **fit_params: Additional parameters for curve fitting
            
        Returns:
            HillCurveParams: Fitted curve parameters
            
        Raises:
            ValueError: If raw data is not available or hill_params already exist
        &#34;&#34;&#34;
        if self.hill_params is not None:
            return self.hill_params  # Already fitted
        
        if self.concentrations is None or self.responses is None:
            raise ValueError(&#34;Need raw data to fit Hill curve&#34;)
        
        if len(self.concentrations) != len(self.responses):
            raise ValueError(&#34;Concentrations and responses must have same length&#34;)
        
        if hill_fitting is None:
            raise ImportError(
                &#34;Hill curve fitting requires scipy. &#34;
                &#34;Install with: pip install scipy&#34;
            )
        
        # Fit Hill curve using hill_fitting module
        self.hill_params = hill_fitting.fit_hill_curve(
            self.concentrations,
            self.responses,
            **fit_params
        )
        
        return self.hill_params
    
    def calculate_s_prime(self) -&gt; float:
        &#34;&#34;&#34;
        Calculate S&#39; = asinh((Upper-Lower)/EC50).
        
        Requires hill_params to be set (call fit_hill_curve first).
        
        Returns:
            float: S&#39; value
            
        Raises:
            ValueError: If hill_params is not available
        &#34;&#34;&#34;
        if self.hill_params is None:
            raise ValueError(&#34;Must fit Hill curve before calculating S&#39;&#34;)
        
        # S&#39; = asinh((A-D)/C) where A=upper, D=lower, C=EC50
        ratio = self.hill_params.amplitude / self.hill_params.ec50
        self.s_prime = math.asinh(ratio)  # asinh(x) = ln(x + sqrt(x^2 + 1))
        return self.s_prime
    
    def fit_and_calculate_s_prime(self, **fit_params) -&gt; float:
        &#34;&#34;&#34;
        Convenience method: fit curve then calculate S&#39;.
        
        Args:
            **fit_params: Parameters for curve fitting
            
        Returns:
            float: S&#39; value
        &#34;&#34;&#34;
        self.fit_hill_curve(**fit_params)
        return self.calculate_s_prime()</code></pre>
</details>
<div class="desc"><p>Represents a dose-response profile for one Compound-CellLine pair in one Assay.</p>
<p>Contains raw data, fitted curve parameters, and calculated S' value.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>compound</code></strong></dt>
<dd>Compound entity</dd>
<dt><strong><code>cell_line</code></strong></dt>
<dd>CellLine entity</dd>
<dt><strong><code>assay</code></strong></dt>
<dd>Assay entity</dd>
<dt><strong><code>concentrations</code></strong></dt>
<dd>Raw concentration values (list of floats) (optional)</dd>
<dt><strong><code>responses</code></strong></dt>
<dd>Raw response values (list of floats) (optional)</dd>
<dt><strong><code>concentration_units</code></strong></dt>
<dd>Units for concentrations (default: 'microM')</dd>
<dt><strong><code>hill_params</code></strong></dt>
<dd>Fitted Hill curve parameters (optional)</dd>
<dt><strong><code>s_prime</code></strong></dt>
<dd>Calculated S' value (optional)</dd>
<dt><strong><code>rank</code></strong></dt>
<dd>Rank of S' value (optional)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Additional metadata from CSV (e.g., MOA, drug targets) (optional)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.DoseResponseProfile.assay"><code class="name">var <span class="ident">assay</span> : <a title="sprime.sprime.Assay" href="#sprime.sprime.Assay">Assay</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.cell_line"><code class="name">var <span class="ident">cell_line</span> : <a title="sprime.sprime.CellLine" href="#sprime.sprime.CellLine">CellLine</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.compound"><code class="name">var <span class="ident">compound</span> : <a title="sprime.sprime.Compound" href="#sprime.sprime.Compound">Compound</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.concentration_units"><code class="name">var <span class="ident">concentration_units</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.concentrations"><code class="name">var <span class="ident">concentrations</span> : List[float] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.hill_params"><code class="name">var <span class="ident">hill_params</span> : <a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.metadata"><code class="name">var <span class="ident">metadata</span> : Dict[str, str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.rank"><code class="name">var <span class="ident">rank</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.responses"><code class="name">var <span class="ident">responses</span> : List[float] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.s_prime"><code class="name">var <span class="ident">s_prime</span> : float | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sprime.sprime.DoseResponseProfile.calculate_s_prime"><code class="name flex">
<span>def <span class="ident">calculate_s_prime</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_s_prime(self) -&gt; float:
    &#34;&#34;&#34;
    Calculate S&#39; = asinh((Upper-Lower)/EC50).
    
    Requires hill_params to be set (call fit_hill_curve first).
    
    Returns:
        float: S&#39; value
        
    Raises:
        ValueError: If hill_params is not available
    &#34;&#34;&#34;
    if self.hill_params is None:
        raise ValueError(&#34;Must fit Hill curve before calculating S&#39;&#34;)
    
    # S&#39; = asinh((A-D)/C) where A=upper, D=lower, C=EC50
    ratio = self.hill_params.amplitude / self.hill_params.ec50
    self.s_prime = math.asinh(ratio)  # asinh(x) = ln(x + sqrt(x^2 + 1))
    return self.s_prime</code></pre>
</details>
<div class="desc"><p>Calculate S' = asinh((Upper-Lower)/EC50).</p>
<p>Requires hill_params to be set (call fit_hill_curve first).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>S' value</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If hill_params is not available</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.fit_and_calculate_s_prime"><code class="name flex">
<span>def <span class="ident">fit_and_calculate_s_prime</span></span>(<span>self, **fit_params) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_and_calculate_s_prime(self, **fit_params) -&gt; float:
    &#34;&#34;&#34;
    Convenience method: fit curve then calculate S&#39;.
    
    Args:
        **fit_params: Parameters for curve fitting
        
    Returns:
        float: S&#39; value
    &#34;&#34;&#34;
    self.fit_hill_curve(**fit_params)
    return self.calculate_s_prime()</code></pre>
</details>
<div class="desc"><p>Convenience method: fit curve then calculate S'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**fit_params</code></strong></dt>
<dd>Parameters for curve fitting</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>S' value</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.DoseResponseProfile.fit_hill_curve"><code class="name flex">
<span>def <span class="ident">fit_hill_curve</span></span>(<span>self, **fit_params) ‑> <a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_hill_curve(self, **fit_params) -&gt; HillCurveParams:
    &#34;&#34;&#34;
    Fit four-parameter Hill equation to raw dose-response data.
    
    Updates self.hill_params with fitted parameters.
    
    Args:
        **fit_params: Additional parameters for curve fitting
        
    Returns:
        HillCurveParams: Fitted curve parameters
        
    Raises:
        ValueError: If raw data is not available or hill_params already exist
    &#34;&#34;&#34;
    if self.hill_params is not None:
        return self.hill_params  # Already fitted
    
    if self.concentrations is None or self.responses is None:
        raise ValueError(&#34;Need raw data to fit Hill curve&#34;)
    
    if len(self.concentrations) != len(self.responses):
        raise ValueError(&#34;Concentrations and responses must have same length&#34;)
    
    if hill_fitting is None:
        raise ImportError(
            &#34;Hill curve fitting requires scipy. &#34;
            &#34;Install with: pip install scipy&#34;
        )
    
    # Fit Hill curve using hill_fitting module
    self.hill_params = hill_fitting.fit_hill_curve(
        self.concentrations,
        self.responses,
        **fit_params
    )
    
    return self.hill_params</code></pre>
</details>
<div class="desc"><p>Fit four-parameter Hill equation to raw dose-response data.</p>
<p>Updates self.hill_params with fitted parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**fit_params</code></strong></dt>
<dd>Additional parameters for curve fitting</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a></code></dt>
<dd>Fitted curve parameters</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If raw data is not available or hill_params already exist</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.HillCurveParams"><code class="flex name class">
<span>class <span class="ident">HillCurveParams</span></span>
<span>(</span><span>ec50: float,<br>upper: float,<br>lower: float,<br>hill_coefficient: float | None = None,<br>r_squared: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class HillCurveParams:
    &#34;&#34;&#34;
    Parameters from four-parameter Hill equation fit.
    
    Hill equation: y = D + (A - D) / (1 + (x/C)^n)
    Where:
        A = upper (upper asymptote)
        D = lower (lower asymptote)
        C = ec50 (half-maximal concentration)
        n = hill_coefficient (slope/steepness)
    
    Attributes:
        ec50: Half-maximal effect concentration (AC50/EC50)
        upper: Upper asymptote (A parameter)
        lower: Lower asymptote (D parameter)
        hill_coefficient: Hill coefficient/slope (n parameter) (optional)
        r_squared: R-squared goodness of fit statistic (optional)
    &#34;&#34;&#34;
    ec50: float
    upper: float
    lower: float
    hill_coefficient: Optional[float] = None
    r_squared: Optional[float] = None
    
    @property
    def amplitude(self) -&gt; float:
        &#34;&#34;&#34;Response amplitude (Upper - Lower)&#34;&#34;&#34;
        return self.upper - self.lower</code></pre>
</details>
<div class="desc"><p>Parameters from four-parameter Hill equation fit.</p>
<p>Hill equation: y = D + (A - D) / (1 + (x/C)^n)</p>
<h2 id="where">Where</h2>
<p>A = upper (upper asymptote)
D = lower (lower asymptote)
C = ec50 (half-maximal concentration)
n = hill_coefficient (slope/steepness)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ec50</code></strong></dt>
<dd>Half-maximal effect concentration (AC50/EC50)</dd>
<dt><strong><code>upper</code></strong></dt>
<dd>Upper asymptote (A parameter)</dd>
<dt><strong><code>lower</code></strong></dt>
<dd>Lower asymptote (D parameter)</dd>
<dt><strong><code>hill_coefficient</code></strong></dt>
<dd>Hill coefficient/slope (n parameter) (optional)</dd>
<dt><strong><code>r_squared</code></strong></dt>
<dd>R-squared goodness of fit statistic (optional)</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.HillCurveParams.amplitude"><code class="name">prop <span class="ident">amplitude</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def amplitude(self) -&gt; float:
    &#34;&#34;&#34;Response amplitude (Upper - Lower)&#34;&#34;&#34;
    return self.upper - self.lower</code></pre>
</details>
<div class="desc"><p>Response amplitude (Upper - Lower)</p></div>
</dd>
<dt id="sprime.sprime.HillCurveParams.ec50"><code class="name">var <span class="ident">ec50</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.HillCurveParams.hill_coefficient"><code class="name">var <span class="ident">hill_coefficient</span> : float | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.HillCurveParams.lower"><code class="name">var <span class="ident">lower</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.HillCurveParams.r_squared"><code class="name">var <span class="ident">r_squared</span> : float | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprime.sprime.HillCurveParams.upper"><code class="name">var <span class="ident">upper</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.RawDataset"><code class="flex name class">
<span>class <span class="ident">RawDataset</span></span>
<span>(</span><span>assay: <a title="sprime.sprime.Assay" href="#sprime.sprime.Assay">Assay</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawDataset:
    &#34;&#34;&#34;
    Holds raw dose-response curve data loaded from CSV/files.
    
    Focus: Data loading, validation, basic structure.
    May contain profiles with raw data (concentrations/responses) or 
    pre-calculated Hill params from CSV.
    &#34;&#34;&#34;
    
    def __init__(self, assay: Assay):
        &#34;&#34;&#34;
        Initialize RawDataset.
        
        Args:
            assay: Assay entity for this dataset
        &#34;&#34;&#34;
        self.assay = assay
        self._profiles: Dict[Tuple[str, str], DoseResponseProfile] = {}  # (compound_id, cellline_name) -&gt; profile
    
    @classmethod
    def load_from_file(
        cls,
        filepath: Union[str, Path],
        assay_name: Optional[str] = None,
        report: Optional[&#39;ProcessingReport&#39;] = None,
        values_as: str = &#34;columns&#34;,
        **csv_kwargs
    ) -&gt; Tuple[&#39;RawDataset&#39;, &#39;ProcessingReport&#39;]:
        &#34;&#34;&#34;
        Load CSV file and create RawDataset with quality reporting.
        
        Handles:
        - Extracting raw data (Data0..DataN, Conc0..ConcN) or Responses/Concentrations
        - Loading pre-calculated params (AC50, Upper, Lower) if present
        - Creating DoseResponseProfile objects
        - Tracking data quality issues and warnings
        
        Args:
            filepath: Path to CSV file
            assay_name: Name for assay (defaults to filename stem)
            report: Optional ProcessingReport to accumulate warnings (creates new if None)
            values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
            **csv_kwargs: Additional arguments for csv.DictReader
            
        Returns:
            Tuple of (RawDataset, ProcessingReport)
        &#34;&#34;&#34;
        filepath = Path(filepath)
        
        # Create or use existing report
        if report is None:
            if ProcessingReport is not None:
                report = ProcessingReport()
                report.input_filepath = filepath
            else:
                # Fallback if reporting not available
                report = None
        
        # Infer assay name
        if assay_name is None:
            assay_name = filepath.stem
        
        assay = Assay(name=assay_name)
        raw_dataset = cls(assay=assay)
        
        # Read CSV
        with open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            reader = csv.DictReader(f, **csv_kwargs)
            fieldnames = reader.fieldnames
            rows = list(reader)
        
        # Validate required columns exist in header
        if fieldnames:
            _validate_required_columns(
                fieldnames, source_name=f&#34;CSV file &#39;{filepath}&#39;&#34;, values_as=values_as
            )
        
        if report:
            report.total_rows = len(rows) + 1  # +1 for header
        
        if not rows:
            if report is None:
                # Return dummy report if reporting not available
                return raw_dataset, None
            return raw_dataset, report
        
        reserved = _reserved_column_names(values_as, fieldnames or [])
        
        # Track compounds seen
        compounds_seen = set()
        
        # Process rows with line numbers (row 1 is header, so start at 2)
        for row_num, row in enumerate(rows, start=2):
            # Check if row is fully blank (all values empty/whitespace)
            is_fully_blank = not any(
                v.strip() if isinstance(v, str) else str(v).strip()
                for v in row.values() if v
            )
            
            if is_fully_blank:
                # Skip fully blank rows silently (no logging, don&#39;t count as processed)
                continue
            
            if report:
                report.rows_processed += 1
            
            # Check for empty cell line - RAISE EXCEPTION
            cell_line_name = row.get(&#39;Cell_Line&#39;, &#39;&#39;).strip()
            if not cell_line_name:
                raise ValueError(
                    f&#34;Row {row_num}: Missing required &#39;Cell_Line&#39; value. &#34;
                    f&#34;All rows must have a cell line specified.&#34;
                )
            
            # Get compound info (Compound_ID required; NCGCID is pass-through only)
            # Rows are taken literally: empty values are null, no forward-filling.
            compound_name = row.get(&#39;Compound Name&#39;, &#39;&#39;).strip() or &#39;Unknown&#39;
            compound_id = row.get(&#39;Compound_ID&#39;, &#39;&#39;).strip()
            
            if not compound_id:
                raise ValueError(
                    f&#34;Row {row_num}: Missing required &#39;Compound_ID&#39; value. &#34;
                    f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                    f&#34;All rows must have a compound identifier.&#34;
                )
            
            # Track compound
            if report and compound_id not in compounds_seen:
                compounds_seen.add(compound_id)
                report.compounds_loaded += 1
            
            # Check for missing compound name
            if report and compound_name == &#39;Unknown&#39;:
                report.add_warning(
                    row_number=row_num,
                    category=&#34;DATA_QUALITY&#34;,
                    message=&#34;Compound Name missing, using &#39;Unknown&#39;&#34;,
                    drug_id=compound_id,
                    cell_line=cell_line_name,
                    field_name=&#34;Compound Name&#34;
                )
                report.missing_compound_names += 1
            
            compound = Compound(
                name=compound_name,
                drug_id=compound_id,
                pubchem_sid=row.get(&#39;pubchem_sid&#39;, &#39;&#39;).strip() or None,
                smiles=row.get(&#39;SMILES&#39;, &#39;&#39;).strip() or None
            )
            
            # Create CellLine
            cell_line = CellLine(
                name=cell_line_name,
                ref_id=row.get(&#39;Cell_Line_Ref_ID&#39;, &#39;&#39;).strip() or None
            )
            
            # Extract raw dose-response data (if present)
            concentrations = None
            responses = None
            
            if values_as == &#34;list&#34;:
                resp_key = next((k for k in row if k.lower() == &#39;responses&#39;), None)
                conc_key = next((k for k in row if k.lower() == &#39;concentrations&#39;), None)
                if resp_key and conc_key:
                    resp_str = (row.get(resp_key) or &#39;&#39;).strip()
                    conc_str = (row.get(conc_key) or &#39;&#39;).strip()
                    if resp_str and conc_str:
                        responses = []
                        concentrations = []
                        for part in resp_str.split(&#39;,&#39;):
                            t = part.strip()
                            if t:
                                try:
                                    v = float(t)
                                    if report and (math.isnan(v) or math.isinf(v)):
                                        report.add_warning(
                                            row_number=row_num,
                                            category=&#34;NUMERICAL&#34;,
                                            message=f&#34;Invalid numeric value (NaN/Inf) in Responses&#34;,
                                            drug_id=compound_id,
                                            compound_name=compound_name,
                                            cell_line=cell_line_name,
                                            field_name=&#34;Responses&#34;,
                                        )
                                        report.invalid_numeric_values += 1
                                        continue
                                    responses.append(v)
                                except (ValueError, TypeError) as e:
                                    if report:
                                        report.add_warning(
                                            row_number=row_num,
                                            category=&#34;DATA_QUALITY&#34;,
                                            message=f&#34;Non-numeric value in Responses: {e}&#34;,
                                            drug_id=compound_id,
                                            compound_name=compound_name,
                                            cell_line=cell_line_name,
                                            field_name=&#34;Responses&#34;,
                                        )
                                        report.invalid_numeric_values += 1
                                    continue
                        conc_parts = []
                        for part in conc_str.split(&#39;,&#39;):
                            t = part.strip()
                            if t:
                                try:
                                    v = float(t)
                                    if report and (math.isnan(v) or math.isinf(v)):
                                        report.add_warning(
                                            row_number=row_num,
                                            category=&#34;NUMERICAL&#34;,
                                            message=f&#34;Invalid numeric value (NaN/Inf) in Concentrations&#34;,
                                            drug_id=compound_id,
                                            compound_name=compound_name,
                                            cell_line=cell_line_name,
                                            field_name=&#34;Concentrations&#34;,
                                        )
                                        report.invalid_numeric_values += 1
                                        continue
                                    conc_parts.append(v)
                                except (ValueError, TypeError) as e:
                                    if report:
                                        report.add_warning(
                                            row_number=row_num,
                                            category=&#34;DATA_QUALITY&#34;,
                                            message=f&#34;Non-numeric value in Concentrations: {e}&#34;,
                                            drug_id=compound_id,
                                            compound_name=compound_name,
                                            cell_line=cell_line_name,
                                            field_name=&#34;Concentrations&#34;,
                                        )
                                        report.invalid_numeric_values += 1
                                    continue
                        if len(responses) != len(conc_parts):
                            raise ValueError(
                                f&#34;Row {row_num}: Responses and Concentrations length mismatch &#34;
                                f&#34;({len(responses)} vs {len(conc_parts)}). &#34;
                                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}.&#34;
                            )
                        if len(responses) &lt; 4:
                            if report:
                                report.add_warning(
                                    row_number=row_num,
                                    category=&#34;MISSING_DATA&#34;,
                                    message=f&#34;Insufficient data points: {len(responses)} found, need 4+ for curve fitting&#34;,
                                    drug_id=compound_id,
                                    compound_name=compound_name,
                                    cell_line=cell_line_name,
                                )
                                report.insufficient_data_points += 1
                            concentrations = None
                            responses = None
                        else:
                            units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                            if not units:
                                raise ValueError(
                                    f&#34;Row {row_num}: Missing required &#39;Concentration_Units&#39; for raw data. &#34;
                                    f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                                    f&#34;Raw dose-response data requires Concentration_Units.&#34;
                                )
                            concentrations = convert_to_micromolar(conc_parts, units)
                            responses = responses
            
            elif True:
                # Columns format: DATA*/CONC*
                data_cols = [k for k in row.keys() if k.startswith(&#39;Data&#39;) or k.startswith(&#39;DATA&#39;)]
                conc_cols = [k for k in row.keys() 
                            if (k.startswith(&#39;Conc&#39;) or k.startswith(&#39;CONC&#39;)) 
                            and &#39;Units&#39; not in k and &#39;units&#39; not in k]
                if data_cols and conc_cols:
                    # Sort columns to ensure correct order
                    data_cols = sorted(data_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                    conc_cols = sorted(conc_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                    
                    responses = []
                    concentrations = []
                    
                    for data_col, conc_col in zip(data_cols, conc_cols):
                        try:
                            resp_val = row.get(data_col, &#39;&#39;) or &#39;&#39;
                            conc_val = row.get(conc_col, &#39;&#39;) or &#39;&#39;
                            resp_val = resp_val.strip() if isinstance(resp_val, str) else &#39;&#39;
                            conc_val = conc_val.strip() if isinstance(conc_val, str) else &#39;&#39;
                            if resp_val and conc_val:
                                resp_float = float(resp_val)
                                conc_float = float(conc_val)
                                
                                # Check for invalid numeric values
                                if report:
                                    if math.isnan(resp_float) or math.isinf(resp_float):
                                        report.add_warning(
                                            row_number=row_num,
                                            category=&#34;NUMERICAL&#34;,
                                            message=f&#34;Invalid numeric value (NaN/Inf) in {data_col}&#34;,
                                            drug_id=compound_id,
                                            compound_name=compound_name,
                                            cell_line=cell_line_name,
                                            field_name=data_col
                                        )
                                        report.invalid_numeric_values += 1
                                        continue
                                    
                                    if math.isnan(conc_float) or math.isinf(conc_float):
                                        report.add_warning(
                                            row_number=row_num,
                                            category=&#34;NUMERICAL&#34;,
                                            message=f&#34;Invalid numeric value (NaN/Inf) in {conc_col}&#34;,
                                            drug_id=compound_id,
                                            compound_name=compound_name,
                                            cell_line=cell_line_name,
                                            field_name=conc_col
                                        )
                                        report.invalid_numeric_values += 1
                                        continue
                                
                                responses.append(resp_float)
                                concentrations.append(conc_float)
                        except (ValueError, TypeError) as e:
                            if report:
                                report.add_warning(
                                    row_number=row_num,
                                    category=&#34;DATA_QUALITY&#34;,
                                    message=f&#34;Non-numeric value in {data_col} or {conc_col}: {str(e)}&#34;,
                                    drug_id=compound_id,
                                    compound_name=compound_name,
                                    cell_line=cell_line_name,
                                    field_name=f&#34;{data_col}/{conc_col}&#34;
                                )
                                report.invalid_numeric_values += 1
                            continue
                    
                    # Check for sufficient data points
                    if report and len(responses) &lt; 4:
                        report.add_warning(
                            row_number=row_num,
                            category=&#34;MISSING_DATA&#34;,
                            message=f&#34;Insufficient data points: {len(responses)} found, need 4+ for curve fitting&#34;,
                            drug_id=compound_id,
                            compound_name=compound_name,
                            cell_line=cell_line_name
                        )
                        report.insufficient_data_points += 1
                    
                    if concentrations and responses:
                        units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                        if not units:
                            raise ValueError(
                                f&#34;Row {row_num}: Missing required &#39;Concentration_Units&#39; for raw data. &#34;
                                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                                f&#34;Raw dose-response data requires Concentration_Units.&#34;
                            )
                        concentrations = convert_to_micromolar(concentrations, units)
                        concentrations = concentrations if concentrations else None
                        responses = responses if responses else None
            
            # Extract pre-calculated Hill params (if present)
            hill_params = None
            ac50 = row.get(&#39;AC50&#39;, &#39;&#39;).strip() or row.get(&#39;ec50&#39;, &#39;&#39;).strip()
            if ac50:
                try:
                    r2_raw = row.get(&#39;r2&#39;, row.get(&#39;R²&#39;, &#39;&#39;))
                    r_sq = _try_float(r2_raw)
                    hill_params = HillCurveParams(
                        ec50=float(ac50),
                        upper=float(row.get(&#39;Upper&#39;, row.get(&#39;Infinity&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                        lower=float(row.get(&#39;Lower&#39;, row.get(&#39;Zero&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                        hill_coefficient=_try_float(row.get(&#39;Hill_Slope&#39;, row.get(&#39;Hill&#39;, row.get(&#39;slope&#39;, &#39;&#39;)))),
                        r_squared=r_sq
                    )
                except (ValueError, TypeError):
                    hill_params = None
            
            # Pre-calculated S&#39; (if present)
            s_prime = _try_float(row.get(&#34;S&#39;&#34;, row.get(&#39;S Prime&#39;, &#39;&#39;)))
            rank = _try_int(row.get(&#39;Rank&#39;, &#39;&#39;))
            
            # Validate that row has either raw data or pre-calculated params
            has_raw_data = concentrations is not None and responses is not None and len(concentrations) &gt; 0
            has_precalc_params = hill_params is not None

            if not (has_raw_data or has_precalc_params):
                raise ValueError(
                    f&#34;Row {row_num}: No dose-response data found for compound &#39;{compound_name}&#39; &#34;
                    f&#34;(Compound_ID: {compound_id}) in cell line &#39;{cell_line_name}&#39;. &#34;
                    f&#34;Row must have either: (1) raw data columns (DATA*/CONC*), or &#34;
                    f&#34;(2) pre-calculated parameters (AC50/Upper/Lower).&#34;
                )
            
            # Extract metadata: generic pass-through (all non-reserved columns, exact header, value as-is)
            metadata = {}
            for col in row.keys():
                if col in reserved:
                    continue
                raw = row.get(col, &#34;&#34;)
                raw = raw if isinstance(raw, str) else str(raw)
                metadata[col] = raw
            
            # Create profile
            profile = DoseResponseProfile(
                compound=compound,
                cell_line=cell_line,
                assay=assay,
                concentrations=concentrations,
                responses=responses,
                concentration_units=&#34;microM&#34;,
                hill_params=hill_params,
                s_prime=s_prime,
                rank=rank,
                metadata=metadata if metadata else None
            )
            
            raw_dataset.add_profile(profile)
            if report:
                report.profiles_created += 1
        
        if report is None:
            # Return dummy report if reporting not available
            return raw_dataset, None
        return raw_dataset, report
    
    def add_profile(self, profile: DoseResponseProfile):
        &#34;&#34;&#34;
        Add a profile to the dataset.
        
        Args:
            profile: DoseResponseProfile to add
            
        Raises:
            ValueError: If profile for this compound-cellline pair already exists
        &#34;&#34;&#34;
        key = (profile.compound.drug_id, profile.cell_line.name)
        if key in self._profiles:
            raise ValueError(f&#34;Profile for {key} already exists&#34;)
        self._profiles[key] = profile
    
    def get_profile(self, compound: Union[Compound, str], 
                    cell_line: Union[CellLine, str]) -&gt; Optional[DoseResponseProfile]:
        &#34;&#34;&#34;
        Retrieve a specific profile.
        
        Args:
            compound: Compound object or drug_id string
            cell_line: CellLine object or cell_line name string
            
        Returns:
            DoseResponseProfile or None if not found
        &#34;&#34;&#34;
        compound_id = compound.drug_id if isinstance(compound, Compound) else compound
        cellline_name = cell_line.name if isinstance(cell_line, CellLine) else cell_line
        return self._profiles.get((compound_id, cellline_name))
    
    def to_screening_dataset(
        self,
        report: Optional[&#39;ProcessingReport&#39;] = None,
        allow_overwrite_hill_coefficients: bool = False,
        **fit_params
    ) -&gt; Tuple[&#39;ScreeningDataset&#39;, &#39;ProcessingReport&#39;]:
        &#34;&#34;&#34;
        Process raw data into ScreeningDataset with quality reporting.
        
        For each profile:
        1. Fit Hill curve when raw data exists, or use pre-calc when no raw.
        2. Always compute S&#39; from Hill params; warn if S&#39; was provided in input and is overwritten.
        
        When both raw data and pre-calc (AC50/Upper/Lower/Hill_Slope/r2) exist:
        - allow_overwrite_hill_coefficients=False (default): raise (would overwrite).
        - allow_overwrite_hill_coefficients=True: fit, overwrite pre-calc, and log
          a warning that pre-calc Hill params were overwritten.
        
        Args:
            report: Optional ProcessingReport to accumulate warnings (creates new if None)
            allow_overwrite_hill_coefficients: If True, allow overwriting pre-calc
                Hill params (AC50, Upper, Lower, Hill_Slope, r2) with fitted values.
                Default False: raise when we would overwrite.
            **fit_params: Parameters for curve fitting (e.g. maxfev, bounds).
            
        Returns:
            Tuple of (ScreeningDataset, ProcessingReport)
            
        Raises:
            ValueError: If profile cannot be processed, or would overwrite
                pre-calc Hill coefficients without allow_overwrite_hill_coefficients.
        &#34;&#34;&#34;
        if report is None:
            if ProcessingReport is not None:
                report = ProcessingReport()
            else:
                report = None
        
        screening_dataset = ScreeningDataset(assay=self.assay)
        
        for profile in self._profiles.values():
            processed_profile = DoseResponseProfile(
                compound=profile.compound,
                cell_line=profile.cell_line,
                assay=profile.assay,
                concentrations=profile.concentrations,
                responses=profile.responses,
                concentration_units=profile.concentration_units,
                hill_params=profile.hill_params,
                s_prime=profile.s_prime,
                rank=profile.rank,
                metadata=profile.metadata
            )
            
            has_raw = (
                processed_profile.concentrations is not None
                and processed_profile.responses is not None
                and len(processed_profile.concentrations) &gt; 0
            )
            had_precalc = processed_profile.hill_params is not None
            
            if has_raw:
                if had_precalc and not allow_overwrite_hill_coefficients:
                    raise ValueError(
                        f&#34;Pre-calculated Hill parameters (AC50, Upper, Lower, Hill_Slope, r2) would be &#34;
                        f&#34;overwritten by fitted values for compound &#39;{processed_profile.compound.name}&#39; &#34;
                        f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                        f&#34;&#39;{processed_profile.cell_line.name}&#39;. &#34;
                        f&#34;Set allow_overwrite_hill_coefficients=True to permit.&#34;
                    )
                processed_profile.hill_params = None
                try:
                    processed_profile.fit_hill_curve(**fit_params)
                except (RuntimeError, ValueError) as e:
                    raise ValueError(
                        f&#34;Curve fitting failed for compound &#39;{processed_profile.compound.name}&#39; &#34;
                        f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                        f&#34;&#39;{processed_profile.cell_line.name}&#39;: {str(e)}&#34;
                    )
                if had_precalc:
                    msg = (
                        f&#34;Pre-calc Hill parameters (AC50, Upper, Lower, Hill_Slope, r2) overwritten by &#34;
                        f&#34;fitted values for &#39;{processed_profile.compound.name}&#39; / &#34;
                        f&#34;&#39;{processed_profile.cell_line.name}&#39;.&#34;
                    )
                    warnings.warn(msg, UserWarning, stacklevel=2)
                    if report:
                        report.add_warning(
                            row_number=0,
                            category=&#34;OVERWRITE_HILL&#34;,
                            message=msg,
                            drug_id=processed_profile.compound.drug_id,
                            compound_name=processed_profile.compound.name,
                            cell_line=processed_profile.cell_line.name,
                        )
            else:
                if processed_profile.hill_params is None:
                    raise ValueError(
                        f&#34;No data available to process for compound &#39;{processed_profile.compound.name}&#39; &#34;
                        f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                        f&#34;&#39;{processed_profile.cell_line.name}&#39;. Profile has neither raw data &#34;
                        f&#34;(concentrations/responses) nor pre-calculated Hill curve parameters.&#34;
                    )
                msg = (
                    f&#34;Using pre-calc Hill parameters as-is for &#39;{processed_profile.compound.name}&#39; / &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39; (no raw data).&#34;
                )
                warnings.warn(msg, UserWarning, stacklevel=2)
                if report:
                    report.add_warning(
                        row_number=0,
                        category=&#34;PRE_CALC_ONLY&#34;,
                        message=msg,
                        drug_id=processed_profile.compound.drug_id,
                        compound_name=processed_profile.compound.name,
                        cell_line=processed_profile.cell_line.name,
                    )
            
            # Check fit quality
            if report and processed_profile.hill_params and processed_profile.hill_params.r_squared is not None:
                if processed_profile.hill_params.r_squared &lt; 0.7:
                    report.add_warning(
                        row_number=0,
                        category=&#34;CURVE_FIT&#34;,
                        message=f&#34;Poor fit quality: R² = {processed_profile.hill_params.r_squared:.3f}&#34;,
                        drug_id=processed_profile.compound.drug_id,
                        compound_name=processed_profile.compound.name,
                        cell_line=processed_profile.cell_line.name
                    )
            
            # Always compute S&#39;; warn if overwriting existing S&#39; from CSV
            if processed_profile.s_prime is not None:
                msg = (
                    f&#34;S&#39; overwritten by recomputation for &#39;{processed_profile.compound.name}&#39; / &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39; (S&#39; was provided in input).&#34;
                )
                warnings.warn(msg, UserWarning, stacklevel=2)
                if report:
                    report.add_warning(
                        row_number=0,
                        category=&#34;OVERWRITE_S_PRIME&#34;,
                        message=msg,
                        drug_id=processed_profile.compound.drug_id,
                        compound_name=processed_profile.compound.name,
                        cell_line=processed_profile.cell_line.name,
                    )
            try:
                processed_profile.calculate_s_prime()
            except Exception as e:
                raise ValueError(
                    f&#34;S&#39; calculation failed for compound &#39;{processed_profile.compound.name}&#39; &#34;
                    f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;: {str(e)}&#34;
                )
            
            # Validate S&#39; was calculated
            if processed_profile.s_prime is None:
                raise ValueError(
                    f&#34;S&#39; calculation returned None for compound &#39;{processed_profile.compound.name}&#39; &#34;
                    f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;. This indicates invalid Hill curve parameters.&#34;
                )
            
            # Add profile to screening dataset
            try:
                screening_dataset.add_profile(processed_profile)
                if report:
                    report.profiles_with_s_prime += 1
            except ValueError as e:
                # Profile already exists or invalid - re-raise with context
                raise ValueError(
                    f&#34;Cannot add profile for compound &#39;{processed_profile.compound.name}&#39; &#34;
                    f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;: {str(e)}&#34;
                )
        
        if report is None:
            # Return dummy report if reporting not available
            return screening_dataset, None
        return screening_dataset, report
    
    @property
    def profiles(self):
        &#34;&#34;&#34;Iterator over all profiles&#34;&#34;&#34;
        return self._profiles.values()
    
    def __len__(self):
        return len(self._profiles)</code></pre>
</details>
<div class="desc"><p>Holds raw dose-response curve data loaded from CSV/files.</p>
<p>Focus: Data loading, validation, basic structure.
May contain profiles with raw data (concentrations/responses) or
pre-calculated Hill params from CSV.</p>
<p>Initialize RawDataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assay</code></strong></dt>
<dd>Assay entity for this dataset</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="sprime.sprime.RawDataset.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>filepath: str | pathlib.Path,<br>assay_name: str | None = None,<br>report: ForwardRef('ProcessingReport') | None = None,<br>values_as: str = 'columns',<br>**csv_kwargs) ‑> Tuple[<a title="sprime.sprime.RawDataset" href="#sprime.sprime.RawDataset">RawDataset</a>, <a title="sprime.reporting.ProcessingReport" href="reporting.html#sprime.reporting.ProcessingReport">ProcessingReport</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load CSV file and create RawDataset with quality reporting.</p>
<p>Handles:
- Extracting raw data (Data0..DataN, Conc0..ConcN) or Responses/Concentrations
- Loading pre-calculated params (AC50, Upper, Lower) if present
- Creating DoseResponseProfile objects
- Tracking data quality issues and warnings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to CSV file</dd>
<dt><strong><code>assay_name</code></strong></dt>
<dd>Name for assay (defaults to filename stem)</dd>
<dt><strong><code>report</code></strong></dt>
<dd>Optional ProcessingReport to accumulate warnings (creates new if None)</dd>
<dt><strong><code>values_as</code></strong></dt>
<dd>"columns" (DATA<em>/CONC</em>) or "list" (Responses, Concentrations)</dd>
<dt><strong><code>**csv_kwargs</code></strong></dt>
<dd>Additional arguments for csv.DictReader</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (RawDataset, ProcessingReport)</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.RawDataset.profiles"><code class="name">prop <span class="ident">profiles</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def profiles(self):
    &#34;&#34;&#34;Iterator over all profiles&#34;&#34;&#34;
    return self._profiles.values()</code></pre>
</details>
<div class="desc"><p>Iterator over all profiles</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sprime.sprime.RawDataset.add_profile"><code class="name flex">
<span>def <span class="ident">add_profile</span></span>(<span>self,<br>profile: <a title="sprime.sprime.DoseResponseProfile" href="#sprime.sprime.DoseResponseProfile">DoseResponseProfile</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_profile(self, profile: DoseResponseProfile):
    &#34;&#34;&#34;
    Add a profile to the dataset.
    
    Args:
        profile: DoseResponseProfile to add
        
    Raises:
        ValueError: If profile for this compound-cellline pair already exists
    &#34;&#34;&#34;
    key = (profile.compound.drug_id, profile.cell_line.name)
    if key in self._profiles:
        raise ValueError(f&#34;Profile for {key} already exists&#34;)
    self._profiles[key] = profile</code></pre>
</details>
<div class="desc"><p>Add a profile to the dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>profile</code></strong></dt>
<dd>DoseResponseProfile to add</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If profile for this compound-cellline pair already exists</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.RawDataset.get_profile"><code class="name flex">
<span>def <span class="ident">get_profile</span></span>(<span>self,<br>compound: <a title="sprime.sprime.Compound" href="#sprime.sprime.Compound">Compound</a> | str,<br>cell_line: <a title="sprime.sprime.CellLine" href="#sprime.sprime.CellLine">CellLine</a> | str) ‑> <a title="sprime.sprime.DoseResponseProfile" href="#sprime.sprime.DoseResponseProfile">DoseResponseProfile</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_profile(self, compound: Union[Compound, str], 
                cell_line: Union[CellLine, str]) -&gt; Optional[DoseResponseProfile]:
    &#34;&#34;&#34;
    Retrieve a specific profile.
    
    Args:
        compound: Compound object or drug_id string
        cell_line: CellLine object or cell_line name string
        
    Returns:
        DoseResponseProfile or None if not found
    &#34;&#34;&#34;
    compound_id = compound.drug_id if isinstance(compound, Compound) else compound
    cellline_name = cell_line.name if isinstance(cell_line, CellLine) else cell_line
    return self._profiles.get((compound_id, cellline_name))</code></pre>
</details>
<div class="desc"><p>Retrieve a specific profile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compound</code></strong></dt>
<dd>Compound object or drug_id string</dd>
<dt><strong><code>cell_line</code></strong></dt>
<dd>CellLine object or cell_line name string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DoseResponseProfile or None if not found</p></div>
</dd>
<dt id="sprime.sprime.RawDataset.to_screening_dataset"><code class="name flex">
<span>def <span class="ident">to_screening_dataset</span></span>(<span>self,<br>report: ForwardRef('ProcessingReport') | None = None,<br>allow_overwrite_hill_coefficients: bool = False,<br>**fit_params) ‑> Tuple[<a title="sprime.sprime.ScreeningDataset" href="#sprime.sprime.ScreeningDataset">ScreeningDataset</a>, <a title="sprime.reporting.ProcessingReport" href="reporting.html#sprime.reporting.ProcessingReport">ProcessingReport</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_screening_dataset(
    self,
    report: Optional[&#39;ProcessingReport&#39;] = None,
    allow_overwrite_hill_coefficients: bool = False,
    **fit_params
) -&gt; Tuple[&#39;ScreeningDataset&#39;, &#39;ProcessingReport&#39;]:
    &#34;&#34;&#34;
    Process raw data into ScreeningDataset with quality reporting.
    
    For each profile:
    1. Fit Hill curve when raw data exists, or use pre-calc when no raw.
    2. Always compute S&#39; from Hill params; warn if S&#39; was provided in input and is overwritten.
    
    When both raw data and pre-calc (AC50/Upper/Lower/Hill_Slope/r2) exist:
    - allow_overwrite_hill_coefficients=False (default): raise (would overwrite).
    - allow_overwrite_hill_coefficients=True: fit, overwrite pre-calc, and log
      a warning that pre-calc Hill params were overwritten.
    
    Args:
        report: Optional ProcessingReport to accumulate warnings (creates new if None)
        allow_overwrite_hill_coefficients: If True, allow overwriting pre-calc
            Hill params (AC50, Upper, Lower, Hill_Slope, r2) with fitted values.
            Default False: raise when we would overwrite.
        **fit_params: Parameters for curve fitting (e.g. maxfev, bounds).
        
    Returns:
        Tuple of (ScreeningDataset, ProcessingReport)
        
    Raises:
        ValueError: If profile cannot be processed, or would overwrite
            pre-calc Hill coefficients without allow_overwrite_hill_coefficients.
    &#34;&#34;&#34;
    if report is None:
        if ProcessingReport is not None:
            report = ProcessingReport()
        else:
            report = None
    
    screening_dataset = ScreeningDataset(assay=self.assay)
    
    for profile in self._profiles.values():
        processed_profile = DoseResponseProfile(
            compound=profile.compound,
            cell_line=profile.cell_line,
            assay=profile.assay,
            concentrations=profile.concentrations,
            responses=profile.responses,
            concentration_units=profile.concentration_units,
            hill_params=profile.hill_params,
            s_prime=profile.s_prime,
            rank=profile.rank,
            metadata=profile.metadata
        )
        
        has_raw = (
            processed_profile.concentrations is not None
            and processed_profile.responses is not None
            and len(processed_profile.concentrations) &gt; 0
        )
        had_precalc = processed_profile.hill_params is not None
        
        if has_raw:
            if had_precalc and not allow_overwrite_hill_coefficients:
                raise ValueError(
                    f&#34;Pre-calculated Hill parameters (AC50, Upper, Lower, Hill_Slope, r2) would be &#34;
                    f&#34;overwritten by fitted values for compound &#39;{processed_profile.compound.name}&#39; &#34;
                    f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;. &#34;
                    f&#34;Set allow_overwrite_hill_coefficients=True to permit.&#34;
                )
            processed_profile.hill_params = None
            try:
                processed_profile.fit_hill_curve(**fit_params)
            except (RuntimeError, ValueError) as e:
                raise ValueError(
                    f&#34;Curve fitting failed for compound &#39;{processed_profile.compound.name}&#39; &#34;
                    f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;: {str(e)}&#34;
                )
            if had_precalc:
                msg = (
                    f&#34;Pre-calc Hill parameters (AC50, Upper, Lower, Hill_Slope, r2) overwritten by &#34;
                    f&#34;fitted values for &#39;{processed_profile.compound.name}&#39; / &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;.&#34;
                )
                warnings.warn(msg, UserWarning, stacklevel=2)
                if report:
                    report.add_warning(
                        row_number=0,
                        category=&#34;OVERWRITE_HILL&#34;,
                        message=msg,
                        drug_id=processed_profile.compound.drug_id,
                        compound_name=processed_profile.compound.name,
                        cell_line=processed_profile.cell_line.name,
                    )
        else:
            if processed_profile.hill_params is None:
                raise ValueError(
                    f&#34;No data available to process for compound &#39;{processed_profile.compound.name}&#39; &#34;
                    f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                    f&#34;&#39;{processed_profile.cell_line.name}&#39;. Profile has neither raw data &#34;
                    f&#34;(concentrations/responses) nor pre-calculated Hill curve parameters.&#34;
                )
            msg = (
                f&#34;Using pre-calc Hill parameters as-is for &#39;{processed_profile.compound.name}&#39; / &#34;
                f&#34;&#39;{processed_profile.cell_line.name}&#39; (no raw data).&#34;
            )
            warnings.warn(msg, UserWarning, stacklevel=2)
            if report:
                report.add_warning(
                    row_number=0,
                    category=&#34;PRE_CALC_ONLY&#34;,
                    message=msg,
                    drug_id=processed_profile.compound.drug_id,
                    compound_name=processed_profile.compound.name,
                    cell_line=processed_profile.cell_line.name,
                )
        
        # Check fit quality
        if report and processed_profile.hill_params and processed_profile.hill_params.r_squared is not None:
            if processed_profile.hill_params.r_squared &lt; 0.7:
                report.add_warning(
                    row_number=0,
                    category=&#34;CURVE_FIT&#34;,
                    message=f&#34;Poor fit quality: R² = {processed_profile.hill_params.r_squared:.3f}&#34;,
                    drug_id=processed_profile.compound.drug_id,
                    compound_name=processed_profile.compound.name,
                    cell_line=processed_profile.cell_line.name
                )
        
        # Always compute S&#39;; warn if overwriting existing S&#39; from CSV
        if processed_profile.s_prime is not None:
            msg = (
                f&#34;S&#39; overwritten by recomputation for &#39;{processed_profile.compound.name}&#39; / &#34;
                f&#34;&#39;{processed_profile.cell_line.name}&#39; (S&#39; was provided in input).&#34;
            )
            warnings.warn(msg, UserWarning, stacklevel=2)
            if report:
                report.add_warning(
                    row_number=0,
                    category=&#34;OVERWRITE_S_PRIME&#34;,
                    message=msg,
                    drug_id=processed_profile.compound.drug_id,
                    compound_name=processed_profile.compound.name,
                    cell_line=processed_profile.cell_line.name,
                )
        try:
            processed_profile.calculate_s_prime()
        except Exception as e:
            raise ValueError(
                f&#34;S&#39; calculation failed for compound &#39;{processed_profile.compound.name}&#39; &#34;
                f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                f&#34;&#39;{processed_profile.cell_line.name}&#39;: {str(e)}&#34;
            )
        
        # Validate S&#39; was calculated
        if processed_profile.s_prime is None:
            raise ValueError(
                f&#34;S&#39; calculation returned None for compound &#39;{processed_profile.compound.name}&#39; &#34;
                f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                f&#34;&#39;{processed_profile.cell_line.name}&#39;. This indicates invalid Hill curve parameters.&#34;
            )
        
        # Add profile to screening dataset
        try:
            screening_dataset.add_profile(processed_profile)
            if report:
                report.profiles_with_s_prime += 1
        except ValueError as e:
            # Profile already exists or invalid - re-raise with context
            raise ValueError(
                f&#34;Cannot add profile for compound &#39;{processed_profile.compound.name}&#39; &#34;
                f&#34;(Compound_ID: {processed_profile.compound.drug_id}) in cell line &#34;
                f&#34;&#39;{processed_profile.cell_line.name}&#39;: {str(e)}&#34;
            )
    
    if report is None:
        # Return dummy report if reporting not available
        return screening_dataset, None
    return screening_dataset, report</code></pre>
</details>
<div class="desc"><p>Process raw data into ScreeningDataset with quality reporting.</p>
<p>For each profile:
1. Fit Hill curve when raw data exists, or use pre-calc when no raw.
2. Always compute S' from Hill params; warn if S' was provided in input and is overwritten.</p>
<p>When both raw data and pre-calc (AC50/Upper/Lower/Hill_Slope/r2) exist:
- allow_overwrite_hill_coefficients=False (default): raise (would overwrite).
- allow_overwrite_hill_coefficients=True: fit, overwrite pre-calc, and log
a warning that pre-calc Hill params were overwritten.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>report</code></strong></dt>
<dd>Optional ProcessingReport to accumulate warnings (creates new if None)</dd>
<dt><strong><code>allow_overwrite_hill_coefficients</code></strong></dt>
<dd>If True, allow overwriting pre-calc
Hill params (AC50, Upper, Lower, Hill_Slope, r2) with fitted values.
Default False: raise when we would overwrite.</dd>
<dt><strong><code>**fit_params</code></strong></dt>
<dd>Parameters for curve fitting (e.g. maxfev, bounds).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (ScreeningDataset, ProcessingReport)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If profile cannot be processed, or would overwrite
pre-calc Hill coefficients without allow_overwrite_hill_coefficients.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.SPrime"><code class="flex name class">
<span>class <span class="ident">SPrime</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SPrime:
    &#34;&#34;&#34;
    Main API for sprime package.
    
    Provides factory methods and convenience functions for loading data,
    processing dose-response profiles, and calculating S&#39; values.
    &#34;&#34;&#34;
    
    @staticmethod
    def load(
        filepath: Union[str, Path],
        assay_name: Optional[str] = None,
        values_as: str = &#34;columns&#34;,
        **csv_kwargs
    ) -&gt; Tuple[RawDataset, Optional[&#39;ProcessingReport&#39;]]:
        &#34;&#34;&#34;
        Load raw data from CSV file or pandas DataFrame with quality reporting.
        
        Auto-detects pandas DataFrame input and converts it. For CSV files,
        uses global reporting configuration for console/log output.
        
        Args:
            filepath: Path to CSV file, or pandas DataFrame
            assay_name: Name for assay (defaults to filename stem or &#39;DataFrame&#39;)
            values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
            **csv_kwargs: Additional arguments for csv.DictReader (ignored for DataFrames)
            
        Returns:
            Tuple of (RawDataset, ProcessingReport)
            
        Raises:
            ValueError: If required columns are missing
            ImportError: If DataFrame provided but pandas not installed
        &#34;&#34;&#34;
        # Auto-detect DataFrame
        try:
            import pandas as pd
            if isinstance(filepath, pd.DataFrame):
                return SPrime.load_from_dataframe(filepath, assay_name, values_as=values_as)
        except ImportError:
            pass  # pandas not available, treat as file path
        except (AttributeError, TypeError):
            pass  # Not a DataFrame, treat as file path
        
        # Treat as file path
        raw_dataset, report = RawDataset.load_from_file(
            filepath, assay_name, values_as=values_as, **csv_kwargs
        )
        
        # Auto-print and write log based on global config
        if report and ReportingConfig is not None:
            report.print_console_summary()
            report.write_log_file()
        
        return raw_dataset, report
    
    @staticmethod
    def load_from_dataframe(
        df,
        assay_name: Optional[str] = None,
        values_as: str = &#34;columns&#34;,
    ) -&gt; Tuple[RawDataset, Optional[&#39;ProcessingReport&#39;]]:
        &#34;&#34;&#34;
        Load raw data from pandas DataFrame with quality reporting.
        
        Args:
            df: pandas DataFrame with columns matching CSV format
            assay_name: Name for assay (defaults to &#39;DataFrame&#39;)
            values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
            
        Returns:
            Tuple of (RawDataset, ProcessingReport)
            
        Raises:
            ValueError: If required columns are missing
            ImportError: If pandas is not installed
            TypeError: If input is not a pandas DataFrame
        &#34;&#34;&#34;
        # Convert DataFrame to list of dicts
        list_of_rows = _convert_dataframe_to_dict_list(df)
        
        # Use get_s_prime_from_data logic but return RawDataset
        if not list_of_rows:
            # Create empty dataset
            if assay_name is None:
                assay_name = &#34;DataFrame&#34;
            assay = Assay(name=assay_name)
            raw_dataset = RawDataset(assay=assay)
            if ProcessingReport is not None:
                report = ProcessingReport()
            else:
                report = None
            return raw_dataset, report
        
        # Validate required columns exist
        first_row_keys = list(list_of_rows[0].keys()) if list_of_rows else []
        if first_row_keys:
            _validate_required_columns(
                first_row_keys, source_name=&#34;DataFrame&#34;, values_as=values_as
            )
        
        # Create report
        if ProcessingReport is not None:
            report = ProcessingReport()
        else:
            report = None
        
        # Create RawDataset
        if assay_name is None:
            assay_name = &#34;DataFrame&#34;
        assay = Assay(name=assay_name)
        raw_dataset = RawDataset(assay=assay)
        
        if report:
            report.total_rows = len(list_of_rows)
        
        # Process rows (similar to get_s_prime_from_data but add to RawDataset)
        # Rows are taken literally: empty values are null, no forward-filling.
        reserved = _reserved_column_names(values_as, first_row_keys)
        compounds_seen = set()
        
        for row_idx, row in enumerate(list_of_rows):
            if report:
                report.rows_processed += 1
            
            # Check if row is fully blank
            is_fully_blank = not any(
                v.strip() if isinstance(v, str) else str(v).strip()
                for v in row.values() if v
            )
            
            if is_fully_blank:
                continue
            
            # Check for empty cell line - RAISE EXCEPTION
            cell_line_name = row.get(&#39;Cell_Line&#39;, &#39;&#39;).strip()
            if not cell_line_name:
                raise ValueError(
                    f&#34;Row {row_idx + 1}: Missing required &#39;Cell_Line&#39; value in DataFrame. &#34;
                    f&#34;All rows must have a cell line specified.&#34;
                )
            
            # Get compound info (Compound_ID required; NCGCID pass-through only)
            compound_name = row.get(&#39;Compound Name&#39;, &#39;&#39;).strip() or &#39;Unknown&#39;
            compound_id = row.get(&#39;Compound_ID&#39;, &#39;&#39;).strip()
            
            if not compound_id:
                raise ValueError(
                    f&#34;Row {row_idx + 1}: Missing required &#39;Compound_ID&#39; value in DataFrame. &#34;
                    f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                    f&#34;All rows must have a compound identifier.&#34;
                )
            
            # Track compound
            if report and compound_id not in compounds_seen:
                compounds_seen.add(compound_id)
                report.compounds_loaded += 1
            
            # Create compound and cell line objects
            compound = Compound(
                name=compound_name,
                drug_id=compound_id,
                pubchem_sid=row.get(&#39;pubchem_sid&#39;, &#39;&#39;).strip() or None,
                smiles=row.get(&#39;SMILES&#39;, &#39;&#39;).strip() or None
            )
            
            cell_line = CellLine(
                name=cell_line_name,
                ref_id=row.get(&#39;Cell_Line_Ref_ID&#39;, &#39;&#39;).strip() or None
            )
            
            # Extract raw dose-response data (if present)
            concentrations = None
            responses = None
            
            if values_as == &#34;list&#34;:
                resp_key = next((k for k in row if k.lower() == &#39;responses&#39;), None)
                conc_key = next((k for k in row if k.lower() == &#39;concentrations&#39;), None)
                if resp_key and conc_key:
                    resp_str = (row.get(resp_key) or &#39;&#39;).strip()
                    conc_str = (row.get(conc_key) or &#39;&#39;).strip()
                    if resp_str and conc_str:
                        responses = []
                        conc_parts = []
                        for part in resp_str.split(&#39;,&#39;):
                            t = part.strip()
                            if t:
                                try:
                                    v = float(t)
                                    if not (math.isnan(v) or math.isinf(v)):
                                        responses.append(v)
                                except (ValueError, TypeError):
                                    pass
                        for part in conc_str.split(&#39;,&#39;):
                            t = part.strip()
                            if t:
                                try:
                                    v = float(t)
                                    if not (math.isnan(v) or math.isinf(v)):
                                        conc_parts.append(v)
                                except (ValueError, TypeError):
                                    pass
                        if len(responses) == len(conc_parts) and len(responses) &gt;= 4:
                            units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                            if not units:
                                raise ValueError(
                                    f&#34;Row {row_idx + 1}: Missing required &#39;Concentration_Units&#39; for raw data in DataFrame. &#34;
                                    f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}.&#34;
                                )
                            concentrations = convert_to_micromolar(conc_parts, units)
                        else:
                            if len(responses) != len(conc_parts):
                                raise ValueError(
                                    f&#34;Row {row_idx + 1}: Responses and Concentrations length mismatch &#34;
                                    f&#34;({len(responses)} vs {len(conc_parts)}) in DataFrame.&#34;
                                )
                            responses = None
                            concentrations = None
            
            else:
                data_cols = [k for k in row.keys() if k.startswith(&#39;Data&#39;) or k.startswith(&#39;DATA&#39;)]
                conc_cols = [k for k in row.keys() 
                            if (k.startswith(&#39;Conc&#39;) or k.startswith(&#39;CONC&#39;)) 
                            and &#39;Units&#39; not in k and &#39;units&#39; not in k]
                if data_cols and conc_cols:
                    data_cols = sorted(data_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                    conc_cols = sorted(conc_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                    responses = []
                    concentrations = []
                    for data_col, conc_col in zip(data_cols, conc_cols):
                        try:
                            resp_val = row.get(data_col, &#39;&#39;) or &#39;&#39;
                            conc_val = row.get(conc_col, &#39;&#39;) or &#39;&#39;
                            resp_val = resp_val.strip() if isinstance(resp_val, str) else str(resp_val)
                            conc_val = conc_val.strip() if isinstance(conc_val, str) else str(conc_val)
                            if resp_val and conc_val:
                                responses.append(float(resp_val))
                                concentrations.append(float(conc_val))
                        except (ValueError, TypeError):
                            continue
                    if concentrations and responses:
                        units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                        if not units:
                            raise ValueError(
                                f&#34;Row {row_idx + 1}: Missing required &#39;Concentration_Units&#39; for raw data in DataFrame. &#34;
                                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                                f&#34;Raw dose-response data requires Concentration_Units.&#34;
                            )
                        concentrations = convert_to_micromolar(concentrations, units)
                    else:
                        concentrations = None
                        responses = None
            
            # Extract pre-calculated Hill params (if present)
            hill_params = None
            ac50 = row.get(&#39;AC50&#39;, &#39;&#39;).strip() or row.get(&#39;ec50&#39;, &#39;&#39;).strip()
            if ac50:
                try:
                    hill_params = HillCurveParams(
                        ec50=float(ac50),
                        upper=float(row.get(&#39;Upper&#39;, row.get(&#39;Infinity&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                        lower=float(row.get(&#39;Lower&#39;, row.get(&#39;Zero&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                        hill_coefficient=_try_float(row.get(&#39;Hill_Slope&#39;, row.get(&#39;Hill&#39;, row.get(&#39;slope&#39;, &#39;&#39;)))),
                        r_squared=_try_float(row.get(&#39;r2&#39;, row.get(&#39;R²&#39;, &#39;&#39;)))
                    )
                except (ValueError, TypeError):
                    hill_params = None
            
            # Validate that row has either raw data or pre-calculated params
            has_raw_data = concentrations is not None and responses is not None and len(concentrations) &gt; 0
            has_precalc_params = hill_params is not None
            
            if not (has_raw_data or has_precalc_params):
                raise ValueError(
                    f&#34;Row {row_idx + 1}: No dose-response data found for compound &#39;{compound_name}&#39; &#34;
                    f&#34;(Compound_ID: {compound_id}) in cell line &#39;{cell_line_name}&#39; in DataFrame. &#34;
                    f&#34;Row must have either: (1) raw data columns (DATA*/CONC*), or &#34;
                    f&#34;(2) pre-calculated parameters (AC50/Upper/Lower).&#34;
                )
            
            # Pre-calculated S&#39; (if present)
            s_prime = _try_float(row.get(&#34;S&#39;&#34;, row.get(&#39;S Prime&#39;, &#39;&#39;)))
            rank = _try_int(row.get(&#39;Rank&#39;, &#39;&#39;))
            
            # Extract metadata: generic pass-through (all non-reserved columns, exact header, value as-is)
            metadata = {}
            for col in row.keys():
                if col in reserved:
                    continue
                raw = row.get(col, &#34;&#34;)
                raw = raw if isinstance(raw, str) else str(raw)
                metadata[col] = raw
            
            # Create profile
            profile = DoseResponseProfile(
                compound=compound,
                cell_line=cell_line,
                assay=assay,
                concentrations=concentrations,
                responses=responses,
                concentration_units=&#34;microM&#34;,
                hill_params=hill_params,
                s_prime=s_prime,
                rank=rank,
                metadata=metadata if metadata else None
            )
            
            raw_dataset.add_profile(profile)
            if report:
                report.profiles_created += 1
        
        # Auto-print and write log based on global config
        if report and ReportingConfig is not None:
            report.print_console_summary()
            report.write_log_file()
        
        return raw_dataset, report
    
    @staticmethod
    def process(
        raw_dataset: RawDataset,
        report: Optional[&#39;ProcessingReport&#39;] = None,
        allow_overwrite_hill_coefficients: bool = False,
        **fit_params
    ) -&gt; Tuple[ScreeningDataset, Optional[&#39;ProcessingReport&#39;]]:
        &#34;&#34;&#34;
        Convert RawDataset to ScreeningDataset (fit curves, calculate S&#39;).
        
        Uses global reporting configuration for console/log output.
        
        Args:
            raw_dataset: RawDataset to process
            report: Optional ProcessingReport to accumulate warnings (reuses from load if None)
            allow_overwrite_hill_coefficients: If True, allow overwriting pre-calc
                Hill params (AC50, Upper, Lower, Hill_Slope, r2) with fitted values when
                both raw and pre-calc exist. Default False (raise). When True,
                overwrites are logged as warnings.
            **fit_params: Parameters for curve fitting (e.g. maxfev, bounds).
            
        Returns:
            Tuple of (ScreeningDataset, ProcessingReport)
        &#34;&#34;&#34;
        screening_dataset, report = raw_dataset.to_screening_dataset(
            report=report,
            allow_overwrite_hill_coefficients=allow_overwrite_hill_coefficients,
            **fit_params
        )
        
        # Auto-print and write log based on global config
        if report and ReportingConfig is not None:
            report.print_console_summary()
            report.write_log_file()
        
        return screening_dataset, report</code></pre>
</details>
<div class="desc"><p>Main API for sprime package.</p>
<p>Provides factory methods and convenience functions for loading data,
processing dose-response profiles, and calculating S' values.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="sprime.sprime.SPrime.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filepath: str | pathlib.Path,<br>assay_name: str | None = None,<br>values_as: str = 'columns',<br>**csv_kwargs) ‑> Tuple[<a title="sprime.sprime.RawDataset" href="#sprime.sprime.RawDataset">RawDataset</a>, <a title="sprime.reporting.ProcessingReport" href="reporting.html#sprime.reporting.ProcessingReport">ProcessingReport</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(
    filepath: Union[str, Path],
    assay_name: Optional[str] = None,
    values_as: str = &#34;columns&#34;,
    **csv_kwargs
) -&gt; Tuple[RawDataset, Optional[&#39;ProcessingReport&#39;]]:
    &#34;&#34;&#34;
    Load raw data from CSV file or pandas DataFrame with quality reporting.
    
    Auto-detects pandas DataFrame input and converts it. For CSV files,
    uses global reporting configuration for console/log output.
    
    Args:
        filepath: Path to CSV file, or pandas DataFrame
        assay_name: Name for assay (defaults to filename stem or &#39;DataFrame&#39;)
        values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
        **csv_kwargs: Additional arguments for csv.DictReader (ignored for DataFrames)
        
    Returns:
        Tuple of (RawDataset, ProcessingReport)
        
    Raises:
        ValueError: If required columns are missing
        ImportError: If DataFrame provided but pandas not installed
    &#34;&#34;&#34;
    # Auto-detect DataFrame
    try:
        import pandas as pd
        if isinstance(filepath, pd.DataFrame):
            return SPrime.load_from_dataframe(filepath, assay_name, values_as=values_as)
    except ImportError:
        pass  # pandas not available, treat as file path
    except (AttributeError, TypeError):
        pass  # Not a DataFrame, treat as file path
    
    # Treat as file path
    raw_dataset, report = RawDataset.load_from_file(
        filepath, assay_name, values_as=values_as, **csv_kwargs
    )
    
    # Auto-print and write log based on global config
    if report and ReportingConfig is not None:
        report.print_console_summary()
        report.write_log_file()
    
    return raw_dataset, report</code></pre>
</details>
<div class="desc"><p>Load raw data from CSV file or pandas DataFrame with quality reporting.</p>
<p>Auto-detects pandas DataFrame input and converts it. For CSV files,
uses global reporting configuration for console/log output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to CSV file, or pandas DataFrame</dd>
<dt><strong><code>assay_name</code></strong></dt>
<dd>Name for assay (defaults to filename stem or 'DataFrame')</dd>
<dt><strong><code>values_as</code></strong></dt>
<dd>"columns" (DATA<em>/CONC</em>) or "list" (Responses, Concentrations)</dd>
<dt><strong><code>**csv_kwargs</code></strong></dt>
<dd>Additional arguments for csv.DictReader (ignored for DataFrames)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (RawDataset, ProcessingReport)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required columns are missing</dd>
<dt><code>ImportError</code></dt>
<dd>If DataFrame provided but pandas not installed</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.SPrime.load_from_dataframe"><code class="name flex">
<span>def <span class="ident">load_from_dataframe</span></span>(<span>df, assay_name: str | None = None, values_as: str = 'columns') ‑> Tuple[<a title="sprime.sprime.RawDataset" href="#sprime.sprime.RawDataset">RawDataset</a>, <a title="sprime.reporting.ProcessingReport" href="reporting.html#sprime.reporting.ProcessingReport">ProcessingReport</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_dataframe(
    df,
    assay_name: Optional[str] = None,
    values_as: str = &#34;columns&#34;,
) -&gt; Tuple[RawDataset, Optional[&#39;ProcessingReport&#39;]]:
    &#34;&#34;&#34;
    Load raw data from pandas DataFrame with quality reporting.
    
    Args:
        df: pandas DataFrame with columns matching CSV format
        assay_name: Name for assay (defaults to &#39;DataFrame&#39;)
        values_as: &#34;columns&#34; (DATA*/CONC*) or &#34;list&#34; (Responses, Concentrations)
        
    Returns:
        Tuple of (RawDataset, ProcessingReport)
        
    Raises:
        ValueError: If required columns are missing
        ImportError: If pandas is not installed
        TypeError: If input is not a pandas DataFrame
    &#34;&#34;&#34;
    # Convert DataFrame to list of dicts
    list_of_rows = _convert_dataframe_to_dict_list(df)
    
    # Use get_s_prime_from_data logic but return RawDataset
    if not list_of_rows:
        # Create empty dataset
        if assay_name is None:
            assay_name = &#34;DataFrame&#34;
        assay = Assay(name=assay_name)
        raw_dataset = RawDataset(assay=assay)
        if ProcessingReport is not None:
            report = ProcessingReport()
        else:
            report = None
        return raw_dataset, report
    
    # Validate required columns exist
    first_row_keys = list(list_of_rows[0].keys()) if list_of_rows else []
    if first_row_keys:
        _validate_required_columns(
            first_row_keys, source_name=&#34;DataFrame&#34;, values_as=values_as
        )
    
    # Create report
    if ProcessingReport is not None:
        report = ProcessingReport()
    else:
        report = None
    
    # Create RawDataset
    if assay_name is None:
        assay_name = &#34;DataFrame&#34;
    assay = Assay(name=assay_name)
    raw_dataset = RawDataset(assay=assay)
    
    if report:
        report.total_rows = len(list_of_rows)
    
    # Process rows (similar to get_s_prime_from_data but add to RawDataset)
    # Rows are taken literally: empty values are null, no forward-filling.
    reserved = _reserved_column_names(values_as, first_row_keys)
    compounds_seen = set()
    
    for row_idx, row in enumerate(list_of_rows):
        if report:
            report.rows_processed += 1
        
        # Check if row is fully blank
        is_fully_blank = not any(
            v.strip() if isinstance(v, str) else str(v).strip()
            for v in row.values() if v
        )
        
        if is_fully_blank:
            continue
        
        # Check for empty cell line - RAISE EXCEPTION
        cell_line_name = row.get(&#39;Cell_Line&#39;, &#39;&#39;).strip()
        if not cell_line_name:
            raise ValueError(
                f&#34;Row {row_idx + 1}: Missing required &#39;Cell_Line&#39; value in DataFrame. &#34;
                f&#34;All rows must have a cell line specified.&#34;
            )
        
        # Get compound info (Compound_ID required; NCGCID pass-through only)
        compound_name = row.get(&#39;Compound Name&#39;, &#39;&#39;).strip() or &#39;Unknown&#39;
        compound_id = row.get(&#39;Compound_ID&#39;, &#39;&#39;).strip()
        
        if not compound_id:
            raise ValueError(
                f&#34;Row {row_idx + 1}: Missing required &#39;Compound_ID&#39; value in DataFrame. &#34;
                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                f&#34;All rows must have a compound identifier.&#34;
            )
        
        # Track compound
        if report and compound_id not in compounds_seen:
            compounds_seen.add(compound_id)
            report.compounds_loaded += 1
        
        # Create compound and cell line objects
        compound = Compound(
            name=compound_name,
            drug_id=compound_id,
            pubchem_sid=row.get(&#39;pubchem_sid&#39;, &#39;&#39;).strip() or None,
            smiles=row.get(&#39;SMILES&#39;, &#39;&#39;).strip() or None
        )
        
        cell_line = CellLine(
            name=cell_line_name,
            ref_id=row.get(&#39;Cell_Line_Ref_ID&#39;, &#39;&#39;).strip() or None
        )
        
        # Extract raw dose-response data (if present)
        concentrations = None
        responses = None
        
        if values_as == &#34;list&#34;:
            resp_key = next((k for k in row if k.lower() == &#39;responses&#39;), None)
            conc_key = next((k for k in row if k.lower() == &#39;concentrations&#39;), None)
            if resp_key and conc_key:
                resp_str = (row.get(resp_key) or &#39;&#39;).strip()
                conc_str = (row.get(conc_key) or &#39;&#39;).strip()
                if resp_str and conc_str:
                    responses = []
                    conc_parts = []
                    for part in resp_str.split(&#39;,&#39;):
                        t = part.strip()
                        if t:
                            try:
                                v = float(t)
                                if not (math.isnan(v) or math.isinf(v)):
                                    responses.append(v)
                            except (ValueError, TypeError):
                                pass
                    for part in conc_str.split(&#39;,&#39;):
                        t = part.strip()
                        if t:
                            try:
                                v = float(t)
                                if not (math.isnan(v) or math.isinf(v)):
                                    conc_parts.append(v)
                            except (ValueError, TypeError):
                                pass
                    if len(responses) == len(conc_parts) and len(responses) &gt;= 4:
                        units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                        if not units:
                            raise ValueError(
                                f&#34;Row {row_idx + 1}: Missing required &#39;Concentration_Units&#39; for raw data in DataFrame. &#34;
                                f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}.&#34;
                            )
                        concentrations = convert_to_micromolar(conc_parts, units)
                    else:
                        if len(responses) != len(conc_parts):
                            raise ValueError(
                                f&#34;Row {row_idx + 1}: Responses and Concentrations length mismatch &#34;
                                f&#34;({len(responses)} vs {len(conc_parts)}) in DataFrame.&#34;
                            )
                        responses = None
                        concentrations = None
        
        else:
            data_cols = [k for k in row.keys() if k.startswith(&#39;Data&#39;) or k.startswith(&#39;DATA&#39;)]
            conc_cols = [k for k in row.keys() 
                        if (k.startswith(&#39;Conc&#39;) or k.startswith(&#39;CONC&#39;)) 
                        and &#39;Units&#39; not in k and &#39;units&#39; not in k]
            if data_cols and conc_cols:
                data_cols = sorted(data_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                conc_cols = sorted(conc_cols, key=lambda x: int(&#39;&#39;.join(filter(str.isdigit, x)) or &#39;0&#39;))
                responses = []
                concentrations = []
                for data_col, conc_col in zip(data_cols, conc_cols):
                    try:
                        resp_val = row.get(data_col, &#39;&#39;) or &#39;&#39;
                        conc_val = row.get(conc_col, &#39;&#39;) or &#39;&#39;
                        resp_val = resp_val.strip() if isinstance(resp_val, str) else str(resp_val)
                        conc_val = conc_val.strip() if isinstance(conc_val, str) else str(conc_val)
                        if resp_val and conc_val:
                            responses.append(float(resp_val))
                            concentrations.append(float(conc_val))
                    except (ValueError, TypeError):
                        continue
                if concentrations and responses:
                    units = row.get(&#39;Concentration_Units&#39;, &#39;&#39;).strip()
                    if not units:
                        raise ValueError(
                            f&#34;Row {row_idx + 1}: Missing required &#39;Concentration_Units&#39; for raw data in DataFrame. &#34;
                            f&#34;Compound: {compound_name}, Cell_Line: {cell_line_name}. &#34;
                            f&#34;Raw dose-response data requires Concentration_Units.&#34;
                        )
                    concentrations = convert_to_micromolar(concentrations, units)
                else:
                    concentrations = None
                    responses = None
        
        # Extract pre-calculated Hill params (if present)
        hill_params = None
        ac50 = row.get(&#39;AC50&#39;, &#39;&#39;).strip() or row.get(&#39;ec50&#39;, &#39;&#39;).strip()
        if ac50:
            try:
                hill_params = HillCurveParams(
                    ec50=float(ac50),
                    upper=float(row.get(&#39;Upper&#39;, row.get(&#39;Infinity&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                    lower=float(row.get(&#39;Lower&#39;, row.get(&#39;Zero&#39;, &#39;0&#39;)).strip() or &#39;0&#39;),
                    hill_coefficient=_try_float(row.get(&#39;Hill_Slope&#39;, row.get(&#39;Hill&#39;, row.get(&#39;slope&#39;, &#39;&#39;)))),
                    r_squared=_try_float(row.get(&#39;r2&#39;, row.get(&#39;R²&#39;, &#39;&#39;)))
                )
            except (ValueError, TypeError):
                hill_params = None
        
        # Validate that row has either raw data or pre-calculated params
        has_raw_data = concentrations is not None and responses is not None and len(concentrations) &gt; 0
        has_precalc_params = hill_params is not None
        
        if not (has_raw_data or has_precalc_params):
            raise ValueError(
                f&#34;Row {row_idx + 1}: No dose-response data found for compound &#39;{compound_name}&#39; &#34;
                f&#34;(Compound_ID: {compound_id}) in cell line &#39;{cell_line_name}&#39; in DataFrame. &#34;
                f&#34;Row must have either: (1) raw data columns (DATA*/CONC*), or &#34;
                f&#34;(2) pre-calculated parameters (AC50/Upper/Lower).&#34;
            )
        
        # Pre-calculated S&#39; (if present)
        s_prime = _try_float(row.get(&#34;S&#39;&#34;, row.get(&#39;S Prime&#39;, &#39;&#39;)))
        rank = _try_int(row.get(&#39;Rank&#39;, &#39;&#39;))
        
        # Extract metadata: generic pass-through (all non-reserved columns, exact header, value as-is)
        metadata = {}
        for col in row.keys():
            if col in reserved:
                continue
            raw = row.get(col, &#34;&#34;)
            raw = raw if isinstance(raw, str) else str(raw)
            metadata[col] = raw
        
        # Create profile
        profile = DoseResponseProfile(
            compound=compound,
            cell_line=cell_line,
            assay=assay,
            concentrations=concentrations,
            responses=responses,
            concentration_units=&#34;microM&#34;,
            hill_params=hill_params,
            s_prime=s_prime,
            rank=rank,
            metadata=metadata if metadata else None
        )
        
        raw_dataset.add_profile(profile)
        if report:
            report.profiles_created += 1
    
    # Auto-print and write log based on global config
    if report and ReportingConfig is not None:
        report.print_console_summary()
        report.write_log_file()
    
    return raw_dataset, report</code></pre>
</details>
<div class="desc"><p>Load raw data from pandas DataFrame with quality reporting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>pandas DataFrame with columns matching CSV format</dd>
<dt><strong><code>assay_name</code></strong></dt>
<dd>Name for assay (defaults to 'DataFrame')</dd>
<dt><strong><code>values_as</code></strong></dt>
<dd>"columns" (DATA<em>/CONC</em>) or "list" (Responses, Concentrations)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (RawDataset, ProcessingReport)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required columns are missing</dd>
<dt><code>ImportError</code></dt>
<dd>If pandas is not installed</dd>
<dt><code>TypeError</code></dt>
<dd>If input is not a pandas DataFrame</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.SPrime.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>raw_dataset: <a title="sprime.sprime.RawDataset" href="#sprime.sprime.RawDataset">RawDataset</a>,<br>report: ForwardRef('ProcessingReport') | None = None,<br>allow_overwrite_hill_coefficients: bool = False,<br>**fit_params) ‑> Tuple[<a title="sprime.sprime.ScreeningDataset" href="#sprime.sprime.ScreeningDataset">ScreeningDataset</a>, <a title="sprime.reporting.ProcessingReport" href="reporting.html#sprime.reporting.ProcessingReport">ProcessingReport</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process(
    raw_dataset: RawDataset,
    report: Optional[&#39;ProcessingReport&#39;] = None,
    allow_overwrite_hill_coefficients: bool = False,
    **fit_params
) -&gt; Tuple[ScreeningDataset, Optional[&#39;ProcessingReport&#39;]]:
    &#34;&#34;&#34;
    Convert RawDataset to ScreeningDataset (fit curves, calculate S&#39;).
    
    Uses global reporting configuration for console/log output.
    
    Args:
        raw_dataset: RawDataset to process
        report: Optional ProcessingReport to accumulate warnings (reuses from load if None)
        allow_overwrite_hill_coefficients: If True, allow overwriting pre-calc
            Hill params (AC50, Upper, Lower, Hill_Slope, r2) with fitted values when
            both raw and pre-calc exist. Default False (raise). When True,
            overwrites are logged as warnings.
        **fit_params: Parameters for curve fitting (e.g. maxfev, bounds).
        
    Returns:
        Tuple of (ScreeningDataset, ProcessingReport)
    &#34;&#34;&#34;
    screening_dataset, report = raw_dataset.to_screening_dataset(
        report=report,
        allow_overwrite_hill_coefficients=allow_overwrite_hill_coefficients,
        **fit_params
    )
    
    # Auto-print and write log based on global config
    if report and ReportingConfig is not None:
        report.print_console_summary()
        report.write_log_file()
    
    return screening_dataset, report</code></pre>
</details>
<div class="desc"><p>Convert RawDataset to ScreeningDataset (fit curves, calculate S').</p>
<p>Uses global reporting configuration for console/log output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_dataset</code></strong></dt>
<dd>RawDataset to process</dd>
<dt><strong><code>report</code></strong></dt>
<dd>Optional ProcessingReport to accumulate warnings (reuses from load if None)</dd>
<dt><strong><code>allow_overwrite_hill_coefficients</code></strong></dt>
<dd>If True, allow overwriting pre-calc
Hill params (AC50, Upper, Lower, Hill_Slope, r2) with fitted values when
both raw and pre-calc exist. Default False (raise). When True,
overwrites are logged as warnings.</dd>
<dt><strong><code>**fit_params</code></strong></dt>
<dd>Parameters for curve fitting (e.g. maxfev, bounds).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (ScreeningDataset, ProcessingReport)</p></div>
</dd>
</dl>
</dd>
<dt id="sprime.sprime.ScreeningDataset"><code class="flex name class">
<span>class <span class="ident">ScreeningDataset</span></span>
<span>(</span><span>assay: <a title="sprime.sprime.Assay" href="#sprime.sprime.Assay">Assay</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScreeningDataset:
    &#34;&#34;&#34;
    Processed dataset with all S&#39; values calculated.
    
    All profiles in this dataset:
    - Have fitted Hill curve parameters
    - Have calculated S&#39; values
    - Are ready for analysis operations
    &#34;&#34;&#34;
    
    def __init__(self, assay: Assay):
        &#34;&#34;&#34;
        Initialize ScreeningDataset.
        
        Args:
            assay: Assay entity for this dataset
        &#34;&#34;&#34;
        self.assay = assay
        self._profiles: Dict[Tuple[str, str], DoseResponseProfile] = {}
    
    def add_profile(self, profile: DoseResponseProfile):
        &#34;&#34;&#34;
        Add a profile (should have S&#39; calculated).
        
        Args:
            profile: DoseResponseProfile with S&#39; calculated
            
        Raises:
            ValueError: If profile doesn&#39;t have S&#39; or Hill params, or already exists
        &#34;&#34;&#34;
        # Validation: profile should be processed
        if profile.s_prime is None:
            raise ValueError(&#34;Profile must have S&#39; calculated before adding to ScreeningDataset&#34;)
        if profile.hill_params is None:
            raise ValueError(&#34;Profile must have Hill params before adding to ScreeningDataset&#34;)
        
        key = (profile.compound.drug_id, profile.cell_line.name)
        if key in self._profiles:
            raise ValueError(f&#34;Profile for {key} already exists&#34;)
        self._profiles[key] = profile
    
    def get_profile(self, compound: Union[Compound, str], 
                    cell_line: Union[CellLine, str]) -&gt; Optional[DoseResponseProfile]:
        &#34;&#34;&#34;
        Retrieve a specific profile.
        
        Args:
            compound: Compound object or drug_id string
            cell_line: CellLine object or cell_line name string
            
        Returns:
            DoseResponseProfile or None if not found
        &#34;&#34;&#34;
        compound_id = compound.drug_id if isinstance(compound, Compound) else compound
        cellline_name = cell_line.name if isinstance(cell_line, CellLine) else cell_line
        return self._profiles.get((compound_id, cellline_name))
    
    def calculate_delta_s_prime(
        self,
        reference_cell_lines: Union[str, List[str]],
        test_cell_lines: Union[str, List[str]],
        headings_one_to_one_in_ref_and_test: Optional[List[str]] = None,
        source_profile: Literal[&#34;ref&#34;, &#34;test&#34;] = &#34;test&#34;,
    ) -&gt; Dict[str, List[Dict]]:
        &#34;&#34;&#34;
        Calculate delta S&#39; = S&#39;(ref) - S&#39;(test) for each compound.
        
        Compound-level columns (1:1 per compound, not per cell line) auto-propagate:
        MOA and drug targets are reserved and always included; additional headings
        may be specified via headings_one_to_one_in_ref_and_test. Values are taken
        from the ref or test profile according to source_profile.
        
        Args:
            reference_cell_lines: Reference cell line name(s)
            test_cell_lines: Test cell line name(s)
            headings_one_to_one_in_ref_and_test: Optional list of metadata headings
                that exist 1:1 in ref and test; included in output, values from
                source_profile.
            source_profile: &#39;ref&#39; or &#39;test&#39;; which profile to use for compound-level
                values (MOA, drug targets, and optional headings).
            
        Returns:
            Dictionary with keys for each reference cell line, containing
            lists of dicts with delta S&#39; and compound-level fields per combo.
        &#34;&#34;&#34;
        ref_list = [reference_cell_lines] if isinstance(reference_cell_lines, str) else reference_cell_lines
        test_list = [test_cell_lines] if isinstance(test_cell_lines, str) else test_cell_lines
        extra_headings = headings_one_to_one_in_ref_and_test or []
        
        results = {}
        for ref_cellline in ref_list:
            rows = []
            compounds = {profile.compound.drug_id: profile.compound for profile in self._profiles.values()}
            
            for drug_id, compound in compounds.items():
                ref_profile = self.get_profile(compound, ref_cellline)
                if ref_profile is None or ref_profile.s_prime is None:
                    continue
                
                for test_cellline in test_list:
                    test_profile = self.get_profile(compound, test_cellline)
                    if test_profile is None or test_profile.s_prime is None:
                        continue
                    
                    delta = ref_profile.s_prime - test_profile.s_prime
                    source_meta = (ref_profile.metadata if source_profile == &#34;ref&#34; else test_profile.metadata) or {}
                    row = {
                        &#39;compound_name&#39;: compound.name,
                        &#39;drug_id&#39;: drug_id,
                        &#39;reference_cell_line&#39;: ref_cellline,
                        &#39;test_cell_line&#39;: test_cellline,
                        &#39;s_prime_ref&#39;: ref_profile.s_prime,
                        &#39;s_prime_test&#39;: test_profile.s_prime,
                        &#39;delta_s_prime&#39;: delta,
                        &#39;MOA&#39;: _resolve_moa(source_meta),
                        &#39;drug targets&#39;: _resolve_drug_targets(source_meta),
                    }
                    for h in extra_headings:
                        row[h] = source_meta.get(h, &#34;&#34;)
                    rows.append(row)
            
            results[ref_cellline] = rows
        
        return results
    
    def to_dict_list(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Export to list of dictionaries with all S&#39; values.
        
        Returns:
            List of dictionaries with profile data
        &#34;&#34;&#34;
        rows = []
        for profile in self._profiles.values():
            row = {
                &#39;compound_name&#39;: profile.compound.name,
                &#39;drug_id&#39;: profile.compound.drug_id,
                &#39;cell_line&#39;: profile.cell_line.name,
                &#39;s_prime&#39;: profile.s_prime,
                &#39;ec50&#39;: profile.hill_params.ec50 if profile.hill_params else None,
                &#39;upper&#39;: profile.hill_params.upper if profile.hill_params else None,
                &#39;lower&#39;: profile.hill_params.lower if profile.hill_params else None,
                &#39;rank&#39;: profile.rank,
            }
            if profile.hill_params:
                row[&#39;hill_coefficient&#39;] = profile.hill_params.hill_coefficient
                row[&#39;r_squared&#39;] = profile.hill_params.r_squared
            rows.append(row)
        return rows
    
    def export_to_csv(
        self,
        filepath: Union[str, Path],
        include_metadata: bool = True
    ) -&gt; None:
        &#34;&#34;&#34;
        Export all profiles to CSV file.
        
        Base columns (identifiers, Hill params, S&#39;, Rank) are always written.
        When include_metadata is True, all generic metadata keys (union across
        profiles) are included as pass-through columns.
        
        Args:
            filepath: Path to output CSV file
            include_metadata: When True, include all metadata columns. When False,
                only base columns.
        &#34;&#34;&#34;
        filepath = Path(filepath)
        profiles = sorted(self.profiles, key=lambda p: (p.compound.name, p.cell_line.name))
        
        base_fieldnames = [
            &#39;Compound Name&#39;, &#39;Compound_ID&#39;, &#39;pubchem_sid&#39;, &#39;SMILES&#39;,
            &#39;Cell_Line&#39;, &#39;Cell_Line_Ref_ID&#39;,
            &#39;EC50&#39;, &#39;Upper&#39;, &#39;Lower&#39;, &#39;Hill_Slope&#39;, &#39;r2&#39;,
            &#34;S&#39;&#34;, &#39;Rank&#39;
        ]
        all_meta_keys = sorted(set(
            k for p in profiles if p.metadata for k in p.metadata
        ))
        fieldnames = list(base_fieldnames)
        if include_metadata and all_meta_keys:
            fieldnames.extend(all_meta_keys)
        
        with open(filepath, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            
            for profile in profiles:
                meta = profile.metadata or {}
                row = {
                    &#39;Compound Name&#39;: profile.compound.name,
                    &#39;Compound_ID&#39;: profile.compound.drug_id,
                    &#39;pubchem_sid&#39;: profile.compound.pubchem_sid or &#39;&#39;,
                    &#39;SMILES&#39;: profile.compound.smiles or &#39;&#39;,
                    &#39;Cell_Line&#39;: profile.cell_line.name,
                    &#39;Cell_Line_Ref_ID&#39;: profile.cell_line.ref_id or &#39;&#39;,
                    &#39;EC50&#39;: f&#34;{profile.hill_params.ec50:.6e}&#34; if profile.hill_params else &#39;&#39;,
                    &#39;Upper&#39;: f&#34;{profile.hill_params.upper:.2f}&#34; if profile.hill_params else &#39;&#39;,
                    &#39;Lower&#39;: f&#34;{profile.hill_params.lower:.2f}&#34; if profile.hill_params else &#39;&#39;,
                    &#39;Hill_Slope&#39;: f&#34;{profile.hill_params.hill_coefficient:.4f}&#34; if profile.hill_params and profile.hill_params.hill_coefficient else &#39;&#39;,
                    &#39;r2&#39;: f&#34;{profile.hill_params.r_squared:.4f}&#34; if profile.hill_params and profile.hill_params.r_squared is not None else &#39;&#39;,
                    &#34;S&#39;&#34;: f&#34;{profile.s_prime:.4f}&#34; if profile.s_prime else &#39;&#39;,
                    &#39;Rank&#39;: str(profile.rank) if profile.rank else &#39;&#39;,
                }
                if include_metadata and all_meta_keys:
                    for k in all_meta_keys:
                        row[k] = meta.get(k, &#39;&#39;)
                
                writer.writerow(row)
    
    @staticmethod
    def export_delta_s_prime_to_csv(
        delta_results: Dict[str, List[Dict]],
        filepath: Union[str, Path],
        headings_one_to_one_in_ref_and_test: Optional[List[str]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Export delta S&#39; results to CSV file.
        
        Includes compound-level columns: MOA, drug targets (reserved), plus any
        headings specified in headings_one_to_one_in_ref_and_test. These must
        match the headings passed to calculate_delta_s_prime when producing
        delta_results.
        
        Args:
            delta_results: Dictionary from calculate_delta_s_prime()
            filepath: Path to output CSV file
            headings_one_to_one_in_ref_and_test: Optional list of metadata
                headings included in delta output (same as for calculate_delta_s_prime).
        &#34;&#34;&#34;
        filepath = Path(filepath)
        extra_headings = headings_one_to_one_in_ref_and_test or []
        
        flat_results = []
        for ref_cellline, comparisons in delta_results.items():
            for comp in comparisons:
                row = {
                    &#39;Compound Name&#39;: comp.get(&#39;compound_name&#39;, &#39;&#39;),
                    &#39;Compound_ID&#39;: comp.get(&#39;drug_id&#39;, &#39;&#39;),
                    &#39;Reference_Cell_Line&#39;: comp.get(&#39;reference_cell_line&#39;, &#39;&#39;),
                    &#39;Test_Cell_Line&#39;: comp.get(&#39;test_cell_line&#39;, &#39;&#39;),
                    &#34;S&#39; (Reference)&#34;: f&#34;{comp.get(&#39;s_prime_ref&#39;, 0.0):.4f}&#34;,
                    &#34;S&#39; (Test)&#34;: f&#34;{comp.get(&#39;s_prime_test&#39;, 0.0):.4f}&#34;,
                    &#34;Delta S&#39;&#34;: f&#34;{comp.get(&#39;delta_s_prime&#39;, 0.0):.4f}&#34;,
                    &#39;MOA&#39;: comp.get(&#39;MOA&#39;, &#39;&#39;),
                    &#39;drug targets&#39;: comp.get(&#39;drug targets&#39;, &#39;&#39;),
                }
                for h in extra_headings:
                    row[h] = comp.get(h, &#39;&#39;)
                flat_results.append(row)
        
        flat_results.sort(key=lambda x: float(x[&#34;Delta S&#39;&#34;]))
        for rank, result in enumerate(flat_results, start=1):
            result[&#39;Rank&#39;] = str(rank)
        
        fieldnames = [
            &#39;Rank&#39;, &#39;Compound Name&#39;, &#39;Compound_ID&#39;,
            &#39;Reference_Cell_Line&#39;, &#39;Test_Cell_Line&#39;,
            &#34;S&#39; (Reference)&#34;, &#34;S&#39; (Test)&#34;, &#34;Delta S&#39;&#34;,
            &#39;MOA&#39;, &#39;drug targets&#39;,
        ]
        fieldnames.extend(extra_headings)
        
        with open(filepath, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(flat_results)
    
    @property
    def profiles(self):
        &#34;&#34;&#34;Iterator over all profiles&#34;&#34;&#34;
        return self._profiles.values()
    
    def __len__(self):
        return len(self._profiles)</code></pre>
</details>
<div class="desc"><p>Processed dataset with all S' values calculated.</p>
<p>All profiles in this dataset:
- Have fitted Hill curve parameters
- Have calculated S' values
- Are ready for analysis operations</p>
<p>Initialize ScreeningDataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>assay</code></strong></dt>
<dd>Assay entity for this dataset</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="sprime.sprime.ScreeningDataset.export_delta_s_prime_to_csv"><code class="name flex">
<span>def <span class="ident">export_delta_s_prime_to_csv</span></span>(<span>delta_results: Dict[str, List[Dict]],<br>filepath: str | pathlib.Path,<br>headings_one_to_one_in_ref_and_test: List[str] | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def export_delta_s_prime_to_csv(
    delta_results: Dict[str, List[Dict]],
    filepath: Union[str, Path],
    headings_one_to_one_in_ref_and_test: Optional[List[str]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Export delta S&#39; results to CSV file.
    
    Includes compound-level columns: MOA, drug targets (reserved), plus any
    headings specified in headings_one_to_one_in_ref_and_test. These must
    match the headings passed to calculate_delta_s_prime when producing
    delta_results.
    
    Args:
        delta_results: Dictionary from calculate_delta_s_prime()
        filepath: Path to output CSV file
        headings_one_to_one_in_ref_and_test: Optional list of metadata
            headings included in delta output (same as for calculate_delta_s_prime).
    &#34;&#34;&#34;
    filepath = Path(filepath)
    extra_headings = headings_one_to_one_in_ref_and_test or []
    
    flat_results = []
    for ref_cellline, comparisons in delta_results.items():
        for comp in comparisons:
            row = {
                &#39;Compound Name&#39;: comp.get(&#39;compound_name&#39;, &#39;&#39;),
                &#39;Compound_ID&#39;: comp.get(&#39;drug_id&#39;, &#39;&#39;),
                &#39;Reference_Cell_Line&#39;: comp.get(&#39;reference_cell_line&#39;, &#39;&#39;),
                &#39;Test_Cell_Line&#39;: comp.get(&#39;test_cell_line&#39;, &#39;&#39;),
                &#34;S&#39; (Reference)&#34;: f&#34;{comp.get(&#39;s_prime_ref&#39;, 0.0):.4f}&#34;,
                &#34;S&#39; (Test)&#34;: f&#34;{comp.get(&#39;s_prime_test&#39;, 0.0):.4f}&#34;,
                &#34;Delta S&#39;&#34;: f&#34;{comp.get(&#39;delta_s_prime&#39;, 0.0):.4f}&#34;,
                &#39;MOA&#39;: comp.get(&#39;MOA&#39;, &#39;&#39;),
                &#39;drug targets&#39;: comp.get(&#39;drug targets&#39;, &#39;&#39;),
            }
            for h in extra_headings:
                row[h] = comp.get(h, &#39;&#39;)
            flat_results.append(row)
    
    flat_results.sort(key=lambda x: float(x[&#34;Delta S&#39;&#34;]))
    for rank, result in enumerate(flat_results, start=1):
        result[&#39;Rank&#39;] = str(rank)
    
    fieldnames = [
        &#39;Rank&#39;, &#39;Compound Name&#39;, &#39;Compound_ID&#39;,
        &#39;Reference_Cell_Line&#39;, &#39;Test_Cell_Line&#39;,
        &#34;S&#39; (Reference)&#34;, &#34;S&#39; (Test)&#34;, &#34;Delta S&#39;&#34;,
        &#39;MOA&#39;, &#39;drug targets&#39;,
    ]
    fieldnames.extend(extra_headings)
    
    with open(filepath, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(flat_results)</code></pre>
</details>
<div class="desc"><p>Export delta S' results to CSV file.</p>
<p>Includes compound-level columns: MOA, drug targets (reserved), plus any
headings specified in headings_one_to_one_in_ref_and_test. These must
match the headings passed to calculate_delta_s_prime when producing
delta_results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta_results</code></strong></dt>
<dd>Dictionary from calculate_delta_s_prime()</dd>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to output CSV file</dd>
<dt><strong><code>headings_one_to_one_in_ref_and_test</code></strong></dt>
<dd>Optional list of metadata
headings included in delta output (same as for calculate_delta_s_prime).</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sprime.sprime.ScreeningDataset.profiles"><code class="name">prop <span class="ident">profiles</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def profiles(self):
    &#34;&#34;&#34;Iterator over all profiles&#34;&#34;&#34;
    return self._profiles.values()</code></pre>
</details>
<div class="desc"><p>Iterator over all profiles</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sprime.sprime.ScreeningDataset.add_profile"><code class="name flex">
<span>def <span class="ident">add_profile</span></span>(<span>self,<br>profile: <a title="sprime.sprime.DoseResponseProfile" href="#sprime.sprime.DoseResponseProfile">DoseResponseProfile</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_profile(self, profile: DoseResponseProfile):
    &#34;&#34;&#34;
    Add a profile (should have S&#39; calculated).
    
    Args:
        profile: DoseResponseProfile with S&#39; calculated
        
    Raises:
        ValueError: If profile doesn&#39;t have S&#39; or Hill params, or already exists
    &#34;&#34;&#34;
    # Validation: profile should be processed
    if profile.s_prime is None:
        raise ValueError(&#34;Profile must have S&#39; calculated before adding to ScreeningDataset&#34;)
    if profile.hill_params is None:
        raise ValueError(&#34;Profile must have Hill params before adding to ScreeningDataset&#34;)
    
    key = (profile.compound.drug_id, profile.cell_line.name)
    if key in self._profiles:
        raise ValueError(f&#34;Profile for {key} already exists&#34;)
    self._profiles[key] = profile</code></pre>
</details>
<div class="desc"><p>Add a profile (should have S' calculated).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>profile</code></strong></dt>
<dd>DoseResponseProfile with S' calculated</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If profile doesn't have S' or Hill params, or already exists</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.ScreeningDataset.calculate_delta_s_prime"><code class="name flex">
<span>def <span class="ident">calculate_delta_s_prime</span></span>(<span>self,<br>reference_cell_lines: str | List[str],<br>test_cell_lines: str | List[str],<br>headings_one_to_one_in_ref_and_test: List[str] | None = None,<br>source_profile: Literal['ref', 'test'] = 'test') ‑> Dict[str, List[Dict]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_delta_s_prime(
    self,
    reference_cell_lines: Union[str, List[str]],
    test_cell_lines: Union[str, List[str]],
    headings_one_to_one_in_ref_and_test: Optional[List[str]] = None,
    source_profile: Literal[&#34;ref&#34;, &#34;test&#34;] = &#34;test&#34;,
) -&gt; Dict[str, List[Dict]]:
    &#34;&#34;&#34;
    Calculate delta S&#39; = S&#39;(ref) - S&#39;(test) for each compound.
    
    Compound-level columns (1:1 per compound, not per cell line) auto-propagate:
    MOA and drug targets are reserved and always included; additional headings
    may be specified via headings_one_to_one_in_ref_and_test. Values are taken
    from the ref or test profile according to source_profile.
    
    Args:
        reference_cell_lines: Reference cell line name(s)
        test_cell_lines: Test cell line name(s)
        headings_one_to_one_in_ref_and_test: Optional list of metadata headings
            that exist 1:1 in ref and test; included in output, values from
            source_profile.
        source_profile: &#39;ref&#39; or &#39;test&#39;; which profile to use for compound-level
            values (MOA, drug targets, and optional headings).
        
    Returns:
        Dictionary with keys for each reference cell line, containing
        lists of dicts with delta S&#39; and compound-level fields per combo.
    &#34;&#34;&#34;
    ref_list = [reference_cell_lines] if isinstance(reference_cell_lines, str) else reference_cell_lines
    test_list = [test_cell_lines] if isinstance(test_cell_lines, str) else test_cell_lines
    extra_headings = headings_one_to_one_in_ref_and_test or []
    
    results = {}
    for ref_cellline in ref_list:
        rows = []
        compounds = {profile.compound.drug_id: profile.compound for profile in self._profiles.values()}
        
        for drug_id, compound in compounds.items():
            ref_profile = self.get_profile(compound, ref_cellline)
            if ref_profile is None or ref_profile.s_prime is None:
                continue
            
            for test_cellline in test_list:
                test_profile = self.get_profile(compound, test_cellline)
                if test_profile is None or test_profile.s_prime is None:
                    continue
                
                delta = ref_profile.s_prime - test_profile.s_prime
                source_meta = (ref_profile.metadata if source_profile == &#34;ref&#34; else test_profile.metadata) or {}
                row = {
                    &#39;compound_name&#39;: compound.name,
                    &#39;drug_id&#39;: drug_id,
                    &#39;reference_cell_line&#39;: ref_cellline,
                    &#39;test_cell_line&#39;: test_cellline,
                    &#39;s_prime_ref&#39;: ref_profile.s_prime,
                    &#39;s_prime_test&#39;: test_profile.s_prime,
                    &#39;delta_s_prime&#39;: delta,
                    &#39;MOA&#39;: _resolve_moa(source_meta),
                    &#39;drug targets&#39;: _resolve_drug_targets(source_meta),
                }
                for h in extra_headings:
                    row[h] = source_meta.get(h, &#34;&#34;)
                rows.append(row)
        
        results[ref_cellline] = rows
    
    return results</code></pre>
</details>
<div class="desc"><p>Calculate delta S' = S'(ref) - S'(test) for each compound.</p>
<p>Compound-level columns (1:1 per compound, not per cell line) auto-propagate:
MOA and drug targets are reserved and always included; additional headings
may be specified via headings_one_to_one_in_ref_and_test. Values are taken
from the ref or test profile according to source_profile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reference_cell_lines</code></strong></dt>
<dd>Reference cell line name(s)</dd>
<dt><strong><code>test_cell_lines</code></strong></dt>
<dd>Test cell line name(s)</dd>
<dt><strong><code>headings_one_to_one_in_ref_and_test</code></strong></dt>
<dd>Optional list of metadata headings
that exist 1:1 in ref and test; included in output, values from
source_profile.</dd>
<dt><strong><code>source_profile</code></strong></dt>
<dd>'ref' or 'test'; which profile to use for compound-level
values (MOA, drug targets, and optional headings).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with keys for each reference cell line, containing
lists of dicts with delta S' and compound-level fields per combo.</p></div>
</dd>
<dt id="sprime.sprime.ScreeningDataset.export_to_csv"><code class="name flex">
<span>def <span class="ident">export_to_csv</span></span>(<span>self, filepath: str | pathlib.Path, include_metadata: bool = True) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_to_csv(
    self,
    filepath: Union[str, Path],
    include_metadata: bool = True
) -&gt; None:
    &#34;&#34;&#34;
    Export all profiles to CSV file.
    
    Base columns (identifiers, Hill params, S&#39;, Rank) are always written.
    When include_metadata is True, all generic metadata keys (union across
    profiles) are included as pass-through columns.
    
    Args:
        filepath: Path to output CSV file
        include_metadata: When True, include all metadata columns. When False,
            only base columns.
    &#34;&#34;&#34;
    filepath = Path(filepath)
    profiles = sorted(self.profiles, key=lambda p: (p.compound.name, p.cell_line.name))
    
    base_fieldnames = [
        &#39;Compound Name&#39;, &#39;Compound_ID&#39;, &#39;pubchem_sid&#39;, &#39;SMILES&#39;,
        &#39;Cell_Line&#39;, &#39;Cell_Line_Ref_ID&#39;,
        &#39;EC50&#39;, &#39;Upper&#39;, &#39;Lower&#39;, &#39;Hill_Slope&#39;, &#39;r2&#39;,
        &#34;S&#39;&#34;, &#39;Rank&#39;
    ]
    all_meta_keys = sorted(set(
        k for p in profiles if p.metadata for k in p.metadata
    ))
    fieldnames = list(base_fieldnames)
    if include_metadata and all_meta_keys:
        fieldnames.extend(all_meta_keys)
    
    with open(filepath, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        
        for profile in profiles:
            meta = profile.metadata or {}
            row = {
                &#39;Compound Name&#39;: profile.compound.name,
                &#39;Compound_ID&#39;: profile.compound.drug_id,
                &#39;pubchem_sid&#39;: profile.compound.pubchem_sid or &#39;&#39;,
                &#39;SMILES&#39;: profile.compound.smiles or &#39;&#39;,
                &#39;Cell_Line&#39;: profile.cell_line.name,
                &#39;Cell_Line_Ref_ID&#39;: profile.cell_line.ref_id or &#39;&#39;,
                &#39;EC50&#39;: f&#34;{profile.hill_params.ec50:.6e}&#34; if profile.hill_params else &#39;&#39;,
                &#39;Upper&#39;: f&#34;{profile.hill_params.upper:.2f}&#34; if profile.hill_params else &#39;&#39;,
                &#39;Lower&#39;: f&#34;{profile.hill_params.lower:.2f}&#34; if profile.hill_params else &#39;&#39;,
                &#39;Hill_Slope&#39;: f&#34;{profile.hill_params.hill_coefficient:.4f}&#34; if profile.hill_params and profile.hill_params.hill_coefficient else &#39;&#39;,
                &#39;r2&#39;: f&#34;{profile.hill_params.r_squared:.4f}&#34; if profile.hill_params and profile.hill_params.r_squared is not None else &#39;&#39;,
                &#34;S&#39;&#34;: f&#34;{profile.s_prime:.4f}&#34; if profile.s_prime else &#39;&#39;,
                &#39;Rank&#39;: str(profile.rank) if profile.rank else &#39;&#39;,
            }
            if include_metadata and all_meta_keys:
                for k in all_meta_keys:
                    row[k] = meta.get(k, &#39;&#39;)
            
            writer.writerow(row)</code></pre>
</details>
<div class="desc"><p>Export all profiles to CSV file.</p>
<p>Base columns (identifiers, Hill params, S', Rank) are always written.
When include_metadata is True, all generic metadata keys (union across
profiles) are included as pass-through columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong></dt>
<dd>Path to output CSV file</dd>
<dt><strong><code>include_metadata</code></strong></dt>
<dd>When True, include all metadata columns. When False,
only base columns.</dd>
</dl></div>
</dd>
<dt id="sprime.sprime.ScreeningDataset.get_profile"><code class="name flex">
<span>def <span class="ident">get_profile</span></span>(<span>self,<br>compound: <a title="sprime.sprime.Compound" href="#sprime.sprime.Compound">Compound</a> | str,<br>cell_line: <a title="sprime.sprime.CellLine" href="#sprime.sprime.CellLine">CellLine</a> | str) ‑> <a title="sprime.sprime.DoseResponseProfile" href="#sprime.sprime.DoseResponseProfile">DoseResponseProfile</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_profile(self, compound: Union[Compound, str], 
                cell_line: Union[CellLine, str]) -&gt; Optional[DoseResponseProfile]:
    &#34;&#34;&#34;
    Retrieve a specific profile.
    
    Args:
        compound: Compound object or drug_id string
        cell_line: CellLine object or cell_line name string
        
    Returns:
        DoseResponseProfile or None if not found
    &#34;&#34;&#34;
    compound_id = compound.drug_id if isinstance(compound, Compound) else compound
    cellline_name = cell_line.name if isinstance(cell_line, CellLine) else cell_line
    return self._profiles.get((compound_id, cellline_name))</code></pre>
</details>
<div class="desc"><p>Retrieve a specific profile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compound</code></strong></dt>
<dd>Compound object or drug_id string</dd>
<dt><strong><code>cell_line</code></strong></dt>
<dd>CellLine object or cell_line name string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DoseResponseProfile or None if not found</p></div>
</dd>
<dt id="sprime.sprime.ScreeningDataset.to_dict_list"><code class="name flex">
<span>def <span class="ident">to_dict_list</span></span>(<span>self) ‑> List[Dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict_list(self) -&gt; List[Dict]:
    &#34;&#34;&#34;
    Export to list of dictionaries with all S&#39; values.
    
    Returns:
        List of dictionaries with profile data
    &#34;&#34;&#34;
    rows = []
    for profile in self._profiles.values():
        row = {
            &#39;compound_name&#39;: profile.compound.name,
            &#39;drug_id&#39;: profile.compound.drug_id,
            &#39;cell_line&#39;: profile.cell_line.name,
            &#39;s_prime&#39;: profile.s_prime,
            &#39;ec50&#39;: profile.hill_params.ec50 if profile.hill_params else None,
            &#39;upper&#39;: profile.hill_params.upper if profile.hill_params else None,
            &#39;lower&#39;: profile.hill_params.lower if profile.hill_params else None,
            &#39;rank&#39;: profile.rank,
        }
        if profile.hill_params:
            row[&#39;hill_coefficient&#39;] = profile.hill_params.hill_coefficient
            row[&#39;r_squared&#39;] = profile.hill_params.r_squared
        rows.append(row)
    return rows</code></pre>
</details>
<div class="desc"><p>Export to list of dictionaries with all S' values.</p>
<h2 id="returns">Returns</h2>
<p>List of dictionaries with profile data</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sprime" href="index.html">sprime</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprime.sprime.calculate_delta_s_prime" href="#sprime.sprime.calculate_delta_s_prime">calculate_delta_s_prime</a></code></li>
<li><code><a title="sprime.sprime.calculate_s_prime_from_params" href="#sprime.sprime.calculate_s_prime_from_params">calculate_s_prime_from_params</a></code></li>
<li><code><a title="sprime.sprime.convert_to_micromolar" href="#sprime.sprime.convert_to_micromolar">convert_to_micromolar</a></code></li>
<li><code><a title="sprime.sprime.fit_hill_from_raw_data" href="#sprime.sprime.fit_hill_from_raw_data">fit_hill_from_raw_data</a></code></li>
<li><code><a title="sprime.sprime.get_s_prime_from_data" href="#sprime.sprime.get_s_prime_from_data">get_s_prime_from_data</a></code></li>
<li><code><a title="sprime.sprime.get_s_primes_from_file" href="#sprime.sprime.get_s_primes_from_file">get_s_primes_from_file</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sprime.sprime.Assay" href="#sprime.sprime.Assay">Assay</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.Assay.description" href="#sprime.sprime.Assay.description">description</a></code></li>
<li><code><a title="sprime.sprime.Assay.name" href="#sprime.sprime.Assay.name">name</a></code></li>
<li><code><a title="sprime.sprime.Assay.readout_type" href="#sprime.sprime.Assay.readout_type">readout_type</a></code></li>
<li><code><a title="sprime.sprime.Assay.screen_id" href="#sprime.sprime.Assay.screen_id">screen_id</a></code></li>
<li><code><a title="sprime.sprime.Assay.time_profile" href="#sprime.sprime.Assay.time_profile">time_profile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.CellLine" href="#sprime.sprime.CellLine">CellLine</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.CellLine.name" href="#sprime.sprime.CellLine.name">name</a></code></li>
<li><code><a title="sprime.sprime.CellLine.ref_id" href="#sprime.sprime.CellLine.ref_id">ref_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.Compound" href="#sprime.sprime.Compound">Compound</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.Compound.drug_id" href="#sprime.sprime.Compound.drug_id">drug_id</a></code></li>
<li><code><a title="sprime.sprime.Compound.name" href="#sprime.sprime.Compound.name">name</a></code></li>
<li><code><a title="sprime.sprime.Compound.pubchem_sid" href="#sprime.sprime.Compound.pubchem_sid">pubchem_sid</a></code></li>
<li><code><a title="sprime.sprime.Compound.smiles" href="#sprime.sprime.Compound.smiles">smiles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.DoseResponseProfile" href="#sprime.sprime.DoseResponseProfile">DoseResponseProfile</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.DoseResponseProfile.assay" href="#sprime.sprime.DoseResponseProfile.assay">assay</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.calculate_s_prime" href="#sprime.sprime.DoseResponseProfile.calculate_s_prime">calculate_s_prime</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.cell_line" href="#sprime.sprime.DoseResponseProfile.cell_line">cell_line</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.compound" href="#sprime.sprime.DoseResponseProfile.compound">compound</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.concentration_units" href="#sprime.sprime.DoseResponseProfile.concentration_units">concentration_units</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.concentrations" href="#sprime.sprime.DoseResponseProfile.concentrations">concentrations</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.fit_and_calculate_s_prime" href="#sprime.sprime.DoseResponseProfile.fit_and_calculate_s_prime">fit_and_calculate_s_prime</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.fit_hill_curve" href="#sprime.sprime.DoseResponseProfile.fit_hill_curve">fit_hill_curve</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.hill_params" href="#sprime.sprime.DoseResponseProfile.hill_params">hill_params</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.metadata" href="#sprime.sprime.DoseResponseProfile.metadata">metadata</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.rank" href="#sprime.sprime.DoseResponseProfile.rank">rank</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.responses" href="#sprime.sprime.DoseResponseProfile.responses">responses</a></code></li>
<li><code><a title="sprime.sprime.DoseResponseProfile.s_prime" href="#sprime.sprime.DoseResponseProfile.s_prime">s_prime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.HillCurveParams" href="#sprime.sprime.HillCurveParams">HillCurveParams</a></code></h4>
<ul class="two-column">
<li><code><a title="sprime.sprime.HillCurveParams.amplitude" href="#sprime.sprime.HillCurveParams.amplitude">amplitude</a></code></li>
<li><code><a title="sprime.sprime.HillCurveParams.ec50" href="#sprime.sprime.HillCurveParams.ec50">ec50</a></code></li>
<li><code><a title="sprime.sprime.HillCurveParams.hill_coefficient" href="#sprime.sprime.HillCurveParams.hill_coefficient">hill_coefficient</a></code></li>
<li><code><a title="sprime.sprime.HillCurveParams.lower" href="#sprime.sprime.HillCurveParams.lower">lower</a></code></li>
<li><code><a title="sprime.sprime.HillCurveParams.r_squared" href="#sprime.sprime.HillCurveParams.r_squared">r_squared</a></code></li>
<li><code><a title="sprime.sprime.HillCurveParams.upper" href="#sprime.sprime.HillCurveParams.upper">upper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.RawDataset" href="#sprime.sprime.RawDataset">RawDataset</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.RawDataset.add_profile" href="#sprime.sprime.RawDataset.add_profile">add_profile</a></code></li>
<li><code><a title="sprime.sprime.RawDataset.get_profile" href="#sprime.sprime.RawDataset.get_profile">get_profile</a></code></li>
<li><code><a title="sprime.sprime.RawDataset.load_from_file" href="#sprime.sprime.RawDataset.load_from_file">load_from_file</a></code></li>
<li><code><a title="sprime.sprime.RawDataset.profiles" href="#sprime.sprime.RawDataset.profiles">profiles</a></code></li>
<li><code><a title="sprime.sprime.RawDataset.to_screening_dataset" href="#sprime.sprime.RawDataset.to_screening_dataset">to_screening_dataset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.SPrime" href="#sprime.sprime.SPrime">SPrime</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.SPrime.load" href="#sprime.sprime.SPrime.load">load</a></code></li>
<li><code><a title="sprime.sprime.SPrime.load_from_dataframe" href="#sprime.sprime.SPrime.load_from_dataframe">load_from_dataframe</a></code></li>
<li><code><a title="sprime.sprime.SPrime.process" href="#sprime.sprime.SPrime.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprime.sprime.ScreeningDataset" href="#sprime.sprime.ScreeningDataset">ScreeningDataset</a></code></h4>
<ul class="">
<li><code><a title="sprime.sprime.ScreeningDataset.add_profile" href="#sprime.sprime.ScreeningDataset.add_profile">add_profile</a></code></li>
<li><code><a title="sprime.sprime.ScreeningDataset.calculate_delta_s_prime" href="#sprime.sprime.ScreeningDataset.calculate_delta_s_prime">calculate_delta_s_prime</a></code></li>
<li><code><a title="sprime.sprime.ScreeningDataset.export_delta_s_prime_to_csv" href="#sprime.sprime.ScreeningDataset.export_delta_s_prime_to_csv">export_delta_s_prime_to_csv</a></code></li>
<li><code><a title="sprime.sprime.ScreeningDataset.export_to_csv" href="#sprime.sprime.ScreeningDataset.export_to_csv">export_to_csv</a></code></li>
<li><code><a title="sprime.sprime.ScreeningDataset.get_profile" href="#sprime.sprime.ScreeningDataset.get_profile">get_profile</a></code></li>
<li><code><a title="sprime.sprime.ScreeningDataset.profiles" href="#sprime.sprime.ScreeningDataset.profiles">profiles</a></code></li>
<li><code><a title="sprime.sprime.ScreeningDataset.to_dict_list" href="#sprime.sprime.ScreeningDataset.to_dict_list">to_dict_list</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
