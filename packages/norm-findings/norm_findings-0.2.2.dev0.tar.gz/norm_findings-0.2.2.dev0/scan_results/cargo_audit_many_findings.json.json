[
    {
        "unsaved_vulnerability_ids": [
            "RUSTSEC-2020-0091",
            "CVE-2020-35711"
        ],
        "unsaved_endpoints": [],
        "title": "[arc-swap 0.4.7] Dangling reference in `access::Map` with Constant",
        "test": "unittests/scans/",
        "severity": "High",
        "tags": [
            "dangling reference"
        ],
        "description": "**Categories:** memory-corruption\n**Description:** `Using the `arc_swap::access::Map` with the `Constant` test helper (or with\nuser-provided implementation of the `Access` trait) could sometimes lead to the\nmap returning dangling references.\n\nReplaced by implementation without `unsafe`, at the cost of added `Clone` bound\non the closure and small penalty on performance.`\n**Affected functions**: arc_swap::access::MapGuard::deref: <1.1.0",
        "component_name": "arc-swap",
        "component_version": "0.4.7",
        "vuln_id_from_tool": "RUSTSEC-2020-0091",
        "publish_date": "2020-12-10",
        "nb_occurences": 1,
        "references": "https://github.com/vorner/arc-swap/issues/45\n",
        "mitigation": "**Update arc-swap to** >=1.1.0, >=0.4.8"
    },
    {
        "unsaved_vulnerability_ids": [
            "RUSTSEC-2021-0020",
            "CVE-2021-21299"
        ],
        "unsaved_endpoints": [],
        "title": "[hyper 0.13.9] Multiple Transfer-Encoding headers misinterprets request payload",
        "test": "unittests/scans/",
        "severity": "High",
        "tags": [
            "http",
            "request-smuggling"
        ],
        "description": "**Categories:** format-injection\n**Description:** `hyper's HTTP server code had a flaw that incorrectly understands some requests\nwith multiple transfer-encoding headers to have a chunked payload, when it\nshould have been rejected as illegal. This combined with an upstream HTTP proxy\nthat understands the request payload boundary differently can result in\n\"request smuggling\" or \"desync attacks\".`",
        "component_name": "hyper",
        "component_version": "0.13.9",
        "vuln_id_from_tool": "RUSTSEC-2021-0020",
        "publish_date": "2021-02-05",
        "nb_occurences": 1,
        "references": "https://github.com/hyperium/hyper/security/advisories/GHSA-6hfq-h8hq-87mf\n",
        "mitigation": "**Update hyper to** >=0.14.3, >=0.13.10, <0.14.0, >=0.12.36, <0.13.0"
    },
    {
        "unsaved_vulnerability_ids": [
            "RUSTSEC-2021-0003",
            "CVE-2021-25900"
        ],
        "unsaved_endpoints": [],
        "title": "[smallvec 0.6.13] Buffer overflow in SmallVec::insert_many",
        "test": "unittests/scans/",
        "severity": "High",
        "tags": [
            "buffer-overflow",
            "heap-overflow",
            "unsound"
        ],
        "description": "**Categories:** memory-corruption\n**Description:** `A bug in the `SmallVec::insert_many` method caused it to allocate a buffer that was smaller than needed.  It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap.\n\nThis bug was only triggered if the iterator passed to `insert_many` yielded more items than the lower bound returned from its `size_hint` method.\n \nThe flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted.  The fix also simplified the implementation of `insert_many` to use less unsafe code, so it is easier to verify its correctness.\n\nThank you to Yechan Bae (@Qwaz) and the Rust group at Georgia Tech\u2019s SSLab for finding and reporting this bug.`\n**Affected functions**: smallvec::SmallVec::insert_many: >=0.6.3, <0.6.14, >=1.0.0, <1.6.1",
        "component_name": "smallvec",
        "component_version": "0.6.13",
        "vuln_id_from_tool": "RUSTSEC-2021-0003",
        "publish_date": "2021-01-08",
        "nb_occurences": 1,
        "references": "https://github.com/servo/rust-smallvec/issues/252\n",
        "mitigation": "**Update smallvec to** >=0.6.14, <1.0.0, >=1.6.1"
    },
    {
        "unsaved_vulnerability_ids": [
            "RUSTSEC-2021-0003",
            "CVE-2021-25900"
        ],
        "unsaved_endpoints": [],
        "title": "[smallvec 1.5.0] Buffer overflow in SmallVec::insert_many",
        "test": "unittests/scans/",
        "severity": "High",
        "tags": [
            "buffer-overflow",
            "heap-overflow",
            "unsound"
        ],
        "description": "**Categories:** memory-corruption\n**Description:** `A bug in the `SmallVec::insert_many` method caused it to allocate a buffer that was smaller than needed.  It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap.\n\nThis bug was only triggered if the iterator passed to `insert_many` yielded more items than the lower bound returned from its `size_hint` method.\n \nThe flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted.  The fix also simplified the implementation of `insert_many` to use less unsafe code, so it is easier to verify its correctness.\n\nThank you to Yechan Bae (@Qwaz) and the Rust group at Georgia Tech\u2019s SSLab for finding and reporting this bug.`\n**Affected functions**: smallvec::SmallVec::insert_many: >=0.6.3, <0.6.14, >=1.0.0, <1.6.1",
        "component_name": "smallvec",
        "component_version": "1.5.0",
        "vuln_id_from_tool": "RUSTSEC-2021-0003",
        "publish_date": "2021-01-08",
        "nb_occurences": 1,
        "references": "https://github.com/servo/rust-smallvec/issues/252\n",
        "mitigation": "**Update smallvec to** >=0.6.14, <1.0.0, >=1.6.1"
    }
]