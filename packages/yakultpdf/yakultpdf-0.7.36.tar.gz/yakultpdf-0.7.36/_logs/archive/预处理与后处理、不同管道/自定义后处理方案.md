# 自定义预处理器方案

## 当前架构

### core.py 预处理流程（第 216-229 行）

```python
# 1. 默认预处理（始终执行）
content = pre_add_line_breaks(content, verbose=verbose)
content = pre_for_typst(content, verbose=verbose)

# 2. 后处理（如果有，在内置预处理之后追加执行）
if postprocess:
    content = postprocess(content)
```

**关键点**：`postprocess` 参数是**追加执行**，不是替换。

---

## gaozhi 的问题

### 现状

`gaozhi.py` 使用：
```python
convert_file(
    template="gaozhi.typ",
    postprocess=process_for_typ,  # 作为追加后处理器
)
```

### 问题

| 预处理步骤 | 操作 | 与 gaozhi 冲突点 |
|-----------|-----|----------------|
| `pre_add_line_breaks` | 规范化空行 | gaozhi 有自己的换行规则 |
| `pre_for_typst` | 转义 `@` `$` | gaozhi 不需要（输出纯文本） |
| `process_for_typ` | 稿纸格式化 | 依赖原始 Markdown 输入 |

**冲突**：`process_for_typ` 设计时假设输入是原始 Markdown，但实际收到的是**已预处理**的内容。

---

## 解决方案

### 方案 A：添加 `skip_default_preprocess` 参数

```python
def convert_file(
    ...
    postprocess: Callable[[str], str] | None = None,
    skip_default_preprocess: bool = False,  # 新增
):
    # 1. 内置预处理
    if not skip_default_preprocess:
        content = pre_add_line_breaks(content)
        content = pre_for_typst(content)
    
    # 2. 后处理
    if postprocess:
        content = postprocess(content)
```

`gaozhi.py` 使用：
```python
convert_file(
    postprocess=process_for_typ,
    skip_default_preprocess=True,  # 跳过内置预处理
)
```

### 方案 B：预处理模式枚举

```python
class PreprocessMode(Enum):
    DEFAULT = "default"      # 只执行默认预处理
    APPEND = "append"        # 默认 + 自定义
    REPLACE = "replace"      # 只执行自定义
```

---

## 分类总结

| 类型 | 说明 | 示例 |
|-----|-----|-----|
| **默认** (Default) | 始终执行 | `pre_add_line_breaks`, `pre_for_typst` |
| **追加** (Append) | 在默认之后执行 | `pre_remove_links` |
| **替换** (Replace) | 跳过默认，只执行自定义 | `process_for_typ` (gaozhi) |

---

## 待办

1. [ ] 决定采用方案 A 或 B
2. [ ] 修改 `core.py` 添加相应参数
3. [ ] 更新 `gaozhi.py` 使用新参数
4. [ ] 添加测试验证三种模式
