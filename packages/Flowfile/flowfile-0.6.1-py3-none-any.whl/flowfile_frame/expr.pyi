# This file was auto-generated to provide type information for Expr
# DO NOT MODIFY THIS FILE MANUALLY
from __future__ import annotations

from typing import TYPE_CHECKING, Any, TypeVar, Union

import polars as pl

if TYPE_CHECKING:
    from collections.abc import Iterable
    from io import IOBase

    from polars import Series
    from polars._typing import *

    if sys.version_info >= (3, 11):
        from typing import Concatenate, ParamSpec
    else:
        from typing import Concatenate

        from typing_extensions import ParamSpec
    T = TypeVar('T')
    P = ParamSpec('P')
    from flowfile_core.schemas import transform_schema
from flowfile_frame.expr_name import ExprNameNameSpace
from flowfile_frame.selectors import Selector

# Define NoneType to handle type hints with None
NoneType = type(None)

ExprOrStr = Union['Expr', str]
ExprOrStrList = list[ExprOrStr]
ExprStrOrList = Union[ExprOrStr, ExprOrStrList]

class StringMethods:
    __module__: Any
    __annotations__: Any
    __dict__: Any
    __weakref__: Any
    __doc__: Any

    def __getattr__(self, name) -> Any: ...

    def __init__(self, parent_expr: Expr, parent_repr_str: str, convertable_to_code: bool=True, _function_sources: list[str] | None=None) -> Any: ...

    def _create_next_expr(self, *args, method_name: str, result_expr: pl.Expr | None, is_complex: bool, convertable_to_code: bool=None, **kwargs) -> Expr: ...

    def contains(self, pattern, literal=False) -> Any: ...

    def ends_with(self, suffix) -> Any: ...

    def len_bytes(self, ) -> Any: ...

    def len_chars(self, ) -> Any: ...

    def replace(self, pattern, replacement, literal=False) -> Any: ...

    def starts_with(self, prefix) -> Any: ...

    def strptime(self, dtype: PolarsTemporalType, format: str | None=None, strict: bool=True, exact: bool=True, cache: bool=True, ambiguous: Literal[earliest, latest, 'raise', null] | Expr='raise') -> Expr: ...

    def to_date(self, format: str, strict: bool=True, exact: bool=True, cache: bool=True) -> Any: ...

    def to_datetime(self, format: str | None=None, time_unit: Literal[ns, us, ms] | None=None, time_zone: str | None=None, strict: bool=True, exact: bool=True, cache: bool=True, ambiguous: Literal[earliest, latest, 'raise', null] | Expr='raise') -> Expr: ...

    def to_lowercase(self, ) -> Any: ...

    def to_titlecase(self, ) -> Any: ...

    def to_uppercase(self, ) -> Any: ...


class DateTimeMethods:
    __module__: Any
    __annotations__: Any
    __dict__: Any
    __weakref__: Any
    __doc__: Any

    def __getattr__(self, name) -> Any: ...

    def __init__(self, parent_expr: Expr, parent_repr_str: str, convertable_to_code: bool=True, _function_sources: list[str] | None=None) -> Any: ...

    def _create_next_expr(self, method_name: str, result_expr: pl.Expr | None, convertable_to_code: bool=None, *args, **kwargs) -> Expr: ...

    def day(self, ) -> Any: ...

    def hour(self, ) -> Any: ...

    def minute(self, ) -> Any: ...

    def month(self, ) -> Any: ...

    def second(self, ) -> Any: ...

    def year(self, ) -> Any: ...


class Expr:
    dt: DateTimeMethods
    is_simple: bool
    list: ExprListNameSpace
    name: ExprNameNameSpace
    str: StringMethods
    __module__: Any
    __annotations__: Any
    is_complex: bool
    __dict__: Any
    __weakref__: Any
    __doc__: Any
    __hash__: Any

    def __add__(self, other) -> Expr: ...

    def __and__(self, other) -> Expr: ...

    def __eq__(self, other) -> Expr: ...

    def __floordiv__(self, other) -> Expr: ...

    def __ge__(self, other) -> Expr: ...

    def __gt__(self, other) -> Expr: ...

    def __init__(self, expr: pl.Expr | None, column_name: str | None=None, repr_str: str | None=None, initial_column_name: str | None=None, selector: Selector | None=None, agg_func: str | None=None, ddof: int | None=None, is_complex: bool=False, convertable_to_code: bool=True, _function_sources: list[str] | None=None) -> Any: ...

    def __invert__(self, ) -> Expr: ...

    def __le__(self, other) -> Expr: ...

    def __lt__(self, other) -> Expr: ...

    def __mod__(self, other) -> Expr: ...

    def __mul__(self, other) -> Expr: ...

    def __ne__(self, other) -> Expr: ...

    def __neg__(self, ) -> Expr: ...

    def __or__(self, other) -> Expr: ...

    def __pow__(self, exponent) -> Expr: ...

    def __radd__(self, other) -> Any: ...

    def __repr__(self, ) -> str: ...

    def __rfloordiv__(self, other) -> Any: ...

    def __rmod__(self, other) -> Any: ...

    def __rmul__(self, other) -> Any: ...

    def __rpow__(self, other) -> Any: ...

    def __rsub__(self, other) -> Any: ...

    def __rtruediv__(self, other) -> Any: ...

    def __sub__(self, other) -> Expr: ...

    def __truediv__(self, other) -> Expr: ...

    # Creates a new Expr for binary operations.
    def _create_binary_op_expr(self, op_symbol: str, other: Any, result_expr: pl.Expr | None) -> Expr: ...

    # Creates a new Expr instance, appending method call to repr string.
    def _create_next_expr(self, *args, method_name: str, result_expr: pl.Expr | None, convertable_to_code: bool=None, is_complex: bool, _function_sources: list[str] | None=None, **kwargs) -> Expr: ...

    # Helper to get appropriate string representation for an expression
    def _get_expr_repr(self, expr) -> Any: ...

    # Compute absolute values.
    def abs(self, ) -> Expr: ...

    # Method equivalent of addition operator `expr + other`.
    def add(self, other: Any) -> Expr: ...

    # Get the group indexes of the group by operation.
    def agg_groups(self, ) -> Expr: ...

    # Rename the expression result.
    def alias(self, name) -> Expr: ...

    # Return whether all values in the column are `True`.
    def all(self, ignore_nulls: bool=True) -> Expr: ...

    # Method equivalent of bitwise "and" operator `expr & other & ...`.
    def and_(self, *others) -> Expr: ...

    # Return whether any of the values in the column are `True`.
    def any(self, ignore_nulls: bool=True) -> Expr: ...

    # Append expressions.
    def append(self, other: IntoExpr, upcast: bool=True) -> Expr: ...

    # Approximate count of unique values.
    def approx_n_unique(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse cosine.
    def arccos(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic cosine.
    def arccosh(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse sine.
    def arcsin(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic sine.
    def arcsinh(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse tangent.
    def arctan(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic tangent.
    def arctanh(self, ) -> Expr: ...

    # Get the index of the maximal value.
    def arg_max(self, ) -> Expr: ...

    # Get the index of the minimal value.
    def arg_min(self, ) -> Expr: ...

    def arg_sort(self, descending: bool=False, nulls_last: bool=False) -> Expr: ...

    # Return indices where expression evaluates `True`.
    def arg_true(self, ) -> Expr: ...

    def arg_unique(self, ) -> Expr: ...

    # Fill missing values with the next non-null value.
    def backward_fill(self, limit: int | None=None) -> Expr: ...

    # Perform an aggregation of bitwise ANDs.
    def bitwise_and(self, ) -> Expr: ...

    # Evaluate the number of set bits.
    def bitwise_count_ones(self, ) -> Expr: ...

    # Evaluate the number of unset bits.
    def bitwise_count_zeros(self, ) -> Expr: ...

    # Evaluate the number most-significant set bits before seeing an unset bit.
    def bitwise_leading_ones(self, ) -> Expr: ...

    # Evaluate the number most-significant unset bits before seeing a set bit.
    def bitwise_leading_zeros(self, ) -> Expr: ...

    # Perform an aggregation of bitwise ORs.
    def bitwise_or(self, ) -> Expr: ...

    # Evaluate the number least-significant set bits before seeing an unset bit.
    def bitwise_trailing_ones(self, ) -> Expr: ...

    # Evaluate the number least-significant unset bits before seeing a set bit.
    def bitwise_trailing_zeros(self, ) -> Expr: ...

    # Perform an aggregation of bitwise XORs.
    def bitwise_xor(self, ) -> Expr: ...

    # Return the `k` smallest elements.
    def bottom_k(self, k: int | IntoExprColumn=5) -> Expr: ...

    # Return the elements corresponding to the `k` smallest elements of the `by` column(s).
    def bottom_k_by(self, by: IntoExpr | Iterable[IntoExpr], k: int | IntoExprColumn=5, reverse: bool | Sequence[bool]=False) -> Expr: ...

    # Casts the Expr to a specified data type.
    def cast(self, dtype: pl.DataType | str | pl.datatypes.classes.DataTypeClass, strict=True) -> Expr: ...

    # Compute the cube root of the elements.
    def cbrt(self, ) -> Expr: ...

    # Rounds up to the nearest integer value.
    def ceil(self, ) -> Expr: ...

    # Set values outside the given boundaries to the boundary value.
    def clip(self, lower_bound: NumericLiteral | TemporalLiteral | IntoExprColumn | None=None, upper_bound: NumericLiteral | TemporalLiteral | IntoExprColumn | None=None) -> Expr: ...

    # Compute the element-wise value for the cosine.
    def cos(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic cosine.
    def cosh(self, ) -> Expr: ...

    # Compute the element-wise value for the cotangent.
    def cot(self, ) -> Expr: ...

    def count(self, ) -> Expr: ...

    # Return the cumulative count of the non-null values in the column.
    def cum_count(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative max computed at every element.
    def cum_max(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative min computed at every element.
    def cum_min(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative product computed at every element.
    def cum_prod(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative sum computed at every element.
    def cum_sum(self, reverse: bool=False) -> Expr: ...

    # Run an expression over a sliding window that increases `1` slot every iteration.
    def cumulative_eval(self, expr: Expr, min_samples: int=1) -> Expr: ...

    # Bin continuous values into discrete categories.
    def cut(self, breaks: Sequence[float], labels: Sequence[str] | None=None, left_closed: bool=False, include_breaks: bool=False) -> Expr: ...

    # Convert from radians to degrees.
    def degrees(self, ) -> Expr: ...

    # Read a serialized expression from a file.
    def deserialize(self, source: str | Path | IOBase | bytes, format: SerializationFormat='binary') -> Expr: ...

    # Calculate the first discrete difference between shifted items.
    def diff(self, n: int | IntoExpr=1, null_behavior: NullBehavior='ignore') -> Expr: ...

    # Compute the dot/inner product between two Expressions.
    def dot(self, other: Expr | str) -> Expr: ...

    # Drop all floating point NaN values.
    def drop_nans(self, ) -> Expr: ...

    # Drop all null values.
    def drop_nulls(self, ) -> Expr: ...

    # Computes the entropy.
    def entropy(self, base: float=2.718281828459045, normalize: bool=True) -> Expr: ...

    # Method equivalent of equality operator `expr == other`.
    def eq(self, other: Any) -> Expr: ...

    # Method equivalent of equality operator `expr == other` where `None == None`.
    def eq_missing(self, other: Any) -> Expr: ...

    # Compute exponentially-weighted moving average.
    def ewm_mean(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Compute time-based exponentially weighted moving average.
    def ewm_mean_by(self, by: str | IntoExpr, half_life: str | timedelta) -> Expr: ...

    # Compute exponentially-weighted moving standard deviation.
    def ewm_std(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, bias: bool=False, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Compute exponentially-weighted moving variance.
    def ewm_var(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, bias: bool=False, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Exclude columns from a multi-column expression.
    def exclude(self, columns: str | PolarsDataType | Collection[str] | Collection[PolarsDataType], *more_columns) -> Expr: ...

    # Compute the exponential, element-wise.
    def exp(self, ) -> Expr: ...

    def explode(self, ) -> Any: ...

    # Extremely fast method for extending the Series with 'n' copies of a value.
    def extend_constant(self, value: IntoExpr, n: int | IntoExprColumn) -> Expr: ...

    def fill_nan(self, value) -> Expr: ...

    def fill_null(self, value) -> Expr: ...

    # Filter expression
    def filter(self, *predicates, **constraints) -> Expr: ...

    def first(self, ) -> Expr: ...

    # Flatten a list or string column.
    def flatten(self, ) -> Expr: ...

    # Rounds down to the nearest integer value.
    def floor(self, ) -> Expr: ...

    # Method equivalent of integer division operator `expr // other`.
    def floordiv(self, other: Any) -> Expr: ...

    # Fill missing values with the last non-null value.
    def forward_fill(self, limit: int | None=None) -> Expr: ...

    # Read an expression from a JSON encoded string to construct an Expression.
    def from_json(self, value: str) -> Expr: ...

    # Take values by index.
    def gather(self, indices: int | Sequence[int] | IntoExpr | Series | np.ndarray[Any, Any]) -> Expr: ...

    # Take every nth value in the Series and return as a new Series.
    def gather_every(self, n: int, offset: int=0) -> Expr: ...

    # Method equivalent of "greater than or equal" operator `expr >= other`.
    def ge(self, other: Any) -> Expr: ...

    # Return a single value by index.
    def get(self, index: int | Expr) -> Expr: ...

    # Get the Polars code representation of this expression, including any function definitions.
    def get_polars_code(self, ) -> str: ...

    # Method equivalent of "greater than" operator `expr > other`.
    def gt(self, other: Any) -> Expr: ...

    # Check whether the expression contains one or more null values.
    def has_nulls(self, ) -> Expr: ...

    # Hash the elements in the selection.
    def hash(self, seed: int=0, seed_1: int | None=None, seed_2: int | None=None, seed_3: int | None=None) -> Expr: ...

    # Get the first `n` rows.
    def head(self, n: int | Expr=10) -> Expr: ...

    # Bin values into buckets and count their occurrences.
    def hist(self, bins: IntoExpr | None=None, bin_count: int | None=None, include_category: bool=False, include_breakpoint: bool=False) -> Expr: ...

    def implode(self, ) -> Any: ...

    # Get the index of the first occurrence of a value, or ``None`` if it's not found.
    def index_of(self, element: IntoExpr) -> Expr: ...

    # Print the value that this expression evaluates to and pass on the value.
    def inspect(self, fmt: str='{}') -> Expr: ...

    # Interpolate intermediate values.
    def interpolate(self, method: InterpolationMethod='linear') -> Expr: ...

    # Fill null values using interpolation based on another column.
    def interpolate_by(self, by: IntoExpr) -> Expr: ...

    # Check if this expression is between the given lower and upper bounds.
    def is_between(self, lower_bound: IntoExpr, upper_bound: IntoExpr, closed: ClosedInterval='both') -> Expr: ...

    # Return a boolean mask indicating duplicated values.
    def is_duplicated(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are finite.
    def is_finite(self, ) -> Expr: ...

    # Return a boolean mask indicating the first occurrence of each distinct value.
    def is_first_distinct(self, ) -> Expr: ...

    def is_in(self, values) -> Any: ...

    # Returns a boolean Series indicating which values are infinite.
    def is_infinite(self, ) -> Expr: ...

    # Return a boolean mask indicating the last occurrence of each distinct value.
    def is_last_distinct(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are NaN.
    def is_nan(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are not NaN.
    def is_not_nan(self, ) -> Expr: ...

    def is_not_null(self, ) -> Expr: ...

    def is_null(self, ) -> Expr: ...

    # Get mask of unique values.
    def is_unique(self, ) -> Expr: ...

    # Compute the kurtosis (Fisher or Pearson) of a dataset.
    def kurtosis(self, fisher: bool=True, bias: bool=True) -> Expr: ...

    def last(self, ) -> Expr: ...

    # Method equivalent of "less than or equal" operator `expr <= other`.
    def le(self, other: Any) -> Expr: ...

    # Return the number of elements in the column.
    def len(self, ) -> Expr: ...

    # Get the first `n` rows (alias for :func:`Expr.head`).
    def limit(self, n: int | Expr=10) -> Expr: ...

    # Compute the logarithm to a given base.
    def log(self, base: float=2.718281828459045) -> Expr: ...

    # Compute the base 10 logarithm of the input array, element-wise.
    def log10(self, ) -> Expr: ...

    # Compute the natural logarithm of each element plus one.
    def log1p(self, ) -> Expr: ...

    # Calculate the lower bound.
    def lower_bound(self, ) -> Expr: ...

    # Method equivalent of "less than" operator `expr < other`.
    def lt(self, other: Any) -> Expr: ...

    # Apply a custom python function to a whole Series or sequence of Series.
    def map_batches(self, function: Callable[[Series], Series | Any], return_dtype: PolarsDataType | pl.DataTypeExpr | None=None, agg_list: bool=False, is_elementwise: bool=False, returns_scalar: bool=False) -> Expr: ...

    # Map a custom/user-defined function (UDF) to each element of a column.
    def map_elements(self, function: Callable[[Any], Any], return_dtype: PolarsDataType | None=None, skip_nulls: bool=True, pass_name: bool=False, strategy: MapElementsStrategy='thread_local', returns_scalar: bool=False) -> Expr: ...

    def max(self, ) -> Expr: ...

    def mean(self, ) -> Expr: ...

    def median(self, ) -> Any: ...

    def min(self, ) -> Expr: ...

    # Method equivalent of modulus operator `expr % other`.
    def mod(self, other: Any) -> Expr: ...

    # Compute the most occurring value(s).
    def mode(self, ) -> Expr: ...

    # Method equivalent of multiplication operator `expr * other`.
    def mul(self, other: Any) -> Expr: ...

    def n_unique(self, ) -> Any: ...

    # Get maximum value, but propagate/poison encountered NaN values.
    def nan_max(self, ) -> Expr: ...

    # Get minimum value, but propagate/poison encountered NaN values.
    def nan_min(self, ) -> Expr: ...

    # Method equivalent of inequality operator `expr != other`.
    def ne(self, other: Any) -> Expr: ...

    # Method equivalent of equality operator `expr != other` where `None == None`.
    def ne_missing(self, other: Any) -> Expr: ...

    # Method equivalent of unary minus operator `-expr`.
    def neg(self, ) -> Expr: ...

    # Negate a boolean expression.
    def not_(self, ) -> Expr: ...

    # Count null values.
    def null_count(self, ) -> Expr: ...

    # Method equivalent of bitwise "or" operator `expr | other | ...`.
    def or_(self, *others) -> Expr: ...

    # Compute expressions over the given groups.
    def over(self, partition_by: ExprStrOrList, *more_exprs, order_by: ExprStrOrList | None=None, descending: bool=False, nulls_last: bool=False, mapping_strategy: Literal[group_to_rows, join, explode]='group_to_rows') -> Expr: ...

    # Computes percentage change between values.
    def pct_change(self, n: int | IntoExprColumn=1) -> Expr: ...

    # Get a boolean mask of the local maximum peaks.
    def peak_max(self, ) -> Expr: ...

    # Get a boolean mask of the local minimum peaks.
    def peak_min(self, ) -> Expr: ...

    # Offers a structured way to apply a sequence of user-defined functions (UDFs).
    def pipe(self, function: Callable[Concatenate[Expr, P], T], *args, **kwargs) -> T: ...

    # Method equivalent of exponentiation operator `expr ** exponent`.
    def pow(self, exponent: IntoExprColumn | int | float) -> Expr: ...

    # Compute the product of an expression.
    def product(self, ) -> Expr: ...

    # Bin continuous values into discrete categories based on their quantiles.
    def qcut(self, quantiles: Sequence[float] | int, labels: Sequence[str] | None=None, left_closed: bool=False, allow_duplicates: bool=False, include_breaks: bool=False) -> Expr: ...

    # Get quantile value.
    def quantile(self, quantile: float | Expr, interpolation: QuantileMethod='nearest') -> Expr: ...

    # Convert from degrees to radians.
    def radians(self, ) -> Expr: ...

    # Assign ranks to data, dealing with ties appropriately.
    def rank(self, method: RankMethod='average', descending: bool=False, seed: int | None=None) -> Expr: ...

    # Create a single chunk of memory for this Series.
    def rechunk(self, ) -> Expr: ...

    # Register a plugin function.
    def register_plugin(self, lib: str, symbol: str, args: list[IntoExpr] | None=None, kwargs: dict[Any, Any] | None=None, is_elementwise: bool=False, input_wildcard_expansion: bool=False, returns_scalar: bool=False, cast_to_supertypes: bool=False, pass_name_to_apply: bool=False, changes_length: bool=False) -> Expr: ...

    # Reinterpret the underlying bits as a signed/unsigned integer.
    def reinterpret(self, signed: bool=True) -> Expr: ...

    # Repeat the elements in this Series as specified in the given expression.
    def repeat_by(self, by: pl.Series | Expr | str | int) -> Expr: ...

    # Replace the given values by different values of the same data type.
    def replace(self, old: IntoExpr | Sequence[Any] | Mapping[Any, Any], new: IntoExpr | Sequence[Any], default: IntoExpr, return_dtype: PolarsDataType | None=None) -> Expr: ...

    # Replace all values by different values.
    def replace_strict(self, old: IntoExpr | Sequence[Any] | Mapping[Any, Any], new: IntoExpr | Sequence[Any], default: IntoExpr, return_dtype: PolarsDataType | pl.DataTypeExpr | None=None) -> Expr: ...

    # Reshape this Expr to a flat column or an Array column.
    def reshape(self, dimensions: tuple[int, ...]) -> Expr: ...

    # Reverse the selection.
    def reverse(self, ) -> Expr: ...

    # Compress the column data using run-length encoding.
    def rle(self, ) -> Expr: ...

    # Get a distinct integer ID for each run of identical values.
    def rle_id(self, ) -> Expr: ...

    # Create rolling groups based on a temporal or integer column.
    def rolling(self, index_column: str, period: str | timedelta, offset: str | timedelta | None=None, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling kurtosis.
    def rolling_kurtosis(self, window_size: int, fisher: bool=True, bias: bool=True, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a custom rolling window function.
    def rolling_map(self, function: Callable[[Series], Any], window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling max (moving max) over the values in this array.
    def rolling_max(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling max based on another column.
    def rolling_max_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Apply a rolling mean (moving mean) over the values in this array.
    def rolling_mean(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling mean based on another column.
    def rolling_mean_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling median.
    def rolling_median(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling median based on another column.
    def rolling_median_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Apply a rolling min (moving min) over the values in this array.
    def rolling_min(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling min based on another column.
    def rolling_min_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling quantile.
    def rolling_quantile(self, quantile: float, interpolation: QuantileMethod='nearest', window_size: int=2, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling quantile based on another column.
    def rolling_quantile_by(self, by: IntoExpr, window_size: timedelta | str, quantile: float, interpolation: QuantileMethod='nearest', min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling skew.
    def rolling_skew(self, window_size: int, bias: bool=True, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling standard deviation.
    def rolling_std(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False, ddof: int=1) -> Expr: ...

    # Compute a rolling standard deviation based on another column.
    def rolling_std_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right', ddof: int=1) -> Expr: ...

    # Apply a rolling sum (moving sum) over the values in this array.
    def rolling_sum(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling sum based on another column.
    def rolling_sum_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling variance.
    def rolling_var(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False, ddof: int=1) -> Expr: ...

    # Compute a rolling variance based on another column.
    def rolling_var_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right', ddof: int=1) -> Expr: ...

    # Round underlying floating point data by `decimals` digits.
    def round(self, decimals: int=0, mode: RoundMode='half_to_even') -> Expr: ...

    # Round to a number of significant figures.
    def round_sig_figs(self, digits: int) -> Expr: ...

    # Sample from this expression.
    def sample(self, n: int | IntoExprColumn | None=None, fraction: float | IntoExprColumn | None=None, with_replacement: bool=False, shuffle: bool=False, seed: int | None=None) -> Expr: ...

    # Find indices where elements should be inserted to maintain order.
    def search_sorted(self, element: IntoExpr | np.ndarray[Any, Any], side: SearchSortedSide='any', descending: bool=False) -> Expr: ...

    # Flags the expression as 'sorted'.
    def set_sorted(self, descending: bool=False) -> Expr: ...

    # Shift values by the given number of indices.
    def shift(self, n: int | IntoExprColumn=1, fill_value: IntoExpr | None=None) -> Expr: ...

    # Shrink numeric columns to the minimal required datatype.
    def shrink_dtype(self, ) -> Expr: ...

    # Shuffle the contents of this expression.
    def shuffle(self, seed: int | None=None) -> Expr: ...

    # Compute the element-wise sign function on numeric types.
    def sign(self, ) -> Expr: ...

    # Compute the element-wise value for the sine.
    def sin(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic sine.
    def sinh(self, ) -> Expr: ...

    # Compute the sample skewness of a data set.
    def skew(self, bias: bool=True) -> Expr: ...

    # Get a slice of this expression.
    def slice(self, offset: int | Expr, length: int | Expr | None=None) -> Expr: ...

    def sort(self, descending=False, nulls_last=False) -> Expr: ...

    # Sort this column by the ordering of other columns.
    def sort_by(self, by: IntoExpr | Iterable[IntoExpr], *more_by, descending: bool | Sequence[bool]=False, nulls_last: bool | Sequence[bool]=False, multithreaded: bool=True, maintain_order: bool=False) -> Expr: ...

    # Compute the square root of the elements.
    def sqrt(self, ) -> Expr: ...

    def std(self, ddof=1) -> Any: ...

    # Method equivalent of subtraction operator `expr - other`.
    def sub(self, other: Any) -> Expr: ...

    def sum(self, ) -> Expr: ...

    # Get the last `n` rows.
    def tail(self, n: int | Expr=10) -> Expr: ...

    # Compute the element-wise value for the tangent.
    def tan(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic tangent.
    def tanh(self, ) -> Expr: ...

    # Cast to physical representation of the logical dtype.
    def to_physical(self, ) -> Expr: ...

    # Return the `k` largest elements.
    def top_k(self, k: int | IntoExprColumn=5) -> Expr: ...

    # Return the elements corresponding to the `k` largest elements of the `by` column(s).
    def top_k_by(self, by: IntoExpr | Iterable[IntoExpr], k: int | IntoExprColumn=5, reverse: bool | Sequence[bool]=False) -> Expr: ...

    # Method equivalent of float division operator `expr / other`.
    def truediv(self, other: Any) -> Expr: ...

    # Get unique values of this expression.
    def unique(self, maintain_order: bool=False) -> Expr: ...

    # Return a count of the unique values in the order of appearance.
    def unique_counts(self, ) -> Expr: ...

    # Calculate the upper bound.
    def upper_bound(self, ) -> Expr: ...

    # Count the occurrence of unique values.
    def value_counts(self, sort: bool=False, parallel: bool=False, name: str | None=None, normalize: bool=False) -> Expr: ...

    def var(self, ddof=1) -> Any: ...

    # Filter a single column.
    def where(self, predicate: Expr) -> Expr: ...

    # Method equivalent of bitwise exclusive-or operator `expr ^ other`.
    def xor(self, other: Any) -> Expr: ...

    def __pos__(self, *args, **kwargs) -> Expr: ...

    def __rxor__(self, *args, **kwargs) -> Expr: ...

    def __sizeof__(self, *args, **kwargs) -> Expr: ...

    def __init_subclass__(self, *args, **kwargs) -> Expr: ...

    def __new__(self, *args, **kwargs) -> Expr: ...

    def __reduce__(self, *args, **kwargs) -> Expr: ...

    def __setattr__(self, *args, **kwargs) -> Expr: ...

    def __subclasshook__(self, *args, **kwargs) -> Expr: ...

    def _skip_batch_predicate(self, *args, **kwargs) -> Expr: ...

    def __getattribute__(self, *args, **kwargs) -> Expr: ...

    def __class__(self, *args, **kwargs) -> Expr: ...

    def _from_pyexpr(self, *args, **kwargs) -> Expr: ...

    def __bool__(self, *args, **kwargs) -> Expr: ...

    def __setstate__(self, *args, **kwargs) -> Expr: ...

    def __format__(self, *args, **kwargs) -> Expr: ...

    def __getstate__(self, *args, **kwargs) -> Expr: ...

    def __array_ufunc__(self, *args, **kwargs) -> Expr: ...

    def __xor__(self, *args, **kwargs) -> Expr: ...

    def __reduce_ex__(self, *args, **kwargs) -> Expr: ...

    def _repr_html_(self, *args, **kwargs) -> Expr: ...

    def __dir__(self, *args, **kwargs) -> Expr: ...

    def __abs__(self, *args, **kwargs) -> Expr: ...

    def __ror__(self, *args, **kwargs) -> Expr: ...

    def _map_batches_wrapper(self, *args, **kwargs) -> Expr: ...

    def __rand__(self, *args, **kwargs) -> Expr: ...

    def __str__(self, *args, **kwargs) -> Expr: ...

    def __delattr__(self, *args, **kwargs) -> Expr: ...


class Column(Expr):
    dt: DateTimeMethods
    is_simple: bool
    list: ExprListNameSpace
    name: ExprNameNameSpace
    str: StringMethods
    __module__: Any
    __annotations__: Any
    __doc__: Any

    def __add__(self, other) -> Column: ...

    def __and__(self, other) -> Expr: ...

    def __eq__(self, other) -> Column: ...

    def __floordiv__(self, other) -> Column: ...

    def __ge__(self, other) -> Expr: ...

    def __gt__(self, other) -> Column: ...

    def __init__(self, name: str, select_input: transform_schema.SelectInput | None=None) -> Any: ...

    def __invert__(self, ) -> Expr: ...

    def __le__(self, other) -> Expr: ...

    def __lt__(self, other) -> Column: ...

    def __mod__(self, other) -> Column: ...

    def __mul__(self, other) -> Column: ...

    def __ne__(self, other) -> Column: ...

    def __neg__(self, ) -> Expr: ...

    def __or__(self, other) -> Expr: ...

    def __pow__(self, exponent) -> Column: ...

    def __radd__(self, other) -> Any: ...

    def __repr__(self, ) -> str: ...

    def __rfloordiv__(self, other) -> Any: ...

    def __rmod__(self, other) -> Any: ...

    def __rmul__(self, other) -> Any: ...

    def __rpow__(self, other) -> Any: ...

    def __rsub__(self, other) -> Any: ...

    def __rtruediv__(self, other) -> Any: ...

    def __sub__(self, other) -> Column: ...

    def __truediv__(self, other) -> Column: ...

    # Creates a new Expr for binary operations.
    def _create_binary_op_expr(self, op_symbol: str, other: Any, result_expr: pl.Expr | None) -> Expr: ...

    # Creates a new Expr instance, appending method call to repr string.
    def _create_next_expr(self, *args, method_name: str, result_expr: pl.Expr | None, convertable_to_code: bool=None, is_complex: bool, _function_sources: list[str] | None=None, **kwargs) -> Expr: ...

    # Helper to get appropriate string representation for an expression
    def _get_expr_repr(self, expr) -> Any: ...

    # Compute absolute values.
    def abs(self, ) -> Expr: ...

    # Method equivalent of addition operator `expr + other`.
    def add(self, other: Any) -> Expr: ...

    # Get the group indexes of the group by operation.
    def agg_groups(self, ) -> Expr: ...

    # Rename a column, returning a new Column instance.
    def alias(self, new_name: str) -> Column: ...

    # Return whether all values in the column are `True`.
    def all(self, ignore_nulls: bool=True) -> Expr: ...

    # Method equivalent of bitwise "and" operator `expr & other & ...`.
    def and_(self, *others) -> Expr: ...

    # Return whether any of the values in the column are `True`.
    def any(self, ignore_nulls: bool=True) -> Expr: ...

    # Append expressions.
    def append(self, other: IntoExpr, upcast: bool=True) -> Expr: ...

    # Approximate count of unique values.
    def approx_n_unique(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse cosine.
    def arccos(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic cosine.
    def arccosh(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse sine.
    def arcsin(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic sine.
    def arcsinh(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse tangent.
    def arctan(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic tangent.
    def arctanh(self, ) -> Expr: ...

    # Get the index of the maximal value.
    def arg_max(self, ) -> Expr: ...

    # Get the index of the minimal value.
    def arg_min(self, ) -> Expr: ...

    def arg_sort(self, descending: bool=False, nulls_last: bool=False) -> Expr: ...

    # Return indices where expression evaluates `True`.
    def arg_true(self, ) -> Expr: ...

    def arg_unique(self, ) -> Expr: ...

    # Fill missing values with the next non-null value.
    def backward_fill(self, limit: int | None=None) -> Expr: ...

    # Perform an aggregation of bitwise ANDs.
    def bitwise_and(self, ) -> Expr: ...

    # Evaluate the number of set bits.
    def bitwise_count_ones(self, ) -> Expr: ...

    # Evaluate the number of unset bits.
    def bitwise_count_zeros(self, ) -> Expr: ...

    # Evaluate the number most-significant set bits before seeing an unset bit.
    def bitwise_leading_ones(self, ) -> Expr: ...

    # Evaluate the number most-significant unset bits before seeing a set bit.
    def bitwise_leading_zeros(self, ) -> Expr: ...

    # Perform an aggregation of bitwise ORs.
    def bitwise_or(self, ) -> Expr: ...

    # Evaluate the number least-significant set bits before seeing an unset bit.
    def bitwise_trailing_ones(self, ) -> Expr: ...

    # Evaluate the number least-significant unset bits before seeing a set bit.
    def bitwise_trailing_zeros(self, ) -> Expr: ...

    # Perform an aggregation of bitwise XORs.
    def bitwise_xor(self, ) -> Expr: ...

    # Return the `k` smallest elements.
    def bottom_k(self, k: int | IntoExprColumn=5) -> Expr: ...

    # Return the elements corresponding to the `k` smallest elements of the `by` column(s).
    def bottom_k_by(self, by: IntoExpr | Iterable[IntoExpr], k: int | IntoExprColumn=5, reverse: bool | Sequence[bool]=False) -> Expr: ...

    # Change the data type of a column, returning a new Column instance.
    def cast(self, dtype: pl.DataType | str | pl.datatypes.classes.DataTypeClass, strict=True) -> Column: ...

    # Compute the cube root of the elements.
    def cbrt(self, ) -> Expr: ...

    # Rounds up to the nearest integer value.
    def ceil(self, ) -> Expr: ...

    # Set values outside the given boundaries to the boundary value.
    def clip(self, lower_bound: NumericLiteral | TemporalLiteral | IntoExprColumn | None=None, upper_bound: NumericLiteral | TemporalLiteral | IntoExprColumn | None=None) -> Expr: ...

    # Compute the element-wise value for the cosine.
    def cos(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic cosine.
    def cosh(self, ) -> Expr: ...

    # Compute the element-wise value for the cotangent.
    def cot(self, ) -> Expr: ...

    def count(self, ) -> Column: ...

    # Return the cumulative count of the non-null values in the column.
    def cum_count(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative max computed at every element.
    def cum_max(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative min computed at every element.
    def cum_min(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative product computed at every element.
    def cum_prod(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative sum computed at every element.
    def cum_sum(self, reverse: bool=False) -> Expr: ...

    # Run an expression over a sliding window that increases `1` slot every iteration.
    def cumulative_eval(self, expr: Expr, min_samples: int=1) -> Expr: ...

    # Bin continuous values into discrete categories.
    def cut(self, breaks: Sequence[float], labels: Sequence[str] | None=None, left_closed: bool=False, include_breaks: bool=False) -> Expr: ...

    # Convert from radians to degrees.
    def degrees(self, ) -> Expr: ...

    # Read a serialized expression from a file.
    def deserialize(self, source: str | Path | IOBase | bytes, format: SerializationFormat='binary') -> Expr: ...

    # Calculate the first discrete difference between shifted items.
    def diff(self, n: int | IntoExpr=1, null_behavior: NullBehavior='ignore') -> Expr: ...

    # Compute the dot/inner product between two Expressions.
    def dot(self, other: Expr | str) -> Expr: ...

    # Drop all floating point NaN values.
    def drop_nans(self, ) -> Expr: ...

    # Drop all null values.
    def drop_nulls(self, ) -> Expr: ...

    # Computes the entropy.
    def entropy(self, base: float=2.718281828459045, normalize: bool=True) -> Expr: ...

    # Method equivalent of equality operator `expr == other`.
    def eq(self, other: Any) -> Expr: ...

    # Method equivalent of equality operator `expr == other` where `None == None`.
    def eq_missing(self, other: Any) -> Expr: ...

    # Compute exponentially-weighted moving average.
    def ewm_mean(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Compute time-based exponentially weighted moving average.
    def ewm_mean_by(self, by: str | IntoExpr, half_life: str | timedelta) -> Expr: ...

    # Compute exponentially-weighted moving standard deviation.
    def ewm_std(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, bias: bool=False, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Compute exponentially-weighted moving variance.
    def ewm_var(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, bias: bool=False, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Exclude columns from a multi-column expression.
    def exclude(self, columns: str | PolarsDataType | Collection[str] | Collection[PolarsDataType], *more_columns) -> Expr: ...

    # Compute the exponential, element-wise.
    def exp(self, ) -> Expr: ...

    def explode(self, ) -> Any: ...

    # Extremely fast method for extending the Series with 'n' copies of a value.
    def extend_constant(self, value: IntoExpr, n: int | IntoExprColumn) -> Expr: ...

    def fill_nan(self, value) -> Column: ...

    def fill_null(self, value) -> Column: ...

    # Filter expression
    def filter(self, *predicates, **constraints) -> Expr: ...

    def first(self, ) -> Column: ...

    # Flatten a list or string column.
    def flatten(self, ) -> Expr: ...

    # Rounds down to the nearest integer value.
    def floor(self, ) -> Expr: ...

    # Method equivalent of integer division operator `expr // other`.
    def floordiv(self, other: Any) -> Expr: ...

    # Fill missing values with the last non-null value.
    def forward_fill(self, limit: int | None=None) -> Expr: ...

    # Read an expression from a JSON encoded string to construct an Expression.
    def from_json(self, value: str) -> Expr: ...

    # Take values by index.
    def gather(self, indices: int | Sequence[int] | IntoExpr | Series | np.ndarray[Any, Any]) -> Expr: ...

    # Take every nth value in the Series and return as a new Series.
    def gather_every(self, n: int, offset: int=0) -> Expr: ...

    # Method equivalent of "greater than or equal" operator `expr >= other`.
    def ge(self, other: Any) -> Expr: ...

    # Return a single value by index.
    def get(self, index: int | Expr) -> Expr: ...

    # Get the Polars code representation of this expression, including any function definitions.
    def get_polars_code(self, ) -> str: ...

    # Method equivalent of "greater than" operator `expr > other`.
    def gt(self, other: Any) -> Expr: ...

    # Check whether the expression contains one or more null values.
    def has_nulls(self, ) -> Expr: ...

    # Hash the elements in the selection.
    def hash(self, seed: int=0, seed_1: int | None=None, seed_2: int | None=None, seed_3: int | None=None) -> Expr: ...

    # Get the first `n` rows.
    def head(self, n: int | Expr=10) -> Expr: ...

    # Bin values into buckets and count their occurrences.
    def hist(self, bins: IntoExpr | None=None, bin_count: int | None=None, include_category: bool=False, include_breakpoint: bool=False) -> Expr: ...

    def implode(self, ) -> Any: ...

    # Get the index of the first occurrence of a value, or ``None`` if it's not found.
    def index_of(self, element: IntoExpr) -> Expr: ...

    # Print the value that this expression evaluates to and pass on the value.
    def inspect(self, fmt: str='{}') -> Expr: ...

    # Interpolate intermediate values.
    def interpolate(self, method: InterpolationMethod='linear') -> Expr: ...

    # Fill null values using interpolation based on another column.
    def interpolate_by(self, by: IntoExpr) -> Expr: ...

    # Check if this expression is between the given lower and upper bounds.
    def is_between(self, lower_bound: IntoExpr, upper_bound: IntoExpr, closed: ClosedInterval='both') -> Expr: ...

    # Return a boolean mask indicating duplicated values.
    def is_duplicated(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are finite.
    def is_finite(self, ) -> Expr: ...

    # Return a boolean mask indicating the first occurrence of each distinct value.
    def is_first_distinct(self, ) -> Expr: ...

    def is_in(self, values) -> Any: ...

    # Returns a boolean Series indicating which values are infinite.
    def is_infinite(self, ) -> Expr: ...

    # Return a boolean mask indicating the last occurrence of each distinct value.
    def is_last_distinct(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are NaN.
    def is_nan(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are not NaN.
    def is_not_nan(self, ) -> Expr: ...

    def is_not_null(self, ) -> Column: ...

    def is_null(self, ) -> Column: ...

    # Get mask of unique values.
    def is_unique(self, ) -> Expr: ...

    # Compute the kurtosis (Fisher or Pearson) of a dataset.
    def kurtosis(self, fisher: bool=True, bias: bool=True) -> Expr: ...

    def last(self, ) -> Column: ...

    # Method equivalent of "less than or equal" operator `expr <= other`.
    def le(self, other: Any) -> Expr: ...

    # Return the number of elements in the column.
    def len(self, ) -> Expr: ...

    # Get the first `n` rows (alias for :func:`Expr.head`).
    def limit(self, n: int | Expr=10) -> Expr: ...

    # Compute the logarithm to a given base.
    def log(self, base: float=2.718281828459045) -> Expr: ...

    # Compute the base 10 logarithm of the input array, element-wise.
    def log10(self, ) -> Expr: ...

    # Compute the natural logarithm of each element plus one.
    def log1p(self, ) -> Expr: ...

    # Calculate the lower bound.
    def lower_bound(self, ) -> Expr: ...

    # Method equivalent of "less than" operator `expr < other`.
    def lt(self, other: Any) -> Expr: ...

    # Apply a custom python function to a whole Series or sequence of Series.
    def map_batches(self, function: Callable[[Series], Series | Any], return_dtype: PolarsDataType | pl.DataTypeExpr | None=None, agg_list: bool=False, is_elementwise: bool=False, returns_scalar: bool=False) -> Expr: ...

    # Map a custom/user-defined function (UDF) to each element of a column.
    def map_elements(self, function: Callable[[Any], Any], return_dtype: PolarsDataType | None=None, skip_nulls: bool=True, pass_name: bool=False, strategy: MapElementsStrategy='thread_local', returns_scalar: bool=False) -> Expr: ...

    def max(self, ) -> Column: ...

    def mean(self, ) -> Column: ...

    def median(self, ) -> Any: ...

    def min(self, ) -> Column: ...

    # Method equivalent of modulus operator `expr % other`.
    def mod(self, other: Any) -> Expr: ...

    # Compute the most occurring value(s).
    def mode(self, ) -> Expr: ...

    # Method equivalent of multiplication operator `expr * other`.
    def mul(self, other: Any) -> Expr: ...

    def n_unique(self, ) -> Any: ...

    # Get maximum value, but propagate/poison encountered NaN values.
    def nan_max(self, ) -> Expr: ...

    # Get minimum value, but propagate/poison encountered NaN values.
    def nan_min(self, ) -> Expr: ...

    # Method equivalent of inequality operator `expr != other`.
    def ne(self, other: Any) -> Expr: ...

    # Method equivalent of equality operator `expr != other` where `None == None`.
    def ne_missing(self, other: Any) -> Expr: ...

    # Method equivalent of unary minus operator `-expr`.
    def neg(self, ) -> Expr: ...

    # Negate a boolean expression.
    def not_(self, ) -> Expr: ...

    # Count null values.
    def null_count(self, ) -> Expr: ...

    # Method equivalent of bitwise "or" operator `expr | other | ...`.
    def or_(self, *others) -> Expr: ...

    # Compute expressions over the given groups.
    def over(self, partition_by: ExprStrOrList, *more_exprs, order_by: ExprStrOrList | None=None, descending: bool=False, nulls_last: bool=False, mapping_strategy: Literal[group_to_rows, join, explode]='group_to_rows') -> Expr: ...

    # Computes percentage change between values.
    def pct_change(self, n: int | IntoExprColumn=1) -> Expr: ...

    # Get a boolean mask of the local maximum peaks.
    def peak_max(self, ) -> Expr: ...

    # Get a boolean mask of the local minimum peaks.
    def peak_min(self, ) -> Expr: ...

    # Offers a structured way to apply a sequence of user-defined functions (UDFs).
    def pipe(self, function: Callable[Concatenate[Expr, P], T], *args, **kwargs) -> T: ...

    # Method equivalent of exponentiation operator `expr ** exponent`.
    def pow(self, exponent: IntoExprColumn | int | float) -> Expr: ...

    # Compute the product of an expression.
    def product(self, ) -> Expr: ...

    # Bin continuous values into discrete categories based on their quantiles.
    def qcut(self, quantiles: Sequence[float] | int, labels: Sequence[str] | None=None, left_closed: bool=False, allow_duplicates: bool=False, include_breaks: bool=False) -> Expr: ...

    # Get quantile value.
    def quantile(self, quantile: float | Expr, interpolation: QuantileMethod='nearest') -> Expr: ...

    # Convert from degrees to radians.
    def radians(self, ) -> Expr: ...

    # Assign ranks to data, dealing with ties appropriately.
    def rank(self, method: RankMethod='average', descending: bool=False, seed: int | None=None) -> Expr: ...

    # Create a single chunk of memory for this Series.
    def rechunk(self, ) -> Expr: ...

    # Register a plugin function.
    def register_plugin(self, lib: str, symbol: str, args: list[IntoExpr] | None=None, kwargs: dict[Any, Any] | None=None, is_elementwise: bool=False, input_wildcard_expansion: bool=False, returns_scalar: bool=False, cast_to_supertypes: bool=False, pass_name_to_apply: bool=False, changes_length: bool=False) -> Expr: ...

    # Reinterpret the underlying bits as a signed/unsigned integer.
    def reinterpret(self, signed: bool=True) -> Expr: ...

    # Repeat the elements in this Series as specified in the given expression.
    def repeat_by(self, by: pl.Series | Expr | str | int) -> Expr: ...

    # Replace the given values by different values of the same data type.
    def replace(self, old: IntoExpr | Sequence[Any] | Mapping[Any, Any], new: IntoExpr | Sequence[Any], default: IntoExpr, return_dtype: PolarsDataType | None=None) -> Expr: ...

    # Replace all values by different values.
    def replace_strict(self, old: IntoExpr | Sequence[Any] | Mapping[Any, Any], new: IntoExpr | Sequence[Any], default: IntoExpr, return_dtype: PolarsDataType | pl.DataTypeExpr | None=None) -> Expr: ...

    # Reshape this Expr to a flat column or an Array column.
    def reshape(self, dimensions: tuple[int, ...]) -> Expr: ...

    # Reverse the selection.
    def reverse(self, ) -> Expr: ...

    # Compress the column data using run-length encoding.
    def rle(self, ) -> Expr: ...

    # Get a distinct integer ID for each run of identical values.
    def rle_id(self, ) -> Expr: ...

    # Create rolling groups based on a temporal or integer column.
    def rolling(self, index_column: str, period: str | timedelta, offset: str | timedelta | None=None, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling kurtosis.
    def rolling_kurtosis(self, window_size: int, fisher: bool=True, bias: bool=True, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a custom rolling window function.
    def rolling_map(self, function: Callable[[Series], Any], window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling max (moving max) over the values in this array.
    def rolling_max(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling max based on another column.
    def rolling_max_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Apply a rolling mean (moving mean) over the values in this array.
    def rolling_mean(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling mean based on another column.
    def rolling_mean_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling median.
    def rolling_median(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling median based on another column.
    def rolling_median_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Apply a rolling min (moving min) over the values in this array.
    def rolling_min(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling min based on another column.
    def rolling_min_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling quantile.
    def rolling_quantile(self, quantile: float, interpolation: QuantileMethod='nearest', window_size: int=2, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling quantile based on another column.
    def rolling_quantile_by(self, by: IntoExpr, window_size: timedelta | str, quantile: float, interpolation: QuantileMethod='nearest', min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling skew.
    def rolling_skew(self, window_size: int, bias: bool=True, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling standard deviation.
    def rolling_std(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False, ddof: int=1) -> Expr: ...

    # Compute a rolling standard deviation based on another column.
    def rolling_std_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right', ddof: int=1) -> Expr: ...

    # Apply a rolling sum (moving sum) over the values in this array.
    def rolling_sum(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling sum based on another column.
    def rolling_sum_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling variance.
    def rolling_var(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False, ddof: int=1) -> Expr: ...

    # Compute a rolling variance based on another column.
    def rolling_var_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right', ddof: int=1) -> Expr: ...

    # Round underlying floating point data by `decimals` digits.
    def round(self, decimals: int=0, mode: RoundMode='half_to_even') -> Expr: ...

    # Round to a number of significant figures.
    def round_sig_figs(self, digits: int) -> Expr: ...

    # Sample from this expression.
    def sample(self, n: int | IntoExprColumn | None=None, fraction: float | IntoExprColumn | None=None, with_replacement: bool=False, shuffle: bool=False, seed: int | None=None) -> Expr: ...

    # Find indices where elements should be inserted to maintain order.
    def search_sorted(self, element: IntoExpr | np.ndarray[Any, Any], side: SearchSortedSide='any', descending: bool=False) -> Expr: ...

    # Flags the expression as 'sorted'.
    def set_sorted(self, descending: bool=False) -> Expr: ...

    # Shift values by the given number of indices.
    def shift(self, n: int | IntoExprColumn=1, fill_value: IntoExpr | None=None) -> Expr: ...

    # Shrink numeric columns to the minimal required datatype.
    def shrink_dtype(self, ) -> Expr: ...

    # Shuffle the contents of this expression.
    def shuffle(self, seed: int | None=None) -> Expr: ...

    # Compute the element-wise sign function on numeric types.
    def sign(self, ) -> Expr: ...

    # Compute the element-wise value for the sine.
    def sin(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic sine.
    def sinh(self, ) -> Expr: ...

    # Compute the sample skewness of a data set.
    def skew(self, bias: bool=True) -> Expr: ...

    # Get a slice of this expression.
    def slice(self, offset: int | Expr, length: int | Expr | None=None) -> Expr: ...

    def sort(self, descending=False, nulls_last=False) -> Column: ...

    # Sort this column by the ordering of other columns.
    def sort_by(self, by: IntoExpr | Iterable[IntoExpr], *more_by, descending: bool | Sequence[bool]=False, nulls_last: bool | Sequence[bool]=False, multithreaded: bool=True, maintain_order: bool=False) -> Expr: ...

    # Compute the square root of the elements.
    def sqrt(self, ) -> Expr: ...

    def std(self, ddof=1) -> Any: ...

    # Method equivalent of subtraction operator `expr - other`.
    def sub(self, other: Any) -> Expr: ...

    def sum(self, ) -> Column: ...

    # Get the last `n` rows.
    def tail(self, n: int | Expr=10) -> Expr: ...

    # Compute the element-wise value for the tangent.
    def tan(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic tangent.
    def tanh(self, ) -> Expr: ...

    # Cast to physical representation of the logical dtype.
    def to_physical(self, ) -> Expr: ...

    # Convert Column state back to a SelectInput schema object.
    def to_select_input(self, ) -> transform_schema.SelectInput: ...

    # Return the `k` largest elements.
    def top_k(self, k: int | IntoExprColumn=5) -> Expr: ...

    # Return the elements corresponding to the `k` largest elements of the `by` column(s).
    def top_k_by(self, by: IntoExpr | Iterable[IntoExpr], k: int | IntoExprColumn=5, reverse: bool | Sequence[bool]=False) -> Expr: ...

    # Method equivalent of float division operator `expr / other`.
    def truediv(self, other: Any) -> Expr: ...

    # Get unique values of this expression.
    def unique(self, maintain_order: bool=False) -> Expr: ...

    # Return a count of the unique values in the order of appearance.
    def unique_counts(self, ) -> Expr: ...

    # Calculate the upper bound.
    def upper_bound(self, ) -> Expr: ...

    # Count the occurrence of unique values.
    def value_counts(self, sort: bool=False, parallel: bool=False, name: str | None=None, normalize: bool=False) -> Expr: ...

    def var(self, ddof=1) -> Any: ...

    # Filter a single column.
    def where(self, predicate: Expr) -> Expr: ...

    # Method equivalent of bitwise exclusive-or operator `expr ^ other`.
    def xor(self, other: Any) -> Expr: ...


class When(Expr):
    dt: DateTimeMethods
    is_simple: bool
    list: ExprListNameSpace
    name: ExprNameNameSpace
    str: StringMethods
    __module__: Any
    __doc__: Any
    __annotations__: Any

    def __add__(self, other) -> When: ...

    def __and__(self, other) -> Expr: ...

    def __eq__(self, other) -> When: ...

    def __floordiv__(self, other) -> When: ...

    def __ge__(self, other) -> Expr: ...

    def __gt__(self, other) -> When: ...

    # Initialize a When expression with a condition.
    def __init__(self, condition) -> Any: ...

    def __invert__(self, ) -> Expr: ...

    def __le__(self, other) -> Expr: ...

    def __lt__(self, other) -> When: ...

    def __mod__(self, other) -> When: ...

    def __mul__(self, other) -> When: ...

    def __ne__(self, other) -> When: ...

    def __neg__(self, ) -> Expr: ...

    def __or__(self, other) -> Expr: ...

    def __pow__(self, exponent) -> When: ...

    def __radd__(self, other) -> Any: ...

    def __repr__(self, ) -> str: ...

    def __rfloordiv__(self, other) -> Any: ...

    def __rmod__(self, other) -> Any: ...

    def __rmul__(self, other) -> Any: ...

    def __rpow__(self, other) -> Any: ...

    def __rsub__(self, other) -> Any: ...

    def __rtruediv__(self, other) -> Any: ...

    def __sub__(self, other) -> When: ...

    def __truediv__(self, other) -> When: ...

    # Creates a new Expr for binary operations.
    def _create_binary_op_expr(self, op_symbol: str, other: Any, result_expr: pl.Expr | None) -> Expr: ...

    # Creates a new Expr instance, appending method call to repr string.
    def _create_next_expr(self, *args, method_name: str, result_expr: pl.Expr | None, convertable_to_code: bool=None, is_complex: bool, _function_sources: list[str] | None=None, **kwargs) -> Expr: ...

    # Extract expression and representation from a value.
    def _get_expr_and_repr(self, value) -> Any: ...

    # Helper to get appropriate string representation for an expression
    def _get_expr_repr(self, expr) -> Any: ...

    # Compute absolute values.
    def abs(self, ) -> Expr: ...

    # Method equivalent of addition operator `expr + other`.
    def add(self, other: Any) -> Expr: ...

    # Get the group indexes of the group by operation.
    def agg_groups(self, ) -> Expr: ...

    # Rename the expression result.
    def alias(self, name) -> When: ...

    # Return whether all values in the column are `True`.
    def all(self, ignore_nulls: bool=True) -> Expr: ...

    # Method equivalent of bitwise "and" operator `expr & other & ...`.
    def and_(self, *others) -> Expr: ...

    # Return whether any of the values in the column are `True`.
    def any(self, ignore_nulls: bool=True) -> Expr: ...

    # Append expressions.
    def append(self, other: IntoExpr, upcast: bool=True) -> Expr: ...

    # Approximate count of unique values.
    def approx_n_unique(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse cosine.
    def arccos(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic cosine.
    def arccosh(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse sine.
    def arcsin(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic sine.
    def arcsinh(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse tangent.
    def arctan(self, ) -> Expr: ...

    # Compute the element-wise value for the inverse hyperbolic tangent.
    def arctanh(self, ) -> Expr: ...

    # Get the index of the maximal value.
    def arg_max(self, ) -> Expr: ...

    # Get the index of the minimal value.
    def arg_min(self, ) -> Expr: ...

    def arg_sort(self, descending: bool=False, nulls_last: bool=False) -> Expr: ...

    # Return indices where expression evaluates `True`.
    def arg_true(self, ) -> Expr: ...

    def arg_unique(self, ) -> Expr: ...

    # Fill missing values with the next non-null value.
    def backward_fill(self, limit: int | None=None) -> Expr: ...

    # Perform an aggregation of bitwise ANDs.
    def bitwise_and(self, ) -> Expr: ...

    # Evaluate the number of set bits.
    def bitwise_count_ones(self, ) -> Expr: ...

    # Evaluate the number of unset bits.
    def bitwise_count_zeros(self, ) -> Expr: ...

    # Evaluate the number most-significant set bits before seeing an unset bit.
    def bitwise_leading_ones(self, ) -> Expr: ...

    # Evaluate the number most-significant unset bits before seeing a set bit.
    def bitwise_leading_zeros(self, ) -> Expr: ...

    # Perform an aggregation of bitwise ORs.
    def bitwise_or(self, ) -> Expr: ...

    # Evaluate the number least-significant set bits before seeing an unset bit.
    def bitwise_trailing_ones(self, ) -> Expr: ...

    # Evaluate the number least-significant unset bits before seeing a set bit.
    def bitwise_trailing_zeros(self, ) -> Expr: ...

    # Perform an aggregation of bitwise XORs.
    def bitwise_xor(self, ) -> Expr: ...

    # Return the `k` smallest elements.
    def bottom_k(self, k: int | IntoExprColumn=5) -> Expr: ...

    # Return the elements corresponding to the `k` smallest elements of the `by` column(s).
    def bottom_k_by(self, by: IntoExpr | Iterable[IntoExpr], k: int | IntoExprColumn=5, reverse: bool | Sequence[bool]=False) -> Expr: ...

    # Casts the Expr to a specified data type.
    def cast(self, dtype: pl.DataType | str | pl.datatypes.classes.DataTypeClass, strict=True) -> When: ...

    # Compute the cube root of the elements.
    def cbrt(self, ) -> Expr: ...

    # Rounds up to the nearest integer value.
    def ceil(self, ) -> Expr: ...

    # Set values outside the given boundaries to the boundary value.
    def clip(self, lower_bound: NumericLiteral | TemporalLiteral | IntoExprColumn | None=None, upper_bound: NumericLiteral | TemporalLiteral | IntoExprColumn | None=None) -> Expr: ...

    # Compute the element-wise value for the cosine.
    def cos(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic cosine.
    def cosh(self, ) -> Expr: ...

    # Compute the element-wise value for the cotangent.
    def cot(self, ) -> Expr: ...

    def count(self, ) -> When: ...

    # Return the cumulative count of the non-null values in the column.
    def cum_count(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative max computed at every element.
    def cum_max(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative min computed at every element.
    def cum_min(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative product computed at every element.
    def cum_prod(self, reverse: bool=False) -> Expr: ...

    # Get an array with the cumulative sum computed at every element.
    def cum_sum(self, reverse: bool=False) -> Expr: ...

    # Run an expression over a sliding window that increases `1` slot every iteration.
    def cumulative_eval(self, expr: Expr, min_samples: int=1) -> Expr: ...

    # Bin continuous values into discrete categories.
    def cut(self, breaks: Sequence[float], labels: Sequence[str] | None=None, left_closed: bool=False, include_breaks: bool=False) -> Expr: ...

    # Convert from radians to degrees.
    def degrees(self, ) -> Expr: ...

    # Read a serialized expression from a file.
    def deserialize(self, source: str | Path | IOBase | bytes, format: SerializationFormat='binary') -> Expr: ...

    # Calculate the first discrete difference between shifted items.
    def diff(self, n: int | IntoExpr=1, null_behavior: NullBehavior='ignore') -> Expr: ...

    # Compute the dot/inner product between two Expressions.
    def dot(self, other: Expr | str) -> Expr: ...

    # Drop all floating point NaN values.
    def drop_nans(self, ) -> Expr: ...

    # Drop all null values.
    def drop_nulls(self, ) -> Expr: ...

    # Computes the entropy.
    def entropy(self, base: float=2.718281828459045, normalize: bool=True) -> Expr: ...

    # Method equivalent of equality operator `expr == other`.
    def eq(self, other: Any) -> Expr: ...

    # Method equivalent of equality operator `expr == other` where `None == None`.
    def eq_missing(self, other: Any) -> Expr: ...

    # Compute exponentially-weighted moving average.
    def ewm_mean(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Compute time-based exponentially weighted moving average.
    def ewm_mean_by(self, by: str | IntoExpr, half_life: str | timedelta) -> Expr: ...

    # Compute exponentially-weighted moving standard deviation.
    def ewm_std(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, bias: bool=False, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Compute exponentially-weighted moving variance.
    def ewm_var(self, com: float | None=None, span: float | None=None, half_life: float | None=None, alpha: float | None=None, adjust: bool=True, bias: bool=False, min_samples: int=1, ignore_nulls: bool=False) -> Expr: ...

    # Exclude columns from a multi-column expression.
    def exclude(self, columns: str | PolarsDataType | Collection[str] | Collection[PolarsDataType], *more_columns) -> Expr: ...

    # Compute the exponential, element-wise.
    def exp(self, ) -> Expr: ...

    def explode(self, ) -> Any: ...

    # Extremely fast method for extending the Series with 'n' copies of a value.
    def extend_constant(self, value: IntoExpr, n: int | IntoExprColumn) -> Expr: ...

    def fill_nan(self, value) -> When: ...

    def fill_null(self, value) -> When: ...

    # Filter expression
    def filter(self, *predicates, **constraints) -> Expr: ...

    def first(self, ) -> When: ...

    # Flatten a list or string column.
    def flatten(self, ) -> Expr: ...

    # Rounds down to the nearest integer value.
    def floor(self, ) -> Expr: ...

    # Method equivalent of integer division operator `expr // other`.
    def floordiv(self, other: Any) -> Expr: ...

    # Fill missing values with the last non-null value.
    def forward_fill(self, limit: int | None=None) -> Expr: ...

    # Read an expression from a JSON encoded string to construct an Expression.
    def from_json(self, value: str) -> Expr: ...

    # Take values by index.
    def gather(self, indices: int | Sequence[int] | IntoExpr | Series | np.ndarray[Any, Any]) -> Expr: ...

    # Take every nth value in the Series and return as a new Series.
    def gather_every(self, n: int, offset: int=0) -> Expr: ...

    # Method equivalent of "greater than or equal" operator `expr >= other`.
    def ge(self, other: Any) -> Expr: ...

    # Return a single value by index.
    def get(self, index: int | Expr) -> Expr: ...

    # Get the Polars code representation of this expression, including any function definitions.
    def get_polars_code(self, ) -> str: ...

    # Method equivalent of "greater than" operator `expr > other`.
    def gt(self, other: Any) -> Expr: ...

    # Check whether the expression contains one or more null values.
    def has_nulls(self, ) -> Expr: ...

    # Hash the elements in the selection.
    def hash(self, seed: int=0, seed_1: int | None=None, seed_2: int | None=None, seed_3: int | None=None) -> Expr: ...

    # Get the first `n` rows.
    def head(self, n: int | Expr=10) -> Expr: ...

    # Bin values into buckets and count their occurrences.
    def hist(self, bins: IntoExpr | None=None, bin_count: int | None=None, include_category: bool=False, include_breakpoint: bool=False) -> Expr: ...

    def implode(self, ) -> Any: ...

    # Get the index of the first occurrence of a value, or ``None`` if it's not found.
    def index_of(self, element: IntoExpr) -> Expr: ...

    # Print the value that this expression evaluates to and pass on the value.
    def inspect(self, fmt: str='{}') -> Expr: ...

    # Interpolate intermediate values.
    def interpolate(self, method: InterpolationMethod='linear') -> Expr: ...

    # Fill null values using interpolation based on another column.
    def interpolate_by(self, by: IntoExpr) -> Expr: ...

    # Check if this expression is between the given lower and upper bounds.
    def is_between(self, lower_bound: IntoExpr, upper_bound: IntoExpr, closed: ClosedInterval='both') -> Expr: ...

    # Return a boolean mask indicating duplicated values.
    def is_duplicated(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are finite.
    def is_finite(self, ) -> Expr: ...

    # Return a boolean mask indicating the first occurrence of each distinct value.
    def is_first_distinct(self, ) -> Expr: ...

    def is_in(self, values) -> Any: ...

    # Returns a boolean Series indicating which values are infinite.
    def is_infinite(self, ) -> Expr: ...

    # Return a boolean mask indicating the last occurrence of each distinct value.
    def is_last_distinct(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are NaN.
    def is_nan(self, ) -> Expr: ...

    # Returns a boolean Series indicating which values are not NaN.
    def is_not_nan(self, ) -> Expr: ...

    def is_not_null(self, ) -> When: ...

    def is_null(self, ) -> When: ...

    # Get mask of unique values.
    def is_unique(self, ) -> Expr: ...

    # Compute the kurtosis (Fisher or Pearson) of a dataset.
    def kurtosis(self, fisher: bool=True, bias: bool=True) -> Expr: ...

    def last(self, ) -> When: ...

    # Method equivalent of "less than or equal" operator `expr <= other`.
    def le(self, other: Any) -> Expr: ...

    # Return the number of elements in the column.
    def len(self, ) -> Expr: ...

    # Get the first `n` rows (alias for :func:`Expr.head`).
    def limit(self, n: int | Expr=10) -> Expr: ...

    # Compute the logarithm to a given base.
    def log(self, base: float=2.718281828459045) -> Expr: ...

    # Compute the base 10 logarithm of the input array, element-wise.
    def log10(self, ) -> Expr: ...

    # Compute the natural logarithm of each element plus one.
    def log1p(self, ) -> Expr: ...

    # Calculate the lower bound.
    def lower_bound(self, ) -> Expr: ...

    # Method equivalent of "less than" operator `expr < other`.
    def lt(self, other: Any) -> Expr: ...

    # Apply a custom python function to a whole Series or sequence of Series.
    def map_batches(self, function: Callable[[Series], Series | Any], return_dtype: PolarsDataType | pl.DataTypeExpr | None=None, agg_list: bool=False, is_elementwise: bool=False, returns_scalar: bool=False) -> Expr: ...

    # Map a custom/user-defined function (UDF) to each element of a column.
    def map_elements(self, function: Callable[[Any], Any], return_dtype: PolarsDataType | None=None, skip_nulls: bool=True, pass_name: bool=False, strategy: MapElementsStrategy='thread_local', returns_scalar: bool=False) -> Expr: ...

    def max(self, ) -> When: ...

    def mean(self, ) -> When: ...

    def median(self, ) -> Any: ...

    def min(self, ) -> When: ...

    # Method equivalent of modulus operator `expr % other`.
    def mod(self, other: Any) -> Expr: ...

    # Compute the most occurring value(s).
    def mode(self, ) -> Expr: ...

    # Method equivalent of multiplication operator `expr * other`.
    def mul(self, other: Any) -> Expr: ...

    def n_unique(self, ) -> Any: ...

    # Get maximum value, but propagate/poison encountered NaN values.
    def nan_max(self, ) -> Expr: ...

    # Get minimum value, but propagate/poison encountered NaN values.
    def nan_min(self, ) -> Expr: ...

    # Method equivalent of inequality operator `expr != other`.
    def ne(self, other: Any) -> Expr: ...

    # Method equivalent of equality operator `expr != other` where `None == None`.
    def ne_missing(self, other: Any) -> Expr: ...

    # Method equivalent of unary minus operator `-expr`.
    def neg(self, ) -> Expr: ...

    # Negate a boolean expression.
    def not_(self, ) -> Expr: ...

    # Count null values.
    def null_count(self, ) -> Expr: ...

    # Method equivalent of bitwise "or" operator `expr | other | ...`.
    def or_(self, *others) -> Expr: ...

    # Set the value to use when no condition is True.
    def otherwise(self, value) -> Any: ...

    # Compute expressions over the given groups.
    def over(self, partition_by: ExprStrOrList, *more_exprs, order_by: ExprStrOrList | None=None, descending: bool=False, nulls_last: bool=False, mapping_strategy: Literal[group_to_rows, join, explode]='group_to_rows') -> Expr: ...

    # Computes percentage change between values.
    def pct_change(self, n: int | IntoExprColumn=1) -> Expr: ...

    # Get a boolean mask of the local maximum peaks.
    def peak_max(self, ) -> Expr: ...

    # Get a boolean mask of the local minimum peaks.
    def peak_min(self, ) -> Expr: ...

    # Offers a structured way to apply a sequence of user-defined functions (UDFs).
    def pipe(self, function: Callable[Concatenate[Expr, P], T], *args, **kwargs) -> T: ...

    # Method equivalent of exponentiation operator `expr ** exponent`.
    def pow(self, exponent: IntoExprColumn | int | float) -> Expr: ...

    # Compute the product of an expression.
    def product(self, ) -> Expr: ...

    # Bin continuous values into discrete categories based on their quantiles.
    def qcut(self, quantiles: Sequence[float] | int, labels: Sequence[str] | None=None, left_closed: bool=False, allow_duplicates: bool=False, include_breaks: bool=False) -> Expr: ...

    # Get quantile value.
    def quantile(self, quantile: float | Expr, interpolation: QuantileMethod='nearest') -> Expr: ...

    # Convert from degrees to radians.
    def radians(self, ) -> Expr: ...

    # Assign ranks to data, dealing with ties appropriately.
    def rank(self, method: RankMethod='average', descending: bool=False, seed: int | None=None) -> Expr: ...

    # Create a single chunk of memory for this Series.
    def rechunk(self, ) -> Expr: ...

    # Register a plugin function.
    def register_plugin(self, lib: str, symbol: str, args: list[IntoExpr] | None=None, kwargs: dict[Any, Any] | None=None, is_elementwise: bool=False, input_wildcard_expansion: bool=False, returns_scalar: bool=False, cast_to_supertypes: bool=False, pass_name_to_apply: bool=False, changes_length: bool=False) -> Expr: ...

    # Reinterpret the underlying bits as a signed/unsigned integer.
    def reinterpret(self, signed: bool=True) -> Expr: ...

    # Repeat the elements in this Series as specified in the given expression.
    def repeat_by(self, by: pl.Series | Expr | str | int) -> Expr: ...

    # Replace the given values by different values of the same data type.
    def replace(self, old: IntoExpr | Sequence[Any] | Mapping[Any, Any], new: IntoExpr | Sequence[Any], default: IntoExpr, return_dtype: PolarsDataType | None=None) -> Expr: ...

    # Replace all values by different values.
    def replace_strict(self, old: IntoExpr | Sequence[Any] | Mapping[Any, Any], new: IntoExpr | Sequence[Any], default: IntoExpr, return_dtype: PolarsDataType | pl.DataTypeExpr | None=None) -> Expr: ...

    # Reshape this Expr to a flat column or an Array column.
    def reshape(self, dimensions: tuple[int, ...]) -> Expr: ...

    # Reverse the selection.
    def reverse(self, ) -> Expr: ...

    # Compress the column data using run-length encoding.
    def rle(self, ) -> Expr: ...

    # Get a distinct integer ID for each run of identical values.
    def rle_id(self, ) -> Expr: ...

    # Create rolling groups based on a temporal or integer column.
    def rolling(self, index_column: str, period: str | timedelta, offset: str | timedelta | None=None, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling kurtosis.
    def rolling_kurtosis(self, window_size: int, fisher: bool=True, bias: bool=True, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a custom rolling window function.
    def rolling_map(self, function: Callable[[Series], Any], window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling max (moving max) over the values in this array.
    def rolling_max(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling max based on another column.
    def rolling_max_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Apply a rolling mean (moving mean) over the values in this array.
    def rolling_mean(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling mean based on another column.
    def rolling_mean_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling median.
    def rolling_median(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling median based on another column.
    def rolling_median_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Apply a rolling min (moving min) over the values in this array.
    def rolling_min(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling min based on another column.
    def rolling_min_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling quantile.
    def rolling_quantile(self, quantile: float, interpolation: QuantileMethod='nearest', window_size: int=2, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling quantile based on another column.
    def rolling_quantile_by(self, by: IntoExpr, window_size: timedelta | str, quantile: float, interpolation: QuantileMethod='nearest', min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling skew.
    def rolling_skew(self, window_size: int, bias: bool=True, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Compute a rolling standard deviation.
    def rolling_std(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False, ddof: int=1) -> Expr: ...

    # Compute a rolling standard deviation based on another column.
    def rolling_std_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right', ddof: int=1) -> Expr: ...

    # Apply a rolling sum (moving sum) over the values in this array.
    def rolling_sum(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False) -> Expr: ...

    # Apply a rolling sum based on another column.
    def rolling_sum_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right') -> Expr: ...

    # Compute a rolling variance.
    def rolling_var(self, window_size: int, weights: list[float] | None=None, min_samples: int | None=None, center: bool=False, ddof: int=1) -> Expr: ...

    # Compute a rolling variance based on another column.
    def rolling_var_by(self, by: IntoExpr, window_size: timedelta | str, min_samples: int=1, closed: ClosedInterval='right', ddof: int=1) -> Expr: ...

    # Round underlying floating point data by `decimals` digits.
    def round(self, decimals: int=0, mode: RoundMode='half_to_even') -> Expr: ...

    # Round to a number of significant figures.
    def round_sig_figs(self, digits: int) -> Expr: ...

    # Sample from this expression.
    def sample(self, n: int | IntoExprColumn | None=None, fraction: float | IntoExprColumn | None=None, with_replacement: bool=False, shuffle: bool=False, seed: int | None=None) -> Expr: ...

    # Find indices where elements should be inserted to maintain order.
    def search_sorted(self, element: IntoExpr | np.ndarray[Any, Any], side: SearchSortedSide='any', descending: bool=False) -> Expr: ...

    # Flags the expression as 'sorted'.
    def set_sorted(self, descending: bool=False) -> Expr: ...

    # Shift values by the given number of indices.
    def shift(self, n: int | IntoExprColumn=1, fill_value: IntoExpr | None=None) -> Expr: ...

    # Shrink numeric columns to the minimal required datatype.
    def shrink_dtype(self, ) -> Expr: ...

    # Shuffle the contents of this expression.
    def shuffle(self, seed: int | None=None) -> Expr: ...

    # Compute the element-wise sign function on numeric types.
    def sign(self, ) -> Expr: ...

    # Compute the element-wise value for the sine.
    def sin(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic sine.
    def sinh(self, ) -> Expr: ...

    # Compute the sample skewness of a data set.
    def skew(self, bias: bool=True) -> Expr: ...

    # Get a slice of this expression.
    def slice(self, offset: int | Expr, length: int | Expr | None=None) -> Expr: ...

    def sort(self, descending=False, nulls_last=False) -> When: ...

    # Sort this column by the ordering of other columns.
    def sort_by(self, by: IntoExpr | Iterable[IntoExpr], *more_by, descending: bool | Sequence[bool]=False, nulls_last: bool | Sequence[bool]=False, multithreaded: bool=True, maintain_order: bool=False) -> Expr: ...

    # Compute the square root of the elements.
    def sqrt(self, ) -> Expr: ...

    def std(self, ddof=1) -> Any: ...

    # Method equivalent of subtraction operator `expr - other`.
    def sub(self, other: Any) -> Expr: ...

    def sum(self, ) -> When: ...

    # Get the last `n` rows.
    def tail(self, n: int | Expr=10) -> Expr: ...

    # Compute the element-wise value for the tangent.
    def tan(self, ) -> Expr: ...

    # Compute the element-wise value for the hyperbolic tangent.
    def tanh(self, ) -> Expr: ...

    # Set the value to use when the condition is True.
    def then(self, value) -> Any: ...

    # Cast to physical representation of the logical dtype.
    def to_physical(self, ) -> Expr: ...

    # Return the `k` largest elements.
    def top_k(self, k: int | IntoExprColumn=5) -> Expr: ...

    # Return the elements corresponding to the `k` largest elements of the `by` column(s).
    def top_k_by(self, by: IntoExpr | Iterable[IntoExpr], k: int | IntoExprColumn=5, reverse: bool | Sequence[bool]=False) -> Expr: ...

    # Method equivalent of float division operator `expr / other`.
    def truediv(self, other: Any) -> Expr: ...

    # Get unique values of this expression.
    def unique(self, maintain_order: bool=False) -> Expr: ...

    # Return a count of the unique values in the order of appearance.
    def unique_counts(self, ) -> Expr: ...

    # Calculate the upper bound.
    def upper_bound(self, ) -> Expr: ...

    # Count the occurrence of unique values.
    def value_counts(self, sort: bool=False, parallel: bool=False, name: str | None=None, normalize: bool=False) -> Expr: ...

    def var(self, ddof=1) -> Any: ...

    # Create a new branch in the chain.
    def when(self, condition) -> Any: ...

    # Filter a single column.
    def where(self, predicate: Expr) -> Expr: ...

    # Method equivalent of bitwise exclusive-or operator `expr ^ other`.
    def xor(self, other: Any) -> Expr: ...


# Enhanced decorator for aggregation functions that sets appropriate properties
def agg_function(func=None, customize_repr=True) -> Expr: ...

# Creates a Column expression.
def col(name: str) -> Column: ...

# Alias for col(). Creates a Column expression.
def column(name: str) -> Column: ...

# Compute the correlation between two columns.
def corr(a: str | Expr, b: str | Expr, method: str='pearson', ddof: int=None, propagate_nans: bool=False) -> Expr: ...

def count(*names) -> Expr: ...

# Compute the covariance between two columns.
def cov(a: str | Expr, b: str | Expr, ddof: int=1) -> Expr: ...

# Return the cumulative count of the non-null values in the column.
def cum_count(expr, reverse: bool=False) -> Expr: ...

def explode(*names) -> Expr: ...

def first(*names) -> Expr: ...

def implode(*names) -> Expr: ...

def last(*names) -> Expr: ...

def len() -> Expr: ...

# Creates a Literal expression.
def lit(value: Any) -> Expr: ...

def max(*names) -> Expr: ...

def mean(*names) -> Expr: ...

def min(*names) -> Expr: ...

def std(column, ddof) -> Expr: ...

def sum(*names) -> Expr: ...

def var(column, ddof) -> Expr: ...

# Start a when-then-otherwise expression.
def when(condition) -> Expr: ...
