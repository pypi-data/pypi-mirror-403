from collections.abc import Sequence
from typing import Any, Literal, TypeVar, overload

import jax.lax
from jax.numpy import _Axis
from jaxtyping import Array, ArrayLike, DTypeLike, Shaped

from algebraic.array.core import AlgebraicArray
from algebraic.spec import Semiring

_K = TypeVar("_K", bound=Semiring)

# Explicit array creation functions
def array(data: Shaped[ArrayLike | AlgebraicArray[_K], ...], dtype: _K) -> Shaped[AlgebraicArray[_K], ...]: ...
def asarray(data: Shaped[ArrayLike | AlgebraicArray[_K], ...], dtype: _K) -> Shaped[AlgebraicArray[_K], ...]: ...
@overload
def zeros(shape: int, dtype: _K) -> Shaped[AlgebraicArray[_K], " {shape}"]: ...
@overload
def zeros(shape: tuple[int, ...], dtype: _K) -> Shaped[AlgebraicArray[_K], " {*shape}"]: ...
@overload
def ones(shape: int, dtype: _K) -> Shaped[AlgebraicArray[_K], " {shape}"]: ...
@overload
def ones(shape: tuple[int, ...], dtype: _K) -> Shaped[AlgebraicArray[_K], " {*shape}"]: ...
def eye(N: int, M: int | None = None, k: int | ArrayLike = 0, *, dtype: _K) -> AlgebraicArray[_K]: ...  # noqa: N803

# Binary arithmetic operations
def add(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def subtract(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def multiply(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...

# Reduction operations
def sum(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: _Axis = None,
    dtype: None | DTypeLike = None,
    keepdims: bool = False,
    initial: ArrayLike | None = None,
    where: ArrayLike | None = None,
) -> AlgebraicArray[_K]: ...
def prod(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: _Axis = None,
    dtype: None | DTypeLike = None,
    keepdims: bool = False,
    initial: ArrayLike | None = None,
    where: ArrayLike | None = None,
) -> AlgebraicArray[_K]: ...
def nansum(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: _Axis = None,
    dtype: None | DTypeLike = None,
    keepdims: bool = False,
) -> AlgebraicArray[_K]: ...
def nanprod(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: _Axis = None,
    dtype: None | DTypeLike = None,
    keepdims: bool = False,
) -> AlgebraicArray[_K]: ...
def all(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: _Axis = None,
    keepdims: bool = False,
    where: ArrayLike | None = None,
) -> AlgebraicArray[_K]: ...
def any(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: _Axis = None,
    keepdims: bool = False,
    where: ArrayLike | None = None,
) -> AlgebraicArray[_K]: ...

# Cumulative operations
def cumsum(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    dtype: None | DTypeLike = None,
) -> AlgebraicArray[_K]: ...
def cumprod(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    dtype: None | DTypeLike = None,
) -> AlgebraicArray[_K]: ...
def nancumsum(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    dtype: None | DTypeLike = None,
) -> AlgebraicArray[_K]: ...
def nancumprod(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    dtype: None | DTypeLike = None,
) -> AlgebraicArray[_K]: ...
def cumulative_sum(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    dtype: None | DTypeLike = None,
) -> AlgebraicArray[_K]: ...
def cumulative_prod(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    dtype: None | DTypeLike = None,
) -> AlgebraicArray[_K]: ...

# Matrix/tensor operations
def matmul(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def dot(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def vdot(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def inner(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def outer(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def kron(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def tensordot(
    a: AlgebraicArray[_K] | ArrayLike,
    b: AlgebraicArray[_K] | ArrayLike,
    axes: int | Sequence[int] | tuple[Sequence[int], Sequence[int]] = 2,
) -> AlgebraicArray[_K]: ...
def einsum(
    subscripts: str,
    *operands: AlgebraicArray[_K] | ArrayLike,
    optimize: str | bool = "optimal",
    precision: jax.lax.PrecisionLike = None,
    _use_xeinsum: bool = False,
) -> AlgebraicArray[_K]: ...
def einsum_path(
    subscripts: str, *operands: AlgebraicArray[_K] | ArrayLike, optimize: str = "optimal"
) -> tuple[Sequence[Any], str]: ...
def cross(
    a: AlgebraicArray[_K] | ArrayLike,
    b: AlgebraicArray[_K] | ArrayLike,
    axisa: int = -1,
    axisb: int = -1,
    axisc: int = -1,
    axis: int | None = None,
) -> AlgebraicArray[_K]: ...
def matrix_transpose(x: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def matvec(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def vecdot(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike, axis: int = -1) -> AlgebraicArray[_K]: ...
def vecmat(a: AlgebraicArray[_K] | ArrayLike, b: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...

# Shape manipulation
def reshape(
    a: AlgebraicArray[_K] | ArrayLike, shape: int | tuple[int, ...] | None, order: str = "C"
) -> AlgebraicArray[_K]: ...
def transpose(a: AlgebraicArray[_K] | ArrayLike, axes: tuple[int, ...] | None = None) -> AlgebraicArray[_K]: ...
def ravel(a: AlgebraicArray[_K] | ArrayLike, order: str = "C") -> AlgebraicArray[_K]: ...
def squeeze(a: AlgebraicArray[_K] | ArrayLike, axis: _Axis = None) -> AlgebraicArray[_K]: ...
def expand_dims(a: AlgebraicArray[_K] | ArrayLike, axis: int | tuple[int, ...]) -> AlgebraicArray[_K]: ...
def swapaxes(a: AlgebraicArray[_K] | ArrayLike, axis1: int, axis2: int) -> AlgebraicArray[_K]: ...
def moveaxis(
    a: AlgebraicArray[_K] | ArrayLike, source: int | tuple[int, ...], destination: int | tuple[int, ...]
) -> AlgebraicArray[_K]: ...
def rollaxis(a: AlgebraicArray[_K] | ArrayLike, axis: int, start: int = 0) -> AlgebraicArray[_K]: ...
def permute_dims(a: AlgebraicArray[_K] | ArrayLike, axes: tuple[int, ...]) -> AlgebraicArray[_K]: ...
def atleast_1d(*arys: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K] | Sequence[AlgebraicArray[_K]]: ...
def atleast_2d(*arys: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K] | Sequence[AlgebraicArray[_K]]: ...
def atleast_3d(*arys: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K] | Sequence[AlgebraicArray[_K]]: ...
def broadcast_arrays(*args: AlgebraicArray[_K] | ArrayLike) -> Sequence[AlgebraicArray[_K]]: ...
def broadcast_to(array: AlgebraicArray[_K] | ArrayLike, shape: tuple[int, ...]) -> AlgebraicArray[_K]: ...
def broadcast_shapes(*shapes: tuple[int, ...]) -> tuple[int, ...]: ...

# Array joining/splitting
def concatenate(arrays: Sequence[AlgebraicArray[_K]], axis: int | None = 0) -> AlgebraicArray[_K]: ...
def concat(arrays: Sequence[AlgebraicArray[_K]], axis: int | None = 0) -> AlgebraicArray[_K]: ...
def stack(arrays: Sequence[AlgebraicArray[_K]], axis: int = 0) -> AlgebraicArray[_K]: ...
def vstack(tup: Sequence[AlgebraicArray[_K]]) -> AlgebraicArray[_K]: ...
def hstack(tup: Sequence[AlgebraicArray[_K]]) -> AlgebraicArray[_K]: ...
def dstack(tup: Sequence[AlgebraicArray[_K]]) -> AlgebraicArray[_K]: ...
def column_stack(tup: Sequence[AlgebraicArray[_K]]) -> AlgebraicArray[_K]: ...
def split(
    ary: AlgebraicArray[_K] | ArrayLike, indices_or_sections: int | Sequence[int], axis: int = 0
) -> Sequence[AlgebraicArray[_K]]: ...
def array_split(
    ary: AlgebraicArray[_K] | ArrayLike, indices_or_sections: int | Sequence[int], axis: int = 0
) -> Sequence[AlgebraicArray[_K]]: ...
def dsplit(ary: AlgebraicArray[_K] | ArrayLike, indices_or_sections: int | Sequence[int]) -> Sequence[AlgebraicArray[_K]]: ...
def hsplit(ary: AlgebraicArray[_K] | ArrayLike, indices_or_sections: int | Sequence[int]) -> Sequence[AlgebraicArray[_K]]: ...
def vsplit(ary: AlgebraicArray[_K] | ArrayLike, indices_or_sections: int | Sequence[int]) -> Sequence[AlgebraicArray[_K]]: ...
def unstack(x: AlgebraicArray[_K] | ArrayLike, axis: int = 0) -> Sequence[AlgebraicArray[_K]]: ...
def block(arrays: Sequence[Any]) -> AlgebraicArray[_K]: ...

# Tiling/repeating
def tile(A: AlgebraicArray[_K] | ArrayLike, reps: int | tuple[int, ...]) -> AlgebraicArray[_K]: ...  # noqa: N803
def repeat(
    a: AlgebraicArray[_K] | ArrayLike,
    repeats: int | ArrayLike,
    axis: int | None = None,
    total_repeat_length: int | None = None,
) -> AlgebraicArray[_K]: ...

# Flipping/rolling
def flip(m: AlgebraicArray[_K] | ArrayLike, axis: _Axis = None) -> AlgebraicArray[_K]: ...
def fliplr(m: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def flipud(m: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def roll(a: AlgebraicArray[_K] | ArrayLike, shift: int | tuple[int, ...], axis: _Axis = None) -> AlgebraicArray[_K]: ...

# Diagonal operations
def diag(v: AlgebraicArray[_K] | ArrayLike, k: int = 0) -> AlgebraicArray[_K]: ...
def diagonal(a: AlgebraicArray[_K] | ArrayLike, offset: int = 0, axis1: int = 0, axis2: int = 1) -> AlgebraicArray[_K]: ...
def diagflat(v: AlgebraicArray[_K] | ArrayLike, k: int = 0) -> AlgebraicArray[_K]: ...
def diag_indices(n: int, ndim: int = 2) -> tuple[Array, ...]: ...
def diag_indices_from(arr: AlgebraicArray[_K] | ArrayLike) -> tuple[Array, ...]: ...
def fill_diagonal(a: AlgebraicArray[_K] | ArrayLike, val: ArrayLike, wrap: bool = False) -> AlgebraicArray[_K]: ...

# Indexing/selection
def take(
    a: AlgebraicArray[_K] | ArrayLike, indices: ArrayLike, axis: int | None = None, mode: str | None = None
) -> AlgebraicArray[_K]: ...
def take_along_axis(arr: AlgebraicArray[_K] | ArrayLike, indices: ArrayLike, axis: int | None) -> AlgebraicArray[_K]: ...
def choose(a: ArrayLike, choices: Sequence[AlgebraicArray[_K]], mode: str = "raise") -> AlgebraicArray[_K]: ...
def compress(condition: ArrayLike, a: AlgebraicArray[_K] | ArrayLike, axis: int | None = None) -> AlgebraicArray[_K]: ...
def extract(condition: ArrayLike, arr: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def where(
    condition: ArrayLike, x: AlgebraicArray[_K] | ArrayLike | None = None, y: AlgebraicArray[_K] | ArrayLike | None = None
) -> AlgebraicArray[_K]: ...
def select(
    condlist: Sequence[ArrayLike], choicelist: Sequence[AlgebraicArray[_K]], default: ArrayLike | AlgebraicArray[_K] = 0
) -> AlgebraicArray[_K]: ...

# def piecewise[_K: Semiring, **_P](
#     x: AlgebraicArray[_K] | ArrayLike, condlist: Sequence[ArrayLike], funclist: Sequence[Any], *args: _P.args, **kw: _P.kwargs
# ) -> AlgebraicArray[_K]: ...

# Array modification
def put(a: AlgebraicArray[_K] | ArrayLike, ind: ArrayLike, v: ArrayLike, mode: str = "raise") -> AlgebraicArray[_K]: ...
def put_along_axis(
    arr: AlgebraicArray[_K] | ArrayLike, indices: ArrayLike, values: ArrayLike, axis: int | None
) -> AlgebraicArray[_K]: ...
def place(arr: AlgebraicArray[_K] | ArrayLike, mask: ArrayLike, vals: ArrayLike) -> AlgebraicArray[_K]: ...
def append(
    arr: AlgebraicArray[_K] | ArrayLike, values: AlgebraicArray[_K] | ArrayLike, axis: int | None = None
) -> AlgebraicArray[_K]: ...
def insert(
    arr: AlgebraicArray[_K] | ArrayLike, obj: int | ArrayLike, values: AlgebraicArray[_K] | ArrayLike, axis: int | None = None
) -> AlgebraicArray[_K]: ...
def delete(
    arr: AlgebraicArray[_K] | ArrayLike, obj: int | slice | ArrayLike, axis: int | None = None
) -> AlgebraicArray[_K]: ...
def resize(a: AlgebraicArray[_K] | ArrayLike, new_shape: int | tuple[int, ...]) -> AlgebraicArray[_K]: ...
def copy(a: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def pad(
    array: AlgebraicArray[_K] | ArrayLike,
    pad_width: int | tuple[int, int] | Sequence[tuple[int, int]],
    mode: str = "constant",
    **kwargs: Any,  # noqa: ANN401
) -> AlgebraicArray[_K]: ...

# Sorting/searching
def argsort(
    a: AlgebraicArray[_K] | ArrayLike, axis: int | None = -1, kind: str | None = None, order: None = None
) -> Array: ...
def partition(a: AlgebraicArray[_K] | ArrayLike, kth: int | ArrayLike, axis: int = -1) -> AlgebraicArray[_K]: ...
def argwhere(a: AlgebraicArray[_K] | ArrayLike) -> Array: ...

# Comparison
def equal(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def not_equal(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def array_equal(a1: AlgebraicArray[_K] | ArrayLike, a2: AlgebraicArray[_K] | ArrayLike, equal_nan: bool = False) -> bool: ...
def array_equiv(a1: AlgebraicArray[_K] | ArrayLike, a2: AlgebraicArray[_K] | ArrayLike) -> bool: ...
def allclose(
    a: AlgebraicArray[_K] | ArrayLike,
    b: AlgebraicArray[_K] | ArrayLike,
    rtol: float = 1e-5,
    atol: float = 1e-8,
    equal_nan: bool = False,
) -> bool: ...
def isclose(
    a: AlgebraicArray[_K] | ArrayLike,
    b: AlgebraicArray[_K] | ArrayLike,
    rtol: float = 1e-5,
    atol: float = 1e-8,
    equal_nan: bool = False,
) -> AlgebraicArray[_K]: ...

# Special operations
def nan_to_num(
    x: AlgebraicArray[_K] | ArrayLike,
    copy: bool = True,
    nan: float = 0.0,
    posinf: float | None = None,
    neginf: float | None = None,
) -> AlgebraicArray[_K]: ...
def copysign(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...
def right_shift(x: AlgebraicArray[_K] | ArrayLike, y: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...

# Multi-index operations
def ravel_multi_index(
    multi_index: tuple[ArrayLike, ...], dims: tuple[int, ...], mode: str = "raise", order: str = "C"
) -> Array: ...
def unravel_index(indices: ArrayLike, shape: tuple[int, ...], order: str = "C") -> tuple[Array, ...]: ...

# Unique operations
def unique(
    ar: AlgebraicArray[_K] | ArrayLike,
    return_index: bool = False,
    return_inverse: bool = False,
    return_counts: bool = False,
    axis: int | None = None,
    size: int | None = None,
    fill_value: ArrayLike | None = None,
) -> AlgebraicArray[_K] | tuple[AlgebraicArray[_K], ...]: ...
def unique_all(x: AlgebraicArray[_K] | ArrayLike) -> tuple[AlgebraicArray[_K], Array, Array, Array]: ...
def unique_counts(x: AlgebraicArray[_K] | ArrayLike) -> tuple[AlgebraicArray[_K], Array]: ...
def unique_inverse(x: AlgebraicArray[_K] | ArrayLike) -> tuple[AlgebraicArray[_K], Array]: ...
def unique_values(x: AlgebraicArray[_K] | ArrayLike) -> AlgebraicArray[_K]: ...

# Bit operations
def packbits(
    a: AlgebraicArray[_K] | ArrayLike, axis: int | None = None, bitorder: Literal["big", "little"] = "big"
) -> AlgebraicArray[_K]: ...
def unpackbits(
    a: AlgebraicArray[_K] | ArrayLike,
    axis: int | None = None,
    count: int | None = None,
    bitorder: Literal["big", "little"] = "big",
) -> AlgebraicArray[_K]: ...

# Apply functions
def apply_along_axis(
    func1d: Any,  # noqa: ANN401
    axis: int,
    arr: AlgebraicArray[_K] | ArrayLike,
    *args: Any,  # noqa: ANN401
    **kwargs: Any,  # noqa: ANN401
) -> AlgebraicArray[_K]: ...
def apply_over_axes(func: Any, a: AlgebraicArray[_K] | ArrayLike, axes: int | tuple[int, ...]) -> AlgebraicArray[_K]: ...  # noqa: ANN401

# String representation
def array_repr(
    arr: AlgebraicArray[_K] | ArrayLike,
    max_line_width: int | None = None,
    precision: int | None = None,
    suppress_small: bool | None = None,
) -> str: ...
def array_str(
    a: AlgebraicArray[_K] | ArrayLike,
    max_line_width: int | None = None,
    precision: int | None = None,
    suppress_small: bool | None = None,
) -> str: ...
