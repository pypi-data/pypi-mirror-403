"""Partial encryption functionality for envdrift.

This module implements a simple build pattern for partial encryption:
- Source files: .env.{env}.clear + .env.{env}.secret
- Generated file: .env.{env} (combined with warning header)
"""

from __future__ import annotations

from pathlib import Path

from envdrift.config import PartialEncryptionEnvironmentConfig
from envdrift.integrations.dotenvx import DotenvxError, DotenvxWrapper

WARNING_HEADER = """#/---------------------------------------------------/
#/ WARNING: AUTO-GENERATED FILE                      /
#/ DO NOT EDIT THIS FILE DIRECTLY                    /
#/                                                    /
#/ This file is generated by: envdrift push          /
#/                                                    /
#/ To make changes:                                  /
#/   1. Edit: {clear_file:<36}/
#/   2. Edit: {secret_file:<36}/
#/   3. Run:  envdrift pull-partial (to decrypt)     /
#/   4. Run:  envdrift push (to regenerate this)     /
#/---------------------------------------------------/
"""


class PartialEncryptionError(Exception):
    """Partial encryption operation failed."""

    @classmethod
    def encrypt_failed(cls, path: Path, cause: Exception) -> PartialEncryptionError:
        """Create error for encryption failure."""
        return cls(f"Failed to encrypt {path}: {cause}")

    @classmethod
    def decrypt_failed(cls, path: Path, cause: Exception) -> PartialEncryptionError:
        """Create error for decryption failure."""
        return cls(f"Failed to decrypt {path}: {cause}")

    @classmethod
    def file_not_found(cls, path: Path) -> PartialEncryptionError:
        """Create error for missing file."""
        return cls(f"Secret file not found: {path}")


def is_file_encrypted(file_path: Path) -> bool:
    """
    Check if a file contains dotenvx encrypted content.

    Args:
        file_path: Path to check

    Returns:
        True if file contains encrypted: prefix or DOTENV_VAULT markers
    """
    if not file_path.exists():
        return False

    content = file_path.read_text()
    return "encrypted:" in content or "DOTENV_VAULT" in content


def combine_files(env_config: PartialEncryptionEnvironmentConfig) -> dict[str, int]:
    """
    Combine clear and encrypted secret files into a single combined file.

    Process:
        1. Read .env.{env}.clear (cleartext vars)
        2. Read .env.{env}.secret (encrypted vars)
        3. Combine with warning header → .env.{env}

    Args:
        env_config: Environment configuration

    Returns:
        Dict with counts: {"clear_lines": X, "secret_vars": Y}

    Raises:
        PartialEncryptionError: If operation fails
    """
    clear_file = Path(env_config.clear_file)
    secret_file = Path(env_config.secret_file)
    combined_file = Path(env_config.combined_file)

    # Read files
    clear_lines = []
    if clear_file.exists():
        clear_lines = clear_file.read_text().splitlines()

    secret_lines = []
    if secret_file.exists():
        secret_lines = secret_file.read_text().splitlines()

    # Build combined content with warning header
    warning = WARNING_HEADER.format(
        clear_file=env_config.clear_file,
        secret_file=env_config.secret_file,
    )

    combined_lines = warning.splitlines()
    combined_lines.append("")

    # Add clear section
    if clear_lines:
        combined_lines.append(f"# From {env_config.clear_file}")
        combined_lines.extend(clear_lines)
        combined_lines.append("")

    # Add encrypted secret section
    if secret_lines:
        # Skip dotenvx header comments from secret file to avoid clutter
        secret_content = [line for line in secret_lines if not line.strip().startswith("#/---")]
        combined_lines.append(f"# From {env_config.secret_file} (encrypted)")
        combined_lines.extend(secret_content)

    # Write combined file
    combined_file.write_text("\n".join(combined_lines) + "\n")

    # Count variables in secret file
    secret_var_count = sum(
        1 for line in secret_lines if "=" in line and not line.strip().startswith("#")
    )

    return {
        "clear_lines": len(clear_lines),
        "secret_vars": secret_var_count,
    }


def encrypt_secret_file(env_config: PartialEncryptionEnvironmentConfig) -> None:
    """
    Encrypt the secret file in-place using dotenvx.

    Args:
        env_config: Environment configuration

    Raises:
        PartialEncryptionError: If encryption fails
    """
    secret_file = Path(env_config.secret_file)

    if not secret_file.exists():
        return

    # Check if already encrypted
    if is_file_encrypted(secret_file):
        return

    # Encrypt using dotenvx
    dotenvx = DotenvxWrapper()
    try:
        dotenvx.encrypt(secret_file)
    except DotenvxError as e:
        raise PartialEncryptionError.encrypt_failed(secret_file, e) from e


def decrypt_secret_file(env_config: PartialEncryptionEnvironmentConfig) -> None:
    """
    Decrypt the secret file in-place using dotenvx.

    Args:
        env_config: Environment configuration

    Raises:
        PartialEncryptionError: If decryption fails
    """
    secret_file = Path(env_config.secret_file)

    if not secret_file.exists():
        raise PartialEncryptionError.file_not_found(secret_file)

    # Check if already decrypted
    if not is_file_encrypted(secret_file):
        return  # Already decrypted

    # Decrypt using dotenvx
    dotenvx = DotenvxWrapper()
    try:
        dotenvx.decrypt(secret_file)
    except DotenvxError as e:
        raise PartialEncryptionError.decrypt_failed(secret_file, e) from e


def push_partial_encryption(env_config: PartialEncryptionEnvironmentConfig) -> dict[str, int]:
    """
    Push operation: Encrypt secret file + combine with clear file.

    Steps:
    1. Encrypt .env.{env}.secret using dotenvx (in-place)
    2. Combine .env.{env}.clear + encrypted .secret → .env.{env}

    Args:
        env_config: Environment configuration

    Returns:
        Dict with stats: {"clear_lines": X, "secret_vars": Y}

    Raises:
        PartialEncryptionError: If push operation fails
    """
    # Step 1: Encrypt secret file
    encrypt_secret_file(env_config)

    # Step 2: Combine files
    stats = combine_files(env_config)

    return stats


def pull_partial_encryption(env_config: PartialEncryptionEnvironmentConfig) -> bool:
    """
    Pull operation: Decrypt secret file for editing.

    Steps:
    1. Decrypt .env.{env}.secret in-place

    Args:
        env_config: Environment configuration

    Returns:
        True if file was decrypted, False if already decrypted

    Raises:
        PartialEncryptionError: If pull operation fails
    """
    secret_file = Path(env_config.secret_file)

    if not secret_file.exists():
        raise PartialEncryptionError.file_not_found(secret_file)

    was_encrypted = is_file_encrypted(secret_file)

    # Decrypt secret file
    decrypt_secret_file(env_config)

    return was_encrypted
