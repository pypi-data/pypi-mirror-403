"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.descriptor_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.internal.extension_dict
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class ReaderMethodOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _State:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ReaderMethodOptions._State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DEFAULT: ReaderMethodOptions._State.ValueType  # 0
        UNARY: ReaderMethodOptions._State.ValueType  # 1
        STREAMING: ReaderMethodOptions._State.ValueType  # 2

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """Option specifying how to pass the state to this method. By
        default, unary methods get passed a unary state, but a method may
        override that default (by setting this option to 'STREAMING') to
        get streaming state. Likewise, by default, streaming methods get
        streaming state, but a method may override that default (by
        setting this option to 'UNARY') to get unary state.
        """

    DEFAULT: ReaderMethodOptions.State.ValueType  # 0
    UNARY: ReaderMethodOptions.State.ValueType  # 1
    STREAMING: ReaderMethodOptions.State.ValueType  # 2

    STATE_FIELD_NUMBER: builtins.int
    state: global___ReaderMethodOptions.State.ValueType
    def __init__(
        self,
        *,
        state: global___ReaderMethodOptions.State.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["state", b"state"]) -> None: ...

global___ReaderMethodOptions = ReaderMethodOptions

@typing.final
class WriterMethodOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONSTRUCTOR_FIELD_NUMBER: builtins.int
    @property
    def constructor(self) -> global___ConstructorMethodOptions:
        """If set, indicates this writer can be used to construct a new actor,
        and an actor can not be _implicitly_ constructed but instead
        must be constructed via a constructor.
        """

    def __init__(
        self,
        *,
        constructor: global___ConstructorMethodOptions | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_constructor", b"_constructor", "constructor", b"constructor"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_constructor", b"_constructor", "constructor", b"constructor"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_constructor", b"_constructor"]) -> typing.Literal["constructor"] | None: ...

global___WriterMethodOptions = WriterMethodOptions

@typing.final
class TransactionMethodOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONSTRUCTOR_FIELD_NUMBER: builtins.int
    @property
    def constructor(self) -> global___ConstructorMethodOptions:
        """If set, indicates this transaction can be used to construct a new actor,
        and an actor can not be _implicitly_ constructed but instead
        must be constructed via a constructor.
        """

    def __init__(
        self,
        *,
        constructor: global___ConstructorMethodOptions | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_constructor", b"_constructor", "constructor", b"constructor"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_constructor", b"_constructor", "constructor", b"constructor"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_constructor", b"_constructor"]) -> typing.Literal["constructor"] | None: ...

global___TransactionMethodOptions = TransactionMethodOptions

@typing.final
class WorkflowMethodOptions(google.protobuf.message.Message):
    """Nothing here yet, but is a placeholder for describing things."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___WorkflowMethodOptions = WorkflowMethodOptions

@typing.final
class ConstructorMethodOptions(google.protobuf.message.Message):
    """Nothing here yet, but is a placeholder for describing things like
    "recallable" constructors, etc.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___ConstructorMethodOptions = ConstructorMethodOptions

@typing.final
class MethodOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    READER_FIELD_NUMBER: builtins.int
    WRITER_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    WORKFLOW_FIELD_NUMBER: builtins.int
    ERRORS_FIELD_NUMBER: builtins.int
    @property
    def reader(self) -> global___ReaderMethodOptions: ...
    @property
    def writer(self) -> global___WriterMethodOptions: ...
    @property
    def transaction(self) -> global___TransactionMethodOptions: ...
    @property
    def workflow(self) -> global___WorkflowMethodOptions:
        """TODO: SagaMethodOptions saga = 5;"""

    @property
    def errors(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Possible error message types that may be raised.

        Name resolution is done in accordance with proto3 definitions,
        see comment in ServiceOptions for more details.
        """

    def __init__(
        self,
        *,
        reader: global___ReaderMethodOptions | None = ...,
        writer: global___WriterMethodOptions | None = ...,
        transaction: global___TransactionMethodOptions | None = ...,
        workflow: global___WorkflowMethodOptions | None = ...,
        errors: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["kind", b"kind", "reader", b"reader", "transaction", b"transaction", "workflow", b"workflow", "writer", b"writer"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["errors", b"errors", "kind", b"kind", "reader", b"reader", "transaction", b"transaction", "workflow", b"workflow", "writer", b"writer"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["kind", b"kind"]) -> typing.Literal["reader", "writer", "transaction", "workflow"] | None: ...

global___MethodOptions = MethodOptions

@typing.final
class ServiceOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATE_FIELD_NUMBER: builtins.int
    DEFAULT_CONSTRUCTIBLE_FIELD_NUMBER: builtins.int
    state: builtins.str
    """The name of the Reboot state `message` that this service supplies methods
    for. May be omitted if the system's default naming convention is
    acceptable. If supplied, the name is looked up using protobuf's normal
    rules: relative names are resolved in the same package, while absolute
    names may refer to any package.
    """
    default_constructible: builtins.bool
    """Whether or not this service can be default constructed via just
    calling a writer even if some methods are specified as constructors.
    """
    def __init__(
        self,
        *,
        state: builtins.str = ...,
        default_constructible: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["default_constructible", b"default_constructible", "state", b"state"]) -> None: ...

global___ServiceOptions = ServiceOptions

@typing.final
class StateOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IMPLEMENTS_FIELD_NUMBER: builtins.int
    @property
    def implements(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A list of names of Reboot method definition `service`s that provide this
        state `message` with methods. May be omitted if the system's default naming
        convention is acceptable. Each named service must, in turn, have their
        `state` option set to point at this state.
        """

    def __init__(
        self,
        *,
        implements: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["implements", b"implements"]) -> None: ...

global___StateOptions = StateOptions

@typing.final
class FileOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ZOD_FIELD_NUMBER: builtins.int
    PYDANTIC_FIELD_NUMBER: builtins.int
    zod: builtins.str
    """Path to TypeScript schema that we want to be able to import in
    our generated code.
    """
    pydantic: builtins.str
    """Path to Python schema that we want to be able to import in
    our generated code.
    """
    def __init__(
        self,
        *,
        zod: builtins.str | None = ...,
        pydantic: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_pydantic", b"_pydantic", "_zod", b"_zod", "pydantic", b"pydantic", "zod", b"zod"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_pydantic", b"_pydantic", "_zod", b"_zod", "pydantic", b"pydantic", "zod", b"zod"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_pydantic", b"_pydantic"]) -> typing.Literal["pydantic"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_zod", b"_zod"]) -> typing.Literal["zod"] | None: ...

global___FileOptions = FileOptions

@typing.final
class FieldOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PYDANTIC_TYPE_FIELD_NUMBER: builtins.int
    pydantic_type: builtins.str
    """The fully qualified Pydantic type for this field if the input schema
    is from Pydantic.
    """
    def __init__(
        self,
        *,
        pydantic_type: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["pydantic_type", b"pydantic_type"]) -> None: ...

global___FieldOptions = FieldOptions

METHOD_FIELD_NUMBER: builtins.int
SERVICE_FIELD_NUMBER: builtins.int
STATE_FIELD_NUMBER: builtins.int
FILE_FIELD_NUMBER: builtins.int
FIELD_FIELD_NUMBER: builtins.int
method: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MethodOptions, global___MethodOptions]
"""TODO: once these options are stable, register field numbers for them in the
      official protobuf global extension registry:
      https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
      For now we use the 50000-99999 range for "in-house" applications.
"""
service: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.ServiceOptions, global___ServiceOptions]
"""TODO: once these options are stable, register field numbers for them in the
      official protobuf global extension registry:
      https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
      For now we use the 50000-99999 range for "in-house" applications.
"""
state: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, global___StateOptions]
"""TODO: once these options are stable, register field numbers for them in the
      official protobuf global extension registry:
      https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
      For now we use the 50000-99999 range for "in-house" applications.
"""
file: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.FileOptions, global___FileOptions]
"""TODO: once these options are stable, register field numbers for them in the
      official protobuf global extension registry:
      https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
      For now we use the 50000-99999 range for "in-house" applications.
"""
field: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.FieldOptions, global___FieldOptions]
"""TODO: once these options are stable, register field numbers for them in the
      official protobuf global extension registry:
      https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
      For now we use the 50000-99999 range for "in-house" applications.
"""
