"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
To build this proto with bazel, the proto and bazel rule must be in the same
package, which means that the proto file must have a package declaration
matching the Bazel workspace's folder structure.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import rbt.v1alpha1.kubernetes_helpers_pb2
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class ApplicationConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Status(google.protobuf.message.Message):
        """Message detailing the current state of the `ApplicationConfig`."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class Failed(google.protobuf.message.Message):
            """Message detailing the "failed" state."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            def __init__(
                self,
            ) -> None: ...

        @typing.final
        class Deploying(google.protobuf.message.Message):
            """Message detailing the "deploying" state."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            def __init__(
                self,
            ) -> None: ...

        @typing.final
        class Deployed(google.protobuf.message.Message):
            """Message detailing the "deployed" state."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            def __init__(
                self,
            ) -> None: ...

        FAILED_FIELD_NUMBER: builtins.int
        DEPLOYING_FIELD_NUMBER: builtins.int
        DEPLOYED_FIELD_NUMBER: builtins.int
        REASON_FIELD_NUMBER: builtins.int
        DEPLOYMENTS_FIELD_NUMBER: builtins.int
        reason: builtins.str
        """Status message providing additional information."""
        @property
        def failed(self) -> global___ApplicationConfig.Status.Failed:
            """If the controller can not transition the `ApplicationConfig` to the
            state `deployed`, it will transition it to the state `failed`.
            """

        @property
        def deploying(self) -> global___ApplicationConfig.Status.Deploying:
            """When a `ApplicationConfig` is created or updated, the controller will
            attempt to create corresponding Kubernetes `Deployment`(s). Until this
            has either succeeded or failed the state of the `ApplicationConfig` is
            `deploying`.
            """

        @property
        def deployed(self) -> global___ApplicationConfig.Status.Deployed:
            """When the corresponding Kubernetes `Deployment`(s) has been created, the
            `ApplicationConfig` is `deployed`.
            """

        @property
        def deployments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[rbt.v1alpha1.kubernetes_helpers_pb2.V1ObjectMeta]:
            """Metadata object of the corresponding Kubernetes `Deployment` object, if
            any. The `Deployment` objects pointed to are the ones corresponding to
            the last successfully "deployed" state. i.e., if we transition back to
            "deploying" (and optionally to "failed") due to a `ApplicationConfig`
            update we are still pointing to the last successfully created or updated
            `Deployment`s.
            """

        def __init__(
            self,
            *,
            failed: global___ApplicationConfig.Status.Failed | None = ...,
            deploying: global___ApplicationConfig.Status.Deploying | None = ...,
            deployed: global___ApplicationConfig.Status.Deployed | None = ...,
            reason: builtins.str = ...,
            deployments: collections.abc.Iterable[rbt.v1alpha1.kubernetes_helpers_pb2.V1ObjectMeta] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["deployed", b"deployed", "deploying", b"deploying", "failed", b"failed", "state_oneof", b"state_oneof"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["deployed", b"deployed", "deploying", b"deploying", "deployments", b"deployments", "failed", b"failed", "reason", b"reason", "state_oneof", b"state_oneof"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["state_oneof", b"state_oneof"]) -> typing.Literal["failed", "deploying", "deployed"] | None: ...

    @typing.final
    class Spec(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class State(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            STATE_TYPE_FULL_NAME_FIELD_NUMBER: builtins.int
            SERVICE_FULL_NAMES_FIELD_NUMBER: builtins.int
            state_type_full_name: builtins.str
            """Fully-qualified state type name; e.g. "chat_room.v1.ChatRoom"."""
            @property
            def service_full_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
                """Fully-qualified names of services hosted by this state type; e.g.
                "chat_room.v1.ChatRoomMethods".
                """

            def __init__(
                self,
                *,
                state_type_full_name: builtins.str = ...,
                service_full_names: collections.abc.Iterable[builtins.str] | None = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing.Literal["service_full_names", b"service_full_names", "state_type_full_name", b"state_type_full_name"]) -> None: ...

        FILE_DESCRIPTOR_SET_FIELD_NUMBER: builtins.int
        CONTAINER_IMAGE_NAME_FIELD_NUMBER: builtins.int
        SERVICE_NAMES_FIELD_NUMBER: builtins.int
        STATES_FIELD_NUMBER: builtins.int
        LEGACY_GRPC_SERVICE_FULL_NAMES_FIELD_NUMBER: builtins.int
        REVISION_FIELD_NUMBER: builtins.int
        REVISION_NUMBER_FIELD_NUMBER: builtins.int
        REPLICAS_FIELD_NUMBER: builtins.int
        SERVERS_FIELD_NUMBER: builtins.int
        REBOOT_VERSION_FIELD_NUMBER: builtins.int
        file_descriptor_set: builtins.bytes
        """A serialized `FileDescriptorSet`. Its content is plain bytes, not base64,
        but note that (since this is a `bytes` field) when the
        `ApplicationConfig` is written to Kubernetes, this field (like any other
        `bytes` field) will be base64 encoded then.
        """
        container_image_name: builtins.str
        """Name of the user image being deployed; e.g. registry.k8s.io/myserver:1.4.
        Matches the corresponding ApplicationDeployment.
        """
        revision: builtins.str
        """A unique string representing the revision of this config. When the
        config's contents change, this string MUST also change. This string MAY
        change even when the contents of the config do not.
        """
        revision_number: builtins.int
        """A monotonically increasing number representing the revision of this
        config. Assumed to be provided from outside the Reboot controller, so
        less rigorous than the "revision" string, but more human-readable.

        ATTENTION: this is a uint32, because wider numbers are JSON-serialized as
                   "string" instead of "int", and JSON serialization is how the
                   Kubernetes clients serialize. This isn't a problem in
                   practice, but since other places use a uint64 for this field
                   it's confusing.
        """
        replicas: builtins.int
        """The number of replicas to run for this application. Must be a
        power of 2. This must be set for any Reboot application new
        enough to support horizontal scaling; for backwards compatibility
        however, an unset value will be interpreted as 1.
        """
        servers: builtins.int
        """The number of servers to run for _each replica_ of this
        application. Must be a power of 2. Unset means: use an arbitrary
        default.
        """
        reboot_version: builtins.str
        """The version of Reboot running in this application. This is used
        by the controller to determine what features are supported by the
        application.
        """
        @property
        def service_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """The names of all the Reboot services served by this server.

            TODO(rjh): this field has been superseded by `states` and
              `legacy_grpc_service_full_names`; remove this field once all callers
              provide those fields.
            """

        @property
        def states(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ApplicationConfig.Spec.State]:
            """All of the Reboot state types served by this server."""

        @property
        def legacy_grpc_service_full_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Legacy gRPC services hosted by this server."""

        def __init__(
            self,
            *,
            file_descriptor_set: builtins.bytes = ...,
            container_image_name: builtins.str = ...,
            service_names: collections.abc.Iterable[builtins.str] | None = ...,
            states: collections.abc.Iterable[global___ApplicationConfig.Spec.State] | None = ...,
            legacy_grpc_service_full_names: collections.abc.Iterable[builtins.str] | None = ...,
            revision: builtins.str = ...,
            revision_number: builtins.int = ...,
            replicas: builtins.int | None = ...,
            servers: builtins.int | None = ...,
            reboot_version: builtins.str = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_replicas", b"_replicas", "_servers", b"_servers", "replicas", b"replicas", "servers", b"servers"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_replicas", b"_replicas", "_servers", b"_servers", "container_image_name", b"container_image_name", "file_descriptor_set", b"file_descriptor_set", "legacy_grpc_service_full_names", b"legacy_grpc_service_full_names", "reboot_version", b"reboot_version", "replicas", b"replicas", "revision", b"revision", "revision_number", b"revision_number", "servers", b"servers", "service_names", b"service_names", "states", b"states"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_replicas", b"_replicas"]) -> typing.Literal["replicas"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_servers", b"_servers"]) -> typing.Literal["servers"] | None: ...

    STATUS_FIELD_NUMBER: builtins.int
    SPEC_FIELD_NUMBER: builtins.int
    @property
    def status(self) -> global___ApplicationConfig.Status:
        """Status of the `ApplicationConfig` reported by the reboot controller."""

    @property
    def spec(self) -> global___ApplicationConfig.Spec: ...
    def __init__(
        self,
        *,
        status: global___ApplicationConfig.Status | None = ...,
        spec: global___ApplicationConfig.Spec | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["spec", b"spec", "status", b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["spec", b"spec", "status", b"status"]) -> None: ...

global___ApplicationConfig = ApplicationConfig
