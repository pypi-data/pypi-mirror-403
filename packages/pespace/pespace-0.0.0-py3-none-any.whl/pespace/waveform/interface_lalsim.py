from typing import Any, Callable
import logging

import taichi as ti
import numpy as np

from ..utils.utils import ti_complex
from ..utils.constants import *

try:
    import lal
    import lalsimulation as lalsim
except ImportError:
    logging.error(
        "lalsuite is not installed by default, if waveforms from lalsimulation are needed, "
        "please install lalsuite manually."
    )
    raise


class WaveformLALSimulationInterface:
    """
    Interface class to get waveform strains from lalsimulation.

    The two polarizations are stacked in `waveform_container` to optimize memory access
    when computing detector responses. While this layout may result in low performance when
    two polarizations are accessed independently.

    The frequency-domain waveform generated by lalsimulation has the length of 2^n + 1,
    which benefits performance of ifft. However, in our case, the waveform is mainly used
    to compute the detector response in frequency-domain, not used to get time-domain
    waveform through ifft. Therefore, to reduce samples need to be computed for response,
    we only ratain the concerned range, use minimum_frequency and maximum_frequency to
    truncate the frequency series given by lalsimulation.

    Since lalsimulation does not provide a direct interface to obtain t(f) for each
    waveform approximant, we simply use the phase Post-Newtonian coefficients to derive
    t(f)=dphi/df, and use fISCO=1/(6^(3/2)*pi*M) as the truncation. For frequency above
    fISCO, we set t(f)=0 adopting the convention that the binary merge around t=0. If
    waveform model of IMRPhenomD or IMRPhenomX is used, [tiwave](https://github.com/nnrui/tiwave)
    is more recommended.
    """

    def __init__(
        self,
        domain: str,
        approximant: str,
        sampling_interval: float,  # dt (second) if time domain; df (Hz) if frequency domain
        reference_frequency: float,
        minimum_frequency: float,
        maximum_frequency: float,
        skip_invalid_params: bool = True,
        parameter_conversion: Callable | None = None,
        **waveform_parameters: dict[str, Any],
    ):
        """ """
        self.domain = domain
        self.approximant = lalsim.GetApproximantFromString(approximant)
        if self.domain == "td":
            self.delta_time = sampling_interval
        elif self.domain == "fd":
            self.delta_frequency = sampling_interval
        else:
            raise ValueError("domain for waveform can only be one of td or fd.")
        self.reference_frequency = reference_frequency
        self.minimum_frequency = minimum_frequency
        self.maximum_frequency = maximum_frequency
        self.skip_invalid_params = skip_invalid_params

        if parameter_conversion is None:
            self.parameter_conversion = self._default_parameter_conversion
        else:
            self.parameter_conversion = parameter_conversion

        self.waveform_parameters = lal.CreateDict()
        for key, value in waveform_parameters.items():
            if key == "ModeArray":
                mode_array_lal = lalsim.SimInspiralCreateModeArray()
                for l, m in value:
                    lalsim.SimInspiralModeArrayActivateMode(mode_array_lal, l, m)
                lalsim.SimInspiralWaveformParamsInsertModeArray(
                    self.waveform_parameters, mode_array_lal
                )
            else:
                insert_func = getattr(lalsim, f"SimInspiralWaveformParamsInsert{key}")
                insert_func(self.waveform_parameters, value)

        self.parameters = {
            "mass_1": 0.0,
            "mass_2": 0.0,
            "spin_1x": 0.0,
            "spin_1y": 0.0,
            "spin_1z": 0.0,
            "spin_2x": 0.0,
            "spin_2y": 0.0,
            "spin_2z": 0.0,
            "luminosity_distance": 0.0,
            "inclination": 0.0,
            "reference_phase": 0.0,
            "long_asc_nodes": 0.0,
            "eccentricity": 0.0,
            "mean_per_ano": 0.0,
        }

        if self.domain == "td":
            self.waveform_container = {"data": None, "t0": None}
            self.update_waveform = self._update_waveform_td
        elif self.domain == "fd":
            num_samples = int(self.maximum_frequency // self.delta_frequency)
            num_samples = 1 << (num_samples - 1).bit_length()  # next power of 2
            num_samples += 1  # start frequency at 0
            full_frequency_samples = np.arange(num_samples) * self.delta_frequency
            frequency_mask_array = (
                full_frequency_samples >= self.minimum_frequency
            ) * (full_frequency_samples <= self.maximum_frequency)
            self._frequency_samples = full_frequency_samples[frequency_mask_array]
            self._frequency_mask_array = frequency_mask_array

            self.waveform_container = ti.Struct.field(
                {"plus": ti_complex, "cross": ti_complex, "tf": float},
                shape=self._frequency_samples.shape,
            )
            self.update_waveform = self._update_waveform_fd
        else:
            raise ValueError("domain for waveform can only be one of td or fd.")

    def _default_parameter_conversion(self, input_params: dict[str, float]):
        return input_params

    def _update_waveform_td(self, parameters: dict[str, float]):
        self.parameters.update(self.parameter_conversion(parameters))
        try:
            hp, hc = lalsim.SimInspiralChooseTDWaveform(
                float(self.parameters["mass_1"] * lal.MSUN_SI),
                float(self.parameters["mass_2"] * lal.MSUN_SI),
                float(self.parameters["spin_1x"]),
                float(self.parameters["spin_1y"]),
                float(self.parameters["spin_1z"]),
                float(self.parameters["spin_2x"]),
                float(self.parameters["spin_2y"]),
                float(self.parameters["spin_2z"]),
                float(self.parameters["luminosity_distance"] * 1e6 * lal.PC_SI),
                float(self.parameters["inclination"]),
                float(self.parameters["reference_phase"]),
                float(self.parameters["long_asc_nodes"]),
                float(self.parameters["eccentricity"]),
                float(self.parameters["mean_per_ano"]),
                float(self.delta_time),
                float(self.minimum_frequency),
                float(self.reference_frequency),
                self.waveform_parameters,
                self.approximant,
            )
        except RuntimeError as e:
            if not e.args[0] == "Internal function call failed: Input domain error":
                raise
            else:
                if self.skip_invalid_params:
                    logging.warning(f"Skipping invalid parameters: {self.parameters}")
                else:
                    raise

        self.waveform_container["data"] = np.stack([hp.data.data, hc.data.data], axis=1)
        self.waveform_container["t0"] = float(hp.epoch)

    def _update_waveform_fd(self, parameters: dict[str, float]):
        self.parameters.update(self.parameter_conversion(parameters))
        try:
            hp, hc = lalsim.SimInspiralChooseFDWaveform(
                float(self.parameters["mass_1"] * lal.MSUN_SI),
                float(self.parameters["mass_2"] * lal.MSUN_SI),
                float(self.parameters["spin_1x"]),
                float(self.parameters["spin_1y"]),
                float(self.parameters["spin_1z"]),
                float(self.parameters["spin_2x"]),
                float(self.parameters["spin_2y"]),
                float(self.parameters["spin_2z"]),
                float(self.parameters["luminosity_distance"] * 1e6 * lal.PC_SI),
                float(self.parameters["inclination"]),
                float(self.parameters["reference_phase"]),
                float(self.parameters["long_asc_nodes"]),
                float(self.parameters["eccentricity"]),
                float(self.parameters["mean_per_ano"]),
                float(self.delta_frequency),
                float(self.minimum_frequency),
                float(self.maximum_frequency),
                float(self.reference_frequency),
                self.waveform_parameters,
                self.approximant,
            )
        except RuntimeError as e:
            if not e.args[0] == "Internal function call failed: Input domain error":
                raise
            else:
                if self.skip_invalid_params:
                    logging.warning(f"Skipping invalid parameters: {self.parameters}")
                else:
                    raise

        plus = hp.data.data[self._frequency_mask_array].view(np.float64).reshape(-1, 2)
        cross = hc.data.data[self._frequency_mask_array].view(np.float64).reshape(-1, 2)
        tf = get_PN_d_phase(self.parameters, self._frequency_samples)

        self.waveform_container.from_numpy({"plus": plus, "cross": cross, "tf": tf})


PI_third = PI ** (1 / 3)
PI_two_thirds = PI_third * PI_third
PI_four_thirds = PI * PI_third
PI_five_thirds = PI_four_thirds * PI_third
PI_two = PI * PI
PI_log = np.log(PI)
Mf_ISCO = 1.0 / (6.0 ** (3 / 2) * PI)


def get_PN_d_phase(
    parameters: dict[str, float],
    frequency_samples: "NDArray",
):
    """ """
    M_total = parameters["mass_1"] + parameters["mass_2"]
    M_total_sec = M_total * MTSUN_SI
    Mf_array = frequency_samples * M_total_sec

    eta = parameters["mass_1"] * parameters["mass_2"] / (M_total * M_total)
    eta_pow2 = eta * eta
    eta_pow3 = eta_pow2 * eta

    delta = np.sqrt(1.0 - 4.0 * eta)

    chi_a = (parameters["spin_1z"] - parameters["spin_2z"]) * 0.5
    chi_a_pow2 = chi_a * chi_a
    chi_a_pow3 = chi_a_pow2 * chi_a
    chi_s = (parameters["spin_1z"] + parameters["spin_2z"]) * 0.5
    chi_s_pow2 = chi_s * chi_s
    chi_s_pow3 = chi_s_pow2 * chi_s

    common_factor = -3.0 / 128.0 / eta
    phi_0 = 1.0 / PI_five_thirds * common_factor
    phi_1 = 0.0 / PI_four_thirds * common_factor
    phi_2 = (37.15 / 7.56 + 55.0 / 9.0 * eta) / PI * common_factor
    phi_3 = (
        (
            -16.0 * PI
            + (113.0 / 3.0 * delta * chi_a)
            + (113.0 / 3.0 - 76.0 / 3.0 * eta) * chi_s
        )
        / PI_two_thirds
        * common_factor
    )
    phi_4 = (
        (
            152.93365 / 5.08032
            + 271.45 / 5.04 * eta
            + 308.5 / 7.2 * eta_pow2
            + (-405.0 / 8.0 + 200.0 * eta) * chi_a_pow2
            - 405.0 / 4.0 * delta * chi_a * chi_s
            + (-405.0 / 8.0 + 5.0 / 2.0 * eta) * chi_s_pow2
        )
        / PI_third
        * common_factor
    )
    phi_5l = (
        (386.45 / 7.56 - 65.0 / 9.0 * eta) * PI
        + (-732.985 / 2.268 - 140.0 / 9.0 * eta) * delta * chi_a
        + (-732.985 / 2.268 + 2426.0 / 8.1 * eta + 340.0 / 9.0 * eta_pow2) * chi_s
    ) * common_factor
    phi_6 = (
        (
            (
                11583.231236531 / 4.694215680
                - 640.0 / 3.0 * PI * PI
                - 684.8 / 2.1 * EULER_GAMMA
                + (-15737.765635 / 3.048192 + 225.5 / 1.2 * PI * PI) * eta
                + 76.055 / 1.728 * eta_pow2
                - 127.825 / 1.296 * eta_pow3
                - np.log(2.0) * 1369.6 / 2.1
            )
            + 2270.0 / 3.0 * PI * delta * chi_a
            + (2270.0 / 3.0 - 520.0 * eta) * PI * chi_s
            + (755.15 / 1.44 - 822.5 / 1.8 * eta) * delta * chi_s * chi_a
            + (755.15 / 2.88 - 2632.45 / 2.52 * eta - 480.0 * eta_pow2) * chi_a_pow2
            + (755.15 / 2.88 - 2324.15 / 5.04 * eta + 1255.0 / 9.0 * eta_pow2)
            * chi_s_pow2
        )
        * PI_third
        * common_factor
    )
    phi_6l = -684.8 / 6.3 * PI_third * common_factor
    phi_7 = (
        (
            (770.96675 / 2.54016 + 378.515 / 1.512 * eta - 740.45 / 7.56 * eta_pow2)
            * PI
            + (
                -25150.083775 / 3.048192
                + 26804.935 / 6.048 * eta
                - 198.5 / 4.8 * eta_pow2
            )
            * delta
            * chi_a
            + (
                -25150.083775 / 3.048192
                + 105666.55595 / 7.62048 * eta
                - 1042.165 / 3.024 * eta_pow2
                + 534.5 / 3.6 * eta_pow3
            )
            * chi_s
            - 1140.0 * PI * delta * chi_a * chi_s
            + (-570.0 + 2240.0 * eta) * PI * chi_a_pow2
            + (-570.0 + 40.0 * eta) * PI * chi_s_pow2
            + (14585.0 / 8.0 - 215.0 / 2.0 * eta) * delta * chi_a * chi_s_pow2
            + (14585.0 / 8.0 - 7270.0 * eta + 80.0 * eta_pow2) * chi_a_pow2 * chi_s
            + (1458.5 / 2.4 - 2380.0 * eta) * delta * chi_a_pow3
            + (1458.5 / 2.4 - 475.0 / 6.0 * eta + 100.0 / 3.0 * eta_pow2) * chi_s_pow3
        )
        * PI_two_thirds
        * common_factor
    )
    phi_8 = (
        (
            (2339.15 / 1.68 - 991.85 / 2.52 * eta) * delta * chi_a
            + (2339.15 / 1.68 - 3970.375 / 2.268 * eta + 196.55 / 1.89 * eta_pow2)
            * chi_s
        )
        * PI_two
        * common_factor
    )
    phi_8l = -phi_8

    time_shift = (
        -5.0 / 3.0 * phi_0 / Mf_ISCO ** (8 / 3)
        - 4.0 / 3.0 * phi_1 / Mf_ISCO ** (7 / 3)
        - phi_2 / Mf_ISCO ** (2)
        - 2.0 / 3.0 * phi_3 / Mf_ISCO ** (5 / 3)
        - 1.0 / 3.0 * phi_4 / Mf_ISCO ** (4 / 3)
        + phi_5l / Mf_ISCO
        + 1.0 / 3.0 * phi_6 / Mf_ISCO ** (2 / 3)
        + 1.0 / 3.0 * phi_6l / Mf_ISCO ** (2 / 3) * (3.0 + np.log(Mf_ISCO) + PI_log)
        + 2.0 / 3.0 * phi_7 / Mf_ISCO ** (1 / 3)
        + phi_8
        + phi_8l * (1.0 + np.log(Mf_ISCO) + PI_log)
    )

    return (
        -M_total_sec
        / (2 * PI)
        * np.where(
            Mf_array < Mf_ISCO,
            -5.0 / 3.0 * phi_0 / Mf_array ** (8 / 3)
            - 4.0 / 3.0 * phi_1 / Mf_array ** (7 / 3)
            - phi_2 / Mf_array ** (2)
            - 2.0 / 3.0 * phi_3 / Mf_array ** (5 / 3)
            - 1.0 / 3.0 * phi_4 / Mf_array ** (4 / 3)
            + phi_5l / Mf_array
            + 1.0 / 3.0 * phi_6 / Mf_array ** (2 / 3)
            + 1.0
            / 3.0
            * phi_6l
            / Mf_array ** (2 / 3)
            * (3.0 + np.log(Mf_array) + PI_log)
            + 2.0 / 3.0 * phi_7 / Mf_array ** (1 / 3)
            + phi_8
            + phi_8l * (1.0 + np.log(Mf_array) + PI_log)
            - time_shift,
            0.0,
        )
    )


from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from numpy.typing import NDArray
