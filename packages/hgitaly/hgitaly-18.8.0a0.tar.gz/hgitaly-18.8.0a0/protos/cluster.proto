syntax = "proto3";

package gitaly;

import "lint.proto";
import "raftpb/raft.proto"; // Upstream go.etcd.io/raft/v3/raftpb/raft.proto

option go_package = "gitlab.com/gitlab-org/gitaly/v18/proto/go/gitalypb";

// RaftEntry encapsulates critical data for replication using etcd/raft library.
// It has a request ID allowing the primary to track when the action is
// effectively applied.
message RaftEntry {
  // LogData contains serialized log data, including the log entry itself
  // and all attached files in the log entry's directory. These data are
  // exchanged at the Transport layer before sending and after receiving
  // messages. They remain transparent to the core Raft engine.
  message LogData {
    // local_path is the path to the staging log entry directory. Before the
    // request is sent to other nodes, this whole directory of the entry is
    // serialized. So, this field is only relevant to the primary node who
    // issues the request.
    bytes local_path = 1;
    // packed is the serialized form of the log entry data. Transport
    // implementations populates this field before sending out messages to other
    // members of a Raft group.
    bytes packed = 2;
  }

  // id is the unique identifier for the Raft message. This ID is generated by
  // an in-memory event registry. Raft uses this ID to track the commit status
  // of a log entry.
  uint64 id = 1;

  // data represents packed and serialized log data.
  LogData data = 2;
}

// RaftPartitionKey is a globally-unique identifier for a replicated partition.
// The replica which minted the partition is responsible for computing the RaftPartitionKey,
// which is a hash of the storage name and partition ID. The key is then consumed
// as-is by other replicas wishing to store the partition.
message RaftPartitionKey {
  // value is the SHA256 digest of the storage name and partition ID of the
  // newly-minted partition.
  string value = 1;
}

// ReplicaID uniquely identifies a replica in the Raft cluster.
// It combines partition information with node-specific details.
message ReplicaID {
  // partition_key identifies which partition this replica belongs to.
  RaftPartitionKey partition_key = 1;
  // member_id is the unique identifier assigned by etcd/raft.
  uint64 member_id = 2;
  // storage_name is the name of the storage where this replica is hosted.
  string storage_name = 3;
  // Metadata contains routing information for the replica.
  message Metadata {
    // address is the network address of the replica.
    string address = 1;
  }
  // metadata contains replica information.
  Metadata metadata = 4;
  // ReplicaType indicates whether a replica is a voter or learner in the Raft cluster
  enum ReplicaType {
    // REPLICA_TYPE_UNSPECIFIED.
    REPLICA_TYPE_UNSPECIFIED = 0;
    // REPLICA_TYPE_VOTER indicates a replica that can participate in Raft elections and voting.
    REPLICA_TYPE_VOTER = 1;
    // REPLICA_TYPE_LEARNER indicates a replica that receives updates but cannot vote.
    REPLICA_TYPE_LEARNER = 2;
  }
  // type indicates whether the replica is learner or voter.
  ReplicaType type = 5;
}

// RaftMessageRequest is a request for the SendMessage RPC. It serves as a
// wrapper for raftpb.Message. etcd/raft's state machines on each member emit
// this message. Since Gitaly employs multi-raft, routing metadata is attached
// to ensure the message reaches the correct Raft group inside the receiving
// Gitaly server.
message RaftMessageRequest {
  // cluster_id is the identifier of the Raft cluster to which this message belongs.
  string cluster_id = 1;

  // replica_id uniquely identifies a replica in the Raft cluster.
  ReplicaID replica_id = 2;

  // message is the Raft message to be delivered.
  raftpb.Message message = 3;
}

// RaftMessageResponse represents a response to the SendMessage RPC.
message RaftMessageResponse {
}

// RaftSnapshotMessageRequest is the input to SendSnapshot RPC.
message RaftSnapshotMessageRequest {
  oneof raft_snapshot_payload {
    // raft_msg is a wrapper for raftpb.Message
    RaftMessageRequest raft_msg = 1;
    // chunk of snapshot data
    bytes chunk = 2;
  }
}

// RaftSnapshotMessageResponse is the response to SendSnapshot RPC.
message RaftSnapshotMessageResponse {
  // destination is where the snapshot is saved.
  string destination = 1;
  // snapshot_size is the snapshot size in bytes.
  uint64 snapshot_size = 2;
}

// JoinClusterRequest is sent by the leader to a new node to join a specific partition.
message JoinClusterRequest {
  // partition_key identifies which partition the new node should join.
  RaftPartitionKey partition_key = 1;

  // leader_id is the Member ID of the current Raft group leader
  uint64 leader_id = 2;

  // member_id is the unique Raft member ID assigned by the leader for this replica.
  uint64 member_id = 3;

  // storage_name is the name of the storage where the replica should be created.
  string storage_name = 4 [(gitaly.storage) = true];

  // relative_path is the path within the storage where the partition data is located.
  string relative_path = 5;

  // replicas contains the current list of all cluster members for routing table initialization.
  repeated ReplicaID replicas = 6;
}

// JoinClusterResponse indicates the result of the join operation.
message JoinClusterResponse {
}

// GetPartitionsRequest is the request for the GetPartitions RPC.
message GetPartitionsRequest {
  // cluster_id is the identifier of the Raft cluster to query.
  string cluster_id = 1;

  // partition_key is an optional filter to get information about a specific partition.
  // If not provided, returns information about all partitions.
  RaftPartitionKey partition_key = 2;

  // relative_path is an optional filter to get information about partitions containing
  // the specified repository relative path. When specified, this is mapped to a partition_key
  // internally, and the storage filter (if provided) is preserved.
  string relative_path = 3;

  // storage is an optional filter to get information about partitions that have
  // replicas on the specified storage name. Can be combined with relative_path or partition_key.
  string storage = 4;

  // include_replica_details determines whether to include detailed replica state information.
  bool include_replica_details = 5;

  // include_relative_paths determines whether to include the list of repository paths
  // for each partition in the response. Set to false if you only need partition counts
  // to reduce memory usage and improve performance.
  bool include_relative_paths = 6;
}

// ClusterStatistics contains aggregated statistics about the entire cluster.
message ClusterStatistics {
  // StorageStats contains statistics for a specific storage/authority.
  message StorageStats {
    // leader_count is the number of partitions where this storage is the leader.
    uint32 leader_count = 1;
    // replica_count is the total number of replicas hosted on this storage.
    uint32 replica_count = 2;
  }

  // total_partitions is the total number of partitions in the cluster.
  uint32 total_partitions = 1;

  // healthy_partitions is the number of partitions with a leader that has a configured address.
  // A partition is considered healthy if:
  // 1. It has a leader (leader_id != 0)
  // 2. The leader replica has metadata with a non-empty address
  // Note: This checks configuration presence, not actual reachability or operational status.
  uint32 healthy_partitions = 2;

  // total_replicas is the total number of replicas across all partitions.
  uint32 total_replicas = 3;

  // healthy_replicas is the number of replicas that have a configured address.
  // A replica is considered healthy if it has metadata with a non-empty address field.
  // Note: This checks configuration presence, not actual reachability or operational status.
  uint32 healthy_replicas = 4;

  // storage_stats maps storage names (authorities) to their leader and replica counts.
  map<string, StorageStats> storage_stats = 5;
}

// GetPartitionsResponse is the response for the GetPartitions streaming RPC.
// Each response message contains information about a single partition.
message GetPartitionsResponse {
  // ReplicaStatus contains status information about a single replica.
  message ReplicaStatus {
    // replica_id uniquely identifies the replica.
    ReplicaID replica_id = 1;

    // is_leader indicates whether this replica is currently the leader.
    bool is_leader = 2;

    // is_healthy indicates whether the replica has a configured address.
    // Note: This checks configuration presence (metadata.address != ""), not actual
    // reachability or operational status. A replica marked as healthy may still be
    // unreachable due to network issues or being offline.
    bool is_healthy = 3;

    // last_index is the index of the last log entry this replica has.
    uint64 last_index = 4;

    // match_index is the highest log index known to be replicated on this replica.
    uint64 match_index = 5;

    // state represents the Raft state of this replica (follower, candidate, leader).
    // Possible values: "StateFollower", "StateCandidate", "StateLeader", "StatePreCandidate"
    string state = 6;
  }

  // cluster_id is the identifier of the Raft cluster.
  string cluster_id = 1;
  // partition_key identifies the partition this response describes.
  RaftPartitionKey partition_key = 2;
  // replicas contains information about all replicas in this partition.
  repeated ReplicaStatus replicas = 3;
  // leader_id is the member ID of the current leader, 0 if no leader.
  uint64 leader_id = 4;
  // term is the current Raft term for this partition.
  uint64 term = 5;
  // index is the current Raft log index for this partition.
  uint64 index = 6;
  // relative_path is the repository path for backward compatibility.
  string relative_path = 7;
  // relative_paths contains the list of repository paths in this partition
  // when include_relative_paths is set to true in the request.
  repeated string relative_paths = 8;
}

// RaftClusterInfoRequest is the request for the GetClusterInfo RPC.
message RaftClusterInfoRequest {
  // cluster_id is the identifier of the Raft cluster to query.
  string cluster_id = 1;
}

// RaftClusterInfoResponse is the response for the GetClusterInfo RPC.
message RaftClusterInfoResponse {
  // cluster_id is the identifier of the Raft cluster.
  string cluster_id = 1;
  // statistics contains aggregated cluster statistics.
  ClusterStatistics statistics = 2;
}

// RaftService manages the sending of Raft messages to peers.
service RaftService {
  // SendMessage processes Raft messages and ensures they are handled by
  // the receiving node to update its Raft state machine.
  rpc SendMessage(stream RaftMessageRequest) returns (RaftMessageResponse) {
    option (op_type) = {
      op: MUTATOR
      scope_level: STORAGE
    };
  }
  // SendSnapshot sends raft snapshots from the leader to the follower node. Typically it
  // would be useful for nodes to catch up to the latest state.
  rpc SendSnapshot(stream RaftSnapshotMessageRequest) returns (RaftSnapshotMessageResponse) {
    option (op_type) = {
      op: MUTATOR
      scope_level: STORAGE
    };
  }

  // JoinCluster is called by the leader to instruct a new node to join an existing cluster.
  rpc JoinCluster(JoinClusterRequest) returns (JoinClusterResponse) {
    option (op_type) = {
      op: MUTATOR
      scope_level: STORAGE
    };
  }

  // GetPartitions retrieves comprehensive information about the Raft cluster topology,
  // partition states, and replica health. This is useful for monitoring and debugging.
  // Returns a stream of partition information, one response per partition.
  rpc GetPartitions(GetPartitionsRequest) returns (stream GetPartitionsResponse) {
    option (op_type) = {
      op: ACCESSOR
      scope_level: STORAGE
    };
  }

  // GetClusterInfo retrieves cluster-wide statistics and overview information.
  // This is a unary RPC that returns only aggregated statistics, not partition details.
  rpc GetClusterInfo(RaftClusterInfoRequest) returns (RaftClusterInfoResponse) {
    option (op_type) = {
      op: ACCESSOR
      scope_level: STORAGE
    };
  }
}
