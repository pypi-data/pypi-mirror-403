# coding: utf-8

"""
    Sonatype Nexus Repository Manager

    This documents the available APIs into [Sonatype Nexus Repository Manager](https://www.sonatype.com/products/sonatype-nexus-repository) as of version 3.88.0-08.

    The version of the OpenAPI document: 3.88.0-08
    Contact: community@sonatype.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import Optional
from typing_extensions import Annotated
from nexus_api_client.models.base_tag_xo import BaseTagXO
from nexus_api_client.models.page_tag_xo import PageTagXO
from nexus_api_client.models.tag_xo import TagXO

from nexus_api_client.api_client import ApiClient, RequestSerialized
from nexus_api_client.api_response import ApiResponse
from nexus_api_client.rest import RESTResponseType


class TagsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def associate(
        self,
        tag_name: Annotated[StrictStr, Field(description="Tag to associate to the matched components")],
        wait: Annotated[Optional[StrictBool], Field(description="The query waits until the indexing is complete")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query by keyword")] = None,
        repository: Annotated[Optional[StrictStr], Field(description="Repository name")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Query by format")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Component group")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Component name")] = None,
        version: Annotated[Optional[StrictStr], Field(description="Component version")] = None,
        prerelease: Annotated[Optional[StrictStr], Field(description="Prerelease version flag")] = None,
        last_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time")] = None,
        last_blob_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time (UI)")] = None,
        md5: Annotated[Optional[StrictStr], Field(description="Specific MD5 hash of component's asset")] = None,
        sha1: Annotated[Optional[StrictStr], Field(description="Specific SHA-1 hash of component's asset")] = None,
        sha256: Annotated[Optional[StrictStr], Field(description="Specific SHA-256 hash of component's asset")] = None,
        sha512: Annotated[Optional[StrictStr], Field(description="Specific SHA-512 hash of component's asset")] = None,
        composer_vendor: Annotated[Optional[StrictStr], Field(description="Vendor")] = None,
        composer_package: Annotated[Optional[StrictStr], Field(description="Package")] = None,
        composer_version: Annotated[Optional[StrictStr], Field(description="Version")] = None,
        conan_base_version: Annotated[Optional[StrictStr], Field(description="Conan base version")] = None,
        conan_channel: Annotated[Optional[StrictStr], Field(description="Conan channel")] = None,
        conan_revision: Annotated[Optional[StrictStr], Field(description="Conan recipe revision")] = None,
        conan_package_id: Annotated[Optional[StrictStr], Field(description="Conan package id")] = None,
        conan_package_revision: Annotated[Optional[StrictStr], Field(description="Conan package revision")] = None,
        docker_image_name: Annotated[Optional[StrictStr], Field(description="Docker image name")] = None,
        docker_image_tag: Annotated[Optional[StrictStr], Field(description="Docker image tag")] = None,
        docker_layer_id: Annotated[Optional[StrictStr], Field(description="Docker layer ID")] = None,
        docker_content_digest: Annotated[Optional[StrictStr], Field(description="Docker content digest")] = None,
        maven_group_id: Annotated[Optional[StrictStr], Field(description="Maven groupId")] = None,
        maven_artifact_id: Annotated[Optional[StrictStr], Field(description="Maven artifactId")] = None,
        maven_base_version: Annotated[Optional[StrictStr], Field(description="Maven base version")] = None,
        maven_extension: Annotated[Optional[StrictStr], Field(description="Maven extension of component's asset")] = None,
        maven_classifier: Annotated[Optional[StrictStr], Field(description="Maven classifier of component's asset")] = None,
        gavec: Annotated[Optional[StrictStr], Field(description="Group asset version extension classifier")] = None,
        npm_scope: Annotated[Optional[StrictStr], Field(description="npm scope")] = None,
        npm_author: Annotated[Optional[StrictStr], Field(description="npm author")] = None,
        npm_description: Annotated[Optional[StrictStr], Field(description="npm description")] = None,
        npm_keywords: Annotated[Optional[StrictStr], Field(description="npm keywords")] = None,
        npm_license: Annotated[Optional[StrictStr], Field(description="npm license")] = None,
        npm_tagged_is: Annotated[Optional[StrictStr], Field(description="npm tagged is")] = None,
        npm_tagged_not: Annotated[Optional[StrictStr], Field(description="npm tagged not")] = None,
        nuget_id: Annotated[Optional[StrictStr], Field(description="NuGet id")] = None,
        nuget_tags: Annotated[Optional[StrictStr], Field(description="NuGet tags")] = None,
        nuget_title: Annotated[Optional[StrictStr], Field(description="NuGet title")] = None,
        nuget_authors: Annotated[Optional[StrictStr], Field(description="NuGet authors")] = None,
        nuget_description: Annotated[Optional[StrictStr], Field(description="NuGet description")] = None,
        nuget_summary: Annotated[Optional[StrictStr], Field(description="NuGet summary")] = None,
        nuget_is_prerelease: Annotated[Optional[StrictStr], Field(description="NuGet prerelease")] = None,
        p2_plugin_name: Annotated[Optional[StrictStr], Field(description="p2 plugin name")] = None,
        pypi_classifiers: Annotated[Optional[StrictStr], Field(description="PyPI classifiers")] = None,
        pypi_description: Annotated[Optional[StrictStr], Field(description="PyPI description")] = None,
        pypi_keywords: Annotated[Optional[StrictStr], Field(description="PyPI keywords")] = None,
        pypi_summary: Annotated[Optional[StrictStr], Field(description="PyPI summary")] = None,
        rubygems_description: Annotated[Optional[StrictStr], Field(description="RubyGems description")] = None,
        rubygems_platform: Annotated[Optional[StrictStr], Field(description="RubyGems platform")] = None,
        rubygems_summary: Annotated[Optional[StrictStr], Field(description="RubyGems summary")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Component tag")] = None,
        terraform_provider: Annotated[Optional[StrictStr], Field(description="terraform provider")] = None,
        terraform_namespace: Annotated[Optional[StrictStr], Field(description="terraform namespace")] = None,
        terraform_name: Annotated[Optional[StrictStr], Field(description="terraform name")] = None,
        yum_architecture: Annotated[Optional[StrictStr], Field(description="Yum architecture")] = None,
        yum_name: Annotated[Optional[StrictStr], Field(description="Yum package name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Associate components with a tag


        :param tag_name: Tag to associate to the matched components (required)
        :type tag_name: str
        :param wait: The query waits until the indexing is complete
        :type wait: bool
        :param q: Query by keyword
        :type q: str
        :param repository: Repository name
        :type repository: str
        :param format: Query by format
        :type format: str
        :param group: Component group
        :type group: str
        :param name: Component name
        :type name: str
        :param version: Component version
        :type version: str
        :param prerelease: Prerelease version flag
        :type prerelease: str
        :param last_updated: Asset last modified time
        :type last_updated: str
        :param last_blob_updated: Asset last modified time (UI)
        :type last_blob_updated: str
        :param md5: Specific MD5 hash of component's asset
        :type md5: str
        :param sha1: Specific SHA-1 hash of component's asset
        :type sha1: str
        :param sha256: Specific SHA-256 hash of component's asset
        :type sha256: str
        :param sha512: Specific SHA-512 hash of component's asset
        :type sha512: str
        :param composer_vendor: Vendor
        :type composer_vendor: str
        :param composer_package: Package
        :type composer_package: str
        :param composer_version: Version
        :type composer_version: str
        :param conan_base_version: Conan base version
        :type conan_base_version: str
        :param conan_channel: Conan channel
        :type conan_channel: str
        :param conan_revision: Conan recipe revision
        :type conan_revision: str
        :param conan_package_id: Conan package id
        :type conan_package_id: str
        :param conan_package_revision: Conan package revision
        :type conan_package_revision: str
        :param docker_image_name: Docker image name
        :type docker_image_name: str
        :param docker_image_tag: Docker image tag
        :type docker_image_tag: str
        :param docker_layer_id: Docker layer ID
        :type docker_layer_id: str
        :param docker_content_digest: Docker content digest
        :type docker_content_digest: str
        :param maven_group_id: Maven groupId
        :type maven_group_id: str
        :param maven_artifact_id: Maven artifactId
        :type maven_artifact_id: str
        :param maven_base_version: Maven base version
        :type maven_base_version: str
        :param maven_extension: Maven extension of component's asset
        :type maven_extension: str
        :param maven_classifier: Maven classifier of component's asset
        :type maven_classifier: str
        :param gavec: Group asset version extension classifier
        :type gavec: str
        :param npm_scope: npm scope
        :type npm_scope: str
        :param npm_author: npm author
        :type npm_author: str
        :param npm_description: npm description
        :type npm_description: str
        :param npm_keywords: npm keywords
        :type npm_keywords: str
        :param npm_license: npm license
        :type npm_license: str
        :param npm_tagged_is: npm tagged is
        :type npm_tagged_is: str
        :param npm_tagged_not: npm tagged not
        :type npm_tagged_not: str
        :param nuget_id: NuGet id
        :type nuget_id: str
        :param nuget_tags: NuGet tags
        :type nuget_tags: str
        :param nuget_title: NuGet title
        :type nuget_title: str
        :param nuget_authors: NuGet authors
        :type nuget_authors: str
        :param nuget_description: NuGet description
        :type nuget_description: str
        :param nuget_summary: NuGet summary
        :type nuget_summary: str
        :param nuget_is_prerelease: NuGet prerelease
        :type nuget_is_prerelease: str
        :param p2_plugin_name: p2 plugin name
        :type p2_plugin_name: str
        :param pypi_classifiers: PyPI classifiers
        :type pypi_classifiers: str
        :param pypi_description: PyPI description
        :type pypi_description: str
        :param pypi_keywords: PyPI keywords
        :type pypi_keywords: str
        :param pypi_summary: PyPI summary
        :type pypi_summary: str
        :param rubygems_description: RubyGems description
        :type rubygems_description: str
        :param rubygems_platform: RubyGems platform
        :type rubygems_platform: str
        :param rubygems_summary: RubyGems summary
        :type rubygems_summary: str
        :param tag: Component tag
        :type tag: str
        :param terraform_provider: terraform provider
        :type terraform_provider: str
        :param terraform_namespace: terraform namespace
        :type terraform_namespace: str
        :param terraform_name: terraform name
        :type terraform_name: str
        :param yum_architecture: Yum architecture
        :type yum_architecture: str
        :param yum_name: Yum package name
        :type yum_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_serialize(
            tag_name=tag_name,
            wait=wait,
            q=q,
            repository=repository,
            format=format,
            group=group,
            name=name,
            version=version,
            prerelease=prerelease,
            last_updated=last_updated,
            last_blob_updated=last_blob_updated,
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            sha512=sha512,
            composer_vendor=composer_vendor,
            composer_package=composer_package,
            composer_version=composer_version,
            conan_base_version=conan_base_version,
            conan_channel=conan_channel,
            conan_revision=conan_revision,
            conan_package_id=conan_package_id,
            conan_package_revision=conan_package_revision,
            docker_image_name=docker_image_name,
            docker_image_tag=docker_image_tag,
            docker_layer_id=docker_layer_id,
            docker_content_digest=docker_content_digest,
            maven_group_id=maven_group_id,
            maven_artifact_id=maven_artifact_id,
            maven_base_version=maven_base_version,
            maven_extension=maven_extension,
            maven_classifier=maven_classifier,
            gavec=gavec,
            npm_scope=npm_scope,
            npm_author=npm_author,
            npm_description=npm_description,
            npm_keywords=npm_keywords,
            npm_license=npm_license,
            npm_tagged_is=npm_tagged_is,
            npm_tagged_not=npm_tagged_not,
            nuget_id=nuget_id,
            nuget_tags=nuget_tags,
            nuget_title=nuget_title,
            nuget_authors=nuget_authors,
            nuget_description=nuget_description,
            nuget_summary=nuget_summary,
            nuget_is_prerelease=nuget_is_prerelease,
            p2_plugin_name=p2_plugin_name,
            pypi_classifiers=pypi_classifiers,
            pypi_description=pypi_description,
            pypi_keywords=pypi_keywords,
            pypi_summary=pypi_summary,
            rubygems_description=rubygems_description,
            rubygems_platform=rubygems_platform,
            rubygems_summary=rubygems_summary,
            tag=tag,
            terraform_provider=terraform_provider,
            terraform_namespace=terraform_namespace,
            terraform_name=terraform_name,
            yum_architecture=yum_architecture,
            yum_name=yum_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def associate_with_http_info(
        self,
        tag_name: Annotated[StrictStr, Field(description="Tag to associate to the matched components")],
        wait: Annotated[Optional[StrictBool], Field(description="The query waits until the indexing is complete")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query by keyword")] = None,
        repository: Annotated[Optional[StrictStr], Field(description="Repository name")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Query by format")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Component group")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Component name")] = None,
        version: Annotated[Optional[StrictStr], Field(description="Component version")] = None,
        prerelease: Annotated[Optional[StrictStr], Field(description="Prerelease version flag")] = None,
        last_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time")] = None,
        last_blob_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time (UI)")] = None,
        md5: Annotated[Optional[StrictStr], Field(description="Specific MD5 hash of component's asset")] = None,
        sha1: Annotated[Optional[StrictStr], Field(description="Specific SHA-1 hash of component's asset")] = None,
        sha256: Annotated[Optional[StrictStr], Field(description="Specific SHA-256 hash of component's asset")] = None,
        sha512: Annotated[Optional[StrictStr], Field(description="Specific SHA-512 hash of component's asset")] = None,
        composer_vendor: Annotated[Optional[StrictStr], Field(description="Vendor")] = None,
        composer_package: Annotated[Optional[StrictStr], Field(description="Package")] = None,
        composer_version: Annotated[Optional[StrictStr], Field(description="Version")] = None,
        conan_base_version: Annotated[Optional[StrictStr], Field(description="Conan base version")] = None,
        conan_channel: Annotated[Optional[StrictStr], Field(description="Conan channel")] = None,
        conan_revision: Annotated[Optional[StrictStr], Field(description="Conan recipe revision")] = None,
        conan_package_id: Annotated[Optional[StrictStr], Field(description="Conan package id")] = None,
        conan_package_revision: Annotated[Optional[StrictStr], Field(description="Conan package revision")] = None,
        docker_image_name: Annotated[Optional[StrictStr], Field(description="Docker image name")] = None,
        docker_image_tag: Annotated[Optional[StrictStr], Field(description="Docker image tag")] = None,
        docker_layer_id: Annotated[Optional[StrictStr], Field(description="Docker layer ID")] = None,
        docker_content_digest: Annotated[Optional[StrictStr], Field(description="Docker content digest")] = None,
        maven_group_id: Annotated[Optional[StrictStr], Field(description="Maven groupId")] = None,
        maven_artifact_id: Annotated[Optional[StrictStr], Field(description="Maven artifactId")] = None,
        maven_base_version: Annotated[Optional[StrictStr], Field(description="Maven base version")] = None,
        maven_extension: Annotated[Optional[StrictStr], Field(description="Maven extension of component's asset")] = None,
        maven_classifier: Annotated[Optional[StrictStr], Field(description="Maven classifier of component's asset")] = None,
        gavec: Annotated[Optional[StrictStr], Field(description="Group asset version extension classifier")] = None,
        npm_scope: Annotated[Optional[StrictStr], Field(description="npm scope")] = None,
        npm_author: Annotated[Optional[StrictStr], Field(description="npm author")] = None,
        npm_description: Annotated[Optional[StrictStr], Field(description="npm description")] = None,
        npm_keywords: Annotated[Optional[StrictStr], Field(description="npm keywords")] = None,
        npm_license: Annotated[Optional[StrictStr], Field(description="npm license")] = None,
        npm_tagged_is: Annotated[Optional[StrictStr], Field(description="npm tagged is")] = None,
        npm_tagged_not: Annotated[Optional[StrictStr], Field(description="npm tagged not")] = None,
        nuget_id: Annotated[Optional[StrictStr], Field(description="NuGet id")] = None,
        nuget_tags: Annotated[Optional[StrictStr], Field(description="NuGet tags")] = None,
        nuget_title: Annotated[Optional[StrictStr], Field(description="NuGet title")] = None,
        nuget_authors: Annotated[Optional[StrictStr], Field(description="NuGet authors")] = None,
        nuget_description: Annotated[Optional[StrictStr], Field(description="NuGet description")] = None,
        nuget_summary: Annotated[Optional[StrictStr], Field(description="NuGet summary")] = None,
        nuget_is_prerelease: Annotated[Optional[StrictStr], Field(description="NuGet prerelease")] = None,
        p2_plugin_name: Annotated[Optional[StrictStr], Field(description="p2 plugin name")] = None,
        pypi_classifiers: Annotated[Optional[StrictStr], Field(description="PyPI classifiers")] = None,
        pypi_description: Annotated[Optional[StrictStr], Field(description="PyPI description")] = None,
        pypi_keywords: Annotated[Optional[StrictStr], Field(description="PyPI keywords")] = None,
        pypi_summary: Annotated[Optional[StrictStr], Field(description="PyPI summary")] = None,
        rubygems_description: Annotated[Optional[StrictStr], Field(description="RubyGems description")] = None,
        rubygems_platform: Annotated[Optional[StrictStr], Field(description="RubyGems platform")] = None,
        rubygems_summary: Annotated[Optional[StrictStr], Field(description="RubyGems summary")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Component tag")] = None,
        terraform_provider: Annotated[Optional[StrictStr], Field(description="terraform provider")] = None,
        terraform_namespace: Annotated[Optional[StrictStr], Field(description="terraform namespace")] = None,
        terraform_name: Annotated[Optional[StrictStr], Field(description="terraform name")] = None,
        yum_architecture: Annotated[Optional[StrictStr], Field(description="Yum architecture")] = None,
        yum_name: Annotated[Optional[StrictStr], Field(description="Yum package name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Associate components with a tag


        :param tag_name: Tag to associate to the matched components (required)
        :type tag_name: str
        :param wait: The query waits until the indexing is complete
        :type wait: bool
        :param q: Query by keyword
        :type q: str
        :param repository: Repository name
        :type repository: str
        :param format: Query by format
        :type format: str
        :param group: Component group
        :type group: str
        :param name: Component name
        :type name: str
        :param version: Component version
        :type version: str
        :param prerelease: Prerelease version flag
        :type prerelease: str
        :param last_updated: Asset last modified time
        :type last_updated: str
        :param last_blob_updated: Asset last modified time (UI)
        :type last_blob_updated: str
        :param md5: Specific MD5 hash of component's asset
        :type md5: str
        :param sha1: Specific SHA-1 hash of component's asset
        :type sha1: str
        :param sha256: Specific SHA-256 hash of component's asset
        :type sha256: str
        :param sha512: Specific SHA-512 hash of component's asset
        :type sha512: str
        :param composer_vendor: Vendor
        :type composer_vendor: str
        :param composer_package: Package
        :type composer_package: str
        :param composer_version: Version
        :type composer_version: str
        :param conan_base_version: Conan base version
        :type conan_base_version: str
        :param conan_channel: Conan channel
        :type conan_channel: str
        :param conan_revision: Conan recipe revision
        :type conan_revision: str
        :param conan_package_id: Conan package id
        :type conan_package_id: str
        :param conan_package_revision: Conan package revision
        :type conan_package_revision: str
        :param docker_image_name: Docker image name
        :type docker_image_name: str
        :param docker_image_tag: Docker image tag
        :type docker_image_tag: str
        :param docker_layer_id: Docker layer ID
        :type docker_layer_id: str
        :param docker_content_digest: Docker content digest
        :type docker_content_digest: str
        :param maven_group_id: Maven groupId
        :type maven_group_id: str
        :param maven_artifact_id: Maven artifactId
        :type maven_artifact_id: str
        :param maven_base_version: Maven base version
        :type maven_base_version: str
        :param maven_extension: Maven extension of component's asset
        :type maven_extension: str
        :param maven_classifier: Maven classifier of component's asset
        :type maven_classifier: str
        :param gavec: Group asset version extension classifier
        :type gavec: str
        :param npm_scope: npm scope
        :type npm_scope: str
        :param npm_author: npm author
        :type npm_author: str
        :param npm_description: npm description
        :type npm_description: str
        :param npm_keywords: npm keywords
        :type npm_keywords: str
        :param npm_license: npm license
        :type npm_license: str
        :param npm_tagged_is: npm tagged is
        :type npm_tagged_is: str
        :param npm_tagged_not: npm tagged not
        :type npm_tagged_not: str
        :param nuget_id: NuGet id
        :type nuget_id: str
        :param nuget_tags: NuGet tags
        :type nuget_tags: str
        :param nuget_title: NuGet title
        :type nuget_title: str
        :param nuget_authors: NuGet authors
        :type nuget_authors: str
        :param nuget_description: NuGet description
        :type nuget_description: str
        :param nuget_summary: NuGet summary
        :type nuget_summary: str
        :param nuget_is_prerelease: NuGet prerelease
        :type nuget_is_prerelease: str
        :param p2_plugin_name: p2 plugin name
        :type p2_plugin_name: str
        :param pypi_classifiers: PyPI classifiers
        :type pypi_classifiers: str
        :param pypi_description: PyPI description
        :type pypi_description: str
        :param pypi_keywords: PyPI keywords
        :type pypi_keywords: str
        :param pypi_summary: PyPI summary
        :type pypi_summary: str
        :param rubygems_description: RubyGems description
        :type rubygems_description: str
        :param rubygems_platform: RubyGems platform
        :type rubygems_platform: str
        :param rubygems_summary: RubyGems summary
        :type rubygems_summary: str
        :param tag: Component tag
        :type tag: str
        :param terraform_provider: terraform provider
        :type terraform_provider: str
        :param terraform_namespace: terraform namespace
        :type terraform_namespace: str
        :param terraform_name: terraform name
        :type terraform_name: str
        :param yum_architecture: Yum architecture
        :type yum_architecture: str
        :param yum_name: Yum package name
        :type yum_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_serialize(
            tag_name=tag_name,
            wait=wait,
            q=q,
            repository=repository,
            format=format,
            group=group,
            name=name,
            version=version,
            prerelease=prerelease,
            last_updated=last_updated,
            last_blob_updated=last_blob_updated,
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            sha512=sha512,
            composer_vendor=composer_vendor,
            composer_package=composer_package,
            composer_version=composer_version,
            conan_base_version=conan_base_version,
            conan_channel=conan_channel,
            conan_revision=conan_revision,
            conan_package_id=conan_package_id,
            conan_package_revision=conan_package_revision,
            docker_image_name=docker_image_name,
            docker_image_tag=docker_image_tag,
            docker_layer_id=docker_layer_id,
            docker_content_digest=docker_content_digest,
            maven_group_id=maven_group_id,
            maven_artifact_id=maven_artifact_id,
            maven_base_version=maven_base_version,
            maven_extension=maven_extension,
            maven_classifier=maven_classifier,
            gavec=gavec,
            npm_scope=npm_scope,
            npm_author=npm_author,
            npm_description=npm_description,
            npm_keywords=npm_keywords,
            npm_license=npm_license,
            npm_tagged_is=npm_tagged_is,
            npm_tagged_not=npm_tagged_not,
            nuget_id=nuget_id,
            nuget_tags=nuget_tags,
            nuget_title=nuget_title,
            nuget_authors=nuget_authors,
            nuget_description=nuget_description,
            nuget_summary=nuget_summary,
            nuget_is_prerelease=nuget_is_prerelease,
            p2_plugin_name=p2_plugin_name,
            pypi_classifiers=pypi_classifiers,
            pypi_description=pypi_description,
            pypi_keywords=pypi_keywords,
            pypi_summary=pypi_summary,
            rubygems_description=rubygems_description,
            rubygems_platform=rubygems_platform,
            rubygems_summary=rubygems_summary,
            tag=tag,
            terraform_provider=terraform_provider,
            terraform_namespace=terraform_namespace,
            terraform_name=terraform_name,
            yum_architecture=yum_architecture,
            yum_name=yum_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def associate_without_preload_content(
        self,
        tag_name: Annotated[StrictStr, Field(description="Tag to associate to the matched components")],
        wait: Annotated[Optional[StrictBool], Field(description="The query waits until the indexing is complete")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query by keyword")] = None,
        repository: Annotated[Optional[StrictStr], Field(description="Repository name")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Query by format")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Component group")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Component name")] = None,
        version: Annotated[Optional[StrictStr], Field(description="Component version")] = None,
        prerelease: Annotated[Optional[StrictStr], Field(description="Prerelease version flag")] = None,
        last_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time")] = None,
        last_blob_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time (UI)")] = None,
        md5: Annotated[Optional[StrictStr], Field(description="Specific MD5 hash of component's asset")] = None,
        sha1: Annotated[Optional[StrictStr], Field(description="Specific SHA-1 hash of component's asset")] = None,
        sha256: Annotated[Optional[StrictStr], Field(description="Specific SHA-256 hash of component's asset")] = None,
        sha512: Annotated[Optional[StrictStr], Field(description="Specific SHA-512 hash of component's asset")] = None,
        composer_vendor: Annotated[Optional[StrictStr], Field(description="Vendor")] = None,
        composer_package: Annotated[Optional[StrictStr], Field(description="Package")] = None,
        composer_version: Annotated[Optional[StrictStr], Field(description="Version")] = None,
        conan_base_version: Annotated[Optional[StrictStr], Field(description="Conan base version")] = None,
        conan_channel: Annotated[Optional[StrictStr], Field(description="Conan channel")] = None,
        conan_revision: Annotated[Optional[StrictStr], Field(description="Conan recipe revision")] = None,
        conan_package_id: Annotated[Optional[StrictStr], Field(description="Conan package id")] = None,
        conan_package_revision: Annotated[Optional[StrictStr], Field(description="Conan package revision")] = None,
        docker_image_name: Annotated[Optional[StrictStr], Field(description="Docker image name")] = None,
        docker_image_tag: Annotated[Optional[StrictStr], Field(description="Docker image tag")] = None,
        docker_layer_id: Annotated[Optional[StrictStr], Field(description="Docker layer ID")] = None,
        docker_content_digest: Annotated[Optional[StrictStr], Field(description="Docker content digest")] = None,
        maven_group_id: Annotated[Optional[StrictStr], Field(description="Maven groupId")] = None,
        maven_artifact_id: Annotated[Optional[StrictStr], Field(description="Maven artifactId")] = None,
        maven_base_version: Annotated[Optional[StrictStr], Field(description="Maven base version")] = None,
        maven_extension: Annotated[Optional[StrictStr], Field(description="Maven extension of component's asset")] = None,
        maven_classifier: Annotated[Optional[StrictStr], Field(description="Maven classifier of component's asset")] = None,
        gavec: Annotated[Optional[StrictStr], Field(description="Group asset version extension classifier")] = None,
        npm_scope: Annotated[Optional[StrictStr], Field(description="npm scope")] = None,
        npm_author: Annotated[Optional[StrictStr], Field(description="npm author")] = None,
        npm_description: Annotated[Optional[StrictStr], Field(description="npm description")] = None,
        npm_keywords: Annotated[Optional[StrictStr], Field(description="npm keywords")] = None,
        npm_license: Annotated[Optional[StrictStr], Field(description="npm license")] = None,
        npm_tagged_is: Annotated[Optional[StrictStr], Field(description="npm tagged is")] = None,
        npm_tagged_not: Annotated[Optional[StrictStr], Field(description="npm tagged not")] = None,
        nuget_id: Annotated[Optional[StrictStr], Field(description="NuGet id")] = None,
        nuget_tags: Annotated[Optional[StrictStr], Field(description="NuGet tags")] = None,
        nuget_title: Annotated[Optional[StrictStr], Field(description="NuGet title")] = None,
        nuget_authors: Annotated[Optional[StrictStr], Field(description="NuGet authors")] = None,
        nuget_description: Annotated[Optional[StrictStr], Field(description="NuGet description")] = None,
        nuget_summary: Annotated[Optional[StrictStr], Field(description="NuGet summary")] = None,
        nuget_is_prerelease: Annotated[Optional[StrictStr], Field(description="NuGet prerelease")] = None,
        p2_plugin_name: Annotated[Optional[StrictStr], Field(description="p2 plugin name")] = None,
        pypi_classifiers: Annotated[Optional[StrictStr], Field(description="PyPI classifiers")] = None,
        pypi_description: Annotated[Optional[StrictStr], Field(description="PyPI description")] = None,
        pypi_keywords: Annotated[Optional[StrictStr], Field(description="PyPI keywords")] = None,
        pypi_summary: Annotated[Optional[StrictStr], Field(description="PyPI summary")] = None,
        rubygems_description: Annotated[Optional[StrictStr], Field(description="RubyGems description")] = None,
        rubygems_platform: Annotated[Optional[StrictStr], Field(description="RubyGems platform")] = None,
        rubygems_summary: Annotated[Optional[StrictStr], Field(description="RubyGems summary")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Component tag")] = None,
        terraform_provider: Annotated[Optional[StrictStr], Field(description="terraform provider")] = None,
        terraform_namespace: Annotated[Optional[StrictStr], Field(description="terraform namespace")] = None,
        terraform_name: Annotated[Optional[StrictStr], Field(description="terraform name")] = None,
        yum_architecture: Annotated[Optional[StrictStr], Field(description="Yum architecture")] = None,
        yum_name: Annotated[Optional[StrictStr], Field(description="Yum package name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Associate components with a tag


        :param tag_name: Tag to associate to the matched components (required)
        :type tag_name: str
        :param wait: The query waits until the indexing is complete
        :type wait: bool
        :param q: Query by keyword
        :type q: str
        :param repository: Repository name
        :type repository: str
        :param format: Query by format
        :type format: str
        :param group: Component group
        :type group: str
        :param name: Component name
        :type name: str
        :param version: Component version
        :type version: str
        :param prerelease: Prerelease version flag
        :type prerelease: str
        :param last_updated: Asset last modified time
        :type last_updated: str
        :param last_blob_updated: Asset last modified time (UI)
        :type last_blob_updated: str
        :param md5: Specific MD5 hash of component's asset
        :type md5: str
        :param sha1: Specific SHA-1 hash of component's asset
        :type sha1: str
        :param sha256: Specific SHA-256 hash of component's asset
        :type sha256: str
        :param sha512: Specific SHA-512 hash of component's asset
        :type sha512: str
        :param composer_vendor: Vendor
        :type composer_vendor: str
        :param composer_package: Package
        :type composer_package: str
        :param composer_version: Version
        :type composer_version: str
        :param conan_base_version: Conan base version
        :type conan_base_version: str
        :param conan_channel: Conan channel
        :type conan_channel: str
        :param conan_revision: Conan recipe revision
        :type conan_revision: str
        :param conan_package_id: Conan package id
        :type conan_package_id: str
        :param conan_package_revision: Conan package revision
        :type conan_package_revision: str
        :param docker_image_name: Docker image name
        :type docker_image_name: str
        :param docker_image_tag: Docker image tag
        :type docker_image_tag: str
        :param docker_layer_id: Docker layer ID
        :type docker_layer_id: str
        :param docker_content_digest: Docker content digest
        :type docker_content_digest: str
        :param maven_group_id: Maven groupId
        :type maven_group_id: str
        :param maven_artifact_id: Maven artifactId
        :type maven_artifact_id: str
        :param maven_base_version: Maven base version
        :type maven_base_version: str
        :param maven_extension: Maven extension of component's asset
        :type maven_extension: str
        :param maven_classifier: Maven classifier of component's asset
        :type maven_classifier: str
        :param gavec: Group asset version extension classifier
        :type gavec: str
        :param npm_scope: npm scope
        :type npm_scope: str
        :param npm_author: npm author
        :type npm_author: str
        :param npm_description: npm description
        :type npm_description: str
        :param npm_keywords: npm keywords
        :type npm_keywords: str
        :param npm_license: npm license
        :type npm_license: str
        :param npm_tagged_is: npm tagged is
        :type npm_tagged_is: str
        :param npm_tagged_not: npm tagged not
        :type npm_tagged_not: str
        :param nuget_id: NuGet id
        :type nuget_id: str
        :param nuget_tags: NuGet tags
        :type nuget_tags: str
        :param nuget_title: NuGet title
        :type nuget_title: str
        :param nuget_authors: NuGet authors
        :type nuget_authors: str
        :param nuget_description: NuGet description
        :type nuget_description: str
        :param nuget_summary: NuGet summary
        :type nuget_summary: str
        :param nuget_is_prerelease: NuGet prerelease
        :type nuget_is_prerelease: str
        :param p2_plugin_name: p2 plugin name
        :type p2_plugin_name: str
        :param pypi_classifiers: PyPI classifiers
        :type pypi_classifiers: str
        :param pypi_description: PyPI description
        :type pypi_description: str
        :param pypi_keywords: PyPI keywords
        :type pypi_keywords: str
        :param pypi_summary: PyPI summary
        :type pypi_summary: str
        :param rubygems_description: RubyGems description
        :type rubygems_description: str
        :param rubygems_platform: RubyGems platform
        :type rubygems_platform: str
        :param rubygems_summary: RubyGems summary
        :type rubygems_summary: str
        :param tag: Component tag
        :type tag: str
        :param terraform_provider: terraform provider
        :type terraform_provider: str
        :param terraform_namespace: terraform namespace
        :type terraform_namespace: str
        :param terraform_name: terraform name
        :type terraform_name: str
        :param yum_architecture: Yum architecture
        :type yum_architecture: str
        :param yum_name: Yum package name
        :type yum_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_serialize(
            tag_name=tag_name,
            wait=wait,
            q=q,
            repository=repository,
            format=format,
            group=group,
            name=name,
            version=version,
            prerelease=prerelease,
            last_updated=last_updated,
            last_blob_updated=last_blob_updated,
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            sha512=sha512,
            composer_vendor=composer_vendor,
            composer_package=composer_package,
            composer_version=composer_version,
            conan_base_version=conan_base_version,
            conan_channel=conan_channel,
            conan_revision=conan_revision,
            conan_package_id=conan_package_id,
            conan_package_revision=conan_package_revision,
            docker_image_name=docker_image_name,
            docker_image_tag=docker_image_tag,
            docker_layer_id=docker_layer_id,
            docker_content_digest=docker_content_digest,
            maven_group_id=maven_group_id,
            maven_artifact_id=maven_artifact_id,
            maven_base_version=maven_base_version,
            maven_extension=maven_extension,
            maven_classifier=maven_classifier,
            gavec=gavec,
            npm_scope=npm_scope,
            npm_author=npm_author,
            npm_description=npm_description,
            npm_keywords=npm_keywords,
            npm_license=npm_license,
            npm_tagged_is=npm_tagged_is,
            npm_tagged_not=npm_tagged_not,
            nuget_id=nuget_id,
            nuget_tags=nuget_tags,
            nuget_title=nuget_title,
            nuget_authors=nuget_authors,
            nuget_description=nuget_description,
            nuget_summary=nuget_summary,
            nuget_is_prerelease=nuget_is_prerelease,
            p2_plugin_name=p2_plugin_name,
            pypi_classifiers=pypi_classifiers,
            pypi_description=pypi_description,
            pypi_keywords=pypi_keywords,
            pypi_summary=pypi_summary,
            rubygems_description=rubygems_description,
            rubygems_platform=rubygems_platform,
            rubygems_summary=rubygems_summary,
            tag=tag,
            terraform_provider=terraform_provider,
            terraform_namespace=terraform_namespace,
            terraform_name=terraform_name,
            yum_architecture=yum_architecture,
            yum_name=yum_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _associate_serialize(
        self,
        tag_name,
        wait,
        q,
        repository,
        format,
        group,
        name,
        version,
        prerelease,
        last_updated,
        last_blob_updated,
        md5,
        sha1,
        sha256,
        sha512,
        composer_vendor,
        composer_package,
        composer_version,
        conan_base_version,
        conan_channel,
        conan_revision,
        conan_package_id,
        conan_package_revision,
        docker_image_name,
        docker_image_tag,
        docker_layer_id,
        docker_content_digest,
        maven_group_id,
        maven_artifact_id,
        maven_base_version,
        maven_extension,
        maven_classifier,
        gavec,
        npm_scope,
        npm_author,
        npm_description,
        npm_keywords,
        npm_license,
        npm_tagged_is,
        npm_tagged_not,
        nuget_id,
        nuget_tags,
        nuget_title,
        nuget_authors,
        nuget_description,
        nuget_summary,
        nuget_is_prerelease,
        p2_plugin_name,
        pypi_classifiers,
        pypi_description,
        pypi_keywords,
        pypi_summary,
        rubygems_description,
        rubygems_platform,
        rubygems_summary,
        tag,
        terraform_provider,
        terraform_namespace,
        terraform_name,
        yum_architecture,
        yum_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tag_name is not None:
            _path_params['tagName'] = tag_name
        # process the query parameters
        if wait is not None:
            
            _query_params.append(('wait', wait))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if repository is not None:
            
            _query_params.append(('repository', repository))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        if group is not None:
            
            _query_params.append(('group', group))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if version is not None:
            
            _query_params.append(('version', version))
            
        if prerelease is not None:
            
            _query_params.append(('prerelease', prerelease))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if last_blob_updated is not None:
            
            _query_params.append(('lastBlobUpdated', last_blob_updated))
            
        if md5 is not None:
            
            _query_params.append(('md5', md5))
            
        if sha1 is not None:
            
            _query_params.append(('sha1', sha1))
            
        if sha256 is not None:
            
            _query_params.append(('sha256', sha256))
            
        if sha512 is not None:
            
            _query_params.append(('sha512', sha512))
            
        if composer_vendor is not None:
            
            _query_params.append(('composer.vendor', composer_vendor))
            
        if composer_package is not None:
            
            _query_params.append(('composer.package', composer_package))
            
        if composer_version is not None:
            
            _query_params.append(('composer.version', composer_version))
            
        if conan_base_version is not None:
            
            _query_params.append(('conan.baseVersion', conan_base_version))
            
        if conan_channel is not None:
            
            _query_params.append(('conan.channel', conan_channel))
            
        if conan_revision is not None:
            
            _query_params.append(('conan.revision', conan_revision))
            
        if conan_package_id is not None:
            
            _query_params.append(('conan.packageId', conan_package_id))
            
        if conan_package_revision is not None:
            
            _query_params.append(('conan.packageRevision', conan_package_revision))
            
        if docker_image_name is not None:
            
            _query_params.append(('docker.imageName', docker_image_name))
            
        if docker_image_tag is not None:
            
            _query_params.append(('docker.imageTag', docker_image_tag))
            
        if docker_layer_id is not None:
            
            _query_params.append(('docker.layerId', docker_layer_id))
            
        if docker_content_digest is not None:
            
            _query_params.append(('docker.contentDigest', docker_content_digest))
            
        if maven_group_id is not None:
            
            _query_params.append(('maven.groupId', maven_group_id))
            
        if maven_artifact_id is not None:
            
            _query_params.append(('maven.artifactId', maven_artifact_id))
            
        if maven_base_version is not None:
            
            _query_params.append(('maven.baseVersion', maven_base_version))
            
        if maven_extension is not None:
            
            _query_params.append(('maven.extension', maven_extension))
            
        if maven_classifier is not None:
            
            _query_params.append(('maven.classifier', maven_classifier))
            
        if gavec is not None:
            
            _query_params.append(('gavec', gavec))
            
        if npm_scope is not None:
            
            _query_params.append(('npm.scope', npm_scope))
            
        if npm_author is not None:
            
            _query_params.append(('npm.author', npm_author))
            
        if npm_description is not None:
            
            _query_params.append(('npm.description', npm_description))
            
        if npm_keywords is not None:
            
            _query_params.append(('npm.keywords', npm_keywords))
            
        if npm_license is not None:
            
            _query_params.append(('npm.license', npm_license))
            
        if npm_tagged_is is not None:
            
            _query_params.append(('npm.tagged_is', npm_tagged_is))
            
        if npm_tagged_not is not None:
            
            _query_params.append(('npm.tagged_not', npm_tagged_not))
            
        if nuget_id is not None:
            
            _query_params.append(('nuget.id', nuget_id))
            
        if nuget_tags is not None:
            
            _query_params.append(('nuget.tags', nuget_tags))
            
        if nuget_title is not None:
            
            _query_params.append(('nuget.title', nuget_title))
            
        if nuget_authors is not None:
            
            _query_params.append(('nuget.authors', nuget_authors))
            
        if nuget_description is not None:
            
            _query_params.append(('nuget.description', nuget_description))
            
        if nuget_summary is not None:
            
            _query_params.append(('nuget.summary', nuget_summary))
            
        if nuget_is_prerelease is not None:
            
            _query_params.append(('nuget.is_prerelease', nuget_is_prerelease))
            
        if p2_plugin_name is not None:
            
            _query_params.append(('p2.pluginName', p2_plugin_name))
            
        if pypi_classifiers is not None:
            
            _query_params.append(('pypi.classifiers', pypi_classifiers))
            
        if pypi_description is not None:
            
            _query_params.append(('pypi.description', pypi_description))
            
        if pypi_keywords is not None:
            
            _query_params.append(('pypi.keywords', pypi_keywords))
            
        if pypi_summary is not None:
            
            _query_params.append(('pypi.summary', pypi_summary))
            
        if rubygems_description is not None:
            
            _query_params.append(('rubygems.description', rubygems_description))
            
        if rubygems_platform is not None:
            
            _query_params.append(('rubygems.platform', rubygems_platform))
            
        if rubygems_summary is not None:
            
            _query_params.append(('rubygems.summary', rubygems_summary))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if terraform_provider is not None:
            
            _query_params.append(('terraform.provider', terraform_provider))
            
        if terraform_namespace is not None:
            
            _query_params.append(('terraform.namespace', terraform_namespace))
            
        if terraform_name is not None:
            
            _query_params.append(('terraform.name', terraform_name))
            
        if yum_architecture is not None:
            
            _query_params.append(('yum.architecture', yum_architecture))
            
        if yum_name is not None:
            
            _query_params.append(('yum.name', yum_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/tags/associate/{tagName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create2(
        self,
        body: Optional[TagXO] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create a tag


        :param body:
        :type body: TagXO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create2_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create2_with_http_info(
        self,
        body: Optional[TagXO] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create a tag


        :param body:
        :type body: TagXO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create2_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create2_without_preload_content(
        self,
        body: Optional[TagXO] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a tag


        :param body:
        :type body: TagXO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create2_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create2_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete3(
        self,
        name: Annotated[StrictStr, Field(description="Name of the tag to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a tag


        :param name: Name of the tag to delete (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete3_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete3_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the tag to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a tag


        :param name: Name of the tag to delete (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete3_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete3_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the tag to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a tag


        :param name: Name of the tag to delete (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete3_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete3_serialize(
        self,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/tags/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def disassociate(
        self,
        tag_name: Annotated[StrictStr, Field(description="Tag to associate to the matched components")],
        wait: Annotated[Optional[StrictBool], Field(description="The query waits until the indexing is complete")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query by keyword")] = None,
        repository: Annotated[Optional[StrictStr], Field(description="Repository name")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Query by format")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Component group")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Component name")] = None,
        version: Annotated[Optional[StrictStr], Field(description="Component version")] = None,
        prerelease: Annotated[Optional[StrictStr], Field(description="Prerelease version flag")] = None,
        last_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time")] = None,
        last_blob_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time (UI)")] = None,
        md5: Annotated[Optional[StrictStr], Field(description="Specific MD5 hash of component's asset")] = None,
        sha1: Annotated[Optional[StrictStr], Field(description="Specific SHA-1 hash of component's asset")] = None,
        sha256: Annotated[Optional[StrictStr], Field(description="Specific SHA-256 hash of component's asset")] = None,
        sha512: Annotated[Optional[StrictStr], Field(description="Specific SHA-512 hash of component's asset")] = None,
        composer_vendor: Annotated[Optional[StrictStr], Field(description="Vendor")] = None,
        composer_package: Annotated[Optional[StrictStr], Field(description="Package")] = None,
        composer_version: Annotated[Optional[StrictStr], Field(description="Version")] = None,
        conan_base_version: Annotated[Optional[StrictStr], Field(description="Conan base version")] = None,
        conan_channel: Annotated[Optional[StrictStr], Field(description="Conan channel")] = None,
        conan_revision: Annotated[Optional[StrictStr], Field(description="Conan recipe revision")] = None,
        conan_package_id: Annotated[Optional[StrictStr], Field(description="Conan package id")] = None,
        conan_package_revision: Annotated[Optional[StrictStr], Field(description="Conan package revision")] = None,
        docker_image_name: Annotated[Optional[StrictStr], Field(description="Docker image name")] = None,
        docker_image_tag: Annotated[Optional[StrictStr], Field(description="Docker image tag")] = None,
        docker_layer_id: Annotated[Optional[StrictStr], Field(description="Docker layer ID")] = None,
        docker_content_digest: Annotated[Optional[StrictStr], Field(description="Docker content digest")] = None,
        maven_group_id: Annotated[Optional[StrictStr], Field(description="Maven groupId")] = None,
        maven_artifact_id: Annotated[Optional[StrictStr], Field(description="Maven artifactId")] = None,
        maven_base_version: Annotated[Optional[StrictStr], Field(description="Maven base version")] = None,
        maven_extension: Annotated[Optional[StrictStr], Field(description="Maven extension of component's asset")] = None,
        maven_classifier: Annotated[Optional[StrictStr], Field(description="Maven classifier of component's asset")] = None,
        gavec: Annotated[Optional[StrictStr], Field(description="Group asset version extension classifier")] = None,
        npm_scope: Annotated[Optional[StrictStr], Field(description="npm scope")] = None,
        npm_author: Annotated[Optional[StrictStr], Field(description="npm author")] = None,
        npm_description: Annotated[Optional[StrictStr], Field(description="npm description")] = None,
        npm_keywords: Annotated[Optional[StrictStr], Field(description="npm keywords")] = None,
        npm_license: Annotated[Optional[StrictStr], Field(description="npm license")] = None,
        npm_tagged_is: Annotated[Optional[StrictStr], Field(description="npm tagged is")] = None,
        npm_tagged_not: Annotated[Optional[StrictStr], Field(description="npm tagged not")] = None,
        nuget_id: Annotated[Optional[StrictStr], Field(description="NuGet id")] = None,
        nuget_tags: Annotated[Optional[StrictStr], Field(description="NuGet tags")] = None,
        nuget_title: Annotated[Optional[StrictStr], Field(description="NuGet title")] = None,
        nuget_authors: Annotated[Optional[StrictStr], Field(description="NuGet authors")] = None,
        nuget_description: Annotated[Optional[StrictStr], Field(description="NuGet description")] = None,
        nuget_summary: Annotated[Optional[StrictStr], Field(description="NuGet summary")] = None,
        nuget_is_prerelease: Annotated[Optional[StrictStr], Field(description="NuGet prerelease")] = None,
        p2_plugin_name: Annotated[Optional[StrictStr], Field(description="p2 plugin name")] = None,
        pypi_classifiers: Annotated[Optional[StrictStr], Field(description="PyPI classifiers")] = None,
        pypi_description: Annotated[Optional[StrictStr], Field(description="PyPI description")] = None,
        pypi_keywords: Annotated[Optional[StrictStr], Field(description="PyPI keywords")] = None,
        pypi_summary: Annotated[Optional[StrictStr], Field(description="PyPI summary")] = None,
        rubygems_description: Annotated[Optional[StrictStr], Field(description="RubyGems description")] = None,
        rubygems_platform: Annotated[Optional[StrictStr], Field(description="RubyGems platform")] = None,
        rubygems_summary: Annotated[Optional[StrictStr], Field(description="RubyGems summary")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Component tag")] = None,
        terraform_provider: Annotated[Optional[StrictStr], Field(description="terraform provider")] = None,
        terraform_namespace: Annotated[Optional[StrictStr], Field(description="terraform namespace")] = None,
        terraform_name: Annotated[Optional[StrictStr], Field(description="terraform name")] = None,
        yum_architecture: Annotated[Optional[StrictStr], Field(description="Yum architecture")] = None,
        yum_name: Annotated[Optional[StrictStr], Field(description="Yum package name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Disassociate components from a tag


        :param tag_name: Tag to associate to the matched components (required)
        :type tag_name: str
        :param wait: The query waits until the indexing is complete
        :type wait: bool
        :param q: Query by keyword
        :type q: str
        :param repository: Repository name
        :type repository: str
        :param format: Query by format
        :type format: str
        :param group: Component group
        :type group: str
        :param name: Component name
        :type name: str
        :param version: Component version
        :type version: str
        :param prerelease: Prerelease version flag
        :type prerelease: str
        :param last_updated: Asset last modified time
        :type last_updated: str
        :param last_blob_updated: Asset last modified time (UI)
        :type last_blob_updated: str
        :param md5: Specific MD5 hash of component's asset
        :type md5: str
        :param sha1: Specific SHA-1 hash of component's asset
        :type sha1: str
        :param sha256: Specific SHA-256 hash of component's asset
        :type sha256: str
        :param sha512: Specific SHA-512 hash of component's asset
        :type sha512: str
        :param composer_vendor: Vendor
        :type composer_vendor: str
        :param composer_package: Package
        :type composer_package: str
        :param composer_version: Version
        :type composer_version: str
        :param conan_base_version: Conan base version
        :type conan_base_version: str
        :param conan_channel: Conan channel
        :type conan_channel: str
        :param conan_revision: Conan recipe revision
        :type conan_revision: str
        :param conan_package_id: Conan package id
        :type conan_package_id: str
        :param conan_package_revision: Conan package revision
        :type conan_package_revision: str
        :param docker_image_name: Docker image name
        :type docker_image_name: str
        :param docker_image_tag: Docker image tag
        :type docker_image_tag: str
        :param docker_layer_id: Docker layer ID
        :type docker_layer_id: str
        :param docker_content_digest: Docker content digest
        :type docker_content_digest: str
        :param maven_group_id: Maven groupId
        :type maven_group_id: str
        :param maven_artifact_id: Maven artifactId
        :type maven_artifact_id: str
        :param maven_base_version: Maven base version
        :type maven_base_version: str
        :param maven_extension: Maven extension of component's asset
        :type maven_extension: str
        :param maven_classifier: Maven classifier of component's asset
        :type maven_classifier: str
        :param gavec: Group asset version extension classifier
        :type gavec: str
        :param npm_scope: npm scope
        :type npm_scope: str
        :param npm_author: npm author
        :type npm_author: str
        :param npm_description: npm description
        :type npm_description: str
        :param npm_keywords: npm keywords
        :type npm_keywords: str
        :param npm_license: npm license
        :type npm_license: str
        :param npm_tagged_is: npm tagged is
        :type npm_tagged_is: str
        :param npm_tagged_not: npm tagged not
        :type npm_tagged_not: str
        :param nuget_id: NuGet id
        :type nuget_id: str
        :param nuget_tags: NuGet tags
        :type nuget_tags: str
        :param nuget_title: NuGet title
        :type nuget_title: str
        :param nuget_authors: NuGet authors
        :type nuget_authors: str
        :param nuget_description: NuGet description
        :type nuget_description: str
        :param nuget_summary: NuGet summary
        :type nuget_summary: str
        :param nuget_is_prerelease: NuGet prerelease
        :type nuget_is_prerelease: str
        :param p2_plugin_name: p2 plugin name
        :type p2_plugin_name: str
        :param pypi_classifiers: PyPI classifiers
        :type pypi_classifiers: str
        :param pypi_description: PyPI description
        :type pypi_description: str
        :param pypi_keywords: PyPI keywords
        :type pypi_keywords: str
        :param pypi_summary: PyPI summary
        :type pypi_summary: str
        :param rubygems_description: RubyGems description
        :type rubygems_description: str
        :param rubygems_platform: RubyGems platform
        :type rubygems_platform: str
        :param rubygems_summary: RubyGems summary
        :type rubygems_summary: str
        :param tag: Component tag
        :type tag: str
        :param terraform_provider: terraform provider
        :type terraform_provider: str
        :param terraform_namespace: terraform namespace
        :type terraform_namespace: str
        :param terraform_name: terraform name
        :type terraform_name: str
        :param yum_architecture: Yum architecture
        :type yum_architecture: str
        :param yum_name: Yum package name
        :type yum_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._disassociate_serialize(
            tag_name=tag_name,
            wait=wait,
            q=q,
            repository=repository,
            format=format,
            group=group,
            name=name,
            version=version,
            prerelease=prerelease,
            last_updated=last_updated,
            last_blob_updated=last_blob_updated,
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            sha512=sha512,
            composer_vendor=composer_vendor,
            composer_package=composer_package,
            composer_version=composer_version,
            conan_base_version=conan_base_version,
            conan_channel=conan_channel,
            conan_revision=conan_revision,
            conan_package_id=conan_package_id,
            conan_package_revision=conan_package_revision,
            docker_image_name=docker_image_name,
            docker_image_tag=docker_image_tag,
            docker_layer_id=docker_layer_id,
            docker_content_digest=docker_content_digest,
            maven_group_id=maven_group_id,
            maven_artifact_id=maven_artifact_id,
            maven_base_version=maven_base_version,
            maven_extension=maven_extension,
            maven_classifier=maven_classifier,
            gavec=gavec,
            npm_scope=npm_scope,
            npm_author=npm_author,
            npm_description=npm_description,
            npm_keywords=npm_keywords,
            npm_license=npm_license,
            npm_tagged_is=npm_tagged_is,
            npm_tagged_not=npm_tagged_not,
            nuget_id=nuget_id,
            nuget_tags=nuget_tags,
            nuget_title=nuget_title,
            nuget_authors=nuget_authors,
            nuget_description=nuget_description,
            nuget_summary=nuget_summary,
            nuget_is_prerelease=nuget_is_prerelease,
            p2_plugin_name=p2_plugin_name,
            pypi_classifiers=pypi_classifiers,
            pypi_description=pypi_description,
            pypi_keywords=pypi_keywords,
            pypi_summary=pypi_summary,
            rubygems_description=rubygems_description,
            rubygems_platform=rubygems_platform,
            rubygems_summary=rubygems_summary,
            tag=tag,
            terraform_provider=terraform_provider,
            terraform_namespace=terraform_namespace,
            terraform_name=terraform_name,
            yum_architecture=yum_architecture,
            yum_name=yum_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def disassociate_with_http_info(
        self,
        tag_name: Annotated[StrictStr, Field(description="Tag to associate to the matched components")],
        wait: Annotated[Optional[StrictBool], Field(description="The query waits until the indexing is complete")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query by keyword")] = None,
        repository: Annotated[Optional[StrictStr], Field(description="Repository name")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Query by format")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Component group")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Component name")] = None,
        version: Annotated[Optional[StrictStr], Field(description="Component version")] = None,
        prerelease: Annotated[Optional[StrictStr], Field(description="Prerelease version flag")] = None,
        last_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time")] = None,
        last_blob_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time (UI)")] = None,
        md5: Annotated[Optional[StrictStr], Field(description="Specific MD5 hash of component's asset")] = None,
        sha1: Annotated[Optional[StrictStr], Field(description="Specific SHA-1 hash of component's asset")] = None,
        sha256: Annotated[Optional[StrictStr], Field(description="Specific SHA-256 hash of component's asset")] = None,
        sha512: Annotated[Optional[StrictStr], Field(description="Specific SHA-512 hash of component's asset")] = None,
        composer_vendor: Annotated[Optional[StrictStr], Field(description="Vendor")] = None,
        composer_package: Annotated[Optional[StrictStr], Field(description="Package")] = None,
        composer_version: Annotated[Optional[StrictStr], Field(description="Version")] = None,
        conan_base_version: Annotated[Optional[StrictStr], Field(description="Conan base version")] = None,
        conan_channel: Annotated[Optional[StrictStr], Field(description="Conan channel")] = None,
        conan_revision: Annotated[Optional[StrictStr], Field(description="Conan recipe revision")] = None,
        conan_package_id: Annotated[Optional[StrictStr], Field(description="Conan package id")] = None,
        conan_package_revision: Annotated[Optional[StrictStr], Field(description="Conan package revision")] = None,
        docker_image_name: Annotated[Optional[StrictStr], Field(description="Docker image name")] = None,
        docker_image_tag: Annotated[Optional[StrictStr], Field(description="Docker image tag")] = None,
        docker_layer_id: Annotated[Optional[StrictStr], Field(description="Docker layer ID")] = None,
        docker_content_digest: Annotated[Optional[StrictStr], Field(description="Docker content digest")] = None,
        maven_group_id: Annotated[Optional[StrictStr], Field(description="Maven groupId")] = None,
        maven_artifact_id: Annotated[Optional[StrictStr], Field(description="Maven artifactId")] = None,
        maven_base_version: Annotated[Optional[StrictStr], Field(description="Maven base version")] = None,
        maven_extension: Annotated[Optional[StrictStr], Field(description="Maven extension of component's asset")] = None,
        maven_classifier: Annotated[Optional[StrictStr], Field(description="Maven classifier of component's asset")] = None,
        gavec: Annotated[Optional[StrictStr], Field(description="Group asset version extension classifier")] = None,
        npm_scope: Annotated[Optional[StrictStr], Field(description="npm scope")] = None,
        npm_author: Annotated[Optional[StrictStr], Field(description="npm author")] = None,
        npm_description: Annotated[Optional[StrictStr], Field(description="npm description")] = None,
        npm_keywords: Annotated[Optional[StrictStr], Field(description="npm keywords")] = None,
        npm_license: Annotated[Optional[StrictStr], Field(description="npm license")] = None,
        npm_tagged_is: Annotated[Optional[StrictStr], Field(description="npm tagged is")] = None,
        npm_tagged_not: Annotated[Optional[StrictStr], Field(description="npm tagged not")] = None,
        nuget_id: Annotated[Optional[StrictStr], Field(description="NuGet id")] = None,
        nuget_tags: Annotated[Optional[StrictStr], Field(description="NuGet tags")] = None,
        nuget_title: Annotated[Optional[StrictStr], Field(description="NuGet title")] = None,
        nuget_authors: Annotated[Optional[StrictStr], Field(description="NuGet authors")] = None,
        nuget_description: Annotated[Optional[StrictStr], Field(description="NuGet description")] = None,
        nuget_summary: Annotated[Optional[StrictStr], Field(description="NuGet summary")] = None,
        nuget_is_prerelease: Annotated[Optional[StrictStr], Field(description="NuGet prerelease")] = None,
        p2_plugin_name: Annotated[Optional[StrictStr], Field(description="p2 plugin name")] = None,
        pypi_classifiers: Annotated[Optional[StrictStr], Field(description="PyPI classifiers")] = None,
        pypi_description: Annotated[Optional[StrictStr], Field(description="PyPI description")] = None,
        pypi_keywords: Annotated[Optional[StrictStr], Field(description="PyPI keywords")] = None,
        pypi_summary: Annotated[Optional[StrictStr], Field(description="PyPI summary")] = None,
        rubygems_description: Annotated[Optional[StrictStr], Field(description="RubyGems description")] = None,
        rubygems_platform: Annotated[Optional[StrictStr], Field(description="RubyGems platform")] = None,
        rubygems_summary: Annotated[Optional[StrictStr], Field(description="RubyGems summary")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Component tag")] = None,
        terraform_provider: Annotated[Optional[StrictStr], Field(description="terraform provider")] = None,
        terraform_namespace: Annotated[Optional[StrictStr], Field(description="terraform namespace")] = None,
        terraform_name: Annotated[Optional[StrictStr], Field(description="terraform name")] = None,
        yum_architecture: Annotated[Optional[StrictStr], Field(description="Yum architecture")] = None,
        yum_name: Annotated[Optional[StrictStr], Field(description="Yum package name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Disassociate components from a tag


        :param tag_name: Tag to associate to the matched components (required)
        :type tag_name: str
        :param wait: The query waits until the indexing is complete
        :type wait: bool
        :param q: Query by keyword
        :type q: str
        :param repository: Repository name
        :type repository: str
        :param format: Query by format
        :type format: str
        :param group: Component group
        :type group: str
        :param name: Component name
        :type name: str
        :param version: Component version
        :type version: str
        :param prerelease: Prerelease version flag
        :type prerelease: str
        :param last_updated: Asset last modified time
        :type last_updated: str
        :param last_blob_updated: Asset last modified time (UI)
        :type last_blob_updated: str
        :param md5: Specific MD5 hash of component's asset
        :type md5: str
        :param sha1: Specific SHA-1 hash of component's asset
        :type sha1: str
        :param sha256: Specific SHA-256 hash of component's asset
        :type sha256: str
        :param sha512: Specific SHA-512 hash of component's asset
        :type sha512: str
        :param composer_vendor: Vendor
        :type composer_vendor: str
        :param composer_package: Package
        :type composer_package: str
        :param composer_version: Version
        :type composer_version: str
        :param conan_base_version: Conan base version
        :type conan_base_version: str
        :param conan_channel: Conan channel
        :type conan_channel: str
        :param conan_revision: Conan recipe revision
        :type conan_revision: str
        :param conan_package_id: Conan package id
        :type conan_package_id: str
        :param conan_package_revision: Conan package revision
        :type conan_package_revision: str
        :param docker_image_name: Docker image name
        :type docker_image_name: str
        :param docker_image_tag: Docker image tag
        :type docker_image_tag: str
        :param docker_layer_id: Docker layer ID
        :type docker_layer_id: str
        :param docker_content_digest: Docker content digest
        :type docker_content_digest: str
        :param maven_group_id: Maven groupId
        :type maven_group_id: str
        :param maven_artifact_id: Maven artifactId
        :type maven_artifact_id: str
        :param maven_base_version: Maven base version
        :type maven_base_version: str
        :param maven_extension: Maven extension of component's asset
        :type maven_extension: str
        :param maven_classifier: Maven classifier of component's asset
        :type maven_classifier: str
        :param gavec: Group asset version extension classifier
        :type gavec: str
        :param npm_scope: npm scope
        :type npm_scope: str
        :param npm_author: npm author
        :type npm_author: str
        :param npm_description: npm description
        :type npm_description: str
        :param npm_keywords: npm keywords
        :type npm_keywords: str
        :param npm_license: npm license
        :type npm_license: str
        :param npm_tagged_is: npm tagged is
        :type npm_tagged_is: str
        :param npm_tagged_not: npm tagged not
        :type npm_tagged_not: str
        :param nuget_id: NuGet id
        :type nuget_id: str
        :param nuget_tags: NuGet tags
        :type nuget_tags: str
        :param nuget_title: NuGet title
        :type nuget_title: str
        :param nuget_authors: NuGet authors
        :type nuget_authors: str
        :param nuget_description: NuGet description
        :type nuget_description: str
        :param nuget_summary: NuGet summary
        :type nuget_summary: str
        :param nuget_is_prerelease: NuGet prerelease
        :type nuget_is_prerelease: str
        :param p2_plugin_name: p2 plugin name
        :type p2_plugin_name: str
        :param pypi_classifiers: PyPI classifiers
        :type pypi_classifiers: str
        :param pypi_description: PyPI description
        :type pypi_description: str
        :param pypi_keywords: PyPI keywords
        :type pypi_keywords: str
        :param pypi_summary: PyPI summary
        :type pypi_summary: str
        :param rubygems_description: RubyGems description
        :type rubygems_description: str
        :param rubygems_platform: RubyGems platform
        :type rubygems_platform: str
        :param rubygems_summary: RubyGems summary
        :type rubygems_summary: str
        :param tag: Component tag
        :type tag: str
        :param terraform_provider: terraform provider
        :type terraform_provider: str
        :param terraform_namespace: terraform namespace
        :type terraform_namespace: str
        :param terraform_name: terraform name
        :type terraform_name: str
        :param yum_architecture: Yum architecture
        :type yum_architecture: str
        :param yum_name: Yum package name
        :type yum_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._disassociate_serialize(
            tag_name=tag_name,
            wait=wait,
            q=q,
            repository=repository,
            format=format,
            group=group,
            name=name,
            version=version,
            prerelease=prerelease,
            last_updated=last_updated,
            last_blob_updated=last_blob_updated,
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            sha512=sha512,
            composer_vendor=composer_vendor,
            composer_package=composer_package,
            composer_version=composer_version,
            conan_base_version=conan_base_version,
            conan_channel=conan_channel,
            conan_revision=conan_revision,
            conan_package_id=conan_package_id,
            conan_package_revision=conan_package_revision,
            docker_image_name=docker_image_name,
            docker_image_tag=docker_image_tag,
            docker_layer_id=docker_layer_id,
            docker_content_digest=docker_content_digest,
            maven_group_id=maven_group_id,
            maven_artifact_id=maven_artifact_id,
            maven_base_version=maven_base_version,
            maven_extension=maven_extension,
            maven_classifier=maven_classifier,
            gavec=gavec,
            npm_scope=npm_scope,
            npm_author=npm_author,
            npm_description=npm_description,
            npm_keywords=npm_keywords,
            npm_license=npm_license,
            npm_tagged_is=npm_tagged_is,
            npm_tagged_not=npm_tagged_not,
            nuget_id=nuget_id,
            nuget_tags=nuget_tags,
            nuget_title=nuget_title,
            nuget_authors=nuget_authors,
            nuget_description=nuget_description,
            nuget_summary=nuget_summary,
            nuget_is_prerelease=nuget_is_prerelease,
            p2_plugin_name=p2_plugin_name,
            pypi_classifiers=pypi_classifiers,
            pypi_description=pypi_description,
            pypi_keywords=pypi_keywords,
            pypi_summary=pypi_summary,
            rubygems_description=rubygems_description,
            rubygems_platform=rubygems_platform,
            rubygems_summary=rubygems_summary,
            tag=tag,
            terraform_provider=terraform_provider,
            terraform_namespace=terraform_namespace,
            terraform_name=terraform_name,
            yum_architecture=yum_architecture,
            yum_name=yum_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def disassociate_without_preload_content(
        self,
        tag_name: Annotated[StrictStr, Field(description="Tag to associate to the matched components")],
        wait: Annotated[Optional[StrictBool], Field(description="The query waits until the indexing is complete")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query by keyword")] = None,
        repository: Annotated[Optional[StrictStr], Field(description="Repository name")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Query by format")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Component group")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Component name")] = None,
        version: Annotated[Optional[StrictStr], Field(description="Component version")] = None,
        prerelease: Annotated[Optional[StrictStr], Field(description="Prerelease version flag")] = None,
        last_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time")] = None,
        last_blob_updated: Annotated[Optional[StrictStr], Field(description="Asset last modified time (UI)")] = None,
        md5: Annotated[Optional[StrictStr], Field(description="Specific MD5 hash of component's asset")] = None,
        sha1: Annotated[Optional[StrictStr], Field(description="Specific SHA-1 hash of component's asset")] = None,
        sha256: Annotated[Optional[StrictStr], Field(description="Specific SHA-256 hash of component's asset")] = None,
        sha512: Annotated[Optional[StrictStr], Field(description="Specific SHA-512 hash of component's asset")] = None,
        composer_vendor: Annotated[Optional[StrictStr], Field(description="Vendor")] = None,
        composer_package: Annotated[Optional[StrictStr], Field(description="Package")] = None,
        composer_version: Annotated[Optional[StrictStr], Field(description="Version")] = None,
        conan_base_version: Annotated[Optional[StrictStr], Field(description="Conan base version")] = None,
        conan_channel: Annotated[Optional[StrictStr], Field(description="Conan channel")] = None,
        conan_revision: Annotated[Optional[StrictStr], Field(description="Conan recipe revision")] = None,
        conan_package_id: Annotated[Optional[StrictStr], Field(description="Conan package id")] = None,
        conan_package_revision: Annotated[Optional[StrictStr], Field(description="Conan package revision")] = None,
        docker_image_name: Annotated[Optional[StrictStr], Field(description="Docker image name")] = None,
        docker_image_tag: Annotated[Optional[StrictStr], Field(description="Docker image tag")] = None,
        docker_layer_id: Annotated[Optional[StrictStr], Field(description="Docker layer ID")] = None,
        docker_content_digest: Annotated[Optional[StrictStr], Field(description="Docker content digest")] = None,
        maven_group_id: Annotated[Optional[StrictStr], Field(description="Maven groupId")] = None,
        maven_artifact_id: Annotated[Optional[StrictStr], Field(description="Maven artifactId")] = None,
        maven_base_version: Annotated[Optional[StrictStr], Field(description="Maven base version")] = None,
        maven_extension: Annotated[Optional[StrictStr], Field(description="Maven extension of component's asset")] = None,
        maven_classifier: Annotated[Optional[StrictStr], Field(description="Maven classifier of component's asset")] = None,
        gavec: Annotated[Optional[StrictStr], Field(description="Group asset version extension classifier")] = None,
        npm_scope: Annotated[Optional[StrictStr], Field(description="npm scope")] = None,
        npm_author: Annotated[Optional[StrictStr], Field(description="npm author")] = None,
        npm_description: Annotated[Optional[StrictStr], Field(description="npm description")] = None,
        npm_keywords: Annotated[Optional[StrictStr], Field(description="npm keywords")] = None,
        npm_license: Annotated[Optional[StrictStr], Field(description="npm license")] = None,
        npm_tagged_is: Annotated[Optional[StrictStr], Field(description="npm tagged is")] = None,
        npm_tagged_not: Annotated[Optional[StrictStr], Field(description="npm tagged not")] = None,
        nuget_id: Annotated[Optional[StrictStr], Field(description="NuGet id")] = None,
        nuget_tags: Annotated[Optional[StrictStr], Field(description="NuGet tags")] = None,
        nuget_title: Annotated[Optional[StrictStr], Field(description="NuGet title")] = None,
        nuget_authors: Annotated[Optional[StrictStr], Field(description="NuGet authors")] = None,
        nuget_description: Annotated[Optional[StrictStr], Field(description="NuGet description")] = None,
        nuget_summary: Annotated[Optional[StrictStr], Field(description="NuGet summary")] = None,
        nuget_is_prerelease: Annotated[Optional[StrictStr], Field(description="NuGet prerelease")] = None,
        p2_plugin_name: Annotated[Optional[StrictStr], Field(description="p2 plugin name")] = None,
        pypi_classifiers: Annotated[Optional[StrictStr], Field(description="PyPI classifiers")] = None,
        pypi_description: Annotated[Optional[StrictStr], Field(description="PyPI description")] = None,
        pypi_keywords: Annotated[Optional[StrictStr], Field(description="PyPI keywords")] = None,
        pypi_summary: Annotated[Optional[StrictStr], Field(description="PyPI summary")] = None,
        rubygems_description: Annotated[Optional[StrictStr], Field(description="RubyGems description")] = None,
        rubygems_platform: Annotated[Optional[StrictStr], Field(description="RubyGems platform")] = None,
        rubygems_summary: Annotated[Optional[StrictStr], Field(description="RubyGems summary")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Component tag")] = None,
        terraform_provider: Annotated[Optional[StrictStr], Field(description="terraform provider")] = None,
        terraform_namespace: Annotated[Optional[StrictStr], Field(description="terraform namespace")] = None,
        terraform_name: Annotated[Optional[StrictStr], Field(description="terraform name")] = None,
        yum_architecture: Annotated[Optional[StrictStr], Field(description="Yum architecture")] = None,
        yum_name: Annotated[Optional[StrictStr], Field(description="Yum package name")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Disassociate components from a tag


        :param tag_name: Tag to associate to the matched components (required)
        :type tag_name: str
        :param wait: The query waits until the indexing is complete
        :type wait: bool
        :param q: Query by keyword
        :type q: str
        :param repository: Repository name
        :type repository: str
        :param format: Query by format
        :type format: str
        :param group: Component group
        :type group: str
        :param name: Component name
        :type name: str
        :param version: Component version
        :type version: str
        :param prerelease: Prerelease version flag
        :type prerelease: str
        :param last_updated: Asset last modified time
        :type last_updated: str
        :param last_blob_updated: Asset last modified time (UI)
        :type last_blob_updated: str
        :param md5: Specific MD5 hash of component's asset
        :type md5: str
        :param sha1: Specific SHA-1 hash of component's asset
        :type sha1: str
        :param sha256: Specific SHA-256 hash of component's asset
        :type sha256: str
        :param sha512: Specific SHA-512 hash of component's asset
        :type sha512: str
        :param composer_vendor: Vendor
        :type composer_vendor: str
        :param composer_package: Package
        :type composer_package: str
        :param composer_version: Version
        :type composer_version: str
        :param conan_base_version: Conan base version
        :type conan_base_version: str
        :param conan_channel: Conan channel
        :type conan_channel: str
        :param conan_revision: Conan recipe revision
        :type conan_revision: str
        :param conan_package_id: Conan package id
        :type conan_package_id: str
        :param conan_package_revision: Conan package revision
        :type conan_package_revision: str
        :param docker_image_name: Docker image name
        :type docker_image_name: str
        :param docker_image_tag: Docker image tag
        :type docker_image_tag: str
        :param docker_layer_id: Docker layer ID
        :type docker_layer_id: str
        :param docker_content_digest: Docker content digest
        :type docker_content_digest: str
        :param maven_group_id: Maven groupId
        :type maven_group_id: str
        :param maven_artifact_id: Maven artifactId
        :type maven_artifact_id: str
        :param maven_base_version: Maven base version
        :type maven_base_version: str
        :param maven_extension: Maven extension of component's asset
        :type maven_extension: str
        :param maven_classifier: Maven classifier of component's asset
        :type maven_classifier: str
        :param gavec: Group asset version extension classifier
        :type gavec: str
        :param npm_scope: npm scope
        :type npm_scope: str
        :param npm_author: npm author
        :type npm_author: str
        :param npm_description: npm description
        :type npm_description: str
        :param npm_keywords: npm keywords
        :type npm_keywords: str
        :param npm_license: npm license
        :type npm_license: str
        :param npm_tagged_is: npm tagged is
        :type npm_tagged_is: str
        :param npm_tagged_not: npm tagged not
        :type npm_tagged_not: str
        :param nuget_id: NuGet id
        :type nuget_id: str
        :param nuget_tags: NuGet tags
        :type nuget_tags: str
        :param nuget_title: NuGet title
        :type nuget_title: str
        :param nuget_authors: NuGet authors
        :type nuget_authors: str
        :param nuget_description: NuGet description
        :type nuget_description: str
        :param nuget_summary: NuGet summary
        :type nuget_summary: str
        :param nuget_is_prerelease: NuGet prerelease
        :type nuget_is_prerelease: str
        :param p2_plugin_name: p2 plugin name
        :type p2_plugin_name: str
        :param pypi_classifiers: PyPI classifiers
        :type pypi_classifiers: str
        :param pypi_description: PyPI description
        :type pypi_description: str
        :param pypi_keywords: PyPI keywords
        :type pypi_keywords: str
        :param pypi_summary: PyPI summary
        :type pypi_summary: str
        :param rubygems_description: RubyGems description
        :type rubygems_description: str
        :param rubygems_platform: RubyGems platform
        :type rubygems_platform: str
        :param rubygems_summary: RubyGems summary
        :type rubygems_summary: str
        :param tag: Component tag
        :type tag: str
        :param terraform_provider: terraform provider
        :type terraform_provider: str
        :param terraform_namespace: terraform namespace
        :type terraform_namespace: str
        :param terraform_name: terraform name
        :type terraform_name: str
        :param yum_architecture: Yum architecture
        :type yum_architecture: str
        :param yum_name: Yum package name
        :type yum_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._disassociate_serialize(
            tag_name=tag_name,
            wait=wait,
            q=q,
            repository=repository,
            format=format,
            group=group,
            name=name,
            version=version,
            prerelease=prerelease,
            last_updated=last_updated,
            last_blob_updated=last_blob_updated,
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            sha512=sha512,
            composer_vendor=composer_vendor,
            composer_package=composer_package,
            composer_version=composer_version,
            conan_base_version=conan_base_version,
            conan_channel=conan_channel,
            conan_revision=conan_revision,
            conan_package_id=conan_package_id,
            conan_package_revision=conan_package_revision,
            docker_image_name=docker_image_name,
            docker_image_tag=docker_image_tag,
            docker_layer_id=docker_layer_id,
            docker_content_digest=docker_content_digest,
            maven_group_id=maven_group_id,
            maven_artifact_id=maven_artifact_id,
            maven_base_version=maven_base_version,
            maven_extension=maven_extension,
            maven_classifier=maven_classifier,
            gavec=gavec,
            npm_scope=npm_scope,
            npm_author=npm_author,
            npm_description=npm_description,
            npm_keywords=npm_keywords,
            npm_license=npm_license,
            npm_tagged_is=npm_tagged_is,
            npm_tagged_not=npm_tagged_not,
            nuget_id=nuget_id,
            nuget_tags=nuget_tags,
            nuget_title=nuget_title,
            nuget_authors=nuget_authors,
            nuget_description=nuget_description,
            nuget_summary=nuget_summary,
            nuget_is_prerelease=nuget_is_prerelease,
            p2_plugin_name=p2_plugin_name,
            pypi_classifiers=pypi_classifiers,
            pypi_description=pypi_description,
            pypi_keywords=pypi_keywords,
            pypi_summary=pypi_summary,
            rubygems_description=rubygems_description,
            rubygems_platform=rubygems_platform,
            rubygems_summary=rubygems_summary,
            tag=tag,
            terraform_provider=terraform_provider,
            terraform_namespace=terraform_namespace,
            terraform_name=terraform_name,
            yum_architecture=yum_architecture,
            yum_name=yum_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _disassociate_serialize(
        self,
        tag_name,
        wait,
        q,
        repository,
        format,
        group,
        name,
        version,
        prerelease,
        last_updated,
        last_blob_updated,
        md5,
        sha1,
        sha256,
        sha512,
        composer_vendor,
        composer_package,
        composer_version,
        conan_base_version,
        conan_channel,
        conan_revision,
        conan_package_id,
        conan_package_revision,
        docker_image_name,
        docker_image_tag,
        docker_layer_id,
        docker_content_digest,
        maven_group_id,
        maven_artifact_id,
        maven_base_version,
        maven_extension,
        maven_classifier,
        gavec,
        npm_scope,
        npm_author,
        npm_description,
        npm_keywords,
        npm_license,
        npm_tagged_is,
        npm_tagged_not,
        nuget_id,
        nuget_tags,
        nuget_title,
        nuget_authors,
        nuget_description,
        nuget_summary,
        nuget_is_prerelease,
        p2_plugin_name,
        pypi_classifiers,
        pypi_description,
        pypi_keywords,
        pypi_summary,
        rubygems_description,
        rubygems_platform,
        rubygems_summary,
        tag,
        terraform_provider,
        terraform_namespace,
        terraform_name,
        yum_architecture,
        yum_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tag_name is not None:
            _path_params['tagName'] = tag_name
        # process the query parameters
        if wait is not None:
            
            _query_params.append(('wait', wait))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if repository is not None:
            
            _query_params.append(('repository', repository))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        if group is not None:
            
            _query_params.append(('group', group))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if version is not None:
            
            _query_params.append(('version', version))
            
        if prerelease is not None:
            
            _query_params.append(('prerelease', prerelease))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if last_blob_updated is not None:
            
            _query_params.append(('lastBlobUpdated', last_blob_updated))
            
        if md5 is not None:
            
            _query_params.append(('md5', md5))
            
        if sha1 is not None:
            
            _query_params.append(('sha1', sha1))
            
        if sha256 is not None:
            
            _query_params.append(('sha256', sha256))
            
        if sha512 is not None:
            
            _query_params.append(('sha512', sha512))
            
        if composer_vendor is not None:
            
            _query_params.append(('composer.vendor', composer_vendor))
            
        if composer_package is not None:
            
            _query_params.append(('composer.package', composer_package))
            
        if composer_version is not None:
            
            _query_params.append(('composer.version', composer_version))
            
        if conan_base_version is not None:
            
            _query_params.append(('conan.baseVersion', conan_base_version))
            
        if conan_channel is not None:
            
            _query_params.append(('conan.channel', conan_channel))
            
        if conan_revision is not None:
            
            _query_params.append(('conan.revision', conan_revision))
            
        if conan_package_id is not None:
            
            _query_params.append(('conan.packageId', conan_package_id))
            
        if conan_package_revision is not None:
            
            _query_params.append(('conan.packageRevision', conan_package_revision))
            
        if docker_image_name is not None:
            
            _query_params.append(('docker.imageName', docker_image_name))
            
        if docker_image_tag is not None:
            
            _query_params.append(('docker.imageTag', docker_image_tag))
            
        if docker_layer_id is not None:
            
            _query_params.append(('docker.layerId', docker_layer_id))
            
        if docker_content_digest is not None:
            
            _query_params.append(('docker.contentDigest', docker_content_digest))
            
        if maven_group_id is not None:
            
            _query_params.append(('maven.groupId', maven_group_id))
            
        if maven_artifact_id is not None:
            
            _query_params.append(('maven.artifactId', maven_artifact_id))
            
        if maven_base_version is not None:
            
            _query_params.append(('maven.baseVersion', maven_base_version))
            
        if maven_extension is not None:
            
            _query_params.append(('maven.extension', maven_extension))
            
        if maven_classifier is not None:
            
            _query_params.append(('maven.classifier', maven_classifier))
            
        if gavec is not None:
            
            _query_params.append(('gavec', gavec))
            
        if npm_scope is not None:
            
            _query_params.append(('npm.scope', npm_scope))
            
        if npm_author is not None:
            
            _query_params.append(('npm.author', npm_author))
            
        if npm_description is not None:
            
            _query_params.append(('npm.description', npm_description))
            
        if npm_keywords is not None:
            
            _query_params.append(('npm.keywords', npm_keywords))
            
        if npm_license is not None:
            
            _query_params.append(('npm.license', npm_license))
            
        if npm_tagged_is is not None:
            
            _query_params.append(('npm.tagged_is', npm_tagged_is))
            
        if npm_tagged_not is not None:
            
            _query_params.append(('npm.tagged_not', npm_tagged_not))
            
        if nuget_id is not None:
            
            _query_params.append(('nuget.id', nuget_id))
            
        if nuget_tags is not None:
            
            _query_params.append(('nuget.tags', nuget_tags))
            
        if nuget_title is not None:
            
            _query_params.append(('nuget.title', nuget_title))
            
        if nuget_authors is not None:
            
            _query_params.append(('nuget.authors', nuget_authors))
            
        if nuget_description is not None:
            
            _query_params.append(('nuget.description', nuget_description))
            
        if nuget_summary is not None:
            
            _query_params.append(('nuget.summary', nuget_summary))
            
        if nuget_is_prerelease is not None:
            
            _query_params.append(('nuget.is_prerelease', nuget_is_prerelease))
            
        if p2_plugin_name is not None:
            
            _query_params.append(('p2.pluginName', p2_plugin_name))
            
        if pypi_classifiers is not None:
            
            _query_params.append(('pypi.classifiers', pypi_classifiers))
            
        if pypi_description is not None:
            
            _query_params.append(('pypi.description', pypi_description))
            
        if pypi_keywords is not None:
            
            _query_params.append(('pypi.keywords', pypi_keywords))
            
        if pypi_summary is not None:
            
            _query_params.append(('pypi.summary', pypi_summary))
            
        if rubygems_description is not None:
            
            _query_params.append(('rubygems.description', rubygems_description))
            
        if rubygems_platform is not None:
            
            _query_params.append(('rubygems.platform', rubygems_platform))
            
        if rubygems_summary is not None:
            
            _query_params.append(('rubygems.summary', rubygems_summary))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if terraform_provider is not None:
            
            _query_params.append(('terraform.provider', terraform_provider))
            
        if terraform_namespace is not None:
            
            _query_params.append(('terraform.namespace', terraform_namespace))
            
        if terraform_name is not None:
            
            _query_params.append(('terraform.name', terraform_name))
            
        if yum_architecture is not None:
            
            _query_params.append(('yum.architecture', yum_architecture))
            
        if yum_name is not None:
            
            _query_params.append(('yum.name', yum_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/tags/associate/{tagName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get3(
        self,
        name: Annotated[StrictStr, Field(description="Name of the tag to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TagXO:
        """Get a tag


        :param name: Name of the tag to retrieve (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get3_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagXO",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get3_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Name of the tag to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TagXO]:
        """Get a tag


        :param name: Name of the tag to retrieve (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get3_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagXO",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get3_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Name of the tag to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a tag


        :param name: Name of the tag to retrieve (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get3_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagXO",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get3_serialize(
        self,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/tags/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tags(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token returned by a prior request. If present, the next page of results are returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PageTagXO:
        """List tags


        :param continuation_token: A token returned by a prior request. If present, the next page of results are returned
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tags_serialize(
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PageTagXO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tags_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token returned by a prior request. If present, the next page of results are returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PageTagXO]:
        """List tags


        :param continuation_token: A token returned by a prior request. If present, the next page of results are returned
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tags_serialize(
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PageTagXO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tags_without_preload_content(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token returned by a prior request. If present, the next page of results are returned")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List tags


        :param continuation_token: A token returned by a prior request. If present, the next page of results are returned
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tags_serialize(
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PageTagXO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tags_serialize(
        self,
        continuation_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuationToken', continuation_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replace(
        self,
        name: StrictStr,
        body: Optional[BaseTagXO] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TagXO:
        """Update a tags attributes


        :param name: (required)
        :type name: str
        :param body:
        :type body: BaseTagXO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_serialize(
            name=name,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagXO",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replace_with_http_info(
        self,
        name: StrictStr,
        body: Optional[BaseTagXO] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TagXO]:
        """Update a tags attributes


        :param name: (required)
        :type name: str
        :param body:
        :type body: BaseTagXO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_serialize(
            name=name,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagXO",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replace_without_preload_content(
        self,
        name: StrictStr,
        body: Optional[BaseTagXO] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a tags attributes


        :param name: (required)
        :type name: str
        :param body:
        :type body: BaseTagXO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_serialize(
            name=name,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagXO",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replace_serialize(
        self,
        name,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v1/tags/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


