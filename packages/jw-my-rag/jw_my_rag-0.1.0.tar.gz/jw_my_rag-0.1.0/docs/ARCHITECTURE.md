# ARCHITECTURE.md

## OCR 기반 문서 인텔리전스 & 벡터 검색 시스템 아키텍처

> **⚠️ 주의사항**
> - 이 문서는 리팩토링 및 재구현의 **단일 진실 원천(Single Source of Truth)**입니다
> - 모든 AI 코딩 에이전트는 이 문서의 규칙을 엄격히 준수해야 합니다
> - 이 문서와 충돌하는 구현은 설계 리뷰 대상입니다

---

## 1️⃣ 문제 재정립 (WHY)

### 1.1 "임베딩 품질 문제"는 대부분 아키텍처 문제다

임베딩 기반 검색 시스템에서 "검색 정확도가 낮다"는 문제가 발생할 때, 개발자들은 본능적으로 다음을 시도한다:

- 더 좋은 임베딩 모델로 교체
- 청크 크기 조정
- 오버랩 비율 튜닝
- 리랭킹 모델 추가

그러나 이러한 접근은 **증상을 치료하는 것**이지 **근본 원인을 해결하는 것**이 아니다.

진짜 문제는 **"무엇을 임베딩하는가"에 대한 명확한 정의가 없다**는 것이다. 임베딩 모델이 아무리 우수해도, 의미적으로 불완전하거나 맥락이 단절된 텍스트를 입력하면 검색 품질은 저하될 수밖에 없다.

### 1.2 나이브한 청크 기반 임베딩의 한계

단순히 문서를 고정 크기로 분할하여 임베딩하는 방식에는 다음과 같은 근본적 결함이 있다:

**맥락 단절(Context Severing)**
- "이 함수는 다음과 같이 동작한다"라는 설명과 실제 코드가 서로 다른 청크에 분리
- 사용자가 "fetch 함수 사용법"을 검색하면, 설명 텍스트와 코드가 별개로 검색됨
- 검색 결과의 응집도(coherence)가 급격히 하락

**의미 단위 무시(Semantic Boundary Ignorance)**
- 코드 블록이 중간에 잘려서 문법적으로 불완전한 청크 생성
- 표/그림 캡션이 본문에서 분리되어 참조 관계 손실
- 섹션 헤더가 이전 섹션의 끝에 붙어버리는 현상

**검색 의도 불일치(Intent Mismatch)**
- 모든 청크가 동등하게 검색 대상이 됨
- "개요를 알고 싶다" vs "구체적 구현을 보고 싶다"를 구분 불가
- 검색 결과에 노이즈가 증가

### 1.3 명확한 표현 경계 없이는 검색 정확도가 저하된다

검색 정확도 문제의 핵심은 다음 질문에 명확히 답하지 못하기 때문이다:

- **무엇이 검색 대상인가?** (검색 가능한 엔티티의 정의)
- **무엇이 맥락 제공자인가?** (검색되지 않지만 결과와 함께 제공될 정보)
- **무엇이 임베딩되어야 하는가?** (벡터로 변환할 대상)
- **무엇이 임베딩되어서는 안 되는가?** (저장은 하되 검색 대상에서 제외할 것)

이 경계가 불명확하면:
- 불필요한 텍스트가 임베딩되어 벡터 공간이 오염됨
- 중요한 맥락이 누락되어 검색 결과의 유용성이 저하됨
- 검색 결과를 사용자에게 설명할 수 없음 (왜 이 결과가 나왔는지 불투명)

---

## 2️⃣ 아키텍처 원칙 (비협상적 규칙)

### 원칙 1: 저장된 모든 텍스트가 임베딩 대상은 아니다

**규칙 명세**
> 시스템에 저장된 텍스트 중 일부만 벡터 임베딩의 대상이다. 저장(Storage)과 임베딩(Embedding)은 독립적인 결정이다.

**존재 이유**
- 메타데이터, 원본 경로, 타임스탬프 등은 저장되어야 하지만 임베딩할 필요가 없다
- 과도하게 짧은 텍스트(1-2 단어)는 의미적 표현력이 부족하다
- 반복적인 보일러플레이트 텍스트는 검색 노이즈만 증가시킨다

**방지하는 문제**
- 벡터 공간 오염: 무의미한 벡터가 검색 결과에 노출
- 저장 비용 낭비: 불필요한 임베딩 연산 및 저장소 사용
- 검색 정밀도 저하: 관련 없는 결과가 상위에 노출

---

### 원칙 2: 임베딩 단위 ≠ 저장 단위

**규칙 명세**
> 하나의 임베딩은 하나의 "의미적 표현"을 나타낸다. 이는 데이터베이스 레코드나 파일 청크와 1:1 대응하지 않을 수 있다.

**존재 이유**
- 하나의 개념은 여러 저장 레코드에 분산될 수 있다 (코드 + 설명 + 예시)
- 하나의 저장 레코드가 여러 임베딩을 생성할 수 있다 (긴 텍스트의 분할)
- 저장 구조는 데이터 무결성을 위한 것이고, 임베딩 구조는 검색 품질을 위한 것이다

**방지하는 문제**
- 저장 스키마 변경이 검색 품질에 예기치 않은 영향을 미침
- 임베딩 전략 변경이 저장 로직을 복잡하게 만듦
- 두 관심사의 결합으로 인한 유지보수 비용 증가

---

### 원칙 3: 모든 임베딩은 의미적 소유자를 가진다

**규칙 명세**
> 시스템의 모든 임베딩은 정확히 하나의 "의미적 소유자(Semantic Owner)"에 귀속되어야 한다. 소유자 없는 임베딩은 존재할 수 없다.

**존재 이유**
- 검색 결과를 사용자에게 맥락과 함께 제공할 수 있어야 한다
- 임베딩 무효화(invalidation) 시 어떤 임베딩을 삭제해야 하는지 알 수 있어야 한다
- 동일 개념에 대한 중복 임베딩을 방지할 수 있어야 한다

**방지하는 문제**
- 고아 임베딩(orphan embedding): 원본이 삭제되었으나 임베딩이 남아 있는 상황
- 맥락 없는 검색 결과: 결과를 보여줘도 사용자가 이해하지 못함
- 중복 임베딩: 동일 내용이 여러 번 임베딩되어 저장 낭비 및 검색 노이즈

---

### 원칙 4: 검색 대상과 맥락 제공자는 다른 엔티티다

**규칙 명세**
> "검색되는 것"과 "검색 결과와 함께 제공되는 맥락"은 명확히 구분되어야 한다. 검색 대상은 임베딩되고, 맥락 제공자는 검색 대상에 연결된다.

**존재 이유**
- 사용자는 구체적인 정보를 검색하지만, 이해를 위해서는 주변 맥락이 필요하다
- 부모 문서(전체 맥락)는 검색 대상이 아니지만, 결과 제공 시 필수적이다
- 검색 대상의 크기는 작을수록 정밀하고, 맥락은 클수록 유용하다

**방지하는 문제**
- 검색 결과만으로는 이해 불가: "이 코드는 무슨 맥락인가?"
- 과도한 임베딩: 맥락 정보까지 모두 임베딩하여 비용 및 노이즈 증가
- 검색-표시 불일치: 검색은 됐지만 유용한 정보를 제공하지 못함

---

### 원칙 5: 뷰(View)는 동일 개념의 다른 표현이다

**규칙 명세**
> 텍스트, 코드, 이미지는 동일한 개념(Concept)을 다른 관점에서 표현한 "뷰"다. 뷰는 독립적인 엔티티가 아니라 개념에 종속된 표현 방식이다.

**존재 이유**
- "Python으로 HTTP 요청하는 방법"은 설명 텍스트 + 코드 예시 + 아키텍처 다이어그램으로 구성될 수 있다
- 각 뷰는 같은 개념을 다른 방식으로 설명한다
- 검색 시 뷰별로 필터링하면서도 개념 단위로 결과를 그룹화할 수 있어야 한다

**방지하는 문제**
- 뷰 간 연결 손실: 코드와 설명이 별개의 검색 결과로 취급됨
- 개념 파편화: 동일 개념이 여러 독립 엔티티로 분리되어 응집도 상실
- 검색 결과 중복: 같은 개념이 뷰별로 여러 번 나타남

---

## 3️⃣ 핵심 도메인 모델 (개념 수준)

### 3.1 Document (문서)

**목적**
- 시스템에 입력되는 최상위 단위
- 모든 하위 엔티티의 출처(provenance)를 추적하는 기준점

**의미적 표현**
- 하나의 물리적 파일 또는 논리적 문서 단위
- 예: PDF 파일 하나, Markdown 문서 하나

**임베딩 여부**: NO
- 문서 자체는 임베딩되지 않음
- 하위 엔티티(Concept, Fragment)만 임베딩 대상

**생명주기 책임**
- 문서 삭제 시 모든 하위 Concept과 Fragment가 연쇄 삭제됨
- 문서 갱신 시 하위 엔티티의 재처리 여부 결정

---

### 3.2 Concept (개념 / Semantic Parent)

**목적**
- 의미적으로 응집된 정보 단위
- 검색 결과의 "단위"가 되는 엔티티

**의미적 표현**
- "하나의 주제"를 설명하는 텍스트, 코드, 이미지의 묶음
- 예: "fetch 함수 사용법" = 설명 텍스트 + 코드 예시 + 결과 스크린샷

**임베딩 여부**: CONDITIONAL
- **대표 임베딩(Representative Embedding)**: 개념 전체를 요약하는 단일 임베딩 (선택적)
- 대표 임베딩은 "개요 검색" 시나리오에서 사용
- 상세 검색은 하위 Fragment의 임베딩을 사용

**생명주기 책임**
- Concept 생성 시 고유 식별자(concept_id) 발급
- 하위 Fragment들의 parent_id로 참조됨
- Concept 삭제 시 모든 하위 Fragment와 임베딩이 무효화됨

---

### 3.3 Child Fragment (자식 프래그먼트)

**목적**
- Concept을 구성하는 개별 정보 조각
- 실제 검색 및 임베딩의 주요 대상

**의미적 표현**
- Concept 내에서 특정 역할을 수행하는 텍스트/코드/이미지 조각
- 예: 설명 텍스트 청크, 코드 블록 하나, 이미지 캡션

**임베딩 여부**: YES
- 모든 Fragment는 임베딩 대상
- 단, 최소 길이 기준 미달 시 제외 가능 (예: 10자 미만)

**생명주기 책임**
- 반드시 하나의 Concept에 소속됨 (parent_id 필수)
- Fragment 내용 변경 시 임베딩 재생성
- 순서(order) 정보로 원본 내 위치 추적

---

### 3.4 View (뷰)

**목적**
- Fragment의 콘텐츠 유형을 분류
- 검색 시 필터링 및 특화 처리의 기준

**의미적 표현**
- `text`: 자연어 설명, 문단, 주석
- `code`: 프로그래밍 코드 블록
- `image`: 이미지 참조 및 대체 텍스트
- `table`: 표 형식 데이터
- `figure`: 도표, 다이어그램 캡션

**임베딩 여부**: N/A (View는 속성이지 엔티티가 아님)
- View는 Fragment의 메타데이터
- 동일 Concept 내 여러 View의 Fragment가 공존 가능

**생명주기 책임**
- View는 Fragment 생성 시 결정되며 변경되지 않음
- View별로 다른 청킹 전략 적용 가능 (텍스트 vs 코드)

---

### 3.5 Embedding Representation (임베딩 표현)

**목적**
- 검색을 위한 벡터 표현
- Fragment 또는 Concept의 의미를 수치화

**의미적 표현**
- 고정 차원의 실수 벡터 (예: 768차원, 1024차원)
- 유사한 의미는 벡터 공간에서 가까운 위치에 매핑됨

**임베딩 여부**: N/A (Embedding Representation 자체가 임베딩 결과물)

**생명주기 책임**
- 원본 콘텐츠 변경 시 재생성 필수
- 안정적인 식별자(doc_id)로 중복 방지
- 원본 엔티티 삭제 시 연쇄 삭제

---

### 도메인 모델 관계도

```
Document (문서)
    │
    ├── Concept A (개념)
    │       │
    │       ├── Fragment A1 [view: text]    ──→ Embedding A1
    │       ├── Fragment A2 [view: code]    ──→ Embedding A2
    │       └── Fragment A3 [view: image]   ──→ Embedding A3
    │
    ├── Concept B (개념)
    │       │
    │       ├── Fragment B1 [view: text]    ──→ Embedding B1
    │       └── Fragment B2 [view: text]    ──→ Embedding B2
    │
    └── (Representative Embedding for Document) ──→ [선택적]
```

---

## 4️⃣ 임베딩 아키텍처 (핵심 섹션)

### 4.1 어떤 엔티티가 임베딩을 가지는가?

| 엔티티 | 임베딩 여부 | 근거 |
|--------|-------------|------|
| Document | NO | 너무 크고 다양한 주제를 포함, 검색 대상으로 부적합 |
| Concept | CONDITIONAL | 대표 임베딩으로 개요 검색 지원 (선택적 구현) |
| Fragment | YES | 주요 검색 대상, 구체적 정보의 벡터 표현 |
| View | N/A | 속성일 뿐 엔티티가 아님 |
| Metadata | NO | 구조화된 필터링 대상, 벡터 검색 대상 아님 |

### 4.2 개념 단위당 임베딩 수

하나의 Concept은 다음과 같은 임베딩을 가질 수 있다:

**필수 임베딩**
- **Fragment 임베딩**: Concept에 속한 각 Fragment마다 하나씩
- Fragment 수 = N이면 최소 N개의 임베딩

**선택적 임베딩**
- **대표 임베딩(Representative Embedding)**: Concept 전체를 요약하는 단일 임베딩
- 대표 임베딩 생성 조건: Concept의 Fragment가 3개 이상일 때
- 대표 임베딩 내용: Concept의 제목 + 첫 번째 텍스트 Fragment 요약

### 4.3 대표 임베딩 vs 지원 임베딩

**대표 임베딩 (Representative Embedding)**
- **정의**: Concept 전체의 의미를 대표하는 단일 벡터
- **용도**:
  - 개요/요약 수준 검색 ("HTTP 요청 관련 내용 찾기")
  - 첫 번째 검색 단계에서 후보 Concept 선별
- **생성 방식**:
  - 제목 + 첫 번째 설명 텍스트 + 코드 시그니처 조합
  - 최대 500자 이내로 압축

**지원 임베딩 (Supporting Embedding)**
- **정의**: Fragment 각각의 상세 내용을 나타내는 벡터
- **용도**:
  - 구체적 검색 ("requests.get 사용 예시")
  - 대표 임베딩으로 선별된 Concept 내에서 정확한 위치 특정
- **생성 방식**:
  - Fragment의 page_content 전체
  - View별 특화 처리 (코드는 구조 보존 분할)

### 4.4 임베딩되지 않는 것

다음은 **절대로 임베딩되어서는 안 된다**:

| 대상 | 이유 |
|------|------|
| 파일 경로/메타데이터 | 의미적 검색 대상이 아님, 구조화 필터링 사용 |
| 10자 미만의 짧은 텍스트 | 의미적 표현력 부족, 노이즈만 증가 |
| 반복되는 보일러플레이트 | 검색 결과 오염, 저장 낭비 |
| 페이지 번호/헤더/푸터 | 문서 구조 정보일 뿐 내용이 아님 |
| 이미 임베딩된 동일 콘텐츠 | 중복 방지 (content_hash로 검증) |
| 순수 참조 정보 | "그림 3 참조"와 같은 참조 텍스트 |

### 4.5 임베딩 소유권 규칙

**규칙 1: 모든 임베딩은 정확히 하나의 Fragment에 귀속된다**
- 임베딩 → Fragment → Concept → Document 체인이 항상 존재해야 함
- 체인이 끊어진 임베딩은 고아(orphan)로 간주하여 정리 대상

**규칙 2: Fragment의 parent_id는 불변이다**
- Fragment 생성 시점에 Concept이 확정됨
- 이후 parent_id 변경은 금지 (새 Fragment 생성으로 대체)

**규칙 3: 임베딩 ID는 콘텐츠 기반으로 결정된다**
- `doc_id = hash(parent_id + view + lang + content)`
- 동일 내용은 항상 동일 ID를 가짐
- 중복 임베딩 자동 방지

### 4.6 임베딩 무효화 규칙

**즉시 무효화가 필요한 경우**
- Fragment의 page_content가 변경됨
- Concept이 삭제됨
- Document가 삭제됨

**무효화 절차**
1. 변경된 엔티티의 모든 하위 임베딩 식별
2. 해당 임베딩을 벡터 저장소에서 삭제
3. 필요시 새로운 임베딩 생성 및 저장

**무효화하지 않는 경우**
- 메타데이터만 변경 (view, lang 등은 doc_id 계산에 포함되므로 해당 시 무효화)
- Concept 내 다른 Fragment 변경 (각 Fragment는 독립)

### 4.7 임베딩 버전 관리 고려사항

**버전 관리가 필요한 상황**
- 임베딩 모델 변경 (voyage-3 → voyage-4)
- 임베딩 차원 변경 (768 → 1024)
- 청킹 전략 변경

**권장 접근법**
- 컬렉션(Collection) 단위로 버전 관리
- 모델 변경 시 새 컬렉션 생성 후 마이그레이션
- 구 컬렉션은 검증 완료 후 삭제

---

## 5️⃣ 검색 아키텍처

### 5.1 검색 파이프라인 단계

검색은 다음 순서로 진행된다:

```
[사용자 쿼리]
      │
      ▼
┌─────────────────────────────────────┐
│  1. 쿼리 해석 (Query Interpretation) │
│     - 쿼리 유형 분류                 │
│     - 메타데이터 필터 추출           │
│     - 검색 의도 파악                 │
└─────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────┐
│  2. 1차 검색 (Primary Search)       │
│     - 벡터 유사도 검색               │
│     - 메타데이터 필터 적용           │
│     - Top-K 후보 선별                │
└─────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────┐
│  3. 후보 확장 (Candidate Expansion) │
│     - 동일 Concept의 다른 Fragment   │
│     - 관련 View 수집                 │
│     - 인접 Fragment 포함             │
└─────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────┐
│  4. 맥락 조립 (Context Assembly)    │
│     - Parent 문서 로드               │
│     - 계층 구조 복원                 │
│     - 출처 정보 첨부                 │
└─────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────┐
│  5. 리랭킹 (Reranking) [선택적]     │
│     - Cross-encoder 재점수          │
│     - 다양성 고려한 재정렬           │
│     - 최종 Top-K 선정                │
└─────────────────────────────────────┘
      │
      ▼
[검색 결과 반환]
```

### 5.2 쿼리 해석 책임

**쿼리 유형 분류**
- **개요 검색**: "HTTP 요청 방법" → 대표 임베딩 우선 검색
- **구체적 검색**: "requests.get timeout 설정" → Fragment 임베딩 검색
- **코드 검색**: "async/await 예제" → view=code 필터 적용
- **하이브리드 검색**: 자연어 + 코드 키워드 혼합

**메타데이터 필터 추출**
- 언어 지정: "Python으로" → lang=python
- 뷰 지정: "코드 예시" → view=code
- 문서 범위: "chapter 3에서" → page 또는 section 필터

### 5.3 1차 검색 대상

**검색되는 것**
- Fragment 임베딩 (주요 검색 대상)
- 대표 임베딩 (개요 검색 시)

**검색 방법**
- 코사인 유사도 기반 벡터 검색
- HNSW 인덱스를 통한 근사 최근접 이웃 검색

**필터 적용 시점**
- 메타데이터 필터는 벡터 검색과 동시에 적용
- view, lang, source 등으로 검색 범위 제한

### 5.4 후보 선별 로직

**Top-K 선정 기준**
- 기본값: K = 10 (조정 가능)
- 유사도 점수 임계값: 0.5 이상 (조정 가능)

**중복 제거**
- 동일 Concept의 Fragment가 여러 개 검색된 경우
- 가장 높은 점수의 Fragment만 대표로 유지
- 또는 Concept 단위로 그룹화하여 반환

### 5.5 맥락 확장 로직

**동일 Concept 확장**
- 검색된 Fragment의 parent_id로 sibling Fragment 조회
- 모든 View의 Fragment 수집 (text, code, image)

**인접 Fragment 확장**
- order 기준으로 앞뒤 Fragment 포함 (선택적)
- 문맥 이해에 필요한 연속성 확보

**Parent 문서 연결**
- Fragment의 parent_id로 Concept의 전체 내용 조회
- 검색 결과와 함께 상위 맥락 제공

### 5.6 리랭킹 단계 (선택적)

**리랭킹 목적**
- 벡터 유사도만으로는 포착 못한 관련성 보완
- 쿼리-결과 쌍의 교차 어텐션 기반 정밀 평가

**리랭킹 전략**
- Cross-encoder 모델로 쿼리-Fragment 쌍 점수 재계산
- 다양성 고려: MMR(Maximal Marginal Relevance) 적용
- 최종 Top-K를 재정렬하여 반환

### 5.7 검색 구성요소별 사용 기술

| 단계 | 기술/방법 |
|------|-----------|
| 벡터 유사도 | 코사인 유사도 + HNSW 인덱스 |
| 메타데이터 필터 | JSONB 인덱스 + SQL WHERE 조건 |
| 계층 구조 해소 | parent_id 기반 JOIN 또는 별도 조회 |
| 리랭킹 | Cross-encoder 또는 LLM 기반 재점수 |

---

## 6️⃣ 뷰 전략 (text / code / image)

### 6.1 뷰가 존재하는 이유

동일한 개념(Concept)은 여러 형태로 표현될 수 있다:

- **텍스트**: 자연어로 설명하는 방식 ("이 함수는 HTTP 요청을 보낸다")
- **코드**: 프로그래밍 언어로 구현 (`response = requests.get(url)`)
- **이미지**: 시각적 표현 (아키텍처 다이어그램, 스크린샷)

이러한 다양한 표현을 "뷰(View)"라고 부르며, 각 뷰는 동일 개념에 대한 **다른 관점**을 제공한다.

### 6.2 뷰의 본질: 독립 검색 대상 vs 임베딩 전략

**핵심 결정: 뷰는 독립 검색 대상이다**

| 관점 | 설명 |
|------|------|
| 독립 검색 대상 (채택) | 각 뷰의 Fragment는 별도로 검색 가능하며, 필터링 기준이 된다 |
| 임베딩 전략 (비채택) | 뷰는 단순히 임베딩 방식의 차이일 뿐 검색 대상이 아니다 |

**채택 근거**:
- 사용자는 "코드 예시만 보고 싶다" 또는 "설명 텍스트만 검색"과 같은 의도를 가짐
- 뷰별 필터링 없이는 검색 결과에 노이즈가 증가
- 코드와 텍스트는 임베딩 공간에서 다른 특성을 가짐 (분리 검색이 효과적)

### 6.3 각 뷰가 동일 개념에 기여하는 방식

```
Concept: "HTTP GET 요청 보내기"
    │
    ├── [text] "requests 라이브러리를 사용하여 GET 요청을 보낼 수 있다.
    │           URL과 선택적 파라미터를 지정하면 된다."
    │
    ├── [code] "import requests
    │           response = requests.get('https://api.example.com')"
    │
    └── [image] "![GET 요청 흐름도](images/get-flow.png)"
```

**기여 방식**:
- `text` 뷰: 개념의 의미와 목적을 설명
- `code` 뷰: 실제 구현 방법을 제시
- `image` 뷰: 시각적 이해를 지원

### 6.4 뷰별 처리 전략

| 뷰 | 청킹 전략 | 임베딩 고려사항 |
|----|-----------|--------------------|
| text | 문장/문단 경계 존중, 1200자 청크, 150자 오버랩 | 자연어에 최적화된 임베딩 모델 사용 |
| code | 함수/클래스 경계 존중, 구문 완전성 유지 | 코드 특화 처리 (주석 분리 등) |
| image | 분할 없음, 단일 Fragment로 유지 | alt 텍스트 + 캡션 기반 임베딩 |
| table | 분할 없음 또는 행 단위 | 구조 정보 보존 |
| figure | 분할 없음 | 캡션 텍스트 기반 임베딩 |

### 6.5 뷰 전략 요약

1. **뷰는 Concept에 종속된 속성이다** - 독립 엔티티가 아님
2. **각 뷰는 독립 검색 대상이다** - view 필터로 검색 범위 제한 가능
3. **동일 Concept의 뷰들은 결과에서 그룹화된다** - 검색 결과 응집도 유지
4. **뷰별 특화 처리가 적용된다** - 청킹, 임베딩 전략이 다름

---

## 7️⃣ 저장소 및 인덱싱 책임 (논리적)

### 7.1 검색을 위해 인덱싱되어야 하는 데이터

**벡터 인덱스 대상**
- Fragment 임베딩 벡터
- 대표 임베딩 벡터 (선택적)

**목적**: 유사도 기반 검색의 성능 보장

**인덱스 유형 요구사항**
- 근사 최근접 이웃(ANN) 검색 지원
- 고차원 벡터에 최적화
- 실시간 삽입/삭제 지원

---

**메타데이터 인덱스 대상**

| 필드 | 인덱스 필요성 | 용도 |
|------|--------------|------|
| parent_id | 필수 | Concept 기반 그룹화/조회 |
| view | 필수 | 뷰별 필터링 |
| lang | 필수 | 언어별 필터링 |
| source | 필수 | 문서 출처별 필터링 |
| order | 선택 | 순서 기반 정렬/조회 |
| page | 선택 | 페이지 기반 필터링 |
| section | 선택 | 섹션 기반 필터링 |

### 7.2 검색 맥락으로만 사용되는 데이터

**저장되지만 인덱싱 불필요**
- Parent 문서 전체 내용 (검색 결과와 함께 제공용)
- Fragment의 원본 텍스트 (검색 결과 표시용)
- 생성/수정 타임스탬프 (감사 추적용)

**특성**
- Primary Key로 직접 조회
- 검색 조건으로 사용되지 않음
- 결과 반환 시에만 필요

### 7.3 사용자에게 설명 가능해야 하는 데이터

검색 결과와 함께 다음 정보가 제공되어야 한다:

**필수 설명 정보**
- 출처(source): 어떤 문서에서 왔는가
- 위치(location): 문서 내 어디에 있는가 (페이지, 섹션)
- 유형(view): 텍스트인가, 코드인가, 이미지인가
- 맥락(context): 주변 내용은 무엇인가 (Parent 내용)

**설명 가능성 요구사항**
- "왜 이 결과가 검색되었는가"를 답할 수 있어야 함
- 사용자가 결과의 신뢰성을 판단할 수 있어야 함
- 원본 문서로의 역추적이 가능해야 함

### 7.4 저장 책임 분리

```
┌─────────────────────────────────────────────────────────┐
│                    검색 저장소                          │
│  - Fragment 임베딩 벡터                                 │
│  - 검색용 메타데이터 (view, lang, parent_id)            │
│  - ANN 인덱스                                          │
└─────────────────────────────────────────────────────────┘
                          │
                          │ parent_id 참조
                          ▼
┌─────────────────────────────────────────────────────────┐
│                    문서 저장소                          │
│  - Parent 문서 전체 내용                                │
│  - Concept 메타데이터                                   │
│  - 맥락 제공용 정보                                     │
└─────────────────────────────────────────────────────────┘
                          │
                          │ source 참조
                          ▼
┌─────────────────────────────────────────────────────────┐
│                    원본 저장소                          │
│  - 원본 파일 경로/참조                                  │
│  - 처리 이력 (파싱 일시, 버전)                          │
│  - 감사 로그                                            │
└─────────────────────────────────────────────────────────┘
```

---

## 8️⃣ 리팩토링 및 재구현 전략

### 8.1 고수준 리팩토링 로드맵

**Phase 1: 도메인 모델 정립**
- 현재 암묵적인 엔티티 관계를 명시적 모델로 정의
- Document → Concept → Fragment 계층 구조 명확화
- 각 엔티티의 책임과 생명주기 문서화

**Phase 2: 임베딩 경계 재정의**
- "무엇이 임베딩되는가" 규칙 수립 및 적용
- 불필요한 임베딩 대상 제거
- 임베딩 ID 생성 로직 표준화

**Phase 3: 검색 파이프라인 분리**
- 쿼리 해석 → 검색 → 확장 → 조립 단계 명확히 분리
- 각 단계의 입출력 계약 정의
- 단계별 테스트 가능한 구조로 리팩토링

**Phase 4: 저장소 책임 분리**
- 검색 저장소 vs 문서 저장소 vs 원본 저장소 분리
- 인덱싱 전략 최적화
- 캐싱 레이어 도입 검토

### 8.2 개념적으로 재사용 가능한 것

**재사용 가능**
- 파일 파싱 로직 (PDF, Markdown, 텍스트)
- 코드 감지 휴리스틱
- 텍스트 정규화 유틸리티
- 임베딩 프로바이더 추상화

**주의하여 재사용**
- 청킹 로직 (경계 조건 재검토 필요)
- 메타데이터 스키마 (필드 정의 재검토)
- Parent-Child 관계 로직 (Concept 모델에 맞게 조정)

### 8.3 반드시 재설계해야 하는 것

**재설계 필수**
- 의미 단위(Semantic Unit) 정의 및 생성 로직
- 임베딩 대상 결정 로직 (현재 암묵적 → 명시적 규칙으로)
- 검색 결과 그룹화 및 맥락 조립 로직
- 임베딩 무효화 및 갱신 메커니즘

**재설계 권장**
- 뷰 분류 체계 (현재 휴리스틱 기반 → 규칙 기반)
- Parent 문서 합성 로직 (단순 연결 → 의미적 요약)

### 8.4 구현 순서 권장

```
1. 도메인 모델 정의
   └── Document, Concept, Fragment, View 인터페이스 정의

2. 파싱 레이어 정비
   └── 기존 파서 활용, RawSegment 출력 표준화

3. Concept 빌더 구현
   └── RawSegment → UnitizedSegment → Concept 변환
   └── Semantic Unit 경계 결정 로직

4. Fragment 빌더 구현
   └── Concept → Fragment 분할
   └── 뷰별 청킹 전략 적용

5. 임베딩 레이어 구현
   └── 임베딩 대상 필터링
   └── doc_id 생성 및 중복 방지
   └── 배치 임베딩 및 저장

6. 검색 레이어 구현
   └── 쿼리 해석 → 검색 → 확장 → 조립 파이프라인

7. 통합 및 검증
   └── End-to-end 테스트
   └── 검색 품질 메트릭 측정
```

---

## 9️⃣ 명시적으로 피해야 할 안티패턴

### 안티패턴 1: 청크 우선 설계 (Chunk-First Design)

**설명**
- 먼저 문서를 고정 크기로 분할하고, 나중에 의미를 부여하려는 접근

**유혹적인 이유**
- 구현이 단순함 (문자열 슬라이싱)
- 모든 문서에 일관되게 적용 가능
- 청크 크기만 조절하면 될 것 같은 착각

**실패하는 이유**
- 의미 경계를 무시하여 맥락 단절 발생
- 코드 블록이 중간에 잘려 문법 오류 상태의 청크 생성
- "설명 + 코드"가 분리되어 검색 결과 품질 저하
- 청크 크기 튜닝으로는 근본적 해결 불가

---

### 안티패턴 2: 모든 것을 임베딩 (Embed Everything)

**설명**
- 저장된 모든 텍스트를 임베딩하는 접근

**유혹적인 이유**
- "더 많이 임베딩하면 더 잘 찾을 수 있다"는 직관
- 임베딩 대상 선별의 복잡성 회피
- 누락에 대한 두려움

**실패하는 이유**
- 벡터 공간 오염 (무의미한 벡터가 유사도 검색 방해)
- 저장 및 연산 비용 기하급수적 증가
- 검색 결과에 노이즈 증가 (관련 없는 결과 상위 노출)
- 임베딩 API 비용 낭비

---

### 안티패턴 3: 뷰를 엔티티로 혼동 (View-as-Entity Confusion)

**설명**
- 텍스트, 코드, 이미지를 독립적인 최상위 엔티티로 취급

**유혹적인 이유**
- 뷰별로 별도 처리 파이프라인 구성이 단순해 보임
- 각 뷰를 독립적으로 최적화할 수 있을 것 같은 기대
- 관심사 분리의 오용

**실패하는 이유**
- 동일 개념의 뷰들 간 연결 손실
- "코드와 그 설명"이 별개의 검색 결과로 취급됨
- 검색 결과의 응집도 저하
- 사용자가 결과를 이해하기 위해 여러 결과를 수동으로 조합해야 함

---

### 안티패턴 4: Parent를 단순 연결로 취급 (Parent as Mere Concatenation)

**설명**
- Parent 문서를 단순히 Child들의 텍스트를 이어붙인 것으로 구현

**유혹적인 이유**
- 구현이 간단 (`parent.content = '\n'.join(child.contents)`)
- 모든 정보가 포함됨
- Parent-Child 관계가 자동으로 성립

**실패하는 이유**
- Parent가 지나치게 길어져 맥락 제공 역할 실패
- 의미적 요약 없이 단순 나열은 정보 가치 낮음
- 임베딩 시 토큰 제한 초과
- Parent의 대표 임베딩이 희석되어 검색 품질 저하

---

### 안티패턴 5: 메타데이터를 임베딩에 포함 (Metadata in Embedding)

**설명**
- 파일 경로, 타임스탬프 등 메타데이터를 임베딩 텍스트에 포함

**유혹적인 이유**
- "source: document.pdf" 같은 정보가 검색에 도움될 것 같은 기대
- 모든 정보를 하나의 벡터에 담으려는 욕심

**실패하는 이유**
- 임베딩 공간에 무관한 노이즈 추가
- 메타데이터는 구조화 필터링으로 처리해야 효과적
- 벡터 유사도 계산에 불필요한 정보가 영향을 미침

---

### 안티패턴 6: 계층 구조 무시 (Flat Embedding Space)

**설명**
- 모든 Fragment를 동등한 수준의 평면적 엔티티로 취급

**유혹적인 이유**
- 구현이 단순함 (계층 추적 불필요)
- 벡터 저장소의 기본 사용 패턴과 일치

**실패하는 이유**
- 맥락 조립 불가 (검색된 Fragment의 상위 맥락을 알 수 없음)
- 중복 제거 어려움 (동일 Concept의 Fragment를 식별 불가)
- 검색 결과 그룹화 불가
- 사용자에게 출처 설명 불가

---

## 🔟 요약: AI 에이전트를 위한 아키텍처 계약

### 아키텍처 헌법 (Architecture Constitution)

다음 규칙은 **불가침**이며, 모든 구현은 이 규칙을 준수해야 한다.

---

#### 제1조: 엔티티 계층 준수

> 모든 데이터는 Document → Concept → Fragment 계층을 따른다.
> 계층을 우회하는 구현은 금지된다.

- Fragment는 반드시 하나의 Concept에 귀속된다
- Concept은 반드시 하나의 Document에 귀속된다
- 고아 엔티티(orphan entity)는 존재해서는 안 된다

---

#### 제2조: 임베딩 대상 명확화

> 임베딩되는 것과 되지 않는 것은 명시적으로 정의되어야 한다.
> 암묵적인 임베딩은 금지된다.

- Fragment: 임베딩됨 (조건: 최소 길이 충족)
- Concept 대표 임베딩: 선택적으로 임베딩됨
- Document: 임베딩되지 않음
- 메타데이터: 임베딩되지 않음

---

#### 제3조: 소유권 체인 유지

> 모든 임베딩은 추적 가능한 소유권 체인을 가진다.
> 체인이 끊어진 임베딩은 무효화 대상이다.

```
Embedding → Fragment → Concept → Document → Source File
```

- 체인의 어느 지점에서든 삭제가 발생하면 하위 모든 임베딩 무효화
- 소유권 체인은 doc_id로 추적됨

---

#### 제4조: 뷰는 속성이다

> 뷰(text, code, image)는 Fragment의 속성이지 독립 엔티티가 아니다.
> 뷰를 최상위 엔티티로 취급하는 구현은 금지된다.

- 동일 Concept 내 여러 뷰의 Fragment가 공존
- 뷰별 필터링은 허용되나 뷰별 분리 저장은 지양

---

#### 제5조: 검색과 맥락의 분리

> 검색 대상(Fragment 임베딩)과 맥락 제공자(Parent 문서)는 분리된다.
> 혼용하는 구현은 금지된다.

- 검색: Fragment 임베딩 대상
- 맥락: Parent 문서에서 제공
- 검색 결과는 반드시 맥락과 함께 반환

---

#### 제6조: 콘텐츠 기반 식별

> 임베딩 ID는 콘텐츠 기반으로 결정적(deterministic)으로 생성된다.
> 랜덤 ID 생성은 금지된다.

- `doc_id = hash(parent_id + view + lang + content)`
- 동일 콘텐츠는 항상 동일 ID
- 중복 임베딩 자동 방지

---

### 설계 리뷰 트리거

다음 상황에서는 **반드시 설계 리뷰**를 수행해야 한다:

1. **새로운 엔티티 유형 추가** 시
   - Document, Concept, Fragment 외의 새로운 최상위 엔티티 도입

2. **임베딩 대상 변경** 시
   - 기존에 임베딩되지 않던 것을 임베딩하려 할 때
   - 기존에 임베딩되던 것을 제외하려 할 때

3. **소유권 체인 변경** 시
   - parent_id 결정 로직 변경
   - 새로운 계층 추가 또는 제거

4. **검색 파이프라인 구조 변경** 시
   - 단계 추가, 제거, 순서 변경
   - 새로운 필터링/랭킹 로직 도입

5. **저장 스키마 변경** 시
   - 새로운 인덱스 추가
   - 메타데이터 필드 추가/제거

---

### AI 에이전트 행동 규칙

**MUST (반드시 해야 함)**
- 모든 Fragment에 유효한 parent_id 할당
- 임베딩 전 최소 길이 검증
- 콘텐츠 기반 doc_id 생성
- 삭제 시 소유권 체인 전체 무효화

**MUST NOT (절대 하지 않음)**
- 고아 임베딩 생성
- 메타데이터를 임베딩 텍스트에 포함
- 랜덤 ID로 임베딩 식별
- Parent 문서 없이 Fragment만 저장

**SHOULD (권장)**
- 뷰별 특화 청킹 전략 적용
- 검색 결과에 맥락 포함
- 중복 임베딩 사전 검사

**SHOULD NOT (지양)**
- 고정 크기 청킹만 의존
- 모든 텍스트 무조건 임베딩
- 계층 구조 평면화

---

## 부록: 용어 정의

| 용어 | 정의 |
|------|------|
| Document | 시스템에 입력되는 최상위 단위 (파일) |
| Concept | 의미적으로 응집된 정보 단위 (Semantic Parent) |
| Fragment | Concept을 구성하는 개별 정보 조각 (Child) |
| View | Fragment의 콘텐츠 유형 (text, code, image 등) |
| Embedding | Fragment 또는 Concept의 벡터 표현 |
| Representative Embedding | Concept 전체를 대표하는 단일 임베딩 |
| Supporting Embedding | 개별 Fragment의 상세 임베딩 |
| Parent Document | Concept의 전체 맥락을 담은 문서 |
| Semantic Owner | 임베딩이 귀속되는 상위 엔티티 |
| doc_id | 콘텐츠 기반 결정적 임베딩 식별자 |

---

*이 문서는 OCR 기반 문서 인텔리전스 & 벡터 검색 시스템의 아키텍처 진실 원천입니다.*
*최종 수정: 2025-01-XX*
