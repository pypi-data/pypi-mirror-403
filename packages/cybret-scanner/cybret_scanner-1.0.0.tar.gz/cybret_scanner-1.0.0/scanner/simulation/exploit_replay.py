"""
Intent Violation Replay - THE KILLER FEATURE

For every vulnerability, generates:
- Exact attack sequence
- Business impact calculation
- PoC code (curl commands, Python code)
- Step-by-step explanation

This transforms "you have a vulnerability" into "here's how attackers exploit it."
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum


class AttackStep:
    """Single step in an attack sequence"""

    def __init__(
        self,
        step_number: int,
        action: str,
        actor: str,
        endpoint: str,
        payload: Optional[Dict] = None,
        expected_result: str = "",
        actual_result: str = "",
    ):
        self.step_number = step_number
        self.action = action
        self.actor = actor
        self.endpoint = endpoint
        self.payload = payload or {}
        self.expected_result = expected_result
        self.actual_result = actual_result

    def to_curl(self, base_url: str = "http://localhost:5000") -> str:
        """Generate curl command for this step"""
        if "GET" in self.action:
            return f"curl -X GET {base_url}{self.endpoint}"
        elif "POST" in self.action:
            import json
            payload_str = json.dumps(self.payload, indent=2)
            return f"curl -X POST {base_url}{self.endpoint} \\\n  -H 'Content-Type: application/json' \\\n  -d '{payload_str}'"
        return f"curl {base_url}{self.endpoint}"

    def to_dict(self) -> Dict:
        return {
            "step": self.step_number,
            "action": self.action,
            "actor": self.actor,
            "endpoint": self.endpoint,
            "payload": self.payload,
            "expected_result": self.expected_result,
            "actual_result": self.actual_result,
        }


@dataclass
class BusinessImpact:
    """Quantified business impact of exploitation"""
    financial_loss: str  # "$120,000 potential loss"
    affected_users: str  # "All users (10,000+)"
    data_exposure: str  # "SSN, credit card numbers exposed"
    compliance_risk: str  # "GDPR violation, $50M fine risk"


@dataclass
class ExploitReplay:
    """
    Complete exploit replay showing HOW to exploit a vulnerability

    This is what differentiates next-level scanners:
    - Not just "IDOR exists"
    - But "Here's how to steal $120k"
    """
    vuln_id: str
    vuln_type: str
    title: str
    severity: str

    # THE KILLER FEATURE: Exact attack sequence
    attack_steps: List[AttackStep] = field(default_factory=list)

    # Business impact
    business_impact: Optional[BusinessImpact] = None

    # Technical details
    invariant_violated: str = ""
    root_cause: str = ""

    # Proof of concept
    poc_curl: List[str] = field(default_factory=list)
    poc_python: str = ""

    # Remediation
    fix_code: str = ""
    fix_explanation: str = ""

    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON export"""
        return {
            "vulnerability": {
                "id": self.vuln_id,
                "type": self.vuln_type,
                "title": self.title,
                "severity": self.severity,
            },
            "exploit": {
                "steps": [step.to_dict() for step in self.attack_steps],
                "invariant_violated": self.invariant_violated,
                "root_cause": self.root_cause,
            },
            "business_impact": {
                "financial_loss": self.business_impact.financial_loss if self.business_impact else "Unknown",
                "affected_users": self.business_impact.affected_users if self.business_impact else "Unknown",
                "data_exposure": self.business_impact.data_exposure if self.business_impact else "None identified",
                "compliance_risk": self.business_impact.compliance_risk if self.business_impact else "Unknown",
            } if self.business_impact else None,
            "proof_of_concept": {
                "curl_commands": self.poc_curl,
                "python_code": self.poc_python,
            },
            "remediation": {
                "fix_code": self.fix_code,
                "explanation": self.fix_explanation,
            }
        }

    def generate_markdown_report(self) -> str:
        """Generate markdown report for this exploit"""
        md = f"# {self.title}\n\n"
        md += f"**Vulnerability ID:** `{self.vuln_id}`\n"
        md += f"**Type:** {self.vuln_type}\n"
        md += f"**Severity:** {self.severity}\n\n"

        md += "## ðŸŽ¯ Attack Sequence\n\n"
        for step in self.attack_steps:
            md += f"### Step {step.step_number}: {step.action}\n"
            md += f"- **Actor:** {step.actor}\n"
            md += f"- **Endpoint:** `{step.endpoint}`\n"
            if step.payload:
                md += f"- **Payload:** `{step.payload}`\n"
            md += f"- **Result:** {step.actual_result}\n\n"

        if self.business_impact:
            md += "## ðŸ’° Business Impact\n\n"
            md += f"- **Financial Loss:** {self.business_impact.financial_loss}\n"
            md += f"- **Affected Users:** {self.business_impact.affected_users}\n"
            md += f"- **Data Exposure:** {self.business_impact.data_exposure}\n"
            md += f"- **Compliance Risk:** {self.business_impact.compliance_risk}\n\n"

        md += "## ðŸ” Technical Analysis\n\n"
        md += f"**Invariant Violated:** {self.invariant_violated}\n\n"
        md += f"**Root Cause:** {self.root_cause}\n\n"

        md += "## ðŸ’» Proof of Concept\n\n"
        md += "### cURL Commands\n\n"
        for i, curl_cmd in enumerate(self.poc_curl, 1):
            md += f"```bash\n# Step {i}\n{curl_cmd}\n```\n\n"

        if self.poc_python:
            md += "### Python Code\n\n"
            md += f"```python\n{self.poc_python}\n```\n\n"

        md += "## âœ… Remediation\n\n"
        if self.fix_code:
            md += "### Fix Code\n\n"
            md += f"```python\n{self.fix_code}\n```\n\n"
        md += f"**Explanation:** {self.fix_explanation}\n\n"

        return md


class ExploitReplayGenerator:
    """
    Generates exploit replays for vulnerabilities

    This turns abstract vulnerabilities into concrete attack scenarios.
    """

    def __init__(self, driver=None, database: str = "neo4j"):
        self.driver = driver
        self.database = database

    def generate_idor_replay(
        self,
        vuln: Dict,
        target_resource: str = "document"
    ) -> ExploitReplay:
        """
        Generate exploit replay for IDOR vulnerability

        Args:
            vuln: Vulnerability dictionary
            target_resource: Resource being accessed (document, order, user)

        Returns:
            ExploitReplay with attack sequence
        """
        replay = ExploitReplay(
            vuln_id=vuln.get("vuln_id", "IDOR-DEMO"),
            vuln_type="IDOR (Insecure Direct Object Reference)",
            title=f"IDOR: Unauthorized Access to {target_resource.title()}",
            severity="CRITICAL",
        )

        # Build attack sequence
        replay.attack_steps = [
            AttackStep(
                step_number=1,
                action="Authenticate as User A",
                actor="attacker (User A)",
                endpoint="/api/login",
                payload={"username": "user_a", "password": "password123"},
                expected_result="Receive authentication token",
                actual_result="token_abc123 received"
            ),
            AttackStep(
                step_number=2,
                action=f"Access User A's {target_resource}",
                actor="attacker (User A)",
                endpoint=f"/api/{target_resource}/100",
                expected_result="Success - User A owns this resource",
                actual_result=f"User A's {target_resource} #100 retrieved"
            ),
            AttackStep(
                step_number=3,
                action=f"Access User B's {target_resource} (IDOR)",
                actor="attacker (User A)",
                endpoint=f"/api/{target_resource}/200",
                expected_result="Forbidden - User A doesn't own resource #200",
                actual_result=f"SUCCESS! User B's {target_resource} #200 retrieved (VULNERABILITY)"
            ),
        ]

        # Business impact
        replay.business_impact = BusinessImpact(
            financial_loss="Potential $50,000-$500,000 loss depending on data value",
            affected_users="All users in the system",
            data_exposure="Full access to all user documents/orders/profiles",
            compliance_risk="GDPR/CCPA violation - $50M+ fine risk"
        )

        # Invariant violated
        replay.invariant_violated = f"Users should only access their own {target_resource}s (owner_id must match current_user.id)"

        # Root cause
        endpoint = vuln.get("file_path", "unknown.py")
        line = vuln.get("line_start", "?")
        replay.root_cause = (
            f"Endpoint at {endpoint}:{line} retrieves {target_resource} by ID "
            f"without verifying ownership. Missing check: `if {target_resource}.user_id != current_user.id: raise Forbidden`"
        )

        # PoC curl commands
        replay.poc_curl = [
            step.to_curl() for step in replay.attack_steps
        ]

        # PoC Python code
        replay.poc_python = f'''import requests

# Step 1: Authenticate as User A
login_response = requests.post(
    "http://localhost:5000/api/login",
    json={{"username": "user_a", "password": "password123"}}
)
token = login_response.json()["token"]

# Step 2: Access own {target_resource} (legitimate)
my_resource = requests.get(
    "http://localhost:5000/api/{target_resource}/100",
    headers={{"Authorization": f"Bearer {{token}}"}}
)
print("My {target_resource}:", my_resource.json())

# Step 3: Access another user's {target_resource} (IDOR attack!)
stolen_resource = requests.get(
    "http://localhost:5000/api/{target_resource}/200",
    headers={{"Authorization": f"Bearer {{token}}"}}
)

if stolen_resource.status_code == 200:
    print("VULNERABILITY CONFIRMED!")
    print("Stolen {target_resource}:", stolen_resource.json())
else:
    print("Protected (no vulnerability)")
'''

        # Fix code
        replay.fix_code = f'''@app.route('/api/{target_resource}/<{target_resource}_id>')
@login_required
def get_{target_resource}({target_resource}_id):
    """Fixed: Added ownership check"""
    session = Session()
    {target_resource} = session.query({target_resource.title()}).filter_by(id={target_resource}_id).first()

    # FIX: Verify ownership
    if {target_resource}.user_id != current_user.id:
        return jsonify({{"error": "Forbidden"}}), 403

    return jsonify({target_resource}.to_dict())
'''

        replay.fix_explanation = (
            f"Add ownership verification before returning the {target_resource}. "
            f"Check that {target_resource}.user_id matches current_user.id. "
            f"This ensures users can only access their own resources."
        )

        return replay

    def generate_auth_bypass_replay(self, vuln: Dict) -> ExploitReplay:
        """Generate exploit replay for authentication bypass"""
        replay = ExploitReplay(
            vuln_id=vuln.get("vuln_id", "AUTH-BYPASS-DEMO"),
            vuln_type="Authentication Bypass",
            title="Authentication Bypass via Debug Flag",
            severity="CRITICAL",
        )

        replay.attack_steps = [
            AttackStep(
                step_number=1,
                action="Attempt normal login with wrong credentials",
                actor="attacker",
                endpoint="/api/login?username=admin&password=wrong",
                expected_result="401 Unauthorized",
                actual_result="401 Unauthorized"
            ),
            AttackStep(
                step_number=2,
                action="Exploit debug bypass parameter",
                actor="attacker",
                endpoint="/api/login?username=admin&debug=true",
                payload={"username": "admin", "debug": "true"},
                expected_result="401 Unauthorized (debug should be disabled)",
                actual_result="200 OK - Received admin token! (VULNERABILITY)"
            ),
            AttackStep(
                step_number=3,
                action="Access admin endpoints with bypassed token",
                actor="attacker",
                endpoint="/api/admin/users",
                expected_result="Forbidden",
                actual_result="SUCCESS! Retrieved all users (VULNERABILITY)"
            ),
        ]

        replay.business_impact = BusinessImpact(
            financial_loss="Complete system compromise - unlimited",
            affected_users="All users and administrators",
            data_exposure="Full database access, all user PII",
            compliance_risk="Critical - immediate breach notification required"
        )

        replay.invariant_violated = "Authentication must always be enforced - no debug bypasses in production"

        endpoint = vuln.get("file_path", "unknown.py")
        line = vuln.get("line_start", "?")
        replay.root_cause = (
            f"Endpoint at {endpoint}:{line} contains debug bypass logic that skips authentication. "
            f"Condition `if debug == 'true'` grants access without credential verification."
        )

        replay.poc_curl = [step.to_curl() for step in replay.attack_steps]

        replay.poc_python = '''import requests

# Exploit debug bypass
response = requests.post(
    "http://localhost:5000/api/login",
    json={"username": "admin", "debug": "true"}
)

if response.status_code == 200:
    token = response.json()["token"]
    print("VULNERABILITY CONFIRMED! Got admin token:", token)

    # Access admin endpoints
    users = requests.get(
        "http://localhost:5000/api/admin/users",
        headers={"Authorization": f"Bearer {token}"}
    )
    print("Stolen user data:", users.json())
'''

        replay.fix_code = '''@app.route('/api/login')
def login():
    """Fixed: Removed debug bypass"""
    username = request.args.get('username')
    password = request.args.get('password')

    # REMOVED DANGEROUS CODE:
    # if debug == 'true' or username == 'admin':
    #     return jsonify({'token': 'debug_token_12345', 'user': 'admin'})

    # Only legitimate authentication
    session = Session()
    user = session.query(User).filter_by(username=username).first()
    if user and user.check_password(password):
        return jsonify({'token': generate_token(user)})

    return jsonify({'error': 'Invalid credentials'}), 401
'''

        replay.fix_explanation = (
            "Remove ALL debug/test bypasses from authentication logic. "
            "Never deploy code with debug flags that skip security checks. "
            "Use environment-based configuration for testing, not runtime parameters."
        )

        return replay

    def generate_privilege_escalation_replay(self, vuln: Dict) -> ExploitReplay:
        """Generate exploit replay for privilege escalation"""
        replay = ExploitReplay(
            vuln_id=vuln.get("vuln_id", "PRIV-ESC-DEMO"),
            vuln_type="Privilege Escalation",
            title="Privilege Escalation via Mass Assignment",
            severity="CRITICAL",
        )

        replay.attack_steps = [
            AttackStep(
                step_number=1,
                action="Register as normal user",
                actor="attacker",
                endpoint="/api/register",
                payload={"username": "attacker", "email": "attacker@evil.com"},
                expected_result="User account created with role='user'",
                actual_result="User #123 created, role='user'"
            ),
            AttackStep(
                step_number=2,
                action="Update profile with mass assignment attack",
                actor="attacker (user #123)",
                endpoint="/api/user/123",
                payload={"name": "Attacker", "role": "admin"},
                expected_result="Forbidden - role field should be protected",
                actual_result="SUCCESS! Role updated to 'admin' (VULNERABILITY)"
            ),
            AttackStep(
                step_number=3,
                action="Access admin endpoints",
                actor="attacker (now admin)",
                endpoint="/api/admin/delete_user/999",
                expected_result="Forbidden (was normal user)",
                actual_result="User #999 deleted successfully (VULNERABILITY)"
            ),
        ]

        replay.business_impact = BusinessImpact(
            financial_loss="$100,000+ from unauthorized admin actions",
            affected_users="All users (attacker has admin access)",
            data_exposure="Complete database access and modification rights",
            compliance_risk="Critical security breach - immediate response required"
        )

        replay.invariant_violated = "Users cannot modify their own roles or permissions"

        endpoint = vuln.get("file_path", "unknown.py")
        line = vuln.get("line_start", "?")
        replay.root_cause = (
            f"Endpoint at {endpoint}:{line} accepts all user input without field filtering. "
            f"Mass assignment allows users to modify sensitive fields like 'role', 'is_admin', 'permissions'."
        )

        replay.poc_curl = [step.to_curl() for step in replay.attack_steps]

        replay.poc_python = '''import requests

# Step 1: Register
register_resp = requests.post(
    "http://localhost:5000/api/register",
    json={"username": "attacker", "password": "evil123"}
)
user_id = register_resp.json()["user_id"]

# Step 2: Escalate privileges via mass assignment
escalate_resp = requests.post(
    f"http://localhost:5000/api/user/{user_id}",
    json={"name": "Attacker", "role": "admin"}  # Inject admin role!
)

if escalate_resp.status_code == 200:
    print("VULNERABILITY CONFIRMED! Escalated to admin")

    # Step 3: Abuse admin privileges
    delete_resp = requests.post(
        "http://localhost:5000/api/admin/delete_user/999"
    )
    print("Deleted user:", delete_resp.json())
'''

        replay.fix_code = '''@app.route('/api/user/<user_id>', methods=['POST'])
@login_required
def update_user(user_id):
    """Fixed: Field whitelist prevents mass assignment"""

    # WHITELIST of allowed fields
    ALLOWED_FIELDS = ['name', 'email', 'profile_picture']

    # Filter input to only allowed fields
    user_data = request.json
    filtered_data = {k: v for k, v in user_data.items() if k in ALLOWED_FIELDS}

    # Verify user can only update themselves
    if int(user_id) != current_user.id:
        return jsonify({"error": "Forbidden"}), 403

    session = Session()
    user = session.query(User).get(user_id)

    # Only update whitelisted fields
    for field, value in filtered_data.items():
        setattr(user, field, value)

    session.commit()
    return jsonify({'message': 'Profile updated'})
'''

        replay.fix_explanation = (
            "Implement field whitelisting to prevent mass assignment attacks. "
            "Only allow users to modify safe fields like name, email, profile_picture. "
            "Never allow modification of sensitive fields like role, is_admin, permissions. "
            "Use separate admin-only endpoints for privilege changes."
        )

        return replay
