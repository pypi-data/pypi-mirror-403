# SPDX-License-Identifier: LGPL-3.0-or-later
"""Tests for neighbor list functionality in torch-admp.

This module contains tests to verify the correctness of neighbor list
implementations, including comparisons with reference implementations
and consistency checks between different neighbor list methods.
"""

import unittest

import freud
import numpy as np
import torch

from torch_admp import env, nblist
from torch_admp.nblist import TorchNeighborList
from torch_admp.utils import to_numpy_array, to_torch_tensor

from . import SEED
from .common import run_test_without_packages


class TestTorchNeighborList(unittest.TestCase):
    """Test class for TorchNeighborList functionality.

    Tests that the TorchNeighborList correctly identifies atom pairs
    within the cutoff distance, comparing against freud reference data.
    """

    def setUp(self):
        """Set up test data for TorchNeighborList testing.

        Creates reference neighbor list data using freud and initializes
        TorchNeighborList with test positions and box.
        """
        # Set random generators with SEED for reproducibility
        np_rng = np.random.default_rng(SEED)
        # torch_rng = torch.Generator().manual_seed(SEED)

        # reference data
        rcut = 4.0
        l_box = 10.0
        box = np.diag([l_box, l_box, l_box])
        positions = np_rng.random((20, 3)) * l_box

        fbox = freud.box.Box.from_matrix(box)
        aq = freud.locality.AABBQuery(fbox, positions)
        res = aq.query(positions, dict(r_max=rcut, exclude_ii=True))
        nblist = res.toNeighborList()
        nblist = np.vstack((nblist[:, 0], nblist[:, 1])).T
        nblist = nblist.astype(np.int32)
        msk = (nblist[:, 0] - nblist[:, 1]) < 0
        self.nblist_ref = nblist[msk]

        self.nblist = TorchNeighborList(rcut)
        self.positions = to_torch_tensor(positions).to(env.GLOBAL_PT_FLOAT_PRECISION)
        self.box = to_torch_tensor(box).to(env.GLOBAL_PT_FLOAT_PRECISION)

    def test_pairs(self):
        """Check that pairs are in the neighbor list.

        Verifies that all pairs identified by TorchNeighborList are
        present in the reference neighbor list from freud.
        """
        pairs = self.nblist(self.positions, self.box)
        pairs = to_numpy_array(pairs)
        mask = pairs[:, 0] < pairs[:, 1]
        assert len(pairs[mask]) == len(self.nblist_ref)
        for p in pairs[mask]:
            mask = (self.nblist_ref[:, 0] == p[0]) & (self.nblist_ref[:, 1] == p[1])
            self.assertTrue(mask.any())


class TestNBList(unittest.TestCase):
    """Test class for neighbor list consistency.

    Tests consistency between different neighbor list implementations
    to ensure they produce identical results.
    """

    def setUp(self) -> None:
        """Set up test data for neighbor list consistency testing.

        Creates random atomic positions in a periodic box and initializes
        parameters for neighbor list testing.
        """
        # Set random generators with SEED for reproducibility
        np_rng = np.random.default_rng(SEED)
        # torch_rng = torch.Generator().manual_seed(SEED)

        # reference data
        l_box = 10.0
        box = np.diag([l_box, l_box, l_box])
        positions = np_rng.random((100, 3)) * l_box

        self.positions = to_torch_tensor(positions).to(env.GLOBAL_PT_FLOAT_PRECISION)
        self.box = to_torch_tensor(box).to(env.GLOBAL_PT_FLOAT_PRECISION)

        # test: cutoff > l_box / 2!!!
        self.rcut = 6.0
        self.nnei = 150

    def test_consistent(self):
        """Test consistency between different neighbor list implementations.

        Compares neighbor lists generated by nblist.dp_nblist and nblist.vesin_nblist
        to ensure they produce identical pairs and distances.
        """
        # test with deepmd
        self._test_consistent()
        # test without deepmd
        # expect: import error inside the function
        with self.assertRaises(ImportError):
            run_test_without_packages(
                func=self._test_consistent,
                pkg_names="deepmd*",
                reload_module=nblist,
            )
        # test without vesin
        # expect: import error inside the function
        with self.assertRaises(ImportError):
            run_test_without_packages(
                func=self._test_consistent,
                pkg_names="vesin*",
                reload_module=nblist,
            )

    def _test_consistent(self):
        pairs_1, ds_1, _buffer_scales = nblist.dp_nblist(
            self.positions, self.box, self.nnei, self.rcut
        )
        pairs_2, ds_2, _buffer_scales = nblist.vesin_nblist(
            self.positions, self.box, self.rcut
        )
        torch.testing.assert_close(
            nblist.sort_pairs(pairs_1), nblist.sort_pairs(pairs_2)
        )
        torch.testing.assert_close(torch.sort(ds_1)[0], torch.sort(ds_2)[0])
