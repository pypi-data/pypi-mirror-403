# ABOUTME: Auto-analysis result models
# ABOUTME: Defines algorithm types and analysis result structures

from datetime import UTC, datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, ConfigDict, Field


class AlgorithmType(str, Enum):
    """Available auto-analysis algorithms."""

    POCKET = "pocket"  # Cavity detection via voxel flood-fill
    NORMAL_OFFSET = "normal_offset"  # Surface-relative offset regions
    FLOOD_FILL = "flood_fill"  # Exterior flood fill from sky for EMPTY regions
    VOXEL_REGIONS = "voxel_regions"  # Underground regions via voxel classification for SOLID boxes
    NORMAL_IDW = "normal_idw"  # Inverse distance weighted normal sampling


ALL_ALGORITHMS = [
    AlgorithmType.POCKET,
    AlgorithmType.NORMAL_OFFSET,
    AlgorithmType.FLOOD_FILL,
    AlgorithmType.VOXEL_REGIONS,
    AlgorithmType.NORMAL_IDW,
]

# Default algorithms (excludes normal_idw which is opt-in)
DEFAULT_ALGORITHMS = [
    AlgorithmType.FLOOD_FILL,
    AlgorithmType.VOXEL_REGIONS,
    AlgorithmType.NORMAL_OFFSET,
]


class GeneratedConstraint(BaseModel):
    """A constraint generated by auto-analysis.

    Wraps standard constraint data with algorithm metadata.
    """

    constraint: dict[str, Any] = Field(..., description="Constraint data (type, sign, geometry)")
    algorithm: AlgorithmType = Field(..., description="Algorithm that generated this")
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Algorithm's confidence in this constraint"
    )
    description: str = Field(..., description="Human-readable description")


class AlgorithmStats(BaseModel):
    """Statistics for a single algorithm's contribution."""

    constraints_generated: int = Field(0, description="Number of constraints from this algorithm")
    coverage_description: str = Field("", description="What this algorithm detected")


class AnalysisSummary(BaseModel):
    """Summary statistics for auto-analysis results."""

    total_constraints: int = Field(..., description="Total constraints generated")
    solid_constraints: int = Field(..., description="Constraints marking solid regions")
    empty_constraints: int = Field(..., description="Constraints marking empty regions")
    algorithms_contributing: int = Field(..., description="Number of algorithms that contributed")


class AnalysisResult(BaseModel):
    """Complete auto-analysis result with generated constraints.

    This is the primary return type from SDFAnalyzer.analyze().
    """

    model_config = ConfigDict(ser_json_timedelta="iso8601")

    analysis_id: str = Field(..., description="Unique identifier for this analysis")
    computed_at: datetime = Field(
        default_factory=lambda: datetime.now(UTC),
        description="When analysis was performed",
    )
    algorithms_run: list[str] = Field(..., description="Algorithms that were executed")
    summary: AnalysisSummary = Field(..., description="Aggregated statistics")
    algorithm_stats: dict[str, AlgorithmStats] = Field(
        default_factory=dict, description="Per-algorithm statistics"
    )
    generated_constraints: list[GeneratedConstraint] = Field(
        default_factory=list, description="Constraints ready for use"
    )

    @property
    def constraints(self) -> list[dict[str, Any]]:
        """Get just the constraint dicts for convenience."""
        return [gc.constraint for gc in self.generated_constraints]
