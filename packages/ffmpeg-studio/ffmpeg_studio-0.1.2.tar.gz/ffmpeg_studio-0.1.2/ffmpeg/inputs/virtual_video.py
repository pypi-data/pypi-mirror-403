from typing import Any, Literal, Optional

from .base_virtual_input import BaseVirtualInput


class VirtualVideo(BaseVirtualInput):
    """Generate video with ffmpeg"""

    def __init__(
        self,
        name: str,
        format: str = "lavfi",
        flags: Optional[dict[str, Any]] = None,
        **kwargs,
    ) -> None:
        super().__init__(name=name, format=format, flags=flags, **kwargs)

    @classmethod
    def from_cellauto(
        cls,
        width: int,
        height: int,
        duration: Optional[int] = None,
        pattern: Optional[int] = None,
        rate: Optional[int] = None,
        random_fill_ratio: Optional[float] = None,
        random_seed: Optional[int] = None,
        rule: Optional[int] = None,
        scroll: Optional[bool] = None,
        start_full: Optional[bool] = None,
        stitch: Optional[bool] = None,
    ):
        """
        Create a pattern generated by an elementary cellular automaton.
        The initial state of the cellular automaton can be defined through the filename and pattern options. If such options are not specified an initial state is created randomly.
        At each new frame a new row in the video is filled with the result of the cellular automaton next generation. The behavior when the whole frame is filled is defined by the scroll option.

        https://ffmpeg.org/ffmpeg-filters.html#cellauto
        """

        local_vars = locals()
        kwargs = {}
        for k, v in local_vars.items():
            if k in {"cls", "height", "width"}:
                continue

            kwargs.update(k=v)

        return cls(
            "cellauto",
            size=f"{width}x{height}",
            flags=dict(t=duration),  # this filter does not take duration like normal
            **kwargs,
        )

    @classmethod
    def from_life(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 30,
        mold: int = 0,
        stitch: int = 1,
        rule: Optional[str] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height", "duration"}
        }
        return cls(
            "life",
            size=f"{width}x{height}",
            flags=dict(t=duration),  # this filter does not take duration like normal
            **kwargs,
        )

    @classmethod
    def from_mandelbrot(
        cls,
        width: int = 640,
        height: int = 480,
        duration: Optional[float] = None,
        rate: Optional[int] = None,
        end_pts: Optional[int] = None,
        end_scale: Optional[float] = None,
        inner: Optional[str] = None,
        bailout: Optional[float] = None,
        maxiter: Optional[int] = None,
        outer: Optional[str] = None,
        start_scale: Optional[float] = None,
        start_x: Optional[float] = None,
        start_y: Optional[float] = None,
    ):
        """
        Generate a Mandelbrot set fractal with zoom animation.

        https://ffmpeg.org/ffmpeg-filters.html#mandelbrot
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height", "duration"}
        }
        return cls(
            "mandelbrot",
            size=f"{width}x{height}",
            flags=dict(t=duration),  # this filter does not take duration like normal
            **kwargs,
        )

    @classmethod
    def from_gradients(
        cls,
        height: int,
        width: int,
        duration: Optional[float] = None,
        rate: Optional[int] = None,
        c0: Optional[str] = None,
        c1: Optional[str] = None,
        c2: Optional[str] = None,
        c3: Optional[str] = None,
        c4: Optional[str] = None,
        c5: Optional[str] = None,
        c6: Optional[str] = None,
        c7: Optional[str] = None,
        x0: Optional[int] = None,
        y0: Optional[int] = None,
        x1: Optional[int] = None,
        y1: Optional[int] = None,
        nb_colors: Optional[int] = None,
        seed: Optional[int] = None,
        speed: Optional[float] = None,
        type: Optional[
            Literal[
                "linear",
                "radial",
                "circular",
                "spiral",
                "square",
            ]
        ] = None,
    ):
        """
        Generate several animated gradients.

        https://ffmpeg.org/ffmpeg-filters.html#gradients
        """
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls("gradients", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_testsrc(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        decimals: Optional[int] = None,
    ):
        """
        Parameters:
            rate : set video rate (default "25")
            duration : set video duration (default -0.000001)
            sar : set video sample aspect ratio (from 0 to INT_MAX) (default 1/1)
            decimals : set number of decimals to show (from 0 to 17) (default 0)
        """
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls("testsrc", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_testsrc2(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        alpha: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls("testsrc2", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_smptehdbars(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls("smptehdbars", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_smptebars(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls("smptebars", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_sierpinski(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        from_sierpinski: Optional[int] = None,
        type: Optional[Literal["carpet", "triangle"]] = None,
        seed: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height", "duration"}
        }
        return cls(
            "sierpinski",
            size=f"{width}x{height}",
            flags=dict(t=duration),  # this filter does not take duration like normal
            **kwargs,
        )

    @classmethod
    def from_ddagrab(
        cls,
        width: int,
        height: int,
        output_idx: int,
        draw_mouse: Optional[bool] = None,
        rate: int = 30,
        offset_x: Optional[int] = None,
        offset_y: Optional[int] = None,
        output_fmt: Optional[
            Literal["auto", "8bit", "bgra", "10bit", "x2bgr10", "16bit", "rgbaf16"]
        ] = None,
        allow_fallback: Optional[bool] = None,
        force_fmt: Optional[bool] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls(
            "ddagrab",
            _size=f"{width}x{height}",
            **kwargs,
        )

    @classmethod
    def from_colorchart(
        cls,
        tile_width: int,
        tile_height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        preset: Optional[Literal["reference", "skintones"]] = None,
        seed: Optional[int] = None,
    ):

        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "tile_width", "tile_height"}
        }
        return cls(
            "colorchart",
            patch_size=f"{tile_width}x{tile_height}",
            _size=f"{tile_width * 6}x{tile_height * 4}",
            **kwargs,
        )

    @classmethod
    def from_color(
        cls,
        color: str,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        decimals: Optional[int] = None,
    ):
        """
        Parameters:
            color : set color
            duration: set video duration
            rate : set video rate (default "25")
            duration : set video duration (default -0.000001)
            sar : set video sample aspect ratio (from 0 to INT_MAX) (default 1/1)
            decimals : set number of decimals to show (from 0 to 17) (default 0)
        """
        local_vars = locals()
        kwargs = {
            k: v for k, v in local_vars.items() if k not in {"cls", "width", "height"}
        }
        return cls("color", size=f"{width}x{height}", **kwargs)
