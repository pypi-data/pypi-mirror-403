
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "mo"

@_ods_cext.register_operation(_Dialect)
class IfOp(_ods_ir.OpView):
  r"""
  The `mo.if` op takes an `i1` condition, a 'then' block and an 'else'
  block. If the condition is true, the 'then' block is run and the op
  returns the results of that block, otherwise the "else" block is
  run and its values are returned.
  
  The blocks have access to all outer values. The blocks must return
  values using the `mo.yield' op, and the returned values must match the
  types given in the `mo.if` result signature.
  
  Example:
  
  ```mlir
    %res = mo.if (%cond : !mo.tensor<[], bool>) -> !mo.tensor<?, f32> {
      %v1 = mo.add(%x, %y) : (!mo.tensor<?, f32>, !mo.tensor<?, f32>
                              ) -> !mo.tensor<?, f32>
      mo.yield %v1 : !mo.tensor<?, f32>
    } else {
      %v2 = mo.sub(%x, %y) : (!mo.tensor<?, f32>, !mo.tensor<?, f32>
                                ) -> !mo.tensor<?, f32>
      mo.yield %v2 : !mo.tensor<?, f32>
    }
  ```
  """

  OPERATION_NAME = "mo.if"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, cond, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def thenRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def elseRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def if_(results_, cond, *, output_param_decls=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, IfOp]:
  op = IfOp(results_=results_, cond=cond, outputParamDecls=output_param_decls, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FromTensorOp(_ods_ir.OpView):
  r"""
  Casts the input shape value to a shape-like tensor.
  
  Example:
  
  ```mlir
    %sh: !mosh.ape
    %sht = mo.shape.to_tensor(%sh) -> !mo.tensor<[2], si64>
  ```
  """

  OPERATION_NAME = "mo.shape.from_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shape_from_tensor(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FromTensorOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ToTensorOp(_ods_ir.OpView):
  r"""
  Casts the input shape value to a shape-like tensor.
  
  Example:
  
  ```mlir
    %sh: !mosh.ape
    %sht = mo.shape.to_tensor(%sh) -> !mo.tensor<[2], si64>
  ```
  """

  OPERATION_NAME = "mo.shape.to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shape_to_tensor(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ToTensorOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastToOp(_ods_ir.OpView):
  r"""
  Broadcasts the input tensor to the result tensor. The shape of the input and
  result tensors must not be unknown or contain unknown dimensions, but can be
  parametric.
  
  This op only has limited compile-time check on the validity of the target
  shape (we expect the user to add any necessary runtime checks); therefore it
  is not recommended for frontend conversion code to rely on this op (use
  `mo.broadcast_to` with a constant shape-like tensor instead).
  
  The broadcasting follows numpy semantics.
  
  Example:
  
  ```mlir
    %from: !mo.tensor<[3], f32>
    %res1 = mo.static.broadcast_to(%from)
      : !mo.tensor<[3], f32> -> !mo.tensor<[2, 3], f32>
    kgen.param.declare N = <...>
    %res2 = mo.static.broadcast_to(%from)
      : !mo.tensor<[3], f32> -> !mo.tensor<[N, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.static.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def static_broadcast_to(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BroadcastToOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the same underlying data, but different shape. The
  shape of the input and result tensors must not be unknown or contain unknown
  dimensions, but can be parametric. We do not allow inferred dimensions
  (e.g. -1 in MO_ReshapeOp).
  
  The op has no compile-time or runtime checks on the validity of the target
  shape (we expect the user to add any necessary runtime checks); therefore it
  is not recommended for frontend conversion code to rely on this op (use
  `mo.reshape` with a constant shape-like tensor instead).
  
  Example:
  
  ```mlir
    %from: !mo.tensor<[2, 3], f32>
    %res = mo.static.reshape(%from)
      : !mo.tensor<[2, 3], f32> -> !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.static.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def static_reshape(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReshapeOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AbsOp(_ods_ir.OpView):
  r"""
  Returns `abs(x)`, where `x` is the input tensors.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.abs(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def abs(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AbsOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  Returns `x + y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.add(%lhs, %rhs) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddSingletonDimOp(_ods_ir.OpView):
  r"""
  Adds a dimension of `1` to a shape at the given axis.
  
  Example:
  ```mlir
    mo.add_singleton_dim[1](%res): (!mo.tensor<[2, 3], f32>) -> !mo.tensor<[2, 1, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.add_singleton_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add_singleton_dim(result, input, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddSingletonDimOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllGatherOp(_ods_ir.OpView):
  r"""
  AllGather takes in inputs each coming from a different device and collects
  the data into an output tensor along the 0th dimension. The output is
  replicated across the same devices.
  """

  OPERATION_NAME = "mo.distributed.allgather"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, outChain, inputs, signalBuffers, inChain, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(signalBuffers))
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outputs)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def signalBuffers(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 2)
    return self.operation.operands[start]

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def distributed_allgather(outputs, out_chain, inputs, signal_buffers, in_chain, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AllGatherOp]:
  op = AllGatherOp(outputs=outputs, outChain=out_chain, inputs=inputs, signalBuffers=signal_buffers, inChain=in_chain, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class AllReduceSumOp(_ods_ir.OpView):
  r"""
  Allreduce takes in inputs each coming from a different device with
  the same shape as the final output and performs a sum reduction
  across the devices. This op instance executes on a specific device
  (specified by the device attribute) and produces the output for that device.
  
  Multiple instances of this op are created (one per device) to enable
  multi-threaded execution.
  """

  OPERATION_NAME = "mo.distributed.allreduce.sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, outChain, inputs, signalBuffers, inChain, device, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(signalBuffers))
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["device"] = (device if (
    isinstance(device, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('M_DeviceRefAttr')) else
      _ods_ir.AttrBuilder.get('M_DeviceRefAttr')(device, context=_ods_context))
    results = []
    results.append(output)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def signalBuffers(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 2, 0, 2)
    return self.operation.operands[start]

  @builtins.property
  def device(self) -> _ods_ir.Attribute:
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def distributed_allreduce_sum(output, out_chain, inputs, signal_buffers, in_chain, device, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return AllReduceSumOp(output=output, outChain=out_chain, inputs=inputs, signalBuffers=signal_buffers, inChain=in_chain, device=device, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  r"""
  Returns `x and y`, where `x` and `y` are input boolean tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = mo.and(%lhs, %rhs) : (!mo.tensor<[2, 3], bool>,
                                !mo.tensor<[2, 3], bool>
                                ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def and_(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgMaxOp(_ods_ir.OpView):
  r"""
  This op is equivalent to reduce_max, but returns indices instead of values.
  
  The axis attribute specifies the reduction axis.
  
  Like reductions, the output shape is the same as the input shape, except for
  the reduced axis which is set to 1. Moreover, the value of `axis` follows
  numpy semantics, e.g., -1 represents the last axis.
  
  For identical maximum values, the lowest index is returned.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<0, 1, 3, 2> : tensor<2x2xsi32>
    } : !mo.tensor<[2, 2], si32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<si32>
    } : !mo.tensor<[], si32>
    %1 = mo.arg_max(%0, %axis) : (!mo.tensor<[2, 2], si32>) -> !mo.tensor<[2, 1], si64>
  ```
  """

  OPERATION_NAME = "mo.arg_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def arg_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArgMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgMinOp(_ods_ir.OpView):
  r"""
  This op is equivalent to reduce_min, but returns indices instead of values.
  
  The axis attribute specifies the reduction axis.
  
  Like reductions, the output shape is the same as the input shape, except for
  the reduced axis which is set to 1. Moreover, the value of `axis` follows
  numpy semantics, e.g., -1 represents the last axis.
  
  For identical minimum values, the lowest index is returned.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<0, 1, 3, 2> : tensor<2x2xsi32>
    } : !mo.tensor<[2, 2], si32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<si32>
    } : !mo.tensor<[], si32>
    %1 = mo.arg_min(%0, %axis) : (!mo.tensor<[2, 2], si32>) -> !mo.tensor<[2, 1], si64>
  ```
  """

  OPERATION_NAME = "mo.arg_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def arg_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArgMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArgNonzeroOp(_ods_ir.OpView):
  r"""
  Returns a tensor of coordinates of the nonzero values in the given tensor.
  The return value is a 2D tensor of shape [nnz x rank_in], where nnz is the
  number of nonzero elements in the input tensor, and rank_in is the rank of
  the input tensor. Coordinates are generated in row-major order.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8> : tensor<3x3xsi32>
    } : !mo.tensor<[3, 3], si32>
    %1 = mo.arg_nonzero(%0) : (!mo.tensor<[3, 3], si32>) -> !mo.tensor<[?, 2], si32>
  ```
  """

  OPERATION_NAME = "mo.arg_nonzero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def arg_nonzero(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArgNonzeroOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssertOp(_ods_ir.OpView):
  r"""
  Asserts that a single boolean value is true.
  
  Currently bare assert operations are *not* used in MO graphs,
  rather they are wrapped first in a KGEN MLIR op attr, a KGEN apply
  attr and finally materialized as an actual operation via the KGENParamDeclare op.
  
  In order to properly materialize assert logic for a particular op and ensure
  the execution dependencies are properly tracked you must:
  
  1. Create each individual assert via calls to AssertOp's emitStaticCall method
  2. Supply all the asserts (really KGENParamDeclare ops) to the materializeAllAssertLogic
     function which will handle linking the individual assertions together via !mo.chains
     and materialize the remaining structures needed to properly track the execution
     dependencies from the asserts to their compute op.
  
  Example:
  
  ```mlir
  // When using emitStaticCall and materializeAllAssertLogic
  %X: mo.tensor<[D1, D2]>,
  %Y: mo.tensor<[D3, D4]>
  
  ...
  
  kgen.param.declare CH0:
    <apply(:(i1) -> !mo.chain "mo.assert"{message = "Error 1" : !kgen.string}, eq(D1, D3))>
  
  kgen.param.declare CH1:
    <apply(:(!mo.chain, i1) -> !mo.chain "mo.assert"{message = "Error 2" : !kgen.string}, CH0, eq(D2, D4))>
  
  %chain1 = mosh.param.to_value = <CH0>
  %chain2 = mosh.param.to_value = <CH1>
  
  %guard_chain = mo.chain.create(%chain1, %chain2)
  
  %Xp, Yp = mo.guard[%guard_chain](%X, %Y)
  
  ...
  
  %Z = mo.op(%Xp, %Yp)
  ```
  """

  OPERATION_NAME = "mo.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, message, *, inChain=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if inChain is not None: operands.append(inChain)
    operands.append(cond)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inChain(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[0]

  @builtins.property
  def cond(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def message(self) -> _ods_ir.Attribute:
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

  @builtins.property
  def chain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def assert_(cond, message, *, in_chain=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AssertOp(cond=cond, message=message, inChain=in_chain, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtanhOp(_ods_ir.OpView):
  r"""
  Returns `atanh(x)`, where `x` is input tensor.
  
  Example:
  ```mlir
    %arg : !mo.tensor<[2, 3], f32>
    %res = mo.atanh(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def atanh(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtanhOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPoolCeilOp(_ods_ir.OpView):
  r"""
  Computes average pooling with the given filter shape, strides, and dilations.
  
  The op supports 2d avg pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<3, 3> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = mo.avg_pool_ceil_mode_true(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[1, 4, 4, 1], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[1, 2, 2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.avg_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def avg_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AvgPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPoolOp(_ods_ir.OpView):
  r"""
  Computes average pooling with the given filter shape, strides, and dilations.
  
  The op supports 2D avg pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. `strides`, `dilations`, `padding`) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<1, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = mo.avg_pool(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[20, 10, 10, 32], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[20, 9, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "mo.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def avg_pool(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AvgPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BandPartOp(_ods_ir.OpView):
  r"""
  Copies a tensor setting everything outside central (diagonal) band of the
  matrices to zero, where all but the last two axes are effectively batches,
  and the last two axes define sub matrices.
  
  Assumes the input has dimensions [I, J, ..., M, N], then the output tensor
  has the same shape as the input, and the values values are given by
  
  out[i, j, ..., m, n] = in_band(m, n) * input[i, j,  ..., m, n].
  
  With the indicator function
  
  in_band(m, n) = ((num_lower < 0 || (m - n) <= num_lower)) &&
                   (num_upper < 0 || (n - m) <= num_upper))
  
  If `exclude` is set, the selection is reverted: The elements in band are set
  to zero while the elements outside the band are copied to the output tensor.
  
  Please explicitly note that with negative values, this kernel returns the
  entire lower or upper triangle of the matrix, and otherwise returns
  a diagonal band around the main diagonal of the matrix.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[3, 2, 3], f32>
    %num_lower = mo.constant {
      value = #M.dense_array<-1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %num_upper = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %exclude = mo.constant {
      value = #M.dense_array<0> : tensor<1xui8>} : !mo.tensor<[], bool>
    %res = mo.linalg.band_part(%arg, %num_lower, %num_upper, %exclude) : (
      !mo.tensor<[3, 2, 3], f32>, !mo.tensor<[], si64>, !mo.tensor<[], si64>,
      !mo.tensor<[], bool>
      ) -> !mo.tensor<[3, 2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.linalg.band_part"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, num_lower, num_upper, exclude, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(num_lower)
    operands.append(num_upper)
    operands.append(exclude)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def num_lower(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def num_upper(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def exclude(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def linalg_band_part(result, input, num_lower, num_upper, exclude, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BandPartOp(result=result, input=input, num_lower=num_lower, num_upper=num_upper, exclude=exclude, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BatchMatmulOp(_ods_ir.OpView):
  r"""
  Performs matrix multiplication on two batches of matrices, represented by
  two N-dimensional tensors.
  
  The last two dimensions of each input are the matrix dimensions.
  
  Example:
  
  ```mlir
    %lhs: ... !mo.tensor<[3, 4, 5], f32>
    %rhs: ... !mo.tensor<[3, 5, 6], f32>
    %res = mo.batch_matmul(%lhs, %rhs) :
      mo.tensor<[3, 4, 5], f32>, !mo.tensor<[3, 5, 6], f32>
    ) -> !mo.tensor<[3, 4, 6], f32>
  ```
  """

  OPERATION_NAME = "mo.batch_matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, transpose_b=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose_b is not None: attributes["transpose_b"] = (transpose_b if (
        isinstance(transpose_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(transpose_b, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def transpose_b(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["transpose_b"]

  @transpose_b.setter
  def transpose_b(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose_b"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def batch_matmul(result, input_a, input_b, *, transpose_b=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BatchMatmulOp(result=result, input_a=input_a, input_b=input_b, transpose_b=transpose_b, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BottomKOp(_ods_ir.OpView):
  r"""
  Computes the bottom (lowest) values and their corresponding indices in a
  tensor along a specified axis. Returned values along the axis are always
  sorted (stable).
  
  Example:
  ```mlir
    %in = mo.constant {
      value = #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11> : tensor<2x6xsi64>
    } : !mo.tensor<[2, 6], si64>
    %k = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<3> : tensor<si64> } : !mo.tensor<[], si64>
    %axis = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<si64> } : !mo.tensor<[], si64>
    %sorted = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<1xi1> } : !mo.tensor<[], bool>
    %values, %indices = mo.bottom_k(%in, %k, %axis, %sorted) : (
      !mo.tensor<[2, 6], si64>, !mo.tensor<[], si64>, !mo.tensor<[], si64>, !mo.tensor<[], bool>
    ) -> (
      !mo.tensor<[2, 3], si64>, !mo.tensor<[2, 3], si64>
    )
  ```
  """

  OPERATION_NAME = "mo.bottom_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def K(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def sorted(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def bottom_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return BottomKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BroadcastShapeOp(_ods_ir.OpView):
  r"""
  Returns the shape that two shapes would broadcast to under the numpy rules:
  
  1. Make the shapes the same rank by adding 1 to the front
     of the shorter shape
  2. Ensure each dimension is equal, either by matching them or promoting a 1
     to a larger number from the other shape
  
  Examples:
  
  ```mlir
  %arg1: !mo.tensor<[1, 2, 3], f32>
  %arg2: !mo.tensor<[4, 2, 1], f32>
  %inshape1 = mo.shape_of(%arg1) : (
    !mo.tensor<[1, 2, 3], f32>) -> !mo.tensor<[3], si64>
  %inshape2 = mo.shape_of(%arg2) : (
    !mo.tensor<[4, 2, 1], f32>) -> !mo.tensor<[3], si64>
  %shape1 = mo.broadcast_shape(%inshape1, %inshape2) : !mo.tensor<[3], si64>
  ```
  In this example, `shape1` will compute to [4, 2, 3]
  
  ```mlir
  %arg1: !mo.tensor<[10, 2, 1], f32>
  %arg2: !mo.tensor<[5], f32>
  %inshape1 = mo.shape_of(%arg1) : (
    !mo.tensor<[10, 2, 1], f32>) -> !mo.tensor<[3], si64>
  %inshape2 = mo.shape_of(%arg2) : (
    !mo.tensor<[5], f32>) -> !mo.tensor<[1], si64>
  %shape1 = mo.broadcast_shape(%inshape1, %inshape2) : !mo.tensor<[3], si64>
  ```
  In this example, `shape1` will compute to [10, 2, 5]
  """

  OPERATION_NAME = "mo.broadcast_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def broadcast_shape(shape, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BroadcastShapeOp(shape=shape, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastToOp(_ods_ir.OpView):
  r"""
  Broadcasts the input tensor to the specified shape.
  
  The broadcasting follows numpy semantics.
  
  Example:
  
  ```mlir
    %from: !mo.tensor<[3], f32>
    %to = mo.constant {
      value = #M.dense_array<2, 3> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %res = mo.broadcast_to(%from, %to) : (
      !mo.tensor<[3], f32>, !mo.tensor<[2], si64>) -> !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newShape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def broadcast_to(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BroadcastToOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCreateOp(_ods_ir.OpView):
  r"""
  This operation creates an uninitialized buffer with the specified shape and data type on a given device.
  The buffer is not initialized with any values, and the operation is intended for use cases where the buffer
  will be filled with data later in the computation.
  
  Example:
  ```mlir
  %buf = mo.buffer.create : !mo.buffer<[20, 20], f32, gpu:0>
  ```
  """

  OPERATION_NAME = "mo.buffer.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_create(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferCreateOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferTransferOp(_ods_ir.OpView):
  r"""
  This operation transfers data from a source buffer to a destination buffer.
  Both buffers must have the same shape and data type. The operation takes an input
  chain and produces an output chain to sequence the transfer with other operations.
  
  Example:
  ```mlir
  %outChain = mo.buffer.transfer[%inChain](%src, %dst) : !mo.buffer<[2,3], f32, gpu:0>, !mo.buffer<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.buffer.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, dst, inChain, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(src)
    operands.append(dst)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def dst(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer_transfer(src, dst, in_chain, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BufferTransferOp(src=src, dst=dst, inChain=in_chain, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  r"""
  This op calls a computation graph.
  
  Example:
  
  ```mlir
    %res = mo.call @gelu(%arg0) : (!mo.tensor<[4, 5], f32>) -> !mo.tensor<[4, 5], f32>
  ```
  """

  OPERATION_NAME = "mo.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, callee, *, prefix=None, outputParamDecls=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if prefix is not None: attributes["prefix"] = (prefix if (
        isinstance(prefix, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(prefix, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def prefix(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["prefix"]

  @prefix.setter
  def prefix(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["prefix"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, operands_, callee, *, prefix=None, output_param_decls=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallOp]:
  op = CallOp(results_=results_, operands_=operands_, callee=callee, prefix=prefix, outputParamDecls=output_param_decls, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  r"""
  Returns the input tensor, cast to the specified element type.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], i32>
    %res = mo.cast(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilOp(_ods_ir.OpView):
  r"""
  Returns the smallest largest integer greater than `x`, where `x` is input
  tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.ceil(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ceil(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CeilOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChainCreateOp(_ods_ir.OpView):
  r"""
  This operation consumes an arbitrary number of values and produces a chain.
  Can be used for the sequencing for side-effecting ops when they might
  depend on multiple other ops producing chains.
  
  ```mlir
  
  %ch0 = mo.assert ...
  %x = mo.matmul ....
  
  %ch1 = mo.chain.create(%ch0: !mo.chain, %x: mo.tensor)
  """

  OPERATION_NAME = "mo.chain.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def chain_create(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChainCreateOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatFromListOp(_ods_ir.OpView):
  r"""
  Concatenates tensors in the input list along a given dimension.
  
  This op concatenates tensors in the `input` list into an output tensor. The
  input tensors and output tensors all have the same shape except along the
  concatenation dimension `axis`. The size of the concatenation dimension in
  output tensor would have be the sum of sizes of the concatenation dimension
  in input tensors.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %list: !mo.list<!mo.tensor<[2, 3], f32>>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.concat_from_list[%axis: !mo.tensor<[], si64>](%list) :
      !mo.list<!mo.tensor<[2, 3], f32>> -> !mo.tensor<[2, ?], f32>
  ```
  """

  OPERATION_NAME = "mo.concat_from_list"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat_from_list(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatFromListOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  Concatenates the input tensors along a given dimension.
  
  `mo.concat` concatenates the `inputs` tensors into an output tensor. There
  must be at least 1 input tensor.
  
  The following constraints apply to the inputs/outputs:
  
  - The input tensors and output tensors all has the same shape except along
    the concatenation dimension `axis`.
  - The size of the concatenation dimension in output tensor have be the sum
    of sizes of the concatenation dimension in input tensors.
  - The element type of the input and output tensors must match.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg0: !mo.tensor<[2, 3], f32>
    %arg1: !mo.tensor<[2, 5], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.concat[%axis: !mo.tensor<[], si64>](%arg0, %arg1) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 5], f32>
    ) -> !mo.tensor<[2, 8], f32>
  ```
  """

  OPERATION_NAME = "mo.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, axis, inputs, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat(result, axis, inputs, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(result=result, axis=axis, inputs=inputs, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantExternalOp(_ods_ir.OpView):
  r"""
  Represents an undefined reference to an "external" constant.
  This constant's backing data is undefined at graph compile time, but all
  other attributes of the tensor are statically known.
  In a given mo.graph, mo.constant.external ops should be uniquely named.
  
  Currently, the `device` attribute on the op determines which device the
  weights registry pointers reside on.
  This should be checked at runtime.
  The device attribute and result type can mismatch only when the `device`
  attribute is on the host.
  This is to support mmap'ed weights, a common use case for external
  constants.
  
  TODO(MSDK-1060): implement the runtime check by storing device alongside
  runtime pointer in the weights registry.
  And emit an explicit mo.transfer in the graph API instead of implicitly
  inserting an HtoD copy in converting mo.constant.external to
  mgp.buffer.constant.external.
  
  If the `hasAlias` attribute is set to true, the external constant might be
  updated through external alias between graph invocation, and it will not
  be lifted to the init phase.
  
  Example:
  
  ```mlir
  %weight = mo.constant.external {
    align = 16 : ui64, device = #M.device_ref<"gpu", 0>, name = "foo"
  } : !mo.tensor<[4096, 4096], bf16>
  """

  OPERATION_NAME = "mo.constant.external"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, align, device, *, hasAlias=None, isPlaceholder=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["align"] = (align if (
    isinstance(align, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('UI64Attr')) else
      _ods_ir.AttrBuilder.get('UI64Attr')(align, context=_ods_context))
    attributes["device"] = (device if (
    isinstance(device, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('M_DeviceRefAttr')) else
      _ods_ir.AttrBuilder.get('M_DeviceRefAttr')(device, context=_ods_context))
    if hasAlias is not None: attributes["hasAlias"] = (hasAlias if (
        isinstance(hasAlias, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(hasAlias, context=_ods_context))
    if isPlaceholder is not None: attributes["isPlaceholder"] = (isPlaceholder if (
        isinstance(isPlaceholder, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(isPlaceholder, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def align(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["align"]

  @align.setter
  def align(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align"] = value

  @builtins.property
  def device(self) -> _ods_ir.Attribute:
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def hasAlias(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["hasAlias"]

  @hasAlias.setter
  def hasAlias(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hasAlias"] = value

  @builtins.property
  def isPlaceholder(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["isPlaceholder"]

  @isPlaceholder.setter
  def isPlaceholder(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isPlaceholder"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant_external(result, name, align, device, *, has_alias=None, is_placeholder=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantExternalOp(result=result, name=name, align=align, device=device, hasAlias=has_alias, isPlaceholder=is_placeholder, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  This op allows storing literal values inside the graph.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<1, 2, 3, 4> : tensor<2x2xsi32>
    } : !mo.tensor<[2, 2], si32>
  ```
  """

  OPERATION_NAME = "mo.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ElementsAttr')) else
      _ods_ir.AttrBuilder.get('ElementsAttr')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantScalarOp(_ods_ir.OpView):
  r"""
  Same as `mo.constant`, but specialized to scalar types.
  
  Example:
  
  ```mlir
    %0 = mo.constant.scalar { value = 3 : si64 } : !mo.scalar<si64>
  ```
  """

  OPERATION_NAME = "mo.constant.scalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1254')) else
      _ods_ir.AttrBuilder.get('anonymous_1254')(value, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant_scalar(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantScalarOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvOp(_ods_ir.OpView):
  r"""
  Computes the convolution product of the input with the given filter,
  strides, dilations, paddings, and groups.
  
  The op supports 1D-3D convolution, with the following layout assumptions:
  - input has channel last layout. For 2D, that's NHWC, i.e.,
    (batch_size, height, width, in_channels)
  - filter has layout RSCF, i.e.,
    (height, width, in_channels / num_groups, out_channels)
  
  `strides`, `dilations`, and `padding` must be of rank 1, or unranked.
  If the input has static rank, all hyperparameters with static shape must
  have sizes of `input_rank - 2`, except padding, which must have
  size `2 * (input_rank - 2)`. Individual elements in the hyperparameters
  apply to corresponding dimensions of the input (after ignoring the batch
  and channel dimensions), with padding representing a before/after pair for
  each axis.
  
  The padding values are expected to take the form (pad_dim1_before,
  pad_dim1_after, pad_dim2_before, pad_dim2_after...) and represent padding
  0's before and after the indicated *spatial* dimensions in `input`. In 2D
  Convolution, dim1 here represents H and dim2 represents W. In python like
  syntax, padding a 2x3 spatial `input` with [0, 1, 2, 1] would yield:
  
  ```python
  input = [
    [1, 2, 3],
    [4, 5, 6]
  ]
  # Shape is 2x3
  
  padded_input = [
    [0, 0, 1, 2, 3, 0],
    [0, 0, 4, 5, 6, 0]
    [0, 0, 0, 0, 0, 0]
  ]
  # Shape is 3x6
  ```
  
  The input, output and filter tensors' ranks must match if statically known.
  
  `num_groups` must be a ranked scalar. The number of input and output
  channels must both be divisible by the number of groups `num_groups`.
  
  This op currently only supports strides and padding on the input.
  
  Example:
  
  ```mlir
    %st = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %di = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %pa = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>}
      : !mo.tensor<[4], si64>
    %ng = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<si64>}
      : %!mo.tensor<[], si64>
    %res = mo.conv(%input, %filter) [strides = %st, dilations = %di, paddings = %pa, num_groups = %ng] : (
      !mo.tensor<[10, 5, 5, 32], f32>, !mo.tensor<[2, 2, 32, 64], f32>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>, !mo.tensor<[], si64>
    ) -> !mo.tensor<[10, 4, 4, 64], f32>
  ```
  """

  OPERATION_NAME = "mo.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(num_groups)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def num_groups(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conv(result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, num_groups=num_groups, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvTransposeOp(_ods_ir.OpView):
  r"""
  This op effectively computes the gradient of a convolution with
  respect to its input (as if the original convolution operation had the same
  filter and hyperparameters as this op). A visualization of the computation
  can be found in https://d2l.ai/chapter_computer-vision/transposed-conv.html.
  
  The op supports 1D-3D spatial dimensions, with the following layout
  assumptions (note the `out_channel` is w.r.t. the original convolution):
  - input has channel last layout.For 2D, that's NHWC, i.e.,
    (batch_size, height, width, out_channels)
  - filter has layout RSFC, i.e., (height, width, out_channels, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding, output_paddings) must
  be of rank 1, or unranked. If the input has static rank, all hyperparameters
  with static shape must have sizes of `input_rank - 2`, except padding, which
  must have size `2 * (input_rank - 2)`. Individual elements in the
  hyperparameters applies to corresponding dimensions of the input (after
  ignoring the batch and channel dimensions), with padding representing a
  before/after pair for each axis.
  
  The padding values are expected to take the form (pad_dim1_before,
  pad_dim1_after, pad_dim2_before, pad_dim2_after...) and represent padding
  0's before and after the indicated *spatial* dimensions in `input`. In 2D
  ConvTranspose, dim1 here represents H_out and dim2 represents W_out. In
  python like syntax, padding a 2x4 spatial `output` with [0, 1, 2, 1] would
  yield:
  
  ```python
  output = [
    [1, 2, 3, 4],
    [5, 6, 7, 8]
  ]
  # Shape is 2x4
  
  padded_input = [
    [3],
  ]
  # Shape is 1x1
  ```
  
  The `output_paddings` argument is meant to resolve the ambiguity of multiple
  potential output shapes when any stride is greater than 1. Basically,
  we'll add `output_paddings[i]` number of zeros at the end of output's ith
  axis. We only support output_paddings = 0.
  
  The input, output and filter tensors' ranks must match if statically known.
  
  Example:
  
  ```mlir
    %st = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %di = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %pa = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>}
      : !mo.tensor<[4], si64>
    %op = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %res = mo.conv_transpose(%input, %filter)
      [strides = %st, dilations = %di, paddings = %pa, output_paddings = %op] : (
      !mo.tensor<[10, 4, 4, 64], f32>, !mo.tensor<[2, 2, 32, 64], f32>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>,
      !mo.tensor<[2], si64>
    ) -> !mo.tensor<[10, 5, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "mo.conv_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(output_paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def output_paddings(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conv_transpose(result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvTransposeOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, output_paddings=output_paddings, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosOp(_ods_ir.OpView):
  r"""
  Returns `cos(x)`, where `x` is input tensor.
  
  Example:
  ```mlir
    %arg : !mo.tensor<[2, 3], f32>
    %res = mo.cos(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cos(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CosOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CumSumOp(_ods_ir.OpView):
  r"""
  Returns the cumulative summation of input tensors along an axis. By default,
  it copies the first element as is. If the `exclusive` attribute is set to 1,
  then the first element is excluded. The `reverse` attribute causes the
  summation to be done in the opposite direction of the axis.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example of outputs:
  
  ```
    input_x = [1, 2, 3]
    axis=0
    output = [1, 3, 6]
    exclusive=1
    output = [0, 1, 3]
    exclusive=0
    reverse=1
    output = [6, 5, 3]
    exclusive=1
    reverse=1
    output = [5, 3, 0]
  ```
  
  Example:
  
  ```mlir
  %arg: !mo.tensor<[2, 3], f32>
  %axis: !mo.tensor<[], i64>
  %res = mo.cumsum(%arg, %axis) {exclusive = 1 : index, reverse = 0 : index} : (
    !mo.tensor<[2, 3], f32>., !mo.tensor<[], i64>) -> !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.cumsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, exclusive, reverse, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exclusive"] = (exclusive if (
    isinstance(exclusive, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(exclusive, context=_ods_context))
    attributes["reverse"] = (reverse if (
    isinstance(reverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(reverse, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def exclusive(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["exclusive"]

  @exclusive.setter
  def exclusive(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exclusive"] = value

  @builtins.property
  def reverse(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cumsum(result, input, axis, exclusive, reverse, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CumSumOp(result=result, input=input, axis=axis, exclusive=exclusive, reverse=reverse, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  r"""
  The `symbol` attribute specifies which underlying Mojo kernel implements
  this operation. This kernel must be decorated with the appropriate decorator
  with the exact same symbol string.
  
  The `function` attribute specifies which labeled function the operation
  refers to. Examples: `mogg.shape`.
  
  Example:
  
  ```mlir
    %0 = mo.custom {symbol = "test_custom_op"}(%arg0)
      (!mo.tensor<[?], f32>) -> !mo.tensor<[?], f32>
  ```
  
  Corresponding kernel definition:
  
  ```mojo
    @register_internal("test_custom_op")
    fn foo(...):
      pass
  ```
  
  Also allows the definition of custom kernels that have side-effects on
  mo.buffer values via the use of chains.
  (Currently limited to NDBuffer based kernels).
  
  Nothing needs to change about the kernel definition, but now the custom op
  must take a `mo.buffer` operand for the value it wants to mutate and
  produce an output chain as its final result and take an input chain as its
  final operand.
  
  Example:
  
  ```mlir
  %ch1 = mo.custom {symbol = "test_mutable_op"}(%arg0, %ch0) :
    (!mo.buffer<[D1, D2], f32>, !mo.chain) -> !mo.chain
  ```
  ```mojo
    @register_internal("test_custom_op")
    fn foo(...):
      pass
  ```
  """

  OPERATION_NAME = "mo.custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, symbol, *, device=None, parameters=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["symbol"] = (symbol if (
    isinstance(symbol, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(symbol, context=_ods_context))
    if device is not None: attributes["device"] = (device if (
        isinstance(device, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('M_DeviceRefAttr')) else
          _ods_ir.AttrBuilder.get('M_DeviceRefAttr')(device, context=_ods_context))
    if parameters is not None: attributes["parameters"] = (parameters if (
        isinstance(parameters, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(parameters, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def symbol(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["symbol"]

  @symbol.setter
  def symbol(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbol"] = value

  @builtins.property
  def device(self) -> _ods_ir.Attribute:
    return self.operation.attributes["device"]

  @device.setter
  def device(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device"] = value

  @builtins.property
  def parameters(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def custom(results_, operands_, symbol, *, device=None, parameters=None, output_param_decls=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CustomOp]:
  op = CustomOp(results_=results_, operands_=operands_, symbol=symbol, device=device, parameters=parameters, outputParamDecls=output_param_decls, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DebugPrintOp(_ods_ir.OpView):
  r"""
  Prints a debug string. If a label attribute is supplied the string is printed with that label.
  Otherwise just the string is printed. For debugging and testing only.
  
  Example:
  ```mlir
    %ch0: !mo.chain
    %ch1 = mo.debug.print(%ch0) {value = "message", label = "label"}
  ```
  """

  OPERATION_NAME = "mo.debug.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, inChain, value, *, label=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def label(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def debug_print(in_chain, value, *, label=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DebugPrintOp(inChain=in_chain, value=value, label=label, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DebugTensorPrintOp(_ods_ir.OpView):
  r"""
  Prints a debug representation of argument input. If a label attribute
  is supplied the tensor contents is printed with that label. Otherwise
  just the tensor metadata is printed. For debugging and testing only.
  
  Example:
  ```mlir
    %arg: !mo.tensor<[5], f32>
    %ch0: !mo.chain
    %ch1 = mo.debug.tensor.print(%ch0, %arg) {label = "label"} : !mo.tensor<[5], f32>
  ```
  """

  OPERATION_NAME = "mo.debug.tensor.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, inChain, input, *, label=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inChain)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def label(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def debug_tensor_print(in_chain, input, *, label=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DebugTensorPrintOp(inChain=in_chain, input=input, label=label, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DebugTensorUnsafePrintOp(_ods_ir.OpView):
  r"""
  Deprecated use mo.debug.tensor.print instead to ensure proper sequencing
  of print operations.
  
  This is just kept around due to the Mojo Graph API not supporting chains at
  the time of writing.
  
  Prints a debug representation of argument input. If a label attribute
  is supplied the tensor contents is printed with that label. Otherwise
  just the tensor metadata is printed. For debugging and testing only.
  
  Example:
  ```mlir
    %arg: !mo.tensor<[5], f32>
    mo.debug.tensor.print(%arg) {label = "label"} : !mo.tensor<[5], f32>
  ```
  """

  OPERATION_NAME = "mo.debug.tensor.unsafe.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def label(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

def debug_tensor_unsafe_print(input, *, label=None, loc=None, ip=None) -> DebugTensorUnsafePrintOp:
  return DebugTensorUnsafePrintOp(input=input, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  r"""
  Returns `x / y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.div(%lhs, %rhs) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  r"""
  Returns `x == y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.equal(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                  !mo.tensor<[2, 3], f32>
                                  ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def equal(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return EqualOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ErfOp(_ods_ir.OpView):
  r"""
  Computes the Gauss error function of the input tensor elements.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.erf(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def erf(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ErfOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExpOp(_ods_ir.OpView):
  r"""
  Returns `exp(x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.exp(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def exp(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FloorOp(_ods_ir.OpView):
  r"""
  Returns the elementwise largest integer not greater than `x`, where `x` is
  input tensor.
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.floor(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def floor(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FloorOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherNdOp(_ods_ir.OpView):
  r"""
  Variant of `mo.gather` that accepts multi-dimensional indices.
  
  The last dimension stores the index whereas
  the outer dimensions act like batch dimensions. The size of the last
  dimension is at most the rank of the input. When the dimension size is less
  than the rank of the input, slices of the input are gathered, starting from
  the leftmost dimension.
  
  ```
  output_shape = (
        input.shape[:batch_dims]
      + indices.shape[batch_dims:-1]
      + data.shape[batch_dims + indices.shape[-1]:]
  )
  ```
  
  ```mlir
    %input = mo.constant {device = #M.device_ref<"cpu", 0>, value =
      #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15> :
      tensor<2x2x4xsi64>} : !mo.tensor<[2, 2, 4], si64>
    %indices = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0, 0> : tensor<3xsi64>} :
      !mo.tensor<[3], si64>
  
    %result = mo.gather_nd(%input, %indices) {batchDims = 0} :
      (!mo.tensor<[2, 2, 4], si64>, !mo.tensor<[3], si64>) ->
      !mo.tensor<[], si64>
  ```
  """

  OPERATION_NAME = "mo.gather_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, batchDims, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["batchDims"] = (batchDims if (
    isinstance(batchDims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(batchDims, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def batchDims(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["batchDims"]

  @batchDims.setter
  def batchDims(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batchDims"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def gather_nd(result, input, indices, batch_dims, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GatherNdOp(result=result, input=input, indices=indices, batchDims=batch_dims, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherOp(_ods_ir.OpView):
  r"""
  Gathers slices from input's axis according to indices.
  
  If input and indices are statically ranked, the output rank must be
  `inputRank - 1 + indicesRank`. In general, the output satisfies the
  following:
  ```
  output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =
    input[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]
  ```
  where `indices` appears at given axis of input.
  
  The values of `axis` and `indices` follows numpy semantics, e.g., -1
  represents the last axis.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[2, 2], f32>
    %indices: !mo.tensor<[2], si64>
    %axis = mo.constant {
      value = #M.dense_array<0> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.gather(%input, %indices, %axis) : (
      !mo.tensor<[2, 2], f32>, !mo.tensor<[2], si64>, !mo.tensor<[], si64>
    ) -> !mo.tensor<[2, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def gather(result, input, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GatherOp(result=result, input=input, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GatherSumOp(_ods_ir.OpView):
  r"""
  A temporary composite op that composes a gather with sum reduction.
  The gather axis is 0 and reduction axis is 1.
  """

  OPERATION_NAME = "mo.gather_sum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def gather_sum(result, input, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GatherSumOp(result=result, input=input, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GraphOp(_ods_ir.OpView):
  r"""
  This op represents a computation graph that consists of:
  - input data and their types
  - output types
  - other ops representing computations on input and intermediate data
  - a terminating output op that returns the outputs
  
  Example:
  
  ```mlir
    mo.graph @example<D1 -> D2>(%arg: !mo.tensor<[D1], f32>) -> (!mo.tensor<[D2], f32>) {
      // ... intermediate computations ...
      %res : !mo.tensor<[D3], f32>
      mo.output<D3> %arg : !mo.tensor<[D3], f32>
    }
  ```
  """

  OPERATION_NAME = "mo.graph"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, signature, functionType, inputParameters, resultParameters, counter, *, isSubgraph=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["signature"] = (signature if (
    isinstance(signature, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1201')) else
      _ods_ir.AttrBuilder.get('anonymous_1201')(signature, context=_ods_context))
    attributes["functionType"] = (functionType if (
    isinstance(functionType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1205')) else
      _ods_ir.AttrBuilder.get('anonymous_1205')(functionType, context=_ods_context))
    attributes["inputParameters"] = (inputParameters if (
    isinstance(inputParameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KGEN_ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('KGEN_ParamDeclArrayAttr')(inputParameters, context=_ods_context))
    attributes["resultParameters"] = (resultParameters if (
    isinstance(resultParameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KGEN_ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('KGEN_ParamDeclArrayAttr')(resultParameters, context=_ods_context))
    if bool(isSubgraph): attributes["isSubgraph"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def signature(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["signature"]

  @signature.setter
  def signature(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signature"] = value

  @builtins.property
  def functionType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["functionType"]

  @functionType.setter
  def functionType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["functionType"] = value

  @builtins.property
  def inputParameters(self) -> _ods_ir.Attribute:
    return self.operation.attributes["inputParameters"]

  @inputParameters.setter
  def inputParameters(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inputParameters"] = value

  @builtins.property
  def resultParameters(self) -> _ods_ir.Attribute:
    return self.operation.attributes["resultParameters"]

  @resultParameters.setter
  def resultParameters(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resultParameters"] = value

  @builtins.property
  def isSubgraph(self) -> bool:
    return "isSubgraph" in self.operation.attributes

  @isSubgraph.setter
  def isSubgraph(self, value):
    if bool(value):
      self.operation.attributes["isSubgraph"] = _ods_ir.UnitAttr.get()
    elif "isSubgraph" in self.operation.attributes:
      del self.operation.attributes["isSubgraph"]

  @isSubgraph.deleter
  def isSubgraph(self):
    del self.operation.attributes["isSubgraph"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def graph(sym_name, signature, function_type, input_parameters, result_parameters, counter, *, is_subgraph=None, loc=None, ip=None) -> GraphOp:
  return GraphOp(sym_name=sym_name, signature=signature, functionType=function_type, inputParameters=input_parameters, resultParameters=result_parameters, counter=counter, isSubgraph=is_subgraph, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  r"""
  Returns `x >= y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.greater_equal(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                          !mo.tensor<[2, 3], f32>
                                          ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def greater_equal(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GreaterEqualOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  r"""
  Returns `x > y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.greater(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                    !mo.tensor<[2, 3], f32>
                                    ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def greater(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GreaterOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GuardOp(_ods_ir.OpView):
  r"""
  Consumes a mo.chain operation and a variadic number of inputs and is
  semantically equivalent to a copy of the variadic inputs.
  
  This can be used in conjunction with the !mo.chain returning ops
  (currently only mo.assert) in order to set up execution dependencies
  between the chain producing op and any appropriate downstream operations.
  
  Example:
  
  ```mlir
    %X: !mo.tensor<[D1, D2], f32>
    %Y: !mo.tensor<[D2, D3], f32>
  
    %chain : !mo.chain
  
    %guarded:2 = mo.guard[%chain](%X, %Y)
  
    %z = mo.matmul(%guarded#0, %guarded#1)
  ```
  """

  OPERATION_NAME = "mo.guard"

  _ODS_REGIONS = (0, True)

  def __init__(self, chain, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(chain)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def chain(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def guard(chain, inputs, *, results=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, GuardOp]:
  op = GuardOp(chain=chain, inputs=inputs, results=results, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class IndexToTensorOp(_ods_ir.OpView):
  r"""
  Example:
  
  ```mlir
    %c: index
    %scalarT = mo.index.to_tensor(%c) -> !mo.tensor<[], si64>
  ```
  """

  OPERATION_NAME = "mo.index.to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value[_ods_ir.IntegerType]:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def index_to_tensor(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IndexToTensorOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InvokeShapeFuncOp(_ods_ir.OpView):
  r"""
  Invokes a shape function with given name and bind its return values to the
  output parameters. Each argument must be a shape-like or integer scalar
  tensor. The `kgenParams` will be passed along to the shape function as is.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[D1, D2], f32>
    %axis  : !mo.tensor<[], si64>
    %input_shape = mo.shape_of(%input)
    : (!mo.tensor<[D1, D2], f32>) -> !mo.tensor<[2], si64>
  
    mo.invoke_shape_func["shape_func_name"]<() -> D1, D2>(%input_shape, %axis)
    : (!mo.tensor<[2], si64>, !mo.tensor<[], si64>)
  ```
  
  `dataDeptTensors` Is an instruction to the lowering that the inputs at
  these indices should be treated as data dependent tensors. These tensors
  include things like dynamic "axis" in reductions or "steps" in slice. Any
  tensor which needs to have its values read to compute the shape for the op
  falls into this category.
  """

  OPERATION_NAME = "mo.invoke_shape_func"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, shapeFuncName, *, outputParamDecls=None, kgenParams=None, dataDeptTensors=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shapeFuncName"] = (shapeFuncName if (
    isinstance(shapeFuncName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(shapeFuncName, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    if kgenParams is not None: attributes["kgenParams"] = (kgenParams if (
        isinstance(kgenParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(kgenParams, context=_ods_context))
    if dataDeptTensors is not None: attributes["dataDeptTensors"] = (dataDeptTensors if (
        isinstance(dataDeptTensors, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(dataDeptTensors, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def shapeFuncName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["shapeFuncName"]

  @shapeFuncName.setter
  def shapeFuncName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shapeFuncName"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def kgenParams(self) -> _Optional[_ods_ir.DictAttr]:
    if "kgenParams" not in self.operation.attributes:
      return None
    return self.operation.attributes["kgenParams"]

  @kgenParams.setter
  def kgenParams(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["kgenParams"] = value
    elif "kgenParams" in self.operation.attributes:
      del self.operation.attributes["kgenParams"]

  @kgenParams.deleter
  def kgenParams(self):
    del self.operation.attributes["kgenParams"]

  @builtins.property
  def dataDeptTensors(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "dataDeptTensors" not in self.operation.attributes:
      return None
    return self.operation.attributes["dataDeptTensors"]

  @dataDeptTensors.setter
  def dataDeptTensors(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["dataDeptTensors"] = value
    elif "dataDeptTensors" in self.operation.attributes:
      del self.operation.attributes["dataDeptTensors"]

  @dataDeptTensors.deleter
  def dataDeptTensors(self):
    del self.operation.attributes["dataDeptTensors"]

def invoke_shape_func(inputs, shape_func_name, *, output_param_decls=None, kgen_params=None, data_dept_tensors=None, loc=None, ip=None) -> InvokeShapeFuncOp:
  return InvokeShapeFuncOp(inputs=inputs, shapeFuncName=shape_func_name, outputParamDecls=output_param_decls, kgenParams=kgen_params, dataDeptTensors=data_dept_tensors, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IsInfOp(_ods_ir.OpView):
  r"""
  Returns true if `x` represents a floating point Inf, where `x` is input
  tensor.
  
  Example:
  
  ```mlir
    %x: !mo.tensor<[2, 3], f32>
    %res = mo.is_inf(%x) : (!mo.tensor<[2, 3], f32>
                          ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.is_inf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def is_inf(result, input_x, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsInfOp(result=result, input_x=input_x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsNaNOp(_ods_ir.OpView):
  r"""
  Returns true if `x` represents a floating point NaN, where `x` is input
  tensor.
  
  Example:
  
  ```mlir
    %x: !mo.tensor<[2, 3], f32>
    %res = mo.is_nan(%x) : (!mo.tensor<[2, 3], f32>
                          ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.is_nan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def is_nan(result, input_x, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsNaNOp(result=result, input_x=input_x, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LayerNormOp(_ods_ir.OpView):
  r"""
  Layer normalization operation which operates on the last dimension of
  `input`:
  
    meanInput = mean(input)
    varInput = var(input)
    result = (input - meanInput) / sqrt(varInput + epsilon) * gamma + beta.
  
  We expect gamma and beta to be shape [channels], where channels is the size
  of the last input dimension.
  """

  OPERATION_NAME = "mo.layer_norm"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, gamma, beta, epsilon, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(gamma)
    operands.append(beta)
    operands.append(epsilon)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def gamma(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def beta(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def epsilon(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def layer_norm(result, input, gamma, beta, epsilon, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LayerNormOp(result=result, input=input, gamma=gamma, beta=beta, epsilon=epsilon, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LayoutTransformOp(_ods_ir.OpView):
  r"""
  This op transforms the layout of input tensor to the layout specified in
  the output type. The `kgenParams` will be passed along as named parameters
  to the underlying mojo kernel.
  
  It requires both the input and output tensor types to contain layout
  annotations.
  """

  OPERATION_NAME = "mo.layout.transform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, kgenParams=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if kgenParams is not None: attributes["kgenParams"] = (kgenParams if (
        isinstance(kgenParams, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(kgenParams, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def kgenParams(self) -> _Optional[_ods_ir.DictAttr]:
    if "kgenParams" not in self.operation.attributes:
      return None
    return self.operation.attributes["kgenParams"]

  @kgenParams.setter
  def kgenParams(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["kgenParams"] = value
    elif "kgenParams" in self.operation.attributes:
      del self.operation.attributes["kgenParams"]

  @kgenParams.deleter
  def kgenParams(self):
    del self.operation.attributes["kgenParams"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def layout_transform(result, input, *, kgen_params=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LayoutTransformOp(result=result, input=input, kgenParams=kgen_params, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListAppendOp(_ods_ir.OpView):
  r"""
  Creates a new list that's the result of appending an element to the end of a
  copy of the input list (i.e., the op is value semantics and doesn't affect
  the input list).
  
  Example:
  
  ```mlir
    %list:   !mo.list<!mo.tensor<[2, 2], f32>>
    %tensor: !mo.tensor<[2, 3], f32>
  
    %tensor = mo.list.append(%list, %tensor) : (
      !mo.list<!mo.tensor<[2, 2], f32>>, !mo.tensor<[2, 3], f32>
    ) -> !mo.list<!mo.tensor<[2, ?], f32>>
  ```
  """

  OPERATION_NAME = "mo.list.append"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, element, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(element)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def element(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_append(result, input, element, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListAppendOp(result=result, input=input, element=element, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListConcatOp(_ods_ir.OpView):
  r"""
  Creates a new list that's the result of concatenating the two input lists
  together.
  
  Example:
  
  ```mlir
    %lhs:   !mo.list<!mo.tensor<[2, 2], f32>>
    %rhs:   !mo.list<!mo.tensor<[2, 2], f32>>
  
    %tensor = mo.list.concat(%lhs, %rhs) : (
      !mo.list<!mo.tensor<[2, 2], f32>>, !mo.list<!mo.tensor<[2, 2], f32>>
    ) -> !mo.list<!mo.tensor<[2, 2], f32>>
  ```
  """

  OPERATION_NAME = "mo.list.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_concat(result, lhs, rhs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListConcatOp(result=result, lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListCreateOp(_ods_ir.OpView):
  r"""
  Creates a new list which contains the given inputs (currently limited to
  tensors).
  
  Example:
  
  ```mlir
    %arg0: !mo.tensor<[2, 3], f32>
    %arg1: !mo.tensor<[2, 5], f32>
  
    %list = mo.list.create(%arg0, %arg1) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 5], f32>
    ) -> !mo.list<!mo.tensor<[2, ?], f32>>
  ```
  """

  OPERATION_NAME = "mo.list.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_create(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListCreateOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetOp(_ods_ir.OpView):
  r"""
  Retrieves the element at given (base zero) index of the list. The index can be
  negative, with numpy indexing semantics, i.e., `-1` means the last element,
  `-2` means the second to last element, etc.
  
  Example:
  
  ```mlir
    %list: !mo.list<!mo.tensor<[2, 2], f32>>
    %idx:  !mo.tensor<[], si32>
  
    %tensor = mo.list.get(%list, %idx) : (
      !mo.list<!mo.tensor<[2, 2], f32>>, !mo.tensor<[], si32>
    ) -> !mo.tensor<[2, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.list.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_get(result, input, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListGetOp(result=result, input=input, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListInsertOp(_ods_ir.OpView):
  r"""
  Creates a new list that's the result of inserting an element at given (base
  zero) index of a copy of the list (i.e., the op is value semantics and
  doesn't affect the input list).
  
  The index can be negative, with numpy indexing semantics, i.e., `-1` means
  the last element, `-2` means the second to last element, etc.
  
  It will push any existing element at the index to after the inserted element
  (which will now be at the index). If the index equals the length of the
  list, the op effectively appends the element to the list.
  
  Example:
  
  ```mlir
    %list:   !mo.list<!mo.tensor<[2, 2], f32>>
    %tensor: !mo.tensor<[2, 3], f32>
    %index:  !mo.tensor<[], si32>
  
    %tensor = mo.list.insert(%list, %tensor, %index) : (
      !mo.list<!mo.tensor<[2, 2], f32>>, !mo.tensor<[2, 3], f32>, !mo.tensor<[], si32>
    ) -> !mo.list<!mo.tensor<[2, ?], f32>>
  ```
  """

  OPERATION_NAME = "mo.list.insert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, element, index, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(element)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def element(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_insert(result, input, element, index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListInsertOp(result=result, input=input, element=element, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListSliceOp(_ods_ir.OpView):
  r"""
  Creates a new list that's the result of applying the equivalent of Python's
  slice operation: list[start:end:step]
  
  The start/end can be negative, with numpy indexing semantics, i.e., `-1` means
  the last element, `-2` means the second to last element, etc.
  
  Steps can be negative as well in which case start to end
  are walked in reverse order.
  
  Example:
  
  ```mlir
    %list:   !mo.list<!mo.tensor<[2, 2], f32>>
    %index:  !mo.tensor<[], si32>
    %start:  !mo.tensor<[], si32>
    %step:  !mo.tensor<[], si32>
  
    %tensor = mo.list.slice(%list, %tensor, %index) : (
      !mo.list<!mo.tensor<[2, 2], f32>>,
      !mo.tensor<[], si32>,  !mo.tensor<[], si32>, !mo.tensor<[], si32>
    ) -> !mo.list<!mo.tensor<[2, ?], f32>>
  ```
  """

  OPERATION_NAME = "mo.list.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, end, step, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(end)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def end(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_slice(result, input, start, end, step, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListSliceOp(result=result, input=input, start=start, end=end, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Log1pOp(_ods_ir.OpView):
  r"""
  Returns `log(1 + x)`, maintaining accuracy for small `x` that could
  otherwise lead to floating-point roundings of the kind `1 + x = 1`.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.log1p(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def log1p(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return Log1pOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogOp(_ods_ir.OpView):
  r"""
  Returns the natural logarithm, `log(x)`.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.log(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def log(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogSoftmaxOp(_ods_ir.OpView):
  r"""
  Returns `log(softmax(x, axis))`, where `x` is input tensor, and `axis` is
  the axis along which `softmax` is applied.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis: !mo.tensor<[], si64>
    %res = mo.logsoftmax(%arg, %axis) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.logsoftmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logsoftmax(result, input, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogSoftmaxOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatmulAllReduceOp(_ods_ir.OpView):
  r"""
  Execute a multi-gpu Matmul + AllReduce.
  This op encode multiple GPU kernels.
  This needs to be a single op to handle kernel overlap / PDL correctly.
  Mega kernel that execute a multi-gpu Matmul + AllReduce.
  The computation is potentially split on the row / col axis
  (For H100+ and large enough dimensions).
  This way we can overlap some of the operations that are independent.
  """

  OPERATION_NAME = "mo.distributed.matmul_allreduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, outChain, inputs, weights, signalBuffers, inChain, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.extend(_get_op_results_or_values(weights))
    operands.extend(_get_op_results_or_values(signalBuffers))
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outputs)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def weights(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def signalBuffers(self) -> _ods_ir.OpOperandList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 2)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 1, 3, 0, 3)
    return self.operation.operands[start]

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def distributed_matmul_allreduce(outputs, out_chain, inputs, weights, signal_buffers, in_chain, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MatmulAllReduceOp]:
  op = MatmulAllReduceOp(outputs=outputs, outChain=out_chain, inputs=inputs, weights=weights, signalBuffers=signal_buffers, inChain=in_chain, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MatmulOp(_ods_ir.OpView):
  r"""
  Performs matrix multiplication on two 2D tensors.
  
  Example:
  
  ```mlir
    %lhs: ... !mo.tensor<[10, 20], f32>
    %rhs: ... !mo.tensor<[20, 5], f32>
    %res = mo.matmul(%lhs, %rhs) : (
      !mo.tensor<[10, 20], f32>, !mo.tensor<[20, 5], f32>
    ) -> !mo.tensor<[10, 5], f32>
  ```
  """

  OPERATION_NAME = "mo.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, transpose_b=None, packed_b=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose_b is not None: attributes["transpose_b"] = (transpose_b if (
        isinstance(transpose_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(transpose_b, context=_ods_context))
    if packed_b is not None: attributes["packed_b"] = (packed_b if (
        isinstance(packed_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(packed_b, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def transpose_b(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["transpose_b"]

  @transpose_b.setter
  def transpose_b(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["transpose_b"] = value

  @builtins.property
  def packed_b(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["packed_b"]

  @packed_b.setter
  def packed_b(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["packed_b"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def matmul(result, input_a, input_b, *, transpose_b=None, packed_b=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatmulOp(result=result, input_a=input_a, input_b=input_b, transpose_b=transpose_b, packed_b=packed_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  r"""
  Returns `max(x, y)`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.max(%lhs, %rhs) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPoolCeilOp(_ods_ir.OpView):
  r"""
  Computes max pooling with the given filter shape, strides, and dilations.
  
  The op supports 2d max pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<3, 3> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = mo.max_pool_ceil_mode_true(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[1, 4, 4, 1], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[1, 2, 2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.max_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPoolOp(_ods_ir.OpView):
  r"""
  Computes max pooling with the given filter shape, strides, and dilations.
  
  For now the op only supports 2d max pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<1, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = mo.max_pool(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[20, 10, 10, 32], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[20, 9, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "mo.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max_pool(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MeanOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their mean value, changng that
  axis's dimension to 1.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.mean(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mean(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MeanOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MergeDimOp(_ods_ir.OpView):
  r"""
  Merges two adjacent dimensions of a tensor into one. Example:
  Input=[A, B, C, D], Axis=1
  
  Output=[A, B*C, D].
  
  We merge axis i and i+1 into one dimension.
  
  Example:
  ```mlir
    %out = mo.merge_dim[1](%res): (!mo.tensor<[1, 2, 3, 4], f32>) -> !mo.tensor<[1, 6, 4], f32>
  ```
  """

  OPERATION_NAME = "mo.merge_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def merge_dim(result, input, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MergeDimOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  r"""
  Returns `min(x, y)`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.min(%lhs, %rhs) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def min(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModOp(_ods_ir.OpView):
  r"""
  Returns `x mod y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], si32>
    %rhs: !mo.tensor<[2, 3], si32>
    %res = mo.add(%lhs, %rhs) : !mo.tensor<[2, 3], si32>
  ```
  """

  OPERATION_NAME = "mo.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mod(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ModOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  Returns `x * y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.mul(%lhs, %rhs) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MutableLoadOp(_ods_ir.OpView):
  r"""
  Allows modelling of in-place operations in MO in conjunction with mo.mutable.store.
  
  This is semantically equivalent to a copy from `inBuffer` to `outTensor`
  
  The output chain of this operation is only allowed to have at most one use.
  
  If the value semantic output of this operation has more than one use the
  operation becomes ineligibile for fusion with compute operations.
  """

  OPERATION_NAME = "mo.mutable.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, outTensor, outChain, inBuffer, inChain, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(outTensor)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outTensor(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def mutable_load(out_tensor, out_chain, in_buffer, in_chain, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MutableLoadOp(outTensor=out_tensor, outChain=out_chain, inBuffer=in_buffer, inChain=in_chain, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MutableStoreOp(_ods_ir.OpView):
  r"""
  Allows modelling of in-place operations in MO in conjunction with mo.mutable.load.
  
  This is semantically equivalent to a copy from `inTensor` to `inBuffer`
  
  The output chain of this operation is only allowed to have at most one use.
  
  If the value semantic tensor input of this operation has more than one use
  the operation becomes ineligibile for fusion with compute operations.
  """

  OPERATION_NAME = "mo.mutable.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, inTensor, inChain, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inTensor)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inTensor(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mutable_store(in_buffer, in_tensor, in_chain, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MutableStoreOp(inBuffer=in_buffer, inTensor=in_tensor, inChain=in_chain, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MutableStoreSliceOp(_ods_ir.OpView):
  r"""
  Stores the  tensor `slice` to a subset of the elements in `inBuffer`.
  
  The subset is chosen using the `start`, `stop`, and `step`
  1D index tensors; each index tensor has N elements, one for each dimension
  of the `input` tensor.
  
  The semantics follows the numpy index semantics, such that
  1. For each dimension `i`, `start[i]:stop[i]:step[i]` represents the
     "indexing" along that dimension.
  2. Negative indices are supported for `start` and `stop`, e.g., -1
     represents the largest axis.
  3. Out of bound indices in `start` and `stop` will be clamped to
     [-dim, dim], where `dim` is the dimension in the corresponding axis.
  4. `step` must contain nonzero elements. Negative steps are supported.
  
  Note: the order in which negative indices are resolved matches that of
  python for `start:
  
  1. Normalize negative indices by adding the dimension size.
  2. Apply clipping logic.
  
  This means the equivalent mo.slice for l[:-1:-1] returns an empty result.
  If we want to reverse the values in `l` we should do l[:-N-1:-1] where
  N is the dimension size. Numbers smaller than -N-1 should also work.
  
  Example:
  ```mlir
  ```mlir
    %buffer: !mo.buffer<[20, 20], f32>
    %slice: !mo.tensor<[D0, D1], f32>
    %ch: !mo.chain
  
    %start: !mo.tensor<[2], si64> // [1,  -6]
    %stop: !mo.tensor<[2], si32>  // [-3, -3]
    %step: !mo.tensor<[2], si64>  // [5,   1]
  
    // equivalent to this in numpy: `buffer[1:-3:5, -6:-3:1] = slice`
    %ch' = mo.mutable.store.slice(%ch, %buffer, %slice, %start, %stop, %step)
  ```
  
  Both consumes and produces a chain. The output chain is allowed to have at
  most one use.
  """

  OPERATION_NAME = "mo.mutable.store.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, slice, start, stop, step, inChain, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(slice)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def slice(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def stop(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mutable_store_slice(in_buffer, slice, start, stop, step, in_chain, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MutableStoreSliceOp(inBuffer=in_buffer, slice=slice, start=start, stop=stop, step=step, inChain=in_chain, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NegativeOp(_ods_ir.OpView):
  r"""
  Returns `-x`, where `x` is input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.negative(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.negative"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def negative(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NegativeOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NonMaximumSuppressionOp(_ods_ir.OpView):
  r"""
  Filters out boxes that have high intersection-over-union (IOU).
  
  `boxes` is supplied as [y1, x1, y2, x2] where (y1, x1) and (y2, x2) are the
  coordinates of any diagonal pair of box corners and the coordinates can be
  provided as normalized (i.e., lying in the interval [0, 1]) or absolute.
  
   Example:
  
   ```mlir
     %boxes : !mo.tensor<[1, 6, 4], f32>
     %scores : !mo.tensor<[1, 1, 6], f32>
     %maxOutputBoxesPerClass : !mo.tensor<[], si64>
     %iouThreshold : !mo.tensor<[], si64>
     %scoreThreshold : !mo.tensor<[], si64>
     %res = mo.non_maximum_suppression(%boxes, %scores, %maxOutputBoxesPerClass, %iouThreshold, %scoreThreshold) : (!mo.tensor<[1, 6, 4], f32>, !mo.tensor<[1, 1, 6], f32>, !mo.tensor<[], si64>, !mo.tensor<[], f32>, !mo.tensor<[], f32>) -> !mo.tensor<[?, ?], si64>
   ```
  """

  OPERATION_NAME = "mo.non_maximum_suppression"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, boxes, scores, maxOutputBoxesPerClass, iouThreshold, scoreThreshold, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(boxes)
    operands.append(scores)
    operands.append(maxOutputBoxesPerClass)
    operands.append(iouThreshold)
    operands.append(scoreThreshold)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def boxes(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scores(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def maxOutputBoxesPerClass(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def iouThreshold(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def scoreThreshold(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def non_maximum_suppression(output, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NonMaximumSuppressionOp(output=output, boxes=boxes, scores=scores, maxOutputBoxesPerClass=max_output_boxes_per_class, iouThreshold=iou_threshold, scoreThreshold=score_threshold, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotEqualOp(_ods_ir.OpView):
  r"""
  Returns elementwise `x != y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.not_equal(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                      !mo.tensor<[2, 3], f32>
                                      ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def not_equal(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotEqualOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  r"""
  Returns `not x` on given input, where input is a boolean tensor.
  
  Example:
  
  ```mlir
    %in: !mo.tensor<[2, 3], bool>
    %res = mo.not(%in) : (!mo.tensor<[2, 3], bool>) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def not_(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  r"""
  Returns `x or y`, where `x` and `y` are input boolean tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = mo.or(%lhs, %rhs) : (!mo.tensor<[2, 3], bool>,
                                !mo.tensor<[2, 3], bool>
                                ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def or_(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  r"""
  This op specifies the output parameters and values for a `mo.graph`. The
  op takes variable number of operands and produces no results. The operand
  number and types must match the signature of the `mo.graph` that contains
  the op (after substituting the bindings to signature output type).
  
  Examples:
  
  ```mlir
    mo.graph @no_params(%arg0: !mo.tensor<?, f32>) -> (!mo.tensor<?, f32>) {
      mo.output %arg0 : !mo.tensor<?, f32>
    }
  
    mo.graph @with_params<D1 -> D2>(
        %arg0: !mo.tensor<[D1], f32>) -> (!mo.tensor<[D2], f32>) {
      mo.output<D1> %arg0 : !mo.tensor<[D1], f32>
    }
  ```
  
  Note that in the parameterized example, the output operands type annotation
  and the graph's output type don't necessarily need to match textually, but
  the compiler will eventually verify that they do.
  """

  OPERATION_NAME = "mo.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, parameters=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if parameters is not None: attributes["parameters"] = (parameters if (
        isinstance(parameters, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('KGEN_ParameterExprArrayAttr')) else
          _ods_ir.AttrBuilder.get('KGEN_ParameterExprArrayAttr')(parameters, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def parameters(self) -> _ods_ir.Attribute:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

def output(operands_, *, parameters=None, loc=None, ip=None) -> OutputOp:
  return OutputOp(operands_=operands_, parameters=parameters, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PadConstantOp(_ods_ir.OpView):
  r"""
  Pads the `input` tensor with a scalar tensor `constant` according to the
  `paddings`. Assumes input has rank `N`, the `paddings` tensor should have
  shape `(2 * N)`, where each consecutive pair of elements has the form
  `[before, after]`, indicating how many of `constant` to add before and after
  the contents of `input` in that dimension. The size of each dimension D of
  the padded output is: `paddings[2*D] + input.dim(D) + paddings[2*D+1]`.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 3], f32>
    %constant = mo.constant {
      value = #M.dense_array<1.0> : tensor<f32>} : !mo.tensor<[], f32>
    %paddings = mo.constant {
      value = #M.dense_array<1, 0, 1, 1> : tensor<4xsi64>
    } : !mo.tensor<[4], si64>
    %output =   mo.pad.constant(%input, %paddings, %constant) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[4], si64>, !mo.tensor<[], f32>
    ) -> !mo.tensor<[3, 5], f32>
  ```
  """

  OPERATION_NAME = "mo.pad.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, constant, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    operands.append(constant)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def constant(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pad_constant(result, input, paddings, constant, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PadConstantOp(result=result, input=input, paddings=paddings, constant=constant, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PadReflectOp(_ods_ir.OpView):
  r"""
  Pads the `input` tensor by reflecting it according to the `paddings`.
  Assumes input has rank `N`, the `paddings` tensor should have shape `(2 *
  N)`, where each consecutive pair of elements has the form `[before, after]`,
  indicating how many of `constant` to add before and after the contents of
  `input` in that dimension. The size of each dimension D of the padded output
  is: `paddings[2*D] + input.dim(D) + paddings[2*D+1]`.
  
  `paddings[D, 0] + input.dim(D) + paddings[D, 1]`.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 3], f32>
    %paddings = mo.constant {
      value = #M.dense_array<1, 0, 1, 1> : tensor<4xsi64>
    } : !mo.tensor<[4], si64>
    %output   = mo.pad.reflect(%input, %paddings) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[4], si64>) ->
      !mo.tensor<[3, 5], f32>
  ```
  """

  OPERATION_NAME = "mo.pad.reflect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pad_reflect(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PadReflectOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PadRepeatOp(_ods_ir.OpView):
  r"""
  Pads the `input` tensor by repeating border values according to `paddings`.
  Assumes input has rank `N`, the `paddings` tensor should have shape `(2 *
  N)`, where each consecutive pair of elements has the form `[before, after]`,
  indicating how many of `constant` to add before and after the contents of
  `input` in that dimension. The size of each dimension D of the padded output
  is: `paddings[2*D] + input.dim(D) + paddings[2*D+1]`.
  
  `paddings[D, 0] + input.dim(D) + paddings[D, 1]`.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 3], f32>
    %paddings = mo.constant {
      value = #M.dense_array<1, 0, 1, 1> : tensor<4xsi64>
    } : !mo.tensor<[4], si64>
    %output   = mo.pad.repeat(%input, %paddings) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[4], si64>) ->
      !mo.tensor<[3, 5], f32>
  ```
  """

  OPERATION_NAME = "mo.pad.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pad_repeat(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PadRepeatOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  r"""
  Computes `x ** y`, where `x` and `y` are input tensors.
  
  Examples:
  
  ```mlir
    %x: !mo.tensor<[2, 3], f32>
    %y: !mo.tensor<[2, 3], f32>
    %res = mo.pow(
        %x: !mo.tensor<[2, 3], f32>,
        %y: !mo.tensor<[2, 3], f32>
    ) : !mo.tensor<[2, 3], f32>
  
    %x: !mo.tensor<[2, 3], f32>
    %y_int: !mo.tensor<[2, 3], si32>
    %res = mo.pow(
        %x: !mo.tensor<[2, 3], f32>,
        %y: !mo.tensor<[2, 3], si32>
    ) : !mo.tensor<[2, 3], f32>
    %res = mo.pow(%x, %y_int) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pow(result, input_x, input_y, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowOp(result=result, input_x=input_x, input_y=input_y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RandomNormalOp(_ods_ir.OpView):
  r"""
    Returns a tensor with shape `shape` populated with random
    values from a normal distribution, with the mean of the distribution equal
    to `mean` and the standard deviation equal to `variance`.
  
  Example:
    ```mlir
      %size = mo.constant {
        value = #M.dense_array<1, 1, 7, 8> : tensor<4xsi64>} : !mo.tensor<[4], si64>
      %mean = mo.constant {
        value = #M.dense_array<2.0> : tensor<1xf32> } : !mo.tensor<[], f32>
      %variance = mo.constant {
        value = #M.dense_array<0.5> : tensor<1xf32> } : !mo.tensor<[], f32>
      %seed = mo.constant {
        value = #M.dense_array<1> : tensor<1xsi64> } : !mo.tensor<[], si64>
      %res = mo.random.normal(%size, %mean, %variance, %seed) :
            (!mo.tensor<[4], si64>, !mo.tensor<[], f32>, !mo.tensor<[], f32>,
            !mo.tensor<[], si64>) -> !mo.tensor<[1, 1, 7, 8], f32>
    ```
  """

  OPERATION_NAME = "mo.random.normal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, mean, variance, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(mean)
    operands.append(variance)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def mean(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def variance(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def random_normal(result, shape, mean, variance, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RandomNormalOp(result=result, shape=shape, mean=mean, variance=variance, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RandomUniformOp(_ods_ir.OpView):
  r"""
  Returns a tensor with shape `shape` populated with random values from a
  uniform distribution on the half-open interval [lowerBound, upperBound).
  
  Example:
  ```mlir
  %size = mo.constant {
    value = #M.dense_array<1, 1, 7, 8> : tensor<4xsi64>} : !mo.tensor<[4], si64>
  %lowerBound = mo.constant {
    value = #M.dense_array<2.0> : tensor<1xf32> } : !mo.tensor<[], f32>
  %upperBound = mo.constant {
    value = #M.dense_array<0.5> : tensor<1xf32> } : !mo.tensor<[], f32>
  %seed = mo.constant {
    value = #M.dense_array<1> : tensor<1xsi64> } : !mo.tensor<[], si64>
  %res = mo.random.uniform(%size, %lowerBound, %upperBound, %seed) :
        (!mo.tensor<[4], si64>, !mo.tensor<[], f32>, !mo.tensor<[], f32>,
        !mo.tensor<[], si64>) -> !mo.tensor<[1, 1, 7, 8], f32>
  ```
  """

  OPERATION_NAME = "mo.random.uniform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, lowerBound, upperBound, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(lowerBound)
    operands.append(upperBound)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lowerBound(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def upperBound(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def random_uniform(result, shape, lower_bound, upper_bound, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RandomUniformOp(result=result, shape=shape, lowerBound=lower_bound, upperBound=upper_bound, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RangeOp(_ods_ir.OpView):
  r"""
  Creates a sequence of numbers. The sequence goes from `start` with
  increments of size `step` up to (but not including) `limit`. All arguments
  are mandatory and must have the same element type.
  
  Note the following restrictions on input values:
  1. `step` must be non-zero
  2. `limit - start` must be zero or have the same sign as `step`
  
  Example:
  
  ```mlir
    %limit : !mo.tensor<[], f32>
    %start = mo.constant {
      value = #M.dense_array<0.0> : tensor<f32>} : !mo.tensor<[], f32>
    %step = mo.constant {
      value = #M.dense_array<1.5> : tensor<f32>} : !mo.tensor<[], f32>
    %res = mo.range(%start, %limit, %step) : (
      !mo.tensor<[], f32>, !mo.tensor<[], f32>, !mo.tensor<[], f32>
    ) -> !mo.tensor<[?], f32>
  
    %startInt = mo.constant {
      value = #M.dense_array<1> : tensor<si32>} : !mo.tensor<[], si32>
    %stepInt = mo.constant {
      value = #M.dense_array<2> : tensor<si32>} : !mo.tensor<[], si32>
    %limitInt = mo.constant {
      value = #M.dense_array<11> : tensor<si32>} : !mo.tensor<[], si32>
    %oddNumbersBelowTen = mo.range(%startInt, %limitInt, %stepInt) : (
      !mo.tensor<[], si32>, !mo.tensor<[], si32>, !mo.tensor<[], si32>
    ) -> !mo.tensor<[5], si32>
  ```
  """

  OPERATION_NAME = "mo.range"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, limit, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(limit)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def limit(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def range(result, start, limit, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RangeOp(result=result, start=start, limit=limit, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RebindOp(_ods_ir.OpView):
  r"""
  This op represents the "rebinding" of a type to another type. This is
  typically used for rebinding the shape of !mo.tensor types to other
  !mo.tensor types to get things to type-check due to strict shape-related
  verifiers.
  
  Rebinding is similar to casting, except no data conversion takes place.
  It is assumed that the two types ultimately prove to be the same at runtime.
  
  Therefore, in cases where it is not statically provable, the left and right
  runtime types are the same, it is expected we will insert runtime assertions
  of some sort. Note, this operation does not do this, and any assertions
  must be inserted separately.
  
  Note, rebinds which use parameters they declare essentially "rename"
  the associated dimensions which is a useful tool. These types of rebinds
  are guaranteed to be removed by shape inference unless they are used to
  name unknown dims (denoted by `?`) from 3P dialects like those in PT.
  
  Examples:
  ```mlir
    // something like ASSERT N == 3 AND Sh == {3, 1} if we aren't statically
    // sure of this fact.
    %1 = mo.rebind(%0) : !mo.tensor<[N, 1], f32> -> !mo.tensor<Sh, f32>
    %2 = mo.rebind(%1) : !mo.tensor<Sh, f32> -> !mo.tensor<[3, 1], f32>
  
    // Renames dims. K == 3, M == 1
    %3 = mo.rebind<() -> K, M>(%0) :
      !mo.tensor<[3, 1], f32> -> !mo.tensor<[K, M], f32>
  ```
  """

  OPERATION_NAME = "mo.rebind"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rebind(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RebindOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceAddOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their sum, changing that axis's
  dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.reduce.add(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.reduce.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_add(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceAddOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMaxOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their maximum, changing that
  axis's dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.reduce.max(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.reduce.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMinOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their minimum, changing that
  axis's dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.reduce.min(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.reduce.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceMulOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their product, changing that
  axis's dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = mo.reduce.mul(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "mo.reduce.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduce_mul(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReduceMulOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReluOp(_ods_ir.OpView):
  r"""
  Returns `max(0, x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.relu(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def relu(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReluOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the same underlying data, but different shape.
  
  The first argument is the tensor to reshape.  The second tensor is the
  shape to reshape the first tensor to.  The second tensor may contain a
  single "-1" element, which signifies that that dimension should be
  automatically computed.
  
  Example:
  
  ```mlir
    %arg1: !mo.tensor<[1, 2, 3], f32>
    %shape = mo.constant {
      value = #M.dense_array<3, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %arg2 = mo.reshape(%arg1, %shape) : !mo.tensor<[3, 2], si64>
  ```
  
  Auto-sizing example:
  
  ```mlir
    %arg1: !mo.tensor<[1, 2, 3], f32>
    %shape = mo.constant {
      value = #M.dense_array<3, -1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %arg2 = mo.reshape(%arg1, %shape) : !mo.tensor<[3, 2], si64>
  ```
  """

  OPERATION_NAME = "mo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newShape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reshape(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReshapeOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeBicubicOp(_ods_ir.OpView):
  r"""
  Resizes a tensor to a new shape using the bicubic interpolation algorithm.
  
  Bicubic interpolation uses a 4x4 pixel neighborhood and cubic polynomials
  to produce smoother results than linear interpolation. This implementation
  uses Keys' cubic convolution with a = -0.5.
  
  Example:
  ```mlir
    %input : !mo.tensor<[1, 3, 224, 224], f32>
    %size = mo.constant {
      value = #M.dense_array<1, 3, 448, 448> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = mo.resize.bicubic(%input, %size) :
      (!mo.tensor<[1, 3, 224, 224], f32>, !mo.tensor<[4], si64>) ->
        !mo.tensor<[1, 3, 448, 448], f32>
  ```
  """

  OPERATION_NAME = "mo.resize.bicubic"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resize_bicubic(result, input, size, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResizeBicubicOp(result=result, input=input, size=size, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeLinearOp(_ods_ir.OpView):
  r"""
  Resizes a tensor to a new shape using the linear algorithm.
  
  The coordinate transform mode can be half-pixel, align-corners or asymmetric.
  
  When set to true, the antialias attribute causes an antialiasing filter to be applied
  when downscaling.
  """

  OPERATION_NAME = "mo.resize.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, antialias, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    attributes["antialias"] = (antialias if (
    isinstance(antialias, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(antialias, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def antialias(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["antialias"]

  @antialias.setter
  def antialias(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["antialias"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resize_linear(result, input, size, coordinate_transform_mode, antialias, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResizeLinearOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, antialias=antialias, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResizeNearestOp(_ods_ir.OpView):
  r"""
  Resizes a tensor to a new shape using the nearest-neighbor algorithm.
  
  The coordinate transform mode can be half-pixel, align-corners or asymmetric.
  
  The values for round mode are:
    - 0: HalfDown
    - 1: HalfUp
    - 2: Floor
    - 3: Ceil
  
  Round mode is HalfDown (0) by default.
  
  Example:
  ```mlir
    %input : !mo.tensor<[1, 1, 2, 2], f32>
    %size = mo.constant {
      value = #M.dense_array<1, 1, 7, 8> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = mo.resize.nearest(%input, %size) {
      coordinate_transform_mode = 0,
      round_mode = 2}:
      (!mo.tensor<[1, 1, 2, 2], f32>, !mo.tensor<[4], si64>) ->
        !mo.tensor<[1, 1, 7, 8], f32>
  ```
  """

  OPERATION_NAME = "mo.resize.nearest"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, *, round_mode=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        isinstance(round_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(round_mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def round_mode(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def resize_nearest(result, input, size, coordinate_transform_mode, *, round_mode=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ResizeNearestOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, round_mode=round_mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoiAlignOp(_ods_ir.OpView):
  r"""
  ROI align consumes an input tensor and regions of interest in which to apply pooling.
  
  Example:
  ```mlir
    %inp: !mo.tensor<[1, 10, 10, 1], f32>
    %rois: !mo.tensor<[1, 5], f32>
    %output_height = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<5> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %spatial_scale = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1.0> : tensor<1xf32>} : !mo.tensor<[], f32>
    %sampling_ratio = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<2.0> : tensor<1xf32>} : !mo.tensor<[], f32>
  
    %res = mo.roi_align(%inp, %rois, %output_height, %output_height, %spatial_scale, %sampling_ratio)
      {aligned = false,  mode = "AVG"}
      : (!mo.tensor<[1, 10, 10, 1], f32>,
        !mo.tensor<[1, 5], f32>,
        !mo.tensor<[], si64>,
        !mo.tensor<[], si64>,
        !mo.tensor<[], f32>,
        !mo.tensor<[], f32>) -> !mo.tensor<[1, 5, 5, 1], f32>
  ```
  
  """

  OPERATION_NAME = "mo.roi_align"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(rois)
    operands.append(output_height)
    operands.append(output_width)
    operands.append(spatial_scale)
    operands.append(sampling_ratio)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["aligned"] = (aligned if (
    isinstance(aligned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_StringAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_StringAttr')(mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rois(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output_height(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output_width(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def spatial_scale(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def sampling_ratio(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def aligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def mode(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def roi_align(result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RoiAlignOp(result=result, input=input, rois=rois, output_height=output_height, output_width=output_width, spatial_scale=spatial_scale, sampling_ratio=sampling_ratio, aligned=aligned, mode=mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RoundOp(_ods_ir.OpView):
  r"""
  Returns the elementwise nearest integer, with ties going towards the
  nearest even number.
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.round(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def round(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RoundOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RsqrtOp(_ods_ir.OpView):
  r"""
  Returns `1/sqrt(x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.rsqrt(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rsqrt(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RsqrtOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterAddOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the sum of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via addition.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] += updates[i][j] if axis = 0,
    output[i][indices[i][j]] += updates[i][j] if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = mo.scatter_nd.add(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[1, 3], f32>, !mo.tensor<[1, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_add(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterAddOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterMaxOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the maximum of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via maximum.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] = max(output[indices[i][j]][j], updates[i][j]) if axis = 0,
    output[i][indices[i][j]] = max(output[i][indices[i][j]], updates[i][j]) if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = mo.scatter_nd.max(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[1, 3], f32>, !mo.tensor<[1, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_max(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterMaxOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterMinOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the minimum of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via minimum.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] = min(output[indices[i][j]][j], updates[i][j]) if axis = 0,
    output[i][indices[i][j]] = min(output[i][indices[i][j]], updates[i][j]) if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = mo.scatter_nd.min(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[1, 3], f32>, !mo.tensor<[1, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_min(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterMinOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterMulOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the product of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via multiplication.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] *= updates[i][j] if axis = 0,
    output[i][indices[i][j]] *= updates[i][j] if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = mo.scatter_nd.mul(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[1, 3], f32>, !mo.tensor<[1, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_mul(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterMulOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdAddOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the sum of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = mo.scatter_nd.add(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter_nd.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_nd_add(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterNdAddOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdMaxOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the maximum of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = mo.scatter_nd.max(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter_nd.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_nd_max(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterNdMaxOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdMinOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the minimum of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = mo.scatter_nd.min(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter_nd.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_nd_min(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterNdMinOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdMulOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the product of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = mo.scatter_nd.mul(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter_nd.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_nd_mul(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterNdMulOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterNdOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = mo.scatter_nd(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter_nd(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterNdOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is updated to the corresponding entry in `updates`.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] = updates[i][j] if axis = 0,
    output[i][indices[i][j]] = updates[i][j] if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = mo.scatter(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "mo.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scatter(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScatterOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  r"""
  Returns `cond ? x : y` (element-wise), where `cond`, `x` and `y` are input
  tensors.
  
  Example:
  
  ```mlir
    %cond: !mo.tensor<[2, 3], bool>
    %x: !mo.tensor<[2, 3], f32>
    %y: !mo.tensor<[2, 3], f32>
    %res = mo.select(%cond, %x, %y) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, cond, x, y, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(x)
    operands.append(y)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def select(result, cond, x, y, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectOp(result=result, cond=cond, x=x, y=y, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShapeOfOp(_ods_ir.OpView):
  r"""
  Returns the shape of a tensor.
  
  Examples:
  
  ```mlir
    // statically ranked
    %arg1: !mo.tensor<[1, 2, 3], f32>
    %shape1 = mo.shape_of(%arg1) : !mo.tensor<[3], si64>
  
    // dynamically ranked
    %arg2: !mo.tensor<?, f32>
    %shape2 = mo.shape_of(%arg2) : !mo.tensor<[?], si64>
  ```
  """

  OPERATION_NAME = "mo.shape_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shape_of(shape, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShapeOfOp(shape=shape, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SinOp(_ods_ir.OpView):
  r"""
  Returns `sin(x)`, where `x` is input tensor.
  
  Example:
  ```mlir
    %arg : !mo.tensor<[2, 3], f32>
    %res = mo.sin(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sin(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SinOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceDimOp(_ods_ir.OpView):
  r"""
  Returns a new tensor with a subset of the elements from an N-dimensional
  `input` tensor. The slice will be taken using `start` / `stop` / `step`
  along the `dim` dimension.
  
  The semantics follows the numpy index semantics, such that
  1. For each dimension `i`, `start[i]:stop[i]:step[i]` represents the
     "indexing" along that dimension.
  2. Negative indices are supported for `start` and `stop`, e.g., -1
     represents the largest axis.
  3. Out of bound indices in `start` and `stop` will be clamped to
     [-dim, dim], where `dim` is the dimension in the corresponding axis.
  4. `step` must contain nonzero elements. Negative steps are supported.
  
  Note: the order in which negative indices are resolved matches that of
  python for `start:
  
  1. Normalize negative indices by adding the dimension size.
  2. Apply clipping logic.
  
  This means the equivalent mo.slice for l[:-1:-1] returns an empty result.
  If we want to reverse the values in `l` we should do l[:-N-1:-1] where
  N is the dimension size. Numbers smaller than -N-1 should also work.
  
  Example:
  ```mlir
    %input: !mo.tensor<[?, ?, ?], f32>
    %start: !mo.tensor<[1], si64> // [1]
    %stop: !mo.tensor<[1], si32>  // [-3]
    %step: !mo.tensor<[1], si64>  // [5]
    // equivalent to this in numpy: `input[1:-3:5, :, :]`
    %res = mo.slice_dim[0](%input, %start, %stop, %step) : (
      !mo.tensor<[10, 10, 10], f32>,
      !mo.tensor<[1], si64>,
      !mo.tensor<[1], si32>,
      !mo.tensor<[1], si64>
    ) -> !mo.tensor<[?, ?, ?], f32>
  ```
  """

  OPERATION_NAME = "mo.slice_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, start, stop, step, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def stop(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def slice_dim(result, input, axis, start, stop, step, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SliceDimOp(result=result, input=input, axis=axis, start=start, stop=stop, step=step, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  r"""
  Returns a new tensor with a subset of the elements from an N-dimensional
  `input` tensor. The subset is chosen using the `start`, `stop`, and `step`
  1D index tensors; each index tensor has N elements, one for each dimension
  of the `input` tensor.
  
  The semantics follows the numpy index semantics, such that
  1. For each dimension `i`, `start[i]:stop[i]:step[i]` represents the
     "indexing" along that dimension.
  2. Negative indices are supported for `start` and `stop`, e.g., -1
     represents the largest axis.
  3. Out of bound indices in `start` and `stop` will be clamped to
     [-dim, dim], where `dim` is the dimension in the corresponding axis.
  4. `step` must contain nonzero elements. Negative steps are supported.
  
  Note: the order in which negative indices are resolved matches that of
  python for `start:
  
  1. Normalize negative indices by adding the dimension size.
  2. Apply clipping logic.
  
  This means the equivalent mo.slice for l[:-1:-1] returns an empty result.
  If we want to reverse the values in `l` we should do l[:-N-1:-1] where
  N is the dimension size. Numbers smaller than -N-1 should also work.
  
  Example:
  ```mlir
    %input: !mo.tensor<[?, ?], f32>
    %start: !mo.tensor<[2], si64> // [1, -6]
    %stop: !mo.tensor<[2], si32>  // [-3, 6]
    %step: !mo.tensor<[2], si64>  // [5, 1]
    // equivalent to this in numpy: `input[1:-3:5, -6:6:1]`
    %res = mo.slice(%input, %start, %stop, %step) : (
      !mo.tensor<[10, 10], f32>,
      !mo.tensor<[2], si64>,
      !mo.tensor<[2], si32>,
      !mo.tensor<[2], si64>
    ) -> !mo.tensor<[?, ?], f32>
  ```
  """

  OPERATION_NAME = "mo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, stop, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def stop(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def slice(result, input, start, stop, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SliceOp(result=result, input=input, start=start, stop=stop, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SoftmaxOp(_ods_ir.OpView):
  r"""
  Returns `exp(input) / sum(exp(input))`, where `x` is input tensor.
  
  The `sum` reduction is applied along `axis`.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis: !mo.tensor<[], si64>
    %res = mo.softmax(%arg, %axis) : (!mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def softmax(result, input, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SoftmaxOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitDimOp(_ods_ir.OpView):
  r"""
  Splits tensor at `axis` into two dimensions. Example:
  Input=[N, K], Axis=0
  
  Output=[S1, S2, K], where S1 = N / S2.
  
  Value of S2 is taken from the output shape.
  
  Example:
  ```mlir
    %out = mo.split_dim[0](%res): (!mo.tensor<[4, 9], f32>) -> !mo.tensor<[2, 2, 9], f32>
  ```
  """

  OPERATION_NAME = "mo.split_dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(axis, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def split_dim(result, input, axis, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SplitDimOp(result=result, input=input, axis=axis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SplitOp(_ods_ir.OpView):
  r"""
  Splits the input tensor into multiple tensors along a given dimension.
  
  `mo.split` splits the tensor `input` into multiple output tensors.
  The number of output tensors is equal to the number of elements in
  `splitSizes`, which is a rank-1 tensor of integers.
  Each of the output tensors has the same shape as `input` except along the
  split dimension `axis`, where the size is given by the corresponding
  element in `splitSizes`.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 8], f32>
    %splitSizes = mo.constant {
      value = #M.dense_array<3, 5> : tensor<2xsi64>
    } : !mo.tensor<[2], si64>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>
    } : !mo.tensor<[], si64>
    %res:2 = mo.split[%axis: !mo.tensor<[], si64>](%input, %splitSizes) : (
      !mo.tensor<[2, 8], f32>, !mo.tensor<[2], si64>
    ) -> (!mo.tensor<[2, 3], f32>, !mo.tensor<[2, 5], f32>)
  ```
  """

  OPERATION_NAME = "mo.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, input, splitSizes, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(splitSizes)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def splitSizes(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def split(results_, input, split_sizes, axis, *, output_param_decls=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SplitOp]:
  op = SplitOp(results_=results_, input=input, splitSizes=split_sizes, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SqrtOp(_ods_ir.OpView):
  r"""
  Returns `sqrt(x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.sqrt(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sqrt(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SqrtOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SqueezeShapeOp(_ods_ir.OpView):
  r"""
  Calculates the shape from squeeze like operators. Given an input shape
  vector representing a tensor of rank `N`, and a list of indices of length
  `M`, returns a new shape vector representing a tensor of rank `N - M`. The
  indices represent the 0-based index of dimensions in the original rank `N`
  tensor.
  
  The indicated indices must represent dimensions of size 1. If
  an index does not point to a dimension to size 1, an error is thrown
  instead.
  
  This operator supports negative indexing with python-like semantics.
  That is all indices must be in [-N, N), if an index is < 0, it is as if
  we added `N` to it.
  
  Example:
  
  ```mlir
    %input_shape : !mo.tensor<[8], si32>
    %indices : !mo.tensor<[4], si32>
    %res = mo.squeeze_shape(%input_shape, %indices) : (!mo.tensor<[8], si32>, !mo.tensor<[4], si32>) -> !mo.tensor<[4], si32>
  ```
  """

  OPERATION_NAME = "mo.squeeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, remove_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(remove_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def remove_indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def squeeze_shape(result, input_shape, remove_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SqueezeShapeOp(result=result, input_shape=input_shape, remove_indices=remove_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  Returns `x - y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = mo.sub(%lhs, %rhs) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TanhOp(_ods_ir.OpView):
  r"""
  Computes `tanh(x)`, where `x` is input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.tanh(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tanh(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TanhOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TileOp(_ods_ir.OpView):
  r"""
  Returns a new Tensor as the result of copying the input tensor N_i times
  on each dimension, where N_i = tiles[i].
  
  The i-th dimension of output shape will be the ith dimension of input shape
  multiplied by N_i.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[2, 3], f32>
    %repeats : !mo.tensor<[2], si64>
    %res = mo.tile(%input, %repeats) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2], si64>) -> !mo.tensor<[?, ?], f32>
  ```
  """

  OPERATION_NAME = "mo.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, repeats, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(repeats)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def repeats(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tile(result, input, repeats, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TileOp(result=result, input=input, repeats=repeats, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TopKOp(_ods_ir.OpView):
  r"""
  Computes the largest values and their corresponding indices in a tensor
  along a specified axis. Returned values along the axis are always sorted
  (stable).
  
  axis: The axis to compute the largest values over.
    The axis must be in [-rank, rank).
  k: The number of values to compute.
  sorted: Whether to return the values and indices sorted or not.
  
  Example:
  ```mlir
    %in = mo.constant {
      value = #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11> : tensor<2x6xsi64>
    } : !mo.tensor<[2, 6], si64>
    %k = mo.constant() { value = #M.dense_array<3> : tensor<si64> } : !mo.tensor<[], si64>
    %axis = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<si64> } : !mo.tensor<[], si64>
    %sorted = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<1xi1> } : !mo.tensor<[], bool>
    %values, %indices = mo.top_k(%in, %k, %axis, %sorted) : (
      !mo.tensor<[2, 6], si64>, !mo.tensor<[], si64>, !mo.tensor<[], si64>, !mo.tensor<[], bool>
    ) -> (
      !mo.tensor<[2, 3], si64>, !mo.tensor<[2, 3], si64>
    )
  ```
  """

  OPERATION_NAME = "mo.top_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def K(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def sorted(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def top_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return TopKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TransferOp(_ods_ir.OpView):
  r"""
  This op represents a possible copy or aliasing operation to make the
  contents of the operand tensor available on the (virtual) device of the
  result tensor.
  
  It is valid for the source and destination devices to be identical. If the
  `alwaysElideSameDeviceCopy` flag is not set, it is implementation defined as
  to whether the result tensor is a copy or alias of the operand tensor; if
  this flag is true, transfers to the same device never result in a copy.
  
  Example:
  
  ```mlir
    %arg : !mo.tensor<[N, 8], f32, gpu:3>
    %onOtherDevice = mo.transfer %arg : !mo.tensor<[N, 8], f32, gpu:3> to <"gpu", 1>
    %onHost = mo.transfer %arg : !mo.tensor<[N, 8], f32, gpu:0> to <"cpu", 1>
  ```
  """

  OPERATION_NAME = "mo.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, outChain, input, inChain, *, alwaysElideSameDeviceCopy=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if alwaysElideSameDeviceCopy is not None: attributes["alwaysElideSameDeviceCopy"] = (alwaysElideSameDeviceCopy if (
        isinstance(alwaysElideSameDeviceCopy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(alwaysElideSameDeviceCopy, context=_ods_context))
    results = []
    results.append(result)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def alwaysElideSameDeviceCopy(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["alwaysElideSameDeviceCopy"]

  @alwaysElideSameDeviceCopy.setter
  def alwaysElideSameDeviceCopy(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alwaysElideSameDeviceCopy"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def transfer(result, out_chain, input, in_chain, *, always_elide_same_device_copy=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return TransferOp(result=result, outChain=out_chain, input=input, inChain=in_chain, alwaysElideSameDeviceCopy=always_elide_same_device_copy, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  r"""
  Returns a new Tensor as the result of permuting the dimensions of the input
  tensor according to the value of perm.
  
  Note that `perm` must contain unique values from `[0, input_rank)`.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[2, 3], f32>
    %perm : !mo.tensor<[2], si64>
    %res = mo.transpose(%input, %perm) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2], si64>) -> !mo.tensor<[3, 2], f32>
  
    %input : !mo.tensor<[?, 5, ?], f32>
    %perm : !mo.tensor<[3], si32>
    %res = mo.transpose(%input, %perm) : (
      !mo.tensor<[?, 5, ?], f32>, !mo.tensor<[3], si32>
    ) -> !mo.tensor<[?, ?, 5], f32>
  ```
  """

  OPERATION_NAME = "mo.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, perm, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(perm)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def perm(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def transpose(result, input, perm, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TransposeOp(result=result, input=input, perm=perm, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TruncOp(_ods_ir.OpView):
  r"""
  Returns the elementwise integer from truncating the decimal. Also known
  as round-toward-zero.
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = mo.trunc(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "mo.trunc"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def trunc(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TruncOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnsqueezeShapeOp(_ods_ir.OpView):
  r"""
  Calculates the shape from unsqueeze like operators. Given an input shape
  vector representing a tensor of rank `N`, and a list of indices of length
  `M`, returns a new shape vector representing a tensor of rank `N + M`.
  
  The indices in the given list map to the new vector of length `N + M` where
  the indicated dimensions are replaced with `1`. The remaining dimension in
  the original input shape vector are copied over in the non-1 dimensions.
  
  This operator supports negative indexing.
  
  Example:
  
  ```mlir
    %input_shape : !mo.tensor<[3], si32>
    %indices : !mo.tensor<[4], si32>
    %res = mo.unsqueeze_shape(%input_shape, %indices) : (!mo.tensor<[4], si32>, !mo.tensor<[3], si32>) -> !mo.tensor<[7], si32>
  ```
  """

  OPERATION_NAME = "mo.unsqueeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, padding_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(padding_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def padding_indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def unsqueeze_shape(result, input_shape, padding_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnsqueezeShapeOp(result=result, input_shape=input_shape, padding_indices=padding_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WhileConditionOp(_ods_ir.OpView):
  r"""
  This op takes the continuation condition of the parent `mo.while`. The op
  takes variable number of operands which must match the operands of the
  parent `mo.while`.
  
  See the mo.while operation for an example.
  """

  OPERATION_NAME = "mo.while.condition"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

def while_condition(condition, args, *, loc=None, ip=None) -> WhileConditionOp:
  return WhileConditionOp(condition=condition, args=args, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class XorOp(_ods_ir.OpView):
  r"""
  Returns `x xor y`, where `x` and `y` are input boolean tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = mo.xor(%lhs, %rhs) : (!mo.tensor<[2, 3], bool>,
                                !mo.tensor<[2, 3], bool>
                                ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "mo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def xor(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XorOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  This op specifies the output values for control flow blocks. The op
  takes variable number of operands and produces no results.
  
  Example:
  
  ```mlir
    mo.if $cond : !mo.tensor<[], bool> (!mo.tensor<?, f32>) {
      mo.yield %arg0 : !mo.tensor<?, f32>
    } else {
      mo.yield %arg1 : !mo.tensor<?, f32>
    }
  ```
  """

  OPERATION_NAME = "mo.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, parameters=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if parameters is not None: attributes["parameters"] = (parameters if (
        isinstance(parameters, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('KGEN_ParameterExprArrayAttr')) else
          _ods_ir.AttrBuilder.get('KGEN_ParameterExprArrayAttr')(parameters, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def parameters(self) -> _ods_ir.Attribute:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

def yield_(operands_, *, parameters=None, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, parameters=parameters, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WhileOp(_ods_ir.OpView):
  r"""
  The `mo.while` operation takes "cond" and "body" blocks. While the "cond"
  block evaluates to the true condition, the "body" block is executed.
  
  The "cond" and "body" blocks have access to both the values listed in the
  `mo.while` signature and any other outer values.
  
  - The "cond" block must return a `!mo.tensor<[], bool>` result
  followed by values whose types match the inputs of the `mo.while` signature.
  
  - The "body" block must return results with the same types as the `mo.while`
  signature, again using a `mo.yield`. The signature must include an "as"
  clause for every input so as to rename it to a fresh symbol.
  
  The results of the `mo.while` op are the operands of the
  `mo.while.condition` op when the condition operand evaluates to false.
  
  Example:
  
  ```mlir
    %x: !mo.tensor<[2], f32>
    %y: !mo.tensor<[], f32>
    %res = mo.while (%x as %inner_x: !mo.tensor<[2], f32>) {
      %zero = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0> : tensor<1xsi64>} : !mo.tensor<[], si64>
      %shape = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<> : tensor<0xsi64>} : !mo.tensor<[0], si64>
      %mean0 = mo.mean (%inner_x, %zero) : (!mo.tensor<[2], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[1], f32>
      %mean1 = mo.reshape (%mean0, %shape) : (!mo.tensor<[1], f32>, !mo.tensor<[0], si64>) -> !mo.tensor<[], f32>
      %cond = mo.greater (%y, %mean1) : (!mo.tensor<[], f32>, !mo.tensor<[], f32>) -> !mo.tensor<[], bool>
      mo.while.condition(%cond) %inner_x : !mo.tensor<[2], f32>
    } do {
      %new_x = mo.add(%inner_x, %inner_x) : !mo.tensor<[2], f32>
      mo.yield %new_x : !mo.tensor<[2], f32>
    }
    %res: !mo.tensor<[2], f32>
  ```
  """

  OPERATION_NAME = "mo.while"

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def condRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def bodyRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def while_(results_, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, WhileOp]:
  op = WhileOp(results_=results_, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)
