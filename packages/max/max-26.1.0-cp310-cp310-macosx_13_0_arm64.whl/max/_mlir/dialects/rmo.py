
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "rmo"

@_ods_cext.register_operation(_Dialect)
class MOArgMaxOp(_ods_ir.OpView):
  r"""
  This op is equivalent to reduce_max, but returns indices instead of values.
  
  The axis attribute specifies the reduction axis.
  
  Like reductions, the output shape is the same as the input shape, except for
  the reduced axis which is set to 1. Moreover, the value of `axis` follows
  numpy semantics, e.g., -1 represents the last axis.
  
  For identical maximum values, the lowest index is returned.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<0, 1, 3, 2> : tensor<2x2xsi32>
    } : !mo.tensor<[2, 2], si32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<si32>
    } : !mo.tensor<[], si32>
    %1 = rmo.mo.arg_max(%0, %axis) : (!mo.tensor<[2, 2], si32>) -> !mo.tensor<[2, 1], si64>
  ```
  """

  OPERATION_NAME = "rmo.mo.arg_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_arg_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOArgMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOArgMinOp(_ods_ir.OpView):
  r"""
  This op is equivalent to reduce_min, but returns indices instead of values.
  
  The axis attribute specifies the reduction axis.
  
  Like reductions, the output shape is the same as the input shape, except for
  the reduced axis which is set to 1. Moreover, the value of `axis` follows
  numpy semantics, e.g., -1 represents the last axis.
  
  For identical minimum values, the lowest index is returned.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<0, 1, 3, 2> : tensor<2x2xsi32>
    } : !mo.tensor<[2, 2], si32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<si32>
    } : !mo.tensor<[], si32>
    %1 = rmo.mo.arg_min(%0, %axis) : (!mo.tensor<[2, 2], si32>) -> !mo.tensor<[2, 1], si64>
  ```
  """

  OPERATION_NAME = "rmo.mo.arg_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_arg_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOArgMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceMaxOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their maximum, changing that
  axis's dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.reduce.max(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.reduce.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_reduce_max(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOReduceMaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceMinOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their minimum, changing that
  axis's dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.reduce.min(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.reduce.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_reduce_min(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOReduceMinOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise add operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise and comparison operation with implicit broadcasting.
  
  Returns elementwise `x & y`, where `x` and `y` are boolean input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = rmo.and(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], bool>,
                                  !mo.tensor<[2, 3], bool>
                                  ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def and_(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AvgPoolOp(_ods_ir.OpView):
  r"""
  Computes average pooling with the given filter shape, strides, and dilations.
  
  For now the op only supports 2d average pooling (so input must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  Example:
  
  ```mlir
  %res = rmo.avg_pool(%input) {
    filter_shape = #mosh<ape<2, 3>> : !mosh.ape
    strides = #mosh<ape<2, 3>> : !mosh.ape
    dilations = #mosh<ape<1, 1>> : !mosh.ape
    paddings = #mosh<ape<0, 0, 0, 0>> : !mosh.ape
    ceil_mode = false
    count_boundary = true
  } : (
    !mo.tensor<[1, 6, 15, 1], f32>,
  ) -> !mo.tensor<[1, 3, 5, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter_shape, strides, dilations, paddings, ceil_mode, count_boundary, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["filter_shape"] = (filter_shape if (
    isinstance(filter_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(filter_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["ceil_mode"] = (ceil_mode if (
    isinstance(ceil_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Attribute:
    return self.operation.attributes["filter_shape"]

  @filter_shape.setter
  def filter_shape(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_shape"] = value

  @builtins.property
  def strides(self) -> _ods_ir.Attribute:
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self) -> _ods_ir.Attribute:
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def ceil_mode(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceil_mode"] = value

  @builtins.property
  def count_boundary(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def avg_pool(input, filter_shape, strides, dilations, paddings, ceil_mode, count_boundary, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AvgPoolOp(input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, ceil_mode=ceil_mode, count_boundary=count_boundary, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastLikeOp(_ods_ir.OpView):
  r"""
  Equivalent to the following:
  
    ```
    %shape_of = rmo.shape_of(%like)
    %result = rmo.broadcast_to(%broadcast, %shape_of)
    ```
  """

  OPERATION_NAME = "rmo.broadcast_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, shapeLike, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(shapeLike)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def shapeLike(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def broadcast_like(result, input, shape_like, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BroadcastLikeOp(result=result, input=input, shapeLike=shape_like, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BroadcastToOp(_ods_ir.OpView):
  r"""
  Broadcasts the input tensor to the specified shape.
  
  Shape restrictions:
  1. `newShape` must have known rank.
  2. `newShape` may not contain any dynamic dimensions.
  """

  OPERATION_NAME = "rmo.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, newShape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["newShape"] = (newShape if (
    isinstance(newShape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(newShape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newShape(self) -> _ods_ir.Attribute:
    return self.operation.attributes["newShape"]

  @newShape.setter
  def newShape(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["newShape"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def broadcast_to(input, new_shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BroadcastToOp(input=input, newShape=new_shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  Concatenates the input tensors along a given dimension.
  
  `mo.concat` concatenates the `inputs` tensors into an output tensor. There
  must be at least 1 input tensor. The input tensors and output tensors all
  has the same shape except along the constant concatenation dimension `axis`.
  The size of the concatenation dimension in output tensor would have be the
  sum of sizes of the concatenation dimension in input tensors.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Shape restrictions:
  1. All inputs must have known and equal ranks.
  2. Input dimensions must match along non-concat-axis.
  
  Example:
  
  ```mlir
    %arg0: !mo.tensor<[2, 3], f32>
    %arg1: !mo.tensor<[2, 5], f32>
    %res = rmo.concat(%arg0, %arg1) {axis = 1}  : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 5], f32>
    ) -> !mo.tensor<[2, 8], f32>
  ```
  """

  OPERATION_NAME = "rmo.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, axis, *, out_dim=None, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_IntegerAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_IntegerAttr')(axis, context=_ods_context))
    if out_dim is not None: attributes["out_dim"] = (out_dim if (
        isinstance(out_dim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_1145')) else
          _ods_ir.AttrBuilder.get('anonymous_1145')(out_dim, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def out_dim(self) -> _Optional[_ods_ir.Attribute]:
    if "out_dim" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_dim"]

  @out_dim.setter
  def out_dim(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["out_dim"] = value
    elif "out_dim" in self.operation.attributes:
      del self.operation.attributes["out_dim"]

  @out_dim.deleter
  def out_dim(self):
    del self.operation.attributes["out_dim"]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat(inputs, axis, *, out_dim=None, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(inputs=inputs, axis=axis, out_dim=out_dim, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvOp(_ods_ir.OpView):
  r"""
  Computes the convolution product of the input with the given filter,
  strides, dilations, paddings, and groups.
  
  The op supports 1D-3D convolution, with the following layout assumptions:
  - input has channel last layout. For 2D, that's NHWC, i.e.,
    (batch_size, height, width, in_channels)
  - filter has layout RSCF, i.e.,
    (height, width, in_channels / num_groups, out_channels)
  
  `strides`, `dilations`, and `padding` are all shape attributes.
  If the input has static rank, and must have have sizes of `input_rank - 2`,
  except padding, which must have size `2 * (input_rank - 2)`. Individual
  elements in the hyperparameters apply to corresponding dimensions of the
  input (after ignoring the batch and channel dimensions), with padding
  representing a before/after pair for each axis.
  
  The padding values are expected to take the form (pad_dim1_before,
  pad_dim1_after, pad_dim2_before, pad_dim2_after...) and represent padding
  0's before and after the indicated *spatial* dimensions in `input`. In 2D
  Convolution, dim1 here represents H and dim2 represents W. In python like
  syntax, padding a 2x3 spatial `input` with [0, 1, 2, 1] would yield:
  
  ```python
  input = [
    [1, 2, 3],
    [4, 5, 6]
  ]
  # Shape is 2x3
  
  padded_input = [
    [0, 0, 1, 2, 3, 0],
    [0, 0, 4, 5, 6, 0]
    [0, 0, 0, 0, 0, 0]
  ]
  # Shape is 3x6
  ```
  
  The input, output and filter tensors' ranks must match.
  
  The number of input and output channels must both be divisible by the number
  of groups `num_groups`.
  
  Example:
  
  ```mlir
  %input: !mo.tensor<[10, 5, 5, 32], f32>,
  %filter: !mo.tensor<[2, 2, 32, 64], f32>
  
  %result = rmo.conv(%input, %filter) {
    strides = #mosh<ape[2, 2]> : !mosh.ape,
    paddings = #mosh<ape[0, 0, 0, 0]> : !mosh.ape,
    dilations = #mosh<ape[1, 1]> : !mosh.ape,
    num_groups = 1 : si64
  } : (
    !mo.tensor<[10, 5, 5, 32], f32>, !mo.tensor<[2, 2, 32, 64], f32>
  ) -> !mo.tensor<[10, 4, 4, 64], f32>
  ```
  """

  OPERATION_NAME = "rmo.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter, strides, dilations, paddings, num_groups, *, input_layout=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["num_groups"] = (num_groups if (
    isinstance(num_groups, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI64Attr')) else
      _ods_ir.AttrBuilder.get('SI64Attr')(num_groups, context=_ods_context))
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Attribute:
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self) -> _ods_ir.Attribute:
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def num_groups(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def input_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conv(input, filter, strides, dilations, paddings, num_groups, *, input_layout=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvOp(input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, num_groups=num_groups, input_layout=input_layout, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvTransposeOp(_ods_ir.OpView):
  r"""
  This op effectively computes the gradient of a convolution with
  respect to its input (as if the original convolution operation had the same
  filter and hyperparameters as this op). A visualization of the computation
  can be found in https://d2l.ai/chapter_computer-vision/transposed-conv.html.
  
  The op supports 1D-3D spatial dimensions, with the following layout
  assumptions (note the `out_channel` is w.r.t. the original convolution):
  - input has channel last layout.For 2D, that's NHWC, i.e.,
    (batch_size, height, width, out_channels)
  - filter has layout RSFC, i.e., (height, width, out_channels, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding, output_paddings) must
  be of rank 1, or unranked. If the input has static rank, all hyperparameters
  with static shape must have sizes of `input_rank - 2`, except padding, which
  must have size `2 * (input_rank - 2)`. Individual elements in the
  hyperparameters applies to corresponding dimensions of the input (after
  ignoring the batch and channel dimensions), with padding representing a
  before/after pair for each axis.
  
  The padding values are expected to take the form (pad_dim1_before,
  pad_dim1_after, pad_dim2_before, pad_dim2_after...) and represent padding
  0's before and after the indicated *spatial* dimensions in `input`. In 2D
  ConvTranspose, dim1 here represents H_out and dim2 represents W_out. In
  python like syntax, padding a 2x4 spatial `output` with [0, 1, 2, 1] would
  yield:
  
  ```python
  output = [
    [1, 2, 3, 4],
    [5, 6, 7, 8]
  ]
  # Shape is 2x4
  
  padded_input = [
    [3],
  ]
  # Shape is 1x1
  ```
  
  The `output_paddings` argument is meant to resolve the ambiguity of multiple
  potential output shapes when any stride is greater than 1. Basically,
  we'll add `output_paddings[i]` number of zeros at the end of output's ith
  axis. We only support output_paddings = 0.
  
  The input, output and filter tensors' ranks must match if statically known.
  
  Example:
  
  ```mlir
  %res = rmo.conv_transpose(%input, %filter) {
    strides = #mosh<ape<1, 1>> : !mosh.ape
    dilations = #mosh<ape<1, 1>> : !mosh.ape
    paddings = #mosh<ape<0, 0, 0, 0>> : !mosh.ape
    output_paddings = #mosh<ape<0, 0>> : !mosh.ape
  } : (
    !mo.tensor<[10, 4, 4, 64], f32>, !mo.tensor<[2, 2, 32, 64], f32>,
  ) -> !mo.tensor<[10, 5, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "rmo.conv_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter, strides, dilations, paddings, output_paddings, *, input_layout=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["output_paddings"] = (output_paddings if (
    isinstance(output_paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(output_paddings, context=_ods_context))
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Attribute:
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self) -> _ods_ir.Attribute:
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def output_paddings(self) -> _ods_ir.Attribute:
    return self.operation.attributes["output_paddings"]

  @output_paddings.setter
  def output_paddings(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_paddings"] = value

  @builtins.property
  def input_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def conv_transpose(input, filter, strides, dilations, paddings, output_paddings, *, input_layout=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvTransposeOp(input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, output_paddings=output_paddings, input_layout=input_layout, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise div operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise equality comparison operation with implicit broadcasting and implicit dtype promotion.
  
  Returns `x == y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f64>
    %res = rmo.equal(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], f32>,
                                      !mo.tensor<[2, 3], f64>
                                      ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def equal(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EqualOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterEqualOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise greater than or equal to comparison operation with implicit broadcasting and implicit dtype promotion.
  
  Returns `x >= y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f64>
    %res = rmo.greater_equal(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], f32>,
                                      !mo.tensor<[2, 3], f64>
                                      ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def greater_equal(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GreaterEqualOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GreaterOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise greater than comparison operation with implicit broadcasting and implicit dtype promotion.
  
  Returns `x > y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f64>
    %res = rmo.greater(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], f32>,
                                      !mo.tensor<[2, 3], f64>
                                      ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def greater(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GreaterOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOATanhOp(_ods_ir.OpView):
  r"""
  Computes `atanh(x)`, where `x` is input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.tanh(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_atanh(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOATanhOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAbsOp(_ods_ir.OpView):
  r"""
  Returns `abs(x)`, where `x` is the input tensors.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.abs(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_abs(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOAbsOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAddOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise addition.
  """

  OPERATION_NAME = "rmo.mo.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_add(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOAddOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAndOp(_ods_ir.OpView):
  r"""
  Returns `x and y`, where `x` and `y` are input boolean tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = rmo.mo.and(%lhs, %rhs) : (!mo.tensor<[2, 3], bool>,
                                    !mo.tensor<[2, 3], bool>
                                    ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_and(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOAndOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOArgNonzeroOp(_ods_ir.OpView):
  r"""
  Returns a tensor of coordinates of the nonzero values in the given tensor.
  The return value is a 2D tensor of shape [nnz x rank_in], where nnz is the
  number of nonzero elements in the input tensor, and rank_in is the rank of
  the input tensor. Coordinates are generated in row-major order.
  
  Example:
  
  ```mlir
    %0 = mo.constant {
      value = #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8> : tensor<3x3xsi32>
    } : !mo.tensor<[3, 3], si32>
    %1 = rmo.mo.arg_nonzero(%0) : (!mo.tensor<[3, 3], si32>) -> !mo.tensor<[?, 2], si64>
  ```
  """

  OPERATION_NAME = "rmo.mo.arg_nonzero"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_arg_nonzero(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOArgNonzeroOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAvgPoolCeilOp(_ods_ir.OpView):
  r"""
  Computes average pooling with the given filter shape, strides, and dilations.
  
  The op supports 2d avg pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<3, 3> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = rmo.mo.avg_pool_ceil_mode_true(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[1, 4, 4, 1], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[1, 2, 2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.avg_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_avg_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOAvgPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOAvgPoolOp(_ods_ir.OpView):
  r"""
  Computes average pooling with the given filter shape, strides, and dilations.
  
  The op supports 2D avg pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. `strides`, `dilations`, `padding`) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<1, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = rmo.mo.avg_pool(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[20, 10, 10, 32], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[20, 9, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.avg_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, count_boundary, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count_boundary"] = (count_boundary if (
    isinstance(count_boundary, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(count_boundary, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def count_boundary(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["count_boundary"]

  @count_boundary.setter
  def count_boundary(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_boundary"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_avg_pool(result, input, filter_shape, strides, dilations, paddings, count_boundary, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOAvgPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, count_boundary=count_boundary, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBandPartOp(_ods_ir.OpView):
  r"""
  Copies a tensor setting everything outside central (diagonal) band of the
  matrices to zero, where all but the last two axes are effectively batches,
  and the last two axes define sub matrices.
  
  Assumes the input has dimensions [I, J, ..., M, N], then the output tensor
  has the same shape as the input, and the values values are given by
  
  out[i, j, ..., m, n] = in_band(m, n) * input[i, j,  ..., m, n].
  
  With the indicator function
  
  in_band(m, n) = ((num_lower < 0 || (m - n) <= num_lower)) &&
                   (num_upper < 0 || (n - m) <= num_upper))
  
  If `exclude` is set, the selection is reverted: The elements in band are set
  to zero while the elements outside the band are copied to the output tensor.
  
  Please explicitly note that with negative values, this kernel returns the
  entire lower or upper triangle of the matrix, and otherwise returns
  a diagonal band around the main diagonal of the matrix.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[3, 2, 3], f32>
    %num_lower = mo.constant {
      value = #M.dense_array<-1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %num_upper = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %exclude = mo.constant {
      value = #M.dense_array<0> : tensor<1xui8>} : !mo.tensor<[], bool>
    %res = rmo.mo.linalg.band_part(%arg, %num_lower, %num_upper, %exclude) : (
      !mo.tensor<[3, 2, 3], f32>, !mo.tensor<[], si64>, !mo.tensor<[], si64>,
      !mo.tensor<[], bool>
      ) -> !mo.tensor<[3, 2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.linalg.band_part"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, num_lower, num_upper, exclude, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(num_lower)
    operands.append(num_upper)
    operands.append(exclude)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def num_lower(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def num_upper(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def exclude(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_linalg_band_part(result, input, num_lower, num_upper, exclude, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOBandPartOp(result=result, input=input, num_lower=num_lower, num_upper=num_upper, exclude=exclude, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBatchMatmulOp(_ods_ir.OpView):
  r"""
  Performs matrix multiplication on two batches of matrices, represented by
  two N-dimensional tensors.
  
  The last two dimensions of each input are the matrix dimensions.
  
  Example:
  
  ```mlir
    %lhs: ... !mo.tensor<[3, 4, 5], f32>
    %rhs: ... !mo.tensor<[3, 5, 6], f32>
    %res = mo.batch_matmul(%lhs, %rhs) :
      mo.tensor<[3, 4, 5], f32>, !mo.tensor<[3, 5, 6], f32>
    ) -> !mo.tensor<[3, 4, 6], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.batch_matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, transpose_b=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose_b is not None: attributes["transpose_b"] = (transpose_b if (
        isinstance(transpose_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(transpose_b, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def transpose_b(self) -> _Optional[_ods_ir.BoolAttr]:
    if "transpose_b" not in self.operation.attributes:
      return None
    return self.operation.attributes["transpose_b"]

  @transpose_b.setter
  def transpose_b(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["transpose_b"] = value
    elif "transpose_b" in self.operation.attributes:
      del self.operation.attributes["transpose_b"]

  @transpose_b.deleter
  def transpose_b(self):
    del self.operation.attributes["transpose_b"]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_batch_matmul(result, input_a, input_b, *, transpose_b=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOBatchMatmulOp(result=result, input_a=input_a, input_b=input_b, transpose_b=transpose_b, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBottomKOp(_ods_ir.OpView):
  r"""
  Computes the bottom (lowest) values and their corresponding indices in a
  tensor along a specified axis. Returned values along the axis are always
  sorted (stable).
  
  Example:
  ```mlir
    %in = mo.constant {
      value = #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11> : tensor<2x6xsi64>
    } : !mo.tensor<[2, 6], si64>
    %k = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<3> : tensor<si64> } : !mo.tensor<[], si64>
    %axis = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<si64> } : !mo.tensor<[], si64>
    %sorted = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<1xi1> } : !mo.tensor<[], bool>
    %values, %indices = rmo.mo.bottom_k(%in, %k, %axis, %sorted) : (
      !mo.tensor<[2, 6], si64>, !mo.tensor<[], si64>, !mo.tensor<[], si64>, !mo.tensor<[], bool>
    ) -> (
      !mo.tensor<[2, 3], si64>, !mo.tensor<[2, 3], si64>
    )
  ```
  """

  OPERATION_NAME = "rmo.mo.bottom_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def K(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def sorted(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def mo_bottom_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MOBottomKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOBroadcastShapeOp(_ods_ir.OpView):
  r"""
  Given two tensors representing shapes, calculate the result of broadcasting
  the shapes.
  """

  OPERATION_NAME = "rmo.mo.broadcast_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_broadcast_shape(shape, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOBroadcastShapeOp(shape=shape, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOBroadcastToOp(_ods_ir.OpView):
  r"""
  Broadcast the given `input` to the shape represented in `newShape`.
  """

  OPERATION_NAME = "rmo.mo.broadcast_to"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newShape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_broadcast_to(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOBroadcastToOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCastOp(_ods_ir.OpView):
  r"""
  Casts the given data, changing from one dtype to another.
  """

  OPERATION_NAME = "rmo.mo.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_cast(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOCastOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCeilOp(_ods_ir.OpView):
  r"""
  Returns the smallest largest integer greater than `x`, where `x` is input
  tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.ceil(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_ceil(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOCeilOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOConcatOp(_ods_ir.OpView):
  r"""
  Concatenates the input tensors along a given dimension.
  
  `mo.concat` concatenates the `inputs` tensors into an output tensor. There
  must be at least 1 input tensor. The input tensors and output tensors all
  has the same shape except along the concatenation dimension `axis`. The size
  of the concatenation dimension in output tensor would have be the sum of
  sizes of the concatenation dimension in input tensors.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg0: !mo.tensor<[2, 3], f32>
    %arg1: !mo.tensor<[2, 5], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.concat[%axis: !mo.tensor<[], si64>](%arg0, %arg1) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 5], f32>
    ) -> !mo.tensor<[2, 8], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, axis, inputs, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_concat(result, axis, inputs, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOConcatOp(result=result, axis=axis, inputs=inputs, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOConvOp(_ods_ir.OpView):
  r"""
  Computes the convolution product of the input with the given filter,
  strides, dilations, paddings, and groups.
  
  The op supports 1D-3D convolution, with the following layout assumptions:
  - input has channel last layout. For 2D, that's NHWC, i.e.,
    (batch_size, height, width, in_channels)
  - filter has layout RSCF, i.e.,
    (height, width, in_channels / num_groups, out_channels)
  
  `strides`, `dilations`, and `padding` must be of rank 1, or unranked.
  If the input has static rank, all hyperparameters with static shape must
  have sizes of `input_rank - 2`, except padding, which must have
  size `2 * (input_rank - 2)`. Individual elements in the hyperparameters
  apply to corresponding dimensions of the input (after ignoring the batch
  and channel dimensions), with padding representing a before/after pair for
  each axis.
  
  The padding values are expected to take the form (pad_dim1_before,
  pad_dim1_after, pad_dim2_before, pad_dim2_after...) and represent padding
  0's before and after the indicated *spatial* dimensions in `input`. In 2D
  Convolution, dim1 here represents H and dim2 represents W. In python like
  syntax, padding a 2x3 spatial `input` with [0, 1, 2, 1] would yield:
  
  ```python
  input = [
    [1, 2, 3],
    [4, 5, 6]
  ]
  # Shape is 2x3
  
  padded_input = [
    [0, 0, 1, 2, 3, 0],
    [0, 0, 4, 5, 6, 0]
    [0, 0, 0, 0, 0, 0]
  ]
  # Shape is 3x6
  ```
  
  The input, output and filter tensors' ranks must match if statically known.
  
  `num_groups` must be a ranked scalar. The number of input and output
  channels must both be divisible by the number of groups `num_groups`.
  
  This op currently only supports strides and padding on the input.
  
  Example:
  
  ```mlir
    %st = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %di = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %pa = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>}
      : !mo.tensor<[4], si64>
    %ng = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<si64>}
      : %!mo.tensor<[], si64>
    %res = rmo.mo.conv(%input, %filter) [strides = %st, dilations = %di, paddings = %pa, num_groups = %ng] : (
      !mo.tensor<[10, 5, 5, 32], f32>, !mo.tensor<[2, 2, 32, 64], f32>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>, !mo.tensor<[], si64>
    ) -> !mo.tensor<[10, 4, 4, 64], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(num_groups)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def num_groups(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_conv(result, input, filter, strides, dilations, paddings, num_groups, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOConvOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, num_groups=num_groups, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOConvTransposeOp(_ods_ir.OpView):
  r"""
  This op effectively computes the gradient of a convolution with
  respect to its input (as if the original convolution operation had the same
  filter and hyperparameters as this op). A visualization of the computation
  can be found in https://d2l.ai/chapter_computer-vision/transposed-conv.html.
  
  The op supports 1D-3D spatial dimensions, with the following layout
  assumptions (note the `out_channel` is w.r.t. the original convolution):
  - input has channel last layout.For 2D, that's NHWC, i.e.,
    (batch_size, height, width, out_channels)
  - filter has layout RSFC, i.e., (height, width, out_channels, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding, output_paddings) must
  be of rank 1, or unranked. If the input has static rank, all hyperparameters
  with static shape must have sizes of `input_rank - 2`, except padding, which
  must have size `2 * (input_rank - 2)`. Individual elements in the
  hyperparameters applies to corresponding dimensions of the input (after
  ignoring the batch and channel dimensions), with padding representing a
  before/after pair for each axis.
  
  The padding values are expected to take the form (pad_dim1_before,
  pad_dim1_after, pad_dim2_before, pad_dim2_after...) and represent padding
  0's before and after the indicated *spatial* dimensions in `input`. In 2D
  ConvTranspose, dim1 here represents H_out and dim2 represents W_out. In
  python like syntax, padding a 2x4 spatial `output` with [0, 1, 2, 1] would
  yield:
  
  ```python
  output = [
    [1, 2, 3, 4],
    [5, 6, 7, 8]
  ]
  # Shape is 2x4
  
  padded_input = [
    [3],
  ]
  # Shape is 1x1
  ```
  
  The `output_paddings` argument is meant to resolve the ambiguity of multiple
  potential output shapes when any stride is greater than 1. Basically,
  we'll add `output_paddings[i]` number of zeros at the end of output's ith
  axis. We only support output_paddings = 0.
  
  The input, output and filter tensors' ranks must match if statically known.
  
  Example:
  
  ```mlir
    %st = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %di = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1, 1> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %pa = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>}
      : !mo.tensor<[4], si64>
    %op = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0> : tensor<2xsi64>}
      : !mo.tensor<[2], si64>
    %res = rmo.mo.conv_transpose(%input, %filter)
      [strides = %st, dilations = %di, paddings = %pa, output_paddings = %op] : (
      !mo.tensor<[10, 4, 4, 64], f32>, !mo.tensor<[2, 2, 32, 64], f32>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>,
      !mo.tensor<[2], si64>
    ) -> !mo.tensor<[10, 5, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.conv_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    operands.append(output_paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if input_layout is not None: attributes["input_layout"] = (input_layout if (
        isinstance(input_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(input_layout, context=_ods_context))
    attributes["filter_layout"] = (filter_layout if (
    isinstance(filter_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filter_layout, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def output_paddings(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def input_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["input_layout"]

  @input_layout.setter
  def input_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_layout"] = value

  @builtins.property
  def filter_layout(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["filter_layout"]

  @filter_layout.setter
  def filter_layout(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_layout"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_conv_transpose(result, input, filter, strides, dilations, paddings, output_paddings, filter_layout, *, input_layout=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOConvTransposeOp(result=result, input=input, filter=filter, strides=strides, dilations=dilations, paddings=paddings, output_paddings=output_paddings, filter_layout=filter_layout, input_layout=input_layout, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCosOp(_ods_ir.OpView):
  r"""
  Returns `cos(x)`, where `x` is input tensor.
  
  Example:
  ```mlir
    %arg : !mo.tensor<[2, 3], f32>
    %res = rmo.mo.cos(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_cos(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOCosOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOCumSumOp(_ods_ir.OpView):
  r"""
  Returns the cumulative summation of input tensors along an axis. By default,
  it copies the first element as is. If the `exclusive` attribute is set to 1,
  then the first element is excluded. The `reverse` attribute causes the
  summation to be done in the opposite direction of the axis.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example of outputs:
  
  ```
    input_x = [1, 2, 3]
    axis=0
    output = [1, 3, 6]
    exclusive=1
    output = [0, 1, 3]
    exclusive=0
    reverse=1
    output = [6, 5, 3]
    exclusive=1
    reverse=1
    output = [5, 3, 0]
  ```
  
  Example:
  
  ```mlir
  %arg: !mo.tensor<[2, 3], f32>
  %axis: !mo.tensor<[], i64>
  %res = rmo.mo.cumsum(%arg, %axis) {exclusive = 1 : index, reverse = 0 : index} : (
    !mo.tensor<[2, 3], f32>., !mo.tensor<[], i64>) -> !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.cumsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, exclusive, reverse, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exclusive"] = (exclusive if (
    isinstance(exclusive, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(exclusive, context=_ods_context))
    attributes["reverse"] = (reverse if (
    isinstance(reverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(reverse, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def exclusive(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["exclusive"]

  @exclusive.setter
  def exclusive(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exclusive"] = value

  @builtins.property
  def reverse(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_cumsum(result, input, axis, exclusive, reverse, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOCumSumOp(result=result, input=input, axis=axis, exclusive=exclusive, reverse=reverse, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MODivOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise division.
  """

  OPERATION_NAME = "rmo.mo.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_div(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MODivOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOEqualOp(_ods_ir.OpView):
  r"""
  Returns `x == y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.equal(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                      !mo.tensor<[2, 3], f32>
                                      ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOErfOp(_ods_ir.OpView):
  r"""
  Computes the Gauss error function of the input tensor elements.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.erf(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_erf(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOErfOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOExpOp(_ods_ir.OpView):
  r"""
  Returns `exp(x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.exp(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_exp(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOExpOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOFloorOp(_ods_ir.OpView):
  r"""
  Returns the elementwise largest integer not greater than `x`, where `x` is
  input tensor.
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.floor(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_floor(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOFloorOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGatherNdOp(_ods_ir.OpView):
  r"""
  Variant of `mo.gather` that accepts multi-dimensional indices.
  
  The last dimension stores the index whereas
  the outer dimensions act like batch dimensions. The size of the last
  dimension is at most the rank of the input. When the dimension size is less
  than the rank of the input, slices of the input are gathered, starting from
  the leftmost dimension.
  
  ```
  output_shape = (
      batch_dims_shape + list(indices.shape)[batch_dims:-1]
      if (indices.shape[-1] == data_rank - batch_dims)
      else batch_dims_shape
      + list(indices.shape)[batch_dims:-1]
      + list(data.shape)[batch_dims + indices.shape[-1] :]
  )
  ```
  
  ```mlir
    %input = mo.constant {device = #M.device_ref<"cpu", 0>, value =
      #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15> :
      tensor<2x2x4xsi64>} : !mo.tensor<[2, 2, 4], si64>
    %indices = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<0, 0, 0> : tensor<3xsi64>} :
      !mo.tensor<[3], si64>
  
    %result = rmo.mo.gather_nd(%input, %indices) {batchDims = 0} :
      (!mo.tensor<[2, 2, 4], si64>, !mo.tensor<[3], si64>) ->
      !mo.tensor<[], si64>
  ```
  """

  OPERATION_NAME = "rmo.mo.gather_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, batchDims, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["batchDims"] = (batchDims if (
    isinstance(batchDims, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(batchDims, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def batchDims(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["batchDims"]

  @batchDims.setter
  def batchDims(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batchDims"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_gather_nd(result, input, indices, batch_dims, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOGatherNdOp(result=result, input=input, indices=indices, batchDims=batch_dims, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGatherOp(_ods_ir.OpView):
  r"""
  Gathers slices from input's axis according to indices.
  
  If input and indices are statically ranked, the output rank must be
  `inputRank - 1 + indicesRank`. In general, the output satisfies the
  following:
  ```
  output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =
    input[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]
  ```
  where `indices` appears at given axis of input.
  
  The values of `axis` and `indices` follows numpy semantics, e.g., -1
  represents the last axis.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[2, 2], f32>
    %indices: !mo.tensor<[2], si64>
    %axis = mo.constant {
      value = #M.dense_array<0> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.gather(%input, %indices, %axis) : (
      !mo.tensor<[2, 2], f32>, !mo.tensor<[2], si64>, !mo.tensor<[], si64>
    ) -> !mo.tensor<[2, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_gather(result, input, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOGatherOp(result=result, input=input, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGreaterEqualOp(_ods_ir.OpView):
  r"""
  Returns `x >= y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.greater_equal(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                              !mo.tensor<[2, 3], f32>
                                              ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.greater_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_greater_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOGreaterEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOGreaterOp(_ods_ir.OpView):
  r"""
  Returns `x > y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.greater(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                        !mo.tensor<[2, 3], f32>
                                        ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_greater(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOGreaterOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOIsInfOp(_ods_ir.OpView):
  r"""
  Returns true if `x` represents a floating point Inf, where `x` is input
  tensor.
  
  Example:
  
  ```mlir
    %x: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.is_inf(%x) : (!mo.tensor<[2, 3], f32>
                          ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.is_inf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_is_inf(result, input_x, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOIsInfOp(result=result, input_x=input_x, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOIsNaNOp(_ods_ir.OpView):
  r"""
  Returns true if `x` represents a floating point NaN, where `x` is input
  tensor.
  
  Example:
  
  ```mlir
    %x: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.is_nan(%x) : (!mo.tensor<[2, 3], f32>
                          ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.is_nan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_is_nan(result, input_x, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOIsNaNOp(result=result, input_x=input_x, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOLog1pOp(_ods_ir.OpView):
  r"""
  Returns `log(1 + x)`, maintaining accuracy for small `x` that could
  otherwise lead to floating-point roundings of the kind `1 + x = 1`.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.log1p(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.log1p"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_log1p(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOLog1pOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOLogOp(_ods_ir.OpView):
  r"""
  Returns the natural logarithm, `log(x)`.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.log(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_log(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOLogOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOLogSoftmaxOp(_ods_ir.OpView):
  r"""
  Returns `log(softmax(x))`, where `x` is input tensor.
  
  The softmax is applied along the last axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.logsoftmax(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.logsoftmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_logsoftmax(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOLogSoftmaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMatmulOp(_ods_ir.OpView):
  r"""
  Performs matrix multiplication on two 2D tensors.
  Example:
  
  ```mlir
    %lhs: ... !mo.tensor<[10, 20], f32>
    %rhs: ... !mo.tensor<[20, 5], f32>
    %res = mo.matmul(%lhs, %rhs) : (
      !mo.tensor<[10, 20], f32>, !mo.tensor<[20, 5], f32>
    ) -> !mo.tensor<[10, 5], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_a, input_b, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_a)
    operands.append(input_b)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_matmul(result, input_a, input_b, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMatmulOp(result=result, input_a=input_a, input_b=input_b, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMaxOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise maximum.
  """

  OPERATION_NAME = "rmo.mo.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_max(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMaxOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMaxPoolCeilOp(_ods_ir.OpView):
  r"""
  Computes max pooling with the given filter shape, strides, and dilations.
  
  The op supports 2d max pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<3, 3> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = rmo.mo.max_pool_ceil_mode_true(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[1, 4, 4, 1], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[1, 2, 2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.max_pool_ceil_mode_true"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_max_pool_ceil_mode_true(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMaxPoolCeilOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMaxPoolOp(_ods_ir.OpView):
  r"""
  Computes max pooling with the given filter shape, strides, and dilations.
  
  For now the op only supports 2d max pooling (so input and filter must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  This op currently only supports strides and dilations on the filter.
  
  Example:
  
  ```mlir
    %fs = mo.constant {
      value = #M.dense_array<2, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %st = mo.constant {
      value = #M.dense_array<1, 2> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %di = mo.constant {
      value = #M.dense_array<1, 1> : tensor<2xsi64>} : !mo.tensor<[2], si64>
    %pa = mo.constant {
      value = #M.dense_array<0, 0, 0, 0> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = rmo.mo.max_pool(%arg) [
        filter_shape = %fs, strides = %st, dilations = %di, paddings = %pa
    ] : (
      !mo.tensor<[20, 10, 10, 32], f32>, !mo.tensor<[2], si64>,
      !mo.tensor<[2], si64>, !mo.tensor<[2], si64>, !mo.tensor<[4], si64>
    ) -> !mo.tensor<[20, 9, 5, 32], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, filter_shape, strides, dilations, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(filter_shape)
    operands.append(strides)
    operands.append(dilations)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def strides(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def dilations(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_max_pool(result, input, filter_shape, strides, dilations, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMaxPoolOp(result=result, input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMeanOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their mean value, changng that
  axis's dimension to 1.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.mean(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.mean"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_mean(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMeanOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMinOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise minimum.
  """

  OPERATION_NAME = "rmo.mo.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_min(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMinOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOModOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise modulus.
  """

  OPERATION_NAME = "rmo.mo.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_mod(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOModOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMulOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise multiplication.
  """

  OPERATION_NAME = "rmo.mo.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_mul(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMulOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMutableLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mutable.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, outTensor, outChain, inBuffer, inChain, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(outTensor)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outTensor(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def mo_mutable_load(out_tensor, out_chain, in_buffer, in_chain, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MOMutableLoadOp(outTensor=out_tensor, outChain=out_chain, inBuffer=in_buffer, inChain=in_chain, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOMutableStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mutable.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, inTensor, inChain, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(inTensor)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inTensor(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_mutable_store(in_buffer, in_tensor, in_chain, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMutableStoreOp(inBuffer=in_buffer, inTensor=in_tensor, inChain=in_chain, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOMutableStoreSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.mutable.store.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, inBuffer, slice, start, stop, step, inChain, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inBuffer)
    operands.append(slice)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inBuffer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def slice(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def stop(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_mutable_store_slice(in_buffer, slice, start, stop, step, in_chain, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOMutableStoreSliceOp(inBuffer=in_buffer, slice=slice, start=start, stop=stop, step=step, inChain=in_chain, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONegativeOp(_ods_ir.OpView):
  r"""
  Returns `-x`, where `x` is input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.negative(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.negative"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_negative(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MONegativeOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONonMaximumSuppressionOp(_ods_ir.OpView):
  r"""
  Filters out boxes that have high intersection-over-union (IOU).
  
  `boxes` is supplied as [y1, x1, y2, x2] where (y1, x1) and (y2, x2) are the
  coordinates of any diagonal pair of box corners and the coordinates can be
  provided as normalized (i.e., lying in the interval [0, 1]) or absolute.
  
   Example:
  
   ```mlir
     %boxes : !mo.tensor<[1, 6, 4], f32>
     %scores : !mo.tensor<[1, 1, 6], f32>
     %maxOutputBoxesPerClass : !mo.tensor<[], si64>
     %iouThreshold : !mo.tensor<[], f32>
     %scoreThreshold : !mo.tensor<[], f32>
     %res = rmo.mo.non_maximum_suppression(%boxes, %scores, %maxOutputBoxesPerClass, %iouThreshold, %scoreThreshold)
       : (!mo.tensor<[1, 6, 4], f32>, !mo.tensor<[1, 1, 6], f32>, !mo.tensor<[], si64>, !mo.tensor<[], f32>, !mo.tensor<[], f32>)
       -> !mo.tensor<[?, ?], si64>
   ```
  """

  OPERATION_NAME = "rmo.mo.non_maximum_suppression"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, boxes, scores, maxOutputBoxesPerClass, iouThreshold, scoreThreshold, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(boxes)
    operands.append(scores)
    operands.append(maxOutputBoxesPerClass)
    operands.append(iouThreshold)
    operands.append(scoreThreshold)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def boxes(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scores(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def maxOutputBoxesPerClass(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def iouThreshold(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def scoreThreshold(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_non_maximum_suppression(output, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MONonMaximumSuppressionOp(output=output, boxes=boxes, scores=scores, maxOutputBoxesPerClass=max_output_boxes_per_class, iouThreshold=iou_threshold, scoreThreshold=score_threshold, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONotEqualOp(_ods_ir.OpView):
  r"""
  Returns elementwise `x != y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.not_equal(%lhs, %rhs) : (!mo.tensor<[2, 3], f32>,
                                          !mo.tensor<[2, 3], f32>
                                          ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_not_equal(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MONotEqualOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MONotOp(_ods_ir.OpView):
  r"""
  Returns `not x` on given input, where input is a boolean tensor.
  
  Example:
  
  ```mlir
    %in: !mo.tensor<[2, 3], bool>
    %res = rmo.mo.not(%in) : (!mo.tensor<[2, 3], bool>) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_not(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MONotOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOOrOp(_ods_ir.OpView):
  r"""
  Returns `x or y`, where `x` and `y` are input boolean tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = rmo.mo.or(%lhs, %rhs) : (!mo.tensor<[2, 3], bool>,
                                   !mo.tensor<[2, 3], bool>
                                   ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_or(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOOrOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPadConstantOp(_ods_ir.OpView):
  r"""
  Pads the `input` tensor with a scalar tensor `constant` according to the
  `paddings`. Assumes input has rank `N`, the `paddings` tensor should have
  shape `(2 * N)`, where each consecutive pair of elements has the form
  `[before, after]`, indicating how many of `constant` to add before and after
  the contents of `input` in that dimension. The size of each dimension D of
  the padded output is: `paddings[2*D] + input.dim(D) + paddings[2*D+1]`.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 3], f32>
    %constant = mo.constant {
      value = #M.dense_array<1.0> : tensor<f32>} : !mo.tensor<[], f32>
    %paddings = mo.constant {
      value = #M.dense_array<1, 0, 1, 1> : tensor<4xsi64>
    } : !mo.tensor<[4], si64>
    %output =   mo.pad.constant(%input, %paddings, %constant) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[4], si64>, !mo.tensor<[], f32>
    ) -> !mo.tensor<[3, 5], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.pad.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, constant, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    operands.append(constant)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def constant(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_pad_constant(result, input, paddings, constant, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOPadConstantOp(result=result, input=input, paddings=paddings, constant=constant, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPadReflectOp(_ods_ir.OpView):
  r"""
  Pads the `input` tensor by reflecting it according to the `paddings`.
  Assumes input has rank `N`, the `paddings` tensor should have shape `(2 *
  N)`, where each consecutive pair of elements has the form `[before, after]`,
  indicating how many of `constant` to add before and after the contents of
  `input` in that dimension. The size of each dimension D of the padded output
  is: `paddings[2*D] + input.dim(D) + paddings[2*D+1]`.
  
  `paddings[D, 0] + input.dim(D) + paddings[D, 1]`.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 3], f32>
    %paddings = mo.constant {
      value = #M.dense_array<1, 0, 1, 1> : tensor<4xsi64>
    } : !mo.tensor<[4], si64>
    %output   = mo.pad.reflect(%input, %paddings) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[4], si64>) ->
      !mo.tensor<[3, 5], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.pad.reflect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_pad_reflect(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOPadReflectOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPadRepeatOp(_ods_ir.OpView):
  r"""
  Pads the `input` tensor by repeating border values according to `paddings`.
  Assumes input has rank `N`, the `paddings` tensor should have shape `(2 *
  N)`, where each consecutive pair of elements has the form `[before, after]`,
  indicating how many of `constant` to add before and after the contents of
  `input` in that dimension. The size of each dimension D of the padded output
  is: `paddings[2*D] + input.dim(D) + paddings[2*D+1]`.
  
  `paddings[D, 0] + input.dim(D) + paddings[D, 1]`.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 3], f32>
    %paddings = mo.constant {
      value = #M.dense_array<1, 0, 1, 1> : tensor<4xsi64>
    } : !mo.tensor<[4], si64>
    %output   = mo.pad.repeat(%input, %paddings) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[4], si64>) ->
      !mo.tensor<[3, 5], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.pad.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, paddings, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(paddings)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def paddings(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_pad_repeat(result, input, paddings, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOPadRepeatOp(result=result, input=input, paddings=paddings, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOPowOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise power. Allows mixed precision operands.
  """

  OPERATION_NAME = "rmo.mo.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_pow(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOPowOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORandomNormalOp(_ods_ir.OpView):
  r"""
    Returns a tensor with shape `shape` populated with random
    values from a normal distribution, with the mean of the distribution equal
    to `mean` and the standard deviation equal to `variance`.
  
  Example:
    ```mlir
      %size = mo.constant {
        value = #M.dense_array<1, 1, 7, 8> : tensor<4xsi64>} : !mo.tensor<[4], si64>
      %mean = mo.constant {
        value = #M.dense_array<2.0> : tensor<1xf32> } : !mo.tensor<[], f32>
      %variance = mo.constant {
        value = #M.dense_array<0.5> : tensor<1xf32> } : !mo.tensor<[], f32>
      %seed = mo.constant {
        value = #M.dense_array<1> : tensor<1xsi64> } : !mo.tensor<[], si64>
      %res = rmo.mo.random.normal(%size, %mean, %variance, %seed) :
            (!mo.tensor<[4], si64>, !mo.tensor<[], f32>, !mo.tensor<[], f32>,
            !mo.tensor<[], si64>) -> !mo.tensor<[1, 1, 7, 8], f32>
    ```
  """

  OPERATION_NAME = "rmo.mo.random.normal"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, mean, variance, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(mean)
    operands.append(variance)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def mean(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def variance(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_random_normal(result, shape, mean, variance, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MORandomNormalOp(result=result, shape=shape, mean=mean, variance=variance, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORandomUniformOp(_ods_ir.OpView):
  r"""
  Returns a tensor with shape `shape` populated with random
  values from a normal distribution, with the mean of the distribution equal
  to `mean` and the standard deviation equal to `variance`.
  
  Example:
  ```mlir
  %size = mo.constant {
    value = #M.dense_array<1, 1, 7, 8> : tensor<4xsi64>} : !mo.tensor<[4], si64>
  %lowerBound = mo.constant {
    value = #M.dense_array<2.0> : tensor<1xf32> } : !mo.tensor<[], f32>
  %upperBound = mo.constant {
    value = #M.dense_array<0.5> : tensor<1xf32> } : !mo.tensor<[], f32>
  %seed = mo.constant {
    value = #M.dense_array<1> : tensor<1xsi64> } : !mo.tensor<[], si64>
  %res = rmo.mo.random.uniform(%size, %lowerBound, %upperBound, %seed) :
        (!mo.tensor<[4], si64>, !mo.tensor<[], f32>, !mo.tensor<[], f32>,
        !mo.tensor<[], si64>) -> !mo.tensor<[1, 1, 7, 8], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.random.uniform"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, shape, lowerBound, upperBound, seed, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(shape)
    operands.append(lowerBound)
    operands.append(upperBound)
    operands.append(seed)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lowerBound(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def upperBound(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def seed(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_random_uniform(result, shape, lower_bound, upper_bound, seed, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MORandomUniformOp(result=result, shape=shape, lowerBound=lower_bound, upperBound=upper_bound, seed=seed, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORangeOp(_ods_ir.OpView):
  r"""
  Creates a sequence of numbers. The sequence goes from `start` with
  increments of size `step` up to (but not including) `limit`. All arguments
  are mandatory and must have the same element type.
  
  Note the following restrictions on input values:
  1. `step` must be non-zero
  2. `limit - start` must be zero or have the same sign as `step`
  
  Example:
  
  ```mlir
    %limit : !mo.tensor<[], f32>
    %start = mo.constant {
      value = #M.dense_array<0.0> : tensor<f32>} : !mo.tensor<[], f32>
    %step = mo.constant {
      value = #M.dense_array<1.5> : tensor<f32>} : !mo.tensor<[], f32>
    %res = rmo.mo.range(%start, %limit, %step) : (
      !mo.tensor<[], f32>, !mo.tensor<[], f32>, !mo.tensor<[], f32>
    ) -> !mo.tensor<[?], f32>
  
    %startInt = mo.constant {
      value = #M.dense_array<1> : tensor<si32>} : !mo.tensor<[], si32>
    %stepInt = mo.constant {
      value = #M.dense_array<2> : tensor<si32>} : !mo.tensor<[], si32>
    %limitInt = mo.constant {
      value = #M.dense_array<11> : tensor<si32>} : !mo.tensor<[], si32>
    %oddNumbersBelowTen = rmo.mo.range(%startInt, %limitInt, %stepInt) : (
      !mo.tensor<[], si32>, !mo.tensor<[], si32>, !mo.tensor<[], si32>
    ) -> !mo.tensor<[5], si32>
  ```
  """

  OPERATION_NAME = "rmo.mo.range"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, start, limit, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(start)
    operands.append(limit)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def limit(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_range(result, start, limit, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MORangeOp(result=result, start=start, limit=limit, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceAddOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their sum, changing that axis's
  dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.reduce.add(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.reduce.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_reduce_add(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOReduceAddOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReduceMulOp(_ods_ir.OpView):
  r"""
  Reduces `input` elements across `axis` to their product, changing that
  axis's dimension to 1 in the output shape.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %res = rmo.mo.reduce.mul(%arg, %axis) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[], si64>) -> !mo.tensor<[2, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.reduce.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_reduce_mul(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOReduceMulOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReluOp(_ods_ir.OpView):
  r"""
  Returns `max(0, x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.relu(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_relu(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOReluOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOReshapeOp(_ods_ir.OpView):
  r"""
  Reshape the `input` tensor to the shape represented in `newShape`.
  """

  OPERATION_NAME = "rmo.mo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, newShape, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newShape)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newShape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_reshape(result, input, new_shape, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOReshapeOp(result=result, input=input, newShape=new_shape, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOResizeBicubicOp(_ods_ir.OpView):
  r"""
  Resizes a tensor to a new shape using the bicubic interpolation algorithm.
  
  Bicubic interpolation uses a 4x4 pixel neighborhood and cubic polynomials
  to produce smoother results than linear interpolation. This implementation
  uses Keys' cubic convolution with a = -0.5.
  
  Example:
  ```mlir
    %input : !mo.tensor<[1, 3, 224, 224], f32>
    %size = mo.constant {
      value = #M.dense_array<1, 3, 448, 448> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = rmo.resize.bicubic(%input, %size) :
      (!mo.tensor<[1, 3, 224, 224], f32>, !mo.tensor<[4], si64>) ->
        !mo.tensor<[1, 3, 448, 448], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.resize.bicubic"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_resize_bicubic(result, input, size, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOResizeBicubicOp(result=result, input=input, size=size, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOResizeLinearOp(_ods_ir.OpView):
  r"""
  Resizes a tensor to a new shape using the linear algorithm.
  
  The coordinate transform mode can be half-pixel, align-corners or asymmetric.
  
  When set to true, the antialias attribute causes an antialiasing filter to be applied
  when downscaling.
  """

  OPERATION_NAME = "rmo.mo.resize.linear"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, antialias, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    attributes["antialias"] = (antialias if (
    isinstance(antialias, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(antialias, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def antialias(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["antialias"]

  @antialias.setter
  def antialias(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["antialias"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_resize_linear(result, input, size, coordinate_transform_mode, antialias, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOResizeLinearOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, antialias=antialias, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOResizeNearestOp(_ods_ir.OpView):
  r"""
  Resizes a tensor to a new shape using the nearest-neighbor algorithm.
  
  The coordinate transform mode can be half-pixel, align-corners or asymmetric.
  
  The values for round mode are:
    - 0: HalfDown
    - 1: HalfUp
    - 2: Floor
    - 3: Ceil
  
  Round mode is HalfDown (0) by default.
  
  Example:
  ```mlir
    %input : !mo.tensor<[1, 1, 2, 2], f32>
    %size = mo.constant {
      value = #M.dense_array<1, 1, 7, 8> : tensor<4xsi64>} : !mo.tensor<[4], si64>
    %res = rmo.resize.nearest(%input, %size) {
      coordinate_transform_mode = 0,
      round_mode = 2}:
      (!mo.tensor<[1, 1, 2, 2], f32>, !mo.tensor<[4], si64>) ->
        !mo.tensor<[1, 1, 7, 8], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.resize.nearest"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, size, coordinate_transform_mode, *, round_mode=None, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coordinate_transform_mode"] = (coordinate_transform_mode if (
    isinstance(coordinate_transform_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MO_CoordinateTransformModeAttr')) else
      _ods_ir.AttrBuilder.get('MO_CoordinateTransformModeAttr')(coordinate_transform_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        isinstance(round_mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(round_mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def coordinate_transform_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["coordinate_transform_mode"]

  @coordinate_transform_mode.setter
  def coordinate_transform_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coordinate_transform_mode"] = value

  @builtins.property
  def round_mode(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_resize_nearest(result, input, size, coordinate_transform_mode, *, round_mode=None, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOResizeNearestOp(result=result, input=input, size=size, coordinate_transform_mode=coordinate_transform_mode, round_mode=round_mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORoiAlignOp(_ods_ir.OpView):
  r"""
  ROI align consumes an input tensor and regions of interest in which to apply pooling.
  
  Example:
  ```mlir
    %inp: !mo.tensor<[1, 10, 10, 1], f32>
    %rois: !mo.tensor<[1, 5], f32>
    %output_height = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<5> : tensor<1xsi64>} : !mo.tensor<[], si64>
    %spatial_scale = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1.0> : tensor<1xf32>} : !mo.tensor<[], f32>
    %sampling_ratio = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<2.0> : tensor<1xf32>} : !mo.tensor<[], f32>
  
    %res = rmo.mo.roi_align(%inp, %rois, %output_height, %output_height, %spatial_scale, %sampling_ratio)
      {aligned = false,  mode = "AVG"}
      : (!mo.tensor<[1, 10, 10, 1], f32>,
        !mo.tensor<[1, 5], f32>,
        !mo.tensor<[], si64>,
        !mo.tensor<[], si64>,
        !mo.tensor<[], f32>,
        !mo.tensor<[], f32>) -> !mo.tensor<[1, 5, 5, 1], f32>
  ```
  
  """

  OPERATION_NAME = "rmo.mo.roi_align"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(rois)
    operands.append(output_height)
    operands.append(output_width)
    operands.append(spatial_scale)
    operands.append(sampling_ratio)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["aligned"] = (aligned if (
    isinstance(aligned, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_StringAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_StringAttr')(mode, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rois(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output_height(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output_width(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def spatial_scale(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def sampling_ratio(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def aligned(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def mode(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_roi_align(result, input, rois, output_height, output_width, spatial_scale, sampling_ratio, aligned, mode, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MORoiAlignOp(result=result, input=input, rois=rois, output_height=output_height, output_width=output_width, spatial_scale=spatial_scale, sampling_ratio=sampling_ratio, aligned=aligned, mode=mode, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORoundOp(_ods_ir.OpView):
  r"""
  Returns the elementwise nearest integer, with ties going away from zero.
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.round(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_round(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MORoundOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MORsqrtOp(_ods_ir.OpView):
  r"""
  Returns `1/sqrt(x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.rsqrt(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_rsqrt(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MORsqrtOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterAddOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the sum of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via addition.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] += updates[i][j] if axis = 0,
    output[i][indices[i][j]] += updates[i][j] if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = rmo.mo.scatter.add(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_add(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterAddOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterMaxOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the maximum of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via maximum.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] = max(output[indices[i][j]][j], updates[i][j]) if axis = 0,
    output[i][indices[i][j]] = max(output[i][indices[i][j]], updates[i][j]) if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = rmo.mo.scatter.max(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_max(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterMaxOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterMinOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the minimum of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via minimum.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] = min(output[indices[i][j]][j], updates[i][j]) if axis = 0,
    output[i][indices[i][j]] = min(output[i][indices[i][j]], updates[i][j]) if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = rmo.mo.scatter.min(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_min(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterMinOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterMulOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices, and it stores the product of elements with duplicate
  indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is combined with existing element via multiplication.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] *= updates[i][j] if axis = 0,
    output[i][indices[i][j]] *= updates[i][j] if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = rmo.mo.scatter.mul(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_mul(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterMulOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdAddOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the sum of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = rmo.mo.scatter_nd.add(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter_nd.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_nd_add(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterNdAddOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdMaxOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the maximum of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = rmo.mo.scatter_nd.max(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter_nd.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_nd_max(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterNdMaxOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdMinOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the minimum of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = rmo.mo.scatter_nd.min(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter_nd.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_nd_min(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterNdMinOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdMulOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices, and it stores the product of any duplicate indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = rmo.mo.scatter_nd.mul(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter_nd.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_nd_mul(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterNdMulOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterNdOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering slices from updates to input
  according to indices.
  
  Specifically, it treats the last dimension of indices as a vector of
  integers used to index into a copy of the input, and it replaces that
  resulting slice (or scalar) with corresponding slice (or scalar) from
  the updates tensor.
  
  Note that the `slice` shows up in case where the index vector length is
  shorter than the rank of input tensor, i.e., the op will slice the leading
  dimensions.
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 2], f32>
    %updates: !mo.tensor<[1, 3, 2], f32>
    %indices: !mo.tensor<[1, 3, 1], si64>
    %res = rmo.mo.scatter_nd(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 2], f32>, !mo.tensor<[1, 3, 2], f32>, !mo.tensor<[1, 3, 1], si64>
    ) -> !mo.tensor<[4, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter_nd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter_nd(result, input, updates, indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterNdOp(result=result, input=input, updates=updates, indices=indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOScatterOp(_ods_ir.OpView):
  r"""
  Produces an output tensor by scattering elements from updates to input
  according to indices.
  
  It takes in `input`, `updates` and `indices` tensors of the same rank, and a
  scalar axis. The output is a copy of the input, with certain elements
  updated based on `updates` and `indices`.
  
  For each entry in `indices`, the target index for `input` is obtained by
  making a copy of the entry's own index, and then updating the `axis`
  dimension with the value of the `indices` entry. Then the element at this
  target index is updated to the corresponding entry in `updates`.
  
  For instance, in a 2D tensor case, the update corresponding to the [i][j] entry
  is performed as below:
  ```
    output[indices[i][j]][j] = updates[i][j] if axis = 0,
    output[i][indices[i][j]] = updates[i][j] if axis = 1,
  ```
  
  Example:
  
  ```mlir
    %input:   !mo.tensor<[4, 4], f32>
    %updates: !mo.tensor<[2, 3], f32>
    %indices: !mo.tensor<[2, 3], si64>
    %res = rmo.mo.scatter(%inputs, %updates, %indices) : (
      !mo.tensor<[4, 4], f32>, !mo.tensor<[2, 3], f32>, !mo.tensor<[2, 3], si64>
    ) -> !mo.tensor<[4, 4], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, updates, indices, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(updates)
    operands.append(indices)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def updates(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_scatter(result, input, updates, indices, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOScatterOp(result=result, input=input, updates=updates, indices=indices, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSelectOp(_ods_ir.OpView):
  r"""
  Returns `cond ? x : y` (element-wise), where `cond`, `x` and `y` are input
  tensors.
  
  Example:
  
  ```mlir
    %cond: !mo.tensor<[2, 3], bool>
    %x: !mo.tensor<[2, 3], f32>
    %y: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.select(%cond, %x, %y) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, cond, x, y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(x)
    operands.append(y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_select(result, cond, x, y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSelectOp(result=result, cond=cond, x=x, y=y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOShapeOfOp(_ods_ir.OpView):
  r"""
  Calculates the runtime shape of the given tensor as a tensor.
  """

  OPERATION_NAME = "rmo.mo.shape_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(shape)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def shape(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_shape_of(shape, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOShapeOfOp(shape=shape, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSinOp(_ods_ir.OpView):
  r"""
  Returns `sin(x)`, where `x` is input tensor.
  
  Example:
  ```mlir
    %arg : !mo.tensor<[2, 3], f32>
    %res = rmo.mo.sin(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_sin(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSinOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSliceOp(_ods_ir.OpView):
  r"""
  Returns a new tensor with a subset of the elements from an N-dimensional
  `input` tensor. The subset is chosen using the `start`, `stop`, and `step`
  1D index tensors; each index tensor has N elements, one for each dimension
  of the `input` tensor.
  
  The semantics follows the numpy index semantics, such that
  1. For each dimension `i`, `start[i]:stop[i]:step[i]` represents the
     "indexing" along that dimension.
  2. Negative indices are supported for `start` and `stop`, e.g., -1
     represents the largest axis.
  3. Out of bound indices in `start` and `stop` will be clamped to
     [-dim, dim], where `dim` is the dimension in the corresponding axis.
  4. `step` must contain nonzero elements. Negative steps are supported.
  
  Note: the order in which negative indices are resolved matches that of
  python for `start:
  
  1. Normalize negative indices by adding the dimension size.
  2. Apply clipping logic.
  
  This means the equivalent mo.slice for l[:-1:-1] returns an empty result.
  If we want to reverse the values in `l` we should do l[:-N-1:-1] where
  N is the dimension size. Numbers smaller than -N-1 should also work.
  
  Example:
  ```mlir
    %input: !mo.tensor<[?, ?], f32>
    %start: !mo.tensor<[2], si64> // [1, -6]
    %stop: !mo.tensor<[2], si32>  // [-3, 6]
    %step: !mo.tensor<[2], si64>  // [5, 1]
    // equivalent to this in numpy: `input[1:-3:5, -6:6:1]`
    %res = rmo.mo.slice(%input, %start, %stop, %step) : (
      !mo.tensor<[10, 10], f32>,
      !mo.tensor<[2], si64>,
      !mo.tensor<[2], si32>,
      !mo.tensor<[2], si64>
    ) -> !mo.tensor<[?, ?], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, start, stop, step, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(start)
    operands.append(stop)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def stop(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_slice(result, input, start, stop, step, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSliceOp(result=result, input=input, start=start, stop=stop, step=step, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSoftmaxOp(_ods_ir.OpView):
  r"""
  Returns `exp(input) / sum(exp(input))`, where `x` is input tensor.
  
  The `sum` reduction is applieed along the last axis.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.softmax(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_softmax(result, input, axis, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSoftmaxOp(result=result, input=input, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSplitOp(_ods_ir.OpView):
  r"""
  Splits the input tensor into multiple tensors along a given dimension.
  
  `mo.split` splits the tensor `input` into multiple output tensors.
  The number of output tensors is equal to the number of elements in
  `splitSizes`, which is a rank-1 tensor of integers.
  Each of the output tensors has the same shape as `input` except along the
  split dimension `axis`, where the size is given by the corresponding
  element in `splitSizes`.
  
  The value of `axis` follows numpy semantics, e.g., -1 represents the last
  axis.
  
  Example:
  
  ```mlir
    %input: !mo.tensor<[2, 8], f32>
    %splitSizes = mo.constant {
      value = #M.dense_array<3, 5> : tensor<2xsi64>
    } : !mo.tensor<[2], si64>
    %axis = mo.constant {
      value = #M.dense_array<1> : tensor<1xsi64>
    } : !mo.tensor<[], si64>
    %res = rmo.mo.split[%axis: !mo.tensor<[], si64>](%input, %splitSizes) : (
      !mo.tensor<[2, 8], f32>, !mo.tensor<[2], si64>
    ) -> (!mo.tensor<[2, 3], f32>, !mo.tensor<[2, 5], f32>)
  ```
  """

  OPERATION_NAME = "rmo.mo.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, input, splitSizes, axis, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(splitSizes)
    operands.append(axis)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def splitSizes(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def mo_split(results_, input, split_sizes, axis, *, output_param_decls=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MOSplitOp]:
  op = MOSplitOp(results_=results_, input=input, splitSizes=split_sizes, axis=axis, outputParamDecls=output_param_decls, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MOSqrtOp(_ods_ir.OpView):
  r"""
  Returns `sqrt(x)`, where `x` is the input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.sqrt(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_sqrt(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSqrtOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSqueezeShapeOp(_ods_ir.OpView):
  r"""
  Calculates the shape from squeeze like operators. Given an input shape
  vector representing a tensor of rank `N`, and a list of indices of length
  `M`, returns a new shape vector representing a tensor of rank `N - M`. The
  indices represent the 0-based index of dimensions in the original rank `N`
  tensor.
  
  The indicated indices must represent dimensions of size 1. If
  an index does not point to a dimension to size 1, an error is thrown
  instead.
  
  This operator supports negative indexing with python-like semantics.
  That is all indices must be in [-N, N), if an index is < 0, it is as if
  we added `N` to it.
  
  Example:
  
  ```mlir
    %input_shape : !mo.tensor<[8], si32>
    %indices : !mo.tensor<[4], si32>
    %res = rmo.mo.squeeze_shape(%input_shape, %indices) : (!mo.tensor<[8], si32>, !mo.tensor<[4], si32>) -> !mo.tensor<[4], si32>
  ```
  """

  OPERATION_NAME = "rmo.mo.squeeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, remove_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(remove_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def remove_indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_squeeze_shape(result, input_shape, remove_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSqueezeShapeOp(result=result, input_shape=input_shape, remove_indices=remove_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOSubOp(_ods_ir.OpView):
  r"""
  Does a non-broadcasted elementwise subtraction.
  """

  OPERATION_NAME = "rmo.mo.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_sub(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOSubOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTanhOp(_ods_ir.OpView):
  r"""
  Computes `tanh(x)`, where `x` is input tensor.
  
  Example:
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.tanh(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_tanh(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOTanhOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTileOp(_ods_ir.OpView):
  r"""
  Returns a new Tensor as the result of copying the input tensor N_i times
  on each dimension, where N_i = tiles[i].
  
  The i-th dimension of output shape will be the ith dimension of input shape
  multiplied by N_i.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[2, 3], f32>
    %repeats : !mo.tensor<[2], si64>
    %res = rmo.mo.tile(%input, %repeats) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2], si64>) -> !mo.tensor<[?, ?], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, repeats, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(repeats)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def repeats(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_tile(result, input, repeats, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOTileOp(result=result, input=input, repeats=repeats, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTopKOp(_ods_ir.OpView):
  r"""
  Computes the largest values and their corresponding indices in a tensor
  along a specified axis. Returned values along the axis are always sorted
  (stable).
  
  Example:
  ```mlir
    %in = mo.constant {
      value = #M.dense_array<0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11> : tensor<2x6xsi64>
    } : !mo.tensor<[2, 6], si64>
    %k = mo.constant() { value = #M.dense_array<3> : tensor<si64> } : !mo.tensor<[], si64>
    %axis = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<si64> } : !mo.tensor<[], si64>
    %sorted = mo.constant {device = #M.device_ref<"cpu", 0>, value = #M.dense_array<1> : tensor<1xi1> } : !mo.tensor<[], bool>
    %values, %indices = rmo.mo.top_k(%in, %k, %axis, %sorted) : (
      !mo.tensor<[2, 6], si64>, !mo.tensor<[], si64>, !mo.tensor<[], si64>, !mo.tensor<[], bool>
    ) -> (
      !mo.tensor<[2, 3], si64>, !mo.tensor<[2, 3], si64>
    )
  ```
  """

  OPERATION_NAME = "rmo.mo.top_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, K, axis, sorted, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(K)
    operands.append(axis)
    operands.append(sorted)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def K(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def sorted(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def mo_top_k(values, indices, input, k, axis, sorted, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MOTopKOp(values=values, indices=indices, input=input, K=k, axis=axis, sorted=sorted, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOTransferOp(_ods_ir.OpView):
  OPERATION_NAME = "rmo.mo.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, outChain, input, inChain, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(inChain)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    results.append(outChain)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inChain(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def outChain(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def mo_transfer(result, out_chain, input, in_chain, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MOTransferOp(result=result, outChain=out_chain, input=input, inChain=in_chain, outputParamDecls=output_param_decls, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MOTransposeOp(_ods_ir.OpView):
  r"""
  Returns a new Tensor as the result of permuting the dimensions of the input
  tensor according to the value of perm.
  
  Note that `perm` must contain unique values from `[0, input_rank)`.
  
  Example:
  
  ```mlir
    %input : !mo.tensor<[2, 3], f32>
    %perm : !mo.tensor<[2], si64>
    %res = rmo.mo.transpose(%input, %perm) : (
      !mo.tensor<[2, 3], f32>, !mo.tensor<[2], si64>) -> !mo.tensor<[3, 2], f32>
  
    %input : !mo.tensor<[?, 5, ?], f32>
    %perm : !mo.tensor<[3], si32>
    %res = rmo.mo.transpose(%input, %perm) : (
      !mo.tensor<[?, 5, ?], f32>, !mo.tensor<[3], si32>
    ) -> !mo.tensor<[?, ?, 5], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, perm, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(perm)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def perm(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_transpose(result, input, perm, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOTransposeOp(result=result, input=input, perm=perm, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOTruncOp(_ods_ir.OpView):
  r"""
  Returns the elementwise integer from truncating the decimal. Also known
  as round-toward-zero.
  
  ```mlir
    %arg: !mo.tensor<[2, 3], f32>
    %res = rmo.mo.trunc(%arg) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.mo.trunc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_trunc(result, input, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOTruncOp(result=result, input=input, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOUnsqueezeShapeOp(_ods_ir.OpView):
  r"""
  Calculates the shape from unsqueeze like operators. Given an input shape
  vector representing a tensor of rank `N`, and a list of indices of length
  `M`, returns a new shape vector representing a tensor of rank `N + M`.
  
  The indices in the given list map to the new vector of length `N + M` where
  the indicated dimensions are replaced with `1`. The remaining dimension in
  the original input shape vector are copied over in the non-1 dimensions.
  
  This operator supports negative indexing.
  
  Example:
  
  ```mlir
    %input_shape : !mo.tensor<[3], si32>
    %indices : !mo.tensor<[4], si32>
    %res = rmo.mo.unsqueeze_shape(%input_shape, %indices) : (!mo.tensor<[4], si32>, !mo.tensor<[3], si32>) -> !mo.tensor<[7], si32>
  ```
  """

  OPERATION_NAME = "rmo.mo.unsqueeze_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_shape, padding_indices, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_shape)
    operands.append(padding_indices)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_shape(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def padding_indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_unsqueeze_shape(result, input_shape, padding_indices, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOUnsqueezeShapeOp(result=result, input_shape=input_shape, padding_indices=padding_indices, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MOXorOp(_ods_ir.OpView):
  r"""
  Returns `x xor y`, where `x` and `y` are input boolean tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = rmo.mo.xor(%lhs, %rhs) : (!mo.tensor<[2, 3], bool>,
                                    !mo.tensor<[2, 3], bool>
                                    ) -> !mo.tensor<[2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.mo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input_x, input_y, *, outputParamDecls=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mo_xor(result, input_x, input_y, *, output_param_decls=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MOXorOp(result=result, input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatmulOp(_ods_ir.OpView):
  r"""
  Performs general matrix multiplication with broadcasting.
  
  If the lhs is 1d, it will be reshaped to `1xD`.
  If the rhs is 1d, it will be reshaped to `Dx1`.
  In both cases, the addition `1` dimensions will be removed from the output shape.
  
  For the multiplication, the innermost (rightmost) 2 dimensions are treated as a maxtrix.
  The lhs matrix will have the shape `MxK`.
  The rhs matrix will have the shape `KxN`.
  The output will have the shape `MxN`
  The `K` dimensions must be equivalent in both matrices.
  
  The remaining outer dimensions will be broadcasted.
  
  Example shapes with outputs:
  [K] @ [K] -> []
  [5, K] @ [K] -> [5]
  [K] @ [K, 6] -> [6]
  [4, K] @ [K, 6] -> [4, 6]
  [8, 10, 4, K] @ [8, 1, K, 6] -> [8, 10, 4, 6]
  [10, 4, K] @ [K, 6] -> [10, 4, 6]
  [10, 4, K] @ [K] -> [10, 4]
  [K] @ [10, 4, K, 7] -> [10, 4, 7]
  """

  OPERATION_NAME = "rmo.matmul"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def matmul(input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatmulOp(input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise max operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MaxPoolOp(_ods_ir.OpView):
  r"""
  Computes max pooling with the given filter shape, strides, and dilations.
  
  For now the op only supports 2d max pooling (so input must be
  4D), with the following layout assumption:
  - input has layout NHWC, i.e., (batch_size, height, width, in_channels)
  
  All hyperparameters (i.e. strides, dilations, padding) must be of rank 1, or
  unranked. If the input has static rank, all hyperparameters with static
  shape must have sizes of `input_rank - 2`, except padding, which must have size
  `2 * (input_rank - 2)`. Individual elements in the hyperparameters applies to
  corresponding dimensions of the input (after ignoring the batch and channel dimensions),
  with padding representing a before/after pair for each axis. The padding values
  are expected to take the form (pad_dim1_before, pad_dim1_after, pad_dim2_before,
  pad_dim2_after...). In 2D Convolution, dim1 here represents H and dim2 represents W.
  
  Example:
  
  ```mlir
  %res = rmo.max_pool(%input) {
    filter_shape = #mosh<ape<2, 3>> : !mosh.ape
    strides = #mosh<ape<2, 3>> : !mosh.ape
    dilations = #mosh<ape<1, 1>> : !mosh.ape
    paddings = #mosh<ape<0, 0, 0, 0>> : !mosh.ape
    ceil_mode = false
  } : (
    !mo.tensor<[1, 6, 15, 1], f32>,
  ) -> !mo.tensor<[1, 3, 5, 1], f32>
  ```
  """

  OPERATION_NAME = "rmo.max_pool"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, filter_shape, strides, dilations, paddings, ceil_mode, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["filter_shape"] = (filter_shape if (
    isinstance(filter_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(filter_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    isinstance(strides, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    isinstance(dilations, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(dilations, context=_ods_context))
    attributes["paddings"] = (paddings if (
    isinstance(paddings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('KnownShapeAttr')) else
      _ods_ir.AttrBuilder.get('KnownShapeAttr')(paddings, context=_ods_context))
    attributes["ceil_mode"] = (ceil_mode if (
    isinstance(ceil_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filter_shape(self) -> _ods_ir.Attribute:
    return self.operation.attributes["filter_shape"]

  @filter_shape.setter
  def filter_shape(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filter_shape"] = value

  @builtins.property
  def strides(self) -> _ods_ir.Attribute:
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def paddings(self) -> _ods_ir.Attribute:
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def ceil_mode(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ceil_mode"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def max_pool(input, filter_shape, strides, dilations, paddings, ceil_mode, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MaxPoolOp(input=input, filter_shape=filter_shape, strides=strides, dilations=dilations, paddings=paddings, ceil_mode=ceil_mode, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MinOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise min operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def min(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MinOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ModOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise mod operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mod(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ModOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise mul operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotEqualOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise not equal comparison operation with implicit broadcasting and implicit dtype promotion.
  
  Returns elementwise `x != y`, where `x` and `y` are input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], f32>
    %rhs: !mo.tensor<[2, 3], f64>
    %res = rmo.not_equal(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], f32>,
                                      !mo.tensor<[2, 3], f64>
                                      ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.not_equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def not_equal(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotEqualOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise or comparison operation with implicit broadcasting.
  
  Returns elementwise `x | y`, where `x` and `y` are boolean input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = rmo.or(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], bool>,
                                  !mo.tensor<[2, 3], bool>
                                  ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def or_(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PowOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise pow operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pow(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PowOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RebindTensorShapeOp(_ods_ir.OpView):
  r"""
  Unlike `mo.rebind` this also has the semantics of doing a runtime check
  that the given shapes are compatible.
  
  Right now this is modeled as a side-effect of the operation due to
  limitations of modeling assertions in our stack. In the future this will
  change and this operation may return either an error or a tensor.
  """

  OPERATION_NAME = "rmo.rebind_tensor_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, outputParamDecls=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def message(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def rebind_tensor_shape(output, input, *, output_param_decls=None, message=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RebindTensorShapeOp(output=output, input=input, outputParamDecls=output_param_decls, message=message, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReshapeOp(_ods_ir.OpView):
  r"""
  Returns a tensor with the same underlying data as `input`, but the shape of `newShape`.
  
  A static dimension set to `-1` will be automatically computed.
  
  Shape restrictions:
  1. `newShape` must have known rank.
  2. `newShape` may not contain any dynamic dimensions.
  """

  OPERATION_NAME = "rmo.reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, newShape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["newShape"] = (newShape if (
    isinstance(newShape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(newShape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newShape(self) -> _ods_ir.Attribute:
    return self.operation.attributes["newShape"]

  @newShape.setter
  def newShape(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["newShape"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reshape(input, new_shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReshapeOp(input=input, newShape=new_shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  r"""
  Returns `cond ? x : y` (element-wise), where `cond`, `x` and `y` are input
  tensors.
  
  Broadcasting is handled by first calculating the common shape between `x` and `y`.
  Then, the `cond` shape and common shape are merged to figure out the final shape.
  All inputs are broadcast to the same final shape.
  
  Dtype casting only applies to the `x` and `y` inputs. `cond` must be a bool.
  
  Example:
  
  ```mlir
    %cond: !mo.tensor<[2, 3], bool>
    %x: !mo.tensor<[1, 3], f32>
    %y: !mo.tensor<[2, 3], i8>
    %res = rmo.select(%cond, %x, %y) : !mo.tensor<[2, 3], f32>
  ```
  """

  OPERATION_NAME = "rmo.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, input_x, input_y, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def select(cond, input_x, input_y, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectOp(cond=cond, input_x=input_x, input_y=input_y, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShapeToTensorOp(_ods_ir.OpView):
  r"""
  Converts a statically known shape attr into a 1d tensor of the shape.
  """

  OPERATION_NAME = "rmo.shape_to_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    isinstance(shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(shape, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shape(self) -> _ods_ir.Attribute:
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def shape_to_tensor(shape, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShapeToTensorOp(shape=shape, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  r"""
  Returns a new tensor with a subset of the elements from an N-dimensional
  `input` tensor. The subset is chosen using the `starts`, `stops`, and
  `steps` shape attributes.
  Each shape attributes has N elements, one for each dimension of the `input`
  tensor.
  
  The semantics follows the numpy index semantics, such that
  1. For each dimension `i`, `starts[i]:stops[i]:steps[i]` represents the
     "indexing" along that dimension.
  2. Negative indices are supported for `starts` and `stops`, e.g., -1
     represents the largest axis.
  3. Unlike `mo.slice`, Out of bound indices in `starts` and `stops` are not
     allowed and each must be in [-dim, dim], where `dim` is the dimension in
     the corresponding axis.
  4. `step` must contain nonzero elements. Negative steps are supported.
  
  Note: the order in which negative indices are resolved matches that of
  python for `start:
  
  1. Normalize negative indices by adding the dimension size.
  2. Apply clipping logic.
  
  This means the equivalent mo.slice for l[:-1:-1] returns an empty result.
  If we want to reverse the values in `l` we should do l[:-N-1:-1] where
  N is the dimension size. Numbers smaller than -N-1 should also work.
  
  Example:
  ```mlir
    %input: !mo.tensor<[10, 10], f32>
  
    // equivalent to this in numpy: `input[1:-3:5, -6:6:1]`
    %res = rmo.slice(%input) {starts = #mosh<ape[1, -6]> : !mosh.ape, steps = #mosh<ape[5, 1]> : !mosh.ape, stops = #mosh<ape[-3, 6]> : !mosh.ape} : (
      !mo.tensor<[10, 10], f32>,
    ) -> !mo.tensor<[2, 2], f32>
  ```
  """

  OPERATION_NAME = "rmo.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, starts, stops, steps, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["starts"] = (starts if (
    isinstance(starts, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(starts, context=_ods_context))
    attributes["stops"] = (stops if (
    isinstance(stops, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(stops, context=_ods_context))
    attributes["steps"] = (steps if (
    isinstance(steps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MOSH_ShapeAttr')) else
      _ods_ir.AttrBuilder.get('MOSH_ShapeAttr')(steps, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def starts(self) -> _ods_ir.Attribute:
    return self.operation.attributes["starts"]

  @starts.setter
  def starts(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["starts"] = value

  @builtins.property
  def stops(self) -> _ods_ir.Attribute:
    return self.operation.attributes["stops"]

  @stops.setter
  def stops(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stops"] = value

  @builtins.property
  def steps(self) -> _ods_ir.Attribute:
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def slice(input, starts, stops, steps, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SliceOp(input=input, starts=starts, stops=stops, steps=steps, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise sub operation with implicit broadcasting and implicit dtype promotion.
  """

  OPERATION_NAME = "rmo.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TopKOp(_ods_ir.OpView):
  r"""
  Computes the largest values and their corresponding indices in a tensor
  along a specified axis.
  Returns values sorted along the axis.
  
  axis: The axis to compute the largest values over.
    The axis must be in [-rank, rank).
  k: The number of values to compute.
  
  Example:
  ```mlir
    %input: !mo.tensor<[2, 6], si64>
    %values, %indices = rmo.top_k(%input) {k = 3, axis = 1} :
      (!mo.tensor<[2, 6], si64>) ->
      (!mo.tensor<[2, 3], si64>, !mo.tensor<[2, 3], si64>)
  ```
  """

  OPERATION_NAME = "rmo.top_k"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, k, axis, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["k"] = (k if (
    isinstance(k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI64Attr')) else
      _ods_ir.AttrBuilder.get('SI64Attr')(k, context=_ods_context))
    attributes["axis"] = (axis if (
    isinstance(axis, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI64Attr')) else
      _ods_ir.AttrBuilder.get('SI64Attr')(axis, context=_ods_context))
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def k(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

  @builtins.property
  def axis(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def values(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def top_k(input, k, axis, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return TopKOp(input=input, k=k, axis=axis, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class XorOp(_ods_ir.OpView):
  r"""
  A flexible binary elementwise xor comparison operation with implicit broadcasting.
  
  Returns elementwise `x ^ y`, where `x` and `y` are boolean input tensors.
  
  Example:
  
  ```mlir
    %lhs: !mo.tensor<[2, 2, 3], bool>
    %rhs: !mo.tensor<[2, 3], bool>
    %res = rmo.xor(%lhs, %rhs) : (!mo.tensor<[2, 2, 3], bool>,
                                  !mo.tensor<[2, 3], bool>
                                  ) -> !mo.tensor<[2, 2, 3], bool>
  ```
  """

  OPERATION_NAME = "rmo.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, input_x, input_y, *, outputParamDecls=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input_x)
    operands.append(input_y)
    _ods_context = _ods_get_default_loc_context(loc)
    if outputParamDecls is not None: attributes["outputParamDecls"] = (outputParamDecls if (
        isinstance(outputParamDecls, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MO_ParamDecls')) else
          _ods_ir.AttrBuilder.get('MO_ParamDecls')(outputParamDecls, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def outputParamDecls(self) -> _ods_ir.Attribute:
    return self.operation.attributes["outputParamDecls"]

  @outputParamDecls.setter
  def outputParamDecls(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["outputParamDecls"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def xor(input_x, input_y, *, output_param_decls=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XorOp(input_x=input_x, input_y=input_y, outputParamDecls=output_param_decls, results=results, loc=loc, ip=ip).result
