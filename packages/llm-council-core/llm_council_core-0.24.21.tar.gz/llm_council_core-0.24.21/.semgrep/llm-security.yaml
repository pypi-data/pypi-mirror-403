# Custom Semgrep Rules for LLM Security
# ADR-035: DevSecOps Implementation - Phase 2
# Issue: #208

rules:
  # Rule 1: Detect unsafe pickle loading (arbitrary code execution)
  - id: unsafe-pickle-load
    patterns:
      - pattern-either:
          - pattern: pickle.load(...)
          - pattern: pickle.loads(...)
          - pattern: cPickle.load(...)
          - pattern: cPickle.loads(...)
    message: |
      Pickle deserialization can execute arbitrary code.
      Avoid using pickle for untrusted data. Consider using JSON or a safer serialization format.
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A8:2017 Insecure Deserialization"
      references:
        - https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data

  # Rule 2: Detect LLM output passed directly to exec/eval
  - id: llm-output-to-exec
    patterns:
      - pattern-either:
          - pattern: exec($LLM_OUTPUT)
          - pattern: eval($LLM_OUTPUT)
          - pattern: compile($LLM_OUTPUT, ...)
    message: |
      LLM output should never be passed directly to exec/eval.
      This can lead to arbitrary code execution from prompt injection attacks.
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-94: Improper Control of Generation of Code"
      owasp: "A3:2017 Injection"
      references:
        - https://owasp.org/www-project-top-ten/

  # Rule 3: Detect unbounded loops with LLM calls (DoS risk)
  - id: unbounded-llm-loop
    patterns:
      # Match any code that is inside an infinite loop
      - pattern-inside: |
          while True:
            ...
      # Within that loop, look for common LLM client call patterns
      - pattern-either:
          # OpenAI-style chat completions
          - pattern: $CLIENT.chat.completions.create(...)
          # Generic completions.create (many SDKs use this)
          - pattern: $CLIENT.completions.create(...)
          # Anthropic / OpenRouter-style messages.create
          - pattern: $CLIENT.messages.create(...)
          # Generic responses.create used by some providers
          - pattern: $CLIENT.responses.create(...)
          # Simpler chat(...) entrypoint sometimes used
          - pattern: $CLIENT.chat(...)
          # Fallback: any $CLIENT.$API.create(...) call in the loop
          - pattern: $CLIENT.$API.create(...)
    message: |
      Unbounded loop with LLM API calls detected.
      This can lead to runaway costs and denial of service.
      Add a maximum iteration limit or termination condition.
    languages: [python]
    severity: WARNING
    metadata:
      category: security
      cwe: "CWE-835: Loop with Unreachable Exit Condition"
      references:
        - https://cwe.mitre.org/data/definitions/835.html

  # Rule 4: Detect hardcoded API keys
  # Uses metavariable-regex to avoid false positives on short test strings
  - id: hardcoded-api-key
    patterns:
      - pattern: $KEY = "$VAL"
      - metavariable-regex:
          metavariable: $VAL
          # Match API keys: sk- optionally followed by or-/ant-/proj-
          # then 20+ alphanumeric/underscore/hyphen characters
          regex: ^sk-(?:or-|ant-|proj-)?[A-Za-z0-9_-]{20,}$
    message: |
      Hardcoded API key detected. Use environment variables instead.
      Example: api_key = os.environ.get("OPENROUTER_API_KEY")
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A2:2017 Broken Authentication"

  # Rule 5: Detect prompt injection via f-strings with user input
  - id: prompt-injection-risk
    patterns:
      - pattern: |
          f"...$USER_INPUT..."
      - metavariable-regex:
          metavariable: $USER_INPUT
          regex: (user_input|user_query|query|prompt|request|message)
    message: |
      User input in f-string may be vulnerable to prompt injection.
      Consider sanitizing input or using structured prompts.
    languages: [python]
    severity: WARNING
    metadata:
      category: security
      cwe: "CWE-74: Improper Neutralization of Special Elements in Output"

  # Rule 6: Detect missing rate limiting on API endpoints
  - id: missing-rate-limit
    patterns:
      - pattern-either:
          # OpenAI-style chat completions
          - pattern: |
              @$APP.route(...)
              def $FUNC(...):
                ...
                $CLIENT.chat.completions.create(...)
                ...
          # OpenAI-compatible clients with retries helper
          - pattern: |
              @$APP.route(...)
              def $FUNC(...):
                ...
                $CLIENT.chat.completions_with_retries(...)
                ...
          # Anthropic-style messages API (and similar providers)
          - pattern: |
              @$APP.route(...)
              def $FUNC(...):
                ...
                $CLIENT.messages.create(...)
                ...
      - pattern-not: |
          @limiter.limit(...)
          @$APP.route(...)
          def $FUNC(...):
            ...
    message: |
      API endpoint with LLM call lacks rate limiting.
      Add rate limiting to prevent abuse and cost overruns.
    languages: [python]
    severity: WARNING
    metadata:
      category: security
      cwe: "CWE-770: Allocation of Resources Without Limits"
