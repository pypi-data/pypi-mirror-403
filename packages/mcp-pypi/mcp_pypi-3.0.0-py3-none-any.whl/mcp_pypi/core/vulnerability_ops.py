"""
Vulnerability operations mixin for PyPI client.
"""

import json
import logging
from typing import Any, Dict, List, Optional, Tuple, cast

from packaging.version import Version

from mcp_pypi.core.models import (
    BatchVulnerabilityResult,
    ErrorCode,
    format_error,
)
from mcp_pypi.utils.helpers import sanitize_package_name, sanitize_version

logger = logging.getLogger("mcp-pypi.client")


class VulnerabilityOpsMixin:
    """Mixin providing vulnerability checking operations."""

    async def check_vulnerabilities(
        self,
        package_name: str,
        version: Optional[str] = None,
        limit: int = 20,
        offset: int = 0,
    ) -> Dict[str, Any]:
        """Check for vulnerabilities in a package using the OSV (Open Source Vulnerabilities) API.

        Args:
            package_name: Name of the package to check
            version: Specific version to check (optional, checks all versions if not provided)
            limit: Maximum number of vulnerabilities to return (default: 20)
            offset: Number of vulnerabilities to skip for pagination (default: 0)

        Returns:
            Dictionary containing vulnerability information including CVEs, severity, and fixes
        """
        try:
            # First check if the package exists
            exists_result = await self.check_package_exists(package_name)
            if not exists_result.get("exists", False):
                return cast(
                    Dict[str, Any],
                    format_error(
                        ErrorCode.NOT_FOUND, f"Package {package_name} not found on PyPI"
                    ),
                )

            sanitized_name = sanitize_package_name(package_name)

            # Create cache key for vulnerability data
            # Cache based on package + version (or "all" for all versions)
            cache_key = f"osv:vulnerabilities:{sanitized_name}:{version or 'all'}"

            # Check cache first (vulnerability data changes slowly)
            cached_result = await self.cache.get(cache_key)
            if cached_result:
                logger.debug(f"Cache hit for vulnerability check: {cache_key}")
                return cached_result

            osv_url = "https://api.osv.dev/v1/query"

            # Build the query payload
            payload = {"package": {"name": sanitized_name, "ecosystem": "PyPI"}}

            if version:
                payload["package"]["version"] = sanitize_version(version)

            # Make the API request to OSV
            logger.info(
                f"Checking vulnerabilities for {sanitized_name} {version or 'all versions'}"
            )

            # OSV API expects POST with JSON payload
            response = await self.http.fetch(
                osv_url,
                method="POST",
                headers={"Content-Type": "application/json"},
                data=json.dumps(payload).encode(),
            )

            # Check for errors in response
            if "error" in response:
                logger.error(f"OSV API error: {response['error']}")
                return {
                    "package": package_name,
                    "version": version or "all",
                    "vulnerabilities": [],
                    "error": response["error"],
                }

            # Parse vulnerabilities from response
            vulnerabilities = []
            osv_vulns = response.get("vulns", [])

            for vuln in osv_vulns:
                # Extract affected versions
                affected_versions = []
                for affected in vuln.get("affected", []):
                    if affected.get("package", {}).get("ecosystem") == "PyPI":
                        if (
                            affected.get("package", {}).get("name", "").lower()
                            == sanitized_name.lower()
                        ):
                            for range_info in affected.get("ranges", []):
                                events = range_info.get("events", [])
                                for event in events:
                                    if "introduced" in event:
                                        affected_versions.append(
                                            f">={event['introduced']}"
                                        )
                                    if "fixed" in event:
                                        affected_versions.append(f"<{event['fixed']}")

                # Extract CVE IDs
                cve_ids = [
                    alias
                    for alias in vuln.get("aliases", [])
                    if alias.startswith("CVE-")
                ]

                # Extract severity information
                severity = None
                severity_score = None
                database_specific = vuln.get("database_specific", {})
                if "severity" in database_specific:
                    severity = database_specific["severity"]

                # Check for CVSS scores in different formats
                for detail in vuln.get("severity", []):
                    if detail.get("type") == "CVSS_V3":
                        severity_score = detail.get("score")
                        break

                vulnerability = {
                    "id": vuln.get("id", ""),
                    "summary": vuln.get(
                        "summary", vuln.get("details", "No description available")
                    ),
                    "severity": severity,
                    "severity_score": severity_score,
                    "cve": cve_ids,
                    "affected_versions": affected_versions,
                    "published": vuln.get("published", ""),
                    "modified": vuln.get("modified", ""),
                    "references": [
                        ref.get("url", "") for ref in vuln.get("references", [])
                    ],
                }

                # If a specific version was requested, only include if it's affected
                if version:
                    # Check if this version is affected
                    version_obj = Version(version)
                    is_affected = False

                    for affected in vuln.get("affected", []):
                        if affected.get("package", {}).get("ecosystem") == "PyPI":
                            if (
                                affected.get("package", {}).get("name", "").lower()
                                == sanitized_name.lower()
                            ):
                                for range_info in affected.get("ranges", []):
                                    events = range_info.get("events", [])
                                    introduced = None
                                    fixed = None

                                    for event in events:
                                        if "introduced" in event:
                                            try:
                                                introduced = Version(
                                                    event["introduced"]
                                                )
                                            except:
                                                # Skip non-version strings (like git hashes)
                                                continue
                                        if "fixed" in event:
                                            try:
                                                fixed = Version(event["fixed"])
                                            except:
                                                # Skip non-version strings (like git hashes)
                                                continue

                                    # Check if version is in affected range
                                    if introduced and version_obj >= introduced:
                                        if fixed is None or version_obj < fixed:
                                            is_affected = True
                                            break

                    if is_affected:
                        vulnerabilities.append(vulnerability)
                else:
                    # No specific version requested, include all vulnerabilities
                    vulnerabilities.append(vulnerability)

            # Sort by severity (critical > high > medium > low)
            severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3}

            # Helper function to extract numeric score
            def get_numeric_score(score_value):
                if not score_value:
                    return 0
                if isinstance(score_value, (int, float)):
                    return float(score_value)
                # Handle CVSS strings like "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N"
                if isinstance(score_value, str) and "CVSS" in score_value:
                    return 0  # Complex CVSS strings need parsing, default to 0
                try:
                    return float(score_value)
                except:
                    return 0

            vulnerabilities.sort(
                key=lambda v: (
                    severity_order.get(str(v.get("severity", "")).upper(), 999),
                    -get_numeric_score(v.get("severity_score")),
                )
            )

            # Count vulnerabilities by severity
            critical_count = sum(
                1
                for v in vulnerabilities
                if str(v.get("severity", "")).upper() == "CRITICAL"
            )
            high_count = sum(
                1
                for v in vulnerabilities
                if str(v.get("severity", "")).upper() == "HIGH"
            )
            medium_count = sum(
                1
                for v in vulnerabilities
                if str(v.get("severity", "")).upper() == "MEDIUM"
            )
            low_count = sum(
                1
                for v in vulnerabilities
                if str(v.get("severity", "")).upper() == "LOW"
            )

            # Apply pagination to vulnerability results
            total_vulnerabilities = len(vulnerabilities)
            paginated_vulnerabilities = vulnerabilities[offset : offset + limit]

            # Limit vulnerability details to avoid token limits
            # Only include essential fields for each vulnerability
            limited_vulnerabilities = []
            for vuln in paginated_vulnerabilities:
                limited_vuln = {
                    "id": vuln.get("id"),
                    "summary": vuln.get("summary", "")[:500],  # Limit summary length
                    "severity": vuln.get("severity"),
                    "cve": vuln.get("cve", [])[:5],  # Limit CVE list
                    "affected_versions": vuln.get("affected_versions", [])[
                        :10
                    ],  # Limit versions
                }
                # Only include first 3 references to save space
                if "references" in vuln and vuln["references"]:
                    limited_vuln["references"] = vuln["references"][:3]
                limited_vulnerabilities.append(limited_vuln)

            result = {
                "package": package_name,
                "version": version or "all",
                "vulnerabilities": limited_vulnerabilities,
                "vulnerable": total_vulnerabilities > 0,
                "total_vulnerabilities": total_vulnerabilities,
                "critical_count": critical_count,
                "high_count": high_count,
                "medium_count": medium_count,
                "low_count": low_count,
                "offset": offset,
                "limit": limit,
                "has_more": (offset + limit) < total_vulnerabilities,
            }

            # Add note if vulnerabilities were truncated
            if (offset + limit) < total_vulnerabilities:
                result["note"] = (
                    f"Showing {len(limited_vulnerabilities)} of {total_vulnerabilities} vulnerabilities "
                    f"(offset={offset}, limit={limit}). Use offset/limit parameters to paginate results."
                )

            # Cache the result with configurable TTL
            # Vulnerability data doesn't change frequently, default is 1 hour
            cache_ttl = self.config.vulnerability_cache_ttl
            await self.cache.set(cache_key, result, ttl=cache_ttl)
            logger.debug(
                f"Cached vulnerability data for {cache_key} with TTL {cache_ttl}s"
            )

            return result

        except Exception as e:
            logger.exception(f"Error checking vulnerabilities for {package_name}: {e}")
            return {
                "package": package_name,
                "version": version or "all",
                "vulnerabilities": [],
                "error": {"message": str(e), "code": "vulnerability_check_error"},
            }

    async def check_vulnerabilities_batch(
        self,
        packages: List[Tuple[str, Optional[str]]],
        batch_size: int = 100,
        skip_cached: bool = True,
    ) -> BatchVulnerabilityResult:
        """Check vulnerabilities for multiple packages using OSV batch API.

        Uses /v1/querybatch endpoint (up to 1000 queries per request) for efficiency.
        This is significantly faster than checking packages one by one.

        Args:
            packages: List of (package_name, version) tuples to check.
                      If version is None, checks all versions for that package.
            batch_size: Maximum number of queries per batch request (default: 100, max: 1000)
            skip_cached: If True, skip packages that are already in cache (default: True)

        Returns:
            BatchVulnerabilityResult containing:
            - results: Dict mapping "pkg:version" to vulnerability data
            - total_packages: Total packages requested
            - vulnerable_count: Number of packages with vulnerabilities
            - cached_count: Number of results retrieved from cache
            - queried_count: Number of packages actually queried
            - errors: List of any errors that occurred
        """
        results: Dict[str, Dict[str, Any]] = {}
        errors: List[Dict[str, str]] = []
        cached_count = 0
        queried_count = 0
        vulnerable_count = 0

        # Deduplicate and sanitize packages
        packages_to_check: List[Tuple[str, Optional[str], str]] = []  # (name, version, key)
        for pkg_name, version in packages:
            sanitized_name = sanitize_package_name(pkg_name)
            sanitized_version = sanitize_version(version) if version else None
            cache_key = f"osv:vulnerabilities:{sanitized_name}:{sanitized_version or 'all'}"
            pkg_key = f"{sanitized_name}:{sanitized_version or 'all'}"

            # Check cache first if skip_cached is True
            if skip_cached:
                cached_result = await self.cache.get(cache_key)
                if cached_result:
                    results[pkg_key] = cached_result
                    cached_count += 1
                    if cached_result.get("vulnerable", False):
                        vulnerable_count += 1
                    continue

            packages_to_check.append((sanitized_name, sanitized_version, pkg_key))

        if not packages_to_check:
            return {
                "results": results,
                "total_packages": len(packages),
                "vulnerable_count": vulnerable_count,
                "cached_count": cached_count,
                "queried_count": 0,
            }

        # Process in batches
        osv_batch_url = "https://api.osv.dev/v1/querybatch"
        batch_size = min(batch_size, 1000)  # OSV limit is 1000 queries per request

        for i in range(0, len(packages_to_check), batch_size):
            batch = packages_to_check[i : i + batch_size]

            # Build batch payload
            queries = []
            for sanitized_name, sanitized_version, _ in batch:
                query: Dict[str, Any] = {
                    "package": {"name": sanitized_name, "ecosystem": "PyPI"}
                }
                if sanitized_version:
                    query["package"]["version"] = sanitized_version
                queries.append(query)

            try:
                logger.info(f"Batch checking {len(batch)} packages for vulnerabilities")

                response = await self.http.fetch(
                    osv_batch_url,
                    method="POST",
                    headers={"Content-Type": "application/json"},
                    data=json.dumps({"queries": queries}).encode(),
                )

                if "error" in response:
                    logger.error(f"OSV batch API error: {response['error']}")
                    for _, _, pkg_key in batch:
                        errors.append({"package": pkg_key, "error": str(response["error"])})
                    continue

                # Process results - OSV returns results in same order as queries
                batch_results = response.get("results", [])
                for j, (sanitized_name, sanitized_version, pkg_key) in enumerate(batch):
                    if j >= len(batch_results):
                        errors.append({"package": pkg_key, "error": "No result returned from OSV"})
                        continue

                    osv_result = batch_results[j]
                    osv_vulns = osv_result.get("vulns", [])

                    # Process vulnerabilities similar to single check
                    vulnerabilities = []
                    for vuln in osv_vulns:
                        # Extract affected versions
                        affected_versions = []
                        for affected in vuln.get("affected", []):
                            if affected.get("package", {}).get("ecosystem") == "PyPI":
                                if (
                                    affected.get("package", {}).get("name", "").lower()
                                    == sanitized_name.lower()
                                ):
                                    for range_info in affected.get("ranges", []):
                                        events = range_info.get("events", [])
                                        for event in events:
                                            if "introduced" in event:
                                                affected_versions.append(
                                                    f">={event['introduced']}"
                                                )
                                            if "fixed" in event:
                                                affected_versions.append(f"<{event['fixed']}")

                        # Extract CVE IDs
                        cve_ids = [
                            alias
                            for alias in vuln.get("aliases", [])
                            if alias.startswith("CVE-")
                        ]

                        # Extract severity
                        severity = None
                        severity_score = None
                        database_specific = vuln.get("database_specific", {})
                        if "severity" in database_specific:
                            severity = database_specific["severity"]

                        for detail in vuln.get("severity", []):
                            if detail.get("type") == "CVSS_V3":
                                severity_score = detail.get("score")
                                break

                        vulnerability = {
                            "id": vuln.get("id", ""),
                            "summary": vuln.get(
                                "summary", vuln.get("details", "No description available")
                            )[:500],
                            "severity": severity,
                            "cve": cve_ids[:5],
                            "affected_versions": affected_versions[:10],
                        }

                        # If version specified, only include if affected
                        if sanitized_version:
                            try:
                                version_obj = Version(sanitized_version)
                                is_affected = False

                                for affected in vuln.get("affected", []):
                                    if affected.get("package", {}).get("ecosystem") == "PyPI":
                                        if (
                                            affected.get("package", {}).get("name", "").lower()
                                            == sanitized_name.lower()
                                        ):
                                            for range_info in affected.get("ranges", []):
                                                events = range_info.get("events", [])
                                                introduced = None
                                                fixed = None

                                                for event in events:
                                                    if "introduced" in event:
                                                        try:
                                                            introduced = Version(event["introduced"])
                                                        except Exception:
                                                            continue
                                                    if "fixed" in event:
                                                        try:
                                                            fixed = Version(event["fixed"])
                                                        except Exception:
                                                            continue

                                                if introduced and version_obj >= introduced:
                                                    if fixed is None or version_obj < fixed:
                                                        is_affected = True
                                                        break

                                if is_affected:
                                    vulnerabilities.append(vulnerability)
                            except Exception:
                                vulnerabilities.append(vulnerability)
                        else:
                            vulnerabilities.append(vulnerability)

                    # Count by severity
                    severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3}
                    vulnerabilities.sort(
                        key=lambda v: severity_order.get(str(v.get("severity", "")).upper(), 999)
                    )

                    critical_count = sum(
                        1 for v in vulnerabilities if str(v.get("severity", "")).upper() == "CRITICAL"
                    )
                    high_count = sum(
                        1 for v in vulnerabilities if str(v.get("severity", "")).upper() == "HIGH"
                    )
                    medium_count = sum(
                        1 for v in vulnerabilities if str(v.get("severity", "")).upper() == "MEDIUM"
                    )
                    low_count = sum(
                        1 for v in vulnerabilities if str(v.get("severity", "")).upper() == "LOW"
                    )

                    result = {
                        "package": sanitized_name,
                        "version": sanitized_version or "all",
                        "vulnerabilities": vulnerabilities[:20],
                        "vulnerable": len(vulnerabilities) > 0,
                        "total_vulnerabilities": len(vulnerabilities),
                        "critical_count": critical_count,
                        "high_count": high_count,
                        "medium_count": medium_count,
                        "low_count": low_count,
                    }

                    results[pkg_key] = result
                    queried_count += 1
                    if result["vulnerable"]:
                        vulnerable_count += 1

                    # Cache the result
                    cache_key = f"osv:vulnerabilities:{sanitized_name}:{sanitized_version or 'all'}"
                    cache_ttl = self.config.vulnerability_cache_ttl
                    await self.cache.set(cache_key, result, ttl=cache_ttl)

            except Exception as e:
                logger.exception(f"Error in batch vulnerability check: {e}")
                for _, _, pkg_key in batch:
                    errors.append({"package": pkg_key, "error": str(e)})

        final_result: BatchVulnerabilityResult = {
            "results": results,
            "total_packages": len(packages),
            "vulnerable_count": vulnerable_count,
            "cached_count": cached_count,
            "queried_count": queried_count,
        }

        if errors:
            final_result["errors"] = errors

        return final_result

    async def _find_earliest_safe_version(
        self, package_name: str, min_version: str, max_version: str
    ) -> Optional[str]:
        """Find the earliest version without vulnerabilities between min and max versions.

        For efficiency, this uses a simplified approach that checks common safe versions
        rather than checking every single version.

        Args:
            package_name: Name of the package
            min_version: Minimum version (potentially vulnerable)
            max_version: Maximum version to consider (usually latest)

        Returns:
            The earliest safe version string, or None if no safe version found
        """
        try:
            # For efficiency, we'll use a heuristic approach:
            # 1. Check if the latest version is safe (most common case)
            # 2. If not, get vulnerability info to find safe ranges

            # First check if latest version is safe
            latest_vuln_check = await self.check_vulnerabilities(
                package_name, max_version
            )
            if not latest_vuln_check.get("vulnerable", True):
                # Latest is safe, now find earliest safe version
                # For most packages, security fixes come in minor/patch releases
                # So we'll recommend a reasonable minimum based on the vulnerable version

                try:
                    min_ver = Version(min_version)
                    max_ver = Version(max_version)

                    # If major version changed, recommend at least the new major version
                    if max_ver.major > min_ver.major:
                        return f"{max_ver.major}.0.0"
                    # If minor version changed significantly (>5), recommend recent minor
                    elif max_ver.minor > min_ver.minor + 5:
                        return f"{max_ver.major}.{max_ver.minor - 2}.0"
                    # Otherwise recommend the latest as safest
                    else:
                        return max_version
                except Exception:
                    return max_version

            # If latest is also vulnerable, we need to check the specific vulnerabilities
            # For now, we'll just recommend the latest version as it likely has fewer issues
            return max_version

        except Exception as e:
            logger.warning(f"Error finding safe version for {package_name}: {e}")
            return None
