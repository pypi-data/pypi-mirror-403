"""Vulnerability checking tools for PyPI MCP Server.

Contains tools for checking package vulnerabilities, batch vulnerability checks,
scanning dependency trees, and scanning installed packages.
"""

from __future__ import annotations

import asyncio
import json
import logging
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, cast

from mcp.types import ToolAnnotations

from mcp_pypi.utils.common.validation import (
    make_error_response,
    validate_depth,
    validate_file_path,
    validate_pagination,
)

if TYPE_CHECKING:
    from mcp_pypi.server import PyPIMCPServer

logger = logging.getLogger("mcp-pypi.server")


def register_vulnerability_tools(server: "PyPIMCPServer") -> None:
    """Register vulnerability-related tools with the MCP server.

    Args:
        server: The PyPIMCPServer instance to register tools with.
    """

    @server.mcp_server.tool(
        annotations=ToolAnnotations(readOnlyHint=True, openWorldHint=True),
        tags={"security", "vulnerabilities"},
    )
    async def check_vulnerabilities(
        package_name: str,
        version: Optional[str] = None,
        limit: int = 20,
        offset: int = 0,
    ) -> Dict[str, Any]:
        """Check for known vulnerabilities in a Python package.

        Uses Google's OSV (Open Source Vulnerabilities) database to identify CVEs,
        security advisories, and known issues. Essential for responsible package recommendations.

        When to use:
        - Before recommending any package for production use
        - When evaluating package options for security-sensitive contexts
        - During security audits or dependency updates
        - When users ask about package safety

        Args:
            package_name (str, required): Name of the package to check.
                Must match PyPI package name exactly.
                Examples: "django", "flask", "requests", "pillow"
            version (str, optional): Specific version to check.
                If not provided, checks all known vulnerabilities for the package.
                Format: Semantic version string
                Examples: "2.28.1", "3.2.0", "1.0.0a1"
                Default: None (checks all versions)
            limit (int, optional): Maximum number of vulnerabilities to return.
                Default: 20, Min: 1, Max: 100
            offset (int, optional): Number of vulnerabilities to skip for pagination.
                Default: 0

        Returns:
            Dictionary containing:
            - vulnerable (bool): True if vulnerabilities found
            - total_vulnerabilities (int): Total count of vulnerabilities
            - critical_count (int): Number of CRITICAL severity issues
            - high_count (int): Number of HIGH severity issues
            - medium_count (int): Number of MEDIUM severity issues
            - low_count (int): Number of LOW severity issues
            - vulnerabilities (list): Detailed vulnerability information
              Each item includes: id, summary, severity, cve list, affected_versions
            - offset: Current offset for pagination
            - limit: Number of results returned
            - has_more: Whether there are more results available

        Example usage:
            check_vulnerabilities("django", "3.2.0")
            -> Returns vulnerabilities specific to Django 3.2.0

            check_vulnerabilities("requests", limit=10, offset=0)
            -> Returns first 10 vulnerabilities

        Note: No vulnerabilities doesn't guarantee perfect security, but indicates no known issues in OSV database.
        """
        try:
            # Validate pagination parameters
            limit, offset = validate_pagination(limit, offset, max_limit=100)

            result = await server.client.check_vulnerabilities(
                package_name, version, limit=limit, offset=offset
            )
            if isinstance(result, dict):
                return result
            return make_error_response(str(result), "vulnerability_check_error")
        except Exception as e:
            logger.error(f"Error checking vulnerabilities: {e}")
            return make_error_response(
                f"Error checking vulnerabilities: {str(e)}", "vulnerability_check_error"
            )

    @server.mcp_server.tool(
        annotations=ToolAnnotations(readOnlyHint=True, openWorldHint=True),
        tags={"security", "batch"},
    )
    async def batch_check_vulnerabilities(
        packages: List[Dict[str, Optional[str]]],
        include_details: bool = False,
    ) -> Dict[str, Any]:
        """Check vulnerabilities for multiple packages in one efficient operation.

        Uses OSV batch API for significantly faster vulnerability checking when
        you need to scan multiple packages at once. Perfect for project audits
        and dependency analysis.

        Performance benefit:
        - 50 packages: 1 API call instead of 50
        - 100 packages: 1-2 API calls instead of 100
        - Cache-aware: Skips already-cached packages

        Args:
            packages (list, required): List of package dictionaries with:
                - name (str): Package name (required)
                - version (str, optional): Specific version to check
                Example: [{"name": "requests", "version": "2.28.0"},
                         {"name": "flask"}, {"name": "django", "version": "4.0.0"}]
                Maximum: 100 packages per call
            include_details (bool, optional): Include full vulnerability details
                for each package. Default: False (summary only)

        Returns:
            Dictionary containing:
            - results: Dict mapping "pkg:version" to vulnerability data
            - total_packages: Total packages checked
            - vulnerable_count: Number with vulnerabilities
            - cached_count: Results from cache (instant)
            - queried_count: Fresh API queries made
            - summary: Quick overview of findings
            - errors: Any errors that occurred (if any)

        Example usage:
            batch_check_vulnerabilities([
                {"name": "requests", "version": "2.28.0"},
                {"name": "flask", "version": "2.0.0"},
                {"name": "django", "version": "4.0.0"}
            ])
            -> Returns batch vulnerability data for all packages

        Tip: Use this before check_requirements_txt for faster audits.
        """
        try:
            if not packages:
                return make_error_response("No packages provided", "invalid_input")

            if len(packages) > 100:
                return make_error_response(
                    f"Too many packages ({len(packages)}). Maximum is 100 per call.",
                    "invalid_input",
                )

            packages_list = [
                (pkg.get("name", ""), pkg.get("version"))
                for pkg in packages
                if pkg.get("name")
            ]

            if not packages_list:
                return make_error_response("No valid packages in request", "invalid_input")

            batch_result = await server.client.check_vulnerabilities_batch(
                packages_list, batch_size=100
            )

            response: Dict[str, Any] = {
                "total_packages": batch_result.get("total_packages", 0),
                "vulnerable_count": batch_result.get("vulnerable_count", 0),
                "cached_count": batch_result.get("cached_count", 0),
                "queried_count": batch_result.get("queried_count", 0),
            }

            if include_details:
                response["results"] = batch_result.get("results", {})
            else:
                summary_results = {}
                for pkg_key, result in batch_result.get("results", {}).items():
                    summary_results[pkg_key] = {
                        "vulnerable": result.get("vulnerable", False),
                        "total_vulnerabilities": result.get("total_vulnerabilities", 0),
                        "critical_count": result.get("critical_count", 0),
                        "high_count": result.get("high_count", 0),
                        "medium_count": result.get("medium_count", 0),
                        "low_count": result.get("low_count", 0),
                    }
                response["results"] = summary_results

            if batch_result.get("errors"):
                response["errors"] = batch_result["errors"]

            vuln_count = response["vulnerable_count"]
            total = response["total_packages"]
            response["summary"] = (
                f"All {total} packages are secure!"
                if vuln_count == 0
                else f"Found vulnerabilities in {vuln_count} of {total} packages"
            )

            return response

        except Exception as e:
            logger.error(f"Error in batch vulnerability check: {e}")
            return make_error_response(
                f"Batch vulnerability check failed: {str(e)}", "batch_vulnerability_error"
            )

    @server.mcp_server.tool(
        annotations=ToolAnnotations(readOnlyHint=True, openWorldHint=True),
        tags={"package", "batch"},
    )
    async def batch_check_packages(
        package_names: List[str],
        include_version: bool = True,
        include_summary: bool = False,
    ) -> Dict[str, Any]:
        """Check multiple packages existence and basic info in parallel.

        Quickly verify if packages exist on PyPI and get their basic info.
        Perfect for validating package lists or checking availability.

        Args:
            package_names (list, required): List of package names to check.
                Maximum: 100 packages per call.
                Example: ["requests", "flask", "nonexistent-pkg-12345"]
            include_version (bool, optional): Include latest version info.
                Default: True
            include_summary (bool, optional): Include package summary/description.
                Default: False (faster without)

        Returns:
            Dictionary containing:
            - packages: Dict mapping package name to info (exists, version, summary)
            - found_count: Number of packages that exist
            - not_found: List of packages not found on PyPI
            - total: Total packages checked

        Example usage:
            batch_check_packages(["requests", "flask", "fake-package"])
            -> Returns existence and version info for each
        """
        try:
            if not package_names:
                return make_error_response("No package names provided", "invalid_input")

            if len(package_names) > 100:
                return make_error_response(
                    f"Too many packages ({len(package_names)}). Maximum is 100 per call.",
                    "invalid_input",
                )

            packages_info: Dict[str, Any] = {}
            not_found: List[str] = []

            async def check_package(name: str) -> Tuple[str, Dict[str, Any]]:
                """Check a single package and return result."""
                exists_result = await server.client.check_package_exists(name)
                if not exists_result.get("exists", False):
                    return (name, {"exists": False})

                result: Dict[str, Any] = {"exists": True}

                if include_version:
                    version_info = await server.client.get_latest_version(name)
                    if not version_info.get("error"):
                        result["version"] = version_info.get("version")

                if include_summary:
                    pkg_info = await server.client.get_package_info(name)
                    if not pkg_info.get("error"):
                        info = pkg_info.get("info", {})
                        result["summary"] = info.get("summary", "")

                return (name, result)

            tasks = [check_package(name) for name in package_names]
            results = await asyncio.gather(*tasks, return_exceptions=True)

            for item in results:
                if isinstance(item, BaseException):
                    logger.error(f"Error checking package: {item}")
                    continue
                result_tuple = cast(Tuple[str, Dict[str, Any]], item)
                name, info = result_tuple
                packages_info[name] = info
                if not info.get("exists", False):
                    not_found.append(name)

            return {
                "packages": packages_info,
                "found_count": len(packages_info) - len(not_found),
                "not_found": not_found,
                "total": len(package_names),
            }

        except Exception as e:
            logger.error(f"Error in batch package check: {e}")
            return make_error_response(
                f"Batch package check failed: {str(e)}", "batch_package_check_error"
            )

    @server.mcp_server.tool(
        annotations=ToolAnnotations(readOnlyHint=True, openWorldHint=True),
        tags={"security", "dependencies"},
    )
    async def scan_dependency_vulnerabilities(
        package_name: str,
        version: Optional[str] = None,
        max_depth: int = 2,
        include_dev: bool = False,
    ) -> Dict[str, Any]:
        """Deep scan for vulnerabilities in a package's entire dependency tree.

        Goes beyond surface-level checks to analyze transitive dependencies - the hidden
        packages that your dependencies depend on. Crucial for comprehensive security assessment.

        Why this matters:
        Many vulnerabilities hide in transitive dependencies. A package might be secure,
        but if it depends on vulnerable packages, your project inherits those risks.

        Args:
            package_name (str, required): Root package to analyze.
                The starting point for dependency tree analysis.
                Examples: "flask", "django", "fastapi", "pandas"
            version (str, optional): Specific version to analyze.
                Format: Semantic version string (e.g., "2.0.1")
                Default: None (uses latest stable version)
            max_depth (int, optional): How deep to scan the dependency tree.
                Controls how many levels of transitive dependencies to check.
                Range: 1-3, where 1=direct deps only, 3=deps of deps of deps
                Default: 2 (recommended for balance of thoroughness and speed)
            include_dev (bool, optional): Include development dependencies.
                Whether to scan optional/dev dependencies in addition to required ones.
                Default: False (only scans required dependencies)

        Returns:
            Dictionary containing:
            - all_clear: Boolean for quick security status check
            - vulnerable_packages: List of packages with vulnerabilities
            - severity_summary: Breakdown by severity level
            - recommendation: Human-readable security assessment
            - dependency_tree: Full tree for understanding relationships

        Best for:
        - Comprehensive security evaluation before adoption
        - Understanding the full security impact of a package
        - Finding hidden vulnerabilities in dependency chains
        """
        try:
            # Validate depth parameter (clamp to 1-5)
            max_depth = validate_depth(max_depth, max_depth=5)

            tree_result = await server.client.get_dependency_tree(
                package_name, version, depth=max_depth
            )
            if "error" in tree_result:
                return cast(Dict[str, Any], tree_result)

            packages_to_scan: set = set()
            vulnerable_packages = []
            total_vulnerabilities = 0
            severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

            def extract_packages(node: Dict[str, Any], depth: int = 0) -> None:
                if depth > max_depth:
                    return

                pkg_name = node.get("name", "")
                pkg_version = node.get("version", "")
                if pkg_name:
                    packages_to_scan.add((pkg_name, pkg_version))

                for dep in node.get("dependencies", []):
                    extract_packages(dep, depth + 1)

                if include_dev:
                    for dep in node.get("dev_dependencies", []):
                        extract_packages(dep, depth + 1)

            extract_packages(tree_result)

            packages_list = [
                (pkg_name, pkg_version or None)
                for pkg_name, pkg_version in packages_to_scan
            ]

            batch_result = await server.client.check_vulnerabilities_batch(
                packages_list, batch_size=100
            )

            for pkg_key, vuln_result in batch_result.get("results", {}).items():
                if vuln_result.get("vulnerable", False):
                    vuln_count = vuln_result.get("total_vulnerabilities", 0)
                    total_vulnerabilities += vuln_count

                    severity_counts["critical"] += vuln_result.get("critical_count", 0)
                    severity_counts["high"] += vuln_result.get("high_count", 0)
                    severity_counts["medium"] += vuln_result.get("medium_count", 0)
                    severity_counts["low"] += vuln_result.get("low_count", 0)

                    pkg_name_extracted = vuln_result.get(
                        "package", pkg_key.split(":")[0]
                    )
                    pkg_version_extracted = vuln_result.get("version", "latest")

                    vulnerable_packages.append(
                        {
                            "package": pkg_name_extracted,
                            "version": pkg_version_extracted,
                            "vulnerabilities": vuln_count,
                            "critical": vuln_result.get("critical_count", 0),
                            "high": vuln_result.get("high_count", 0),
                            "summary": (
                                vuln_result.get("vulnerabilities", [])[0].get(
                                    "summary", ""
                                )
                                if vuln_result.get("vulnerabilities")
                                else ""
                            ),
                        }
                    )

            vulnerable_packages.sort(
                key=lambda p: (p["critical"], p["high"], p["vulnerabilities"]),
                reverse=True,
            )

            return {
                "package": f"{package_name} {version or 'latest'}",
                "total_packages_scanned": len(packages_to_scan),
                "vulnerable_packages": vulnerable_packages,
                "total_vulnerabilities": total_vulnerabilities,
                "severity_summary": severity_counts,
                "all_clear": len(vulnerable_packages) == 0,
                "recommendation": (
                    "No vulnerabilities found in dependency tree!"
                    if len(vulnerable_packages) == 0
                    else f"Found {total_vulnerabilities} vulnerabilities in {len(vulnerable_packages)} packages. "
                    f"Review CRITICAL ({severity_counts['critical']}) and HIGH ({severity_counts['high']}) issues first."
                ),
                "dependency_tree": tree_result,
            }

        except Exception as e:
            logger.error(f"Error scanning dependency vulnerabilities: {e}")
            return make_error_response(
                f"Error scanning dependencies: {str(e)}", "dependency_scan_error"
            )

    @server.mcp_server.tool(
        annotations=ToolAnnotations(readOnlyHint=True, openWorldHint=True),
        tags={"security", "environment"},
    )
    async def scan_installed_packages(
        environment_path: Optional[str] = None,
        include_system: bool = False,
        output_format: str = "summary",
    ) -> Dict[str, Any]:
        """Scan installed packages in Python environments for vulnerabilities.

        Analyzes your actual installed packages to identify security risks. Automatically
        detects common virtual environment locations or accepts specific paths.

        Smart detection includes:
        - Virtual environments (.venv, venv, env, virtualenv)
        - Conda environments
        - Poetry/Pipenv environments
        - System packages (with explicit permission)

        Perfect timing:
        - After installing new packages - catch issues immediately
        - Before deploying - ensure production safety
        - During code reviews - verify environment security
        - Regular audits - catch newly discovered vulnerabilities

        Args:
            environment_path: Absolute path to Python environment directory
                           (e.g., /home/user/project/.venv)
                           Auto-detects common locations if not provided
            include_system: Include system packages (default: False)
            output_format: "summary" or "detailed" (default: "summary")

        Returns:
            Dictionary containing:
            - all_clear: Quick boolean security status
            - vulnerability_summary: Count by severity level
            - top_risks: Most critical packages to fix
            - update_commands: Copy-paste commands for fixes
            - recommendation: Human-readable assessment

        Tip: Regular scans catch vulnerabilities discovered after installation.
        """
        try:
            # Validate environment path if provided (prevent path traversal attacks)
            if environment_path:
                is_valid, error_msg = validate_file_path(environment_path)
                if not is_valid:
                    return make_error_response(
                        error_msg or "Invalid environment path", "invalid_path"
                    )

            if not environment_path:
                for venv_name in [".venv", "venv", "env", ".env", "virtualenv"]:
                    venv_path = Path.cwd() / venv_name
                    if venv_path.exists() and (venv_path / "bin" / "pip").exists():
                        environment_path = str(venv_path)
                        break
                    elif (
                        venv_path.exists()
                        and (venv_path / "Scripts" / "pip.exe").exists()
                    ):
                        environment_path = str(venv_path)
                        break

            if environment_path:
                if os.name == "nt":
                    pip_cmd = os.path.join(environment_path, "Scripts", "pip.exe")
                else:
                    pip_cmd = os.path.join(environment_path, "bin", "pip")
                env_type = "virtualenv"

                conda_meta = Path(environment_path) / "conda-meta"
                if conda_meta.exists():
                    env_type = "conda"
            else:
                pip_cmd = "pip"
                env_type = "system"

            try:
                result = subprocess.run(
                    [pip_cmd, "list", "--format=json"],
                    capture_output=True,
                    text=True,
                    check=True,
                )
                installed_packages = json.loads(result.stdout)
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to get package list: {e}")
                return {
                    "error": {
                        "message": f"Failed to get package list: {str(e)}",
                        "code": "pip_list_error",
                    }
                }

            vulnerable_packages = []
            total_packages = len(installed_packages)
            critical_count = 0
            high_count = 0
            medium_count = 0
            low_count = 0

            for pkg in installed_packages:
                pkg_name = pkg["name"]
                pkg_version = pkg["version"]

                vuln_result = await server.client.check_vulnerabilities(
                    pkg_name, pkg_version
                )

                if vuln_result.get("vulnerable", False):
                    vuln_count = vuln_result.get("total_vulnerabilities", 0)
                    critical = vuln_result.get("critical_count", 0)
                    high = vuln_result.get("high_count", 0)
                    medium = vuln_result.get("medium_count", 0)
                    low = vuln_result.get("low_count", 0)

                    critical_count += critical
                    high_count += high
                    medium_count += medium
                    low_count += low

                    latest_version_info = await server.client.get_latest_version(
                        pkg_name
                    )
                    latest_version = latest_version_info.get("version", "unknown")

                    vulnerable_packages.append(
                        {
                            "package": pkg_name,
                            "installed_version": pkg_version,
                            "latest_version": latest_version,
                            "vulnerabilities": vuln_count,
                            "critical": critical,
                            "high": high,
                            "medium": medium,
                            "low": low,
                            "summary": (
                                vuln_result.get("vulnerabilities", [])[0].get(
                                    "summary", ""
                                )
                                if vuln_result.get("vulnerabilities")
                                else "Multiple vulnerabilities found"
                            ),
                        }
                    )

            vulnerable_packages.sort(
                key=lambda p: (
                    p["critical"],
                    p["high"],
                    p["medium"],
                    p["vulnerabilities"],
                ),
                reverse=True,
            )

            update_commands = []
            if vulnerable_packages:
                if env_type in ["virtualenv", "system"]:
                    critical_updates = [
                        p for p in vulnerable_packages if p["critical"] > 0
                    ]
                    high_updates = [
                        p
                        for p in vulnerable_packages
                        if p["high"] > 0 and p["critical"] == 0
                    ]

                    if critical_updates:
                        pkgs = " ".join(
                            [
                                f"{p['package']}=={p['latest_version']}"
                                for p in critical_updates[:5]
                            ]
                        )
                        update_commands.append(f"{pip_cmd} install --upgrade {pkgs}")

                    if high_updates and len(update_commands) < 3:
                        pkgs = " ".join(
                            [
                                f"{p['package']}=={p['latest_version']}"
                                for p in high_updates[:5]
                            ]
                        )
                        update_commands.append(f"{pip_cmd} install --upgrade {pkgs}")

                elif env_type == "conda":
                    for pkg in vulnerable_packages[:5]:
                        update_commands.append(f"conda update {pkg['package']}")

            total_vulnerabilities = critical_count + high_count + medium_count + low_count

            return {
                "environment_type": env_type,
                "environment_path": environment_path or "system",
                "python_version": subprocess.run(
                    [pip_cmd, "--version"], capture_output=True, text=True
                ).stdout.strip(),
                "total_packages": total_packages,
                "vulnerable_packages": (
                    vulnerable_packages
                    if output_format == "detailed"
                    else len(vulnerable_packages)
                ),
                "vulnerability_summary": {
                    "total": total_vulnerabilities,
                    "critical": critical_count,
                    "high": high_count,
                    "medium": medium_count,
                    "low": low_count,
                },
                "top_risks": (
                    vulnerable_packages[:10] if output_format == "summary" else []
                ),
                "all_clear": len(vulnerable_packages) == 0,
                "recommendation": (
                    f"All {total_packages} packages are secure!"
                    if len(vulnerable_packages) == 0
                    else f"Found {total_vulnerabilities} vulnerabilities in {len(vulnerable_packages)} packages. "
                    f"URGENT: Fix {critical_count} CRITICAL and {high_count} HIGH severity issues!"
                ),
                "update_commands": update_commands,
                "scan_timestamp": datetime.now().isoformat(),
            }

        except Exception as e:
            logger.error(f"Error scanning installed packages: {e}")
            return make_error_response(
                f"Error scanning environment: {str(e)}", "environment_scan_error"
            )
