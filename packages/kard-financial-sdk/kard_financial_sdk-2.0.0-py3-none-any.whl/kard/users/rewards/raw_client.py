# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...commons.errors.does_not_exist_error import DoesNotExistError
from ...commons.errors.internal_server_error import InternalServerError
from ...commons.errors.invalid_request import InvalidRequest
from ...commons.errors.unauthorized_error import UnauthorizedError
from ...commons.types.category_option import CategoryOption
from ...commons.types.error_response import ErrorResponse
from ...commons.types.organization_id import OrganizationId
from ...commons.types.purchase_channel import PurchaseChannel
from ...commons.types.state import State
from ...commons.types.user_id import UserId
from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from .types.location_sort_options import LocationSortOptions
from .types.locations_response_object import LocationsResponseObject
from .types.offer_sort_options import OfferSortOptions
from .types.offers_response_object import OffersResponseObject


class RawRewardsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def offers(
        self,
        organization_id: OrganizationId,
        user_id: UserId,
        *,
        page_size: typing.Optional[int] = None,
        page_after: typing.Optional[str] = None,
        page_before: typing.Optional[str] = None,
        filter_purchase_channel: typing.Optional[typing.Sequence[PurchaseChannel]] = None,
        filter_category: typing.Optional[CategoryOption] = None,
        filter_is_targeted: typing.Optional[bool] = None,
        sort: typing.Optional[typing.Union[OfferSortOptions, typing.Sequence[OfferSortOptions]]] = None,
        include: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[OffersResponseObject]:
        """
        Retrieve national brand offers that a specified user is eligible for. Call this endpoint to build out your
        [targeted offers UX experience](/2024-10-01/api/getting-started#b-discover-a-lapsed-customer-clo). Local offers details
        can be found by calling the [Get Eligible Locations](/2024-10-01/api/rewards/locations) endpoint with the
        `includeLocal` query parameter.<br/>
        <b>Required scopes:</b> `rewards:read`

        Parameters
        ----------
        organization_id : OrganizationId

        user_id : UserId

        page_size : typing.Optional[int]

        page_after : typing.Optional[str]

        page_before : typing.Optional[str]

        filter_purchase_channel : typing.Optional[typing.Sequence[PurchaseChannel]]

        filter_category : typing.Optional[CategoryOption]

        filter_is_targeted : typing.Optional[bool]

        sort : typing.Optional[typing.Union[OfferSortOptions, typing.Sequence[OfferSortOptions]]]
            If provided, response will be sorted by the specified fields

        include : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            CSV list of included resources in the response (e.g "categories"). Allowed value is `categories`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[OffersResponseObject]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/issuers/{jsonable_encoder(organization_id)}/users/{jsonable_encoder(user_id)}/offers",
            method="GET",
            params={
                "page[size]": page_size,
                "page[after]": page_after,
                "page[before]": page_before,
                "filter[purchaseChannel]": filter_purchase_channel,
                "filter[category]": filter_category,
                "filter[isTargeted]": filter_is_targeted,
                "sort": sort,
                "include": include,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    OffersResponseObject,
                    parse_obj_as(
                        type_=OffersResponseObject,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 400:
                raise InvalidRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise DoesNotExistError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def locations(
        self,
        organization_id: OrganizationId,
        user_id: UserId,
        *,
        page_size: typing.Optional[int] = None,
        page_after: typing.Optional[str] = None,
        page_before: typing.Optional[str] = None,
        filter_name: typing.Optional[str] = None,
        filter_city: typing.Optional[str] = None,
        filter_zip_code: typing.Optional[str] = None,
        filter_state: typing.Optional[State] = None,
        filter_category: typing.Optional[CategoryOption] = None,
        filter_longitude: typing.Optional[float] = None,
        filter_latitude: typing.Optional[float] = None,
        filter_radius: typing.Optional[int] = None,
        sort: typing.Optional[typing.Union[LocationSortOptions, typing.Sequence[LocationSortOptions]]] = None,
        include: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LocationsResponseObject]:
        """
        Retrieve national and local geographic locations that a specified user has eligible in-store offers at. To
        include local locations, add the `includeLocal` query parameter to your api call. Use this endpoint to build
        out your [map-specific UX experiences](/2024-10-01/api/getting-started#c-discover-clos-near-you-map-view). Please note
        that Longitude and Latitude fields are prioritized over State, City and Zipcode and are the recommended search
        pattern.<br/>
        <br/>
        <b>Required scopes:</b> `rewards:read`

        Parameters
        ----------
        organization_id : OrganizationId

        user_id : UserId

        page_size : typing.Optional[int]

        page_after : typing.Optional[str]

        page_before : typing.Optional[str]

        filter_name : typing.Optional[str]

        filter_city : typing.Optional[str]

        filter_zip_code : typing.Optional[str]

        filter_state : typing.Optional[State]

        filter_category : typing.Optional[CategoryOption]

        filter_longitude : typing.Optional[float]

        filter_latitude : typing.Optional[float]

        filter_radius : typing.Optional[int]

        sort : typing.Optional[typing.Union[LocationSortOptions, typing.Sequence[LocationSortOptions]]]
            If provided, response will be sorted by the specified fields

        include : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            CSV list of included resources in the response (e.g "offers,categories"). Allowed values are `offers` and `categories`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LocationsResponseObject]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/issuers/{jsonable_encoder(organization_id)}/users/{jsonable_encoder(user_id)}/locations",
            method="GET",
            params={
                "page[size]": page_size,
                "page[after]": page_after,
                "page[before]": page_before,
                "filter[name]": filter_name,
                "filter[city]": filter_city,
                "filter[zipCode]": filter_zip_code,
                "filter[state]": filter_state,
                "filter[category]": filter_category,
                "filter[longitude]": filter_longitude,
                "filter[latitude]": filter_latitude,
                "filter[radius]": filter_radius,
                "sort": sort,
                "include": include,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LocationsResponseObject,
                    parse_obj_as(
                        type_=LocationsResponseObject,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 400:
                raise InvalidRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise DoesNotExistError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawRewardsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def offers(
        self,
        organization_id: OrganizationId,
        user_id: UserId,
        *,
        page_size: typing.Optional[int] = None,
        page_after: typing.Optional[str] = None,
        page_before: typing.Optional[str] = None,
        filter_purchase_channel: typing.Optional[typing.Sequence[PurchaseChannel]] = None,
        filter_category: typing.Optional[CategoryOption] = None,
        filter_is_targeted: typing.Optional[bool] = None,
        sort: typing.Optional[typing.Union[OfferSortOptions, typing.Sequence[OfferSortOptions]]] = None,
        include: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[OffersResponseObject]:
        """
        Retrieve national brand offers that a specified user is eligible for. Call this endpoint to build out your
        [targeted offers UX experience](/2024-10-01/api/getting-started#b-discover-a-lapsed-customer-clo). Local offers details
        can be found by calling the [Get Eligible Locations](/2024-10-01/api/rewards/locations) endpoint with the
        `includeLocal` query parameter.<br/>
        <b>Required scopes:</b> `rewards:read`

        Parameters
        ----------
        organization_id : OrganizationId

        user_id : UserId

        page_size : typing.Optional[int]

        page_after : typing.Optional[str]

        page_before : typing.Optional[str]

        filter_purchase_channel : typing.Optional[typing.Sequence[PurchaseChannel]]

        filter_category : typing.Optional[CategoryOption]

        filter_is_targeted : typing.Optional[bool]

        sort : typing.Optional[typing.Union[OfferSortOptions, typing.Sequence[OfferSortOptions]]]
            If provided, response will be sorted by the specified fields

        include : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            CSV list of included resources in the response (e.g "categories"). Allowed value is `categories`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[OffersResponseObject]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/issuers/{jsonable_encoder(organization_id)}/users/{jsonable_encoder(user_id)}/offers",
            method="GET",
            params={
                "page[size]": page_size,
                "page[after]": page_after,
                "page[before]": page_before,
                "filter[purchaseChannel]": filter_purchase_channel,
                "filter[category]": filter_category,
                "filter[isTargeted]": filter_is_targeted,
                "sort": sort,
                "include": include,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    OffersResponseObject,
                    parse_obj_as(
                        type_=OffersResponseObject,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 400:
                raise InvalidRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise DoesNotExistError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def locations(
        self,
        organization_id: OrganizationId,
        user_id: UserId,
        *,
        page_size: typing.Optional[int] = None,
        page_after: typing.Optional[str] = None,
        page_before: typing.Optional[str] = None,
        filter_name: typing.Optional[str] = None,
        filter_city: typing.Optional[str] = None,
        filter_zip_code: typing.Optional[str] = None,
        filter_state: typing.Optional[State] = None,
        filter_category: typing.Optional[CategoryOption] = None,
        filter_longitude: typing.Optional[float] = None,
        filter_latitude: typing.Optional[float] = None,
        filter_radius: typing.Optional[int] = None,
        sort: typing.Optional[typing.Union[LocationSortOptions, typing.Sequence[LocationSortOptions]]] = None,
        include: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LocationsResponseObject]:
        """
        Retrieve national and local geographic locations that a specified user has eligible in-store offers at. To
        include local locations, add the `includeLocal` query parameter to your api call. Use this endpoint to build
        out your [map-specific UX experiences](/2024-10-01/api/getting-started#c-discover-clos-near-you-map-view). Please note
        that Longitude and Latitude fields are prioritized over State, City and Zipcode and are the recommended search
        pattern.<br/>
        <br/>
        <b>Required scopes:</b> `rewards:read`

        Parameters
        ----------
        organization_id : OrganizationId

        user_id : UserId

        page_size : typing.Optional[int]

        page_after : typing.Optional[str]

        page_before : typing.Optional[str]

        filter_name : typing.Optional[str]

        filter_city : typing.Optional[str]

        filter_zip_code : typing.Optional[str]

        filter_state : typing.Optional[State]

        filter_category : typing.Optional[CategoryOption]

        filter_longitude : typing.Optional[float]

        filter_latitude : typing.Optional[float]

        filter_radius : typing.Optional[int]

        sort : typing.Optional[typing.Union[LocationSortOptions, typing.Sequence[LocationSortOptions]]]
            If provided, response will be sorted by the specified fields

        include : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            CSV list of included resources in the response (e.g "offers,categories"). Allowed values are `offers` and `categories`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LocationsResponseObject]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/issuers/{jsonable_encoder(organization_id)}/users/{jsonable_encoder(user_id)}/locations",
            method="GET",
            params={
                "page[size]": page_size,
                "page[after]": page_after,
                "page[before]": page_before,
                "filter[name]": filter_name,
                "filter[city]": filter_city,
                "filter[zipCode]": filter_zip_code,
                "filter[state]": filter_state,
                "filter[category]": filter_category,
                "filter[longitude]": filter_longitude,
                "filter[latitude]": filter_latitude,
                "filter[radius]": filter_radius,
                "sort": sort,
                "include": include,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LocationsResponseObject,
                    parse_obj_as(
                        type_=LocationsResponseObject,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 400:
                raise InvalidRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise DoesNotExistError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
