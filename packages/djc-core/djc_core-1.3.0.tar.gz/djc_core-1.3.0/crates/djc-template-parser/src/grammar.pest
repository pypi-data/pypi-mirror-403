// Legend:
// See https://docs.rs/pest/latest/pest/#pest-the-elegant-parser
// -  { ... }: None - Accept whitespace or comments within their expressions.
//                    Create token pairs during parsing, error-reported.
// - _{ ... }: Silent - Do not create token pairs during parsing, nor are they error-reported.
// - @{ ... }: Atomic - Do not accept whitespace or comments within their expressions.
//                      Any rules called by atomic rules do not generate token pairs.
// - ${ ... }: Compound-atomic - Same as atomic, plus not forbidden from generating token pairs.


/////////////////////////////
// TAG
/////////////////////////////

// The full tag is a sequence of attributes
// E.g. `{% slot key=val key2=val2 %}`
// NOTE: tag_wrapper is used when parsing exclusively a single Django template tag.
tag_wrapper = { SOI ~ django_tag ~ EOI }
django_tag = ${ "{%" ~ spacing* ~ tag_content ~ spacing* ~ "%}" }

// The contents of a tag, without the delimiters
tag_content = ${
    // Special handling for 'for' tag
    (forloop_tag_name ~ spacing_with_whitespace ~ forloop_tag_content)
    // Generic or end tag (e.g. `{% component "button" %}` or `{% endcomponent %}`)
    | (tag_name
      ~ (
          // Regular attributes for other tags
          (spacing_with_whitespace ~ attribute)*
          ~ spacing*  // Allow optional spacing/comments after last attribute
          ~ self_closing_slash?  // Optional self-closing slash at the end
        )
    )
}

// NOTE: For supporting HTML tags, we could add rules like this:
// tag_wrapper = { SOI ~ (django_tag | html_tag) ~ EOI }
// html_tag = { "<" ~ html_tag_content ~ ">" }
// html_tag_content = ${
//     tag_name                                  // The tag name must come first
//     ~ (spacing_with_whitespace ~ attribute)*  // Then zero or more attributes, MUST be separated by whitespace
//     ~ (spacing* ~ self_closing_slash)?        // Optional self-closing slash at the end
//    // ^^^^^^^^^ This space is OPTIONAL in HTML
//                                               // There MAY be space between last attribute and self-closing slash
//                                               // and NO space between `/` and closing `>`
// }

// Tag name SHOULD be a valid Python identifier, but this syntax leaves us space
// to also support kebab-case, snake_case, PascalCase, and tag namespacing (for sharing components)
// with either `.` or `:`
tag_name = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-" | ":" | ".")* }

self_closing_slash = { "/" }

// An attribute can be either a key-value pair or just a value
// E.g. `key=val`, `key2=val2`, `"val3"`, `...[1, 2, 3]`
attribute = ${
    (key ~ "=" ~ filtered_value)    // key=value form with NO whitespace allowed around =
    | spread_value                  // spread operator form (e.g. `...[1, 2, 3]`)
    | filtered_value                // value-only form (e.g. `"val3"`)
}

// Spread operator followed by a value, e.g. `...[1, 2, 3]`
spread_value = ${
    "..." ~ filtered_value
}

/////////////////////////////
// FORLOOP TAG
/////////////////////////////

// Special rule for "for" tag name - this allows us to get it as a child pair in Pest
forloop_tag_name = @{ "for" }

// For loop tag content: loop_vars in iterable (NO self-closing slash allowed)
// This rule is only used when tag_name is "for"
// E.g., "x, y, z in items" or "item in (my_list + other_list)"
forloop_tag_content = ${
    forloop_vars
    ~ spacing_with_whitespace
    ~ "in"
    ~ spacing_with_whitespace
    ~ filtered_value  // The iterable can be any value, including Python expressions
}

// Loop variables: can be single or comma-separated
// E.g., "x" or "x, y, z"
forloop_vars = ${
    forloop_var
    ~ (spacing* ~ "," ~ spacing* ~ forloop_var)*
}

// A single loop variable (Python identifier)
forloop_var = @{
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

/////////////////////////////
// KEY
/////////////////////////////

// Full key definition
// NOTE: @ in front of a rule means they should not have whitespace in between
key = @{ key_start ~ key_char* }

// A key must not start with certain characters
key_start = @{
    !((":" | "'" | "\"" | "_(" | "[" | "{" | "*" | "..." | "." | WHITESPACE) ~ ANY) ~
    key_char
}

// Characters that can appear in a key
//
// Keys are preferably alphanumeric + `_-`. But practically we allow much more,
// as these may be HTML attributes.
//
// Rules to keys:
// 1. Keys do not contain whitespaces
// 2. Must NOT start with `:` or `'`, `"`, `_("`, `_('`, `[`, `{`, `*`, `**`, `...`
// 3. Key is terminated when it comes across:
//    - Any of `=`, `'`, `"`, `_("`, `_('`, `[`, `{`, `*`, `**`, `...`
//    - Any whitespace
//
// Examples:
// - `key=val` - valid key
// - `:key=val` - invalid
// - `attr:key=val` - valid, because `:` is not first
// - `...key=val` - invalid, key cannot follow `...`
// - `_("hello")` - not a key. It is a valid value, but not a key
// - `"key"=val` - invalid, keys must not contain quotes
// - `key[0]=val` - invalid. we don't allow setting indices. So the key would end at `[`, so it
//                  would be as if having two attributes: `key` and `[0]=val`.
//                  However, then there's a missing space between the two, so that's an error too.
//                  And `[0]` would also be an invalid key.
key_char = @{
    ASCII_ALPHANUMERIC |
    "_" | "-" | "@" | "#" | "." | ":" |  // Common special chars
    // Add other allowed special chars here
    !(("=" | "'" | "\"" | "_(" | "[" | "{" | "*" | "..." | WHITESPACE) ~ ANY) ~ ANY
}

/////////////////////////////
// FILTER
/////////////////////////////

// Tag value can be a simple value followed by optional filters
//
// Value syntax supports Django filters, e.g. `"HELLO"|lower` or `my_list|select:1`,
// generally with format `value|filter:filter_arg`. Multiple filters can be chained
// up one after another.
//
// For context on how Django parses filters, see:
// https://github.com/django/django/blob/862b7f98a02b7973848db578ff6d24ec8500fdb4/django/template/base.py#L621
//
// NOTE: Filter pipe CAN be separated by whitespace
filtered_value = ${
    value ~ filter_chain?
}

// A chain of filters separated by pipes
filter_chain = ${
    spacing* ~ filter ~ (spacing* ~ filter)*
}
// In the position of a dictionary key we don't allow filter arguments
// because filter args also use colon `:`, which conflicts with dict keys.
// So something like `{"key"|lower:arg: value}` would be ambiguous.
filter_chain_noarg = ${
    spacing* ~ filter_noarg ~ (spacing* ~ filter_noarg)*
}

// A single filter with optional argument
// NOTE: Filter pipe `|` CAN be surrounded by whitespace
filter = ${
    "|" ~ spacing* ~ filter_name ~ filter_arg_part?
}
filter_noarg = ${
    "|" ~ spacing* ~ filter_name
}

// Filter name must be alphanumeric + `_`
filter_name = @{
    !(":" | "|") ~ (ASCII_ALPHANUMERIC | "_")+ // Ensure filter name doesn't start with : or |
}

// NOTE: Filter arg `:` CAN be surrounded by whitespace
// The argument part of a filter, including the colon
filter_arg_part = ${
    spacing* ~ ":" ~ spacing* ~ filter_arg
}

filter_arg = {
    value
}

/////////////////////////////
// VALUE
/////////////////////////////

// The actual value
// 
// - A number (e.g. -1, +1.5, .5, 1e-10)
// - A variable name (alphanumeric + dots)
// - A string literal (single or double quoted)
// - A translation string (string literal wrapped in _())
// - List of values
// - Dictionary of values
//
// NOTE: Order matters here - We need to first check for `_("...")` because `_`
//       is also a valid variable name.
value = {
    dict |
    list |
    translation |
    python_expr |
    variable |
    float |
    int |
    string_literal
}

/////////////////////////////
// LIST
/////////////////////////////

// List of values, e.g. [1, "a"|upper, [2, 3],]
// List items MAY be spread with `*`
list = ${
    "[" ~ spacing*
    ~ (
        list_item ~ spacing*                          // First value
        ~ ("," ~ spacing* ~ list_item ~ spacing*)*    // Additional values
        ~ ("," ~ spacing*)?                           // Optional trailing comma
    )?
    ~ "]"
}


// A single list item, which can be spread
// NOTE: Spread operator CAN be surrounded by whitespace
//       but leading spacing is already handled in `list` rule.
list_item = ${
    list_item_spread? ~ spacing* ~ filtered_value
}

// List item spread operator
list_item_spread = @{ "*" }


/////////////////////////////
// DICT
/////////////////////////////

// Dictionary rules
dict = ${
    "{"
    ~ spacing*         // Optional leading whitespace
    ~ (
        dict_item ~ (spacing* ~ "," ~ spacing* ~ dict_item)*  // 0 or more dict items, separated by commas
    )?
    ~ spacing* ~ ","?  // Optional trailing comma
    ~ spacing* ~ "}"
}
dict_item = _{ (dict_item_pair | dict_item_spread) }
dict_item_pair = ${ dict_key ~ spacing* ~ ":" ~ spacing* ~ filtered_value } // `key: value` pair
dict_item_spread = ${ dict_item_spread_op ~ spacing* ~ filtered_value } // `**value` spread

// Dict item spread operator
dict_item_spread_op = @{ "**" }

// A filtered key can have filters but not filter arguments
// because filter args also use colon `:`, which conflicts with dict keys.
// So something like `{"key"|lower:arg: value}` would be ambiguous.
dict_key = {
    dict_key_inner ~ filter_chain_noarg?
}

// NOTE: Order matters here - We need to first check for `_("...")` because `_`
//       is also a valid variable name.
dict_key_inner = _{
    translation
    | python_expr
    | variable
    | float
    | int
    | string_literal
}

/////////////////////////////
// PYTHON EXPRESSION
/////////////////////////////

// Python expression wrapped in parentheses
// This allows inline Python code anywhere a value is expected
// E.g. ("YES" if my_item[0].name.upper()[:2] == "LO" else None)
python_expr = ${ "(" ~ python_inner ~ ")" }

// It's tricky to determine the end of the Python expression. We can't just
// take the first `)` we see, because it could be inside a string literal.
// Also, there may be nested parentheses. So we need to recursively check
// for `)` every time we introduce nested parentheses.
python_inner = ${
    (
        // NOTE: Order matters here - We need to first check for `"""`, `'''`
        // before `""`, `''`, and only then other characters, so that we skip
        // all content inside string literals.
        python_str_triple_double |  // Check triple quotes first (longer match)
        python_str_triple_single |
        python_str_double |
        python_str_single |
        python_nested_paren |
        python_other_char
    )*
}

// String literals within Python expressions (atomic to prevent looking inside)
python_str_triple_double = @{ "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" }
python_str_triple_single = @{ "'''" ~ (!"'''" ~ ANY)* ~ "'''" }
python_str_double = @{ "\"" ~ (python_esc | !"\"" ~ ANY)* ~ "\"" }
python_str_single = @{ "'" ~ (python_esc | !"'" ~ ANY)* ~ "'" }
python_esc = _{ "\\" ~ ANY }

// Nested parentheses (recursive) - silent so they don't create extra tokens
python_nested_paren = _{ "(" ~ python_inner ~ ")" }

// Any other character (but not `)` or `(` at top level)
python_other_char = { !")" ~ !"(" ~ ANY }

/////////////////////////////
// SCALARS AND UTILS
//
// Common value types used in multiple places
/////////////////////////////

// Float pattern: Matches numbers with decimal point or scientific notation
float = @{
    ("-" | "+")? ~
    (
        // .42, .42e-10
        ("." ~ ASCII_DIGIT+ ~ ("e" ~ ("-" | "+")? ~ ASCII_DIGIT+)?) |
        // 42.42, 42.42e-10
        (ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ ("e" ~ ("-" | "+")? ~ ASCII_DIGIT+)?) |
        // 42e-10
        (ASCII_DIGIT+ ~ "e" ~ ("-" | "+")? ~ ASCII_DIGIT+)
    )
}

// Int pattern: Matches whole numbers
int = @{
    ("-" | "+")? ~ ASCII_DIGIT+
}

// Variable pattern: \w\.
variable = @{
    (ASCII_ALPHA | "_") ~
    (ASCII_ALPHANUMERIC | "_" | ".")*
}

// String literals (single or double quoted)
string_literal = @{
    double_quoted_string |
    single_quoted_string
}

// Double quoted strings that may contain escaped quote
double_quoted_string = @{
    "\"" ~ (!"\"" ~ ("\\\"" | ANY))* ~ "\""
}

// Single quoted strings that may contain escaped quote
single_quoted_string = @{
    "'" ~ (!"'" ~ ("\\'" | ANY))* ~ "'"
}

// translation strings: _("string") or _('string')
translation = ${
    "_("
    ~ spacing*
    ~ string_literal
    ~ spacing*
    ~ ")"
}

// Spacing includes both whitespace and comments
spacing = ${ WHITESPACE | COMMENT }

// Spacing that requires at least one WHITESPACE character
// This ensures there's at least one whitespace between tag_name and attributes,
// but allows any number of comments
spacing_with_whitespace = ${
    (COMMENT* ~ WHITESPACE ~ COMMENT*)+
}

// Comments are wrapped in {# ... #} and can contain anything except the closing #}
// Comments may be between attributes, e.g. `key1=val1 {# comment #} key2=val2`
COMMENT = @{ "{#" ~ (!"#}" ~ ANY)* ~ "#}" }

// NOTE: `_{` in front of a rule means that the characters will be excluded from the AST.
//        So in other words, the AST won't contain a "whitespace" node. It will be simply
//        blind to whitespace.
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
