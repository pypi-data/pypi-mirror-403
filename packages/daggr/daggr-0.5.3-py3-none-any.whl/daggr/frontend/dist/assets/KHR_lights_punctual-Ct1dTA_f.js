import{b$ as y,ab as m,V as r,o as b,bC as L,_ as w,s as A,f as v,cf as C,b0 as g,bR as P,bQ as S}from"./index-C7ioxznG.js";import{b as T}from"./objectModelMapping-CY2JGqxk.js";import{ArrayItem as _,GLTFLoader as p}from"./glTFLoader-dcV3nFjy.js";import"./index-BmJkaHuF.js";import"./bone-D3wPsQsS.js";import"./skeleton-Dp5NNatR.js";import"./rawTexture-B_Rn1rXF.js";import"./assetContainer-WmWzRef8.js";L.AddNodeConstructor("Light_Type_0",(l,e)=>()=>new c(l,r.Zero(),e));class c extends y{get shadowAngle(){return this._shadowAngle}set shadowAngle(e){this._shadowAngle=e,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(e){const i=this.needCube();if(this._direction=e,this.needCube()!==i&&this._shadowGenerators){const t=this._shadowGenerators.values();for(let n=t.next();n.done!==!0;n=t.next())n.value.recreateShadowMap()}}constructor(e,i,t,n){super(e,t,n),this._shadowAngle=Math.PI/2,this.position=i}getClassName(){return"PointLight"}getTypeID(){return m.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(e){if(this.direction)return super.getShadowDirection(e);switch(e){case 0:return new r(1,0,0);case 1:return new r(-1,0,0);case 2:return new r(0,-1,0);case 3:return new r(0,1,0);case 4:return new r(0,0,1);case 5:return new r(0,0,-1)}return r.Zero()}_setDefaultShadowProjectionMatrix(e,i,t){const n=this.getScene().activeCamera,f=this.getDepthMinZ(n),a=this.getDepthMaxZ(n),s=this.getScene().getEngine().useReverseDepthBuffer;b.PerspectiveFovLHToRef(this.shadowAngle,1,s?a:f,s?f:a,e,!0,this._scene.getEngine().isNDCHalfZRange,void 0,s)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(e,i){const t=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x-t.x,this.transformedPosition.y-t.y,this.transformedPosition.z-t.z,0,i):this._uniformBuffer.updateFloat4("vLightData",this.position.x-t.x,this.position.y-t.y,this.position.z-t.z,0,i),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,i),this}transferToNodeMaterialEffect(e,i){const t=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?e.setFloat3(i,this.transformedPosition.x-t.x,this.transformedPosition.y-t.y,this.transformedPosition.z-t.z):e.setFloat3(i,this.position.x-t.x,this.position.y-t.y,this.position.z-t.z),this}prepareLightSpecificDefines(e,i){e["POINTLIGHT"+i]=!0}}w([A()],c.prototype,"shadowAngle",null);v("BABYLON.PointLight",c);const d="KHR_lights_punctual";class x{constructor(e){this.name=d,this._loader=e,this.enabled=this._loader.isExtensionUsed(d)}dispose(){this._loader=null,delete this._lights}onLoading(){const e=this._loader.gltf.extensions;if(e&&e[this.name]){const i=e[this.name];this._lights=i.lights,_.Assign(this._lights)}}loadNodeAsync(e,i,t){return p.LoadExtensionAsync(e,i,this.name,async(n,f)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(e,i,a=>{let s;const o=_.Get(n,this._lights,f.light),u=o.name||a.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,o.type){case"directional":{const h=new C(u,r.Backward(),this._loader.babylonScene);h.position.setAll(0),s=h;break}case"point":{s=new c(u,r.Zero(),this._loader.babylonScene);break}case"spot":{const h=new T(u,r.Zero(),r.Backward(),0,1,this._loader.babylonScene);h.angle=(o.spot&&o.spot.outerConeAngle||Math.PI/4)*2,h.innerAngle=(o.spot&&o.spot.innerConeAngle||0)*2,s=h;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${n}: Invalid light type (${o.type})`)}s._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,o._babylonLight=s,s.falloffType=m.FALLOFF_GLTF,s.diffuse=o.color?g.FromArray(o.color):g.White(),s.intensity=o.intensity==null?1:o.intensity,s.range=o.range==null?Number.MAX_VALUE:o.range,s.parent=a,this._loader._babylonLights.push(s),p.AddPointerMetadata(s,n),t(a)})))}}P(d);S(d,!0,l=>new x(l));export{x as KHR_lights};
