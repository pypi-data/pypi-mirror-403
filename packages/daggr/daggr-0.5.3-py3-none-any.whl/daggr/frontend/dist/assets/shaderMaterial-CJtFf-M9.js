import{aY as F,o as E,H as x,N as R,K as q,$ as j,W as L,k as W,X as z,a3 as D,Y as K,aZ as X,a_ as G,Z as H,S as O,T as U,Q,a$ as w,d as C,a2 as $,f as J}from"./index-C7ioxznG.js";import"./index-BmJkaHuF.js";const V=new WeakMap;function Y(v){const t=v.getVertexBuffers();if(!t)return null;let e=V.get(v);if(!e)e=new Map,V.set(v,e);else{let n=!1;for(const s in t)if(!e.has(s)){n=!0;break}if(!n)return e}for(const n in t){const s=t[n];if(s){const r=s.byteOffset,i=s.byteStride,a=s.type;e.set(n,{offset:r,stride:i,type:a})}}return e}function Z(v,t){t.forEach((e,n)=>{const s=`vp_${n}_info`;v.setFloat3(s,e.offset,e.stride,e.type)})}const P={effect:null,subMesh:null};class y extends F{constructor(t,e,n,s={},r=!0){super(t,e,r),this._textures={},this._internalTextures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new E,this._cachedWorldViewProjectionMatrix=new E,this._multiview=!1,this._vertexPullingMetadata=null,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=n,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...s}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){this._options.uniforms.indexOf(t)===-1&&this._options.uniforms.push(t)}setTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._textures[t]=e,this}setInternalTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._internalTextures[t]=e,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=e,this}setExternalTexture(t,e){return this._options.externalTextures.indexOf(t)===-1&&this._options.externalTextures.push(t),this._externalTextures[t]=e,this}setFloat(t,e){return this._checkUniform(t),this._floats[t]=e,this}setInt(t,e){return this._checkUniform(t),this._ints[t]=e,this}setUInt(t,e){return this._checkUniform(t),this._uints[t]=e,this}setFloats(t,e){return this._checkUniform(t),this._floatsArrays[t]=e,this}setColor3(t,e){return this._checkUniform(t),this._colors3[t]=e,this}setColor3Array(t,e){return this._checkUniform(t),this._colors3Arrays[t]=e.reduce((n,s)=>(n.push(s.r,s.g,s.b),n),[]),this}setColor4(t,e){return this._checkUniform(t),this._colors4[t]=e,this}setColor4Array(t,e){return this._checkUniform(t),this._colors4Arrays[t]=e.reduce((n,s)=>(n.push(s.r,s.g,s.b,s.a),n),[]),this}setVector2(t,e){return this._checkUniform(t),this._vectors2[t]=e,this}setVector3(t,e){return this._checkUniform(t),this._vectors3[t]=e,this}setVector4(t,e){return this._checkUniform(t),this._vectors4[t]=e,this}setQuaternion(t,e){return this._checkUniform(t),this._quaternions[t]=e,this}setQuaternionArray(t,e){return this._checkUniform(t),this._quaternionsArrays[t]=e.reduce((n,s)=>(s.toArray(n,n.length),n),[]),this}setMatrix(t,e){return this._checkUniform(t),this._matrices[t]=e,this}setMatrices(t,e){this._checkUniform(t);const n=new Float32Array(e.length*16);for(let s=0;s<e.length;s++)e[s].copyToArray(n,s*16);return this._matrixArrays[t]=n,this}setMatrix3x3(t,e){return this._checkUniform(t),this._matrices3x3[t]=e,this}setMatrix2x2(t,e){return this._checkUniform(t),this._matrices2x2[t]=e,this}setArray2(t,e){return this._checkUniform(t),this._vectors2Arrays[t]=e,this}setArray3(t,e){return this._checkUniform(t),this._vectors3Arrays[t]=e,this}setArray4(t,e){return this._checkUniform(t),this._vectors4Arrays[t]=e,this}setUniformBuffer(t,e){return this._options.uniformBuffers.indexOf(t)===-1&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=e,this}setTextureSampler(t,e){return this._options.samplerObjects.indexOf(t)===-1&&this._options.samplerObjects.push(t),this._textureSamplers[t]=e,this}setStorageBuffer(t,e){return this._options.storageBuffers.indexOf(t)===-1&&this._options.storageBuffers.push(t),this._storageBuffers[t]=e,this}setDefine(t,e){const n=t.trimEnd()+" ",s=this.options.defines.findIndex(r=>r===t||r.startsWith(n));return s>=0&&this.options.defines.splice(s,1),(typeof e!="boolean"||e)&&this.options.defines.push(n+e),this}isReadyForSubMesh(t,e,n){return this.isReady(t,n,e)}isReady(t,e,n){var k;const s=n&&this._storeEffectOnSubMeshes;if(this.isFrozen){const c=s?n._drawWrapper:this._drawWrapper;if(c.effect&&c._wasPreviouslyReady&&c._wasPreviouslyUsingInstances===e)return!0}const r=this.getScene(),i=r.getEngine(),a=[],h=[];let u=null,T=this._shaderPath,f=this._options.uniforms,o=this._options.uniformBuffers,_=this._options.samplers;i.getCaps().multiview&&r.activeCamera&&r.activeCamera.outputRenderTarget&&r.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,a.push("#define MULTIVIEW"),f.indexOf("viewProjection")!==-1&&f.indexOf("viewProjectionR")===-1&&f.push("viewProjectionR"));for(let c=0;c<this._options.defines.length;c++){const g=this._options.defines[c].indexOf("#define")===0?this._options.defines[c]:`#define ${this._options.defines[c]}`;a.push(g)}for(let c=0;c<this._options.attributes.length;c++)h.push(this._options.attributes[c]);if(t&&t.isVerticesDataPresent(x.ColorKind)&&(h.indexOf(x.ColorKind)===-1&&h.push(x.ColorKind),a.push("#define VERTEXCOLOR")),e&&(a.push("#define INSTANCES"),R(h,this._materialHelperNeedsPreviousMatrices),t!=null&&t.hasThinInstances&&(a.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(x.ColorInstanceKind)&&(h.push(x.ColorInstanceKind),a.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){h.push(x.MatricesIndicesKind),h.push(x.MatricesWeightsKind),t.numBoneInfluencers>4&&(h.push(x.MatricesIndicesExtraKind),h.push(x.MatricesWeightsExtraKind));const c=t.skeleton;a.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),u=new $,u.addCPUSkinningFallback(0,t),c.isUsingTextureForMatrices?(a.push("#define BONETEXTURE"),f.indexOf("boneTextureWidth")===-1&&f.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(a.push("#define BonesPerMesh "+(c.bones.length+1)),f.indexOf("mBones")===-1&&f.push("mBones"))}else a.push("#define NUM_BONE_INFLUENCERS 0");let A=0;const m=t?t.morphTargetManager:null;if(m){const c=a.indexOf("#define UV1")!==-1,g=a.indexOf("#define UV2")!==-1,B=a.indexOf("#define TANGENT")!==-1,b=a.indexOf("#define NORMAL")!==-1,N=a.indexOf("#define VERTEXCOLOR")!==-1;A=q(m,a,h,t,!0,b,B,c,g,N),m.isUsingTextureForTargets&&(f.indexOf("morphTargetTextureIndices")===-1&&f.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),A>0&&(f=f.slice(),f.push("morphTargetInfluences"),f.push("morphTargetCount"),f.push("morphTargetTextureInfo"),f.push("morphTargetTextureIndices"))}else a.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const c=t.bakedVertexAnimationManager;c&&c.isEnabled&&(a.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),f.indexOf("bakedVertexAnimationSettings")===-1&&f.push("bakedVertexAnimationSettings"),f.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&f.push("bakedVertexAnimationTextureSizeInverted"),f.indexOf("bakedVertexAnimationTime")===-1&&f.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture"),e&&h.push("bakedVertexAnimationSettingsInstanced"))}for(const c in this._textures)if(!this._textures[c].isReady())return!1;for(const c in this._internalTextures)if(!this._internalTextures[c].isReady)return!1;t&&this.needAlphaTestingForMesh(t)&&a.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(j(f),L(this,r,a)),r.fogEnabled&&(t!=null&&t.applyFog)&&r.fogMode!==W.FOGMODE_NONE&&(a.push("#define FOG"),f.indexOf("view")===-1&&f.push("view"),f.indexOf("vFogInfos")===-1&&f.push("vFogInfos"),f.indexOf("vFogColor")===-1&&f.push("vFogColor")),this._useLogarithmicDepth&&(a.push("#define LOGARITHMICDEPTH"),f.indexOf("logarithmicDepthConstant")===-1&&f.push("logarithmicDepthConstant"));const d=n?n.getRenderingMesh():t;if(d&&this.useVertexPulling){const c=d.geometry;c&&(this._vertexPullingMetadata=Y(c),this._vertexPullingMetadata&&this._vertexPullingMetadata.forEach((B,b)=>{f.push(`vp_${b}_info`)})),a.push("#define USE_VERTEX_PULLING");const g=(k=d.geometry)==null?void 0:k.getIndexBuffer();g&&!d.isUnIndexed&&(a.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),g.is32Bits&&a.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}this.customShaderNameResolve&&(f=f.slice(),o=o.slice(),_=_.slice(),T=this.customShaderNameResolve(this.name,f,o,_,a,h));const l=s?n._getDrawWrapper(void 0,!0):this._drawWrapper,S=(l==null?void 0:l.effect)??null,I=(l==null?void 0:l.defines)??null,M=a.join(`
`);let p=S;return I!==M&&(p=i.createEffect(T,{attributes:h,uniformsNames:f,uniformBuffersNames:o,samplers:_,defines:M,fallbacks:u,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:A},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},i),s?n.setEffect(p,M,this._materialContext):l&&l.setEffect(p,M),this._onEffectCreatedObservable&&(P.effect=p,P.subMesh=n??(t==null?void 0:t.subMeshes[0])??null,this._onEffectCreatedObservable.notifyObservers(P))),l._wasPreviouslyUsingInstances=!!e,p!=null&&p.isReady()?(S!==p&&r.resetCachedMaterial(),l._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(t,e){const n=e??this.getEffect();if(!n)return;const s=this._options.uniforms;s.indexOf("world")!==-1&&n.setMatrix("world",t);const r=this.getScene();s.indexOf("worldView")!==-1&&(t.multiplyToRef(r.getViewMatrix(),this._cachedWorldViewMatrix),n.setMatrix("worldView",this._cachedWorldViewMatrix)),s.indexOf("worldViewProjection")!==-1&&(t.multiplyToRef(r.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),n.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),s.indexOf("view")!==-1&&n.setMatrix("view",r.getViewMatrix())}bindForSubMesh(t,e,n){var s;this.bind(t,e,(s=n._drawWrapperOverride)==null?void 0:s.effect,n)}bind(t,e,n,s){var f;const r=s&&this._storeEffectOnSubMeshes,i=n??(r?s.effect:this.getEffect());if(!i)return;const a=this.getScene();this._activeEffect=i,this.bindOnlyWorldMatrix(t,n);const h=this._options.uniformBuffers;let u=!1;if(i&&h&&h.length>0&&a.getEngine().supportsUniformBuffers)for(let o=0;o<h.length;++o)switch(h[o]){case"Mesh":e&&(e.getMeshUniformBuffer().bindToEffect(i,"Mesh"),e.transferToEffect(t));break;case"Scene":z(i,a.getSceneUniformBuffer()),a.finalizeSceneUbo(),u=!0;break}const T=e&&r?this._mustRebind(a,i,s,e.visibility):a.getCachedMaterial()!==this;if(i&&T){!u&&this._options.uniforms.indexOf("view")!==-1&&i.setMatrix("view",a.getViewMatrix()),!u&&this._options.uniforms.indexOf("projection")!==-1&&i.setMatrix("projection",a.getProjectionMatrix()),!u&&this._options.uniforms.indexOf("viewProjection")!==-1&&(i.setMatrix("viewProjection",a.getTransformMatrix()),this._multiview&&i.setMatrix("viewProjectionR",a._transformMatrixR)),a.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&i.setVector3("cameraPosition",a.activeCamera.globalPosition),D(e,i),K(i,this,a),this._vertexPullingMetadata&&Z(i,this._vertexPullingMetadata),this._useLogarithmicDepth&&X(r?s.materialDefines:i.defines,i,a),e&&G(a,e,i);let o;for(o in this._textures)i.setTexture(o,this._textures[o]);for(o in this._internalTextures)i._bindTexture(o,this._internalTextures[o]);for(o in this._textureArrays)i.setTextureArray(o,this._textureArrays[o]);for(o in this._ints)i.setInt(o,this._ints[o]);for(o in this._uints)i.setUInt(o,this._uints[o]);for(o in this._floats)i.setFloat(o,this._floats[o]);for(o in this._floatsArrays)i.setArray(o,this._floatsArrays[o]);for(o in this._colors3)i.setColor3(o,this._colors3[o]);for(o in this._colors3Arrays)i.setArray3(o,this._colors3Arrays[o]);for(o in this._colors4){const l=this._colors4[o];i.setFloat4(o,l.r,l.g,l.b,l.a)}for(o in this._colors4Arrays)i.setArray4(o,this._colors4Arrays[o]);for(o in this._vectors2)i.setVector2(o,this._vectors2[o]);for(o in this._vectors3)i.setVector3(o,this._vectors3[o]);for(o in this._vectors4)i.setVector4(o,this._vectors4[o]);for(o in this._quaternions)i.setQuaternion(o,this._quaternions[o]);for(o in this._matrices)i.setMatrix(o,this._matrices[o]);for(o in this._matrixArrays)i.setMatrices(o,this._matrixArrays[o]);for(o in this._matrices3x3)i.setMatrix3x3(o,this._matrices3x3[o]);for(o in this._matrices2x2)i.setMatrix2x2(o,this._matrices2x2[o]);for(o in this._vectors2Arrays)i.setArray2(o,this._vectors2Arrays[o]);for(o in this._vectors3Arrays)i.setArray3(o,this._vectors3Arrays[o]);for(o in this._vectors4Arrays)i.setArray4(o,this._vectors4Arrays[o]);for(o in this._quaternionsArrays)i.setArray4(o,this._quaternionsArrays[o]);for(o in this._uniformBuffers){const l=this._uniformBuffers[o].getBuffer();l&&i.bindUniformBuffer(l,o)}const _=a.getEngine(),A=_.setExternalTexture;if(A)for(o in this._externalTextures)A.call(_,o,this._externalTextures[o]);const m=_.setTextureSampler;if(m)for(o in this._textureSamplers)m.call(_,o,this._textureSamplers[o]);const d=_.setStorageBuffer;if(d)for(o in this._storageBuffers)d.call(_,o,this._storageBuffers[o])}if(i&&e&&(T||!this.isFrozen)){H(e,i),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(i);const o=e.bakedVertexAnimationManager;if(o&&o.isEnabled){const _=r?s._drawWrapper:this._drawWrapper;(f=e.bakedVertexAnimationManager)==null||f.bind(i,!!_._wasPreviouslyUsingInstances)}}this._afterBind(e,i,s)}getActiveTextures(){const t=super.getActiveTextures();for(const e in this._textures)t.push(this._textures[e]);for(const e in this._textureArrays){const n=this._textureArrays[e];for(let s=0;s<n.length;s++)t.push(n[s])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const n in this._textures)if(this._textures[n]===t)return!0;const e=t.getInternalTexture();for(const n in this._internalTextures)if(this._internalTextures[n]===e)return!0;for(const n in this._textureArrays){const s=this._textureArrays[n];for(let r=0;r<s.length;r++)if(s[r]===t)return!0}return!1}clone(t){const e=O.Clone(()=>new y(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);e.name=t,e.id=t,typeof e._shaderPath=="object"&&(e._shaderPath={...e._shaderPath}),this._options={...this._options};const n=Object.keys(this._options);for(const s of n){const r=this._options[s];Array.isArray(r)&&(this._options[s]=r.slice(0))}this.stencil.copyTo(e.stencil);for(const s in this._textures)e.setTexture(s,this._textures[s]);for(const s in this._internalTextures)e.setInternalTexture(s,this._internalTextures[s]);for(const s in this._textureArrays)e.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)e.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)e.setInt(s,this._ints[s]);for(const s in this._uints)e.setUInt(s,this._uints[s]);for(const s in this._floats)e.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)e.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)e.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)e._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)e.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)e._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)e.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)e.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)e.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)e.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)e._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)e.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)e._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)e.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)e.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)e.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)e.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)e.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)e.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)e.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)e.setStorageBuffer(s,this._storageBuffers[s]);return e}dispose(t,e,n){if(e){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._internalTextures)this._internalTextures[s].dispose();for(s in this._textureArrays){const r=this._textureArrays[s];for(let i=0;i<r.length;i++)r[i].dispose()}}this._textures={},this._internalTextures={},super.dispose(t,e,n)}serialize(){const t=O.Serialize(this);t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let e;t.stencil=this.stencil.serialize(),t.textures={};for(e in this._textures)t.textures[e]=this._textures[e].serialize();t.textureArrays={};for(e in this._textureArrays){t.textureArrays[e]=[];const n=this._textureArrays[e];for(let s=0;s<n.length;s++)t.textureArrays[e].push(n[s].serialize())}t.ints={};for(e in this._ints)t.ints[e]=this._ints[e];t.uints={};for(e in this._uints)t.uints[e]=this._uints[e];t.floats={};for(e in this._floats)t.floats[e]=this._floats[e];t.floatsArrays={};for(e in this._floatsArrays)t.floatsArrays[e]=this._floatsArrays[e];t.colors3={};for(e in this._colors3){const n=this._colors3[e];t.colors3[e]=[n.r,n.g,n.b]}t.colors3Arrays={};for(e in this._colors3Arrays)t.colors3Arrays[e]=this._colors3Arrays[e];t.colors4={};for(e in this._colors4){const n=this._colors4[e];t.colors4[e]=[n.r,n.g,n.b,n.a]}t.colors4Arrays={};for(e in this._colors4Arrays)t.colors4Arrays[e]=this._colors4Arrays[e];t.vectors2={};for(e in this._vectors2){const n=this._vectors2[e];t.vectors2[e]=[n.x,n.y]}t.vectors3={};for(e in this._vectors3){const n=this._vectors3[e];t.vectors3[e]=[n.x,n.y,n.z]}t.vectors4={};for(e in this._vectors4){const n=this._vectors4[e];t.vectors4[e]=[n.x,n.y,n.z,n.w]}t.quaternions={};for(e in this._quaternions)t.quaternions[e]=this._quaternions[e].asArray();t.matrices={};for(e in this._matrices)t.matrices[e]=this._matrices[e].asArray();t.matrixArray={};for(e in this._matrixArrays)t.matrixArray[e]=this._matrixArrays[e];t.matrices3x3={};for(e in this._matrices3x3)t.matrices3x3[e]=this._matrices3x3[e];t.matrices2x2={};for(e in this._matrices2x2)t.matrices2x2[e]=this._matrices2x2[e];t.vectors2Arrays={};for(e in this._vectors2Arrays)t.vectors2Arrays[e]=this._vectors2Arrays[e];t.vectors3Arrays={};for(e in this._vectors3Arrays)t.vectors3Arrays[e]=this._vectors3Arrays[e];t.vectors4Arrays={};for(e in this._vectors4Arrays)t.vectors4Arrays[e]=this._vectors4Arrays[e];t.quaternionsArrays={};for(e in this._quaternionsArrays)t.quaternionsArrays[e]=this._quaternionsArrays[e];return t}static Parse(t,e,n){const s=O.Parse(()=>new y(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,e,n);let r;t.stencil&&s.stencil.parse(t.stencil,e,n);for(r in t.textures)s.setTexture(r,U.Parse(t.textures[r],e,n));for(r in t.textureArrays){const i=t.textureArrays[r],a=[];for(let h=0;h<i.length;h++)a.push(U.Parse(i[h],e,n));s.setTextureArray(r,a)}for(r in t.ints)s.setInt(r,t.ints[r]);for(r in t.uints)s.setUInt(r,t.uints[r]);for(r in t.floats)s.setFloat(r,t.floats[r]);for(r in t.floatsArrays)s.setFloats(r,t.floatsArrays[r]);for(r in t.colors3){const i=t.colors3[r];s.setColor3(r,{r:i[0],g:i[1],b:i[2]})}for(r in t.colors3Arrays){const i=t.colors3Arrays[r].reduce((a,h,u)=>(u%3===0?a.push([h]):a[a.length-1].push(h),a),[]).map(a=>({r:a[0],g:a[1],b:a[2]}));s.setColor3Array(r,i)}for(r in t.colors4){const i=t.colors4[r];s.setColor4(r,{r:i[0],g:i[1],b:i[2],a:i[3]})}for(r in t.colors4Arrays){const i=t.colors4Arrays[r].reduce((a,h,u)=>(u%4===0?a.push([h]):a[a.length-1].push(h),a),[]).map(a=>({r:a[0],g:a[1],b:a[2],a:a[3]}));s.setColor4Array(r,i)}for(r in t.vectors2){const i=t.vectors2[r];s.setVector2(r,{x:i[0],y:i[1]})}for(r in t.vectors3){const i=t.vectors3[r];s.setVector3(r,{x:i[0],y:i[1],z:i[2]})}for(r in t.vectors4){const i=t.vectors4[r];s.setVector4(r,{x:i[0],y:i[1],z:i[2],w:i[3]})}for(r in t.quaternions)s.setQuaternion(r,Q.FromArray(t.quaternions[r]));for(r in t.matrices)s.setMatrix(r,E.FromArray(t.matrices[r]));for(r in t.matrixArray)s._matrixArrays[r]=new Float32Array(t.matrixArray[r]);for(r in t.matrices3x3)s.setMatrix3x3(r,t.matrices3x3[r]);for(r in t.matrices2x2)s.setMatrix2x2(r,t.matrices2x2[r]);for(r in t.vectors2Arrays)s.setArray2(r,t.vectors2Arrays[r]);for(r in t.vectors3Arrays)s.setArray3(r,t.vectors3Arrays[r]);for(r in t.vectors4Arrays)s.setArray4(r,t.vectors4Arrays[r]);for(r in t.quaternionsArrays)s.setArray4(r,t.quaternionsArrays[r]);return s}static async ParseFromFileAsync(t,e,n,s=""){return await new Promise((r,i)=>{const a=new w;a.addEventListener("readystatechange",()=>{if(a.readyState==4)if(a.status==200){const h=JSON.parse(a.responseText),u=this.Parse(h,n||C.LastCreatedScene,s);t&&(u.name=t),r(u)}else i("Unable to load the ShaderMaterial")}),a.open("GET",e),a.send()})}static async ParseFromSnippetAsync(t,e,n=""){return await new Promise((s,r)=>{const i=new w;i.addEventListener("readystatechange",()=>{if(i.readyState==4)if(i.status==200){const a=JSON.parse(JSON.parse(i.responseText).jsonPayload),h=JSON.parse(a.shaderMaterial),u=this.Parse(h,e||C.LastCreatedScene,n);u.snippetId=t,s(u)}else r("Unable to load the snippet "+t)}),i.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),i.send()})}}y.SnippetUrl="https://snippet.babylonjs.com";y.CreateFromSnippetAsync=y.ParseFromSnippetAsync;J("BABYLON.ShaderMaterial",y);export{y as ShaderMaterial};
