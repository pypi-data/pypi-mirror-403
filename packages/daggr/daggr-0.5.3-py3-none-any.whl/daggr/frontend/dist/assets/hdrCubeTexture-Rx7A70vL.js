const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/hdrFiltering.vertex-Bxg3sIdY.js","assets/index-C7ioxznG.js","assets/index-BmJkaHuF.js","assets/index-BJecwV5W.css","assets/hdrFiltering.fragment-Y_VkqQDx.js","assets/helperFunctions-CFR2hQoc.js","assets/hdrFilteringFunctions-B59PKIxy.js","assets/pbrBRDFFunctions-BhqyLC0T.js","assets/hdrFiltering.vertex-B9jAjN4s.js","assets/hdrFiltering.fragment-Dj6TDQ7S.js","assets/helperFunctions-B2fIE0QR.js","assets/hdrFilteringFunctions-BVOTfwCk.js","assets/pbrBRDFFunctions-BInprDgy.js","assets/hdrIrradianceFiltering.vertex-CbMgEGhA.js","assets/hdrIrradianceFiltering.fragment-BQdW--_P.js","assets/hdrIrradianceFiltering.vertex-CaplnPpN.js","assets/hdrIrradianceFiltering.fragment-mUHSnwSD.js"])))=>i.map(i=>d[i]);
import{m as M,V as r,E as R,n as F,B as I,o as b,O as L,T as P,p as A,q as E,r as v,t as x,u as y,f as D}from"./index-C7ioxznG.js";import{_}from"./index-BmJkaHuF.js";import{I as W}from"./iblCdfGenerator-CgxcR2EC.js";import{G}from"./hdr-DQiJunw5.js";import"./rawTexture-B_Rn1rXF.js";class z{constructor(e,t={}){this._lodGenerationOffset=0,this._lodGenerationScale=.8,this.quality=4096,this.hdrScale=1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!0,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:1,label:"HDR_Radiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),this._engine.updateTextureSamplingMode(3,i.texture,!0),i}_prefilterInternal(e){const t=e.getSize().width,i=M(t)+1,a=this._effectWrapper.effect,h=this._createRenderTarget(t);this._effectRenderer.saveStates(),this._effectRenderer.setViewport();const d=e.getInternalTexture();d&&this._engine.updateTextureSamplingMode(3,d,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const f=[[new r(0,0,-1),new r(0,-1,0),new r(1,0,0)],[new r(0,0,1),new r(0,-1,0),new r(-1,0,0)],[new r(1,0,0),new r(0,0,1),new r(0,1,0)],[new r(1,0,0),new r(0,0,-1),new r(0,-1,0)],[new r(1,0,0),new r(0,-1,0),new r(0,0,1)],[new r(-1,0,0),new r(0,-1,0),new r(0,0,-1)]];a.setFloat("hdrScale",this.hdrScale),a.setFloat2("vFilteringInfo",e.getSize().width,i),a.setTexture("inputTexture",e);for(let c=0;c<6;c++){a.setVector3("up",f[c][0]),a.setVector3("right",f[c][1]),a.setVector3("front",f[c][2]);for(let s=0;s<i;s++){this._engine.bindFramebuffer(h,c,void 0,void 0,!0,s),this._effectRenderer.applyEffectWrapper(this._effectWrapper);let n=Math.pow(2,(s-this._lodGenerationOffset)/this._lodGenerationScale)/t;s===0&&(n=0),a.setFloat("alphaG",n),this._effectRenderer.draw()}}this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),this._engine._releaseTexture(e._texture);const l=h.texture.type,o=h.texture.format;return h._swapAndDie(e._texture),e._texture.type=l,e._texture.format=o,e.gammaSpace=!1,e.lodGenerationOffset=this._lodGenerationOffset,e.lodGenerationScale=this._lodGenerationScale,e._prefiltered=!0,e}_createEffect(e,t){const i=[];e.gammaSpace&&i.push("#define GAMMA_INPUT"),i.push("#define NUM_SAMPLES "+this.quality+"u");const a=this._engine.isWebGPU;return new R({engine:this._engine,name:"hdrFiltering",vertexShader:"hdrFiltering",fragmentShader:"hdrFiltering",samplerNames:["inputTexture"],uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale","alphaG"],useShaderStore:!0,defines:i,onCompiled:t,shaderLanguage:a?1:0,extraInitializationsAsync:async()=>{a?await Promise.all([_(()=>import("./hdrFiltering.vertex-Bxg3sIdY.js"),__vite__mapDeps([0,1,2,3])),_(()=>import("./hdrFiltering.fragment-Y_VkqQDx.js"),__vite__mapDeps([4,1,2,3,5,6,7]))]):await Promise.all([_(()=>import("./hdrFiltering.vertex-B9jAjN4s.js"),__vite__mapDeps([8,1,2,3])),_(()=>import("./hdrFiltering.fragment-Dj6TDQ7S.js"),__vite__mapDeps([9,1,2,3,10,11,12]))])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this._effectRenderer=new F(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync(),this._prefilterInternal(e),this._effectRenderer.dispose(),this._effectWrapper.dispose()}}class B{constructor(e,t={}){this.quality=4096,this.hdrScale=1,this.useCdf=!1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality,this.useCdf=t.useCdf||this.useCdf}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!1,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:2,label:"HDR_Irradiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),i}_prefilterInternal(e){const t=e.getSize().width,i=M(t),a=this._effectWrapper.effect,h=Math.max(32,1<<M(t>>3)),d=this._createRenderTarget(h);this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const f=[[new r(0,0,-1),new r(0,-1,0),new r(1,0,0)],[new r(0,0,1),new r(0,-1,0),new r(-1,0,0)],[new r(1,0,0),new r(0,0,1),new r(0,1,0)],[new r(1,0,0),new r(0,0,-1),new r(0,-1,0)],[new r(1,0,0),new r(0,-1,0),new r(0,0,1)],[new r(-1,0,0),new r(0,-1,0),new r(0,0,-1)]];a.setFloat("hdrScale",this.hdrScale),a.setFloat2("vFilteringInfo",e.getSize().width,i),a.setTexture("inputTexture",e),this._cdfGenerator&&a.setTexture("icdfTexture",this._cdfGenerator.getIcdfTexture());for(let o=0;o<6;o++)a.setVector3("up",f[o][0]),a.setVector3("right",f[o][1]),a.setVector3("front",f[o][2]),this._engine.bindFramebuffer(d,o,void 0,void 0,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper),this._effectRenderer.draw();this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),a.setTexture("inputTexture",null),a.setTexture("icdfTexture",null);const l=new I(e.getScene(),d.texture);return l.name=e.name+"_irradiance",l.displayName=e.name+"_irradiance",l.gammaSpace=!1,l}_createEffect(e,t){const i=[];e.gammaSpace&&i.push("#define GAMMA_INPUT"),i.push("#define NUM_SAMPLES "+this.quality+"u");const a=this._engine.isWebGPU,h=["inputTexture"];return this._cdfGenerator&&(h.push("icdfTexture"),i.push("#define IBL_CDF_FILTERING")),new R({engine:this._engine,name:"HDRIrradianceFiltering",vertexShader:"hdrIrradianceFiltering",fragmentShader:"hdrIrradianceFiltering",samplerNames:h,uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale"],useShaderStore:!0,defines:i,onCompiled:t,shaderLanguage:a?1:0,extraInitializationsAsync:async()=>{a?await Promise.all([_(()=>import("./hdrIrradianceFiltering.vertex-CbMgEGhA.js"),__vite__mapDeps([13,1,2,3])),_(()=>import("./hdrIrradianceFiltering.fragment-BQdW--_P.js"),__vite__mapDeps([14,1,2,3,5,6,7]))]):await Promise.all([_(()=>import("./hdrIrradianceFiltering.vertex-CaplnPpN.js"),__vite__mapDeps([15,1,2,3])),_(()=>import("./hdrIrradianceFiltering.fragment-mUHSnwSD.js"),__vite__mapDeps([16,1,2,3,10,11,12]))])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){var i;if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this.useCdf&&(this._cdfGenerator=new W(this._engine),this._cdfGenerator.iblSource=e,await this._cdfGenerator.renderWhenReady()),this._effectRenderer=new F(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync();const t=this._prefilterInternal(e);return this.useCdf&&await this._cdfGenerator.findDominantDirection().then(a=>{t._dominantDirection=a}),this._effectRenderer.dispose(),this._effectWrapper.dispose(),(i=this._cdfGenerator)==null||i.dispose(),t}}class g extends I{set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}set rotationY(e){this._rotationY=e,this.setReflectionTextureMatrix(b.RotationY(this._rotationY))}get rotationY(){return this._rotationY}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const t=this.getScene();t&&t.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}constructor(e,t,i,a=!1,h=!0,d=!1,f=!1,l=null,o=null,c=!1,s=!1,n=!1){var u;super(t),this._generateHarmonics=!0,this._onError=null,this._isBlocking=!0,this._rotationY=0,this.boundingBoxPosition=r.Zero(),this.onLoadObservable=new L,e&&(this._coordinatesMode=P.CUBIC_MODE,this.name=e,this.url=e,this.hasAlpha=!1,this.isCube=!0,this._textureMatrix=b.Identity(),this._prefilterOnLoad=f,this._prefilterIrradianceOnLoad=s,this._prefilterUsingCdf=n,this._onLoad=()=>{this.onLoadObservable.notifyObservers(this),l&&l()},this._onError=o,this.gammaSpace=d,this._noMipmap=a,this._size=i,this._supersample=c||n,this._generateHarmonics=h,this._texture=this._getFromCache(e,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?this._texture.isReady?A.SetImmediate(()=>this._onLoad()):this._texture.onLoadedObservable.add(this._onLoad):(u=this.getScene())!=null&&u.useDelayedTextureLoading?this.delayLoadState=4:this._loadTexture())}getClassName(){return"EnvCubeTexture"}_loadTexture(){const e=this._getEngine(),t=e.getCaps();let i=0;t.textureFloat&&t.textureFloatLinearFiltering?i=1:t.textureHalfFloat&&t.textureHalfFloatLinearFiltering&&(i=2);const a=async h=>{this.lodGenerationOffset=0,this.lodGenerationScale=.8;const d=await this._getCubeMapTextureDataAsync(h,this._size,this._supersample);if(this._generateHarmonics){const c=v.ConvertCubeMapToSphericalPolynomial(d);this.sphericalPolynomial=c}const f=[];let l=null,o=null;for(let c=0;c<6;c++){i===2?o=new Uint16Array(this._size*this._size*3):i===0&&(l=new Uint8Array(this._size*this._size*3));const s=d[g._FacesMapping[c]];if(this.gammaSpace||o||l){for(let n=0;n<this._size*this._size;n++)if(this.gammaSpace&&(s[n*3+0]=Math.pow(s[n*3+0],x),s[n*3+1]=Math.pow(s[n*3+1],x),s[n*3+2]=Math.pow(s[n*3+2],x)),o&&(o[n*3+0]=y(s[n*3+0]),o[n*3+1]=y(s[n*3+1]),o[n*3+2]=y(s[n*3+2])),l){let u=Math.max(s[n*3+0]*255,0),m=Math.max(s[n*3+1]*255,0),w=Math.max(s[n*3+2]*255,0);const T=Math.max(Math.max(u,m),w);if(T>255){const S=255/T;u*=S,m*=S,w*=S}l[n*3+0]=u,l[n*3+1]=m,l[n*3+2]=w}}o?f.push(o):l?f.push(l):f.push(s)}return f};if(e._features.allowTexturePrefiltering&&(this._prefilterOnLoad||this._prefilterIrradianceOnLoad)){const h=this._onLoad,d=new z(e);this._onLoad=()=>{let f=Promise.resolve(null),l=Promise.resolve();this._prefilterIrradianceOnLoad&&(f=new B(e,{useCdf:this._prefilterUsingCdf}).prefilter(this)),this._prefilterOnLoad&&(l=d.prefilter(this)),Promise.all([f,l]).then(o=>{const c=o[0];if(this._prefilterIrradianceOnLoad&&c){this.irradianceTexture=c;const s=this.getScene();s&&s.markAllMaterialsAsDirty(1)}h&&h()})}}this._texture=e.createRawCubeTextureFromUrl(this.url,this.getScene(),this._size,4,i,this._noMipmap,a,null,this._onLoad,this._onError),!this._generateHarmonics&&!this._texture._sphericalPolynomial&&(this._texture._sphericalPolynomial=new E)}delayLoad(){this.delayLoadState===4&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||this._loadTexture())}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(e){var t;this._textureMatrix=e,e.updateFlag!==this._textureMatrix.updateFlag&&e.isIdentity()!==this._textureMatrix.isIdentity()&&((t=this.getScene())==null||t.markAllMaterialsAsDirty(1,i=>i.getActiveTextures().indexOf(this)!==-1))}dispose(){this.onLoadObservable.clear(),super.dispose()}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.hasAlpha=this.hasAlpha,e.isCube=!0,e.level=this.level,e.size=this._size,e.coordinatesMode=this.coordinatesMode,e.useInGammaSpace=this.gammaSpace,e.generateHarmonics=this._generateHarmonics,e.noMipmap=this._noMipmap,e.isBlocking=this._isBlocking,e.rotationY=this._rotationY,e}clone(){const e=this._instantiateClone();return e.level=this.level,e.wrapU=this.wrapU,e.wrapV=this.wrapV,e.coordinatesIndex=this.coordinatesIndex,e.coordinatesMode=this.coordinatesMode,e}static _Parse(e,t){t.name=e.name,t.hasAlpha=e.hasAlpha,t.level=e.level,t.coordinatesMode=e.coordinatesMode,t.isBlocking=e.isBlocking,e.boundingBoxPosition&&(t.boundingBoxPosition=r.FromArray(e.boundingBoxPosition)),e.boundingBoxSize&&(t.boundingBoxSize=r.FromArray(e.boundingBoxSize)),e.rotationY&&(t.rotationY=e.rotationY)}}g._FacesMapping=["right","left","up","down","front","back"];class p extends g{constructor(e,t,i,a=!1,h=!0,d=!1,f=!1,l=null,o=null,c=!1,s=!1,n=!1){super(e,t,i,a,h,d,f,l,o,c,s,n)}getClassName(){return"HDRCubeTexture"}async _getCubeMapTextureDataAsync(e,t,i){return G(e,t,i)}_instantiateClone(){return new p(this.url,this.getScene()||this._getEngine(),this._size,this._noMipmap,this._generateHarmonics,this.gammaSpace)}serialize(){const e=super.serialize();return e?(e.customType="BABYLON.HDRCubeTexture",e):null}static Parse(e,t,i){if(!e.name||e.isRenderTarget)return null;const a=new p(i+e.name,t,e.size,e.noMipmap,e.generateHarmonics,e.useInGammaSpace);return this._Parse(e,a),a}}D("BABYLON.HDRCubeTexture",p);export{p as HDRCubeTexture};
