import{aI as h,V as w,o as u,p as Y,Q as y,aJ as R,aK as U}from"./index-C7ioxznG.js";import{A as V}from"./assetContainer-WmWzRef8.js";import{B as b}from"./bone-D3wPsQsS.js";import{S as D}from"./skeleton-Dp5NNatR.js";import"./index-BmJkaHuF.js";import"./rawTexture-B_Rn1rXF.js";const O="Xposition",F="Yposition",k="Zposition",x="Xrotation",v="Yrotation",M="Zrotation",j="HIERARCHY",K="MOTION";class X{constructor(t){this.loopMode=h.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=_(),this.numFrames=0,this.frameRate=0,this.skeleton=t}}function _(){return{name:"",type:"",offset:new w,channels:[],children:[],frames:[],parent:null}}function Z(){return{frame:0,position:new w,rotation:new y}}function z(n){const t=n.offset.x,o=n.offset.y,a=n.offset.z;return u.Translation(t,o,a)}function Q(n,t){if(n.frames.length===0)return[];const o=[],a=n.channels.some(i=>i===O||i===F||i===k),e=n.channels.some(i=>i===x||i===v||i===M),r=new h(`${n.name}_pos`,"position",t.frameRate,h.ANIMATIONTYPE_VECTOR3,t.loopMode),f=new h(`${n.name}_rot`,"rotationQuaternion",t.frameRate,h.ANIMATIONTYPE_QUATERNION,t.loopMode),s=[],c=[];for(let i=0;i<n.frames.length;i++){const l=n.frames[i];a&&l.position&&s.push({frame:l.frame,value:l.position.clone()}),e&&c.push({frame:l.frame,value:l.rotation.clone()})}return s.length>0&&(r.setKeys(s),o.push(r)),c.length>0&&(f.setKeys(c),o.push(f)),o}function P(n,t,o){const a=z(n),e=new b(n.name,o.skeleton,t,a),r=Q(n,o);for(const f of r)f.getKeys()&&f.getKeys().length>0&&e.animations.push(f);for(const f of n.children)P(f,e,o)}function B(n,t,o,a){if(o.type==="ENDSITE")return;const e=Z();e.frame=t,e.position=new w,e.rotation=new y,o.frames.push(e);let r=u.Identity();for(let f=0;f<o.channels.length;++f){const s=o.channels[f],c=n[a.i++];if(!c)continue;const i=parseFloat(c.trim());if(s.endsWith("position"))switch(s){case O:e.position.x=i;break;case F:e.position.y=i;break;case k:e.position.z=i;break}else if(s.endsWith("rotation")){const l=Y.ToRadians(i);let m;switch(s){case x:m=u.RotationX(l);break;case v:m=u.RotationY(l);break;case M:m=u.RotationZ(l);break}r=m.multiply(r)}}y.FromRotationMatrixToRef(r,e.rotation);for(const f of o.children)B(n,t,f,a)}function L(n,t,o,a){var c,i,l,m;const e=_();e.parent=o,a.list.push(e);let r=t.trim().split(/\s+/);if(r[0].toUpperCase()==="END"&&r[1].toUpperCase()==="SITE"?(e.type="ENDSITE",e.name="ENDSITE"):(e.name=r[1],e.type=r[0].toUpperCase()),((c=n.shift())==null?void 0:c.trim())!="{")throw new Error("Expected opening { after type & name");const f=(i=n.shift())==null?void 0:i.trim().split(/\s+/);if(!f)throw new Error("Unexpected end of file: missing OFFSET");if(r=f,r[0].toUpperCase()!="OFFSET")throw new Error("Expected OFFSET, but got: "+r[0]);if(r.length!=4)throw new Error("OFFSET: Invalid number of values");const s=new w(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]));if(isNaN(s.x)||isNaN(s.y)||isNaN(s.z))throw new Error("OFFSET: Invalid values");if(e.offset=s,e.type!="ENDSITE"){if(r=(l=n.shift())==null?void 0:l.trim().split(/\s+/),!r)throw new Error("Unexpected end of file: missing CHANNELS");if(r[0].toUpperCase()!="CHANNELS")throw new Error("Expected CHANNELS definition");const p=parseInt(r[1]);e.channels=r.splice(2,p),e.children=[]}for(;n.length>0;){const p=(m=n.shift())==null?void 0:m.trim();if(p==="}")return e;p&&e.children.push(L(n,p,e,a))}throw new Error("Unexpected end of file: missing closing brace")}function T(n,t,o,a){const e=n.split(`
`),{loopMode:r}=a;t._blockEntityCollection=!!o;const f=new D("","",t);f._parentContainer=o,t._blockEntityCollection=!1;const s=new X(f);s.loopMode=r;const c=e.shift();if(!c||c.trim().toUpperCase()!==j)throw new Error("HIERARCHY expected");const i=e.shift();if(!i)throw new Error("Unexpected end of file after HIERARCHY");const l=L(e,i.trim(),null,s),m=e.shift();if(!m||m.trim().toUpperCase()!==K)throw new Error("MOTION expected");const p=e.shift();if(!p)throw new Error("Unexpected end of file before frame count");const C=p.trim().split(/[\s]+/);if(C.length<2)throw new Error("Invalid frame count line");const N=parseInt(C[1]);if(isNaN(N))throw new Error("Failed to read number of frames.");s.numFrames=N;const H=e.shift();if(!H)throw new Error("Unexpected end of file before frame time");const I=H.trim().split(/[\s]+/);if(I.length<3)throw new Error("Invalid frame time line");const d=parseFloat(I[2]);if(isNaN(d))throw new Error("Failed to read frame time.");if(d<=0)throw new Error("Failed to read frame time. Invalid value "+d);s.frameRate=1/d;for(let g=0;g<N;++g){const A=e.shift();if(!A)continue;const S=A.trim().split(/[\s]+/)||[];B(S,g,l,{i:0})}return s.root=l,P(s.root,null,s),s.skeleton.returnToRest(),s.skeleton}class E{constructor(t){this.name=R.name,this.extensions=R.extensions,this._loadingOptions={...E._DefaultLoadingOptions,...t??{}}}static get _DefaultLoadingOptions(){return{loopMode:h.ANIMATIONLOOPMODE_CYCLE}}createPlugin(t){return new E(t[R.name])}canDirectLoad(t){return this.isBvhHeader(t)}isBvhHeader(t){return t.split(`
`)[0]=="HIERARCHY"}isNotBvhHeader(t){return!this.isBvhHeader(t)}importMeshAsync(t,o,a){if(typeof a!="string")return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(a))return Promise.reject("BVH loader expects HIERARCHY header.");try{const e=T(a,o,null,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[e],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(e){return Promise.reject(e)}}loadAsync(t,o){return typeof o!="string"?Promise.reject("BVH loader expects string data."):this.isNotBvhHeader(o)?Promise.reject("BVH loader expects HIERARCHY header."):this.importMeshAsync(null,t,o).then(()=>{})}loadAssetContainerAsync(t,o){if(typeof o!="string")return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(o))return Promise.reject("BVH loader expects HIERARCHY header.");const a=new V(t);try{const e=T(o,t,a,this._loadingOptions);return a.skeletons.push(e),Promise.resolve(a)}catch(e){return Promise.reject(e)}}}U(new E);export{E as BVHFileLoader};
