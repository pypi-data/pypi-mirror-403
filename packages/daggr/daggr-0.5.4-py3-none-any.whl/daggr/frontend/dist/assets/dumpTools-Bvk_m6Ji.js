const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-C7ioxznG.js","assets/index-BmJkaHuF.js","assets/index-BJecwV5W.css","assets/pass.fragment-BcviHoc5.js"])))=>i.map(i=>d[i]);
import{_ as D}from"./index-BmJkaHuF.js";import{cc as A,p as d,L as v,cd as b,d as g,n as T,E as I,_ as C,ce as x}from"./index-C7ioxznG.js";let f=null;async function S(){var i;const a=((i=g.LastCreatedEngine)==null?void 0:i.createCanvas(100,100))??new OffscreenCanvas(100,100);a instanceof OffscreenCanvas&&v.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:s}=await D(async()=>{const{ThinEngine:e}=await import("./index-C7ioxznG.js").then(c=>c.cv);return{ThinEngine:e}},__vite__mapDeps([0,1,2]));if(!s.IsSupported)throw new Error("DumpData: No WebGL context available. Cannot dump data.");const t={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1},n=new s(a,!1,t);g.Instances.pop(),g.OnEnginesDisposedObservable.add(e=>{n&&e!==n&&!n.isDisposed&&g.Instances.length===0&&_()}),n.getCaps().parallelShaderCompile=void 0;const o=new T(n),{passPixelShader:r}=await D(async()=>{const{passPixelShader:e}=await import("./pass.fragment-BcviHoc5.js");return{passPixelShader:e}},__vite__mapDeps([3,0,1,2])),p=new I({engine:n,name:r.name,fragmentShader:r.shader,samplerNames:["textureSampler"]});return{canvas:a,dumpEngine:{engine:n,renderer:o,wrapper:p}}}async function O(){return f||(f=S()),await f}class E{static async EncodeImageAsync(s,t,n,o,r,p){const i=await O(),e=i.dumpEngine;e.engine.setSize(t,n,!0);const c=e.engine.createRawTexture(s,t,n,5,!1,!r,1);return e.renderer.setViewport(),e.renderer.applyEffectWrapper(e.wrapper),e.wrapper.effect._bindTexture("textureSampler",c),e.renderer.draw(),c.dispose(),await new Promise((l,u)=>{d.ToBlob(i.canvas,m=>{m?l(m):u(new Error("EncodeImageAsync: Failed to convert canvas to blob."))},o,p)})}}C([x],E,"EncodeImageAsync",null);const R=E.EncodeImageAsync;async function h(a,s,t,n,o="image/png",r,p){const i=await t.readPixels(0,0,a,s),e=new Uint8Array(i.buffer);y(a,s,e,n,o,r,!0,void 0,p)}async function w(a,s,t,n="image/png",o,r=!1,p=!1,i){if(t instanceof Float32Array){const l=new Uint8Array(t.length);let u=t.length;for(;u--;){const m=t[u];l[u]=Math.round(A(m)*255)}t=l}const e=await E.EncodeImageAsync(t,a,s,n,r,i);o!==void 0&&d.DownloadBlob(e,o),e.type!==n&&v.Warn(`DumpData: The requested mimeType '${n}' is not supported. The result has mimeType '${e.type}' instead.`);const c=await e.arrayBuffer();return p?c:`data:${n};base64,${b(c)}`}function y(a,s,t,n,o="image/png",r,p=!1,i=!1,e){r===void 0&&!n&&(r=""),w(a,s,t,o,r,p,i,e).then(c=>{n&&n(c)})}function _(){f&&(f==null||f.then(a=>{a.canvas instanceof HTMLCanvasElement&&a.canvas.remove(),a.dumpEngine&&(a.dumpEngine.engine.dispose(),a.dumpEngine.renderer.dispose(),a.dumpEngine.wrapper.dispose())}),f=null)}const W={DumpData:y,DumpDataAsync:w,DumpFramebuffer:h,Dispose:_},L=()=>{d.DumpData=y,d.DumpDataAsync=w,d.DumpFramebuffer=h};L();export{_ as Dispose,y as DumpData,w as DumpDataAsync,h as DumpFramebuffer,W as DumpTools,R as EncodeImageAsync};
