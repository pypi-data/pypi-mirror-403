import{c as r,V as A,Q as T,o as F,L as g,bR as L,bQ as V}from"./index-C7ioxznG.js";import{GLTFLoader as w,ArrayItem as B}from"./glTFLoader-dcV3nFjy.js";import"./thinInstanceMesh-ClAKTXM0.js";import"./index-BmJkaHuF.js";import"./bone-D3wPsQsS.js";import"./skeleton-Dp5NNatR.js";import"./rawTexture-B_Rn1rXF.js";import"./assetContainer-WmWzRef8.js";import"./objectModelMapping-CY2JGqxk.js";const c="EXT_mesh_gpu_instancing";class E{constructor(l){this.name=c,this._loader=l,this.enabled=this._loader.isExtensionUsed(c)}dispose(){this._loader=null}loadNodeAsync(l,s,b){return w.LoadExtensionAsync(l,s,this.name,async(m,h)=>{this._loader._disableInstancedMesh++;const p=this._loader.loadNodeAsync(`/nodes/${s.index}`,s,b);if(this._loader._disableInstancedMesh--,!s._primitiveBabylonMeshes)return await p;const u=new Array;let t=0;const i=a=>{if(h.attributes[a]==null){u.push(Promise.resolve(null));return}const o=B.Get(`${m}/attributes/${a}`,this._loader.gltf.accessors,h.attributes[a]);if(u.push(this._loader._loadFloatAccessorAsync(`/accessors/${o.bufferView}`,o)),t===0)t=o.count;else if(t!==o.count)throw new Error(`${m}/attributes: Instance buffer accessors do not have the same count.`)};return i("TRANSLATION"),i("ROTATION"),i("SCALE"),i("_COLOR_0"),await p.then(async a=>{const[o,d,_,n]=await Promise.all(u),y=new Float32Array(t*16);r.Vector3[0].copyFromFloats(0,0,0),r.Quaternion[0].copyFromFloats(0,0,0,1),r.Vector3[1].copyFromFloats(1,1,1);for(let e=0;e<t;++e)o&&A.FromArrayToRef(o,e*3,r.Vector3[0]),d&&T.FromArrayToRef(d,e*4,r.Quaternion[0]),_&&A.FromArrayToRef(_,e*3,r.Vector3[1]),F.ComposeToRef(r.Vector3[1],r.Quaternion[0],r.Vector3[0],r.Matrix[0]),r.Matrix[0].copyToArray(y,e*16);for(const e of s._primitiveBabylonMeshes)e.thinInstanceSetBuffer("matrix",y,16,!0),n&&(n.length===t*3?e.thinInstanceSetBuffer("color",n,3,!0):n.length===t*4?e.thinInstanceSetBuffer("color",n,4,!0):g.Warn("Unexpected size of _COLOR_0 attribute for mesh "+e.name));return a})})}}L(c);V(c,!0,f=>new E(f));export{E as EXT_mesh_gpu_instancing};
