const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/depth.vertex-Dk3Js-19.js","assets/index-C7ioxznG.js","assets/index-BmJkaHuF.js","assets/index-BJecwV5W.css","assets/bonesDeclaration-CPFcQo5E.js","assets/instancesVertex-C9_ob8I4.js","assets/morphTargetsVertexDeclaration-DFgrcEZ0.js","assets/clipPlaneVertex-BFcaiwOj.js","assets/instancesDeclaration-BPQ1TXm4.js","assets/morphTargetsVertex-CMN--LFF.js","assets/bonesVertex-pqgqQc-t.js","assets/bakedVertexAnimation-mwPok164.js","assets/depth.fragment-B-W_bwh2.js","assets/clipPlaneFragment-Dj_n1rvQ.js","assets/packingFunctions-CazEkDR0.js"])))=>i.map(i=>d[i]);
import{ShadowGenerator as v}from"./shadowGenerator-CYed11Zw.js";import{G as R,T as I,g as Q,x as ie,H as D,a2 as ce,K as ue,N as fe,W as le,$ as _e,C as me,a3 as pe,Y as ge,Z as xe,i as re,E as Me,b as j,O as Se,a4 as Ce,e as ve,V as f,o as A,L as q,d as Ee,a5 as Re,a6 as be,a7 as De,j as X}from"./index-C7ioxznG.js";import{_ as O}from"./index-BmJkaHuF.js";import"./clipPlaneFragment-De5ww3cH.js";import"./packingFunctions-BxWTQVav.js";import"./bakedVertexAnimation-BEH8Oe3p.js";import"./morphTargetsVertex-BRGjlcgZ.js";import"./clipPlaneVertex-CtJF83UU.js";import"./instancesDeclaration-BPyR_knl.js";import"./pointCloudVertex-B_qUFYLl.js";const G="depthPixelShader",ne=`#ifdef ALPHATEST
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vec4 vViewPos;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
gl_FragColor=pack(vViewPos.z);
#else
gl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;R.ShadersStore[G]||(R.ShadersStore[G]=ne);const Ae={name:G,shader:ne},Te=Object.freeze(Object.defineProperty({__proto__:null,depthPixelShader:Ae},Symbol.toStringTag,{value:"Module"})),ee="pointCloudVertexDeclaration",Pe=`#ifdef POINTSIZE
uniform float pointSize;
#endif
`;R.IncludesShadersStore[ee]||(R.IncludesShadersStore[ee]=Pe);const K="depthVertexShader",ae=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform mat4 view;varying vec4 vViewPos;
#endif
#include<pointCloudVertexDeclaration>
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vViewPos=view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<pointCloudVertex>
}
`;R.ShadersStore[K]||(R.ShadersStore[K]=ae);const we={name:K,shader:ae},Fe=Object.freeze(Object.defineProperty({__proto__:null,depthVertexShader:we},Symbol.toStringTag,{value:"Module"}));class L{get shaderLanguage(){return this._shaderLanguage}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}constructor(e,t=1,i=null,s=!1,r=I.TRILINEAR_SAMPLINGMODE,n=!1,h,d){this._shaderLanguage=0,this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._shadersLoaded=!1,this._scene=e,this._storeNonLinearDepth=s,this._storeCameraSpaceZ=n,this.isPacked=t===0,this.isPacked?this.clearColor=new Q(1,1,1,1):this.clearColor=new Q(n?0:1,0,0,1),this._initShaderSourceAsync(),L._SceneComponentInitialization(this._scene);const o=e.getEngine();this._camera=i,r!==I.NEAREST_SAMPLINGMODE&&(t===1&&!o._caps.textureFloatLinearFiltering&&(r=I.NEAREST_SAMPLINGMODE),t===2&&!o._caps.textureHalfFloatLinearFiltering&&(r=I.NEAREST_SAMPLINGMODE));const u=this.isPacked||!o._features.supportExtendedTextureFormats?5:6;this._depthMap=d??new ie(h??"DepthRenderer",{width:o.getRenderWidth(),height:o.getRenderHeight()},this._scene,!1,!0,t,!1,r,void 0,void 0,void 0,u),this._depthMap.wrapU=I.CLAMP_ADDRESSMODE,this._depthMap.wrapV=I.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(c=>{c.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{var c;o._enableGPUDebugMarkers&&(o.restoreDefaultFramebuffer(),(c=o._debugPushGroup)==null||c.call(o,"Depth renderer"))}),this._depthMap.onAfterUnbindObservable.add(()=>{var c;o._enableGPUDebugMarkers&&((c=o._debugPopGroup)==null||c.call(o))}),this._depthMap.customIsReadyFunction=(c,p,l)=>{if((l||p===0)&&c.subMeshes)for(let m=0;m<c.subMeshes.length;++m){const a=c.subMeshes[m],M=a.getRenderingMesh(),T=M._getInstancesRenderList(a._id,!!a.getReplacementMesh()),P=o.getCaps().instancedArrays&&(T.visibleInstances[a._id]!==null&&T.visibleInstances[a._id]!==void 0||M.hasThinInstances);if(!this.isReady(a,P))return!1}return!0};const g=c=>{var J;const p=c.getRenderingMesh(),l=c.getEffectiveMesh(),m=this._scene,a=m.getEngine(),M=c.getMaterial();if(l._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!M||l.infiniteDistance||M.disableDepthWrite||c.verticesCount===0||c._renderId===m.getRenderId())return;const T=l._getWorldMatrixDeterminant()<0;let P=M._getEffectiveOrientation(p);T&&(P=P===0?1:0);const F=P===0;a.setState(M.backFaceCulling,0,!1,F,this.reverseCulling?!M.cullBackFaces:M.cullBackFaces);const z=p._getInstancesRenderList(c._id,!!c.getReplacementMesh());if(z.mustReturn)return;const W=a.getCaps().instancedArrays&&(z.visibleInstances[c._id]!==null&&z.visibleInstances[c._id]!==void 0||p.hasThinInstances),U=this._camera||m.activeCamera;if(this.isReady(c,W)&&U){c._renderId=m.getRenderId();let b=(J=l._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:J[a.currentRenderPassId];if(b===void 0&&l.getClassName()==="GaussianSplattingMesh"&&(b=l.material.makeDepthRenderingMaterial(this._scene,this._shaderLanguage),this.setMaterialForRendering(l,b),!b.isReady()))return;let V=c._getDrawWrapper();!V&&b&&(V=b._getDrawWrapper());const de=U.mode===me.ORTHOGRAPHIC_CAMERA;if(!V)return;const C=V.effect;a.enableEffect(V),W||p._bind(c,C,M.fillMode),b?b.bindForSubMesh(l.getWorldMatrix(),l,c):(C.setMatrix("viewProjection",m.getTransformMatrix()),C.setMatrix("world",l.getWorldMatrix()),this._storeCameraSpaceZ&&C.setMatrix("view",m.getViewMatrix()));let Z,H;if(de?(Z=!a.useReverseDepthBuffer&&a.isNDCHalfZRange?0:1,H=a.useReverseDepthBuffer&&a.isNDCHalfZRange?0:1):(Z=a.useReverseDepthBuffer&&a.isNDCHalfZRange?U.minZ:a.isNDCHalfZRange?0:U.minZ,H=a.useReverseDepthBuffer&&a.isNDCHalfZRange?0:U.maxZ),C.setFloat2("depthValues",Z,Z+H),!b){if(M.needAlphaTestingForMesh(l)){const N=M.getAlphaTestTexture();N&&(C.setTexture("diffuseSampler",N),C.setMatrix("diffuseMatrix",N.getTextureMatrix()))}pe(p,C),ge(C,M,m),xe(p,C),p.morphTargetManager&&p.morphTargetManager.isUsingTextureForTargets&&p.morphTargetManager._bind(C);const y=c.getMesh().bakedVertexAnimationManager;y&&y.isEnabled&&y.bind(C,W),M.pointsCloud&&C.setFloat("pointSize",M.pointSize)}p._processRendering(l,c,C,M.fillMode,z,W,(y,N)=>C.setMatrix("world",N))}};this._depthMap.customRenderFunction=(c,p,l,m)=>{let a;if(m.length)for(a=0;a<m.length;a++)g(m.data[a]);for(a=0;a<c.length;a++)g(c.data[a]);for(a=0;a<p.length;a++)g(p.data[a]);if(this.forceDepthWriteTransparentMeshes)for(a=0;a<l.length;a++)g(l.data[a]);else for(a=0;a<l.length;a++)l.data[a].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}async _initShaderSourceAsync(e=!1){this._scene.getEngine().isWebGPU&&!e&&!L.ForceGLSL?(this._shaderLanguage=1,await Promise.all([O(()=>import("./depth.vertex-Dk3Js-19.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),O(()=>import("./depth.fragment-B-W_bwh2.js"),__vite__mapDeps([12,1,2,3,13,14]))])):await Promise.all([O(()=>Promise.resolve().then(()=>Fe),void 0),O(()=>Promise.resolve().then(()=>Te),void 0)]),this._shadersLoaded=!0}isReady(e,t){var P;if(!this._shadersLoaded)return!1;const i=this._scene.getEngine(),s=e.getMesh(),r=s.getScene(),n=(P=s._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:P[i.currentRenderPassId];if(n)return n.isReadyForSubMesh(s,e,t);const h=e.getMaterial();if(!h||h.disableDepthWrite)return!1;const d=[],o=[D.PositionKind];let u=!1,g=!1;const c=!1;h.needAlphaTestingForMesh(s)&&h.getAlphaTestTexture()&&(d.push("#define ALPHATEST"),s.isVerticesDataPresent(D.UVKind)&&(o.push(D.UVKind),d.push("#define UV1"),u=!0),s.isVerticesDataPresent(D.UV2Kind)&&(o.push(D.UV2Kind),d.push("#define UV2"),g=!0));const p=new ce;if(s.useBones&&s.computeBonesUsingShaders&&s.skeleton){o.push(D.MatricesIndicesKind),o.push(D.MatricesWeightsKind),s.numBoneInfluencers>4&&(o.push(D.MatricesIndicesExtraKind),o.push(D.MatricesWeightsExtraKind)),d.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers),s.numBoneInfluencers>0&&p.addCPUSkinningFallback(0,s);const F=s.skeleton;F.isUsingTextureForMatrices?d.push("#define BONETEXTURE"):d.push("#define BonesPerMesh "+(F.bones.length+1))}else d.push("#define NUM_BONE_INFLUENCERS 0");const l=s.morphTargetManager?ue(s.morphTargetManager,d,o,s,!0,!1,!1,u,g,c):0;h.pointsCloud&&d.push("#define POINTSIZE"),t&&(d.push("#define INSTANCES"),fe(o),e.getRenderingMesh().hasThinInstances&&d.push("#define THIN_INSTANCES"));const m=s.bakedVertexAnimationManager;m&&m.isEnabled&&(d.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&o.push("bakedVertexAnimationSettingsInstanced")),this._storeNonLinearDepth&&d.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&d.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&d.push("#define PACKED"),le(h,r,d);const a=e._getDrawWrapper(void 0,!0),M=a.defines,T=d.join(`
`);if(M!==T){const F=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],z=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];_e(F),a.setEffect(i.createEffect("depth",{attributes:o,uniformsNames:F,uniformBuffersNames:[],samplers:z,defines:T,fallbacks:p,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:l},shaderLanguage:this._shaderLanguage},i),T)}return a.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer)this._scene._depthRenderer[t]===this&&e.push(t);if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}L.ForceGLSL=!1;L._SceneComponentInitialization=S=>{throw re("DepthRendererSceneComponent")};var te;(function(S){S[S.NormalizedViewDepth=0]="NormalizedViewDepth",S[S.ViewDepth=1]="ViewDepth",S[S.ScreenDepth=2]="ScreenDepth"})(te||(te={}));class w extends Me{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(O(()=>Promise.resolve().then(()=>Ve),void 0))):t.push(O(()=>Promise.resolve().then(()=>Le),void 0))}constructor(e,t=null,i="",s){super({...s,name:e,engine:t||j.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:w.FragmentUrl,uniforms:w.Uniforms,defines:i}),this.textureWidth=0,this.textureHeight=0}bind(e=!1){super.bind(e);const t=this.drawWrapper.effect;this.textureWidth===1||this.textureHeight===1?t.setInt2("texSize",this.textureWidth,this.textureHeight):t.setFloat2("texSize",this.textureWidth,this.textureHeight)}}w.FragmentUrl="minmaxRedux";w.Uniforms=["texSize"];const ze=new Float32Array(4),Ie=new Uint8Array(4),E={min:0,max:0};class Be{get depthRedux(){return this._depthRedux}set depthRedux(e){this._depthRedux!==e&&(this._depthRedux=e,this._recreatePostProcesses())}get textureWidth(){return this._textureWidth}get textureHeight(){return this._textureHeight}constructor(e,t=!0){this.onAfterReductionPerformed=new Se,this._textureWidth=0,this._textureHeight=0,this._scene=e,this._depthRedux=t,this.reductionSteps=[]}setTextureDimensions(e,t,i=0){return e===this._textureWidth&&t===this._textureHeight&&i===this._depthTextureType?!1:(this._textureWidth=e,this._textureHeight=t,this._depthTextureType=i,this._recreatePostProcesses(),!0)}readMinMax(e){const t=e.type===j.TEXTURETYPE_FLOAT||e.type===j.TEXTURETYPE_HALF_FLOAT,i=t?ze:Ie;this._scene.getEngine()._readTexturePixels(e,1,1,-1,0,i,!1),E.min=i[0],E.max=i[1],t||(E.min=E.min/255,E.max=E.max/255),E.min>=E.max&&(E.min=0,E.max=1),this.onAfterReductionPerformed.notifyObservers(E)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._textureWidth=0,this._textureHeight=0);for(let t=0;t<this.reductionSteps.length;++t)this.reductionSteps[t].dispose();this.reductionSteps.length=0}_recreatePostProcesses(){this.dispose(!1);const e=this._scene;let t=this.textureWidth,i=this.textureHeight;const s=new w("Initial reduction phase",e.getEngine(),"#define INITIAL"+(this._depthRedux?`
#define DEPTH_REDUX`:"")+(this._depthTextureType===1?`
#define VIEW_DEPTH`:""));s.textureWidth=t,s.textureHeight=i,this.reductionSteps.push(s);let r=1;for(;t>1||i>1;){t=Math.max(Math.round(t/2),1),i=Math.max(Math.round(i/2),1);const n=new w("Reduction phase "+r,e.getEngine(),"#define "+(t==1&&i==1?"LAST":t==1||i==1?"ONEBEFORELAST":"MAIN"));n.textureWidth=t,n.textureHeight=i,this.reductionSteps.push(n),r++}}}const $="minmaxReduxPixelShader",oe=`varying vec2 vUV;uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(textureSampler,coord,0).r;float f2=texelFetch(textureSampler,coord+ivec2(1,0),0).r;float f3=texelFetch(textureSampler,coord+ivec2(1,1),0).r;float f4=texelFetch(textureSampler,coord+ivec2(0,1),0).r;
#ifdef DEPTH_REDUX
#ifdef VIEW_DEPTH
float minz=3.4e38;if (f1 != 0.0) { minz=f1; }
if (f2 != 0.0) { minz=min(minz,f2); }
if (f3 != 0.0) { minz=min(minz,f3); }
if (f4 != 0.0) { minz=min(minz,f4); }
float maxz=max(max(max(f1,f2),f3),f4);
#else
float minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#endif
#else
float minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
void main(void)
{glFragColor=vec4(0.);if (true) { 
discard;}}
#endif
`;R.ShadersStore[$]||(R.ShadersStore[$]=oe);const Oe={name:$,shader:oe},Le=Object.freeze(Object.defineProperty({__proto__:null,minmaxReduxPixelShader:Oe},Symbol.toStringTag,{value:"Module"})),Y="minmaxReduxPixelShader",he=`varying vUV: vec2f;var textureSampler: texture_2d<f32>;
#if defined(INITIAL)
uniform texSize: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;
#ifdef DEPTH_REDUX
#ifdef VIEW_DEPTH
var minz=3.4e38;if (f1 != 0.0) { minz=f1; }
if (f2 != 0.0) { minz=min(minz,f2); }
if (f3 != 0.0) { minz=min(minz,f3); }
if (f4 != 0.0) { minz=min(minz,f4); }
let maxz=max(max(max(f1,f2),f3),f4);
#else
let minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#endif
#else
let minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);
#endif
fragmentOutputs.color=vec4f(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform texSize: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform texSize: vec2i;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { 
discard;}}
#endif
`;R.ShadersStoreWGSL[Y]||(R.ShadersStoreWGSL[Y]=he);const Ue={name:Y,shader:he},Ve=Object.freeze(Object.defineProperty({__proto__:null,minmaxReduxPixelShaderWGSL:Ue},Symbol.toStringTag,{value:"Module"}));class ye{get onAfterReductionPerformed(){return this._thinMinMaxReducer.onAfterReductionPerformed}constructor(e){this._onAfterUnbindObserver=null,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new Ce(e.getScene()),this._thinMinMaxReducer=new Be(e.getScene()),this._reductionSteps=[],this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,i=2,s=!0){if(e!==this._sourceTexture&&(this._thinMinMaxReducer.depthRedux=t,this.deactivate(),this._sourceTexture=e,this._forceFullscreenViewport=s,this._thinMinMaxReducer.setTextureDimensions(e.getRenderWidth(),e.getRenderHeight()))){this._disposePostProcesses();const r=this._thinMinMaxReducer.reductionSteps;for(let n=0;n<r.length;++n){const h=r[n],d=new ve(h.name,w.FragmentUrl,{effectWrapper:h,samplingMode:1,engine:this._camera.getScene().getEngine(),textureType:i,textureFormat:7,size:{width:h.textureWidth,height:h.textureHeight}});this._reductionSteps.push(d),d.autoClear=!1,d.forceFullscreenViewport=s,n===0&&(d.externalTextureSamplerBinding=!0,d.onApplyObservable.add(o=>{o.setTexture("textureSampler",this._sourceTexture)})),n===r.length-1&&this._reductionSteps[n-1].onAfterRenderObservable.add(()=>{this._thinMinMaxReducer.readMinMax(d.inputTexture.texture)})}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){this._onAfterUnbindObserver||!this._sourceTexture||(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{var t,i;const e=this._camera.getScene().getEngine();(t=e._debugPushGroup)==null||t.call(e,"min max reduction"),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport,0,0,!0,this._reductionSteps.length-1),e.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length-1].inputTexture,!1),(i=e._debugPopGroup)==null||i.call(e)}),this._activated=!0)}deactivate(){!this._onAfterUnbindObserver||!this._sourceTexture||(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=void 0,this._disposePostProcesses(),this._postProcessManager.dispose(),this._postProcessManager=void 0,this._thinMinMaxReducer.dispose(),this._thinMinMaxReducer=void 0,this._sourceTexture=null)}_disposePostProcesses(){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps.length=0}}class Ne extends ye{get depthRenderer(){return this._depthRenderer}constructor(e){super(e)}setDepthRenderer(e=null,t=2,i=!0){const s=this._camera.getScene();this._depthRenderer&&(delete s._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),e===null&&(s._depthRenderer||(s._depthRenderer={}),this._depthRendererId="minmax_"+this._camera.id,e=this._depthRenderer=new L(s,t,this._camera,!1,1,!1,`DepthRenderer ${this._depthRendererId}`),e.enabled=!1,s._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,i)}setSourceTexture(e,t,i=2,s=!0){super.setSourceTexture(e,t,i,s)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){super.dispose(e),this._depthRenderer&&e&&(this._depthRenderer.dispose(),this._depthRenderer=null)}}const se=f.Up(),We=f.Zero(),_=new f,B=new f,k=new A;class x extends v{_validateFilter(e){return e===v.FILTER_NONE||e===v.FILTER_PCF||e===v.FILTER_PCSS?e:(q.Error('Unsupported filter "'+e+'"!'),v.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){e=Math.min(Math.max(e,x.MIN_CASCADES_COUNT),x.MAX_CASCADES_COUNT),e!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),!this._freezeShadowCastersBoundingInfoObservable&&!e&&(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(()=>this._computeShadowCastersBoundingInfo())),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const i=e[t];if(!i)continue;const s=i.getBoundingInfo(),r=s.boundingBox;this._scbiMin.minimizeInPlace(r.minimumWorld),this._scbiMax.maximizeInPlace(r.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return x.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(e){const t=this._getCamera();if(!t){this._shadowMaxZ=e;return}this._shadowMaxZ===e||e<t.minZ||e>t.maxZ&&t.maxZ!==0||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0)}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._getCamera();if(t){if(this._autoCalcDepthBounds=e,!e){this._depthReducer&&this._depthReducer.deactivate(),this.setMinMaxDistance(0,1);return}this._depthReducer||(this._depthReducer=new Ne(t),this._depthReducer.onAfterReductionPerformed.add(i=>{let s=i.min,r=i.max;s>=r&&(s=0,r=1),(s!=this._minDistance||r!=this._maxDistance)&&this.setMinMaxDistance(s,r)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){var e,t;return((t=(e=this._depthReducer)==null?void 0:e.depthRenderer)==null?void 0:t.getDepthMap().refreshRate)??-1}set autoCalcDepthBoundsRefreshRate(e){var t;(t=this._depthReducer)!=null&&t.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._getCamera();if(!e)return;const t=e.minZ,i=e.maxZ||this._shadowMaxZ,s=i-t,r=this._minDistance,n=this._shadowMaxZ<i&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(i-t),this._maxDistance):this._maxDistance,h=t+r*s,d=t+n*s,o=d-h,u=d/h;for(let g=0;g<this._cascades.length;++g){const c=(g+1)/this._numCascades,p=h*u**c,l=h+o*c,m=this._lambda*(p-l)+l;this._cascades[g].prevBreakDistance=g===0?r:this._cascades[g-1].breakDistance,this._cascades[g].breakDistance=(m-t)/s,this._viewSpaceFrustumsZ[g]=m,this._frustumLengths[g]=(this._cascades[g].breakDistance-this._cascades[g].prevBreakDistance)*s}this._breaksAreDirty=!1}_computeMatrices(){const e=this._scene;if(!this._getCamera())return;f.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),Math.abs(f.Dot(this._lightDirection,f.Up()))===1&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const i=e.getEngine().useReverseDepthBuffer;for(let s=0;s<this._numCascades;++s){this._computeFrustumInWorldSpace(s),this._computeCascadeFrustum(s),this._cascadeMaxExtents[s].subtractToRef(this._cascadeMinExtents[s],_),this._frustumCenter[s].addToRef(this._lightDirection.scale(this._cascadeMinExtents[s].z),this._shadowCameraPos[s]),A.LookAtLHToRef(this._shadowCameraPos[s],this._frustumCenter[s],se,this._viewMatrices[s]);let r=0,n=_.z;const h=this._shadowCastersBoundingInfo;h.update(this._viewMatrices[s]);const d=h.boundingBox.minimumWorld.z,o=h.boundingBox.maximumWorld.z;d>n||(!this._depthClamp||this.filter===v.FILTER_PCSS?(r=Math.min(r,d),this.filter!==v.FILTER_PCSS&&(n=Math.min(n,o))):(n=Math.min(n,o),r=Math.max(r,d),n=Math.max(r+1,n))),A.OrthoOffCenterLHToRef(this._cascadeMinExtents[s].x,this._cascadeMaxExtents[s].x,this._cascadeMinExtents[s].y,this._cascadeMaxExtents[s].y,i?n:r,i?r:n,this._projectionMatrices[s],e.getEngine().isNDCHalfZRange),this._cascadeMinExtents[s].z=r,this._cascadeMaxExtents[s].z=n,this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s],this._transformMatrices[s]),f.TransformCoordinatesToRef(We,this._transformMatrices[s],_),_.scaleInPlace(this._mapSize/2),B.copyFromFloats(Math.round(_.x),Math.round(_.y),Math.round(_.z)),B.subtractInPlace(_).scaleInPlace(2/this._mapSize),A.TranslationToRef(B.x,B.y,0,k),this._projectionMatrices[s].multiplyToRef(k,this._projectionMatrices[s]),this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s],this._transformMatrices[s]),this._transformMatrices[s].copyToArray(this._transformMatricesAsArray,s*16)}}_computeFrustumInWorldSpace(e){const t=this._getCamera();if(!t)return;const i=this._cascades[e].prevBreakDistance,s=this._cascades[e].breakDistance,r=this._scene.getEngine().isNDCHalfZRange;t.getViewMatrix();const n=t.maxZ===0,h=t.maxZ;n&&(t.maxZ=this._shadowMaxZ,t.getProjectionMatrix(!0));const d=A.Invert(t.getTransformationMatrix());n&&(t.maxZ=h,t.getProjectionMatrix(!0));const o=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let u=0;u<x._FrustumCornersNdcSpace.length;++u)_.copyFrom(x._FrustumCornersNdcSpace[(u+o)%x._FrustumCornersNdcSpace.length]),r&&_.z===-1&&(_.z=0),f.TransformCoordinatesToRef(_,d,this._frustumCornersWorldSpace[e][u]);for(let u=0;u<x._FrustumCornersNdcSpace.length/2;++u)_.copyFrom(this._frustumCornersWorldSpace[e][u+4]).subtractInPlace(this._frustumCornersWorldSpace[e][u]),B.copyFrom(_).scaleInPlace(i),_.scaleInPlace(s),_.addInPlace(this._frustumCornersWorldSpace[e][u]),this._frustumCornersWorldSpace[e][u+4].copyFrom(_),this._frustumCornersWorldSpace[e][u].addInPlace(B)}_computeCascadeFrustum(e){if(this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0),!!this._getCamera()){for(let i=0;i<this._frustumCornersWorldSpace[e].length;++i)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][i]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let i=0;for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s){const r=this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e],_).length();i=Math.max(i,r)}i=Math.ceil(i*16)/16,this._cascadeMaxExtents[e].copyFromFloats(i,i,i),this._cascadeMinExtents[e].copyFromFloats(-i,-i,-i)}else{const i=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,_),A.LookAtLHToRef(i,_,se,k);for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s)f.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][s],k,_),this._cascadeMinExtents[e].minimizeInPlace(_),this._cascadeMaxExtents[e].maximizeInPlace(_)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))}static get IsSupported(){const e=Ee.LastCreatedEngine;return e?e._features.supportCSM:!1}constructor(e,t,i,s,r=!0){if(!x.IsSupported){q.Error("CascadedShadowMap is not supported by the current engine.");return}super(e,t,i,s,r),this.usePercentageCloserFiltering=!0}_initializeGenerator(){var e;this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??x.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new f(0,0,0),this._scbiMax=this._scbiMax??new f(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new Re(new f(0,0,0),new f(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??((e=this._getCamera())==null?void 0:e.maxZ)??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){var i;const e=this._scene.getEngine();(i=this._shadowMap)==null||i.dispose();const t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new ie(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0,void 0,void 0,void 0,`DepthStencilForCSMShadowGenerator-${this._light.name}`),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),this._shadowMap===null)return;this._transformMatricesAsArray=new Float32Array(this._numCascades*16),this._tempTransformMatricesAsArray=new Float32Array(this._numCascades*16),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(this._numCascades*2),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let t=0;t<this._numCascades;++t){this._cascades[t]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[t]=A.Zero(),this._projectionMatrices[t]=A.Zero(),this._transformMatrices[t]=A.Zero(),this._cascadeMinExtents[t]=new f,this._cascadeMaxExtents[t]=new f,this._frustumCenter[t]=new f,this._shadowCameraPos[t]=new f,this._frustumCornersWorldSpace[t]=new Array(x._FrustumCornersNdcSpace.length);for(let i=0;i<x._FrustumCornersNdcSpace.length;++i)this._frustumCornersWorldSpace[t][i]=new f}const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(t=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[t]),this._currentLayer=t,this._filter===v.FILTER_PCF&&e.setColorWrite(!1),be.eyeAtCamera=!1,this._scene.setTransformMatrix(this.getCascadeViewMatrix(t),this.getCascadeProjectionMatrix(t)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{var t;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),e._enableGPUDebugMarkers&&(e.restoreDefaultFramebuffer(),(t=e._debugPushGroup)==null||t.call(e,`Cascaded shadow map generation for pass id ${e.currentRenderPassId}`)),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(e){e.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==v.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const i=this._scene,s=this._light;if(!i.shadowsEnabled||!s.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=i.useRightHandedSystem;const r=this._getCamera();r&&this._shadowMaxZ<=(r.maxZ||this._shadowMaxZ)&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),this.cascadeBlendPercentage===0&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(e,t){const i=this._light,s=this._scene;if(!s.shadowsEnabled||!i.shadowEnabled)return;const r=this._getCamera();if(!r)return;const n=this.getShadowMap();if(!n)return;const h=n.getSize().width,d=this._transformMatricesAsArray,o=s.floatingOriginMode?De(this._scene.floatingOriginOffset,this._viewMatrices,this._projectionMatrices,this._numCascades,this._tempTransformMatricesAsArray):d;if(t.setMatrices("lightMatrix"+e,o),t.setArray("viewFrustumZ"+e,this._viewSpaceFrustumsZ),t.setFloat("cascadeBlendFactor"+e,this.cascadeBlendPercentage===0?1e4:1/this.cascadeBlendPercentage),t.setArray("frustumLengths"+e,this._frustumLengths),this._filter===v.FILTER_PCF)t.setDepthStencilTexture("shadowTexture"+e,n),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),h,1/h,this.frustumEdgeFalloff,e);else if(this._filter===v.FILTER_PCSS){for(let u=0;u<this._numCascades;++u)this._lightSizeUVCorrection[u*2+0]=u===0?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[u].x-this._cascadeMinExtents[u].x),this._lightSizeUVCorrection[u*2+1]=u===0?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[u].y-this._cascadeMinExtents[u].y),this._depthCorrection[u]=u===0?1:(this._cascadeMaxExtents[u].z-this._cascadeMinExtents[u].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);t.setDepthStencilTexture("shadowTexture"+e,n),t.setTexture("depthTexture"+e,n),t.setArray2("lightSizeUVCorrection"+e,this._lightSizeUVCorrection),t.setArray("depthCorrection"+e,this._depthCorrection),t.setFloat("penumbraDarkness"+e,this.penumbraDarkness),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/h,this._contactHardeningLightSizeUVRatio*h,this.frustumEdgeFalloff,e)}else t.setTexture("shadowTexture"+e,n),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),h,1/h,this.frustumEdgeFalloff,e);i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(r),this.getLight().getDepthMinZ(r)+this.getLight().getDepthMaxZ(r),e)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let i=0;i<t.renderList.length;i++){const s=t.renderList[i];e.renderList.push(s.id)}return e}static Parse(e,t){const i=v.Parse(e,t,(s,r,n)=>new x(s,r,void 0,n));return e.numCascades!==void 0&&(i.numCascades=e.numCascades),e.debug!==void 0&&(i.debug=e.debug),e.stabilizeCascades!==void 0&&(i.stabilizeCascades=e.stabilizeCascades),e.lambda!==void 0&&(i.lambda=e.lambda),e.cascadeBlendPercentage!==void 0&&(i.cascadeBlendPercentage=e.cascadeBlendPercentage),e.depthClamp!==void 0&&(i.depthClamp=e.depthClamp),e.autoCalcDepthBounds!==void 0&&(i.autoCalcDepthBounds=e.autoCalcDepthBounds),e.shadowMaxZ!==void 0&&(i.shadowMaxZ=e.shadowMaxZ),e.penumbraDarkness!==void 0&&(i.penumbraDarkness=e.penumbraDarkness),e.freezeShadowCastersBoundingInfo!==void 0&&(i.freezeShadowCastersBoundingInfo=e.freezeShadowCastersBoundingInfo),e.minDistance!==void 0&&e.maxDistance!==void 0&&i.setMinMaxDistance(e.minDistance,e.maxDistance),i}}x._FrustumCornersNdcSpace=[new f(-1,1,-1),new f(1,1,-1),new f(1,-1,-1),new f(-1,-1,-1),new f(-1,1,1),new f(1,1,1),new f(1,-1,1),new f(-1,-1,1)];x.CLASSNAME="CascadedShadowGenerator";x.DEFAULT_CASCADES_COUNT=4;x.MIN_CASCADES_COUNT=2;x.MAX_CASCADES_COUNT=4;x._SceneComponentInitialization=S=>{throw re("ShadowGeneratorSceneComponent")};class Ze{constructor(e){this.name=X.NAME_SHADOWGENERATOR,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(X.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(e){e.shadowGenerators=[];const t=this.scene.lights;for(const i of t){if(i.doNotSerialize)continue;const s=i.getShadowGenerators();if(s){const r=s.values();for(let n=r.next();n.done!==!0;n=r.next()){const h=n.value;h.doNotSerialize||e.shadowGenerators.push(h.serialize())}}}}addFromContainer(e){}removeFromContainer(e,t){}dispose(){}_gatherRenderTargets(e){const t=this.scene;if(this.scene.shadowsEnabled)for(let i=0;i<t.lights.length;i++){const s=t.lights[i],r=s.getShadowGenerators();if(s.isEnabled()&&s.shadowEnabled&&r){const n=r.values();for(let h=n.next();h.done!==!0;h=n.next()){const o=h.value.getShadowMap();t.textures.indexOf(o)!==-1&&e.push(o)}}}}}v._SceneComponentInitialization=S=>{let e=S._getComponent(X.NAME_SHADOWGENERATOR);e||(e=new Ze(S),S._addComponent(e))};export{Ze as ShadowGeneratorSceneComponent};
