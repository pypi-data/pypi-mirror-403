import{p as L,ab as m,T as d,L as R,V as a,bC as D,_ as C,s as w,f as S,b0 as y,bz as M,Q as z,bR as B,bQ as U}from"./index-C7ioxznG.js";import{R as b}from"./rawTexture-B_Rn1rXF.js";import{ArrayItem as A,GLTFLoader as E}from"./glTFLoader-dcV3nFjy.js";import"./index-BmJkaHuF.js";import"./bone-D3wPsQsS.js";import"./skeleton-Dp5NNatR.js";import"./assetContainer-WmWzRef8.js";import"./objectModelMapping-CY2JGqxk.js";async function F(){const i=new Uint16Array(16384),t=new Uint16Array(4096*4),s=await L.LoadFileAsync(L.GetAssetUrl("https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin")),e=new Uint16Array(s),n=e.length/8;for(let r=0;r<n;r++)i[r*4]=e[r*8],i[r*4+1]=e[r*8+1],i[r*4+2]=e[r*8+2],i[r*4+3]=e[r*8+3],t[r*4]=e[r*8+4],t[r*4+1]=e[r*8+5],t[r*4+2]=e[r*8+6],t[r*4+3]=e[r*8+7];return[i,t]}function P(i){const t=i.useDelayedTextureLoading;i.useDelayedTextureLoading=!1;const s=i._blockEntityCollection;i._blockEntityCollection=!1,i._ltcTextures={LTC1:b.CreateRGBATexture(null,64,64,i.getEngine(),!1,!1,2,2,0,!1,!0),LTC2:b.CreateRGBATexture(null,64,64,i.getEngine(),!1,!1,2,2,0,!1,!0)},i._blockEntityCollection=s,i._ltcTextures.LTC1.wrapU=d.CLAMP_ADDRESSMODE,i._ltcTextures.LTC1.wrapV=d.CLAMP_ADDRESSMODE,i._ltcTextures.LTC2.wrapU=d.CLAMP_ADDRESSMODE,i._ltcTextures.LTC2.wrapV=d.CLAMP_ADDRESSMODE,i.useDelayedTextureLoading=t,F().then(e=>{var n,r;i._ltcTextures&&(((n=i._ltcTextures)==null?void 0:n.LTC1).update(e[0]),((r=i._ltcTextures)==null?void 0:r.LTC2).update(e[1]),i.onDisposeObservable.addOnce(()=>{var o,f;(o=i._ltcTextures)==null||o.LTC1.dispose(),(f=i._ltcTextures)==null||f.LTC2.dispose()}))}).catch(e=>{R.Error(`Area Light fail to get LTC textures data. Error: ${e}`)})}class O extends m{constructor(t,s,e,n){super(t,e,n),this.position=s,this._scene._ltcTextures||P(this._scene)}transferTexturesToEffect(t,s){return this._scene._ltcTextures&&(t.setTexture("areaLightsLTC1Sampler",this._scene._ltcTextures.LTC1),t.setTexture("areaLightsLTC2Sampler",this._scene._ltcTextures.LTC2)),this}prepareLightSpecificDefines(t,s){t["AREALIGHT"+s]=!0,t.AREALIGHTUSED=!0}_isReady(){return this._scene._ltcTextures?this._scene._ltcTextures.LTC1.isReady()&&this._scene._ltcTextures.LTC2.isReady():!1}}D.AddNodeConstructor("Light_Type_4",(i,t)=>()=>new u(i,a.Zero(),1,1,t));class u extends O{get emissionTexture(){return this._emissionTextureTexture}set emissionTexture(t){this._emissionTextureTexture!==t&&(this._emissionTextureTexture=t,this._emissionTextureTexture&&(this._emissionTextureTexture.wrapU=0,this._emissionTextureTexture.wrapV=0),this._emissionTextureTexture&&u._IsTexture(this._emissionTextureTexture)&&this._emissionTextureTexture.onLoadObservable.addOnce(()=>{this._markMeshesAsLightDirty()}))}get width(){return this._width.x}set width(t){this._width.x=t}get height(){return this._height.y}set height(t){this._height.y=t}constructor(t,s,e,n,r,l){super(t,s,r,l),this._emissionTextureTexture=null,this._width=new a(e,0,0),this._height=new a(0,n,0),this._pointTransformedPosition=a.Zero(),this._pointTransformedWidth=a.Zero(),this._pointTransformedHeight=a.Zero()}getClassName(){return"RectAreaLight"}getTypeID(){return m.LIGHTTYPEID_RECT_AREALIGHT}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightWidth",4),this._uniformBuffer.addUniform("vLightHeight",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeTransformedInformation(){return this.parent&&this.parent.getWorldMatrix?(a.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._pointTransformedPosition),a.TransformNormalToRef(this._width,this.parent.getWorldMatrix(),this._pointTransformedWidth),a.TransformNormalToRef(this._height,this.parent.getWorldMatrix(),this._pointTransformedHeight),!0):!1}static _IsTexture(t){return t.onLoadObservable!==void 0}transferToEffect(t,s){const e=this._scene.floatingOriginOffset;return this._computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this._pointTransformedPosition.x-e.x,this._pointTransformedPosition.y-e.y,this._pointTransformedPosition.z-e.z,0,s),this._uniformBuffer.updateFloat4("vLightWidth",this._pointTransformedWidth.x/2,this._pointTransformedWidth.y/2,this._pointTransformedWidth.z/2,0,s),this._uniformBuffer.updateFloat4("vLightHeight",this._pointTransformedHeight.x/2,this._pointTransformedHeight.y/2,this._pointTransformedHeight.z/2,0,s)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x-e.x,this.position.y-e.y,this.position.z-e.z,0,s),this._uniformBuffer.updateFloat4("vLightWidth",this._width.x/2,this._width.y/2,this._width.z/2,0,s),this._uniformBuffer.updateFloat4("vLightHeight",this._height.x/2,this._height.y/2,this._height.z/2,0,s)),this}transferTexturesToEffect(t,s){return super.transferTexturesToEffect(t,s),this._emissionTextureTexture&&this._emissionTextureTexture.isReady()&&t.setTexture("rectAreaLightEmissionTexture"+s,this._emissionTextureTexture),this}transferToNodeMaterialEffect(t,s){const e=this._scene.floatingOriginOffset;return this._computeTransformedInformation()?t.setFloat3(s,this._pointTransformedPosition.x-e.x,this._pointTransformedPosition.y-e.y,this._pointTransformedPosition.z-e.z):t.setFloat3(s,this.position.x-e.x,this.position.y-e.y,this.position.z-e.z),this}prepareLightSpecificDefines(t,s){super.prepareLightSpecificDefines(t,s),t["RECTAREALIGHTEMISSIONTEXTURE"+s]=!!(this._emissionTextureTexture&&this._emissionTextureTexture.isReady())}}C([w()],u.prototype,"width",null);C([w()],u.prototype,"height",null);S("BABYLON.RectAreaLight",u);const c="EXT_lights_area";class v{constructor(t){this.name=c,this._loader=t,this.enabled=this._loader.isExtensionUsed(c)}dispose(){this._loader=null,delete this._lights}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const s=t[this.name];this._lights=s.lights,A.Assign(this._lights)}}loadNodeAsync(t,s,e){return E.LoadExtensionAsync(t,s,this.name,async(n,r)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(t,s,l=>{var x;let h;const o=A.Get(n,this._lights,r.light),f=o.name||l.name;this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer;const _=o.size!==void 0?o.size:1;switch(o.type){case"rect":{const T=((x=o.rect)==null?void 0:x.aspect)!==void 0?o.rect.aspect*_:_,g=_;h=new u(f,a.Zero(),T,g,this._loader.babylonScene);break}case"disk":{const T=Math.sqrt(_*_*.25*Math.PI);h=new u(f,a.Zero(),T,T,this._loader.babylonScene);break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${n}: Invalid area light type (${o.type})`)}h._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,o._babylonLight=h,h.falloffType=m.FALLOFF_GLTF,h.diffuse=o.color?y.FromArray(o.color):y.White(),h.intensity=o.intensity==null?1:o.intensity;const p=new M(`${f}_orientation`,this._loader.babylonScene);p.rotationQuaternion=z.RotationAxis(a.Up(),Math.PI),p.parent=l,h.parent=p,this._loader._babylonLights.push(h),E.AddPointerMetadata(h,n),e(l)})))}}B(c);U(c,!0,i=>new v(i));export{v as EXT_lights_area};
