// this is for databricks sql
{
	
	"datepart_translations" : { // case sensitive! will be processed lengthier pattern first (yyyy goes before DD)
		"YYYY" : "yyyy",
		"YY" : "yy",
		"Month":"MMMM",
		"MONTH":"MMMM",
		"month":"MMMM",
		"MON" : "MMM",
		"Mon" : "MMM",
		"mon" : "MMM",
		"WW":"WEEK",
		"ww":"WEEK",
		"DD" : "dd",
        "hh24" : "HH",
		"hh12" : "hh",
		"HH24" : "HH",
		"HH12" : "hh",
		"mi" : "mm",
		"MI" : "mm",
		"Mi" : "mm",
		"(?<!S)SS(?!S)" : "ss",
		"MS'" : "SSS'",
		"US" : "SSSSSS",
		"AM":"a",
		"PM":"a",
		"am":"a",
		"pm":"a",
		"TZH\:TZM":"Z",
		"Day":"EEEE",
		"day":"EEEE",
		"DAY":"EEEE",
		"DY":"EEE",
		"Dy":"EEE",
		"dy":"EEE"
		
	},

	"line_subst" : [
		//datetime formats for date manipulation functions
		{"from" : "\bSYSDATE\b", "to" : "CURRENT_TIMESTAMP"},
		{"from" : "SYSTIMESTAMP", "to" : "CURRENT_TIMESTAMP"},
		{"from" : "SESSSTARTTIME", "to" : "CURRENT_TIMESTAMP"},
		{"from" : "\$\$(\w+)", "to" : "'{$1}'"},
		{"from" : "\bIN\s*\(", "to" : "FUNCTION_IN ("},
		//{"from" : "(.*)\s\|\|\s(.*)\b", "to" : "concat($1,$2)"},
		//casting.  This is tied into converting datatypes for conforming nodes statement category must be specified as DATATYPE_CASTING for BB aws glue writer
		{"from" : "\(nolock\)", "to" : ""},
		{"from" : "numeric\(10\)", "to" : "integer", "statement_categories" : ["DATATYPE_CASTING"]},
		{"from" : "timestamp\(\d+,\d+\)", "to" : "timestamp", "statement_categories" : ["DATATYPE_CASTING"]},
		{"from" : "'\s*,\s*([0-9]+)", "to" : "','$1'"}, // in case we have IN ('a','b',123). dbks will fail casting the numeric into string
		{"from" : "'YYYY([-]?)MM([-]?)DD([ '])", "to" : "'yyyy$1MM$2dd$3", "case_sensitive_match" : "1"},
		{"from" : "'YYYYMM'", "to" : "'yyyyMM'", "case_sensitive_match" : "1"},
		{"from" : "'yyyy([-]?)mm([-]?)dd([ '])", "to" : "'yyyy$1MM$2dd$3", "case_sensitive_match" : "1"},
		{"from" : "([ '])hh24:mi:ss'", "to" : "$1HH:mm:ss'"},
		{"from": "([ '])HH24:MI'", "to" : "$1HH:mm'"},
		{"from": "([ '])MM/DD/YYYY HH:MI:SS AM'", "to" : "$1MM/dd/yyyy HH:mm:SS a'"},
		{"from": "([ '])DD-Mon-YY'", "to" : "$1dd-MM-yy'"},
		{"from" : "'12319999'", "to" : "'9999-12-31'"},
		{"from" : "SESSSTARTTIME", "to" : "(to_timestamp('{starttime}'))"}, // note that 'starttime' is a variable that gets initialized in the header tag
		{"from" : "NOT\s+ISNULL", "to" : "NOT_ISNULL"} //trick into 'creating a function call NOT_ISNULL
		, {"from" : "AT TIME ZONE", "to" : "AT_TZ"}, // convert set of keywords to single token to be treated as operator
		{"from" : "'\$PMRepositoryUserName'", "to" : "current_user()"},
		{"from" : "\$PMRepositoryUserName", "to" : "current_user()"}
	],
	"operator_to_function_subst" : { //converting operators to functions
		"||" : "concat"
		, "AT_TZ" : "AT_TIME_ZONE" // convert fake operator to function call
	},
	"block_subst" : [
		{"from" : "\bCAST\s*(\(.+\s+)AS(\s+\w+\s*\))", "to" : "CAST_COMMA$1,$2"} // convert cast to comma-delimited function for ease of parsing its args
	],
	"function_subst" : [
		{"from" : "FROM_TZ", "full_subst" : "WAS_FROM_TZ, __ARG1__"}, // reduce FROM_TZ function call to a pair of args in its parent function call
		{"from" : "AT_TIME_ZONE", "arg_pattern" : {"1" : "^WAS_FROM_TZ$"}, "output_template" : "from_utc_timestamp($ARGS_AFTER_1ST_ARG)"}, // if first arg to fake func AT_TIME_ZONE was FROM_TZ call, change it to from_utc_timestamp
		{"from" : "CAST_COMMA", "output_template" : "cast($1 AS $2)"}, // return cast to normal format
		{"from" : "FUNCTION_IN", "output_template" : "$1 IN ( $ARGS_AFTER_1ST_ARG )"},
		{"from" : "TO_INTEGER", "output_template" : "cast($1 as int)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'MM'"},"output_template" : "DATE_ADD(MONTH,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'MON'"},"output_template" : "DATE_ADD(MONTH,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'D'"},"output_template" : "DATE_ADD(DAY,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'DD'"},"output_template" : "DATE_ADD(DAY,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'DDD'"},"output_template" : "DATE_ADD(DAY,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'DY'"},"output_template" : "DATE_ADD(DAY,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'HH'"},"output_template" : "DATE_ADD(HOUR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'HH12'"},"output_template" : "DATE_ADD(HOUR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'HH24'"},"output_template" : "DATE_ADD(HOUR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'Y'"},"output_template" : "DATE_ADD(YEAR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'YY'"},"output_template" : "DATE_ADD(YEAR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'YYY'"},"output_template" : "DATE_ADD(YEAR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'YYYY'"},"output_template" : "DATE_ADD(YEAR,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'MI'"},"output_template" : "DATE_ADD(MINUTE,$3,$1)"},
		{"from" : "ADD_TO_DATE", "arg_pattern" : {"2" : "'SS'"},"output_template" : "DATE_ADD(SECOND,$3,$1)"},
		{"from" : "ADD_TO_DATE", "to" : "DATE_ADD", "arg_placement" : { "1":"3", "2":"1" }},
		{"from" : "DATE_DIFF", "output_template" : "DATEDIFF($1, $2)", "arg_pattern" : {"3" : "D"}},
		{"from" : "DATE_DIFF", "output_template" : "MONTHS_BETWEEN($1, $2)", "arg_pattern" : {"3" : "(MM|MON)"}},
		{"from" : "DATE_DIFF", "output_template" : "YEAR($1) - YEAR($2)", "arg_pattern" : {"3" : "Y"}},
		{"from" : "DATE_DIFF", "output_template" : "(unix_timestamp($1) - unix_timestamp($2)) / 60", "arg_pattern" : {"3" : "HH"}},
		{"from" : "IS_SPACES", "output_template" : "TRIM($1) = ''"}, // convert IS_SPACES into a comparison of a trimmed string to blank string
  	{"from" : "TO_DECIMAL", "output_template" : "CAST($1 AS DECIMAL($2))", "num_args": "2"},
    {"from" : "TO_DECIMAL", "output_template" : "CAST($1 AS DECIMAL(38, 4))", "num_args": "1"},
		{"from" : "TO_INTEGER", "to" : "INTEGER"},
		{"from" : "TO_BIGINT", "to" : "BIGINT"},
		{"from" : "LENGTH", "to" : "CHARACTER_LENGTH"},
		{"from" : "LAST", "to" : "LAST_VALUE"},
		{"from" : "FIRST", "to" : "FIRST_VALUE"},
		{"from" : "ERROR", "to" : "RAISE_ERROR"},
		{"from" : "NOT_ISNULL", "output_template" : "$1 IS NOT NULL"},
		{"from" : "ISNULL", "output_template" : "$1 IS NULL"},
		//{"from" : "IIF", "output_template" : "CASE WHEN $1 THEN $2 ELSE $3 END"}, // specify template, instead of swapping arguments or replacing the function call
		{"from" : "IIF", "to" : "IF"},
		{"from" : "IS_DATE", "output_template" : "TO_DATE($1 ,$2) IS NOT NULL", "num_args" : "2"},
		{"from" : "IS_NUMBER", "output_template" : "cast($1 as double) IS NOT NULL"},
		{"from" : "DATE_COMPARE", "output_template" :  "cast(regexp_replace($1, \"-\", \"\") as int) > cast(regexp_replace($2, \"-\", \"\") as int)"},
		{"from" : "MAKE_DATE_TIME", "output_template" :  "cast($1+\"-\"+$2+\"-\"+$3+\" \"+$4+\":\"+$5+\":\"+$6 as timestamp)", "num_args" : "6"},
		{"from" : "MAKE_DATE_TIME", "output_template" :  "cast($1+\"-\"+$2+\"-\"+$3+\" \"+$4+\":\"+$5+\":\"+$6+\".\"+$7 as timestamp)", "num_args" : "7"},
		{"from" : "SETVARIABLE", "output_template" : "SET $1 = $2"},
		{"from" : "REG_REPLACE", "output_template" : "REGEXP_REPLACE($1,$2,$3)","num_args" : "3"},
		{"from" : "REPLACECHR", "output_template" : "REPLACE ( $2,$3,$4 )","arg_pattern" : {"1" : "0"}, "num_args" : "4"},
		{"from" : "REPLACECHR", "output_template" : "REPLACE_MULTISTRING($ARGS_AFTER_1ST_ARG)"}, //convert to a dummy function removing the 1st arg
		{"from" : "REPLACESTR", "output_template" : "REPLACE($2,$3,$4)","arg_pattern" : {"1" : "0"}, "num_args" : "4"},
		{"from" : "REPLACESTR", "output_template" : "REPLACE_MULTISTRING($ARGS_AFTER_1ST_ARG)"}, //convert to a dummy function removing the 1st arg
		{"from" : "REPLACE_MULTISTRING", "output_template" : "REGEXP_REPLACE($1, '(' || $ARGS_AFTER_1ST_ARG_EXCLUDING_LAST_ARG || ')', $LAST_ARG )", "new_arg_separator" : " || '|' ||", "each_arg_routine" : "::escape_regex_arg"},
		{"from" : "REG_MATCH", "output_template" : "$1 RLIKE $2"},
		{"from" : "REG_EXTRACT", "output_template" : "REGEXP_EXTRACT(SUBSTRING($1 FROM $4), $2, $3)"},
		{"from" : "SETMAXVARIABLE", "output_template" : "SET $1 = GREATEST($1, $2)"},
		{"from": "Trunc", "output_template" : "cast($1 AS date)"},
		{"from" : "instr", "num_args" : 3, "output_template" : "locate($2,$1,$3)"},
		{"from" : "instr", "num_args" : 4, "output_template" : "locate($2,$1,$3)"},
		{"from": "SUBSTR", "to" : "SUBSTRING"},
		{"from": "CHRCODE", "to" : "ASCII"},
		{"from": "CONVERT_BASE", "to" : "CONV"},
		{"from": "LN", "to" : "LOG"},
		{"from": "CHOOSE", "output_template" : "CASE WHEN $1 > $2 THEN 1 WHEN $1 < $2 THEN -1 ELSE 0 END "},
		{"from": "DEC_BASE64 ", "output_template" : "CAST(FROM_BASE64($1) AS STRING)"},
		{"from": "ENC_BASE64 ", "output_template" : "TO_BASE64($1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'HH'"},"output_template" : "extract(HOUR from $1_"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'HH12'"},"output_template" : "extract(HOUR from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'HH24'"},"output_template" : "extract(HOUR from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'D'"},"output_template" : "extract(DAY from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'DD'"},"output_template" : "extract(DAY from $1("},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'DDD'"},"output_template" : "extract(DAY from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'DY'"},"output_template" : "extract(DAY from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'DAY'"},"output_template" : "extract(DAY from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'MM'"},"output_template" : "extract(MONTH from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'MON'"},"output_template" : "extract(MONTH from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'MONTH'"},"output_template" : "extract(MONTH from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'Y'"},"output_template" : "extract(YEAR from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'YY'"},"output_template" : "extract(YEAR from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'YYY'"},"output_template" : "extract(YEAR from $1)"},
		{"from" : "GET_DATE_PART", "arg_pattern" : {"2" : "'YYYY'"},"output_template" : "extract(YEAR from $1)"},
		{"from": "LN", "output_template" : "TO_TIMESTAMP(CONCAT($1, '-', $2, '-', $3, ' ', $4, ':', $5, ':', $6), 'yyyy-MM-dd HH:mm:ss')"},
		{"from" : "TO_DATE", "arg_pattern" : {"2" : "(M|D|Y|S|Q|A|P|T|W)"},"output_template" : "TO_TIMESTAMP($1,$2)","date_format_arg" : "2"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "'yyy'"},"output_template" : "substring(DATE_FORMAT($1, 'yyyy'),2)"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "'y'"},"output_template" : "substring(DATE_FORMAT($1, 'yyyy'),4)"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "'w'"},"output_template" : "CEIL(DAY($1) / 7)"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "(M|D|Y|S|Q|A|P|T|W)"},"output_template" : "date_format($1,$2)","date_format_arg" : "2"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "'WW'"},"output_template" : "WEEKOFYEAR($1)"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "'IW'"},"output_template" : "WEEKOFYEAR($1)"},
		{"from" : "TO_CHAR", "arg_pattern" : {"2" : "'W'"},"output_template" : "case when extract(DAY from $1) < 8 then '1' when extract(DAY from $1)< 15 then '2' when extract(DAY from $1) < 22 then '3' when extract(DAY from $1) < 29 then '4'         else '5'        end"}
		//{"from" : "CONCAT", "output_template" : "CONCAT_WS('',$1,$ARGS_AFTER_1ST_ARG_EXCLUDING_LAST_ARG, $LAST_ARG )", "each_arg_routine" : "::convert_concat"} //escape_regex_arg mimic
		//from" : "\$\$(\w+)", "to"	:"{$1}"},
		//{"from" : "\$(\w+)", "to"	:"{$1}"} 
	]
}

// this is a loadable code
/*LOADABLE_CODE
use strict;
# check if the arg is a string and add backslash in front of the chars *()[]
sub main::escape_regex_arg
{
	my $str = shift;
	return $str unless $str =~ /^'.*'$/; #return unless arg is a quote-enclosed string
	$str =~ s/\*/\\\*/gis;
	$str =~ s/\(/\\\(/gis;
	$str =~ s/\)/\\\)/gis;
	$str =~ s/\[/\\\[/gis;
	$str =~ s/\]/\\\]/gis;
	return $str;
}

# check if the arg is a string and add backslash in front of the chars *()[]
sub main::convert_concat
{
	my $arg = shift;
	$arg =~ s/\bCONCAT\b\((.*?)\)/CONCAT_WS(''$1)/gis;
	return $arg;
}

LOADABLE_CODE*/
