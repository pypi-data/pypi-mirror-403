"""Reporting and context generation tools.

Generates executive Markdown summaries and optimized context files for
AI interaction (LLM prompts). Includes Mermaid graph support.
"""

import pathlib
import time
from typing import Dict, Any


def generate_dependency_diagram(dependencies: Dict[str, Any]) -> str:
    """Generates a Mermaid-formatted dependency graph for the top project modules."""
    graph = ["graph TD"]
    import_graph = dependencies.get("import_graph", {})
    if not import_graph:
        return ""

    node_scores = {u: len(v) for u, v in import_graph.items()}
    top_nodes = sorted(node_scores.items(), key=lambda x: x[1], reverse=True)[:20]
    top_node_names = {name for name, _ in top_nodes}

    added_edges = set()
    for u, neighbors in import_graph.items():
        if u in top_node_names or any(v in top_node_names for v in neighbors):
            u_short = u.split("/")[-1].replace(".py", "").replace("__init__", "init")
            for v in neighbors:
                if u == v:
                    continue
                v_short = v.split(".")[-1]
                edge = f"{u_short}->{v_short}"
                if edge not in added_edges:
                    graph.append(f"    {u_short} --> {v_short}")
                    added_edges.add(edge)

    graph.append("    classDef module fill:#f9f,stroke:#333,stroke-width:2px;")
    for name in top_node_names:
        short = name.split("/")[-1].replace(".py", "").replace("__init__", "init")
        graph.append(f"    {short}")
        graph.append(f"    class {short} module;")

    return "\n".join(graph)


class MarkdownBuilder:
    """Helper class for building Markdown documents.

    Maintains a list of lines and provides methods to add sections and headers.
    """

    def __init__(self, title: str):
        """Initialize the builder with a document title.

        Args:
            title: The main title of the document.
        """
        self.lines = [
            f"# {title}",
            f"Analysis Date: {time.strftime('%Y-%m-%d %H:%M:%S')}",
            "Analyzer Version: 2.0 (Ai-Context-Core)",
            "",
        ]

    def add_section(self, title: str, content: str, level: int = 2):
        """Adds a section with a header and content.

        Args:
            title: Section title.
            content: Section markdown content.
            level: Markdown header level (1-6).
        """
        self.lines.append(f"{'#' * level} {title}")
        self.lines.append(content)
        self.lines.append("")

    def build(self) -> str:
        """Constructs the final Markdown document.

        Returns:
            The complete Markdown content as a string.
        """
        return "\n".join(self.lines)


def generate_project_summary(
    analyses: Dict[str, Any],
    output_path: pathlib.Path,
    project_name: str,
    format: str = "markdown",
) -> None:
    """Generates an executive summary of the project."""
    from .summary_generator import SummaryGenerator

    gen = SummaryGenerator(analyses, project_name)
    if format == "html":
        gen.generate_html(output_path)
    else:
        gen.generate_markdown(output_path)


def generate_ai_context(
    analyses: Dict[str, Any], output_path: pathlib.Path, project_name: str
) -> None:
    """Generates an optimized project overview file for AI consumption."""
    gen = AICtxGenerator(analyses, project_name)
    content = gen.build()
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(content)


class AICtxGenerator:
    """Generator for AI Context documents.

    Formats project analysis data into a structured Markdown file optimized
    for LLM consumption.
    """

    def __init__(self, analyses: Dict[str, Any], project_name: str):
        """Initialize the generator.

        Args:
            analyses: Dictionary containing all analysis results.
            project_name: Name of the project.
        """
        self.analyses = analyses
        self.project_name = project_name
        self.lines = [
            f"# AI CONTEXT - {project_name}",
            "Automatically generated by Ai-Context-Core",
            "",
        ]

    def build(self) -> str:
        """Constructs the full AI Context document.

        Returns:
            The complete Markdown content as a string.
        """
        s = self.analyses.get("structure", {})
        c = self.analyses.get("complexity", {})
        m = self.analyses.get("metrics", {})

        self.lines.append("## üìÅ PROJECT STRUCTURE")
        self.lines.append(f"\n{s.get('tree', 'N/A')[:1200]}\n")

        self._add_entry_points()
        self._add_manual_notes()
        self._add_patterns()
        self._add_antipatterns()

        self.lines.append("\n## üìà COMPLEXITY AND METRICS")
        self.lines.append(f"- **Total Modules**: {c.get('total_modules', 0)}")
        self.lines.append(f"- **Source Lines (SLOC)**: {c.get('total_lines', 0):,}")
        self.lines.append(
            f"- **Total Physical Lines**: {c.get('total_physical_lines', 0) or m.get('total_physical_lines', 0):,}"
        )
        self.lines.append(f"- **Functions**: {c.get('total_functions', 0)}")
        self.lines.append(f"- **Classes**: {c.get('total_classes', 0)}")
        self.lines.append(
            f"- **Average Complexity**: {c.get('average_complexity', 0):.1f}"
        )
        self.lines.append(
            f"- **Avg Maintenance Index**: {c.get('avg_maintenance_index', 0) or m.get('avg_maintenance_index', 0):.1f}"
        )

        cm = [m[0] for m in c.get("most_complex_modules", [])[:3]]
        self.lines.append(f"- **Most Complex Modules**: {', '.join(cm)}")

        self._add_dependencies()
        self._add_optimizations()
        self._add_git()

        self.lines.append("\n## üîë PROJECT KEYWORDS")
        ft = list(s.get("file_types", {}).keys())
        self.lines.append(f"- **Technologies**: {', '.join(ft[:8])}")

        return "\n".join(self.lines)

    def _add_entry_points(self):
        """Adds entry points section to the report."""
        ep = self.analyses.get("entry_points", [])
        self.lines.append("## üéØ ENTRY POINTS")
        for p in ep[:10]:
            self.lines.append(f"- `{p}`")
        if len(ep) > 10:
            self.lines.append(f"... and {len(ep) - 10} more")

    def _add_manual_notes(self):
        """Adds manual architecture notes to the report."""
        notes = self.analyses.get("manual_notes", "")
        if notes:
            self.lines.append("\n## üìù MANUAL ARCHITECTURE NOTES")
            self.lines.append(notes)

    def _add_patterns(self):
        """Adds detected patterns section to the report."""
        pats = self.analyses.get("patterns", {})
        self.lines.append("\n## üèóÔ∏è DETECTED PATTERNS")
        if not pats:
            self.lines.append("No clear design patterns detected.")
            return
        for name, occs in pats.items():
            self.lines.append(f"### {name}")
            for o in occs[:3]:
                self.lines.append(
                    f"- **{o.get('class') or o.get('name') or 'N/A'}** in `{o.get('module', 'N/A')}` ({o.get('confidence', 0)}%)"
                )
                for ev in o.get("evidence", []):
                    self.lines.append(f"  - _Evidence: {ev}_")

    def _add_antipatterns(self):
        """Adds detected antipatterns section to the report."""
        ap = self.analyses.get("antipatterns", [])
        if not ap:
            return
        self.lines.append("\n## ‚ö†Ô∏è DETECTED ANTI-PATTERNS")
        for i in ap[:5]:
            self.lines.append(f"- **{i['module']}**")
            for issue in i.get("issues", [])[:2]:
                self.lines.append(f"  - {issue.get('message', 'N/A')}")

    def _add_dependencies(self):
        """Adds dependency analysis and graphs to the report."""
        deps = self.analyses.get("dependencies", {})
        self.lines.append("\n## üîó PRIMARY DEPENDENCIES")
        tp = deps.get("third_party", [])
        if tp:
            counts = {}
            for d in tp:
                base = d.split(".")[0]
                counts[base] = counts.get(base, 0) + 1
            self.lines.append("### Third Party (most frequent):")
            for p, c in sorted(counts.items(), key=lambda x: x[1], reverse=True)[:15]:
                self.lines.append(f"- `{p}` ({c} imports)")

        unused = deps.get("unused_imports", {})
        if unused:
            self.lines.append("\n## ‚ö†Ô∏è UNUSED IMPORTS")
            for mod, items in list(unused.items())[:5]:
                self.lines.append(f"- **{mod}**: {', '.join(items[:5])}")

        high_c = sorted(
            deps.get("coupling_metrics", {}).items(),
            key=lambda x: x[1].get("cbo", 0),
            reverse=True,
        )[:5]
        high_c = [i for i in high_c if i[1].get("cbo", 0) > 5]
        if high_c:
            self.lines.append("\n## üîó HIGH COUPLING MODULES (CBO)")
            for mod, m in high_c:
                self.lines.append(
                    f"- **{mod}**: CBO {m['cbo']} (In: {m['fan_in']}, Out: {m['fan_out']})"
                )

        g_m = deps.get("graph_metrics", {})
        if g_m:
            self.lines.append("\n## üï∏Ô∏è  DEPENDENCY STRUCTURE")
            self.lines.append(
                f"- **Nodes**: {g_m.get('nodes', 0)}\n- **Edges**: {g_m.get('edges', 0)}\n- **Density**: {g_m.get('density', 0):.3f}"
            )
            self.lines.append("\n## üï∏Ô∏è DEPENDENCY DIAGRAM (Conceptual)\n```mermaid")
            self.lines.append(generate_dependency_diagram(deps))
            self.lines.append("```")

    def _add_optimizations(self):
        """Adds optimization recommendations section to the report."""
        opts = self.analyses.get("optimizations", [])
        if not opts:
            return
        self.lines.append("\n## üí° OPTIMIZATION RECOMMENDATIONS")
        for o in opts[:5]:
            self.lines.append(f"### {o.get('module')}")
            for s in o.get("suggestions", [])[:2]:
                self.lines.append(
                    f"- **{s.get('type', 'Opt')}**: {s.get('message', 'N/A')}"
                )

    def _add_git(self):
        """Adds git evolution and hotspots section to the report."""
        git = self.analyses.get("git", {})
        if not git:
            return
        self.lines.append("\n## üîÑ GIT AND EVOLUTION")
        hot = git.get("hotspots", [])
        if hot:
            self.lines.append("### Top Hotspots:")
            for h in hot[:5]:
                self.lines.append(f"- `{h['path']}` ({h['commits']} commits)")

        ch = git.get("churn", {})
        if ch.get("available"):
            self.lines.append(f"### Recent Churn ({ch.get('period_days')} days):")
            self.lines.append(f"- Total lines changed: {ch.get('total_churn')}")
