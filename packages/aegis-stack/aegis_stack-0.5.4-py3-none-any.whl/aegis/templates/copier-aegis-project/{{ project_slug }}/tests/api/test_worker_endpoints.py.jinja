{%- if include_worker %}
"""
Tests for worker API endpoints.

These tests focus on the worker HTTP endpoints that handle task enqueuing,
ensuring TaskRequest model works correctly with task_kwargs field and
validates the API contract.
"""

from collections.abc import AsyncIterator
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from httpx import AsyncClient, ASGITransport

from app.integrations.main import create_integrated_app


class TestWorkerEndpoints:
    """Test worker API endpoints for task enqueuing."""

    @pytest.fixture
    async def async_client(self) -> AsyncIterator[AsyncClient]:
        """Async HTTP client for testing."""
        app = create_integrated_app()

        # Manually trigger startup for health check registration
        from app.components.backend.hooks import backend_hooks
        await backend_hooks.discover_lifespan_hooks()
        await backend_hooks.execute_startup_hooks()

        transport = ASGITransport(app=app)
        async with AsyncClient(
            transport=transport, base_url="http://test"
        ) as client:
            yield client

    @patch("app.components.worker.pools.create_pool")
    async def test_enqueue_task_with_kwargs(self, mock_create_pool, async_client):
        """Test task enqueueing with task_kwargs field."""
        # Clear cache to ensure fresh mock
        from app.components.worker.pools import clear_pool_cache
        await clear_pool_cache()

        # Mock pool and job
        mock_pool = AsyncMock()
        mock_job = MagicMock()
        mock_job.job_id = "test-job-123"
        mock_pool.enqueue_job.return_value = mock_job

        # Mock the get_queue_pool function to return our mocked pool
        mock_create_pool.return_value = mock_pool

        # Test data with task_kwargs
        task_request = {
            "task_name": "cpu_intensive_task",
            "queue_type": "system",
            "args": ["arg1", "arg2"],
            "task_kwargs": {
                "keyword_arg": "value",
                "another_kwarg": 123
            },
            "delay_seconds": None
        }

        # Make the API call
        response = await async_client.post(
            "/api/v1/tasks/enqueue",
            json=task_request
        )

        # Verify response
        assert response.status_code == 200
        response_data = response.json()
        assert response_data["task_id"] == "test-job-123"
        assert response_data["task_name"] == "cpu_intensive_task"
        assert response_data["queue_type"] == "system"

        # Verify that enqueue_job was called with task_kwargs unpacked
        mock_pool.enqueue_job.assert_called_once_with(
            "cpu_intensive_task",
            "arg1",
            "arg2",
            _queue_name="arq:queue:system",
            _defer_by=None,
            keyword_arg="value",
            another_kwarg=123
        )

    @patch("app.components.worker.pools.create_pool")
    async def test_enqueue_task_without_kwargs(self, mock_create_pool, async_client):
        """Test task enqueueing without task_kwargs (empty dict)."""
        # Clear cache to ensure fresh mock
        from app.components.worker.pools import clear_pool_cache
        await clear_pool_cache()

        # Mock pool and job
        mock_pool = AsyncMock()
        mock_job = MagicMock()
        mock_job.job_id = "test-job-456"
        mock_pool.enqueue_job.return_value = mock_job
        mock_create_pool.return_value = mock_pool

        # Test data without task_kwargs (should default to empty dict)
        task_request = {
            "task_name": "io_simulation_task",
            "queue_type": "system",
            "args": [],
        }

        # Make the API call
        response = await async_client.post(
            "/api/v1/tasks/enqueue",
            json=task_request
        )

        # Verify response
        assert response.status_code == 200
        response_data = response.json()
        assert response_data["task_id"] == "test-job-456"

        # Verify enqueue_job called with no extra kwargs
        mock_pool.enqueue_job.assert_called_once_with(
            "io_simulation_task",
            _queue_name="arq:queue:system",
            _defer_by=None
        )

    async def test_enqueue_task_invalid_queue_type(self, async_client):
        """Test error handling for invalid queue type."""
        task_request = {
            "task_name": "cpu_intensive_task",
            "queue_type": "invalid_queue",
            "args": [],
            "task_kwargs": {}
        }

        response = await async_client.post(
            "/api/v1/tasks/enqueue",
            json=task_request
        )

        # Should return 400 for invalid queue type
        assert response.status_code == 400
        response_data = response.json()
        assert "detail" in response_data
        assert response_data["detail"]["error"] == "invalid_queue_type"

    async def test_task_request_model_validation(self, async_client):
        """Test TaskRequest model validation."""
        # Missing required task_name field
        invalid_request = {
            "queue_type": "system",
            "args": [],
            "task_kwargs": {}
        }

        response = await async_client.post(
            "/api/v1/tasks/enqueue",
            json=invalid_request
        )

        # Should return 422 for validation error
        assert response.status_code == 422
{% endif %}