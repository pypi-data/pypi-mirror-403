"""
Component health registration startup hook.

Automatically detects available components and registers their health checks
with the system health service using Python's import system.
"""

import importlib
from pathlib import Path
from typing import Any

from app.components.backend.main import get_configured_app
from app.core.log import logger
from app.services.backend.middleware_inspector import (
    MiddlewareMetadata,
    get_fastapi_middleware_metadata,
)
from app.services.backend.route_inspector import (
    RouteMetadata,
    get_fastapi_route_metadata,
)
from app.services.system.health import register_health_check
from app.services.system.models import ComponentStatus, ComponentStatusType

# Cache for route metadata - initialized once at startup
_cached_route_metadata: RouteMetadata | None = None
# Cache for middleware metadata - initialized once at startup
_cached_middleware_metadata: MiddlewareMetadata | None = None
# Cache for lifecycle metadata - initialized once at startup
_cached_lifecycle_metadata: dict[str, Any] | None = None


def _initialize_route_metadata_cache() -> None:
    """
    Initialize route and middleware metadata caches using the configured FastAPI app.
    Called once during startup to avoid recreating the app on every health check.
    """
    global _cached_route_metadata, _cached_middleware_metadata
    
    if _cached_route_metadata is not None and _cached_middleware_metadata is not None:
        return  # Already initialized
    
    try:
        app = get_configured_app()
        if app is not None:
            # Cache route metadata
            if _cached_route_metadata is None:
                _cached_route_metadata = get_fastapi_route_metadata(app)
                logger.info(
                    f"Route metadata cached: "
                    f"{_cached_route_metadata.total_routes} routes, "
                    f"{_cached_route_metadata.total_endpoints} endpoints"
                )
            
            # Cache middleware metadata
            if _cached_middleware_metadata is None:
                _cached_middleware_metadata = get_fastapi_middleware_metadata(app)
                logger.info(
                    f"Middleware metadata cached: "
                    f"{_cached_middleware_metadata.total_middleware} middleware, "
                    f"{_cached_middleware_metadata.security_count} security layers"
                )
        else:
            logger.warning(
                "FastAPI app not yet configured - route and middleware metadata "
                "cache will be initialized later"
            )
    except Exception as e:
        logger.error(f"Failed to initialize route and middleware metadata cache: {e}")


def _discover_lifecycle_hooks() -> dict[str, Any]:
    """
    Discover startup and shutdown hooks from the backend directories.

    Returns a dict with startup_hooks and shutdown_hooks lists,
    each containing hook info with name and description.
    """
    backend_dir = Path(__file__).parent.parent

    def get_hooks_from_dir(hook_dir: Path) -> list[dict[str, str]]:
        """Get hook info from a directory by importing modules and reading docstrings."""
        hooks = []
        if not hook_dir.exists():
            return hooks

        for hook_file in sorted(hook_dir.glob("*.py")):
            if hook_file.name.startswith("_"):
                continue

            module_name = f"app.components.backend.{hook_dir.name}.{hook_file.stem}"
            try:
                module = importlib.import_module(module_name)
                # Check if it has a startup_hook or shutdown_hook function
                hook_func = getattr(module, "startup_hook", None) or getattr(
                    module, "shutdown_hook", None
                )
                if hook_func:
                    # Get description from function docstring (full text)
                    doc = hook_func.__doc__ or ""
                    description = doc.strip() if doc else f"{hook_file.stem} hook"

                    hooks.append({
                        "name": hook_file.stem,
                        "description": description,
                        "module": module_name,
                    })
            except Exception as e:
                logger.debug(f"Could not load hook module {module_name}: {e}")
                # Still include it as discovered
                hooks.append({
                    "name": hook_file.stem,
                    "description": f"{hook_file.stem} hook",
                    "module": module_name,
                })

        return hooks

    startup_hooks = get_hooks_from_dir(backend_dir / "startup")
    shutdown_hooks = get_hooks_from_dir(backend_dir / "shutdown")

    return {
        "startup_hooks": startup_hooks,
        "shutdown_hooks": shutdown_hooks,
    }


def _initialize_lifecycle_metadata_cache() -> None:
    """Initialize lifecycle metadata cache."""
    global _cached_lifecycle_metadata

    if _cached_lifecycle_metadata is not None:
        return

    try:
        _cached_lifecycle_metadata = _discover_lifecycle_hooks()
        startup_count = len(_cached_lifecycle_metadata.get("startup_hooks", []))
        shutdown_count = len(_cached_lifecycle_metadata.get("shutdown_hooks", []))
        logger.info(
            f"Lifecycle metadata cached: {startup_count} startup hooks, "
            f"{shutdown_count} shutdown hooks"
        )
    except Exception as e:
        logger.error(f"Failed to initialize lifecycle metadata cache: {e}")
        _cached_lifecycle_metadata = {"startup_hooks": [], "shutdown_hooks": []}


async def _backend_component_health() -> ComponentStatus:
    """
    FastAPI backend health check with route and middleware introspection.

    In test environment, reports as healthy since the app is loaded.
    In production, uses internal check to avoid circular dependency.
    Includes comprehensive route and middleware metadata for dashboard display.
    """
    import os
    global _cached_route_metadata, _cached_middleware_metadata, _cached_lifecycle_metadata

    # Check if we're in test environment
    if os.getenv("PYTEST_CURRENT_TEST") or "pytest" in os.getenv("_", ""):
        # Even in test mode, try to get route and middleware information if possible
        try:
            
            # Initialize cache if not already done (might happen in tests)
            if _cached_route_metadata is None or _cached_middleware_metadata is None:
                _initialize_route_metadata_cache()
            
            route_metadata = _cached_route_metadata
            middleware_metadata = _cached_middleware_metadata
            
            # Handle case where metadata is not available in test mode
            if route_metadata is None or middleware_metadata is None:
                return ComponentStatus(
                    name="backend",
                    status=ComponentStatusType.HEALTHY,
                    message="FastAPI backend available (test mode)",
                    response_time_ms=None,
                    metadata={
                        "type": "component_check",
                        "environment": "test",
                        "note": "Backend component loaded successfully",
                        "route_introspection": "unavailable",
                        "middleware_introspection": "unavailable",
                    },
                )
            
            # Create message with both route and middleware info
            message_parts = [f"{route_metadata.total_routes} routes"]
            if middleware_metadata.security_count > 0:
                message_parts.append(
                    f"{middleware_metadata.security_count} security layers"
                )
            
            return ComponentStatus(
                name="backend",
                status=ComponentStatusType.HEALTHY,
                message=(
                    f"FastAPI backend available (test mode): "
                    f"{', '.join(message_parts)}"
                ),
                response_time_ms=None,
                metadata={
                    "type": "component_check",
                    "environment": "test",
                    "note": "Backend component loaded successfully",
                    **route_metadata.model_dump_for_metadata(),
                    **middleware_metadata.model_dump_for_metadata(),
                },
            )
        except Exception as e:
            logger.warning(
                f"Could not get route and middleware metadata in test mode: {e}"
            )
            return ComponentStatus(
                name="backend",
                status=ComponentStatusType.HEALTHY,
                message="FastAPI backend available (test mode)",
                response_time_ms=None,
                metadata={
                    "type": "component_check",
                    "environment": "test",
                    "note": "Backend component loaded successfully",
                    "route_introspection_error": str(e),
                    "middleware_introspection_error": str(e),
                },
            )

    # In production, use cached route and middleware information
    try:
        # Initialize cache if not already done (fallback safety)
        if _cached_route_metadata is None or _cached_middleware_metadata is None:
            logger.warning(
                "Route and middleware metadata cache not initialized at startup, "
                "initializing now..."
            )
            _initialize_route_metadata_cache()
        
        route_metadata = _cached_route_metadata
        middleware_metadata = _cached_middleware_metadata
        
        # Handle case where metadata is still not available
        if route_metadata is None or middleware_metadata is None:
            return ComponentStatus(
                name="backend",
                status=ComponentStatusType.HEALTHY,
                message=(
                    "FastAPI backend active (introspection unavailable)"
                ),
                response_time_ms=None,
                metadata={
                    "type": "internal_component_check",
                    "note": (
                        "Backend is running but route/middleware metadata unavailable"
                    ),
                    "check_method": "internal_execution",
                },
            )
        
        # Create descriptive message based on route and middleware data
        total_routes = route_metadata.total_routes
        total_endpoints = route_metadata.total_endpoints
        method_counts = route_metadata.method_counts
        security_count = middleware_metadata.security_count
        
        # Format method summary (e.g., "12 GET, 5 POST")
        method_summary = ", ".join([
            f"{count} {method}" 
            for method, count in sorted(method_counts.items())
        ])
        
        message_parts = [f"{total_routes} routes"]
        if total_endpoints != total_routes:
            message_parts.append(f"{total_endpoints} endpoints")
        if security_count > 0:
            message_parts.append(f"{security_count} security layers")
        if method_summary:
            message_parts.append(f"({method_summary})")
        
        message = f"FastAPI backend active: {', '.join(message_parts)}"

        # Initialize lifecycle cache if not already done
        if _cached_lifecycle_metadata is None:
            _initialize_lifecycle_metadata_cache()

        # Build lifecycle metadata (default to empty if still None)
        lifecycle_data = _cached_lifecycle_metadata or {
            "startup_hooks": [],
            "shutdown_hooks": [],
        }

        return ComponentStatus(
            name="backend",
            status=ComponentStatusType.HEALTHY,
            message=message,
            response_time_ms=None,
            metadata={
                "type": "internal_component_check",
                "note": (
                    "Backend is running since this health check executed"
                ),
                "check_method": "internal_execution",
                **route_metadata.model_dump_for_metadata(),
                **middleware_metadata.model_dump_for_metadata(),
                "lifecycle": lifecycle_data,
            },
        )
    except Exception as e:
        return ComponentStatus(
            name="backend",
            status=ComponentStatusType.UNHEALTHY,
            message=f"Backend component check failed: {str(e)}",
            response_time_ms=None,
            metadata={
                "type": "internal_component_check",
                "error": "import_or_execution_error",
                "error_details": str(e),
            },
        )


async def _frontend_component_health() -> ComponentStatus:
    """
    Flet frontend health check.

    Since the frontend runs in the same process as the backend,
    we check if the frontend component is properly initialized.
    """
    try:
        # Check if frontend component is available
        from importlib.metadata import version

        from app.components.frontend.main import create_frontend_app

        # Verify the frontend app factory function works
        create_frontend_app()

        # Get Flet version safely
        try:
            flet_version = version("flet")
        except Exception:
            flet_version = "unknown"

        return ComponentStatus(
            name="frontend",
            status=ComponentStatusType.HEALTHY,
            message="Flet frontend component available",
            response_time_ms=None,
            metadata={
                "type": "component_check",
                "framework": "Flet",
                "version": flet_version,
                "note": "Frontend integrated with FastAPI",
            },
        )

    except ImportError as e:
        return ComponentStatus(
            name="frontend",
            status=ComponentStatusType.UNHEALTHY,
            message="Frontend component not found",
            response_time_ms=None,
            metadata={
                "type": "component_check",
                "error": "import_error",
                "error_details": str(e),
            },
        )
    except Exception as e:
        return ComponentStatus(
            name="frontend",
            status=ComponentStatusType.UNHEALTHY,
            message=f"Frontend component error: {str(e)}",
            response_time_ms=None,
            metadata={
                "type": "component_check",
                "error": "unexpected_error",
                "error_details": str(e),
            },
        )

{%- if include_scheduler %}


async def _scheduler_component_health() -> ComponentStatus:
    """
    Check scheduler component health from backend.
{%- if scheduler_backend != "memory" %}

    With persistence: Gets real task data from database
{%- else %}

    Without persistence: Shows component as activated only
{%- endif %}
    """
    {% if scheduler_backend != "memory" %}
    try:
        from app.services.scheduler.task_monitor import TaskHealthMonitor
        monitor = TaskHealthMonitor()
        # No scheduler instance available in backend
        health_data = await monitor.get_health_metadata(None)
        
        # Format message based on task data
        total_tasks = health_data.total_tasks
        if total_tasks > 0:
            message = f"Scheduler running with {total_tasks} tasks"
        else:
            message = "Scheduler running (no tasks)"
        
        return ComponentStatus(
            name="scheduler",
            status=ComponentStatusType.HEALTHY,
            message=message,
            response_time_ms=None,
            metadata=health_data.model_dump(),
        )
    except Exception as e:
        logger.error("Failed to get scheduler health data", error=str(e))
        # Fallback to basic status
        return ComponentStatus(
            name="scheduler",
            status=ComponentStatusType.WARNING,
            message="Scheduler enabled, health data unavailable",
            response_time_ms=None,
            metadata={
                "type": "component_status",
                "error": "health_check_failed",
                "error_details": str(e),
            },
        )
    {% else %}
    return ComponentStatus(
        name="scheduler",
        status=ComponentStatusType.HEALTHY,
        message="Scheduler component activated",
        response_time_ms=None,
        metadata={
            "type": "component_status",
            "deployment": "separate_container",
            "status": "activated",
            "note": "Memory-only mode - no cross-container health monitoring",
        },
    )
    {% endif %}
{%- endif %}


async def startup_hook() -> None:
    """
    Auto-detect available components and register their health checks.

    Always registers core components (backend, frontend) and detects
    optional components using Python's import system.
    """
    logger.info("Registering component health checks...")

    # Initialize caches once at startup
    _initialize_route_metadata_cache()
    _initialize_lifecycle_metadata_cache()

    # Register backend component (includes system metrics - CPU, Memory, Disk)
    # Note: Frontend (Flet) is integrated into the Server card, no separate check needed
    register_health_check("backend", _backend_component_health)
    logger.info("Backend component health check registered")

    {%- if include_scheduler %}
    # Register scheduler component health check
    register_health_check("scheduler", _scheduler_component_health)
    {% if scheduler_backend != "memory" %}
    logger.info("Scheduler component health check registered (with task data)")
    {% else %}
    logger.info("Scheduler component enabled (shows as activated)")
    {% endif %}
    {%- endif %}

    {%- if include_worker %}
    # Register worker health check (shows queue status and job metrics)
    from app.services.system.health import check_worker_health
    register_health_check("worker", check_worker_health)
    logger.info("Worker component health check registered")
    {%- endif %}

    {%- if include_redis %}
    # Register cache health check (Redis connectivity and operations)
    from app.services.system.health import check_cache_health
    register_health_check("cache", check_cache_health)
    logger.info("Cache component health check registered")
    {%- endif %}

    {%- if include_database %}
    # Register database health check
    from app.services.system.health_db import check_database_health
    register_health_check("database", check_database_health)
    logger.info("Database component health check registered")
    {% endif %}

    {%- if ollama_mode != "none" %}
    # Register Ollama health check (local LLM infrastructure)
    from app.services.system.health import check_ollama_health
    register_health_check("ollama", check_ollama_health)
    logger.info("Ollama component health check registered")
    {%- endif %}

    logger.info("Component health detection complete")

    # ==========================================
    # Service Health Checks Registration
    # ==========================================

    from app.services.system.health import register_service_health_check

    logger.info("Registering service health checks...")

    {%- if include_auth %}
    # Register auth service health check
    from app.services.auth.health import check_auth_service_health
    register_service_health_check("auth", check_auth_service_health)
    logger.info("Auth service health check registered")
    {%- endif %}

    {%- if include_ai %}
    # Register AI service health check
    from app.services.ai.health import check_ai_service_health
    register_service_health_check("ai", check_ai_service_health)
    logger.info("AI service health check registered")
    {%- endif %}

    {%- if include_comms %}
    # Register comms service health check
    from app.services.comms.health import check_comms_service_health
    register_service_health_check("comms", check_comms_service_health)
    logger.info("Comms service health check registered")
    {%- endif %}

    # Future services will be registered here:
    # Example:
    #     from app.services.payment.health import check_payment_service_health
    #     register_service_health_check("payment", check_payment_service_health)

    logger.info("Service health detection complete")
