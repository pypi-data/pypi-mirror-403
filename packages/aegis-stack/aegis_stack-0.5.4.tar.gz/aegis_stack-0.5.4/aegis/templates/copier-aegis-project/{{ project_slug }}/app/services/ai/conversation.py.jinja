"""
AI conversation management.

{% if ai_backend == "memory" %}
In-memory conversation storage and management for AI chat sessions.
This provides conversation persistence during application runtime.
{% else %}
SQLite-based conversation storage and management for AI chat sessions.
Provides persistent conversation history across application restarts.
{% endif %}
"""

import uuid
from datetime import UTC, datetime
from typing import Any

from app.core.log import logger

{% if ai_backend != "memory" %}
from sqlmodel import select

from app.core.db import db_session, init_database
from app.models.conversation import Conversation as ConversationModel
from app.models.conversation import ConversationMessage as MessageModel
{% endif %}

from .models import AIProvider, Conversation, ConversationMessage, MessageRole


class ConversationManager:
    """
{% if ai_backend == "memory" %}
    Manages AI conversations in memory.

    This is a simple in-memory implementation. In production, you might want
    to use a database or external storage for persistence across restarts.
{% else %}
    Manages AI conversations with SQLite persistence.

    Stores conversations in the project database using SQLModel tables.
    Provides persistence across application restarts.
{% endif %}
    """

    def __init__(self) -> None:
        """Initialize conversation manager."""
{% if ai_backend == "memory" %}
        self.conversations: dict[str, Conversation] = {}
{% else %}
        # Ensure database is initialized (creates tables if missing)
        # This allows CLI commands (like 'ai chat') to work without starting the server
        init_database()
{% endif %}

    def create_conversation(
        self,
        provider: AIProvider,
        model: str,
        user_id: str = "default",
        conversation_id: str | None = None,
    ) -> Conversation:
        """
        Create a new conversation.

        Args:
            provider: AI provider being used
            model: Model name
            user_id: User identifier
            conversation_id: Optional custom conversation ID

        Returns:
            Conversation: The created conversation
        """
        if conversation_id is None:
            conversation_id = str(uuid.uuid4())

        conversation = Conversation(
            id=conversation_id,
            provider=provider,
            model=model,
            metadata={"user_id": user_id, "created_by": "ai_service"},
        )

{% if ai_backend == "memory" %}
        self.conversations[conversation_id] = conversation
{% else %}
        # Save to database
        self._save_to_db(conversation)
{% endif %}

        return conversation

    def get_conversation(self, conversation_id: str) -> Conversation | None:
        """
        Get a conversation by ID.

        Args:
            conversation_id: The conversation identifier

        Returns:
            Conversation | None: The conversation if found, None otherwise
        """
{% if ai_backend == "memory" %}
        return self.conversations.get(conversation_id)
{% else %}
        with db_session() as session:
            conv_db = session.get(ConversationModel, conversation_id)
            if not conv_db:
                return None

            # Load messages
            stmt = select(MessageModel).where(
                MessageModel.conversation_id == conversation_id
            ).order_by(MessageModel.timestamp)
            messages_db = session.exec(stmt).all()

            # Convert to Pydantic models
            messages = [
                ConversationMessage(
                    id=msg.id,
                    role=MessageRole(msg.role),
                    content=msg.content,
                    timestamp=msg.timestamp,
                    metadata=msg.meta_data or {},
                )
                for msg in messages_db
            ]

            # Get provider/model from meta_data
            meta_data = conv_db.meta_data or {}

            return Conversation(
                id=conv_db.id,
                title=conv_db.title,
                provider=AIProvider(meta_data.get("provider", "openai")),
                model=meta_data.get("model", "unknown"),
                created_at=conv_db.created_at,
                updated_at=conv_db.updated_at,
                messages=messages,
                metadata=meta_data,
            )
{% endif %}

    def save_conversation(self, conversation: Conversation) -> None:
        """
        Save a conversation (update in storage).

        Args:
            conversation: The conversation to save
        """
        conversation.updated_at = datetime.now(UTC)
{% if ai_backend == "memory" %}
        self.conversations[conversation.id] = conversation
{% else %}
        self._save_to_db(conversation)
{% endif %}

    def list_conversations(self, user_id: str | None = None) -> list[Conversation]:
        """
        List conversations, optionally filtered by user.

        Args:
            user_id: Optional user ID to filter by

        Returns:
            list[Conversation]: List of conversations
        """
{% if ai_backend == "memory" %}
        conversations = list(self.conversations.values())

        if user_id:
            conversations = [
                conv
                for conv in conversations
                if conv.metadata.get("user_id") == user_id
            ]

        # Sort by most recent activity
        conversations.sort(key=lambda c: c.updated_at, reverse=True)
        return conversations
{% else %}
        with db_session() as session:
            stmt = select(ConversationModel).order_by(
                ConversationModel.updated_at.desc()
            )
            all_convs = session.exec(stmt).all()

            conversations = []
            for conv_db in all_convs:
                meta_data = conv_db.meta_data or {}

                # Filter by user_id if specified
                if user_id and meta_data.get("user_id") != user_id:
                    continue

                # Load messages for this conversation
                msg_stmt = select(MessageModel).where(
                    MessageModel.conversation_id == conv_db.id
                ).order_by(MessageModel.timestamp)
                messages_db = session.exec(msg_stmt).all()

                messages = [
                    ConversationMessage(
                        id=msg.id,
                        role=MessageRole(msg.role),
                        content=msg.content,
                        timestamp=msg.timestamp,
                        metadata=msg.meta_data or {},
                    )
                    for msg in messages_db
                ]

                conversations.append(Conversation(
                    id=conv_db.id,
                    title=conv_db.title,
                    provider=AIProvider(meta_data.get("provider", "openai")),
                    model=meta_data.get("model", "unknown"),
                    created_at=conv_db.created_at,
                    updated_at=conv_db.updated_at,
                    messages=messages,
                    metadata=meta_data,
                ))

            return conversations
{% endif %}

    def delete_conversation(self, conversation_id: str) -> bool:
        """
        Delete a conversation.

        Args:
            conversation_id: The conversation identifier

        Returns:
            bool: True if conversation was deleted, False if not found
        """
{% if ai_backend == "memory" %}
        if conversation_id in self.conversations:
            del self.conversations[conversation_id]
            return True
        return False
{% else %}
        with db_session() as session:
            conv_db = session.get(ConversationModel, conversation_id)
            if not conv_db:
                return False

            # Delete messages first
            stmt = select(MessageModel).where(
                MessageModel.conversation_id == conversation_id
            )
            messages = session.exec(stmt).all()
            for msg in messages:
                session.delete(msg)

            # Delete conversation
            session.delete(conv_db)
            session.commit()

            return True
{% endif %}

    def get_conversation_count(self, user_id: str | None = None) -> int:
        """
        Get count of conversations.

        Args:
            user_id: Optional user ID to filter by

        Returns:
            int: Number of conversations
        """
{% if ai_backend == "memory" %}
        if user_id:
            return len(
                [
                    conv
                    for conv in self.conversations.values()
                    if conv.metadata.get("user_id") == user_id
                ]
            )
        return len(self.conversations)
{% else %}
        return len(self.list_conversations(user_id))
{% endif %}

    def get_recent_conversations(
        self, limit: int = 10, user_id: str | None = None
    ) -> list[Conversation]:
        """
        Get recent conversations.

        Args:
            limit: Maximum number of conversations to return
            user_id: Optional user ID to filter by

        Returns:
            list[Conversation]: Recent conversations
        """
        conversations = self.list_conversations(user_id)
        return conversations[:limit]

    def cleanup_old_conversations(self, max_age_hours: int = 24) -> int:
        """
        Clean up old conversations.

        Args:
            max_age_hours: Maximum age in hours before cleanup

        Returns:
            int: Number of conversations cleaned up
        """
        cutoff_time = datetime.now(UTC).timestamp() - (max_age_hours * 3600)
{% if ai_backend == "memory" %}
        to_delete = []

        for conv_id, conversation in self.conversations.items():
            if conversation.updated_at.timestamp() < cutoff_time:
                to_delete.append(conv_id)

        for conv_id in to_delete:
            del self.conversations[conv_id]

        if to_delete:
            logger.info(f"Cleaned up {len(to_delete)} old conversations")

        return len(to_delete)
{% else %}
        deleted_count = 0

        with db_session() as session:
            stmt = select(ConversationModel)
            all_convs = session.exec(stmt).all()

            for conv in all_convs:
                if conv.updated_at.timestamp() < cutoff_time:
                    # Delete messages
                    msg_stmt = select(MessageModel).where(
                        MessageModel.conversation_id == conv.id
                    )
                    messages = session.exec(msg_stmt).all()
                    for msg in messages:
                        session.delete(msg)

                    # Delete conversation
                    session.delete(conv)
                    deleted_count += 1

            session.commit()

        if deleted_count > 0:
            logger.info(f"Cleaned up {deleted_count} old conversations")

        return deleted_count
{% endif %}

    def get_stats(self) -> dict[str, Any]:
        """
        Get conversation manager statistics.

        Returns:
            dict: Statistics about conversations
        """
{% if ai_backend == "memory" %}
        total_conversations = len(self.conversations)
        total_messages = sum(
            conv.get_message_count() for conv in self.conversations.values()
        )

        # Get user breakdown
        users = set()
        for conv in self.conversations.values():
            user_id = conv.metadata.get("user_id")
            if user_id:
                users.add(user_id)

        return {
            "total_conversations": total_conversations,
            "total_messages": total_messages,
            "unique_users": len(users),
            "average_messages_per_conversation": (
                total_messages / total_conversations if total_conversations > 0 else 0
            ),
        }
{% else %}
        with db_session() as session:
            # Count conversations
            conv_stmt = select(ConversationModel)
            all_convs = session.exec(conv_stmt).all()
            total_conversations = len(all_convs)

            # Count messages
            msg_stmt = select(MessageModel)
            all_msgs = session.exec(msg_stmt).all()
            total_messages = len(all_msgs)

            # Get unique users
            users = set()
            for conv in all_convs:
                meta_data = conv.meta_data or {}
                user_id = meta_data.get("user_id")
                if user_id:
                    users.add(user_id)

            return {
                "total_conversations": total_conversations,
                "total_messages": total_messages,
                "unique_users": len(users),
                "average_messages_per_conversation": (
                    total_messages / total_conversations if total_conversations > 0 else 0
                ),
            }
{% endif %}

{% if ai_backend != "memory" %}
    def _save_to_db(self, conversation: Conversation) -> None:
        """Save conversation and its messages to database."""
        with db_session() as session:
            # Build meta_data with provider/model included
            meta_data = {
                **conversation.metadata,
                "provider": conversation.provider.value,
                "model": conversation.model,
            }

            # Check if conversation exists
            conv_db = session.get(ConversationModel, conversation.id)
            if conv_db:
                # Update existing
                conv_db.title = conversation.title
                conv_db.updated_at = conversation.updated_at
                conv_db.meta_data = meta_data
            else:
                # Create new
                conv_db = ConversationModel(
                    id=conversation.id,
                    title=conversation.title,
                    user_id=conversation.metadata.get("user_id", "default"),
                    created_at=conversation.created_at,
                    updated_at=conversation.updated_at,
                    meta_data=meta_data,
                )
                session.add(conv_db)

            # Save messages
            for message in conversation.messages:
                msg_db = session.get(MessageModel, message.id)
                if not msg_db:
                    msg_db = MessageModel(
                        id=message.id,
                        conversation_id=conversation.id,
                        role=message.role.value,
                        content=message.content,
                        timestamp=message.timestamp,
                        meta_data=message.metadata,
                    )
                    session.add(msg_db)

            session.commit()
{% endif %}
