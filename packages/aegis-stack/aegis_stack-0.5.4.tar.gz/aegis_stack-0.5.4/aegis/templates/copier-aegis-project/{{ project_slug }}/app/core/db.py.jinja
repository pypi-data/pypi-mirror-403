# app/core/db.py
"""
Database configuration and session management.

This module provides {% if database_engine == "postgres" %}PostgreSQL{% else %}SQLite{% endif %} database connectivity using SQLModel and SQLAlchemy.
Includes proper session management with transaction handling{% if database_engine == "sqlite" %} and foreign key support{% endif %}.
"""

from collections.abc import AsyncGenerator, Generator
from contextlib import asynccontextmanager, contextmanager
{% if database_engine == "sqlite" %}
from pathlib import Path
{% endif %}
from typing import Any
{% if database_engine == "sqlite" %}
from urllib.parse import urlparse
{% endif %}

from sqlalchemy import create_engine{% if database_engine == "sqlite" %}, event{% endif %}

from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine
{% if database_engine == "sqlite" %}
from sqlalchemy.pool import NullPool
{% endif %}
from sqlalchemy.orm import sessionmaker
from sqlmodel import Session, SQLModel
from sqlmodel.ext.asyncio.session import AsyncSession

from app.core.config import settings
from app.core.log import logger

{% if database_engine == "sqlite" %}
# Extract database file path from URL for backup operations
def _extract_database_path(database_url: str) -> str:
    """Extract the file path from a SQLite database URL."""
    parsed = urlparse(database_url)
    if parsed.scheme == "sqlite":
        # Handle both sqlite:/// and sqlite:// formats
        path = parsed.path
        if path.startswith("/") and len(parsed.netloc) == 0:
            # sqlite:///./path/file.db -> ./path/file.db
            return path[1:]
        elif parsed.netloc == "" and not path.startswith("/"):
            # sqlite://./path/file.db -> ./path/file.db
            return path
        else:
            # sqlite:///absolute/path/file.db -> /absolute/path/file.db
            return path
    else:
        raise ValueError(f"Unsupported database URL scheme: {parsed.scheme}")

DATABASE_PATH = _extract_database_path(settings.DATABASE_URL)
{% endif %}

{% if database_engine == "sqlite" %}
# Create SQLite engine with proper configuration (sync)
# NullPool disables connection pooling - each query gets a fresh connection
# This ensures the server sees changes made by external processes (e.g., CLI)
engine = create_engine(
    settings.DATABASE_URL,
    connect_args=settings.DATABASE_CONNECT_ARGS,
    echo=settings.DATABASE_ENGINE_ECHO,
    poolclass=NullPool,
)
{% else %}
# Create PostgreSQL engine with proper configuration (sync)
engine = create_engine(
    settings.database_url_effective,
    echo=settings.DATABASE_ENGINE_ECHO,
)
{% endif %}

# Create async engine for non-blocking operations
def _get_async_database_url(database_url: str) -> str:
    """Convert sync database URL to async version."""
{% if database_engine == "sqlite" %}
    if database_url.startswith("sqlite:///"):
        return database_url.replace("sqlite:///", "sqlite+aiosqlite:///")
    elif database_url.startswith("sqlite://"):
        return database_url.replace("sqlite://", "sqlite+aiosqlite://")
{% else %}
    if database_url.startswith("postgresql://"):
        return database_url.replace("postgresql://", "postgresql+asyncpg://")
{% endif %}
    # For other database types, return as-is and let SQLAlchemy handle it
    return database_url

{% if database_engine == "sqlite" %}
async_engine = create_async_engine(
    _get_async_database_url(settings.DATABASE_URL),
    echo=settings.DATABASE_ENGINE_ECHO,
    poolclass=NullPool,
    connect_args=settings.DATABASE_CONNECT_ARGS,
)


# Enable foreign key constraints for SQLite
@event.listens_for(engine, "connect")
def set_sqlite_pragma(dbapi_connection: Any, connection_record: Any) -> None:
    """Enable foreign key constraints in SQLite."""
    cursor = dbapi_connection.cursor()
    cursor.execute("PRAGMA foreign_keys=ON")
    cursor.close()
{% else %}
async_engine = create_async_engine(
    _get_async_database_url(settings.database_url_effective),
    echo=settings.DATABASE_ENGINE_ECHO,
)
{% endif %}


# Configure session factory with SQLModel Session (sync)
SessionLocal = sessionmaker(
    class_=Session, bind=engine, autoflush=False, autocommit=False
)

# Configure async session factory using SQLModel's AsyncSession
AsyncSessionLocal = async_sessionmaker(
    async_engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


@contextmanager
def db_session(autocommit: bool = True) -> Generator[Session, None, None]:
    """
    Database session context manager with automatic transaction handling.

    Args:
        autocommit: Whether to automatically commit the transaction on success

    Yields:
        Session: Database session instance

    Example:
        with db_session() as session:
            # Your database operations here
            result = session.query(MyModel).first()
    """
    db_session: Session = SessionLocal()
    try:
        yield db_session
        if autocommit:
            db_session.commit()
    except Exception:
        db_session.rollback()
        raise
    finally:
        db_session.close()


@asynccontextmanager
async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    """
    Async database session context manager with automatic transaction handling.

    Yields:
        AsyncSession: Async database session instance

    Example:
        async with get_async_session() as session:
            # Your async database operations here
            result = await session.exec(select(MyModel))
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise


def init_database() -> None:
    """
    Initialize the database{% if database_engine == "sqlite" %} by creating tables and ensuring directory structure{% else %} (no-op for postgres - use migrations){% endif %}.
{% if database_engine == "sqlite" %}

    This function:
    1. Creates the database directory if it doesn't exist
    2. Creates all tables defined by SQLModel models
    3. Logs the initialization status
{% else %}

    For PostgreSQL, this is a no-op. Use Alembic migrations to create/modify tables.
    This function exists for SQLite compatibility where CLI commands need tables
    to exist without running migrations.
{% endif %}
    """
{% if database_engine == "sqlite" %}
    try:
        # Ensure database directory exists
        db_path = Path(DATABASE_PATH)
        db_path.parent.mkdir(parents=True, exist_ok=True)

        # Create all tables
        SQLModel.metadata.create_all(engine)

        if db_path.exists():
            logger.info(f"Database initialized: {DATABASE_PATH}")
        else:
            logger.info(f"Database will be created on first use: {DATABASE_PATH}")

    except Exception as e:
        logger.error(f"Database initialization failed: {e}")
        raise
{% else %}
    # PostgreSQL uses Alembic migrations - create_all() would conflict
    # This no-op exists so code calling init_database() still works
    pass
{% endif %}
