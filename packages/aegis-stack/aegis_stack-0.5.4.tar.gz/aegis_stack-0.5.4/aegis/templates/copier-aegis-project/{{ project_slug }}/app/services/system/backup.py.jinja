"""
Database backup service for {{ project_name }}.

Provides database backup functionality for scheduled backup jobs.
Included when scheduler and database components are both present.
"""
{% if scheduler_backend != "memory" or (include_scheduler and include_database) %}

import asyncio
{% if database_engine == "sqlite" %}
import shutil
{% else %}
import subprocess
{% endif %}
from datetime import datetime
from pathlib import Path

{% if database_engine == "sqlite" %}
from app.core.db import DATABASE_PATH
{% else %}
from app.core.config import settings
{% endif %}
from app.core.log import logger

# Backup file naming pattern
{% if database_engine == "sqlite" %}
BACKUP_FILE_PATTERN = "database_backup_*.db"
BACKUP_FILE_PREFIX = "database_backup_"
{% else %}
BACKUP_FILE_PATTERN = "database_backup_*.sql"
BACKUP_FILE_PREFIX = "database_backup_"
{% endif %}


async def backup_database_job() -> None:
    """
    Scheduled database backup job.

{% if database_engine == "sqlite" %}
    Creates a backup of the SQLite database file with timestamp.
{% else %}
    Creates a backup of the PostgreSQL database using pg_dump.
{% endif %}
    Keeps the last 7 daily backups to prevent disk space issues.
    """
    try:
        # Ensure backup directory exists
        backup_dir = Path("backups")
        backup_dir.mkdir(exist_ok=True)

        # Create timestamped backup filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
{% if database_engine == "sqlite" %}
        backup_filename = f"{BACKUP_FILE_PREFIX}{timestamp}.db"
        backup_path = backup_dir / backup_filename

        # Copy database file
        if Path(DATABASE_PATH).exists():
            shutil.copy2(DATABASE_PATH, backup_path)
            logger.info(f"Database backup created: {backup_path}")
        else:
            logger.warning(f"Database file not found for backup: {DATABASE_PATH}")
{% else %}
        backup_filename = f"{BACKUP_FILE_PREFIX}{timestamp}.sql"
        backup_path = backup_dir / backup_filename

        # Run pg_dump to create backup
        result = subprocess.run(
            ["pg_dump", settings.database_url_effective, "-f", str(backup_path)],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            logger.info(f"Database backup created: {backup_path}")
        else:
            logger.error(f"pg_dump failed: {result.stderr}")
{% endif %}

        # Clean up old backups (keep last 7) - always run regardless of backup success
        await _cleanup_old_backups(backup_dir)

    except Exception as e:
        logger.error(f"Database backup failed: {e}")


async def _cleanup_old_backups(backup_dir: Path, keep_count: int = 7) -> None:
    """
    Remove old backup files, keeping only the most recent ones.

    Args:
        backup_dir: Directory containing backup files
        keep_count: Number of recent backups to keep
    """
    try:
        # Get all backup files sorted by modification time (newest first)
        backup_files = [
            f for f in backup_dir.glob(BACKUP_FILE_PATTERN)
            if f.is_file()
        ]
        backup_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)

        # Remove old backups beyond keep_count
        old_backups = backup_files[keep_count:]
        for old_backup in old_backups:
            old_backup.unlink()
            logger.info(f"Removed old backup: {old_backup.name}")

        if old_backups:
            kept_count = min(len(backup_files), keep_count)
            logger.info(
                f"Cleaned up {len(old_backups)} old backups, kept {kept_count}"
            )

    except Exception as e:
        logger.error(f"Backup cleanup failed: {e}")


async def restore_database_from_backup(backup_filename: str) -> bool:
    """
    Restore database from a backup file.

    Args:
        backup_filename: Name of the backup file to restore from

    Returns:
        True if restore was successful, False otherwise
    """
    try:
        backup_dir = Path("backups")
        backup_path = backup_dir / backup_filename

        if not backup_path.exists():
            logger.error(f"Backup file not found: {backup_path}")
            return False

{% if database_engine == "sqlite" %}
        # Create backup of current database before restore
        current_db = Path(DATABASE_PATH)
        if current_db.exists():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            current_backup = backup_dir / f"pre_restore_backup_{timestamp}.db"
            shutil.copy2(current_db, current_backup)
            logger.info(f"Created pre-restore backup: {current_backup}")

        # Restore from backup
        shutil.copy2(backup_path, DATABASE_PATH)
        logger.info(f"Database restored from backup: {backup_filename}")
        return True
{% else %}
        # Create backup before restore
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        pre_restore_path = backup_dir / f"pre_restore_backup_{timestamp}.sql"
        pre_result = subprocess.run(
            ["pg_dump", settings.database_url_effective, "-f", str(pre_restore_path)],
            capture_output=True,
            text=True,
        )
        if pre_result.returncode == 0:
            logger.info(f"Created pre-restore backup: {pre_restore_path}")

        # Restore from backup using psql
        result = subprocess.run(
            ["psql", settings.database_url_effective, "-f", str(backup_path)],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            logger.info(f"Database restored from backup: {backup_filename}")
            return True
        else:
            logger.error(f"psql restore failed: {result.stderr}")
            return False
{% endif %}

    except Exception as e:
        logger.error(f"Database restore failed: {e}")
        return False
{% endif %}