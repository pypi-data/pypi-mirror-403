from __future__ import annotations

import json
from typing import Self, TYPE_CHECKING

from .models import Coordinate
from .utils import is_valid_fence

if TYPE_CHECKING:
    import os
    from .hull import AbstractHull
    from .models import RotatedPolycube, JSON_SOLUTION, SNAPSHOT

__all__ = ("Grid", "HullGrid")


class Grid:
    def __init__(self, size: Coordinate, offset: Coordinate = Coordinate(0, 0, 0)) -> None:
        """Creates a cuboid grid with the given size and offset."""
        self._size = size
        self._offset = offset
        self._offset_size = size + offset
        self._cells: dict[Coordinate, int] = {}
        """Grid cells, mapping coordinates to polycube ids."""

    def __contains__(self, item: object) -> bool:
        return item in self._cells

    @property
    def size(self) -> Coordinate:
        return self._size

    @property
    def offset(self) -> Coordinate:
        return self._offset

    def in_bounds(self, pos: Coordinate) -> bool:
        """Checks if the given coordinate is within the grid bounds."""
        offset, offset_size = self._offset, self._offset_size
        px, py, pz = pos.x, pos.y, pos.z
        return offset.x <= px < offset_size.x and offset.y <= py < offset_size.y and offset.z <= pz < offset_size.z

    def place(self, polycube: RotatedPolycube, offset: Coordinate) -> None:
        """Places the polycube at the given offset.
        Assumes that the polycube can be placed, use can_place to check beforehand!
        """
        cells = self._cells
        for coord in polycube.coords:
            cells[coord + offset] = polycube.id

    def can_place(self, polycube: RotatedPolycube, offset: Coordinate) -> bool:
        """Checks if the polycube can be placed at the given offset, or more precisely,
        if every cell it would occupy is empty and in bounds.
        """
        cells, in_bounds = self._cells, self.in_bounds
        for coord in polycube.coords:
            coord += offset
            if coord in cells or not in_bounds(coord):
                return False
        return True

    def to_json(self, filename: str | os.PathLike[str] | None = None) -> JSON_SOLUTION:
        """Exports the current grid into the JSON format, returns it, and writes it to a file if specified."""
        output: JSON_SOLUTION = [[self.size.x, self.size.y, self.size.z]]
        output.extend([[_id, coord.x, coord.y, coord.z] for coord, _id in self._cells.items()])

        if filename is not None:
            with open(filename, "w") as f:
                json.dump(output, f, indent=2)

        return output

    def format(self) -> str:
        """Exports the current grid into a human-readable format."""

        raise NotImplementedError

    def merge(self, other: Grid) -> None:
        """Copies all cubes from another grid into this one, according to the offset of the grids."""

        raise NotImplementedError

    def validate(self) -> bool:
        """Checks if there is a valid polycube fence in the grid."""
        return is_valid_fence(set(self._cells.keys()))

    @classmethod
    def from_snapshot(cls, snapshot: SNAPSHOT) -> Self:
        """Reconstructs a grid from a snapshot and a hull.
        Snapshot must have been generated by to_snapshot().
        """
        size = Coordinate.from_tuple(snapshot["size"])
        offset = Coordinate.from_tuple(snapshot["offset"])
        cells = {Coordinate.from_tuple(t): i for t, i in snapshot["cells"].items()}

        self = cls(size, offset)
        self._cells = cells
        return self

    def to_snapshot(self) -> SNAPSHOT:
        """Retrieves a pickable snapshot of the grid, reconstructible with from_snapshot()"""
        return {
            "size": self._size.to_tuple(),
            "offset": self._offset.to_tuple(),
            "cells": {c.to_tuple(): i for c, i in self._cells.items()},
        }


class HullGrid[H: AbstractHull](Grid):
    def __init__(self, size: Coordinate, hull: H, offset: Coordinate = Coordinate(0, 0, 0)) -> None:
        """Creates a Grid that contains a hull and allows certain operations on it."""
        super().__init__(size, offset)
        self._hull = hull
        self._active_frontier: set[Coordinate] = set()

    def place(self, polycube: RotatedPolycube, offset: Coordinate) -> None:
        super().place(polycube, offset)
        self._hull.update_frontier(polycube, offset)
        self._update_active_frontier(polycube, offset)

    @property
    def hull(self) -> H:
        """Direct access to the hull, prefer using the proxied methods when possible:
        frontier, active_frontier, in_hull, in_inner_part
        """
        return self._hull

    @property
    def frontier(self) -> frozenset[Coordinate]:
        """Returns a frozen view of the current frontier coordinates."""
        return frozenset(self._hull.frontier)

    @property
    def active_frontier(self) -> frozenset[Coordinate]:
        """Returns a frozen view of the current active frontier coordinates."""
        return frozenset(self._active_frontier)

    @active_frontier.setter
    def active_frontier(self, value: set[Coordinate]) -> None:
        """Sets the active frontier coordinates. Only use this if you know what you're doing"""
        self._active_frontier = value

    def _update_active_frontier(self, polycube: RotatedPolycube, offset: Coordinate) -> None:
        """Remove the coordinates of the polycube at the offset from the frontier, if present."""
        placed_points = [point + offset for point in polycube.coords]
        placed_points_neighbors = [point + offset for point in polycube.get_all_neighbor_cells()]

        for placed_point in placed_points:
            if placed_point not in self._active_frontier:
                continue

            self._active_frontier.remove(placed_point)

        for point in placed_points_neighbors:
            if point in self._cells or point not in self._hull.frontier:
                continue

            self._active_frontier.add(point)

    def in_hull(self, pos: Coordinate) -> bool:
        """Checks if the given coordinate is inside the hull."""
        return self._hull.in_hull(pos)

    def in_inner_part(self, pos: Coordinate) -> bool:
        """Checks if the given coordinate is inside the inner part of the hull."""
        return self._hull.in_inner_part(pos)

    @classmethod
    def from_snapshot(cls, snapshot: SNAPSHOT, hull: H | None = None) -> Self:
        """Reconstructs a grid from a snapshot and a hull.
        Snapshot must have been generated by to_snapshot().
        """
        if hull is None:
            raise ValueError("Hull must be provided when reconstructing a HullGrid from a snapshot.")

        size = Coordinate.from_tuple(snapshot["size"])
        offset = Coordinate.from_tuple(snapshot["offset"])
        cells = {Coordinate.from_tuple(t): i for t, i in snapshot["cells"].items()}
        active_frontier = {Coordinate.from_tuple(t) for t in snapshot["active_frontier"]}

        self = cls(size, hull, offset)
        self._cells = cells
        self._active_frontier = active_frontier
        return self

    def to_snapshot(self) -> SNAPSHOT:
        """Retrieves a pickable snapshot of the grid, reconstructible with from_snapshot()
        Note: You have to serialize the hull separately, use Hull.to_snapshot and Hull.from_snapshot.
        """
        snapshot = super().to_snapshot()
        snapshot["active_frontier"] = tuple(c.to_tuple() for c in self._active_frontier)
        return snapshot
