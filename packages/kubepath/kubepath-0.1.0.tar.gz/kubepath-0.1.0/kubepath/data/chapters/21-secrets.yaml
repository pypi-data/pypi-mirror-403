chapter:
  number: 21
  title: "Secrets"
  description: "Securely store and use sensitive data like passwords and API keys"

concepts:
  - title: "What are Secrets?"
    content: |
      **Secrets** are like ConfigMaps, but for sensitive data.

      **The Safe vs Bulletin Board Analogy**

      - **ConfigMap** = Office bulletin board (everyone can see)
      - **Secret** = Locked safe (only authorized access)

      Both store data, but Secrets have extra protections.

      **What Makes Secrets Different:**

      ```
      ┌─────────────────────────────────────────────────────────────┐
      │               ConfigMap vs Secret                           │
      │                                                             │
      │   ConfigMap:                                                │
      │   ┌─────────────────────────────────────────────┐          │
      │   │ data:                                        │          │
      │   │   LOG_LEVEL: debug     ← Plain text         │          │
      │   │   MAX_CONN: "100"                            │          │
      │   └─────────────────────────────────────────────┘          │
      │                                                             │
      │   Secret:                                                   │
      │   ┌─────────────────────────────────────────────┐          │
      │   │ data:                                        │          │
      │   │   password: cGFzc3dvcmQ=  ← Base64 encoded  │          │
      │   │   api-key: YWJjMTIz                          │          │
      │   └─────────────────────────────────────────────┘          │
      │                                                             │
      │   Additional protections:                                   │
      │   ✓ Base64 encoded (not encrypted by default)              │
      │   ✓ Only sent to nodes that need them                      │
      │   ✓ Stored in tmpfs on nodes (not on disk)                 │
      │   ✓ Can enable encryption at rest                          │
      └─────────────────────────────────────────────────────────────┘
      ```

      **Use Secrets For:**
      - Database passwords
      - API keys and tokens
      - TLS certificates
      - SSH keys
      - OAuth credentials

      **Important Warning:**

      ```
      ⚠️  Base64 is NOT encryption!

      $ echo "cGFzc3dvcmQ=" | base64 -d
      password

      Base64 is just encoding. Anyone with access to the
      Secret can decode it. Use RBAC and encryption at rest!
      ```

      **Key insight:** Secrets provide better handling than ConfigMaps,
      but are not truly secure without additional measures (RBAC, encryption).
    key_points:
      - "Secrets store sensitive data (passwords, keys)"
      - "Data is base64 encoded, NOT encrypted"
      - "Use RBAC to control who can access Secrets"
      - "Enable encryption at rest for true security"

  - title: "Secret Types"
    content: |
      Kubernetes has several built-in Secret types.

      **Common Secret Types:**

      | Type | Use Case |
      |------|----------|
      | `Opaque` | Generic, any key-value (default) |
      | `kubernetes.io/dockerconfigjson` | Docker registry auth |
      | `kubernetes.io/tls` | TLS certificates |
      | `kubernetes.io/basic-auth` | Username/password |
      | `kubernetes.io/ssh-auth` | SSH private keys |
      | `kubernetes.io/service-account-token` | Auto-created for ServiceAccounts |

      **Creating Different Types:**

      ```bash
      # Generic (Opaque) - most common
      kubectl create secret generic db-secret \
        --from-literal=username=admin \
        --from-literal=password=secret123

      # Docker registry
      kubectl create secret docker-registry my-registry \
        --docker-server=registry.example.com \
        --docker-username=user \
        --docker-password=pass

      # TLS certificate
      kubectl create secret tls my-tls \
        --cert=path/to/tls.crt \
        --key=path/to/tls.key
      ```

      **Visual Guide:**

      ```
      ┌─────────────────────────────────────────────────────────────┐
      │                    SECRET TYPES                             │
      │                                                             │
      │   Opaque (generic)                                          │
      │   ┌────────────────────────────────────────────┐           │
      │   │ Any key-value pairs                        │           │
      │   │ DB passwords, API keys, config values     │           │
      │   └────────────────────────────────────────────┘           │
      │                                                             │
      │   docker-registry                                           │
      │   ┌────────────────────────────────────────────┐           │
      │   │ .dockerconfigjson file format             │           │
      │   │ Used for imagePullSecrets                 │           │
      │   └────────────────────────────────────────────┘           │
      │                                                             │
      │   tls                                                       │
      │   ┌────────────────────────────────────────────┐           │
      │   │ Must have tls.crt and tls.key fields      │           │
      │   │ Used by Ingress for HTTPS                 │           │
      │   └────────────────────────────────────────────┘           │
      └─────────────────────────────────────────────────────────────┘
      ```

      **Key insight:** Use the appropriate type - Kubernetes validates
      that required fields exist (e.g., tls.crt for TLS secrets).
    key_points:
      - "Opaque is the default, generic type"
      - "docker-registry for container registry auth"
      - "tls for HTTPS certificates"
      - "Type enforces required fields"

  - title: "Creating and Using Secrets"
    content: |
      **Creating Secrets:**

      ```bash
      # From literals
      kubectl create secret generic app-secret \
        --from-literal=DB_PASSWORD=secret123 \
        --from-literal=API_KEY=abc456

      # From files
      kubectl create secret generic ssh-key \
        --from-file=id_rsa=/path/to/key

      # From YAML (values must be base64 encoded)
      ```

      **YAML Format:**

      ```yaml
      apiVersion: v1
      kind: Secret
      metadata:
        name: app-secret
      type: Opaque
      data:                          # Base64 encoded
        DB_PASSWORD: c2VjcmV0MTIz    # echo -n "secret123" | base64
        API_KEY: YWJjNDU2            # echo -n "abc456" | base64
      ```

      **Or use stringData (auto-encoded):**

      ```yaml
      apiVersion: v1
      kind: Secret
      metadata:
        name: app-secret
      type: Opaque
      stringData:                    # Plain text, auto-encoded
        DB_PASSWORD: secret123
        API_KEY: abc456
      ```

      **Using in Pods (same as ConfigMaps!):**

      ```yaml
      # As environment variables
      env:
      - name: DB_PASSWORD
        valueFrom:
          secretKeyRef:              # Note: secretKeyRef, not configMapKeyRef
            name: app-secret
            key: DB_PASSWORD

      # All keys as env vars
      envFrom:
      - secretRef:
          name: app-secret

      # As volume mount
      volumes:
      - name: secret-volume
        secret:
          secretName: app-secret
      ```

      **Visual Summary:**

      ```
      ┌─────────────────────────────────────────────────────────────┐
      │                SECRET → POD FLOW                            │
      │                                                             │
      │   Secret: app-secret                                        │
      │   ┌────────────────────┐                                    │
      │   │ DB_PASSWORD: xxx   │                                    │
      │   │ API_KEY: yyy       │                                    │
      │   └─────────┬──────────┘                                    │
      │             │                                               │
      │     ┌───────┴───────┐                                       │
      │     ▼               ▼                                       │
      │  env vars        volume mount                               │
      │  ┌─────────┐     ┌─────────┐                               │
      │  │DB_PASS= │     │/secrets/│                               │
      │  │ xxx     │     │ DB_PASS │                               │
      │  └─────────┘     │ API_KEY │                               │
      │                  └─────────┘                               │
      └─────────────────────────────────────────────────────────────┘
      ```

      **Key insight:** Using Secrets is identical to ConfigMaps,
      just use `secretKeyRef` instead of `configMapKeyRef`.
    key_points:
      - "Use 'data' with base64 or 'stringData' with plain text"
      - "secretKeyRef for env vars (like configMapKeyRef)"
      - "secretRef for envFrom (like configMapRef)"
      - "Volume mounts work the same way"

command_practice:
  - id: "cmd-01"
    title: "Create a Secret"
    instructions: |
      **What we're doing:** Create a Secret with database credentials.

      **Why this matters:** This is how you securely store passwords
      that your applications need.

      **The command:**
      ```
      kubectl create secret generic <name> --from-literal=KEY=value
      ```

      Create a database secret:
    command_hint: "kubectl create secret generic db-creds --from-literal=username=admin --from-literal=password=supersecret"
    validation:
      type: "command_output"
      command: "kubectl get secret db-creds"
      expected_contains: "Opaque"
    points: 10

  - id: "cmd-02"
    title: "View Secret (Encoded)"
    instructions: |
      **What we're doing:** View the Secret contents (they're base64 encoded).

      **Why this matters:** Understanding that Secrets are encoded, not encrypted.

      View the secret data:
    command_hint: "kubectl get secret db-creds -o yaml"
    validation:
      type: "command_output"
      command: "kubectl get secret db-creds -o yaml"
      expected_contains: "data"
    points: 10

  - id: "cmd-03"
    title: "Decode a Secret"
    instructions: |
      **What we're doing:** Decode a Secret value to see the actual content.

      **Why this matters:** This demonstrates that base64 is NOT encryption.
      Anyone with Secret access can decode it.

      Decode the password field:
    command_hint: "kubectl get secret db-creds -o jsonpath='{.data.password}' | base64 -d"
    validation:
      type: "command_output"
      command: "kubectl get secret db-creds -o jsonpath='{.data.password}'"
      expected_contains: ""
    points: 10

scenarios:
  - id: "scenario-01"
    title: "Secret Not Found"
    description: |
      A pod is stuck in CreateContainerConfigError:

      ```
      Warning  Failed  secret "database-secret" not found
      ```

      The developer says they created the Secret yesterday!

      Your mission: Find and fix the Secret issue!
    manifest: |
      apiVersion: v1
      kind: Secret
      metadata:
        name: database-secrets
        namespace: default
      type: Opaque
      stringData:
        DB_PASSWORD: mypassword
      ---
      apiVersion: v1
      kind: Pod
      metadata:
        name: db-app
      spec:
        containers:
        - name: app
          image: nginx
          env:
          - name: DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: database-secret
                key: DB_PASSWORD
    hints:
      - "Check the Secret name vs what the pod references"
      - "Secret is 'database-secrets' (plural) but pod wants 'database-secret' (singular)"
      - "Either rename the Secret or update the pod reference"
    solution_validation:
      type: "command_output"
      command: "kubectl get pod db-app -o jsonpath='{.status.phase}'"
      expected_contains: "Running"
    points: 25
    hint_penalty: 5

  - id: "scenario-02"
    title: "Wrong Secret Key"
    description: |
      A pod can't start because of a missing key in the Secret:

      ```
      Error: secret key "PASSWORD" not found in secret "app-credentials"
      ```

      Your mission: Fix the key mismatch!
    manifest: |
      apiVersion: v1
      kind: Secret
      metadata:
        name: app-credentials
      type: Opaque
      stringData:
        db_password: secret123
        api_key: myapikey
      ---
      apiVersion: v1
      kind: Pod
      metadata:
        name: credentials-pod
      spec:
        containers:
        - name: app
          image: nginx
          env:
          - name: DB_PASS
            valueFrom:
              secretKeyRef:
                name: app-credentials
                key: PASSWORD
    hints:
      - "Compare the Secret keys with what the pod expects"
      - "Secret has 'db_password' but pod wants 'PASSWORD'"
      - "Update the pod to use 'db_password' as the key"
    solution_validation:
      type: "command_output"
      command: "kubectl get pod credentials-pod -o jsonpath='{.status.phase}'"
      expected_contains: "Running"
    points: 25
    hint_penalty: 5

quiz:
  passing_score: 70
  questions:
    - type: "multiple_choice"
      question: "What encoding does Kubernetes use for Secret values?"
      options:
        - "AES-256 encryption"
        - "Base64 encoding"
        - "SHA-256 hashing"
        - "Plain text"
      correct: 1
      explanation: "Secrets use base64 encoding by default, which is NOT encryption."
      points: 5

    - type: "true_false"
      question: "Base64 encoded Secrets are secure and cannot be decoded."
      correct: false
      explanation: "Base64 is encoding, not encryption. Anyone can decode it with: base64 -d"
      points: 5

    - type: "command_challenge"
      question: "Write the command to create a generic Secret named 'api-secret' with key 'TOKEN' and value 'abc123'"
      expected_contains: "create secret"
      alternatives:
        - "kubectl create secret generic api-secret --from-literal=TOKEN=abc123"
      hint: "Use kubectl create secret generic with --from-literal"
      explanation: "`kubectl create secret generic api-secret --from-literal=TOKEN=abc123`"
      points: 10

    - type: "fill_yaml"
      question: "Complete the pod spec to read a Secret as an env var:"
      yaml_template: |
        env:
        - name: PASSWORD
          valueFrom:
            __________:
              name: db-secret
              key: password
      expected: "secretKeyRef"
      explanation: "Use secretKeyRef to reference a specific key from a Secret."
      points: 10

    - type: "multiple_choice"
      question: "Which Secret type is used for Docker registry authentication?"
      options:
        - "Opaque"
        - "kubernetes.io/tls"
        - "kubernetes.io/dockerconfigjson"
        - "kubernetes.io/basic-auth"
      correct: 2
      explanation: "docker-registry type stores Docker registry credentials in the expected format."
      points: 5

    - type: "fill_yaml"
      question: "Complete the Secret spec to provide plain text values (auto-encoded):"
      yaml_template: |
        apiVersion: v1
        kind: Secret
        metadata:
          name: my-secret
        __________:
          password: myplainpassword
      expected: "stringData"
      explanation: "stringData accepts plain text values and automatically base64 encodes them."
      points: 10

    - type: "command_challenge"
      question: "Write the command to decode the 'password' field from Secret 'db-creds'"
      expected_contains: "base64"
      alternatives:
        - "kubectl get secret db-creds -o jsonpath='{.data.password}' | base64 -d"
        - "kubectl get secret db-creds -o jsonpath='{.data.password}' | base64 --decode"
      hint: "Get the field with jsonpath then pipe to base64 decode"
      explanation: "kubectl get secret db-creds -o jsonpath='{.data.password}' | base64 -d"
      points: 10

    - type: "true_false"
      question: "You can use envFrom to load all Secret keys as environment variables."
      correct: true
      explanation: "envFrom with secretRef works just like configMapRef for loading all keys."
      points: 5
