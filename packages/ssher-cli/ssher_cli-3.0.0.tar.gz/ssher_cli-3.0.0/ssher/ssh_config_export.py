"""
Export servers to ~/.ssh/config format.
Developed by Inioluwa Adeyinka
"""

import os
from pathlib import Path
from typing import List, Optional

from ssher.formatting import success, error, warning, info
from ssher.models import Server


def export_ssh_config(servers: List[Server], output_path: Optional[str] = None,
                      append: bool = False) -> bool:
    """Export servers to SSH config format.

    Args:
        servers: List of Server objects to export.
        output_path: Output file path (default: ~/.ssh/config).
        append: If True, append to existing file. Otherwise overwrite managed section.

    Returns:
        True on success.
    """
    if not servers:
        print(warning("No servers to export."))
        return False

    if output_path is None:
        output_path = Path.home() / ".ssh" / "config"
    else:
        output_path = Path(output_path)

    # Ensure .ssh directory exists
    output_path.parent.mkdir(mode=0o700, exist_ok=True)

    marker_start = "# --- SSHer Managed (Start) ---"
    marker_end = "# --- SSHer Managed (End) ---"

    # Build config blocks
    blocks = []
    blocks.append(marker_start)
    blocks.append(f"# Generated by SSHer v3.0.0")
    blocks.append("")

    for server in servers:
        lines = [f"Host {server.name}"]
        lines.append(f"    HostName {server.host}")
        lines.append(f"    User {server.user}")

        if server.port != 22:
            lines.append(f"    Port {server.port}")

        if server.auth_type == 'key' and server.key_path:
            lines.append(f"    IdentityFile {server.key_path}")

        if server.keep_alive > 0:
            lines.append(f"    ServerAliveInterval {server.keep_alive}")
            lines.append(f"    ServerAliveCountMax 3")

        if server.connection_timeout != 30:
            lines.append(f"    ConnectTimeout {server.connection_timeout}")

        if server.x11_forward:
            lines.append(f"    ForwardX11 yes")

        if server.jump_host:
            lines.append(f"    ProxyJump {server.jump_host}")

        for fwd in server.local_forwards:
            lines.append(f"    LocalForward {fwd['local']} localhost:{fwd['remote']}")

        for fwd in server.remote_forwards:
            lines.append(f"    RemoteForward {fwd['remote']} localhost:{fwd['local']}")

        for key, value in server.custom_options.items():
            lines.append(f"    {key} {value}")

        lines.append("")
        blocks.append("\n".join(lines))

    blocks.append(marker_end)
    managed_content = "\n".join(blocks) + "\n"

    if append:
        # Append mode: add to end of file
        with open(output_path, 'a') as f:
            f.write("\n" + managed_content)
    else:
        # Replace managed section or create new file
        if output_path.exists():
            existing = output_path.read_text()
            if marker_start in existing and marker_end in existing:
                # Replace managed section
                before = existing[:existing.index(marker_start)]
                after = existing[existing.index(marker_end) + len(marker_end):]
                new_content = before + managed_content + after
            else:
                # Append managed section
                new_content = existing.rstrip() + "\n\n" + managed_content
        else:
            new_content = managed_content

        output_path.write_text(new_content)

    output_path.chmod(0o600)
    print(success(f"Exported {len(servers)} servers to {output_path}"))
    return True
