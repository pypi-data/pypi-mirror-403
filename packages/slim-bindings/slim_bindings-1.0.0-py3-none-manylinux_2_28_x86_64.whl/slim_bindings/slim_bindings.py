

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_slim_bindings_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_slim_bindings_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_slim_bindings_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("slim_bindings")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_slim_bindings_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_slim_bindings_checksum_func_create_service() != 50798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_create_service_with_config() != 6614:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_get_build_info() != 20767:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_get_global_service() != 63486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_get_services() != 58132:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_get_version() != 28442:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_initialize_from_config() != 7375:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_initialize_with_configs() != 4551:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_initialize_with_defaults() != 58956:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_is_initialized() != 4144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_dataplane_config() != 6114:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_insecure_client_config() != 42525:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_insecure_server_config() != 40258:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_runtime_config() != 61090:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_runtime_config_with() != 39801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_server_config() != 36482:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_service_config() != 58037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_service_config_with() != 9565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_service_configuration() != 51471:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_tracing_config() != 62274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_new_tracing_config_with() != 52432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_func_shutdown_blocking() != 6435:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_create_session() != 43342:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait() != 26130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait_async() != 11981:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_create_session_async() != 12561:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_delete_session() != 35432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait() != 49247:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait_async() != 21135:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_delete_session_async() != 57531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_id() != 25966:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_listen_for_session() != 8567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_listen_for_session_async() != 25092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_name() != 60302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_remove_route() != 38502:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_remove_route_async() != 6042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_set_route() != 60890:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_set_route_async() != 32403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_subscribe() != 43519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_subscribe_async() != 53158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_unsubscribe() != 42801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_app_unsubscribe_async() != 44105:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_completionhandle_wait() != 24983:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_completionhandle_wait_async() != 35325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for() != 61981:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for_async() != 7758:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_name_components() != 49977:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_name_id() != 28732:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_config() != 32098:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_connect() != 51734:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_connect_async() != 25060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_create_app() != 6710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_create_app_async() != 17578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_create_app_with_direction() != 32611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_create_app_with_direction_async() != 55495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret() != 54746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret_async() != 43226:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_disconnect() != 15579:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_get_connection_id() != 21647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_get_name() != 14958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_run() != 39615:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_run_async() != 12742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_run_server() != 29360:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_run_server_async() != 24894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_shutdown() != 9865:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_shutdown_async() != 9544:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_service_stop_server() != 52012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_config() != 40208:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_destination() != 42059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_get_message() != 53473:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_get_message_async() != 56667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_invite() != 25093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_invite_and_wait() != 29134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_invite_and_wait_async() != 27936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_invite_async() != 3867:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_is_initiator() != 55820:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_metadata() != 27503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_participants_list() != 62568:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_participants_list_async() != 13982:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish() != 32701:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_and_wait() != 58778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_and_wait_async() != 4151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_async() != 8206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_to() != 18923:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait() != 53774:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait_async() != 62190:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_to_async() != 48126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_with_params() != 40703:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_publish_with_params_async() != 16343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_remove() != 19253:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_remove_and_wait() != 46797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_remove_and_wait_async() != 23062:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_remove_async() != 702:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_session_id() != 54096:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_session_type() != 62208:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_method_session_source() != 18512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_app_new() != 29282:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_app_new_with_direction() != 10680:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_app_new_with_secret() != 34848:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_name_new() != 17614:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_name_new_with_id() != 54828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_service_new() != 45367:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_slim_bindings_checksum_constructor_service_new_with_config() != 16863:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_slim_bindings_fn_clone_app.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_clone_app.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_free_app.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_free_app.restype = None
_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new_with_direction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new_with_direction.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new_with_secret.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new_with_secret.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_and_wait.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_and_wait.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_and_wait_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_and_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_listen_for_session.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_listen_for_session.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_app_listen_for_session_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_listen_for_session_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_app_remove_route.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_remove_route.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_app_remove_route_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_remove_route_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_set_route.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_set_route.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_app_set_route_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_set_route_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_subscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_subscribe.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_app_subscribe_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_subscribe_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_app_unsubscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_unsubscribe.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_app_unsubscribe_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_app_unsubscribe_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_clone_completionhandle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_clone_completionhandle.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_free_completionhandle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_free_completionhandle.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_async.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_for.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_for.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_for_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_for_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_clone_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_clone_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_free_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_free_name.restype = None
_UniffiLib.uniffi_slim_bindings_fn_constructor_name_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_name_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_constructor_name_new_with_id.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_name_new_with_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_name_components.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_name_components.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_name_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_name_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_slim_bindings_fn_clone_service.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_clone_service.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_free_service.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_free_service.restype = None
_UniffiLib.uniffi_slim_bindings_fn_constructor_service_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_service_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_constructor_service_new_with_config.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_constructor_service_new_with_config.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_service_config.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_service_connect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_connect_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_connect_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_direction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_direction.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_direction_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_direction_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_secret.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_secret_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_secret_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_disconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_disconnect.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_service_get_connection_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_get_connection_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_service_get_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_get_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_service_run.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_run.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_service_run_async.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_run_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_run_server.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_run_server.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_service_run_server_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_run_server_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_shutdown.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_shutdown.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_service_shutdown_async.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_shutdown_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_service_stop_server.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_service_stop_server.restype = None
_UniffiLib.uniffi_slim_bindings_fn_clone_session.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_clone_session.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_free_session.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_free_session.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_session_config.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_session_destination.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_destination.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_session_get_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_get_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_session_get_message_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_get_message_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_and_wait.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_and_wait.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_and_wait_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_and_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_is_initiator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_is_initiator.restype = ctypes.c_int8
_UniffiLib.uniffi_slim_bindings_fn_method_session_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_metadata.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_session_participants_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_participants_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_session_participants_list_async.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_participants_list_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_and_wait.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_and_wait.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_and_wait_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_and_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_with_params.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_with_params.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_with_params_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_with_params_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_and_wait.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_and_wait.restype = None
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_and_wait_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_and_wait_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_async.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_slim_bindings_fn_method_session_session_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_session_id.restype = ctypes.c_uint32
_UniffiLib.uniffi_slim_bindings_fn_method_session_session_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_session_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_method_session_source.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_method_session_source.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_func_create_service.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_create_service.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_func_create_service_with_config.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_create_service_with_config.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_func_get_build_info.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_get_build_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_get_global_service.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_get_global_service.restype = ctypes.c_void_p
_UniffiLib.uniffi_slim_bindings_fn_func_get_services.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_get_services.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_get_version.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_get_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_initialize_from_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_initialize_from_config.restype = None
_UniffiLib.uniffi_slim_bindings_fn_func_initialize_with_configs.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_initialize_with_configs.restype = None
_UniffiLib.uniffi_slim_bindings_fn_func_initialize_with_defaults.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_initialize_with_defaults.restype = None
_UniffiLib.uniffi_slim_bindings_fn_func_is_initialized.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_is_initialized.restype = ctypes.c_int8
_UniffiLib.uniffi_slim_bindings_fn_func_new_dataplane_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_dataplane_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_insecure_client_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_insecure_client_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_insecure_server_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_insecure_server_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_runtime_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_runtime_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_runtime_config_with.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_runtime_config_with.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_server_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_server_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_service_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_service_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_service_config_with.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_service_config_with.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_service_configuration.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_service_configuration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_tracing_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_tracing_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_new_tracing_config_with.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_new_tracing_config_with.restype = _UniffiRustBuffer
_UniffiLib.uniffi_slim_bindings_fn_func_shutdown_blocking.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_slim_bindings_fn_func_shutdown_blocking.restype = None
_UniffiLib.ffi_slim_bindings_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_slim_bindings_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_slim_bindings_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rustbuffer_free.restype = None
_UniffiLib.ffi_slim_bindings_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_slim_bindings_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_u8.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_u8.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_slim_bindings_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_i8.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_i8.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_slim_bindings_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_u16.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_u16.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_slim_bindings_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_i16.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_i16.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_slim_bindings_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_u32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_u32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_slim_bindings_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_i32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_i32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_slim_bindings_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_u64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_u64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_slim_bindings_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_i64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_i64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_slim_bindings_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_f32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_f32.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_slim_bindings_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_f64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_f64.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_slim_bindings_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_pointer.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_slim_bindings_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_slim_bindings_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_poll_void.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_cancel_void.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_slim_bindings_rust_future_free_void.restype = None
_UniffiLib.ffi_slim_bindings_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_slim_bindings_rust_future_complete_void.restype = None
_UniffiLib.uniffi_slim_bindings_checksum_func_create_service.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_create_service.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_create_service_with_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_create_service_with_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_get_build_info.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_get_build_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_get_global_service.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_get_global_service.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_get_services.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_get_services.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_get_version.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_get_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_initialize_from_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_initialize_from_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_initialize_with_configs.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_initialize_with_configs.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_initialize_with_defaults.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_initialize_with_defaults.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_is_initialized.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_is_initialized.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_dataplane_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_dataplane_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_insecure_client_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_insecure_client_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_insecure_server_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_insecure_server_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_runtime_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_runtime_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_runtime_config_with.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_runtime_config_with.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_server_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_server_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_service_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_service_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_service_config_with.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_service_config_with.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_service_configuration.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_service_configuration.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_tracing_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_tracing_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_new_tracing_config_with.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_new_tracing_config_with.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_func_shutdown_blocking.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_func_shutdown_blocking.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session_and_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_create_session_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session_and_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_delete_session_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_id.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_listen_for_session.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_listen_for_session.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_listen_for_session_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_listen_for_session_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_name.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_remove_route.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_remove_route.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_remove_route_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_remove_route_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_set_route.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_set_route.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_set_route_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_set_route_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_subscribe.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_subscribe_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_subscribe_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_unsubscribe.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_unsubscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_app_unsubscribe_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_app_unsubscribe_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_completionhandle_wait_for_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_name_components.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_name_components.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_name_id.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_name_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_connect.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_connect_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_connect_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_direction.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_direction.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_direction_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_direction_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_create_app_with_secret_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_disconnect.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_disconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_get_connection_id.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_get_connection_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_get_name.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_get_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run_server.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run_server.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run_server_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_run_server_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_shutdown.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_shutdown_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_shutdown_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_service_stop_server.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_service_stop_server.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_destination.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_destination.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_get_message.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_get_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_get_message_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_get_message_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite_and_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite_and_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite_and_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_invite_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_is_initiator.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_is_initiator.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_metadata.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_participants_list.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_participants_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_participants_list_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_participants_list_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_and_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_and_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_and_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to_and_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_to_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_with_params.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_with_params.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_with_params_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_publish_with_params_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove_and_wait.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove_and_wait_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove_and_wait_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove_async.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_remove_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_session_id.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_session_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_session_type.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_session_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_method_session_source.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_method_session_source.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_app_new.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_app_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_app_new_with_direction.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_app_new_with_direction.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_app_new_with_secret.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_app_new_with_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_name_new.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_name_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_name_new_with_id.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_name_new_with_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_service_new.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_service_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_slim_bindings_checksum_constructor_service_new_with_config.argtypes = (
)
_UniffiLib.uniffi_slim_bindings_checksum_constructor_service_new_with_config.restype = ctypes.c_uint16
_UniffiLib.ffi_slim_bindings_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_slim_bindings_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

# The Duration type.
Duration = datetime.timedelta

# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class _UniffiConverterDuration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_u64()
        microseconds = buf.read_u32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def check_lower(value):
        seconds = value.seconds + value.days * 24 * 3600
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        buf.write_i64(seconds)
        buf.write_u32(nanoseconds)



class AppProtocol(typing.Protocol):
    """
    Adapter that bridges the App API with language-bindings interface

    This adapter uses enum-based auth types (`AuthProvider`/`AuthVerifier`) instead of generics
    to be compatible with UniFFI, supporting multiple authentication mechanisms (SharedSecret,
    JWT, SPIRE, StaticToken). It provides both synchronous (blocking) and asynchronous methods
    for flexibility.
    """

    def create_session(self, config: "SessionConfig",destination: "Name"):
        """
        Create a new session (blocking version for FFI)

        Returns a SessionWithCompletion containing the session context and a completion handle.
        Call `.wait()` on the completion handle to wait for session establishment.
        """

        raise NotImplementedError
    def create_session_and_wait(self, config: "SessionConfig",destination: "Name"):
        """
        Create a new session and wait for completion (blocking version)

        This method creates a session and blocks until the session establishment completes.
        Returns only the session context, as the completion has already been awaited.
        """

        raise NotImplementedError
    def create_session_and_wait_async(self, config: "SessionConfig",destination: "Name"):
        """
        Create a new session and wait for completion (async version)

        This method creates a session and waits until the session establishment completes.
        Returns only the session context, as the completion has already been awaited.
        """

        raise NotImplementedError
    def create_session_async(self, config: "SessionConfig",destination: "Name"):
        """
        Create a new session (async version)

        Returns a SessionWithCompletion containing the session context and a completion handle.
        Await the completion handle to wait for session establishment.
        For point-to-point sessions, this ensures the remote peer has acknowledged the session.
        For multicast sessions, this ensures the initial setup is complete.
        """

        raise NotImplementedError
    def delete_session(self, session: "Session"):
        """
        Delete a session (blocking version for FFI)

        Returns a completion handle that can be awaited to ensure the deletion completes.
        """

        raise NotImplementedError
    def delete_session_and_wait(self, session: "Session"):
        """
        Delete a session and wait for completion (blocking version)

        This method deletes a session and blocks until the deletion completes.
        """

        raise NotImplementedError
    def delete_session_and_wait_async(self, session: "Session"):
        """
        Delete a session and wait for completion (async version)

        This method deletes a session and waits until the deletion completes.
        """

        raise NotImplementedError
    def delete_session_async(self, session: "Session"):
        """
        Delete a session (async version)

        Returns a completion handle that can be awaited to ensure the deletion completes.
        """

        raise NotImplementedError
    def id(self, ):
        """
        Get the app ID (derived from name)
        """

        raise NotImplementedError
    def listen_for_session(self, timeout: "typing.Optional[Duration]"):
        """
        Listen for incoming sessions (blocking version for FFI)
        """

        raise NotImplementedError
    def listen_for_session_async(self, timeout: "typing.Optional[Duration]"):
        """
        Listen for incoming sessions (async version)
        """

        raise NotImplementedError
    def name(self, ):
        """
        Get the app name
        """

        raise NotImplementedError
    def remove_route(self, name: "Name",connection_id: "int"):
        """
        Remove a route (blocking version for FFI)
        """

        raise NotImplementedError
    def remove_route_async(self, name: "Name",connection_id: "int"):
        """
        Remove a route (async version)
        """

        raise NotImplementedError
    def set_route(self, name: "Name",connection_id: "int"):
        """
        Set a route to a name for a specific connection (blocking version for FFI)
        """

        raise NotImplementedError
    def set_route_async(self, name: "Name",connection_id: "int"):
        """
        Set a route to a name for a specific connection (async version)
        """

        raise NotImplementedError
    def subscribe(self, name: "Name",connection_id: "typing.Optional[int]"):
        """
        Subscribe to a session name (blocking version for FFI)
        """

        raise NotImplementedError
    def subscribe_async(self, name: "Name",connection_id: "typing.Optional[int]"):
        """
        Subscribe to a name (async version)
        """

        raise NotImplementedError
    def unsubscribe(self, name: "Name",connection_id: "typing.Optional[int]"):
        """
        Unsubscribe from a name (blocking version for FFI)
        """

        raise NotImplementedError
    def unsubscribe_async(self, name: "Name",connection_id: "typing.Optional[int]"):
        """
        Unsubscribe from a name (async version)
        """

        raise NotImplementedError


class App:
    """
    Adapter that bridges the App API with language-bindings interface

    This adapter uses enum-based auth types (`AuthProvider`/`AuthVerifier`) instead of generics
    to be compatible with UniFFI, supporting multiple authentication mechanisms (SharedSecret,
    JWT, SPIRE, StaticToken). It provides both synchronous (blocking) and asynchronous methods
    for flexibility.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig"):
        """
        Create a new App with identity provider and verifier configurations

        This is the main entry point for creating a SLIM application from language bindings.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails

        # Supported Identity Types
        - SharedSecret: Symmetric key authentication
        - JWT: Dynamic JWT generation/verification with signing/decoding keys
        - StaticJWT: Static JWT loaded from file with auto-reload
        """

        _UniffiConverterTypeName.check_lower(base_name)
        
        _UniffiConverterTypeIdentityProviderConfig.check_lower(identity_provider_config)
        
        _UniffiConverterTypeIdentityVerifierConfig.check_lower(identity_verifier_config)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new,
        _UniffiConverterTypeName.lower(base_name),
        _UniffiConverterTypeIdentityProviderConfig.lower(identity_provider_config),
        _UniffiConverterTypeIdentityVerifierConfig.lower(identity_verifier_config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_free_app, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_clone_app, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_with_direction(cls, name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig",direction: "Direction"):
        """
        Create a new App with traffic direction (blocking version)

        This is a convenience function for creating a SLIM application with configurable
        traffic direction (send-only, receive-only, bidirectional, or none).

        # Arguments
        * `name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others
        * `direction` - Traffic direction for sessions (Send, Recv, Bidirectional, or None)

        # Returns
        * `Ok(Arc<App>)` - Successfully created app
        * `Err(SlimError)` - If app creation fails
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterTypeIdentityProviderConfig.check_lower(identity_provider_config)
        
        _UniffiConverterTypeIdentityVerifierConfig.check_lower(identity_verifier_config)
        
        _UniffiConverterTypeDirection.check_lower(direction)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new_with_direction,
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterTypeIdentityProviderConfig.lower(identity_provider_config),
        _UniffiConverterTypeIdentityVerifierConfig.lower(identity_verifier_config),
        _UniffiConverterTypeDirection.lower(direction))
        return cls._make_instance_(pointer)

    @classmethod
    def new_with_secret(cls, name: "Name",secret: "str"):
        """
        Create a new App with SharedSecret authentication (blocking version)

        This is a convenience function for creating a SLIM application using SharedSecret authentication.

        # Arguments
        * `name` - The base name for the app (without ID)
        * `secret` - The shared secret string for authentication

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterString.check_lower(secret)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_constructor_app_new_with_secret,
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterString.lower(secret))
        return cls._make_instance_(pointer)



    def create_session(self, config: "SessionConfig",destination: "Name") -> "SessionWithCompletion":
        """
        Create a new session (blocking version for FFI)

        Returns a SessionWithCompletion containing the session context and a completion handle.
        Call `.wait()` on the completion handle to wait for session establishment.
        """

        _UniffiConverterTypeSessionConfig.check_lower(config)
        
        _UniffiConverterTypeName.check_lower(destination)
        
        return _UniffiConverterTypeSessionWithCompletion.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSessionConfig.lower(config),
        _UniffiConverterTypeName.lower(destination))
        )





    def create_session_and_wait(self, config: "SessionConfig",destination: "Name") -> "Session":
        """
        Create a new session and wait for completion (blocking version)

        This method creates a session and blocks until the session establishment completes.
        Returns only the session context, as the completion has already been awaited.
        """

        _UniffiConverterTypeSessionConfig.check_lower(config)
        
        _UniffiConverterTypeName.check_lower(destination)
        
        return _UniffiConverterTypeSession.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_and_wait,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSessionConfig.lower(config),
        _UniffiConverterTypeName.lower(destination))
        )




    async def create_session_and_wait_async(self, config: "SessionConfig",destination: "Name") -> "Session":
        """
        Create a new session and wait for completion (async version)

        This method creates a session and waits until the session establishment completes.
        Returns only the session context, as the completion has already been awaited.
        """

        _UniffiConverterTypeSessionConfig.check_lower(config)
        
        _UniffiConverterTypeName.check_lower(destination)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_and_wait_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSessionConfig.lower(config),
        _UniffiConverterTypeName.lower(destination)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeSession.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )



    async def create_session_async(self, config: "SessionConfig",destination: "Name") -> "SessionWithCompletion":
        """
        Create a new session (async version)

        Returns a SessionWithCompletion containing the session context and a completion handle.
        Await the completion handle to wait for session establishment.
        For point-to-point sessions, this ensures the remote peer has acknowledged the session.
        For multicast sessions, this ensures the initial setup is complete.
        """

        _UniffiConverterTypeSessionConfig.check_lower(config)
        
        _UniffiConverterTypeName.check_lower(destination)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_create_session_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSessionConfig.lower(config),
        _UniffiConverterTypeName.lower(destination)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSessionWithCompletion.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def delete_session(self, session: "Session") -> "CompletionHandle":
        """
        Delete a session (blocking version for FFI)

        Returns a completion handle that can be awaited to ensure the deletion completes.
        """

        _UniffiConverterTypeSession.check_lower(session)
        
        return _UniffiConverterTypeCompletionHandle.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSession.lower(session))
        )





    def delete_session_and_wait(self, session: "Session") -> None:
        """
        Delete a session and wait for completion (blocking version)

        This method deletes a session and blocks until the deletion completes.
        """

        _UniffiConverterTypeSession.check_lower(session)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSession.lower(session))





    async def delete_session_and_wait_async(self, session: "Session") -> None:

        """
        Delete a session and wait for completion (async version)

        This method deletes a session and waits until the deletion completes.
        """

        _UniffiConverterTypeSession.check_lower(session)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_and_wait_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSession.lower(session)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )



    async def delete_session_async(self, session: "Session") -> "CompletionHandle":
        """
        Delete a session (async version)

        Returns a completion handle that can be awaited to ensure the deletion completes.
        """

        _UniffiConverterTypeSession.check_lower(session)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_delete_session_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSession.lower(session)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeCompletionHandle.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def id(self, ) -> "int":
        """
        Get the app ID (derived from name)
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_app_id,self._uniffi_clone_pointer(),)
        )





    def listen_for_session(self, timeout: "typing.Optional[Duration]") -> "Session":
        """
        Listen for incoming sessions (blocking version for FFI)
        """

        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return _UniffiConverterTypeSession.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_listen_for_session,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalDuration.lower(timeout))
        )




    async def listen_for_session_async(self, timeout: "typing.Optional[Duration]") -> "Session":
        """
        Listen for incoming sessions (async version)
        """

        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_listen_for_session_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalDuration.lower(timeout)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeSession.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def name(self, ) -> "Name":
        """
        Get the app name
        """

        return _UniffiConverterTypeName.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_app_name,self._uniffi_clone_pointer(),)
        )





    def remove_route(self, name: "Name",connection_id: "int") -> None:
        """
        Remove a route (blocking version for FFI)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterUInt64.check_lower(connection_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_remove_route,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterUInt64.lower(connection_id))





    async def remove_route_async(self, name: "Name",connection_id: "int") -> None:

        """
        Remove a route (async version)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterUInt64.check_lower(connection_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_remove_route_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterUInt64.lower(connection_id)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def set_route(self, name: "Name",connection_id: "int") -> None:
        """
        Set a route to a name for a specific connection (blocking version for FFI)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterUInt64.check_lower(connection_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_set_route,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterUInt64.lower(connection_id))





    async def set_route_async(self, name: "Name",connection_id: "int") -> None:

        """
        Set a route to a name for a specific connection (async version)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterUInt64.check_lower(connection_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_set_route_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterUInt64.lower(connection_id)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def subscribe(self, name: "Name",connection_id: "typing.Optional[int]") -> None:
        """
        Subscribe to a session name (blocking version for FFI)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterOptionalUInt64.check_lower(connection_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_subscribe,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterOptionalUInt64.lower(connection_id))





    async def subscribe_async(self, name: "Name",connection_id: "typing.Optional[int]") -> None:

        """
        Subscribe to a name (async version)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterOptionalUInt64.check_lower(connection_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_subscribe_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterOptionalUInt64.lower(connection_id)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def unsubscribe(self, name: "Name",connection_id: "typing.Optional[int]") -> None:
        """
        Unsubscribe from a name (blocking version for FFI)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterOptionalUInt64.check_lower(connection_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_app_unsubscribe,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterOptionalUInt64.lower(connection_id))





    async def unsubscribe_async(self, name: "Name",connection_id: "typing.Optional[int]") -> None:

        """
        Unsubscribe from a name (async version)
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterOptionalUInt64.check_lower(connection_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_app_unsubscribe_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterOptionalUInt64.lower(connection_id)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )





class _UniffiConverterTypeApp:

    @staticmethod
    def lift(value: int):
        return App._make_instance_(value)

    @staticmethod
    def check_lower(value: App):
        if not isinstance(value, App):
            raise TypeError("Expected App instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AppProtocol):
        if not isinstance(value, App):
            raise TypeError("Expected App instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AppProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class CompletionHandleProtocol(typing.Protocol):
    """
    FFI-compatible completion handle for async operations

    Represents a pending operation that can be awaited to ensure completion.
    Used for operations that need delivery confirmation or handshake acknowledgment.

    # Examples

    Basic usage:
    ```ignore
    let completion = session.publish(data, None, None)?;
    completion.wait()?; // Wait for delivery confirmation
    ```
    """

    def wait(self, ):
        """
        Wait for the operation to complete indefinitely (blocking version)

        This blocks the calling thread until the operation completes.
        Use this from Go or other languages when you need to ensure
        an operation has finished before proceeding.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        raise NotImplementedError
    def wait_async(self, ):
        """
        Wait for the operation to complete indefinitely (async version)

        This is the async version that integrates with UniFFI's polling mechanism.
        The operation will yield control while waiting.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        raise NotImplementedError
    def wait_for(self, timeout: "Duration"):
        """
        Wait for the operation to complete with a timeout (blocking version)

        This blocks the calling thread until the operation completes or the timeout expires.
        Use this from Go or other languages when you need to ensure
        an operation has finished before proceeding with a time limit.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Arguments
        * `timeout` - Maximum time to wait for completion

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError::Timeout)` - If the operation timed out
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        raise NotImplementedError
    def wait_for_async(self, timeout: "Duration"):
        """
        Wait for the operation to complete with a timeout (async version)

        This is the async version that integrates with UniFFI's polling mechanism.
        The operation will yield control while waiting until completion or timeout.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Arguments
        * `timeout` - Maximum time to wait for completion

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError::Timeout)` - If the operation timed out
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        raise NotImplementedError


class CompletionHandle:
    """
    FFI-compatible completion handle for async operations

    Represents a pending operation that can be awaited to ensure completion.
    Used for operations that need delivery confirmation or handshake acknowledgment.

    # Examples

    Basic usage:
    ```ignore
    let completion = session.publish(data, None, None)?;
    completion.wait()?; // Wait for delivery confirmation
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_free_completionhandle, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_clone_completionhandle, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def wait(self, ) -> None:
        """
        Wait for the operation to complete indefinitely (blocking version)

        This blocks the calling thread until the operation completes.
        Use this from Go or other languages when you need to ensure
        an operation has finished before proceeding.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait,self._uniffi_clone_pointer(),)





    async def wait_async(self, ) -> None:

        """
        Wait for the operation to complete indefinitely (async version)

        This is the async version that integrates with UniFFI's polling mechanism.
        The operation will yield control while waiting.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_async(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def wait_for(self, timeout: "Duration") -> None:
        """
        Wait for the operation to complete with a timeout (blocking version)

        This blocks the calling thread until the operation completes or the timeout expires.
        Use this from Go or other languages when you need to ensure
        an operation has finished before proceeding with a time limit.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Arguments
        * `timeout` - Maximum time to wait for completion

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError::Timeout)` - If the operation timed out
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_for,self._uniffi_clone_pointer(),
        _UniffiConverterDuration.lower(timeout))





    async def wait_for_async(self, timeout: "Duration") -> None:

        """
        Wait for the operation to complete with a timeout (async version)

        This is the async version that integrates with UniFFI's polling mechanism.
        The operation will yield control while waiting until completion or timeout.

        **Note:** This can only be called once per handle. Subsequent calls
        will return an error.

        # Arguments
        * `timeout` - Maximum time to wait for completion

        # Returns
        * `Ok(())` - Operation completed successfully
        * `Err(SlimError::Timeout)` - If the operation timed out
        * `Err(SlimError)` - Operation failed or handle already consumed
        """

        _UniffiConverterDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_completionhandle_wait_for_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterDuration.lower(timeout)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )





class _UniffiConverterTypeCompletionHandle:

    @staticmethod
    def lift(value: int):
        return CompletionHandle._make_instance_(value)

    @staticmethod
    def check_lower(value: CompletionHandle):
        if not isinstance(value, CompletionHandle):
            raise TypeError("Expected CompletionHandle instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CompletionHandleProtocol):
        if not isinstance(value, CompletionHandle):
            raise TypeError("Expected CompletionHandle instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CompletionHandleProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NameProtocol(typing.Protocol):
    """
    Name type for SLIM (Secure Low-Latency Interactive Messaging)
    """

    def components(self, ):
        """
        Get the name components as a vector of strings
        """

        raise NotImplementedError
    def id(self, ):
        """
        Get the name ID
        """

        raise NotImplementedError


class Name:
    """
    Name type for SLIM (Secure Low-Latency Interactive Messaging)
    """

    _pointer: ctypes.c_void_p
    def __init__(self, component0: "str",component1: "str",component2: "str"):
        """
        Create a new Name from components without an ID
        """

        _UniffiConverterString.check_lower(component0)
        
        _UniffiConverterString.check_lower(component1)
        
        _UniffiConverterString.check_lower(component2)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_constructor_name_new,
        _UniffiConverterString.lower(component0),
        _UniffiConverterString.lower(component1),
        _UniffiConverterString.lower(component2))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_free_name, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_clone_name, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_with_id(cls, component0: "str",component1: "str",component2: "str",id: "int"):
        """
        Create a new Name from components with an ID
        """

        _UniffiConverterString.check_lower(component0)
        
        _UniffiConverterString.check_lower(component1)
        
        _UniffiConverterString.check_lower(component2)
        
        _UniffiConverterUInt64.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_constructor_name_new_with_id,
        _UniffiConverterString.lower(component0),
        _UniffiConverterString.lower(component1),
        _UniffiConverterString.lower(component2),
        _UniffiConverterUInt64.lower(id))
        return cls._make_instance_(pointer)



    def components(self, ) -> "typing.List[str]":
        """
        Get the name components as a vector of strings
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_name_components,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "int":
        """
        Get the name ID
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_name_id,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Name):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Name):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_name_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(other)))



class _UniffiConverterTypeName:

    @staticmethod
    def lift(value: int):
        return Name._make_instance_(value)

    @staticmethod
    def check_lower(value: Name):
        if not isinstance(value, Name):
            raise TypeError("Expected Name instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NameProtocol):
        if not isinstance(value, Name):
            raise TypeError("Expected Name instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NameProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ServiceProtocol(typing.Protocol):
    """
    Service wrapper for uniffi bindings
    """

    def config(self, ):
        """
        Get the service configuration
        """

        raise NotImplementedError
    def connect(self, config: "ClientConfig"):
        """
        Connect to a remote endpoint as a client - blocking version
        """

        raise NotImplementedError
    def connect_async(self, config: "ClientConfig"):
        """
        Connect to a remote endpoint as a client
        """

        raise NotImplementedError
    def create_app(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig"):
        """
        Create a new App with authentication configuration (blocking version)

        This method initializes authentication providers/verifiers and creates a App
        on this service instance. This is a blocking wrapper around create_app_async.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        raise NotImplementedError
    def create_app_async(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig"):
        """
        Create a new App with authentication configuration (async version)

        This method initializes authentication providers/verifiers and creates a App
        on this service instance.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        raise NotImplementedError
    def create_app_with_direction(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig",direction: "Direction"):
        """
        Create a new App with authentication configuration and traffic direction (blocking version)

        This method initializes authentication providers/verifiers and creates an App
        on this service instance. The direction parameter controls whether the app
        can send messages, receive messages, both, or neither.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others
        * `direction` - Traffic direction: Send, Recv, Bidirectional, or None

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        raise NotImplementedError
    def create_app_with_direction_async(self, name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig",direction: "Direction"):
        """
        Create a new App with authentication configuration and traffic direction (async version)

        This method initializes authentication providers/verifiers and creates an App
        on this service instance. The direction parameter controls whether the app
        can send messages, receive messages, both, or neither.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others
        * `direction` - Traffic direction: Send, Recv, Bidirectional, or None

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        raise NotImplementedError
    def create_app_with_secret(self, name: "Name",secret: "str"):
        """
        Create a new App with SharedSecret authentication (helper function)

        This is a convenience function for creating a SLIM application using SharedSecret authentication
        on this service instance.

        # Arguments
        * `name` - The base name for the app (without ID)
        * `secret` - The shared secret string for authentication

        # Returns
        * `Ok(Arc<App>)` - Successfully created app
        * `Err(SlimError)` - If app creation fails
        """

        raise NotImplementedError
    def create_app_with_secret_async(self, name: "Name",secret: "str"):
        """
        Create a new App with SharedSecret authentication (async version)

        This is a convenience function for creating a SLIM application using SharedSecret authentication
        on this service instance. This is the async version.

        # Arguments
        * `name` - The base name for the app (without ID)
        * `secret` - The shared secret string for authentication

        # Returns
        * `Ok(Arc<App>)` - Successfully created app
        * `Err(SlimError)` - If app creation fails
        """

        raise NotImplementedError
    def disconnect(self, conn_id: "int"):
        """
        Disconnect a client connection by connection ID - blocking version
        """

        raise NotImplementedError
    def get_connection_id(self, endpoint: "str"):
        """
        Get the connection ID for a given endpoint
        """

        raise NotImplementedError
    def get_name(self, ):
        """
        Get the service identifier/name
        """

        raise NotImplementedError
    def run(self, ):
        """
        Run the service (starts all configured servers and clients) - blocking version
        """

        raise NotImplementedError
    def run_async(self, ):
        """
        Run the service (starts all configured servers and clients)
        """

        raise NotImplementedError
    def run_server(self, config: "ServerConfig"):
        """
        Start a server with the given configuration - blocking version
        """

        raise NotImplementedError
    def run_server_async(self, config: "ServerConfig"):
        """
        Start a server with the given configuration
        """

        raise NotImplementedError
    def shutdown(self, ):
        """
        Shutdown the service gracefully - blocking version
        """

        raise NotImplementedError
    def shutdown_async(self, ):
        """
        Shutdown the service gracefully
        """

        raise NotImplementedError
    def stop_server(self, endpoint: "str"):
        """
        Stop a server by endpoint - blocking version
        """

        raise NotImplementedError


class Service:
    """
    Service wrapper for uniffi bindings
    """

    _pointer: ctypes.c_void_p
    def __init__(self, name: "str"):
        """
        Create a new Service with the given name
        """

        _UniffiConverterString.check_lower(name)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_constructor_service_new,
        _UniffiConverterString.lower(name))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_free_service, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_clone_service, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_with_config(cls, name: "str",config: "ServiceConfig"):
        """
        Create a new Service with configuration
        """

        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterTypeServiceConfig.check_lower(config)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_constructor_service_new_with_config,
        _UniffiConverterString.lower(name),
        _UniffiConverterTypeServiceConfig.lower(config))
        return cls._make_instance_(pointer)



    def config(self, ) -> "ServiceConfig":
        """
        Get the service configuration
        """

        return _UniffiConverterTypeServiceConfig.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_service_config,self._uniffi_clone_pointer(),)
        )





    def connect(self, config: "ClientConfig") -> "int":
        """
        Connect to a remote endpoint as a client - blocking version
        """

        _UniffiConverterTypeClientConfig.check_lower(config)
        
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_connect,self._uniffi_clone_pointer(),
        _UniffiConverterTypeClientConfig.lower(config))
        )




    async def connect_async(self, config: "ClientConfig") -> "int":
        """
        Connect to a remote endpoint as a client
        """

        _UniffiConverterTypeClientConfig.check_lower(config)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_connect_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeClientConfig.lower(config)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_u64,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_u64,
            _UniffiLib.ffi_slim_bindings_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def create_app(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig") -> "App":
        """
        Create a new App with authentication configuration (blocking version)

        This method initializes authentication providers/verifiers and creates a App
        on this service instance. This is a blocking wrapper around create_app_async.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        _UniffiConverterTypeName.check_lower(base_name)
        
        _UniffiConverterTypeIdentityProviderConfig.check_lower(identity_provider_config)
        
        _UniffiConverterTypeIdentityVerifierConfig.check_lower(identity_verifier_config)
        
        return _UniffiConverterTypeApp.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(base_name),
        _UniffiConverterTypeIdentityProviderConfig.lower(identity_provider_config),
        _UniffiConverterTypeIdentityVerifierConfig.lower(identity_verifier_config))
        )




    async def create_app_async(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig") -> "App":
        """
        Create a new App with authentication configuration (async version)

        This method initializes authentication providers/verifiers and creates a App
        on this service instance.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        _UniffiConverterTypeName.check_lower(base_name)
        
        _UniffiConverterTypeIdentityProviderConfig.check_lower(identity_provider_config)
        
        _UniffiConverterTypeIdentityVerifierConfig.check_lower(identity_verifier_config)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(base_name),
        _UniffiConverterTypeIdentityProviderConfig.lower(identity_provider_config),
        _UniffiConverterTypeIdentityVerifierConfig.lower(identity_verifier_config)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeApp.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def create_app_with_direction(self, base_name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig",direction: "Direction") -> "App":
        """
        Create a new App with authentication configuration and traffic direction (blocking version)

        This method initializes authentication providers/verifiers and creates an App
        on this service instance. The direction parameter controls whether the app
        can send messages, receive messages, both, or neither.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others
        * `direction` - Traffic direction: Send, Recv, Bidirectional, or None

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        _UniffiConverterTypeName.check_lower(base_name)
        
        _UniffiConverterTypeIdentityProviderConfig.check_lower(identity_provider_config)
        
        _UniffiConverterTypeIdentityVerifierConfig.check_lower(identity_verifier_config)
        
        _UniffiConverterTypeDirection.check_lower(direction)
        
        return _UniffiConverterTypeApp.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_direction,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(base_name),
        _UniffiConverterTypeIdentityProviderConfig.lower(identity_provider_config),
        _UniffiConverterTypeIdentityVerifierConfig.lower(identity_verifier_config),
        _UniffiConverterTypeDirection.lower(direction))
        )




    async def create_app_with_direction_async(self, name: "Name",identity_provider_config: "IdentityProviderConfig",identity_verifier_config: "IdentityVerifierConfig",direction: "Direction") -> "App":
        """
        Create a new App with authentication configuration and traffic direction (async version)

        This method initializes authentication providers/verifiers and creates an App
        on this service instance. The direction parameter controls whether the app
        can send messages, receive messages, both, or neither.

        # Arguments
        * `base_name` - The base name for the app (without ID)
        * `identity_provider_config` - Configuration for proving identity to others
        * `identity_verifier_config` - Configuration for verifying identity of others
        * `direction` - Traffic direction: Send, Recv, Bidirectional, or None

        # Returns
        * `Ok(Arc<App>)` - Successfully created adapter
        * `Err(SlimError)` - If adapter creation fails
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterTypeIdentityProviderConfig.check_lower(identity_provider_config)
        
        _UniffiConverterTypeIdentityVerifierConfig.check_lower(identity_verifier_config)
        
        _UniffiConverterTypeDirection.check_lower(direction)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_direction_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterTypeIdentityProviderConfig.lower(identity_provider_config),
        _UniffiConverterTypeIdentityVerifierConfig.lower(identity_verifier_config),
        _UniffiConverterTypeDirection.lower(direction)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeApp.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def create_app_with_secret(self, name: "Name",secret: "str") -> "App":
        """
        Create a new App with SharedSecret authentication (helper function)

        This is a convenience function for creating a SLIM application using SharedSecret authentication
        on this service instance.

        # Arguments
        * `name` - The base name for the app (without ID)
        * `secret` - The shared secret string for authentication

        # Returns
        * `Ok(Arc<App>)` - Successfully created app
        * `Err(SlimError)` - If app creation fails
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterString.check_lower(secret)
        
        return _UniffiConverterTypeApp.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_secret,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterString.lower(secret))
        )




    async def create_app_with_secret_async(self, name: "Name",secret: "str") -> "App":
        """
        Create a new App with SharedSecret authentication (async version)

        This is a convenience function for creating a SLIM application using SharedSecret authentication
        on this service instance. This is the async version.

        # Arguments
        * `name` - The base name for the app (without ID)
        * `secret` - The shared secret string for authentication

        # Returns
        * `Ok(Arc<App>)` - Successfully created app
        * `Err(SlimError)` - If app creation fails
        """

        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterString.check_lower(secret)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_create_app_with_secret_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterString.lower(secret)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeApp.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def disconnect(self, conn_id: "int") -> None:
        """
        Disconnect a client connection by connection ID - blocking version
        """

        _UniffiConverterUInt64.check_lower(conn_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_disconnect,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(conn_id))






    def get_connection_id(self, endpoint: "str") -> "typing.Optional[int]":
        """
        Get the connection ID for a given endpoint
        """

        _UniffiConverterString.check_lower(endpoint)
        
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_service_get_connection_id,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(endpoint))
        )





    def get_name(self, ) -> "str":
        """
        Get the service identifier/name
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_method_service_get_name,self._uniffi_clone_pointer(),)
        )





    def run(self, ) -> None:
        """
        Run the service (starts all configured servers and clients) - blocking version
        """

        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_run,self._uniffi_clone_pointer(),)





    async def run_async(self, ) -> None:

        """
        Run the service (starts all configured servers and clients)
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_run_async(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def run_server(self, config: "ServerConfig") -> None:
        """
        Start a server with the given configuration - blocking version
        """

        _UniffiConverterTypeServerConfig.check_lower(config)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_run_server,self._uniffi_clone_pointer(),
        _UniffiConverterTypeServerConfig.lower(config))





    async def run_server_async(self, config: "ServerConfig") -> None:

        """
        Start a server with the given configuration
        """

        _UniffiConverterTypeServerConfig.check_lower(config)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_run_server_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeServerConfig.lower(config)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def shutdown(self, ) -> None:
        """
        Shutdown the service gracefully - blocking version
        """

        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_shutdown,self._uniffi_clone_pointer(),)





    async def shutdown_async(self, ) -> None:

        """
        Shutdown the service gracefully
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_service_shutdown_async(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def stop_server(self, endpoint: "str") -> None:
        """
        Stop a server by endpoint - blocking version
        """

        _UniffiConverterString.check_lower(endpoint)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_service_stop_server,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(endpoint))







class _UniffiConverterTypeService:

    @staticmethod
    def lift(value: int):
        return Service._make_instance_(value)

    @staticmethod
    def check_lower(value: Service):
        if not isinstance(value, Service):
            raise TypeError("Expected Service instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ServiceProtocol):
        if not isinstance(value, Service):
            raise TypeError("Expected Service instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ServiceProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SessionProtocol(typing.Protocol):
    """
    Session context for language bindings (UniFFI-compatible)

    Wraps the session context with proper async access patterns for message reception.
    Provides both synchronous (blocking) and asynchronous methods for FFI compatibility.
    """

    def config(self, ):
        """
        Get the session configuration
        """

        raise NotImplementedError
    def destination(self, ):
        """
        Get the destination name for this session
        """

        raise NotImplementedError
    def get_message(self, timeout: "typing.Optional[Duration]"):
        """
        Receive a message from the session (blocking version for FFI)

        # Arguments
        * `timeout` - Optional timeout duration

        # Returns
        * `Ok(ReceivedMessage)` - Message with context and payload bytes
        * `Err(SlimError)` - If the receive fails or times out
        """

        raise NotImplementedError
    def get_message_async(self, timeout: "typing.Optional[Duration]"):
        """
        Receive a message from the session (async version)
        """

        raise NotImplementedError
    def invite(self, participant: "Name"):
        """
        Invite a participant to the session (blocking version)

        Returns a completion handle that can be awaited to ensure the invitation completes.
        """

        raise NotImplementedError
    def invite_and_wait(self, participant: "Name"):
        """
        Invite a participant and wait for completion (blocking version)

        This method invites a participant and blocks until the invitation completes.
        """

        raise NotImplementedError
    def invite_and_wait_async(self, participant: "Name"):
        """
        Invite a participant and wait for completion (async version)

        This method invites a participant and waits until the invitation completes.
        """

        raise NotImplementedError
    def invite_async(self, participant: "Name"):
        """
        Invite a participant to the session (async version)

        Returns a completion handle that can be awaited to ensure the invitation completes.
        """

        raise NotImplementedError
    def is_initiator(self, ):
        """
        Check if this session is the initiator
        """

        raise NotImplementedError
    def metadata(self, ):
        """
        Get the session metadata
        """

        raise NotImplementedError
    def participants_list(self, ):
        """
        Get list of participants in the session (blocking version for FFI)
        """

        raise NotImplementedError
    def participants_list_async(self, ):
        """
        Get list of participants in the session
        """

        raise NotImplementedError
    def publish(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a message to the session's destination (blocking version)

        Returns a completion handle that can be awaited to ensure the message was delivered.

        # Arguments
        * `data` - The message payload bytes
        * `payload_type` - Optional content type identifier
        * `metadata` - Optional key-value metadata pairs

        # Returns
        * `Ok(CompletionHandle)` - Handle to await delivery confirmation
        * `Err(SlimError)` - If publishing fails

        # Example
        ```ignore
        let completion = session.publish(data, None, None)?;
        completion.wait()?; // Blocks until message is delivered
        ```
        """

        raise NotImplementedError
    def publish_and_wait(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a message and wait for completion (blocking version)

        This method publishes a message and blocks until the delivery completes.
        """

        raise NotImplementedError
    def publish_and_wait_async(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a message and wait for completion (async version)

        This method publishes a message and waits until the delivery completes.
        """

        raise NotImplementedError
    def publish_async(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a message to the session's destination (async version)

        Returns a completion handle that can be awaited to ensure the message was delivered.
        """

        raise NotImplementedError
    def publish_to(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a reply message to the originator of a received message (blocking version for FFI)

        This method uses the routing information from a previously received message
        to send a reply back to the sender. This is the preferred way to implement
        request/reply patterns.

        Returns a completion handle that can be awaited to ensure the message was delivered.

        # Arguments
        * `message_context` - Context from a message received via `get_message()`
        * `data` - The reply payload bytes
        * `payload_type` - Optional content type identifier
        * `metadata` - Optional key-value metadata pairs

        # Returns
        * `Ok(CompletionHandle)` - Handle to await delivery confirmation
        * `Err(SlimError)` - If publishing fails
        """

        raise NotImplementedError
    def publish_to_and_wait(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a reply message and wait for completion (blocking version)

        This method publishes a reply to a received message and blocks until the delivery completes.
        """

        raise NotImplementedError
    def publish_to_and_wait_async(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a reply message and wait for completion (async version)

        This method publishes a reply to a received message and waits until the delivery completes.
        """

        raise NotImplementedError
    def publish_to_async(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Publish a reply message (async version)

        Returns a completion handle that can be awaited to ensure the message was delivered.
        """

        raise NotImplementedError
    def publish_with_params(self, destination: "Name",fanout: "int",data: "bytes",connection_out: "typing.Optional[int]",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Low-level publish with full control over all parameters (blocking version for FFI)

        This is an advanced method that provides complete control over routing and delivery.
        Most users should use `publish()` or `publish_to()` instead.

        # Arguments
        * `destination` - Target name to send to
        * `fanout` - Number of copies to send (for multicast)
        * `data` - The message payload bytes
        * `connection_out` - Optional specific connection ID to use
        * `payload_type` - Optional content type identifier
        * `metadata` - Optional key-value metadata pairs
        """

        raise NotImplementedError
    def publish_with_params_async(self, destination: "Name",fanout: "int",data: "bytes",connection_out: "typing.Optional[int]",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]"):
        """
        Low-level publish with full control (async version)
        """

        raise NotImplementedError
    def remove(self, participant: "Name"):
        """
        Remove a participant from the session (blocking version)

        Returns a completion handle that can be awaited to ensure the removal completes.
        """

        raise NotImplementedError
    def remove_and_wait(self, participant: "Name"):
        """
        Remove a participant and wait for completion (blocking version)

        This method removes a participant and blocks until the removal completes.
        """

        raise NotImplementedError
    def remove_and_wait_async(self, participant: "Name"):
        """
        Remove a participant and wait for completion (async version)

        This method removes a participant and waits until the removal completes.
        """

        raise NotImplementedError
    def remove_async(self, participant: "Name"):
        """
        Remove a participant from the session (async version)

        Returns a completion handle that can be awaited to ensure the removal completes.
        """

        raise NotImplementedError
    def session_id(self, ):
        """
        Get the session ID
        """

        raise NotImplementedError
    def session_type(self, ):
        """
        Get the session type (PointToPoint or Group)
        """

        raise NotImplementedError
    def source(self, ):
        """
        Get the source name for this session
        """

        raise NotImplementedError


class Session:
    """
    Session context for language bindings (UniFFI-compatible)

    Wraps the session context with proper async access patterns for message reception.
    Provides both synchronous (blocking) and asynchronous methods for FFI compatibility.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_free_session, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_clone_session, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def config(self, ) -> "SessionConfig":
        """
        Get the session configuration
        """

        return _UniffiConverterTypeSessionConfig.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_config,self._uniffi_clone_pointer(),)
        )





    def destination(self, ) -> "Name":
        """
        Get the destination name for this session
        """

        return _UniffiConverterTypeName.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_destination,self._uniffi_clone_pointer(),)
        )





    def get_message(self, timeout: "typing.Optional[Duration]") -> "ReceivedMessage":
        """
        Receive a message from the session (blocking version for FFI)

        # Arguments
        * `timeout` - Optional timeout duration

        # Returns
        * `Ok(ReceivedMessage)` - Message with context and payload bytes
        * `Err(SlimError)` - If the receive fails or times out
        """

        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return _UniffiConverterTypeReceivedMessage.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_get_message,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalDuration.lower(timeout))
        )




    async def get_message_async(self, timeout: "typing.Optional[Duration]") -> "ReceivedMessage":
        """
        Receive a message from the session (async version)
        """

        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_get_message_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalDuration.lower(timeout)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeReceivedMessage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def invite(self, participant: "Name") -> "CompletionHandle":
        """
        Invite a participant to the session (blocking version)

        Returns a completion handle that can be awaited to ensure the invitation completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        return _UniffiConverterTypeCompletionHandle.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_invite,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(participant))
        )





    def invite_and_wait(self, participant: "Name") -> None:
        """
        Invite a participant and wait for completion (blocking version)

        This method invites a participant and blocks until the invitation completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_invite_and_wait,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(participant))





    async def invite_and_wait_async(self, participant: "Name") -> None:

        """
        Invite a participant and wait for completion (async version)

        This method invites a participant and waits until the invitation completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_invite_and_wait_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(participant)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )



    async def invite_async(self, participant: "Name") -> "CompletionHandle":
        """
        Invite a participant to the session (async version)

        Returns a completion handle that can be awaited to ensure the invitation completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_invite_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(participant)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeCompletionHandle.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def is_initiator(self, ) -> "bool":
        """
        Check if this session is the initiator
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_is_initiator,self._uniffi_clone_pointer(),)
        )





    def metadata(self, ) -> "dict[str, str]":
        """
        Get the session metadata
        """

        return _UniffiConverterMapStringString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_metadata,self._uniffi_clone_pointer(),)
        )





    def participants_list(self, ) -> "typing.List[Name]":
        """
        Get list of participants in the session (blocking version for FFI)
        """

        return _UniffiConverterSequenceTypeName.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_participants_list,self._uniffi_clone_pointer(),)
        )




    async def participants_list_async(self, ) -> "typing.List[Name]":
        """
        Get list of participants in the session
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_participants_list_async(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeName.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def publish(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> "CompletionHandle":
        """
        Publish a message to the session's destination (blocking version)

        Returns a completion handle that can be awaited to ensure the message was delivered.

        # Arguments
        * `data` - The message payload bytes
        * `payload_type` - Optional content type identifier
        * `metadata` - Optional key-value metadata pairs

        # Returns
        * `Ok(CompletionHandle)` - Handle to await delivery confirmation
        * `Err(SlimError)` - If publishing fails

        # Example
        ```ignore
        let completion = session.publish(data, None, None)?;
        completion.wait()?; // Blocks until message is delivered
        ```
        """

        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return _UniffiConverterTypeCompletionHandle.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_publish,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata))
        )





    def publish_and_wait(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> None:
        """
        Publish a message and wait for completion (blocking version)

        This method publishes a message and blocks until the delivery completes.
        """

        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_and_wait,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata))





    async def publish_and_wait_async(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> None:

        """
        Publish a message and wait for completion (async version)

        This method publishes a message and waits until the delivery completes.
        """

        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_publish_and_wait_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )



    async def publish_async(self, data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> "CompletionHandle":
        """
        Publish a message to the session's destination (async version)

        Returns a completion handle that can be awaited to ensure the message was delivered.
        """

        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_publish_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeCompletionHandle.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def publish_to(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> "CompletionHandle":
        """
        Publish a reply message to the originator of a received message (blocking version for FFI)

        This method uses the routing information from a previously received message
        to send a reply back to the sender. This is the preferred way to implement
        request/reply patterns.

        Returns a completion handle that can be awaited to ensure the message was delivered.

        # Arguments
        * `message_context` - Context from a message received via `get_message()`
        * `data` - The reply payload bytes
        * `payload_type` - Optional content type identifier
        * `metadata` - Optional key-value metadata pairs

        # Returns
        * `Ok(CompletionHandle)` - Handle to await delivery confirmation
        * `Err(SlimError)` - If publishing fails
        """

        _UniffiConverterTypeMessageContext.check_lower(message_context)
        
        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return _UniffiConverterTypeCompletionHandle.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMessageContext.lower(message_context),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata))
        )





    def publish_to_and_wait(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> None:
        """
        Publish a reply message and wait for completion (blocking version)

        This method publishes a reply to a received message and blocks until the delivery completes.
        """

        _UniffiConverterTypeMessageContext.check_lower(message_context)
        
        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMessageContext.lower(message_context),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata))





    async def publish_to_and_wait_async(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> None:

        """
        Publish a reply message and wait for completion (async version)

        This method publishes a reply to a received message and waits until the delivery completes.
        """

        _UniffiConverterTypeMessageContext.check_lower(message_context)
        
        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_and_wait_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeMessageContext.lower(message_context),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )



    async def publish_to_async(self, message_context: "MessageContext",data: "bytes",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> "CompletionHandle":
        """
        Publish a reply message (async version)

        Returns a completion handle that can be awaited to ensure the message was delivered.
        """

        _UniffiConverterTypeMessageContext.check_lower(message_context)
        
        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_publish_to_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeMessageContext.lower(message_context),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeCompletionHandle.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def publish_with_params(self, destination: "Name",fanout: "int",data: "bytes",connection_out: "typing.Optional[int]",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> None:
        """
        Low-level publish with full control over all parameters (blocking version for FFI)

        This is an advanced method that provides complete control over routing and delivery.
        Most users should use `publish()` or `publish_to()` instead.

        # Arguments
        * `destination` - Target name to send to
        * `fanout` - Number of copies to send (for multicast)
        * `data` - The message payload bytes
        * `connection_out` - Optional specific connection ID to use
        * `payload_type` - Optional content type identifier
        * `metadata` - Optional key-value metadata pairs
        """

        _UniffiConverterTypeName.check_lower(destination)
        
        _UniffiConverterUInt32.check_lower(fanout)
        
        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalUInt64.check_lower(connection_out)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_publish_with_params,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(destination),
        _UniffiConverterUInt32.lower(fanout),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalUInt64.lower(connection_out),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata))





    async def publish_with_params_async(self, destination: "Name",fanout: "int",data: "bytes",connection_out: "typing.Optional[int]",payload_type: "typing.Optional[str]",metadata: "typing.Optional[dict[str, str]]") -> None:

        """
        Low-level publish with full control (async version)
        """

        _UniffiConverterTypeName.check_lower(destination)
        
        _UniffiConverterUInt32.check_lower(fanout)
        
        _UniffiConverterBytes.check_lower(data)
        
        _UniffiConverterOptionalUInt64.check_lower(connection_out)
        
        _UniffiConverterOptionalString.check_lower(payload_type)
        
        _UniffiConverterOptionalMapStringString.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_publish_with_params_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(destination),
        _UniffiConverterUInt32.lower(fanout),
        _UniffiConverterBytes.lower(data),
        _UniffiConverterOptionalUInt64.lower(connection_out),
        _UniffiConverterOptionalString.lower(payload_type),
        _UniffiConverterOptionalMapStringString.lower(metadata)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def remove(self, participant: "Name") -> "CompletionHandle":
        """
        Remove a participant from the session (blocking version)

        Returns a completion handle that can be awaited to ensure the removal completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        return _UniffiConverterTypeCompletionHandle.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_remove,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(participant))
        )





    def remove_and_wait(self, participant: "Name") -> None:
        """
        Remove a participant and wait for completion (blocking version)

        This method removes a participant and blocks until the removal completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_remove_and_wait,self._uniffi_clone_pointer(),
        _UniffiConverterTypeName.lower(participant))





    async def remove_and_wait_async(self, participant: "Name") -> None:

        """
        Remove a participant and wait for completion (async version)

        This method removes a participant and waits until the removal completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_remove_and_wait_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(participant)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_void,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_void,
            _UniffiLib.ffi_slim_bindings_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )



    async def remove_async(self, participant: "Name") -> "CompletionHandle":
        """
        Remove a participant from the session (async version)

        Returns a completion handle that can be awaited to ensure the removal completes.
        """

        _UniffiConverterTypeName.check_lower(participant)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_slim_bindings_fn_method_session_remove_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeName.lower(participant)
            ),
            _UniffiLib.ffi_slim_bindings_rust_future_poll_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_complete_pointer,
            _UniffiLib.ffi_slim_bindings_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeCompletionHandle.lift,
            
    # Error FFI converter
_UniffiConverterTypeSlimError,

        )




    def session_id(self, ) -> "int":
        """
        Get the session ID
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_session_id,self._uniffi_clone_pointer(),)
        )





    def session_type(self, ) -> "SessionType":
        """
        Get the session type (PointToPoint or Group)
        """

        return _UniffiConverterTypeSessionType.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_session_type,self._uniffi_clone_pointer(),)
        )





    def source(self, ) -> "Name":
        """
        Get the source name for this session
        """

        return _UniffiConverterTypeName.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_method_session_source,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSession:

    @staticmethod
    def lift(value: int):
        return Session._make_instance_(value)

    @staticmethod
    def check_lower(value: Session):
        if not isinstance(value, Session):
            raise TypeError("Expected Session instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SessionProtocol):
        if not isinstance(value, Session):
            raise TypeError("Expected Session instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SessionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class BasicAuth:
    """
    Basic authentication configuration
    """

    username: "str"
    password: "str"
    def __init__(self, *, username: "str", password: "str"):
        self.username = username
        self.password = password

    def __str__(self):
        return "BasicAuth(username={}, password={})".format(self.username, self.password)

    def __eq__(self, other):
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        return True

class _UniffiConverterTypeBasicAuth(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BasicAuth(
            username=_UniffiConverterString.read(buf),
            password=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.username)
        _UniffiConverterString.check_lower(value.password)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.username, buf)
        _UniffiConverterString.write(value.password, buf)


class BuildInfo:
    """
    Build information for the SLIM bindings
    """

    version: "str"
    """
    Semantic version (e.g., "0.7.0")
    """

    git_sha: "str"
    """
    Git commit hash (short)
    """

    build_date: "str"
    """
    Build date in ISO 8601 UTC format
    """

    profile: "str"
    """
    Build profile (debug/release)
    """

    def __init__(self, *, version: "str", git_sha: "str", build_date: "str", profile: "str"):
        self.version = version
        self.git_sha = git_sha
        self.build_date = build_date
        self.profile = profile

    def __str__(self):
        return "BuildInfo(version={}, git_sha={}, build_date={}, profile={})".format(self.version, self.git_sha, self.build_date, self.profile)

    def __eq__(self, other):
        if self.version != other.version:
            return False
        if self.git_sha != other.git_sha:
            return False
        if self.build_date != other.build_date:
            return False
        if self.profile != other.profile:
            return False
        return True

class _UniffiConverterTypeBuildInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuildInfo(
            version=_UniffiConverterString.read(buf),
            git_sha=_UniffiConverterString.read(buf),
            build_date=_UniffiConverterString.read(buf),
            profile=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.version)
        _UniffiConverterString.check_lower(value.git_sha)
        _UniffiConverterString.check_lower(value.build_date)
        _UniffiConverterString.check_lower(value.profile)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.version, buf)
        _UniffiConverterString.write(value.git_sha, buf)
        _UniffiConverterString.write(value.build_date, buf)
        _UniffiConverterString.write(value.profile, buf)


class ClientConfig:
    """
    Client configuration for connecting to a SLIM server
    """

    endpoint: "str"
    """
    The target endpoint the client will connect to
    """

    origin: "typing.Optional[str]"
    """
    Origin (HTTP Host authority override) for the client
    """

    server_name: "typing.Optional[str]"
    """
    Optional TLS SNI server name override
    """

    compression: "typing.Optional[CompressionType]"
    """
    Compression type
    """

    rate_limit: "typing.Optional[str]"
    """
    Rate limit string (e.g., "100/s" for 100 requests per second)
    """

    tls: "TlsClientConfig"
    """
    TLS client configuration
    """

    keepalive: "typing.Optional[KeepaliveConfig]"
    """
    Keepalive parameters
    """

    proxy: "ProxyConfig"
    """
    HTTP Proxy configuration
    """

    connect_timeout: "Duration"
    """
    Connection timeout
    """

    request_timeout: "Duration"
    """
    Request timeout
    """

    buffer_size: "typing.Optional[int]"
    """
    Read buffer size in bytes
    """

    headers: "dict[str, str]"
    """
    Headers associated with gRPC requests
    """

    auth: "ClientAuthenticationConfig"
    """
    Authentication configuration for outgoing RPCs
    """

    backoff: "BackoffConfig"
    """
    Backoff retry configuration
    """

    metadata: "typing.Optional[str]"
    """
    Arbitrary user-provided metadata as JSON string
    """

    def __init__(self, *, endpoint: "str", origin: "typing.Optional[str]", server_name: "typing.Optional[str]", compression: "typing.Optional[CompressionType]", rate_limit: "typing.Optional[str]", tls: "TlsClientConfig", keepalive: "typing.Optional[KeepaliveConfig]", proxy: "ProxyConfig", connect_timeout: "Duration", request_timeout: "Duration", buffer_size: "typing.Optional[int]", headers: "dict[str, str]", auth: "ClientAuthenticationConfig", backoff: "BackoffConfig", metadata: "typing.Optional[str]"):
        self.endpoint = endpoint
        self.origin = origin
        self.server_name = server_name
        self.compression = compression
        self.rate_limit = rate_limit
        self.tls = tls
        self.keepalive = keepalive
        self.proxy = proxy
        self.connect_timeout = connect_timeout
        self.request_timeout = request_timeout
        self.buffer_size = buffer_size
        self.headers = headers
        self.auth = auth
        self.backoff = backoff
        self.metadata = metadata

    def __str__(self):
        return "ClientConfig(endpoint={}, origin={}, server_name={}, compression={}, rate_limit={}, tls={}, keepalive={}, proxy={}, connect_timeout={}, request_timeout={}, buffer_size={}, headers={}, auth={}, backoff={}, metadata={})".format(self.endpoint, self.origin, self.server_name, self.compression, self.rate_limit, self.tls, self.keepalive, self.proxy, self.connect_timeout, self.request_timeout, self.buffer_size, self.headers, self.auth, self.backoff, self.metadata)

    def __eq__(self, other):
        if self.endpoint != other.endpoint:
            return False
        if self.origin != other.origin:
            return False
        if self.server_name != other.server_name:
            return False
        if self.compression != other.compression:
            return False
        if self.rate_limit != other.rate_limit:
            return False
        if self.tls != other.tls:
            return False
        if self.keepalive != other.keepalive:
            return False
        if self.proxy != other.proxy:
            return False
        if self.connect_timeout != other.connect_timeout:
            return False
        if self.request_timeout != other.request_timeout:
            return False
        if self.buffer_size != other.buffer_size:
            return False
        if self.headers != other.headers:
            return False
        if self.auth != other.auth:
            return False
        if self.backoff != other.backoff:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeClientConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientConfig(
            endpoint=_UniffiConverterString.read(buf),
            origin=_UniffiConverterOptionalString.read(buf),
            server_name=_UniffiConverterOptionalString.read(buf),
            compression=_UniffiConverterOptionalTypeCompressionType.read(buf),
            rate_limit=_UniffiConverterOptionalString.read(buf),
            tls=_UniffiConverterTypeTlsClientConfig.read(buf),
            keepalive=_UniffiConverterOptionalTypeKeepaliveConfig.read(buf),
            proxy=_UniffiConverterTypeProxyConfig.read(buf),
            connect_timeout=_UniffiConverterDuration.read(buf),
            request_timeout=_UniffiConverterDuration.read(buf),
            buffer_size=_UniffiConverterOptionalUInt64.read(buf),
            headers=_UniffiConverterMapStringString.read(buf),
            auth=_UniffiConverterTypeClientAuthenticationConfig.read(buf),
            backoff=_UniffiConverterTypeBackoffConfig.read(buf),
            metadata=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.endpoint)
        _UniffiConverterOptionalString.check_lower(value.origin)
        _UniffiConverterOptionalString.check_lower(value.server_name)
        _UniffiConverterOptionalTypeCompressionType.check_lower(value.compression)
        _UniffiConverterOptionalString.check_lower(value.rate_limit)
        _UniffiConverterTypeTlsClientConfig.check_lower(value.tls)
        _UniffiConverterOptionalTypeKeepaliveConfig.check_lower(value.keepalive)
        _UniffiConverterTypeProxyConfig.check_lower(value.proxy)
        _UniffiConverterDuration.check_lower(value.connect_timeout)
        _UniffiConverterDuration.check_lower(value.request_timeout)
        _UniffiConverterOptionalUInt64.check_lower(value.buffer_size)
        _UniffiConverterMapStringString.check_lower(value.headers)
        _UniffiConverterTypeClientAuthenticationConfig.check_lower(value.auth)
        _UniffiConverterTypeBackoffConfig.check_lower(value.backoff)
        _UniffiConverterOptionalString.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.endpoint, buf)
        _UniffiConverterOptionalString.write(value.origin, buf)
        _UniffiConverterOptionalString.write(value.server_name, buf)
        _UniffiConverterOptionalTypeCompressionType.write(value.compression, buf)
        _UniffiConverterOptionalString.write(value.rate_limit, buf)
        _UniffiConverterTypeTlsClientConfig.write(value.tls, buf)
        _UniffiConverterOptionalTypeKeepaliveConfig.write(value.keepalive, buf)
        _UniffiConverterTypeProxyConfig.write(value.proxy, buf)
        _UniffiConverterDuration.write(value.connect_timeout, buf)
        _UniffiConverterDuration.write(value.request_timeout, buf)
        _UniffiConverterOptionalUInt64.write(value.buffer_size, buf)
        _UniffiConverterMapStringString.write(value.headers, buf)
        _UniffiConverterTypeClientAuthenticationConfig.write(value.auth, buf)
        _UniffiConverterTypeBackoffConfig.write(value.backoff, buf)
        _UniffiConverterOptionalString.write(value.metadata, buf)


class ClientJwtAuth:
    """
    JWT authentication configuration for client-side signing
    """

    key: "JwtKeyType"
    """
    JWT key configuration (encoding key for signing)
    """

    audience: "typing.Optional[typing.List[str]]"
    """
    JWT audience claims to include
    """

    issuer: "typing.Optional[str]"
    """
    JWT issuer to include
    """

    subject: "typing.Optional[str]"
    """
    JWT subject to include
    """

    duration: "Duration"
    """
    Token validity duration (default: 3600 seconds)
    """

    def __init__(self, *, key: "JwtKeyType", audience: "typing.Optional[typing.List[str]]", issuer: "typing.Optional[str]", subject: "typing.Optional[str]", duration: "Duration"):
        self.key = key
        self.audience = audience
        self.issuer = issuer
        self.subject = subject
        self.duration = duration

    def __str__(self):
        return "ClientJwtAuth(key={}, audience={}, issuer={}, subject={}, duration={})".format(self.key, self.audience, self.issuer, self.subject, self.duration)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.audience != other.audience:
            return False
        if self.issuer != other.issuer:
            return False
        if self.subject != other.subject:
            return False
        if self.duration != other.duration:
            return False
        return True

class _UniffiConverterTypeClientJwtAuth(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientJwtAuth(
            key=_UniffiConverterTypeJwtKeyType.read(buf),
            audience=_UniffiConverterOptionalSequenceString.read(buf),
            issuer=_UniffiConverterOptionalString.read(buf),
            subject=_UniffiConverterOptionalString.read(buf),
            duration=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeJwtKeyType.check_lower(value.key)
        _UniffiConverterOptionalSequenceString.check_lower(value.audience)
        _UniffiConverterOptionalString.check_lower(value.issuer)
        _UniffiConverterOptionalString.check_lower(value.subject)
        _UniffiConverterDuration.check_lower(value.duration)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeJwtKeyType.write(value.key, buf)
        _UniffiConverterOptionalSequenceString.write(value.audience, buf)
        _UniffiConverterOptionalString.write(value.issuer, buf)
        _UniffiConverterOptionalString.write(value.subject, buf)
        _UniffiConverterDuration.write(value.duration, buf)


class DataplaneConfig:
    """
    DataPlane configuration wrapper for uniffi bindings
    """

    servers: "typing.List[ServerConfig]"
    """
    DataPlane GRPC server settings
    """

    clients: "typing.List[ClientConfig]"
    """
    DataPlane client configs
    """

    def __init__(self, *, servers: "typing.List[ServerConfig]", clients: "typing.List[ClientConfig]"):
        self.servers = servers
        self.clients = clients

    def __str__(self):
        return "DataplaneConfig(servers={}, clients={})".format(self.servers, self.clients)

    def __eq__(self, other):
        if self.servers != other.servers:
            return False
        if self.clients != other.clients:
            return False
        return True

class _UniffiConverterTypeDataplaneConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DataplaneConfig(
            servers=_UniffiConverterSequenceTypeServerConfig.read(buf),
            clients=_UniffiConverterSequenceTypeClientConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeServerConfig.check_lower(value.servers)
        _UniffiConverterSequenceTypeClientConfig.check_lower(value.clients)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeServerConfig.write(value.servers, buf)
        _UniffiConverterSequenceTypeClientConfig.write(value.clients, buf)


class ExponentialBackoff:
    """
    Exponential backoff configuration
    """

    base: "Duration"
    """
    Base delay
    """

    factor: "int"
    """
    Multiplication factor for each retry
    """

    max_delay: "Duration"
    """
    Maximum delay
    """

    max_attempts: "int"
    """
    Maximum number of retry attempts
    """

    jitter: "bool"
    """
    Whether to add random jitter to delays
    """

    def __init__(self, *, base: "Duration", factor: "int", max_delay: "Duration", max_attempts: "int", jitter: "bool"):
        self.base = base
        self.factor = factor
        self.max_delay = max_delay
        self.max_attempts = max_attempts
        self.jitter = jitter

    def __str__(self):
        return "ExponentialBackoff(base={}, factor={}, max_delay={}, max_attempts={}, jitter={})".format(self.base, self.factor, self.max_delay, self.max_attempts, self.jitter)

    def __eq__(self, other):
        if self.base != other.base:
            return False
        if self.factor != other.factor:
            return False
        if self.max_delay != other.max_delay:
            return False
        if self.max_attempts != other.max_attempts:
            return False
        if self.jitter != other.jitter:
            return False
        return True

class _UniffiConverterTypeExponentialBackoff(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExponentialBackoff(
            base=_UniffiConverterDuration.read(buf),
            factor=_UniffiConverterUInt64.read(buf),
            max_delay=_UniffiConverterDuration.read(buf),
            max_attempts=_UniffiConverterUInt64.read(buf),
            jitter=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterDuration.check_lower(value.base)
        _UniffiConverterUInt64.check_lower(value.factor)
        _UniffiConverterDuration.check_lower(value.max_delay)
        _UniffiConverterUInt64.check_lower(value.max_attempts)
        _UniffiConverterBool.check_lower(value.jitter)

    @staticmethod
    def write(value, buf):
        _UniffiConverterDuration.write(value.base, buf)
        _UniffiConverterUInt64.write(value.factor, buf)
        _UniffiConverterDuration.write(value.max_delay, buf)
        _UniffiConverterUInt64.write(value.max_attempts, buf)
        _UniffiConverterBool.write(value.jitter, buf)


class FixedIntervalBackoff:
    """
    Fixed interval backoff configuration
    """

    interval: "Duration"
    """
    Fixed interval between retries
    """

    max_attempts: "int"
    """
    Maximum number of retry attempts
    """

    def __init__(self, *, interval: "Duration", max_attempts: "int"):
        self.interval = interval
        self.max_attempts = max_attempts

    def __str__(self):
        return "FixedIntervalBackoff(interval={}, max_attempts={})".format(self.interval, self.max_attempts)

    def __eq__(self, other):
        if self.interval != other.interval:
            return False
        if self.max_attempts != other.max_attempts:
            return False
        return True

class _UniffiConverterTypeFixedIntervalBackoff(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FixedIntervalBackoff(
            interval=_UniffiConverterDuration.read(buf),
            max_attempts=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterDuration.check_lower(value.interval)
        _UniffiConverterUInt64.check_lower(value.max_attempts)

    @staticmethod
    def write(value, buf):
        _UniffiConverterDuration.write(value.interval, buf)
        _UniffiConverterUInt64.write(value.max_attempts, buf)


class JwtAuth:
    """
    JWT authentication configuration for server-side verification
    """

    key: "JwtKeyType"
    """
    JWT key configuration (decoding key for verification)
    """

    audience: "typing.Optional[typing.List[str]]"
    """
    JWT audience claims to verify
    """

    issuer: "typing.Optional[str]"
    """
    JWT issuer to verify
    """

    subject: "typing.Optional[str]"
    """
    JWT subject to verify
    """

    duration: "Duration"
    """
    Token validity duration (default: 3600 seconds)
    """

    def __init__(self, *, key: "JwtKeyType", audience: "typing.Optional[typing.List[str]]", issuer: "typing.Optional[str]", subject: "typing.Optional[str]", duration: "Duration"):
        self.key = key
        self.audience = audience
        self.issuer = issuer
        self.subject = subject
        self.duration = duration

    def __str__(self):
        return "JwtAuth(key={}, audience={}, issuer={}, subject={}, duration={})".format(self.key, self.audience, self.issuer, self.subject, self.duration)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.audience != other.audience:
            return False
        if self.issuer != other.issuer:
            return False
        if self.subject != other.subject:
            return False
        if self.duration != other.duration:
            return False
        return True

class _UniffiConverterTypeJwtAuth(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return JwtAuth(
            key=_UniffiConverterTypeJwtKeyType.read(buf),
            audience=_UniffiConverterOptionalSequenceString.read(buf),
            issuer=_UniffiConverterOptionalString.read(buf),
            subject=_UniffiConverterOptionalString.read(buf),
            duration=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeJwtKeyType.check_lower(value.key)
        _UniffiConverterOptionalSequenceString.check_lower(value.audience)
        _UniffiConverterOptionalString.check_lower(value.issuer)
        _UniffiConverterOptionalString.check_lower(value.subject)
        _UniffiConverterDuration.check_lower(value.duration)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeJwtKeyType.write(value.key, buf)
        _UniffiConverterOptionalSequenceString.write(value.audience, buf)
        _UniffiConverterOptionalString.write(value.issuer, buf)
        _UniffiConverterOptionalString.write(value.subject, buf)
        _UniffiConverterDuration.write(value.duration, buf)


class JwtKeyConfig:
    """
    JWT key configuration
    """

    algorithm: "JwtAlgorithm"
    """
    Algorithm used for signing/verifying the JWT
    """

    format: "JwtKeyFormat"
    """
    Key format - PEM, JWK or JWKS
    """

    key: "JwtKeyData"
    """
    Encoded key or file path
    """

    def __init__(self, *, algorithm: "JwtAlgorithm", format: "JwtKeyFormat", key: "JwtKeyData"):
        self.algorithm = algorithm
        self.format = format
        self.key = key

    def __str__(self):
        return "JwtKeyConfig(algorithm={}, format={}, key={})".format(self.algorithm, self.format, self.key)

    def __eq__(self, other):
        if self.algorithm != other.algorithm:
            return False
        if self.format != other.format:
            return False
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeJwtKeyConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return JwtKeyConfig(
            algorithm=_UniffiConverterTypeJwtAlgorithm.read(buf),
            format=_UniffiConverterTypeJwtKeyFormat.read(buf),
            key=_UniffiConverterTypeJwtKeyData.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeJwtAlgorithm.check_lower(value.algorithm)
        _UniffiConverterTypeJwtKeyFormat.check_lower(value.format)
        _UniffiConverterTypeJwtKeyData.check_lower(value.key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeJwtAlgorithm.write(value.algorithm, buf)
        _UniffiConverterTypeJwtKeyFormat.write(value.format, buf)
        _UniffiConverterTypeJwtKeyData.write(value.key, buf)


class KeepaliveConfig:
    """
    Keepalive configuration for the client
    """

    tcp_keepalive: "Duration"
    """
    TCP keepalive duration
    """

    http2_keepalive: "Duration"
    """
    HTTP2 keepalive duration
    """

    timeout: "Duration"
    """
    Keepalive timeout
    """

    keep_alive_while_idle: "bool"
    """
    Whether to permit keepalive without an active stream
    """

    def __init__(self, *, tcp_keepalive: "Duration", http2_keepalive: "Duration", timeout: "Duration", keep_alive_while_idle: "bool"):
        self.tcp_keepalive = tcp_keepalive
        self.http2_keepalive = http2_keepalive
        self.timeout = timeout
        self.keep_alive_while_idle = keep_alive_while_idle

    def __str__(self):
        return "KeepaliveConfig(tcp_keepalive={}, http2_keepalive={}, timeout={}, keep_alive_while_idle={})".format(self.tcp_keepalive, self.http2_keepalive, self.timeout, self.keep_alive_while_idle)

    def __eq__(self, other):
        if self.tcp_keepalive != other.tcp_keepalive:
            return False
        if self.http2_keepalive != other.http2_keepalive:
            return False
        if self.timeout != other.timeout:
            return False
        if self.keep_alive_while_idle != other.keep_alive_while_idle:
            return False
        return True

class _UniffiConverterTypeKeepaliveConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeepaliveConfig(
            tcp_keepalive=_UniffiConverterDuration.read(buf),
            http2_keepalive=_UniffiConverterDuration.read(buf),
            timeout=_UniffiConverterDuration.read(buf),
            keep_alive_while_idle=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterDuration.check_lower(value.tcp_keepalive)
        _UniffiConverterDuration.check_lower(value.http2_keepalive)
        _UniffiConverterDuration.check_lower(value.timeout)
        _UniffiConverterBool.check_lower(value.keep_alive_while_idle)

    @staticmethod
    def write(value, buf):
        _UniffiConverterDuration.write(value.tcp_keepalive, buf)
        _UniffiConverterDuration.write(value.http2_keepalive, buf)
        _UniffiConverterDuration.write(value.timeout, buf)
        _UniffiConverterBool.write(value.keep_alive_while_idle, buf)


class KeepaliveServerParameters:
    """
    Keepalive configuration for the server
    """

    max_connection_idle: "Duration"
    """
    Max connection idle time (time after which an idle connection is closed)
    """

    max_connection_age: "Duration"
    """
    Max connection age (maximum time a connection may exist before being closed)
    """

    max_connection_age_grace: "Duration"
    """
    Max connection age grace (additional time after max_connection_age before closing)
    """

    time: "Duration"
    """
    Keepalive ping frequency
    """

    timeout: "Duration"
    """
    Keepalive ping timeout (time to wait for ack)
    """

    def __init__(self, *, max_connection_idle: "Duration", max_connection_age: "Duration", max_connection_age_grace: "Duration", time: "Duration", timeout: "Duration"):
        self.max_connection_idle = max_connection_idle
        self.max_connection_age = max_connection_age
        self.max_connection_age_grace = max_connection_age_grace
        self.time = time
        self.timeout = timeout

    def __str__(self):
        return "KeepaliveServerParameters(max_connection_idle={}, max_connection_age={}, max_connection_age_grace={}, time={}, timeout={})".format(self.max_connection_idle, self.max_connection_age, self.max_connection_age_grace, self.time, self.timeout)

    def __eq__(self, other):
        if self.max_connection_idle != other.max_connection_idle:
            return False
        if self.max_connection_age != other.max_connection_age:
            return False
        if self.max_connection_age_grace != other.max_connection_age_grace:
            return False
        if self.time != other.time:
            return False
        if self.timeout != other.timeout:
            return False
        return True

class _UniffiConverterTypeKeepaliveServerParameters(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeepaliveServerParameters(
            max_connection_idle=_UniffiConverterDuration.read(buf),
            max_connection_age=_UniffiConverterDuration.read(buf),
            max_connection_age_grace=_UniffiConverterDuration.read(buf),
            time=_UniffiConverterDuration.read(buf),
            timeout=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterDuration.check_lower(value.max_connection_idle)
        _UniffiConverterDuration.check_lower(value.max_connection_age)
        _UniffiConverterDuration.check_lower(value.max_connection_age_grace)
        _UniffiConverterDuration.check_lower(value.time)
        _UniffiConverterDuration.check_lower(value.timeout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterDuration.write(value.max_connection_idle, buf)
        _UniffiConverterDuration.write(value.max_connection_age, buf)
        _UniffiConverterDuration.write(value.max_connection_age_grace, buf)
        _UniffiConverterDuration.write(value.time, buf)
        _UniffiConverterDuration.write(value.timeout, buf)


class MessageContext:
    """
    Generic message context for language bindings (UniFFI-compatible)

    Provides routing and descriptive metadata needed for replying,
    auditing, and instrumentation across different language bindings.
    This type is exported to foreign languages via UniFFI.
    """

    source_name: "Name"
    """
    Fully-qualified sender identity
    """

    destination_name: "typing.Optional[Name]"
    """
    Fully-qualified destination identity (may be empty for broadcast/group scenarios)
    """

    payload_type: "str"
    """
    Logical/semantic type (defaults to "msg" if unspecified)
    """

    metadata: "dict[str, str]"
    """
    Arbitrary key/value pairs supplied by the sender (e.g. tracing IDs)
    """

    input_connection: "int"
    """
    Numeric identifier of the inbound connection carrying the message
    """

    identity: "str"
    """
    Identity contained in the message
    """

    def __init__(self, *, source_name: "Name", destination_name: "typing.Optional[Name]", payload_type: "str", metadata: "dict[str, str]", input_connection: "int", identity: "str"):
        self.source_name = source_name
        self.destination_name = destination_name
        self.payload_type = payload_type
        self.metadata = metadata
        self.input_connection = input_connection
        self.identity = identity

    def __str__(self):
        return "MessageContext(source_name={}, destination_name={}, payload_type={}, metadata={}, input_connection={}, identity={})".format(self.source_name, self.destination_name, self.payload_type, self.metadata, self.input_connection, self.identity)

    def __eq__(self, other):
        if self.source_name != other.source_name:
            return False
        if self.destination_name != other.destination_name:
            return False
        if self.payload_type != other.payload_type:
            return False
        if self.metadata != other.metadata:
            return False
        if self.input_connection != other.input_connection:
            return False
        if self.identity != other.identity:
            return False
        return True

class _UniffiConverterTypeMessageContext(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MessageContext(
            source_name=_UniffiConverterTypeName.read(buf),
            destination_name=_UniffiConverterOptionalTypeName.read(buf),
            payload_type=_UniffiConverterString.read(buf),
            metadata=_UniffiConverterMapStringString.read(buf),
            input_connection=_UniffiConverterUInt64.read(buf),
            identity=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeName.check_lower(value.source_name)
        _UniffiConverterOptionalTypeName.check_lower(value.destination_name)
        _UniffiConverterString.check_lower(value.payload_type)
        _UniffiConverterMapStringString.check_lower(value.metadata)
        _UniffiConverterUInt64.check_lower(value.input_connection)
        _UniffiConverterString.check_lower(value.identity)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeName.write(value.source_name, buf)
        _UniffiConverterOptionalTypeName.write(value.destination_name, buf)
        _UniffiConverterString.write(value.payload_type, buf)
        _UniffiConverterMapStringString.write(value.metadata, buf)
        _UniffiConverterUInt64.write(value.input_connection, buf)
        _UniffiConverterString.write(value.identity, buf)


class ProxyConfig:
    """
    HTTP Proxy configuration
    """

    url: "typing.Optional[str]"
    """
    The HTTP proxy URL (e.g., "http://proxy.example.com:8080")
    """

    tls: "TlsClientConfig"
    """
    TLS configuration for proxy connection
    """

    username: "typing.Optional[str]"
    """
    Optional username for proxy authentication
    """

    password: "typing.Optional[str]"
    """
    Optional password for proxy authentication
    """

    headers: "dict[str, str]"
    """
    Headers to send with proxy requests
    """

    def __init__(self, *, url: "typing.Optional[str]", tls: "TlsClientConfig", username: "typing.Optional[str]", password: "typing.Optional[str]", headers: "dict[str, str]"):
        self.url = url
        self.tls = tls
        self.username = username
        self.password = password
        self.headers = headers

    def __str__(self):
        return "ProxyConfig(url={}, tls={}, username={}, password={}, headers={})".format(self.url, self.tls, self.username, self.password, self.headers)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.tls != other.tls:
            return False
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        if self.headers != other.headers:
            return False
        return True

class _UniffiConverterTypeProxyConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProxyConfig(
            url=_UniffiConverterOptionalString.read(buf),
            tls=_UniffiConverterTypeTlsClientConfig.read(buf),
            username=_UniffiConverterOptionalString.read(buf),
            password=_UniffiConverterOptionalString.read(buf),
            headers=_UniffiConverterMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.url)
        _UniffiConverterTypeTlsClientConfig.check_lower(value.tls)
        _UniffiConverterOptionalString.check_lower(value.username)
        _UniffiConverterOptionalString.check_lower(value.password)
        _UniffiConverterMapStringString.check_lower(value.headers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.url, buf)
        _UniffiConverterTypeTlsClientConfig.write(value.tls, buf)
        _UniffiConverterOptionalString.write(value.username, buf)
        _UniffiConverterOptionalString.write(value.password, buf)
        _UniffiConverterMapStringString.write(value.headers, buf)


class ReceivedMessage:
    """
    Received message containing context and payload
    """

    context: "MessageContext"
    payload: "bytes"
    def __init__(self, *, context: "MessageContext", payload: "bytes"):
        self.context = context
        self.payload = payload

    def __str__(self):
        return "ReceivedMessage(context={}, payload={})".format(self.context, self.payload)

    def __eq__(self, other):
        if self.context != other.context:
            return False
        if self.payload != other.payload:
            return False
        return True

class _UniffiConverterTypeReceivedMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivedMessage(
            context=_UniffiConverterTypeMessageContext.read(buf),
            payload=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeMessageContext.check_lower(value.context)
        _UniffiConverterBytes.check_lower(value.payload)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeMessageContext.write(value.context, buf)
        _UniffiConverterBytes.write(value.payload, buf)


class RuntimeConfig:
    """
    Runtime configuration for the SLIM bindings

    Controls the Tokio runtime behavior including thread count, naming, and shutdown timeout.
    """

    n_cores: "int"
    """
    Number of cores to use for the runtime (0 = use all available cores)
    """

    thread_name: "str"
    """
    Thread name prefix for the runtime
    """

    drain_timeout: "Duration"
    """
    Timeout duration for draining services during shutdown
    """

    def __init__(self, *, n_cores: "int", thread_name: "str", drain_timeout: "Duration"):
        self.n_cores = n_cores
        self.thread_name = thread_name
        self.drain_timeout = drain_timeout

    def __str__(self):
        return "RuntimeConfig(n_cores={}, thread_name={}, drain_timeout={})".format(self.n_cores, self.thread_name, self.drain_timeout)

    def __eq__(self, other):
        if self.n_cores != other.n_cores:
            return False
        if self.thread_name != other.thread_name:
            return False
        if self.drain_timeout != other.drain_timeout:
            return False
        return True

class _UniffiConverterTypeRuntimeConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RuntimeConfig(
            n_cores=_UniffiConverterUInt64.read(buf),
            thread_name=_UniffiConverterString.read(buf),
            drain_timeout=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.n_cores)
        _UniffiConverterString.check_lower(value.thread_name)
        _UniffiConverterDuration.check_lower(value.drain_timeout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.n_cores, buf)
        _UniffiConverterString.write(value.thread_name, buf)
        _UniffiConverterDuration.write(value.drain_timeout, buf)


class ServerConfig:
    """
    Server configuration for running a SLIM server
    """

    endpoint: "str"
    """
    Endpoint address to listen on (e.g., "0.0.0.0:50051" or "[::]:50051")
    """

    tls: "TlsServerConfig"
    """
    TLS server configuration
    """

    http2_only: "bool"
    """
    Use HTTP/2 only (default: true)
    """

    max_frame_size: "typing.Optional[int]"
    """
    Maximum size (in MiB) of messages accepted by the server
    """

    max_concurrent_streams: "typing.Optional[int]"
    """
    Maximum number of concurrent streams per connection
    """

    max_header_list_size: "typing.Optional[int]"
    """
    Maximum header list size in bytes
    """

    read_buffer_size: "typing.Optional[int]"
    """
    Read buffer size in bytes
    """

    write_buffer_size: "typing.Optional[int]"
    """
    Write buffer size in bytes
    """

    keepalive: "KeepaliveServerParameters"
    """
    Keepalive parameters
    """

    auth: "ServerAuthenticationConfig"
    """
    Authentication configuration for incoming requests
    """

    metadata: "typing.Optional[str]"
    """
    Arbitrary user-provided metadata as JSON string
    """

    def __init__(self, *, endpoint: "str", tls: "TlsServerConfig", http2_only: "bool", max_frame_size: "typing.Optional[int]", max_concurrent_streams: "typing.Optional[int]", max_header_list_size: "typing.Optional[int]", read_buffer_size: "typing.Optional[int]", write_buffer_size: "typing.Optional[int]", keepalive: "KeepaliveServerParameters", auth: "ServerAuthenticationConfig", metadata: "typing.Optional[str]"):
        self.endpoint = endpoint
        self.tls = tls
        self.http2_only = http2_only
        self.max_frame_size = max_frame_size
        self.max_concurrent_streams = max_concurrent_streams
        self.max_header_list_size = max_header_list_size
        self.read_buffer_size = read_buffer_size
        self.write_buffer_size = write_buffer_size
        self.keepalive = keepalive
        self.auth = auth
        self.metadata = metadata

    def __str__(self):
        return "ServerConfig(endpoint={}, tls={}, http2_only={}, max_frame_size={}, max_concurrent_streams={}, max_header_list_size={}, read_buffer_size={}, write_buffer_size={}, keepalive={}, auth={}, metadata={})".format(self.endpoint, self.tls, self.http2_only, self.max_frame_size, self.max_concurrent_streams, self.max_header_list_size, self.read_buffer_size, self.write_buffer_size, self.keepalive, self.auth, self.metadata)

    def __eq__(self, other):
        if self.endpoint != other.endpoint:
            return False
        if self.tls != other.tls:
            return False
        if self.http2_only != other.http2_only:
            return False
        if self.max_frame_size != other.max_frame_size:
            return False
        if self.max_concurrent_streams != other.max_concurrent_streams:
            return False
        if self.max_header_list_size != other.max_header_list_size:
            return False
        if self.read_buffer_size != other.read_buffer_size:
            return False
        if self.write_buffer_size != other.write_buffer_size:
            return False
        if self.keepalive != other.keepalive:
            return False
        if self.auth != other.auth:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeServerConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ServerConfig(
            endpoint=_UniffiConverterString.read(buf),
            tls=_UniffiConverterTypeTlsServerConfig.read(buf),
            http2_only=_UniffiConverterBool.read(buf),
            max_frame_size=_UniffiConverterOptionalUInt32.read(buf),
            max_concurrent_streams=_UniffiConverterOptionalUInt32.read(buf),
            max_header_list_size=_UniffiConverterOptionalUInt32.read(buf),
            read_buffer_size=_UniffiConverterOptionalUInt64.read(buf),
            write_buffer_size=_UniffiConverterOptionalUInt64.read(buf),
            keepalive=_UniffiConverterTypeKeepaliveServerParameters.read(buf),
            auth=_UniffiConverterTypeServerAuthenticationConfig.read(buf),
            metadata=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.endpoint)
        _UniffiConverterTypeTlsServerConfig.check_lower(value.tls)
        _UniffiConverterBool.check_lower(value.http2_only)
        _UniffiConverterOptionalUInt32.check_lower(value.max_frame_size)
        _UniffiConverterOptionalUInt32.check_lower(value.max_concurrent_streams)
        _UniffiConverterOptionalUInt32.check_lower(value.max_header_list_size)
        _UniffiConverterOptionalUInt64.check_lower(value.read_buffer_size)
        _UniffiConverterOptionalUInt64.check_lower(value.write_buffer_size)
        _UniffiConverterTypeKeepaliveServerParameters.check_lower(value.keepalive)
        _UniffiConverterTypeServerAuthenticationConfig.check_lower(value.auth)
        _UniffiConverterOptionalString.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.endpoint, buf)
        _UniffiConverterTypeTlsServerConfig.write(value.tls, buf)
        _UniffiConverterBool.write(value.http2_only, buf)
        _UniffiConverterOptionalUInt32.write(value.max_frame_size, buf)
        _UniffiConverterOptionalUInt32.write(value.max_concurrent_streams, buf)
        _UniffiConverterOptionalUInt32.write(value.max_header_list_size, buf)
        _UniffiConverterOptionalUInt64.write(value.read_buffer_size, buf)
        _UniffiConverterOptionalUInt64.write(value.write_buffer_size, buf)
        _UniffiConverterTypeKeepaliveServerParameters.write(value.keepalive, buf)
        _UniffiConverterTypeServerAuthenticationConfig.write(value.auth, buf)
        _UniffiConverterOptionalString.write(value.metadata, buf)


class ServiceConfig:
    """
    Service configuration wrapper for uniffi bindings
    """

    node_id: "typing.Optional[str]"
    """
    Optional node ID for the service
    """

    group_name: "typing.Optional[str]"
    """
    Optional group name for the service
    """

    dataplane: "DataplaneConfig"
    """
    DataPlane configuration (servers and clients)
    """

    def __init__(self, *, node_id: "typing.Optional[str]", group_name: "typing.Optional[str]", dataplane: "DataplaneConfig"):
        self.node_id = node_id
        self.group_name = group_name
        self.dataplane = dataplane

    def __str__(self):
        return "ServiceConfig(node_id={}, group_name={}, dataplane={})".format(self.node_id, self.group_name, self.dataplane)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.group_name != other.group_name:
            return False
        if self.dataplane != other.dataplane:
            return False
        return True

class _UniffiConverterTypeServiceConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ServiceConfig(
            node_id=_UniffiConverterOptionalString.read(buf),
            group_name=_UniffiConverterOptionalString.read(buf),
            dataplane=_UniffiConverterTypeDataplaneConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.node_id)
        _UniffiConverterOptionalString.check_lower(value.group_name)
        _UniffiConverterTypeDataplaneConfig.check_lower(value.dataplane)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.node_id, buf)
        _UniffiConverterOptionalString.write(value.group_name, buf)
        _UniffiConverterTypeDataplaneConfig.write(value.dataplane, buf)


class SessionConfig:
    """
    Session configuration
    """

    session_type: "SessionType"
    """
    Session type (PointToPoint or Group)
    """

    enable_mls: "bool"
    """
    Enable MLS encryption for this session
    """

    max_retries: "typing.Optional[int]"
    """
    Maximum number of retries for message transmission (None = use default)
    """

    interval: "typing.Optional[Duration]"
    """
    Interval between retries in milliseconds (None = use default)
    """

    metadata: "dict[str, str]"
    """
    Custom metadata key-value pairs for the session
    """

    def __init__(self, *, session_type: "SessionType", enable_mls: "bool", max_retries: "typing.Optional[int]", interval: "typing.Optional[Duration]", metadata: "dict[str, str]"):
        self.session_type = session_type
        self.enable_mls = enable_mls
        self.max_retries = max_retries
        self.interval = interval
        self.metadata = metadata

    def __str__(self):
        return "SessionConfig(session_type={}, enable_mls={}, max_retries={}, interval={}, metadata={})".format(self.session_type, self.enable_mls, self.max_retries, self.interval, self.metadata)

    def __eq__(self, other):
        if self.session_type != other.session_type:
            return False
        if self.enable_mls != other.enable_mls:
            return False
        if self.max_retries != other.max_retries:
            return False
        if self.interval != other.interval:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeSessionConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SessionConfig(
            session_type=_UniffiConverterTypeSessionType.read(buf),
            enable_mls=_UniffiConverterBool.read(buf),
            max_retries=_UniffiConverterOptionalUInt32.read(buf),
            interval=_UniffiConverterOptionalDuration.read(buf),
            metadata=_UniffiConverterMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeSessionType.check_lower(value.session_type)
        _UniffiConverterBool.check_lower(value.enable_mls)
        _UniffiConverterOptionalUInt32.check_lower(value.max_retries)
        _UniffiConverterOptionalDuration.check_lower(value.interval)
        _UniffiConverterMapStringString.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSessionType.write(value.session_type, buf)
        _UniffiConverterBool.write(value.enable_mls, buf)
        _UniffiConverterOptionalUInt32.write(value.max_retries, buf)
        _UniffiConverterOptionalDuration.write(value.interval, buf)
        _UniffiConverterMapStringString.write(value.metadata, buf)


class SessionWithCompletion:
    """
    Result of creating a session, containing the session context and a completion handle

    The completion handle should be awaited to ensure the session is fully established.
    """

    session: "Session"
    """
    The session context for performing operations
    """

    completion: "CompletionHandle"
    """
    Completion handle to wait for session establishment
    """

    def __init__(self, *, session: "Session", completion: "CompletionHandle"):
        self.session = session
        self.completion = completion

    def __str__(self):
        return "SessionWithCompletion(session={}, completion={})".format(self.session, self.completion)

    def __eq__(self, other):
        if self.session != other.session:
            return False
        if self.completion != other.completion:
            return False
        return True

class _UniffiConverterTypeSessionWithCompletion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SessionWithCompletion(
            session=_UniffiConverterTypeSession.read(buf),
            completion=_UniffiConverterTypeCompletionHandle.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeSession.check_lower(value.session)
        _UniffiConverterTypeCompletionHandle.check_lower(value.completion)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSession.write(value.session, buf)
        _UniffiConverterTypeCompletionHandle.write(value.completion, buf)


class SpireConfig:
    """
    SPIRE configuration for SPIFFE Workload API integration
    """

    socket_path: "typing.Optional[str]"
    """
    Path to the SPIFFE Workload API socket (None => use SPIFFE_ENDPOINT_SOCKET env var)
    """

    target_spiffe_id: "typing.Optional[str]"
    """
    Optional target SPIFFE ID when requesting JWT SVIDs
    """

    jwt_audiences: "typing.List[str]"
    """
    Audiences to request/verify for JWT SVIDs
    """

    trust_domains: "typing.List[str]"
    """
    Optional trust domains override for X.509 bundle retrieval
    """

    def __init__(self, *, socket_path: "typing.Optional[str]", target_spiffe_id: "typing.Optional[str]", jwt_audiences: "typing.List[str]", trust_domains: "typing.List[str]"):
        self.socket_path = socket_path
        self.target_spiffe_id = target_spiffe_id
        self.jwt_audiences = jwt_audiences
        self.trust_domains = trust_domains

    def __str__(self):
        return "SpireConfig(socket_path={}, target_spiffe_id={}, jwt_audiences={}, trust_domains={})".format(self.socket_path, self.target_spiffe_id, self.jwt_audiences, self.trust_domains)

    def __eq__(self, other):
        if self.socket_path != other.socket_path:
            return False
        if self.target_spiffe_id != other.target_spiffe_id:
            return False
        if self.jwt_audiences != other.jwt_audiences:
            return False
        if self.trust_domains != other.trust_domains:
            return False
        return True

class _UniffiConverterTypeSpireConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SpireConfig(
            socket_path=_UniffiConverterOptionalString.read(buf),
            target_spiffe_id=_UniffiConverterOptionalString.read(buf),
            jwt_audiences=_UniffiConverterSequenceString.read(buf),
            trust_domains=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.socket_path)
        _UniffiConverterOptionalString.check_lower(value.target_spiffe_id)
        _UniffiConverterSequenceString.check_lower(value.jwt_audiences)
        _UniffiConverterSequenceString.check_lower(value.trust_domains)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.socket_path, buf)
        _UniffiConverterOptionalString.write(value.target_spiffe_id, buf)
        _UniffiConverterSequenceString.write(value.jwt_audiences, buf)
        _UniffiConverterSequenceString.write(value.trust_domains, buf)


class StaticJwtAuth:
    """
    Static JWT (Bearer token) authentication configuration
    The token is loaded from a file and automatically reloaded when changed
    """

    token_file: "str"
    """
    Path to file containing the JWT token
    """

    duration: "Duration"
    """
    Duration for caching the token before re-reading from file (default: 3600 seconds)
    """

    def __init__(self, *, token_file: "str", duration: "Duration"):
        self.token_file = token_file
        self.duration = duration

    def __str__(self):
        return "StaticJwtAuth(token_file={}, duration={})".format(self.token_file, self.duration)

    def __eq__(self, other):
        if self.token_file != other.token_file:
            return False
        if self.duration != other.duration:
            return False
        return True

class _UniffiConverterTypeStaticJwtAuth(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StaticJwtAuth(
            token_file=_UniffiConverterString.read(buf),
            duration=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.token_file)
        _UniffiConverterDuration.check_lower(value.duration)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.token_file, buf)
        _UniffiConverterDuration.write(value.duration, buf)


class TlsClientConfig:
    """
    TLS configuration for client connections
    """

    insecure: "bool"
    """
    Disable TLS entirely (plain text connection)
    """

    insecure_skip_verify: "bool"
    """
    Skip server certificate verification (enables TLS but doesn't verify certs)
    WARNING: Only use for testing - insecure in production!
    """

    source: "TlsSource"
    """
    Certificate and key source for client authentication
    """

    ca_source: "CaSource"
    """
    CA certificate source for verifying server certificates
    """

    include_system_ca_certs_pool: "bool"
    """
    Include system CA certificates pool (default: true)
    """

    tls_version: "str"
    """
    TLS version to use: "tls1.2" or "tls1.3" (default: "tls1.3")
    """

    def __init__(self, *, insecure: "bool", insecure_skip_verify: "bool", source: "TlsSource", ca_source: "CaSource", include_system_ca_certs_pool: "bool", tls_version: "str"):
        self.insecure = insecure
        self.insecure_skip_verify = insecure_skip_verify
        self.source = source
        self.ca_source = ca_source
        self.include_system_ca_certs_pool = include_system_ca_certs_pool
        self.tls_version = tls_version

    def __str__(self):
        return "TlsClientConfig(insecure={}, insecure_skip_verify={}, source={}, ca_source={}, include_system_ca_certs_pool={}, tls_version={})".format(self.insecure, self.insecure_skip_verify, self.source, self.ca_source, self.include_system_ca_certs_pool, self.tls_version)

    def __eq__(self, other):
        if self.insecure != other.insecure:
            return False
        if self.insecure_skip_verify != other.insecure_skip_verify:
            return False
        if self.source != other.source:
            return False
        if self.ca_source != other.ca_source:
            return False
        if self.include_system_ca_certs_pool != other.include_system_ca_certs_pool:
            return False
        if self.tls_version != other.tls_version:
            return False
        return True

class _UniffiConverterTypeTlsClientConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TlsClientConfig(
            insecure=_UniffiConverterBool.read(buf),
            insecure_skip_verify=_UniffiConverterBool.read(buf),
            source=_UniffiConverterTypeTlsSource.read(buf),
            ca_source=_UniffiConverterTypeCaSource.read(buf),
            include_system_ca_certs_pool=_UniffiConverterBool.read(buf),
            tls_version=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.insecure)
        _UniffiConverterBool.check_lower(value.insecure_skip_verify)
        _UniffiConverterTypeTlsSource.check_lower(value.source)
        _UniffiConverterTypeCaSource.check_lower(value.ca_source)
        _UniffiConverterBool.check_lower(value.include_system_ca_certs_pool)
        _UniffiConverterString.check_lower(value.tls_version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.insecure, buf)
        _UniffiConverterBool.write(value.insecure_skip_verify, buf)
        _UniffiConverterTypeTlsSource.write(value.source, buf)
        _UniffiConverterTypeCaSource.write(value.ca_source, buf)
        _UniffiConverterBool.write(value.include_system_ca_certs_pool, buf)
        _UniffiConverterString.write(value.tls_version, buf)


class TlsServerConfig:
    """
    TLS configuration for server connections
    """

    insecure: "bool"
    """
    Disable TLS entirely (plain text connection)
    """

    source: "TlsSource"
    """
    Certificate and key source for server authentication
    """

    client_ca: "CaSource"
    """
    CA certificate source for verifying client certificates
    """

    include_system_ca_certs_pool: "bool"
    """
    Include system CA certificates pool (default: true)
    """

    tls_version: "str"
    """
    TLS version to use: "tls1.2" or "tls1.3" (default: "tls1.3")
    """

    reload_client_ca_file: "bool"
    """
    Reload client CA file when modified
    """

    def __init__(self, *, insecure: "bool", source: "TlsSource", client_ca: "CaSource", include_system_ca_certs_pool: "bool", tls_version: "str", reload_client_ca_file: "bool"):
        self.insecure = insecure
        self.source = source
        self.client_ca = client_ca
        self.include_system_ca_certs_pool = include_system_ca_certs_pool
        self.tls_version = tls_version
        self.reload_client_ca_file = reload_client_ca_file

    def __str__(self):
        return "TlsServerConfig(insecure={}, source={}, client_ca={}, include_system_ca_certs_pool={}, tls_version={}, reload_client_ca_file={})".format(self.insecure, self.source, self.client_ca, self.include_system_ca_certs_pool, self.tls_version, self.reload_client_ca_file)

    def __eq__(self, other):
        if self.insecure != other.insecure:
            return False
        if self.source != other.source:
            return False
        if self.client_ca != other.client_ca:
            return False
        if self.include_system_ca_certs_pool != other.include_system_ca_certs_pool:
            return False
        if self.tls_version != other.tls_version:
            return False
        if self.reload_client_ca_file != other.reload_client_ca_file:
            return False
        return True

class _UniffiConverterTypeTlsServerConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TlsServerConfig(
            insecure=_UniffiConverterBool.read(buf),
            source=_UniffiConverterTypeTlsSource.read(buf),
            client_ca=_UniffiConverterTypeCaSource.read(buf),
            include_system_ca_certs_pool=_UniffiConverterBool.read(buf),
            tls_version=_UniffiConverterString.read(buf),
            reload_client_ca_file=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.insecure)
        _UniffiConverterTypeTlsSource.check_lower(value.source)
        _UniffiConverterTypeCaSource.check_lower(value.client_ca)
        _UniffiConverterBool.check_lower(value.include_system_ca_certs_pool)
        _UniffiConverterString.check_lower(value.tls_version)
        _UniffiConverterBool.check_lower(value.reload_client_ca_file)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.insecure, buf)
        _UniffiConverterTypeTlsSource.write(value.source, buf)
        _UniffiConverterTypeCaSource.write(value.client_ca, buf)
        _UniffiConverterBool.write(value.include_system_ca_certs_pool, buf)
        _UniffiConverterString.write(value.tls_version, buf)
        _UniffiConverterBool.write(value.reload_client_ca_file, buf)


class TracingConfig:
    """
    Tracing/logging configuration for the SLIM bindings

    Controls logging behavior including log level, thread name/ID display, and filters.
    """

    log_level: "str"
    """
    Log level (e.g., "debug", "info", "warn", "error")
    """

    display_thread_names: "bool"
    """
    Whether to display thread names in logs
    """

    display_thread_ids: "bool"
    """
    Whether to display thread IDs in logs
    """

    filters: "typing.List[str]"
    """
    List of tracing filter directives (e.g., ["slim=debug", "tokio=info"])
    """

    def __init__(self, *, log_level: "str", display_thread_names: "bool", display_thread_ids: "bool", filters: "typing.List[str]"):
        self.log_level = log_level
        self.display_thread_names = display_thread_names
        self.display_thread_ids = display_thread_ids
        self.filters = filters

    def __str__(self):
        return "TracingConfig(log_level={}, display_thread_names={}, display_thread_ids={}, filters={})".format(self.log_level, self.display_thread_names, self.display_thread_ids, self.filters)

    def __eq__(self, other):
        if self.log_level != other.log_level:
            return False
        if self.display_thread_names != other.display_thread_names:
            return False
        if self.display_thread_ids != other.display_thread_ids:
            return False
        if self.filters != other.filters:
            return False
        return True

class _UniffiConverterTypeTracingConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TracingConfig(
            log_level=_UniffiConverterString.read(buf),
            display_thread_names=_UniffiConverterBool.read(buf),
            display_thread_ids=_UniffiConverterBool.read(buf),
            filters=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.log_level)
        _UniffiConverterBool.check_lower(value.display_thread_names)
        _UniffiConverterBool.check_lower(value.display_thread_ids)
        _UniffiConverterSequenceString.check_lower(value.filters)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.log_level, buf)
        _UniffiConverterBool.write(value.display_thread_names, buf)
        _UniffiConverterBool.write(value.display_thread_ids, buf)
        _UniffiConverterSequenceString.write(value.filters, buf)





class BackoffConfig:
    """
    Backoff retry configuration
    """

    def __init__(self):
        raise RuntimeError("BackoffConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EXPONENTIAL:
        config: "ExponentialBackoff"

        def __init__(self,config: "ExponentialBackoff"):
            self.config = config

        def __str__(self):
            return "BackoffConfig.EXPONENTIAL(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_exponential():
                return False
            if self.config != other.config:
                return False
            return True
    
    class FIXED_INTERVAL:
        config: "FixedIntervalBackoff"

        def __init__(self,config: "FixedIntervalBackoff"):
            self.config = config

        def __str__(self):
            return "BackoffConfig.FIXED_INTERVAL(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_fixed_interval():
                return False
            if self.config != other.config:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_exponential(self) -> bool:
        return isinstance(self, BackoffConfig.EXPONENTIAL)
    def is_fixed_interval(self) -> bool:
        return isinstance(self, BackoffConfig.FIXED_INTERVAL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
BackoffConfig.EXPONENTIAL = type("BackoffConfig.EXPONENTIAL", (BackoffConfig.EXPONENTIAL, BackoffConfig,), {})  # type: ignore
BackoffConfig.FIXED_INTERVAL = type("BackoffConfig.FIXED_INTERVAL", (BackoffConfig.FIXED_INTERVAL, BackoffConfig,), {})  # type: ignore




class _UniffiConverterTypeBackoffConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BackoffConfig.EXPONENTIAL(
                _UniffiConverterTypeExponentialBackoff.read(buf),
            )
        if variant == 2:
            return BackoffConfig.FIXED_INTERVAL(
                _UniffiConverterTypeFixedIntervalBackoff.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_exponential():
            _UniffiConverterTypeExponentialBackoff.check_lower(value.config)
            return
        if value.is_fixed_interval():
            _UniffiConverterTypeFixedIntervalBackoff.check_lower(value.config)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_exponential():
            buf.write_i32(1)
            _UniffiConverterTypeExponentialBackoff.write(value.config, buf)
        if value.is_fixed_interval():
            buf.write_i32(2)
            _UniffiConverterTypeFixedIntervalBackoff.write(value.config, buf)







class CaSource:
    """
    CA certificate source configuration
    """

    def __init__(self):
        raise RuntimeError("CaSource cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FILE:
        """
        Load CA from file
        """

        path: "str"

        def __init__(self,path: "str"):
            self.path = path

        def __str__(self):
            return "CaSource.FILE(path={})".format(self.path)

        def __eq__(self, other):
            if not other.is_file():
                return False
            if self.path != other.path:
                return False
            return True
    
    class PEM:
        """
        Load CA from PEM string
        """

        data: "str"

        def __init__(self,data: "str"):
            self.data = data

        def __str__(self):
            return "CaSource.PEM(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_pem():
                return False
            if self.data != other.data:
                return False
            return True
    
    class SPIRE:
        """
        Load CA from SPIRE Workload API
        """

        config: "SpireConfig"

        def __init__(self,config: "SpireConfig"):
            self.config = config

        def __str__(self):
            return "CaSource.SPIRE(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_spire():
                return False
            if self.config != other.config:
                return False
            return True
    
    class NONE:
        """
        No CA configured
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CaSource.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_file(self) -> bool:
        return isinstance(self, CaSource.FILE)
    def is_pem(self) -> bool:
        return isinstance(self, CaSource.PEM)
    def is_spire(self) -> bool:
        return isinstance(self, CaSource.SPIRE)
    def is_none(self) -> bool:
        return isinstance(self, CaSource.NONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CaSource.FILE = type("CaSource.FILE", (CaSource.FILE, CaSource,), {})  # type: ignore
CaSource.PEM = type("CaSource.PEM", (CaSource.PEM, CaSource,), {})  # type: ignore
CaSource.SPIRE = type("CaSource.SPIRE", (CaSource.SPIRE, CaSource,), {})  # type: ignore
CaSource.NONE = type("CaSource.NONE", (CaSource.NONE, CaSource,), {})  # type: ignore




class _UniffiConverterTypeCaSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CaSource.FILE(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return CaSource.PEM(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return CaSource.SPIRE(
                _UniffiConverterTypeSpireConfig.read(buf),
            )
        if variant == 4:
            return CaSource.NONE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_file():
            _UniffiConverterString.check_lower(value.path)
            return
        if value.is_pem():
            _UniffiConverterString.check_lower(value.data)
            return
        if value.is_spire():
            _UniffiConverterTypeSpireConfig.check_lower(value.config)
            return
        if value.is_none():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_file():
            buf.write_i32(1)
            _UniffiConverterString.write(value.path, buf)
        if value.is_pem():
            buf.write_i32(2)
            _UniffiConverterString.write(value.data, buf)
        if value.is_spire():
            buf.write_i32(3)
            _UniffiConverterTypeSpireConfig.write(value.config, buf)
        if value.is_none():
            buf.write_i32(4)







class ClientAuthenticationConfig:
    """
    Authentication configuration enum for client
    """

    def __init__(self):
        raise RuntimeError("ClientAuthenticationConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BASIC:
        config: "BasicAuth"

        def __init__(self,config: "BasicAuth"):
            self.config = config

        def __str__(self):
            return "ClientAuthenticationConfig.BASIC(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_basic():
                return False
            if self.config != other.config:
                return False
            return True
    
    class STATIC_JWT:
        config: "StaticJwtAuth"

        def __init__(self,config: "StaticJwtAuth"):
            self.config = config

        def __str__(self):
            return "ClientAuthenticationConfig.STATIC_JWT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_static_jwt():
                return False
            if self.config != other.config:
                return False
            return True
    
    class JWT:
        config: "ClientJwtAuth"

        def __init__(self,config: "ClientJwtAuth"):
            self.config = config

        def __str__(self):
            return "ClientAuthenticationConfig.JWT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_jwt():
                return False
            if self.config != other.config:
                return False
            return True
    
    class NONE:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClientAuthenticationConfig.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_basic(self) -> bool:
        return isinstance(self, ClientAuthenticationConfig.BASIC)
    def is_static_jwt(self) -> bool:
        return isinstance(self, ClientAuthenticationConfig.STATIC_JWT)
    def is_jwt(self) -> bool:
        return isinstance(self, ClientAuthenticationConfig.JWT)
    def is_none(self) -> bool:
        return isinstance(self, ClientAuthenticationConfig.NONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClientAuthenticationConfig.BASIC = type("ClientAuthenticationConfig.BASIC", (ClientAuthenticationConfig.BASIC, ClientAuthenticationConfig,), {})  # type: ignore
ClientAuthenticationConfig.STATIC_JWT = type("ClientAuthenticationConfig.STATIC_JWT", (ClientAuthenticationConfig.STATIC_JWT, ClientAuthenticationConfig,), {})  # type: ignore
ClientAuthenticationConfig.JWT = type("ClientAuthenticationConfig.JWT", (ClientAuthenticationConfig.JWT, ClientAuthenticationConfig,), {})  # type: ignore
ClientAuthenticationConfig.NONE = type("ClientAuthenticationConfig.NONE", (ClientAuthenticationConfig.NONE, ClientAuthenticationConfig,), {})  # type: ignore




class _UniffiConverterTypeClientAuthenticationConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClientAuthenticationConfig.BASIC(
                _UniffiConverterTypeBasicAuth.read(buf),
            )
        if variant == 2:
            return ClientAuthenticationConfig.STATIC_JWT(
                _UniffiConverterTypeStaticJwtAuth.read(buf),
            )
        if variant == 3:
            return ClientAuthenticationConfig.JWT(
                _UniffiConverterTypeClientJwtAuth.read(buf),
            )
        if variant == 4:
            return ClientAuthenticationConfig.NONE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_basic():
            _UniffiConverterTypeBasicAuth.check_lower(value.config)
            return
        if value.is_static_jwt():
            _UniffiConverterTypeStaticJwtAuth.check_lower(value.config)
            return
        if value.is_jwt():
            _UniffiConverterTypeClientJwtAuth.check_lower(value.config)
            return
        if value.is_none():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_basic():
            buf.write_i32(1)
            _UniffiConverterTypeBasicAuth.write(value.config, buf)
        if value.is_static_jwt():
            buf.write_i32(2)
            _UniffiConverterTypeStaticJwtAuth.write(value.config, buf)
        if value.is_jwt():
            buf.write_i32(3)
            _UniffiConverterTypeClientJwtAuth.write(value.config, buf)
        if value.is_none():
            buf.write_i32(4)







class CompressionType(enum.Enum):
    """
    Compression type for gRPC messages
    """

    GZIP = 0
    
    ZLIB = 1
    
    DEFLATE = 2
    
    SNAPPY = 3
    
    ZSTD = 4
    
    LZ4 = 5
    
    NONE = 6
    
    EMPTY = 7
    


class _UniffiConverterTypeCompressionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CompressionType.GZIP
        if variant == 2:
            return CompressionType.ZLIB
        if variant == 3:
            return CompressionType.DEFLATE
        if variant == 4:
            return CompressionType.SNAPPY
        if variant == 5:
            return CompressionType.ZSTD
        if variant == 6:
            return CompressionType.LZ4
        if variant == 7:
            return CompressionType.NONE
        if variant == 8:
            return CompressionType.EMPTY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == CompressionType.GZIP:
            return
        if value == CompressionType.ZLIB:
            return
        if value == CompressionType.DEFLATE:
            return
        if value == CompressionType.SNAPPY:
            return
        if value == CompressionType.ZSTD:
            return
        if value == CompressionType.LZ4:
            return
        if value == CompressionType.NONE:
            return
        if value == CompressionType.EMPTY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == CompressionType.GZIP:
            buf.write_i32(1)
        if value == CompressionType.ZLIB:
            buf.write_i32(2)
        if value == CompressionType.DEFLATE:
            buf.write_i32(3)
        if value == CompressionType.SNAPPY:
            buf.write_i32(4)
        if value == CompressionType.ZSTD:
            buf.write_i32(5)
        if value == CompressionType.LZ4:
            buf.write_i32(6)
        if value == CompressionType.NONE:
            buf.write_i32(7)
        if value == CompressionType.EMPTY:
            buf.write_i32(8)







class Direction(enum.Enum):
    """
    Direction enum
    Indicates whether the App can send, receive, both, or neither.
    """

    SEND = 0
    
    RECV = 1
    
    BIDIRECTIONAL = 2
    
    NONE = 3
    


class _UniffiConverterTypeDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Direction.SEND
        if variant == 2:
            return Direction.RECV
        if variant == 3:
            return Direction.BIDIRECTIONAL
        if variant == 4:
            return Direction.NONE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Direction.SEND:
            return
        if value == Direction.RECV:
            return
        if value == Direction.BIDIRECTIONAL:
            return
        if value == Direction.NONE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Direction.SEND:
            buf.write_i32(1)
        if value == Direction.RECV:
            buf.write_i32(2)
        if value == Direction.BIDIRECTIONAL:
            buf.write_i32(3)
        if value == Direction.NONE:
            buf.write_i32(4)







class IdentityProviderConfig:
    """
    Identity provider configuration - used to prove identity to others
    """

    def __init__(self):
        raise RuntimeError("IdentityProviderConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SHARED_SECRET:
        """
        Shared secret authentication (symmetric key)
        """

        id: "str"
        data: "str"

        def __init__(self,id: "str", data: "str"):
            self.id = id
            self.data = data

        def __str__(self):
            return "IdentityProviderConfig.SHARED_SECRET(id={}, data={})".format(self.id, self.data)

        def __eq__(self, other):
            if not other.is_shared_secret():
                return False
            if self.id != other.id:
                return False
            if self.data != other.data:
                return False
            return True
    
    class STATIC_JWT:
        """
        Static JWT loaded from file with auto-reload
        """

        config: "StaticJwtAuth"

        def __init__(self,config: "StaticJwtAuth"):
            self.config = config

        def __str__(self):
            return "IdentityProviderConfig.STATIC_JWT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_static_jwt():
                return False
            if self.config != other.config:
                return False
            return True
    
    class JWT:
        """
        Dynamic JWT generation with signing key
        """

        config: "ClientJwtAuth"

        def __init__(self,config: "ClientJwtAuth"):
            self.config = config

        def __str__(self):
            return "IdentityProviderConfig.JWT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_jwt():
                return False
            if self.config != other.config:
                return False
            return True
    
    class SPIRE:
        """
        SPIRE-based identity provider (non-Windows only)
        """

        config: "SpireConfig"

        def __init__(self,config: "SpireConfig"):
            self.config = config

        def __str__(self):
            return "IdentityProviderConfig.SPIRE(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_spire():
                return False
            if self.config != other.config:
                return False
            return True
    
    class NONE:
        """
        No identity provider configured
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "IdentityProviderConfig.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_shared_secret(self) -> bool:
        return isinstance(self, IdentityProviderConfig.SHARED_SECRET)
    def is_static_jwt(self) -> bool:
        return isinstance(self, IdentityProviderConfig.STATIC_JWT)
    def is_jwt(self) -> bool:
        return isinstance(self, IdentityProviderConfig.JWT)
    def is_spire(self) -> bool:
        return isinstance(self, IdentityProviderConfig.SPIRE)
    def is_none(self) -> bool:
        return isinstance(self, IdentityProviderConfig.NONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
IdentityProviderConfig.SHARED_SECRET = type("IdentityProviderConfig.SHARED_SECRET", (IdentityProviderConfig.SHARED_SECRET, IdentityProviderConfig,), {})  # type: ignore
IdentityProviderConfig.STATIC_JWT = type("IdentityProviderConfig.STATIC_JWT", (IdentityProviderConfig.STATIC_JWT, IdentityProviderConfig,), {})  # type: ignore
IdentityProviderConfig.JWT = type("IdentityProviderConfig.JWT", (IdentityProviderConfig.JWT, IdentityProviderConfig,), {})  # type: ignore
IdentityProviderConfig.SPIRE = type("IdentityProviderConfig.SPIRE", (IdentityProviderConfig.SPIRE, IdentityProviderConfig,), {})  # type: ignore
IdentityProviderConfig.NONE = type("IdentityProviderConfig.NONE", (IdentityProviderConfig.NONE, IdentityProviderConfig,), {})  # type: ignore




class _UniffiConverterTypeIdentityProviderConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return IdentityProviderConfig.SHARED_SECRET(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return IdentityProviderConfig.STATIC_JWT(
                _UniffiConverterTypeStaticJwtAuth.read(buf),
            )
        if variant == 3:
            return IdentityProviderConfig.JWT(
                _UniffiConverterTypeClientJwtAuth.read(buf),
            )
        if variant == 4:
            return IdentityProviderConfig.SPIRE(
                _UniffiConverterTypeSpireConfig.read(buf),
            )
        if variant == 5:
            return IdentityProviderConfig.NONE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_shared_secret():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterString.check_lower(value.data)
            return
        if value.is_static_jwt():
            _UniffiConverterTypeStaticJwtAuth.check_lower(value.config)
            return
        if value.is_jwt():
            _UniffiConverterTypeClientJwtAuth.check_lower(value.config)
            return
        if value.is_spire():
            _UniffiConverterTypeSpireConfig.check_lower(value.config)
            return
        if value.is_none():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_shared_secret():
            buf.write_i32(1)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterString.write(value.data, buf)
        if value.is_static_jwt():
            buf.write_i32(2)
            _UniffiConverterTypeStaticJwtAuth.write(value.config, buf)
        if value.is_jwt():
            buf.write_i32(3)
            _UniffiConverterTypeClientJwtAuth.write(value.config, buf)
        if value.is_spire():
            buf.write_i32(4)
            _UniffiConverterTypeSpireConfig.write(value.config, buf)
        if value.is_none():
            buf.write_i32(5)







class IdentityVerifierConfig:
    """
    Identity verifier configuration - used to verify identity of others
    """

    def __init__(self):
        raise RuntimeError("IdentityVerifierConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SHARED_SECRET:
        """
        Shared secret verification (symmetric key)
        """

        id: "str"
        data: "str"

        def __init__(self,id: "str", data: "str"):
            self.id = id
            self.data = data

        def __str__(self):
            return "IdentityVerifierConfig.SHARED_SECRET(id={}, data={})".format(self.id, self.data)

        def __eq__(self, other):
            if not other.is_shared_secret():
                return False
            if self.id != other.id:
                return False
            if self.data != other.data:
                return False
            return True
    
    class JWT:
        """
        JWT verification with decoding key
        """

        config: "JwtAuth"

        def __init__(self,config: "JwtAuth"):
            self.config = config

        def __str__(self):
            return "IdentityVerifierConfig.JWT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_jwt():
                return False
            if self.config != other.config:
                return False
            return True
    
    class SPIRE:
        """
        SPIRE-based identity verifier (non-Windows only)
        """

        config: "SpireConfig"

        def __init__(self,config: "SpireConfig"):
            self.config = config

        def __str__(self):
            return "IdentityVerifierConfig.SPIRE(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_spire():
                return False
            if self.config != other.config:
                return False
            return True
    
    class NONE:
        """
        No identity verifier configured
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "IdentityVerifierConfig.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_shared_secret(self) -> bool:
        return isinstance(self, IdentityVerifierConfig.SHARED_SECRET)
    def is_jwt(self) -> bool:
        return isinstance(self, IdentityVerifierConfig.JWT)
    def is_spire(self) -> bool:
        return isinstance(self, IdentityVerifierConfig.SPIRE)
    def is_none(self) -> bool:
        return isinstance(self, IdentityVerifierConfig.NONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
IdentityVerifierConfig.SHARED_SECRET = type("IdentityVerifierConfig.SHARED_SECRET", (IdentityVerifierConfig.SHARED_SECRET, IdentityVerifierConfig,), {})  # type: ignore
IdentityVerifierConfig.JWT = type("IdentityVerifierConfig.JWT", (IdentityVerifierConfig.JWT, IdentityVerifierConfig,), {})  # type: ignore
IdentityVerifierConfig.SPIRE = type("IdentityVerifierConfig.SPIRE", (IdentityVerifierConfig.SPIRE, IdentityVerifierConfig,), {})  # type: ignore
IdentityVerifierConfig.NONE = type("IdentityVerifierConfig.NONE", (IdentityVerifierConfig.NONE, IdentityVerifierConfig,), {})  # type: ignore




class _UniffiConverterTypeIdentityVerifierConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return IdentityVerifierConfig.SHARED_SECRET(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return IdentityVerifierConfig.JWT(
                _UniffiConverterTypeJwtAuth.read(buf),
            )
        if variant == 3:
            return IdentityVerifierConfig.SPIRE(
                _UniffiConverterTypeSpireConfig.read(buf),
            )
        if variant == 4:
            return IdentityVerifierConfig.NONE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_shared_secret():
            _UniffiConverterString.check_lower(value.id)
            _UniffiConverterString.check_lower(value.data)
            return
        if value.is_jwt():
            _UniffiConverterTypeJwtAuth.check_lower(value.config)
            return
        if value.is_spire():
            _UniffiConverterTypeSpireConfig.check_lower(value.config)
            return
        if value.is_none():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_shared_secret():
            buf.write_i32(1)
            _UniffiConverterString.write(value.id, buf)
            _UniffiConverterString.write(value.data, buf)
        if value.is_jwt():
            buf.write_i32(2)
            _UniffiConverterTypeJwtAuth.write(value.config, buf)
        if value.is_spire():
            buf.write_i32(3)
            _UniffiConverterTypeSpireConfig.write(value.config, buf)
        if value.is_none():
            buf.write_i32(4)







class JwtAlgorithm(enum.Enum):
    """
    JWT signing/verification algorithm
    """

    HS256 = 0
    
    HS384 = 1
    
    HS512 = 2
    
    ES256 = 3
    
    ES384 = 4
    
    RS256 = 5
    
    RS384 = 6
    
    RS512 = 7
    
    PS256 = 8
    
    PS384 = 9
    
    PS512 = 10
    
    ED_DSA = 11
    


class _UniffiConverterTypeJwtAlgorithm(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JwtAlgorithm.HS256
        if variant == 2:
            return JwtAlgorithm.HS384
        if variant == 3:
            return JwtAlgorithm.HS512
        if variant == 4:
            return JwtAlgorithm.ES256
        if variant == 5:
            return JwtAlgorithm.ES384
        if variant == 6:
            return JwtAlgorithm.RS256
        if variant == 7:
            return JwtAlgorithm.RS384
        if variant == 8:
            return JwtAlgorithm.RS512
        if variant == 9:
            return JwtAlgorithm.PS256
        if variant == 10:
            return JwtAlgorithm.PS384
        if variant == 11:
            return JwtAlgorithm.PS512
        if variant == 12:
            return JwtAlgorithm.ED_DSA
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == JwtAlgorithm.HS256:
            return
        if value == JwtAlgorithm.HS384:
            return
        if value == JwtAlgorithm.HS512:
            return
        if value == JwtAlgorithm.ES256:
            return
        if value == JwtAlgorithm.ES384:
            return
        if value == JwtAlgorithm.RS256:
            return
        if value == JwtAlgorithm.RS384:
            return
        if value == JwtAlgorithm.RS512:
            return
        if value == JwtAlgorithm.PS256:
            return
        if value == JwtAlgorithm.PS384:
            return
        if value == JwtAlgorithm.PS512:
            return
        if value == JwtAlgorithm.ED_DSA:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == JwtAlgorithm.HS256:
            buf.write_i32(1)
        if value == JwtAlgorithm.HS384:
            buf.write_i32(2)
        if value == JwtAlgorithm.HS512:
            buf.write_i32(3)
        if value == JwtAlgorithm.ES256:
            buf.write_i32(4)
        if value == JwtAlgorithm.ES384:
            buf.write_i32(5)
        if value == JwtAlgorithm.RS256:
            buf.write_i32(6)
        if value == JwtAlgorithm.RS384:
            buf.write_i32(7)
        if value == JwtAlgorithm.RS512:
            buf.write_i32(8)
        if value == JwtAlgorithm.PS256:
            buf.write_i32(9)
        if value == JwtAlgorithm.PS384:
            buf.write_i32(10)
        if value == JwtAlgorithm.PS512:
            buf.write_i32(11)
        if value == JwtAlgorithm.ED_DSA:
            buf.write_i32(12)







class JwtKeyData:
    """
    JWT key data source
    """

    def __init__(self):
        raise RuntimeError("JwtKeyData cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class DATA:
        """
        String with encoded key(s)
        """

        value: "str"

        def __init__(self,value: "str"):
            self.value = value

        def __str__(self):
            return "JwtKeyData.DATA(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_data():
                return False
            if self.value != other.value:
                return False
            return True
    
    class FILE:
        """
        File path to the key(s)
        """

        path: "str"

        def __init__(self,path: "str"):
            self.path = path

        def __str__(self):
            return "JwtKeyData.FILE(path={})".format(self.path)

        def __eq__(self, other):
            if not other.is_file():
                return False
            if self.path != other.path:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_data(self) -> bool:
        return isinstance(self, JwtKeyData.DATA)
    def is_file(self) -> bool:
        return isinstance(self, JwtKeyData.FILE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
JwtKeyData.DATA = type("JwtKeyData.DATA", (JwtKeyData.DATA, JwtKeyData,), {})  # type: ignore
JwtKeyData.FILE = type("JwtKeyData.FILE", (JwtKeyData.FILE, JwtKeyData,), {})  # type: ignore




class _UniffiConverterTypeJwtKeyData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JwtKeyData.DATA(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return JwtKeyData.FILE(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_data():
            _UniffiConverterString.check_lower(value.value)
            return
        if value.is_file():
            _UniffiConverterString.check_lower(value.path)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_data():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_file():
            buf.write_i32(2)
            _UniffiConverterString.write(value.path, buf)







class JwtKeyFormat(enum.Enum):
    """
    JWT key format
    """

    PEM = 0
    
    JWK = 1
    
    JWKS = 2
    


class _UniffiConverterTypeJwtKeyFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JwtKeyFormat.PEM
        if variant == 2:
            return JwtKeyFormat.JWK
        if variant == 3:
            return JwtKeyFormat.JWKS
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == JwtKeyFormat.PEM:
            return
        if value == JwtKeyFormat.JWK:
            return
        if value == JwtKeyFormat.JWKS:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == JwtKeyFormat.PEM:
            buf.write_i32(1)
        if value == JwtKeyFormat.JWK:
            buf.write_i32(2)
        if value == JwtKeyFormat.JWKS:
            buf.write_i32(3)







class JwtKeyType:
    """
    JWT key type (encoding, decoding, or autoresolve)
    """

    def __init__(self):
        raise RuntimeError("JwtKeyType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ENCODING:
        """
        Encoding key for signing JWTs (client-side)
        """

        key: "JwtKeyConfig"

        def __init__(self,key: "JwtKeyConfig"):
            self.key = key

        def __str__(self):
            return "JwtKeyType.ENCODING(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_encoding():
                return False
            if self.key != other.key:
                return False
            return True
    
    class DECODING:
        """
        Decoding key for verifying JWTs (server-side)
        """

        key: "JwtKeyConfig"

        def __init__(self,key: "JwtKeyConfig"):
            self.key = key

        def __str__(self):
            return "JwtKeyType.DECODING(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_decoding():
                return False
            if self.key != other.key:
                return False
            return True
    
    class AUTORESOLVE:
        """
        Automatically resolve keys based on claims
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "JwtKeyType.AUTORESOLVE()".format()

        def __eq__(self, other):
            if not other.is_autoresolve():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_encoding(self) -> bool:
        return isinstance(self, JwtKeyType.ENCODING)
    def is_decoding(self) -> bool:
        return isinstance(self, JwtKeyType.DECODING)
    def is_autoresolve(self) -> bool:
        return isinstance(self, JwtKeyType.AUTORESOLVE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
JwtKeyType.ENCODING = type("JwtKeyType.ENCODING", (JwtKeyType.ENCODING, JwtKeyType,), {})  # type: ignore
JwtKeyType.DECODING = type("JwtKeyType.DECODING", (JwtKeyType.DECODING, JwtKeyType,), {})  # type: ignore
JwtKeyType.AUTORESOLVE = type("JwtKeyType.AUTORESOLVE", (JwtKeyType.AUTORESOLVE, JwtKeyType,), {})  # type: ignore




class _UniffiConverterTypeJwtKeyType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return JwtKeyType.ENCODING(
                _UniffiConverterTypeJwtKeyConfig.read(buf),
            )
        if variant == 2:
            return JwtKeyType.DECODING(
                _UniffiConverterTypeJwtKeyConfig.read(buf),
            )
        if variant == 3:
            return JwtKeyType.AUTORESOLVE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_encoding():
            _UniffiConverterTypeJwtKeyConfig.check_lower(value.key)
            return
        if value.is_decoding():
            _UniffiConverterTypeJwtKeyConfig.check_lower(value.key)
            return
        if value.is_autoresolve():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_encoding():
            buf.write_i32(1)
            _UniffiConverterTypeJwtKeyConfig.write(value.key, buf)
        if value.is_decoding():
            buf.write_i32(2)
            _UniffiConverterTypeJwtKeyConfig.write(value.key, buf)
        if value.is_autoresolve():
            buf.write_i32(3)







class ServerAuthenticationConfig:
    """
    Authentication configuration enum for server
    """

    def __init__(self):
        raise RuntimeError("ServerAuthenticationConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BASIC:
        config: "BasicAuth"

        def __init__(self,config: "BasicAuth"):
            self.config = config

        def __str__(self):
            return "ServerAuthenticationConfig.BASIC(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_basic():
                return False
            if self.config != other.config:
                return False
            return True
    
    class JWT:
        config: "JwtAuth"

        def __init__(self,config: "JwtAuth"):
            self.config = config

        def __str__(self):
            return "ServerAuthenticationConfig.JWT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_jwt():
                return False
            if self.config != other.config:
                return False
            return True
    
    class NONE:

        def __init__(self,):
            pass

        def __str__(self):
            return "ServerAuthenticationConfig.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_basic(self) -> bool:
        return isinstance(self, ServerAuthenticationConfig.BASIC)
    def is_jwt(self) -> bool:
        return isinstance(self, ServerAuthenticationConfig.JWT)
    def is_none(self) -> bool:
        return isinstance(self, ServerAuthenticationConfig.NONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ServerAuthenticationConfig.BASIC = type("ServerAuthenticationConfig.BASIC", (ServerAuthenticationConfig.BASIC, ServerAuthenticationConfig,), {})  # type: ignore
ServerAuthenticationConfig.JWT = type("ServerAuthenticationConfig.JWT", (ServerAuthenticationConfig.JWT, ServerAuthenticationConfig,), {})  # type: ignore
ServerAuthenticationConfig.NONE = type("ServerAuthenticationConfig.NONE", (ServerAuthenticationConfig.NONE, ServerAuthenticationConfig,), {})  # type: ignore




class _UniffiConverterTypeServerAuthenticationConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ServerAuthenticationConfig.BASIC(
                _UniffiConverterTypeBasicAuth.read(buf),
            )
        if variant == 2:
            return ServerAuthenticationConfig.JWT(
                _UniffiConverterTypeJwtAuth.read(buf),
            )
        if variant == 3:
            return ServerAuthenticationConfig.NONE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_basic():
            _UniffiConverterTypeBasicAuth.check_lower(value.config)
            return
        if value.is_jwt():
            _UniffiConverterTypeJwtAuth.check_lower(value.config)
            return
        if value.is_none():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_basic():
            buf.write_i32(1)
            _UniffiConverterTypeBasicAuth.write(value.config, buf)
        if value.is_jwt():
            buf.write_i32(2)
            _UniffiConverterTypeJwtAuth.write(value.config, buf)
        if value.is_none():
            buf.write_i32(3)







class SessionType(enum.Enum):
    """
    Session type enum
    """

    POINT_TO_POINT = 0
    
    GROUP = 1
    


class _UniffiConverterTypeSessionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SessionType.POINT_TO_POINT
        if variant == 2:
            return SessionType.GROUP
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SessionType.POINT_TO_POINT:
            return
        if value == SessionType.GROUP:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SessionType.POINT_TO_POINT:
            buf.write_i32(1)
        if value == SessionType.GROUP:
            buf.write_i32(2)




# SlimError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SlimError(Exception):
    """
    Error types for SLIM operations
    """

    pass

_UniffiTempSlimError = SlimError

class SlimError:  # type: ignore
    """
    Error types for SLIM operations
    """

    class ServiceError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.ServiceError({})".format(str(self))
    _UniffiTempSlimError.ServiceError = ServiceError # type: ignore
    class SessionError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.SessionError({})".format(str(self))
    _UniffiTempSlimError.SessionError = SessionError # type: ignore
    class ReceiveError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.ReceiveError({})".format(str(self))
    _UniffiTempSlimError.ReceiveError = ReceiveError # type: ignore
    class SendError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.SendError({})".format(str(self))
    _UniffiTempSlimError.SendError = SendError # type: ignore
    class AuthError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.AuthError({})".format(str(self))
    _UniffiTempSlimError.AuthError = AuthError # type: ignore
    class ConfigError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.ConfigError({})".format(str(self))
    _UniffiTempSlimError.ConfigError = ConfigError # type: ignore
    class Timeout(_UniffiTempSlimError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SlimError.Timeout({})".format(str(self))
    _UniffiTempSlimError.Timeout = Timeout # type: ignore
    class InvalidArgument(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.InvalidArgument({})".format(str(self))
    _UniffiTempSlimError.InvalidArgument = InvalidArgument # type: ignore
    class InternalError(_UniffiTempSlimError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "SlimError.InternalError({})".format(str(self))
    _UniffiTempSlimError.InternalError = InternalError # type: ignore

SlimError = _UniffiTempSlimError # type: ignore
del _UniffiTempSlimError


class _UniffiConverterTypeSlimError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SlimError.ServiceError(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SlimError.SessionError(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return SlimError.ReceiveError(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return SlimError.SendError(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return SlimError.AuthError(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return SlimError.ConfigError(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return SlimError.Timeout(
            )
        if variant == 8:
            return SlimError.InvalidArgument(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return SlimError.InternalError(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SlimError.ServiceError):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.SessionError):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.ReceiveError):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.SendError):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.AuthError):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.ConfigError):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.Timeout):
            return
        if isinstance(value, SlimError.InvalidArgument):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, SlimError.InternalError):
            _UniffiConverterString.check_lower(value.message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SlimError.ServiceError):
            buf.write_i32(1)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.SessionError):
            buf.write_i32(2)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.ReceiveError):
            buf.write_i32(3)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.SendError):
            buf.write_i32(4)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.AuthError):
            buf.write_i32(5)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.ConfigError):
            buf.write_i32(6)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.Timeout):
            buf.write_i32(7)
        if isinstance(value, SlimError.InvalidArgument):
            buf.write_i32(8)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, SlimError.InternalError):
            buf.write_i32(9)
            _UniffiConverterString.write(value.message, buf)





class TlsSource:
    """
    TLS certificate and key source configuration
    """

    def __init__(self):
        raise RuntimeError("TlsSource cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PEM:
        """
        Load certificate and key from PEM strings
        """

        cert: "str"
        key: "str"

        def __init__(self,cert: "str", key: "str"):
            self.cert = cert
            self.key = key

        def __str__(self):
            return "TlsSource.PEM(cert={}, key={})".format(self.cert, self.key)

        def __eq__(self, other):
            if not other.is_pem():
                return False
            if self.cert != other.cert:
                return False
            if self.key != other.key:
                return False
            return True
    
    class FILE:
        """
        Load certificate and key from files (with auto-reload support)
        """

        cert: "str"
        key: "str"

        def __init__(self,cert: "str", key: "str"):
            self.cert = cert
            self.key = key

        def __str__(self):
            return "TlsSource.FILE(cert={}, key={})".format(self.cert, self.key)

        def __eq__(self, other):
            if not other.is_file():
                return False
            if self.cert != other.cert:
                return False
            if self.key != other.key:
                return False
            return True
    
    class SPIRE:
        """
        Load certificate and key from SPIRE Workload API
        """

        config: "SpireConfig"

        def __init__(self,config: "SpireConfig"):
            self.config = config

        def __str__(self):
            return "TlsSource.SPIRE(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_spire():
                return False
            if self.config != other.config:
                return False
            return True
    
    class NONE:
        """
        No certificate/key configured
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TlsSource.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pem(self) -> bool:
        return isinstance(self, TlsSource.PEM)
    def is_file(self) -> bool:
        return isinstance(self, TlsSource.FILE)
    def is_spire(self) -> bool:
        return isinstance(self, TlsSource.SPIRE)
    def is_none(self) -> bool:
        return isinstance(self, TlsSource.NONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TlsSource.PEM = type("TlsSource.PEM", (TlsSource.PEM, TlsSource,), {})  # type: ignore
TlsSource.FILE = type("TlsSource.FILE", (TlsSource.FILE, TlsSource,), {})  # type: ignore
TlsSource.SPIRE = type("TlsSource.SPIRE", (TlsSource.SPIRE, TlsSource,), {})  # type: ignore
TlsSource.NONE = type("TlsSource.NONE", (TlsSource.NONE, TlsSource,), {})  # type: ignore




class _UniffiConverterTypeTlsSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TlsSource.PEM(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return TlsSource.FILE(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return TlsSource.SPIRE(
                _UniffiConverterTypeSpireConfig.read(buf),
            )
        if variant == 4:
            return TlsSource.NONE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_pem():
            _UniffiConverterString.check_lower(value.cert)
            _UniffiConverterString.check_lower(value.key)
            return
        if value.is_file():
            _UniffiConverterString.check_lower(value.cert)
            _UniffiConverterString.check_lower(value.key)
            return
        if value.is_spire():
            _UniffiConverterTypeSpireConfig.check_lower(value.config)
            return
        if value.is_none():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_pem():
            buf.write_i32(1)
            _UniffiConverterString.write(value.cert, buf)
            _UniffiConverterString.write(value.key, buf)
        if value.is_file():
            buf.write_i32(2)
            _UniffiConverterString.write(value.cert, buf)
            _UniffiConverterString.write(value.key, buf)
        if value.is_spire():
            buf.write_i32(3)
            _UniffiConverterTypeSpireConfig.write(value.config, buf)
        if value.is_none():
            buf.write_i32(4)





class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalDuration(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterDuration.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeName(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeName.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeName.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeName.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeKeepaliveConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeKeepaliveConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeKeepaliveConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeKeepaliveConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCompressionType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCompressionType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCompressionType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCompressionType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterMapStringString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterMapStringString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterMapStringString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeName(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeName.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeName.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeService(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeService.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeService.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeService.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeClientConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeClientConfig.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeClientConfig.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeClientConfig.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeServerConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeServerConfig.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeServerConfig.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeServerConfig.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeServiceConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeServiceConfig.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeServiceConfig.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeServiceConfig.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

def create_service(name: "str") -> "Service":
    """
    Create a new Service with builder pattern
    """

    _UniffiConverterString.check_lower(name)
    
    return _UniffiConverterTypeService.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_func_create_service,
        _UniffiConverterString.lower(name)))


def create_service_with_config(name: "str",config: "ServiceConfig") -> "Service":
    """
    Create a new Service with configuration
    """

    _UniffiConverterString.check_lower(name)
    
    _UniffiConverterTypeServiceConfig.check_lower(config)
    
    return _UniffiConverterTypeService.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_func_create_service_with_config,
        _UniffiConverterString.lower(name),
        _UniffiConverterTypeServiceConfig.lower(config)))


def get_build_info() -> "BuildInfo":
    """
    Get detailed build information
    """

    return _UniffiConverterTypeBuildInfo.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_get_build_info,))


def get_global_service() -> "Service":
    """
    Get the global service instance (creates it if it doesn't exist)

    This returns a reference to the shared global service that can be used
    across the application. All calls to this function return the same service instance.
    """

    return _UniffiConverterTypeService.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_get_global_service,))


def get_services() -> "typing.List[Service]":
    """
    Returns references to all global services.
    If not initialized, initializes with defaults first.
    """

    return _UniffiConverterSequenceTypeService.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_get_services,))


def get_version() -> "str":
    """
    Get the version of the SLIM bindings (simple string)
    """

    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_get_version,))


def initialize_from_config(config_path: "str") -> None:
    """
    Initialize SLIM bindings from a configuration file

    This function:
    1. Loads the configuration file
    2. Initializes the crypto provider
    3. Sets up tracing/logging exactly as the main SLIM application does
    4. Initializes the global runtime with configuration from the file
    5. Initializes and starts the global service with servers/clients from config

    This must be called before using any SLIM bindings functionality.
    It's safe to call multiple times - subsequent calls will be ignored.

    # Arguments
    * `config_path` - Path to the YAML configuration file

    # Returns
    * `Ok(())` - Successfully initialized
    * `Err(SlimError)` - If initialization fails

    # Example
    ```ignore
    initialize_from_config("/path/to/config.yaml")?;
    ```
    """

    _UniffiConverterString.check_lower(config_path)
    
    _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_initialize_from_config,
        _UniffiConverterString.lower(config_path))


def initialize_with_configs(runtime_config: "RuntimeConfig",tracing_config: "TracingConfig",service_config: "typing.List[ServiceConfig]") -> None:
    """
    Initialize SLIM bindings with custom configuration structs

    This function allows you to programmatically configure SLIM bindings by passing
    configuration structs directly, without needing a config file.

    # Arguments
    * `runtime_config` - Runtime configuration (thread count, naming, etc.)
    * `tracing_config` - Tracing/logging configuration
    * `service_config` - Service configuration (node ID, group name, etc.)

    # Returns
    * `Ok(())` - Successfully initialized
    * `Err(SlimError)` - If initialization fails

    # Example
    ```ignore
    let runtime_config = new_runtime_config();
    let tracing_config = new_tracing_config();
    let mut service_config = new_service_config();
    service_config.node_id = Some("my-node".to_string());

    initialize_with_configs(runtime_config, tracing_config, service_config)?;
    ```
    """

    _UniffiConverterTypeRuntimeConfig.check_lower(runtime_config)
    
    _UniffiConverterTypeTracingConfig.check_lower(tracing_config)
    
    _UniffiConverterSequenceTypeServiceConfig.check_lower(service_config)
    
    _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_func_initialize_with_configs,
        _UniffiConverterTypeRuntimeConfig.lower(runtime_config),
        _UniffiConverterTypeTracingConfig.lower(tracing_config),
        _UniffiConverterSequenceTypeServiceConfig.lower(service_config))


def initialize_with_defaults() -> None:
    """
    Initialize SLIM bindings with default configuration

    This is a convenience function that initializes the bindings with:
    - Default runtime configuration
    - Default tracing/logging configuration
    - Initialized crypto provider
    - Default global service (no servers/clients)

    Use `initialize_from_config` for file-based configuration or
    `initialize_with_configs` for programmatic configuration.
    """

    _uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_initialize_with_defaults,)


def is_initialized() -> "bool":
    """
    Check if SLIM bindings have been initialized
    """

    return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_is_initialized,))


def new_dataplane_config() -> "DataplaneConfig":
    """
    Create a new DataplaneConfig
    """

    return _UniffiConverterTypeDataplaneConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_dataplane_config,))


def new_insecure_client_config(endpoint: "str") -> "ClientConfig":
    """
    Create a new insecure client config (no TLS)
    """

    _UniffiConverterString.check_lower(endpoint)
    
    return _UniffiConverterTypeClientConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_insecure_client_config,
        _UniffiConverterString.lower(endpoint)))


def new_insecure_server_config(endpoint: "str") -> "ServerConfig":
    """
    Create a new insecure server config (no TLS)
    """

    _UniffiConverterString.check_lower(endpoint)
    
    return _UniffiConverterTypeServerConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_insecure_server_config,
        _UniffiConverterString.lower(endpoint)))


def new_runtime_config() -> "RuntimeConfig":
    """
    Create a new BindingsRuntimeConfig with default values
    """

    return _UniffiConverterTypeRuntimeConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_runtime_config,))


def new_runtime_config_with(n_cores: "int",thread_name: "str",drain_timeout: "Duration") -> "RuntimeConfig":
    """
    Create a new BindingsRuntimeConfig with custom values
    """

    _UniffiConverterUInt64.check_lower(n_cores)
    
    _UniffiConverterString.check_lower(thread_name)
    
    _UniffiConverterDuration.check_lower(drain_timeout)
    
    return _UniffiConverterTypeRuntimeConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_runtime_config_with,
        _UniffiConverterUInt64.lower(n_cores),
        _UniffiConverterString.lower(thread_name),
        _UniffiConverterDuration.lower(drain_timeout)))


def new_server_config(endpoint: "str") -> "ServerConfig":
    """
    Create a new server config with the given endpoint and default values
    """

    _UniffiConverterString.check_lower(endpoint)
    
    return _UniffiConverterTypeServerConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_server_config,
        _UniffiConverterString.lower(endpoint)))


def new_service_config() -> "ServiceConfig":
    """
    Create a new BindingsServiceConfig with default values
    """

    return _UniffiConverterTypeServiceConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_service_config,))


def new_service_config_with(node_id: "typing.Optional[str]",group_name: "typing.Optional[str]",dataplane: "DataplaneConfig") -> "ServiceConfig":
    """
    Create a new BindingsServiceConfig with custom values
    """

    _UniffiConverterOptionalString.check_lower(node_id)
    
    _UniffiConverterOptionalString.check_lower(group_name)
    
    _UniffiConverterTypeDataplaneConfig.check_lower(dataplane)
    
    return _UniffiConverterTypeServiceConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_service_config_with,
        _UniffiConverterOptionalString.lower(node_id),
        _UniffiConverterOptionalString.lower(group_name),
        _UniffiConverterTypeDataplaneConfig.lower(dataplane)))


def new_service_configuration() -> "ServiceConfig":
    """
    Create a new ServiceConfiguration
    """

    return _UniffiConverterTypeServiceConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_service_configuration,))


def new_tracing_config() -> "TracingConfig":
    """
    Create a new BindingsTracingConfig with default values
    """

    return _UniffiConverterTypeTracingConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_tracing_config,))


def new_tracing_config_with(log_level: "str",display_thread_names: "bool",display_thread_ids: "bool",filters: "typing.List[str]") -> "TracingConfig":
    """
    Create a new BindingsTracingConfig with custom values
    """

    _UniffiConverterString.check_lower(log_level)
    
    _UniffiConverterBool.check_lower(display_thread_names)
    
    _UniffiConverterBool.check_lower(display_thread_ids)
    
    _UniffiConverterSequenceString.check_lower(filters)
    
    return _UniffiConverterTypeTracingConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_slim_bindings_fn_func_new_tracing_config_with,
        _UniffiConverterString.lower(log_level),
        _UniffiConverterBool.lower(display_thread_names),
        _UniffiConverterBool.lower(display_thread_ids),
        _UniffiConverterSequenceString.lower(filters)))


def shutdown_blocking() -> None:
    """
    Perform graceful shutdown operations (blocking version)

    This is a blocking wrapper around the async `shutdown()` function for use from
    synchronous contexts or language bindings that don't support async.

    # Returns
    * `Ok(())` - Successfully shut down
    * `Err(SlimError)` - If shutdown fails
    """

    _uniffi_rust_call_with_error(_UniffiConverterTypeSlimError,_UniffiLib.uniffi_slim_bindings_fn_func_shutdown_blocking,)


__all__ = [
    "InternalError",
    "BackoffConfig",
    "CaSource",
    "ClientAuthenticationConfig",
    "CompressionType",
    "Direction",
    "IdentityProviderConfig",
    "IdentityVerifierConfig",
    "JwtAlgorithm",
    "JwtKeyData",
    "JwtKeyFormat",
    "JwtKeyType",
    "ServerAuthenticationConfig",
    "SessionType",
    "SlimError",
    "TlsSource",
    "BasicAuth",
    "BuildInfo",
    "ClientConfig",
    "ClientJwtAuth",
    "DataplaneConfig",
    "ExponentialBackoff",
    "FixedIntervalBackoff",
    "JwtAuth",
    "JwtKeyConfig",
    "KeepaliveConfig",
    "KeepaliveServerParameters",
    "MessageContext",
    "ProxyConfig",
    "ReceivedMessage",
    "RuntimeConfig",
    "ServerConfig",
    "ServiceConfig",
    "SessionConfig",
    "SessionWithCompletion",
    "SpireConfig",
    "StaticJwtAuth",
    "TlsClientConfig",
    "TlsServerConfig",
    "TracingConfig",
    "create_service",
    "create_service_with_config",
    "get_build_info",
    "get_global_service",
    "get_services",
    "get_version",
    "initialize_from_config",
    "initialize_with_configs",
    "initialize_with_defaults",
    "is_initialized",
    "new_dataplane_config",
    "new_insecure_client_config",
    "new_insecure_server_config",
    "new_runtime_config",
    "new_runtime_config_with",
    "new_server_config",
    "new_service_config",
    "new_service_config_with",
    "new_service_configuration",
    "new_tracing_config",
    "new_tracing_config_with",
    "shutdown_blocking",
    "App",
    "CompletionHandle",
    "Name",
    "Service",
    "Session",
]

