# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.airtable_data_input import AirtableDataInput
from ..types.asana_data_input import AsanaDataInput
from ..types.click_up_data_input import ClickUpDataInput
from ..types.close_data_input import CloseDataInput
from ..types.confluence_data_input import ConfluenceDataInput
from ..types.create_sandbox_response import CreateSandboxResponse
from ..types.discord_data_input import DiscordDataInput
from ..types.dropbox_data import DropboxData
from ..types.dump_sandbox_response_airtable_data import DumpSandboxResponseAirtableData
from ..types.dump_sandbox_response_asana_data import DumpSandboxResponseAsanaData
from ..types.dump_sandbox_response_click_up_data import DumpSandboxResponseClickUpData
from ..types.dump_sandbox_response_close_data import DumpSandboxResponseCloseData
from ..types.dump_sandbox_response_confluence_data import DumpSandboxResponseConfluenceData
from ..types.dump_sandbox_response_discord_data import DumpSandboxResponseDiscordData
from ..types.dump_sandbox_response_dropbox_data import DumpSandboxResponseDropboxData
from ..types.dump_sandbox_response_git_hub_data import DumpSandboxResponseGitHubData
from ..types.dump_sandbox_response_gmail_data import DumpSandboxResponseGmailData
from ..types.dump_sandbox_response_google_calendar_data import DumpSandboxResponseGoogleCalendarData
from ..types.dump_sandbox_response_google_cloud_data import DumpSandboxResponseGoogleCloudData
from ..types.dump_sandbox_response_google_docs_data import DumpSandboxResponseGoogleDocsData
from ..types.dump_sandbox_response_google_drive_data import DumpSandboxResponseGoogleDriveData
from ..types.dump_sandbox_response_google_forms_data import DumpSandboxResponseGoogleFormsData
from ..types.dump_sandbox_response_google_sheets_data import DumpSandboxResponseGoogleSheetsData
from ..types.dump_sandbox_response_hub_spot_data import DumpSandboxResponseHubSpotData
from ..types.dump_sandbox_response_jira_data import DumpSandboxResponseJiraData
from ..types.dump_sandbox_response_linear_data import DumpSandboxResponseLinearData
from ..types.dump_sandbox_response_local_memory_data import DumpSandboxResponseLocalMemoryData
from ..types.dump_sandbox_response_mem0data import DumpSandboxResponseMem0Data
from ..types.dump_sandbox_response_monday_data import DumpSandboxResponseMondayData
from ..types.dump_sandbox_response_moneybird_data import DumpSandboxResponseMoneybirdData
from ..types.dump_sandbox_response_motion_data import DumpSandboxResponseMotionData
from ..types.dump_sandbox_response_ms_teams_data import DumpSandboxResponseMsTeamsData
from ..types.dump_sandbox_response_notion_data import DumpSandboxResponseNotionData
from ..types.dump_sandbox_response_one_drive_data import DumpSandboxResponseOneDriveData
from ..types.dump_sandbox_response_outlook_calendar_data import DumpSandboxResponseOutlookCalendarData
from ..types.dump_sandbox_response_outlook_mail_data import DumpSandboxResponseOutlookMailData
from ..types.dump_sandbox_response_quick_books_data import DumpSandboxResponseQuickBooksData
from ..types.dump_sandbox_response_resend_data import DumpSandboxResponseResendData
from ..types.dump_sandbox_response_salesforce_data import DumpSandboxResponseSalesforceData
from ..types.dump_sandbox_response_shopify_data import DumpSandboxResponseShopifyData
from ..types.dump_sandbox_response_slack_data import DumpSandboxResponseSlackData
from ..types.dump_sandbox_response_snowflake_data import DumpSandboxResponseSnowflakeData
from ..types.dump_sandbox_response_supabase_data import DumpSandboxResponseSupabaseData
from ..types.dump_sandbox_response_word_press_data import DumpSandboxResponseWordPressData
from ..types.git_hub_data_input import GitHubDataInput
from ..types.gmail_data import GmailData
from ..types.google_calendar_data_input import GoogleCalendarDataInput
from ..types.google_cloud_data_input import GoogleCloudDataInput
from ..types.google_docs_data import GoogleDocsData
from ..types.google_drive_data import GoogleDriveData
from ..types.google_forms_data_input import GoogleFormsDataInput
from ..types.google_sheets_data_input import GoogleSheetsDataInput
from ..types.http_validation_error import HttpValidationError
from ..types.hub_spot_data_input import HubSpotDataInput
from ..types.initialize_sandbox_response import InitializeSandboxResponse
from ..types.jira_data_input import JiraDataInput
from ..types.linear_data_input import LinearDataInput
from ..types.local_memory_data import LocalMemoryData
from ..types.mem0data_input import Mem0DataInput
from ..types.monday_data_input import MondayDataInput
from ..types.moneybird_data_input import MoneybirdDataInput
from ..types.motion_data_input import MotionDataInput
from ..types.ms_teams_data_input import MsTeamsDataInput
from ..types.notion_data_input import NotionDataInput
from ..types.one_drive_data_input import OneDriveDataInput
from ..types.outlook_calendar_data import OutlookCalendarData
from ..types.outlook_mail_data import OutlookMailData
from ..types.quick_books_data import QuickBooksData
from ..types.release_sandbox_response import ReleaseSandboxResponse
from ..types.resend_data_input import ResendDataInput
from ..types.reset_sandbox_response import ResetSandboxResponse
from ..types.salesforce_data_input import SalesforceDataInput
from ..types.sandbox_info import SandboxInfo
from ..types.sandbox_mcp_server import SandboxMcpServer
from ..types.shopify_data_input import ShopifyDataInput
from ..types.slack_data_input import SlackDataInput
from ..types.snowflake_data_input import SnowflakeDataInput
from ..types.supabase_data_input import SupabaseDataInput
from ..types.word_press_data import WordPressData

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSandboxClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_sandbox(
        self,
        server_name: SandboxMcpServer,
        *,
        test_account_email: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateSandboxResponse]:
        """
        Acquire an idle sandbox instance for a specific MCP server. The sandbox will be marked as 'occupied'. Optionally specify a test_account_email to acquire a specific test account.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        test_account_email : typing.Optional[str]
            Optional email of a specific test account to acquire. If provided, the system will attempt to acquire the sandbox associated with this test account email instead of a random idle sandbox.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}",
            method="POST",
            json={
                "test_account_email": test_account_email,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSandboxResponse,
                    parse_obj_as(
                        type_=CreateSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_sandbox(
        self, server_name: SandboxMcpServer, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SandboxInfo]:
        """
        Retrieve detailed information about a specific sandbox instance.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SandboxInfo]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}/{jsonable_encoder(sandbox_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SandboxInfo,
                    parse_obj_as(
                        type_=SandboxInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_sandbox(
        self, server_name: SandboxMcpServer, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ReleaseSandboxResponse]:
        """
        Release an occupied sandbox back to idle state and marks the sandbox as available for reuse.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ReleaseSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}/{jsonable_encoder(sandbox_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReleaseSandboxResponse,
                    parse_obj_as(
                        type_=ReleaseSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def reset_sandbox(
        self, server_name: SandboxMcpServer, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ResetSandboxResponse]:
        """
        Reset the sandbox to its initial empty state, clearing all data while maintaining the sandbox instance.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ResetSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}/{jsonable_encoder(sandbox_id)}/reset",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ResetSandboxResponse,
                    parse_obj_as(
                        type_=ResetSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_local_dev(
        self, sandbox_id: str, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Upload files to the local dev workspace at /workspace.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/local_dev/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_local_dev(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Download all files from local dev as a tar archive.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/local_dev/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_jira_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[JiraDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with jira-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[JiraDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/jira/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=JiraDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_jira_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseJiraData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseJiraData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/jira/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseJiraData,
                    parse_obj_as(
                        type_=DumpSandboxResponseJiraData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_google_calendar_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleCalendarDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_calendar-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleCalendarDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_calendar/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleCalendarDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_google_calendar_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGoogleCalendarData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGoogleCalendarData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_calendar/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleCalendarData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleCalendarData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_gmail_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GmailData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with gmail-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GmailData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/gmail/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=GmailData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_gmail_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGmailData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGmailData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/gmail/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGmailData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGmailData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_google_docs_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleDocsData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_docs-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleDocsData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_docs/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=GoogleDocsData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_google_docs_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGoogleDocsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGoogleDocsData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_docs/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleDocsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleDocsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_google_drive_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleDriveData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_drive-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleDriveData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_drive/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleDriveData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_google_drive_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGoogleDriveData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGoogleDriveData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_drive/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleDriveData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleDriveData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_google_forms_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleFormsDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_forms-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleFormsDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_forms/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleFormsDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_google_forms_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGoogleFormsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGoogleFormsData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_forms/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleFormsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleFormsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_google_sheets_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleSheetsDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_sheets-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleSheetsDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_sheets/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleSheetsDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_google_sheets_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGoogleSheetsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGoogleSheetsData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_sheets/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleSheetsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleSheetsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_salesforce_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SalesforceDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with salesforce-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SalesforceDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/salesforce/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SalesforceDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_salesforce_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseSalesforceData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseSalesforceData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/salesforce/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSalesforceData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSalesforceData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_onedrive_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[OneDriveDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with onedrive-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[OneDriveDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/onedrive/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=OneDriveDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_onedrive_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseOneDriveData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseOneDriveData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/onedrive/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseOneDriveData,
                    parse_obj_as(
                        type_=DumpSandboxResponseOneDriveData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_microsoft_teams_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MsTeamsDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with microsoft_teams-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MsTeamsDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/microsoft_teams/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MsTeamsDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_microsoft_teams_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseMsTeamsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseMsTeamsData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/microsoft_teams/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMsTeamsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMsTeamsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_outlook_mail_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[OutlookMailData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with outlook_mail-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[OutlookMailData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_mail/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=OutlookMailData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_outlook_mail_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseOutlookMailData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseOutlookMailData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_mail/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseOutlookMailData,
                    parse_obj_as(
                        type_=DumpSandboxResponseOutlookMailData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[LocalMemoryData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with localmemory-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[LocalMemoryData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/localmemory/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=LocalMemoryData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseLocalMemoryData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseLocalMemoryData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/localmemory/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseLocalMemoryData,
                    parse_obj_as(
                        type_=DumpSandboxResponseLocalMemoryData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_hubspot_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[HubSpotDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with hubspot-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[HubSpotDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/hubspot/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=HubSpotDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_hubspot_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseHubSpotData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseHubSpotData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/hubspot/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseHubSpotData,
                    parse_obj_as(
                        type_=DumpSandboxResponseHubSpotData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_quickbooks_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[QuickBooksData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with quickbooks-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[QuickBooksData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/quickbooks/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=QuickBooksData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_quickbooks_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseQuickBooksData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseQuickBooksData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/quickbooks/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseQuickBooksData,
                    parse_obj_as(
                        type_=DumpSandboxResponseQuickBooksData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_moneybird_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MoneybirdDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with moneybird-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MoneybirdDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/moneybird/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MoneybirdDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_moneybird_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseMoneybirdData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseMoneybirdData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/moneybird/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMoneybirdData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMoneybirdData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_dropbox_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[DropboxData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with dropbox-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[DropboxData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/dropbox/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=DropboxData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_dropbox_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseDropboxData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseDropboxData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/dropbox/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseDropboxData,
                    parse_obj_as(
                        type_=DumpSandboxResponseDropboxData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_shopify_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ShopifyDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with shopify-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ShopifyDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/shopify/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ShopifyDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_shopify_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseShopifyData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseShopifyData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/shopify/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseShopifyData,
                    parse_obj_as(
                        type_=DumpSandboxResponseShopifyData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_outlook_calendar_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[OutlookCalendarData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with outlook_calendar-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[OutlookCalendarData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_calendar/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=OutlookCalendarData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_outlook_calendar_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseOutlookCalendarData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseOutlookCalendarData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_calendar/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseOutlookCalendarData,
                    parse_obj_as(
                        type_=DumpSandboxResponseOutlookCalendarData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_clickup_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ClickUpDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with clickup-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ClickUpDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/clickup/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ClickUpDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_clickup_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseClickUpData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseClickUpData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/clickup/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseClickUpData,
                    parse_obj_as(
                        type_=DumpSandboxResponseClickUpData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_close_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[CloseDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with close-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[CloseDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/close/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=CloseDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_close_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseCloseData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseCloseData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/close/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseCloseData,
                    parse_obj_as(
                        type_=DumpSandboxResponseCloseData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_resend_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ResendDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with resend-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ResendDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/resend/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ResendDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_resend_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseResendData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseResendData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/resend/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseResendData,
                    parse_obj_as(
                        type_=DumpSandboxResponseResendData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_wordpress_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[WordPressData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with wordpress-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[WordPressData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/wordpress/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=WordPressData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_wordpress_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseWordPressData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseWordPressData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/wordpress/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseWordPressData,
                    parse_obj_as(
                        type_=DumpSandboxResponseWordPressData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_asana_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[AsanaDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with asana-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[AsanaDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/asana/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=AsanaDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_asana_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseAsanaData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseAsanaData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/asana/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseAsanaData,
                    parse_obj_as(
                        type_=DumpSandboxResponseAsanaData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_mem0sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[Mem0DataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with mem0-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[Mem0DataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/mem0/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Mem0DataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_mem0sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseMem0Data]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseMem0Data]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/mem0/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMem0Data,
                    parse_obj_as(
                        type_=DumpSandboxResponseMem0Data,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_supabase_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SupabaseDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with supabase-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SupabaseDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/supabase/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SupabaseDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_supabase_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseSupabaseData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseSupabaseData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/supabase/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSupabaseData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSupabaseData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_github_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GitHubDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with github-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GitHubDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/github/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GitHubDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_github_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGitHubData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGitHubData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/github/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGitHubData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGitHubData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_linear_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[LinearDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with linear-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[LinearDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/linear/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=LinearDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_linear_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseLinearData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseLinearData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/linear/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseLinearData,
                    parse_obj_as(
                        type_=DumpSandboxResponseLinearData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_notion_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[NotionDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with notion-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[NotionDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/notion/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=NotionDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_notion_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseNotionData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseNotionData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/notion/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseNotionData,
                    parse_obj_as(
                        type_=DumpSandboxResponseNotionData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_slack_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SlackDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with slack-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SlackDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/slack/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=SlackDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_slack_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseSlackData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseSlackData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/slack/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSlackData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSlackData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_confluence_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ConfluenceDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with confluence-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ConfluenceDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/confluence/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ConfluenceDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_confluence_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseConfluenceData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseConfluenceData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/confluence/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseConfluenceData,
                    parse_obj_as(
                        type_=DumpSandboxResponseConfluenceData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_discord_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[DiscordDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with discord-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[DiscordDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/discord/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=DiscordDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_discord_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseDiscordData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseDiscordData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/discord/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseDiscordData,
                    parse_obj_as(
                        type_=DumpSandboxResponseDiscordData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_airtable_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[AirtableDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with airtable-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[AirtableDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/airtable/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=AirtableDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_airtable_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseAirtableData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseAirtableData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/airtable/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseAirtableData,
                    parse_obj_as(
                        type_=DumpSandboxResponseAirtableData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_snowflake_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SnowflakeDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with snowflake-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SnowflakeDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/snowflake/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SnowflakeDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_snowflake_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseSnowflakeData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseSnowflakeData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/snowflake/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSnowflakeData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSnowflakeData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_google_cloud_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleCloudDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_cloud-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleCloudDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_cloud/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleCloudDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_google_cloud_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseGoogleCloudData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseGoogleCloudData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/google_cloud/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleCloudData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleCloudData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_monday_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MondayDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with monday-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MondayDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/monday/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MondayDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_monday_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseMondayData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseMondayData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/monday/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMondayData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMondayData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_motion_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MotionDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with motion-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MotionDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/motion/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MotionDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_motion_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DumpSandboxResponseMotionData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DumpSandboxResponseMotionData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/motion/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMotionData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMotionData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def dump_calcom_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        sandbox_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/Cal.com/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def initialize_calcom_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        sandbox_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sandbox/Cal.com/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSandboxClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_sandbox(
        self,
        server_name: SandboxMcpServer,
        *,
        test_account_email: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateSandboxResponse]:
        """
        Acquire an idle sandbox instance for a specific MCP server. The sandbox will be marked as 'occupied'. Optionally specify a test_account_email to acquire a specific test account.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        test_account_email : typing.Optional[str]
            Optional email of a specific test account to acquire. If provided, the system will attempt to acquire the sandbox associated with this test account email instead of a random idle sandbox.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}",
            method="POST",
            json={
                "test_account_email": test_account_email,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSandboxResponse,
                    parse_obj_as(
                        type_=CreateSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_sandbox(
        self, server_name: SandboxMcpServer, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SandboxInfo]:
        """
        Retrieve detailed information about a specific sandbox instance.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SandboxInfo]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}/{jsonable_encoder(sandbox_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SandboxInfo,
                    parse_obj_as(
                        type_=SandboxInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_sandbox(
        self, server_name: SandboxMcpServer, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ReleaseSandboxResponse]:
        """
        Release an occupied sandbox back to idle state and marks the sandbox as available for reuse.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ReleaseSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}/{jsonable_encoder(sandbox_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ReleaseSandboxResponse,
                    parse_obj_as(
                        type_=ReleaseSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def reset_sandbox(
        self, server_name: SandboxMcpServer, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ResetSandboxResponse]:
        """
        Reset the sandbox to its initial empty state, clearing all data while maintaining the sandbox instance.

        Parameters
        ----------
        server_name : SandboxMcpServer
            The MCP server name

        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ResetSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/{jsonable_encoder(server_name)}/{jsonable_encoder(sandbox_id)}/reset",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ResetSandboxResponse,
                    parse_obj_as(
                        type_=ResetSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_local_dev(
        self, sandbox_id: str, *, files: typing.List[core.File], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Upload files to the local dev workspace at /workspace.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        files : typing.List[core.File]
            See core.File for more documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/local_dev/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            data={},
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_local_dev(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Download all files from local dev as a tar archive.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/local_dev/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_jira_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[JiraDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with jira-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[JiraDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/jira/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=JiraDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_jira_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseJiraData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseJiraData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/jira/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseJiraData,
                    parse_obj_as(
                        type_=DumpSandboxResponseJiraData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_google_calendar_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleCalendarDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_calendar-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleCalendarDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_calendar/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleCalendarDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_google_calendar_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGoogleCalendarData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGoogleCalendarData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_calendar/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleCalendarData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleCalendarData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_gmail_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GmailData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with gmail-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GmailData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/gmail/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=GmailData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_gmail_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGmailData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGmailData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/gmail/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGmailData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGmailData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_google_docs_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleDocsData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_docs-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleDocsData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_docs/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=GoogleDocsData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_google_docs_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGoogleDocsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGoogleDocsData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_docs/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleDocsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleDocsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_google_drive_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleDriveData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_drive-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleDriveData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_drive/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleDriveData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_google_drive_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGoogleDriveData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGoogleDriveData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_drive/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleDriveData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleDriveData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_google_forms_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleFormsDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_forms-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleFormsDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_forms/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleFormsDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_google_forms_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGoogleFormsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGoogleFormsData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_forms/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleFormsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleFormsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_google_sheets_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleSheetsDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_sheets-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleSheetsDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_sheets/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleSheetsDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_google_sheets_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGoogleSheetsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGoogleSheetsData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_sheets/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleSheetsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleSheetsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_salesforce_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SalesforceDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with salesforce-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SalesforceDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/salesforce/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SalesforceDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_salesforce_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseSalesforceData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseSalesforceData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/salesforce/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSalesforceData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSalesforceData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_onedrive_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[OneDriveDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with onedrive-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[OneDriveDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/onedrive/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=OneDriveDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_onedrive_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseOneDriveData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseOneDriveData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/onedrive/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseOneDriveData,
                    parse_obj_as(
                        type_=DumpSandboxResponseOneDriveData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_microsoft_teams_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MsTeamsDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with microsoft_teams-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MsTeamsDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/microsoft_teams/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MsTeamsDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_microsoft_teams_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseMsTeamsData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseMsTeamsData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/microsoft_teams/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMsTeamsData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMsTeamsData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_outlook_mail_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[OutlookMailData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with outlook_mail-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[OutlookMailData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_mail/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=OutlookMailData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_outlook_mail_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseOutlookMailData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseOutlookMailData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_mail/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseOutlookMailData,
                    parse_obj_as(
                        type_=DumpSandboxResponseOutlookMailData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[LocalMemoryData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with localmemory-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[LocalMemoryData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/localmemory/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=LocalMemoryData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseLocalMemoryData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseLocalMemoryData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/localmemory/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseLocalMemoryData,
                    parse_obj_as(
                        type_=DumpSandboxResponseLocalMemoryData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_hubspot_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[HubSpotDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with hubspot-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[HubSpotDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/hubspot/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=HubSpotDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_hubspot_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseHubSpotData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseHubSpotData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/hubspot/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseHubSpotData,
                    parse_obj_as(
                        type_=DumpSandboxResponseHubSpotData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_quickbooks_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[QuickBooksData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with quickbooks-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[QuickBooksData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/quickbooks/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=QuickBooksData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_quickbooks_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseQuickBooksData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseQuickBooksData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/quickbooks/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseQuickBooksData,
                    parse_obj_as(
                        type_=DumpSandboxResponseQuickBooksData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_moneybird_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MoneybirdDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with moneybird-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MoneybirdDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/moneybird/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MoneybirdDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_moneybird_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseMoneybirdData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseMoneybirdData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/moneybird/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMoneybirdData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMoneybirdData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_dropbox_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[DropboxData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with dropbox-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[DropboxData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/dropbox/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=DropboxData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_dropbox_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseDropboxData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseDropboxData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/dropbox/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseDropboxData,
                    parse_obj_as(
                        type_=DumpSandboxResponseDropboxData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_shopify_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ShopifyDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with shopify-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ShopifyDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/shopify/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ShopifyDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_shopify_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseShopifyData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseShopifyData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/shopify/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseShopifyData,
                    parse_obj_as(
                        type_=DumpSandboxResponseShopifyData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_outlook_calendar_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[OutlookCalendarData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with outlook_calendar-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[OutlookCalendarData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_calendar/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=OutlookCalendarData, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_outlook_calendar_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseOutlookCalendarData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseOutlookCalendarData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/outlook_calendar/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseOutlookCalendarData,
                    parse_obj_as(
                        type_=DumpSandboxResponseOutlookCalendarData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_clickup_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ClickUpDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with clickup-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ClickUpDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/clickup/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ClickUpDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_clickup_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseClickUpData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseClickUpData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/clickup/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseClickUpData,
                    parse_obj_as(
                        type_=DumpSandboxResponseClickUpData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_close_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[CloseDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with close-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[CloseDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/close/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=CloseDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_close_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseCloseData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseCloseData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/close/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseCloseData,
                    parse_obj_as(
                        type_=DumpSandboxResponseCloseData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_resend_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ResendDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with resend-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ResendDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/resend/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ResendDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_resend_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseResendData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseResendData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/resend/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseResendData,
                    parse_obj_as(
                        type_=DumpSandboxResponseResendData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_wordpress_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[WordPressData] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with wordpress-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[WordPressData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/wordpress/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=WordPressData, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_wordpress_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseWordPressData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseWordPressData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/wordpress/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseWordPressData,
                    parse_obj_as(
                        type_=DumpSandboxResponseWordPressData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_asana_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[AsanaDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with asana-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[AsanaDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/asana/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=AsanaDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_asana_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseAsanaData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseAsanaData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/asana/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseAsanaData,
                    parse_obj_as(
                        type_=DumpSandboxResponseAsanaData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_mem0sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[Mem0DataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with mem0-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[Mem0DataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/mem0/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=Mem0DataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_mem0sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseMem0Data]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseMem0Data]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/mem0/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMem0Data,
                    parse_obj_as(
                        type_=DumpSandboxResponseMem0Data,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_supabase_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SupabaseDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with supabase-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SupabaseDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/supabase/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SupabaseDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_supabase_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseSupabaseData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseSupabaseData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/supabase/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSupabaseData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSupabaseData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_github_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GitHubDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with github-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GitHubDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/github/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GitHubDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_github_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGitHubData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGitHubData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/github/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGitHubData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGitHubData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_linear_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[LinearDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with linear-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[LinearDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/linear/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=LinearDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_linear_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseLinearData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseLinearData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/linear/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseLinearData,
                    parse_obj_as(
                        type_=DumpSandboxResponseLinearData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_notion_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[NotionDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with notion-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[NotionDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/notion/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=NotionDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_notion_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseNotionData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseNotionData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/notion/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseNotionData,
                    parse_obj_as(
                        type_=DumpSandboxResponseNotionData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_slack_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SlackDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with slack-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SlackDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/slack/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(object_=request, annotation=SlackDataInput, direction="write"),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_slack_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseSlackData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseSlackData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/slack/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSlackData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSlackData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_confluence_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[ConfluenceDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with confluence-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[ConfluenceDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/confluence/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ConfluenceDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_confluence_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseConfluenceData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseConfluenceData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/confluence/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseConfluenceData,
                    parse_obj_as(
                        type_=DumpSandboxResponseConfluenceData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_discord_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[DiscordDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with discord-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[DiscordDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/discord/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=DiscordDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_discord_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseDiscordData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseDiscordData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/discord/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseDiscordData,
                    parse_obj_as(
                        type_=DumpSandboxResponseDiscordData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_airtable_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[AirtableDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with airtable-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[AirtableDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/airtable/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=AirtableDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_airtable_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseAirtableData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseAirtableData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/airtable/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseAirtableData,
                    parse_obj_as(
                        type_=DumpSandboxResponseAirtableData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_snowflake_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[SnowflakeDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with snowflake-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[SnowflakeDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/snowflake/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SnowflakeDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_snowflake_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseSnowflakeData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseSnowflakeData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/snowflake/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseSnowflakeData,
                    parse_obj_as(
                        type_=DumpSandboxResponseSnowflakeData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_google_cloud_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[GoogleCloudDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with google_cloud-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[GoogleCloudDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_cloud/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=GoogleCloudDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_google_cloud_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseGoogleCloudData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseGoogleCloudData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/google_cloud/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseGoogleCloudData,
                    parse_obj_as(
                        type_=DumpSandboxResponseGoogleCloudData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_monday_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MondayDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with monday-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MondayDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/monday/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MondayDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_monday_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseMondayData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseMondayData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/monday/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMondayData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMondayData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_motion_sandbox(
        self,
        sandbox_id: str,
        *,
        init_default_data: typing.Optional[bool] = None,
        request: typing.Optional[MotionDataInput] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InitializeSandboxResponse]:
        """
        Initialize the sandbox with motion-specific data following the defined schema.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        init_default_data : typing.Optional[bool]
            If true, use default test data for initialization

        request : typing.Optional[MotionDataInput]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InitializeSandboxResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/motion/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            params={
                "init_default_data": init_default_data,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=MotionDataInput, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InitializeSandboxResponse,
                    parse_obj_as(
                        type_=InitializeSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_motion_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DumpSandboxResponseMotionData]:
        """
        Export all data from the sandbox in the same format used for initialization.

        Parameters
        ----------
        sandbox_id : str
            The unique sandbox identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DumpSandboxResponseMotionData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/motion/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DumpSandboxResponseMotionData,
                    parse_obj_as(
                        type_=DumpSandboxResponseMotionData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def dump_calcom_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        sandbox_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/Cal.com/{jsonable_encoder(sandbox_id)}/dump",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def initialize_calcom_sandbox(
        self, sandbox_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        sandbox_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sandbox/Cal.com/{jsonable_encoder(sandbox_id)}/initialize",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
