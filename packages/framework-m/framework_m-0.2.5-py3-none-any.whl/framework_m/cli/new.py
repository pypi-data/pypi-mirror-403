"""Scaffolding CLI Commands - Create new apps and doctypes.

This module provides CLI commands for scaffolding new Framework M
components using templates.

Usage:
    m new:doctype Invoice              # Create new doctype
    m new:doctype Invoice --app myapp  # Explicit app target
"""

from __future__ import annotations

import re
import sys
from pathlib import Path
from typing import Annotated

import cyclopts

# =============================================================================
# Template Content (Embedded for simplicity)
# =============================================================================

DOCTYPE_TEMPLATE = '''\
"""{{ class_name }} DocType.

Auto-generated by `m new:doctype {{ name }}`.
"""

from __future__ import annotations

from typing import ClassVar

from pydantic import Field

from framework_m.core.domain.base_doctype import BaseDocType


class {{ class_name }}(BaseDocType):
    """{{ class_name }} DocType definition.

    Attributes:
        name: Unique identifier for this {{ name }}.
    """

    __doctype_name__: ClassVar[str] = "{{ class_name }}"

    name: str = Field(description="Unique identifier")

    class Meta:
        """DocType metadata."""

        naming_rule: ClassVar[str] = "autoincrement"
        is_submittable: ClassVar[bool] = False
        api_resource: ClassVar[bool] = True  # Expose via REST API
        show_in_desk: ClassVar[bool] = True  # Show in Desk UI
'''

CONTROLLER_TEMPLATE = '''\
"""{{ class_name }} Controller.

Auto-generated by `m new:doctype {{ name }}`.
"""

from __future__ import annotations

from framework_m.core.domain.base_controller import BaseController
from .doctype import {{ class_name }}


class {{ class_name }}Controller(BaseController[{{ class_name }}]):
    """Controller for {{ class_name }} DocType.

    Implement custom business logic here.
    """

    doctype = {{ class_name }}

    async def before_save(self, doc: {{ class_name }}) -> None:
        """Called before saving a document."""
        pass

    async def after_save(self, doc: {{ class_name }}) -> None:
        """Called after saving a document."""
        pass
'''

TEST_TEMPLATE = '''\
"""Tests for {{ class_name }} DocType.

Auto-generated by `m new:doctype {{ name }}`.
"""

from __future__ import annotations

import pytest

from .doctype import {{ class_name }}


class Test{{ class_name }}:
    """Tests for {{ class_name }}."""

    def test_create_{{ snake_name }}(self) -> None:
        """{{ class_name }} should be creatable."""
        doc = {{ class_name }}(name="test-001")
        assert doc.name == "test-001"

    def test_{{ snake_name }}_doctype_name(self) -> None:
        """{{ class_name }} should have correct doctype name."""
        assert {{ class_name }}.__doctype_name__ == "{{ class_name }}"
'''

INIT_TEMPLATE = '''\
"""{{ class_name }} DocType package.

Auto-generated by `m new:doctype {{ name }}`.
"""

from .controller import {{ class_name }}Controller
from .doctype import {{ class_name }}

__all__ = ["{{ class_name }}", "{{ class_name }}Controller"]
'''


# =============================================================================
# Name Utilities
# =============================================================================


def to_pascal_case(name: str) -> str:
    """Convert name to PascalCase.

    Examples:
        >>> to_pascal_case("sales_order")
        'SalesOrder'
        >>> to_pascal_case("user")
        'User'
        >>> to_pascal_case("ItemSupplier")
        'ItemSupplier'
    """
    # Handle snake_case - capitalize first letter of each part, preserve rest
    if "_" in name:
        return "".join(
            (word[0].upper() + word[1:]) if word else "" for word in name.split("_")
        )
    # Handle kebab-case
    if "-" in name:
        return "".join(
            (word[0].upper() + word[1:]) if word else "" for word in name.split("-")
        )
    # Already PascalCase or single word - just ensure first letter is uppercase
    return name[0].upper() + name[1:] if name else name


def to_snake_case(name: str) -> str:
    """Convert name to snake_case.

    Examples:
        >>> to_snake_case("SalesOrder")
        'sales_order'
        >>> to_snake_case("user")
        'user'
        >>> to_snake_case("my-app")
        'my_app'
    """
    # First, replace hyphens with underscores
    name = name.replace("-", "_")
    # Insert underscore before uppercase letters
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def normalize_app_name(name: str) -> str:
    """Normalize app name to Python package format.

    Examples:
        >>> normalize_app_name("my-app")
        'my_app'
    """
    return name.replace("-", "_")


# =============================================================================
# App Detection Strategy
# =============================================================================

# Entry point group for discovering installed apps
APPS_ENTRY_POINT_GROUP = "framework_m.apps"


def detect_app_from_cwd() -> str | None:
    """Detect app name from pyproject.toml in cwd or parents.

    Returns:
        App name if found, None otherwise.
    """
    for path in [Path.cwd(), *Path.cwd().parents]:
        pyproject = path / "pyproject.toml"
        if pyproject.exists():
            return parse_project_name(pyproject)
    return None


def parse_project_name(pyproject_path: Path) -> str | None:
    """Parse project name from pyproject.toml.

    Args:
        pyproject_path: Path to pyproject.toml

    Returns:
        Normalized project name or None
    """
    try:
        content = pyproject_path.read_text()
        # Simple regex to find name = "..."
        match = re.search(r'name\s*=\s*["\']([^"\']+)["\']', content)
        if match:
            return normalize_app_name(match.group(1))
    except Exception:
        pass
    return None


def is_interactive() -> bool:
    """Check if running in interactive terminal."""
    return sys.stdin.isatty()


def list_installed_apps() -> list[str]:
    """List installed apps from entry points.

    Scans the framework_m.apps entry point group for registered apps.

    Returns:
        List of app names
    """
    from importlib.metadata import entry_points

    eps = entry_points(group=APPS_ENTRY_POINT_GROUP)
    return [ep.name for ep in eps]


def prompt_select(prompt: str, options: list[str]) -> str | None:
    """Prompt user to select from a list of options.

    Args:
        prompt: The prompt message
        options: List of options to choose from

    Returns:
        Selected option or None if cancelled
    """
    if not options:
        return None

    print(f"\n{prompt}")
    for i, opt in enumerate(options, 1):
        print(f"  {i}. {opt}")

    try:
        choice = input("\nEnter number (or 'q' to quit): ").strip()
        if choice.lower() == "q":
            return None

        idx = int(choice) - 1
        if 0 <= idx < len(options):
            return options[idx]
    except (ValueError, EOFError, KeyboardInterrupt):
        pass

    return None


def detect_app(explicit_app: str | None = None) -> str | None:
    """Detect app using the detection strategy.

    Strategy:
    1. Explicit --app parameter wins
    2. Auto-detect from pyproject.toml in CWD or parents
    3. None if not found (caller handles interactive/error)

    Args:
        explicit_app: Explicitly provided app name

    Returns:
        App name or None
    """
    if explicit_app:
        return normalize_app_name(explicit_app)

    return detect_app_from_cwd()


def require_app(explicit_app: str | None = None) -> str:
    """Require an app, prompting if necessary.

    Full implementation of App Detection Strategy:
    1. Explicit --app parameter wins
    2. Auto-detect from pyproject.toml
    3. Interactive prompt if TTY
    4. Fail with error if non-interactive

    Args:
        explicit_app: Explicitly provided app name

    Returns:
        App name (guaranteed)

    Raises:
        SystemExit: If app cannot be determined
    """
    # 1. Explicit --app wins
    if explicit_app:
        return normalize_app_name(explicit_app)

    # 2. Auto-detect from CWD
    detected = detect_app_from_cwd()
    if detected:
        return detected

    # 3. Interactive prompt if TTY
    if is_interactive():
        apps = list_installed_apps()
        if apps:
            print("Could not detect app from current directory.")
            selected = prompt_select("Which app?", apps)
            if selected:
                return selected
            print("\nNo app selected.")
        else:
            print("Could not detect app from current directory.")
            print("No apps registered in entry points.")

    # 4. Fail with clear error
    print(
        "Error: Cannot detect app. Use --app <name>.",
        file=sys.stderr,
    )
    raise SystemExit(1)


# =============================================================================
# Scaffold Functions
# =============================================================================


def render_template(template: str, context: dict[str, str]) -> str:
    """Simple template rendering (no Jinja2 dependency).

    Args:
        template: Template string with {{ var }} placeholders
        context: Dict of variable names to values

    Returns:
        Rendered template
    """
    result = template
    for key, value in context.items():
        result = result.replace("{{ " + key + " }}", value)
    return result


def scaffold_doctype(
    doctype_name: str,
    output_dir: Path,
) -> dict[str, Path]:
    """Create doctype scaffold files.

    Args:
        doctype_name: Name of the doctype (e.g., "Invoice" or "sales_order")
        output_dir: Directory to create files in

    Returns:
        Dict mapping file type to created path
    """
    class_name = to_pascal_case(doctype_name)
    snake_name = to_snake_case(doctype_name)

    context = {
        "name": doctype_name,
        "class_name": class_name,
        "snake_name": snake_name,
    }

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    created_files: dict[str, Path] = {}

    # Create files
    files = [
        ("__init__.py", INIT_TEMPLATE),
        ("doctype.py", DOCTYPE_TEMPLATE),
        ("controller.py", CONTROLLER_TEMPLATE),
        (f"test_{snake_name}.py", TEST_TEMPLATE),
    ]

    for filename, template in files:
        filepath = output_dir / filename
        content = render_template(template, context)
        filepath.write_text(content)
        created_files[filename] = filepath

    return created_files


# =============================================================================
# CLI Commands
# =============================================================================


def new_doctype_command(
    name: Annotated[str, cyclopts.Parameter(help="Name of the new DocType")],
    app: Annotated[
        str | None,
        cyclopts.Parameter(name="--app", help="Target app name"),
    ] = None,
    output: Annotated[
        Path | None,
        cyclopts.Parameter(
            name="--output", help="Output directory (default: doctypes/<name>)"
        ),
    ] = None,
) -> None:
    """Create a new DocType with scaffolded files.

    Creates a new DocType package with:
    - doctype.py (schema definition)
    - controller.py (business logic)
    - test_*.py (pytest tests)

    Examples:
        m new:doctype Invoice
        m new:doctype Invoice --app myapp
        m new:doctype SalesOrder --output ./my_doctypes/sales_order
    """
    # Detect app if not provided
    detected_app = detect_app(app)

    if detected_app is None and output is None:
        if is_interactive():
            print("Warning: Could not detect app. Creating in current directory.")
        else:
            print(
                "Error: Cannot detect app. Use --app <name> or --output <path>.",
                file=sys.stderr,
            )
            raise SystemExit(1)

    # Determine output directory
    if output:
        output_dir = output
    elif detected_app:
        # Default: Check for src/doctypes first (standard structure)
        snake_name = to_snake_case(name)
        src_doctypes = Path.cwd() / "src" / "doctypes"
        if src_doctypes.exists():
            output_dir = src_doctypes / snake_name
        else:
            output_dir = Path.cwd() / "doctypes" / snake_name
    else:
        snake_name = to_snake_case(name)
        output_dir = Path.cwd() / snake_name

    # Check if directory already exists
    if output_dir.exists():
        print(f"Error: Directory already exists: {output_dir}", file=sys.stderr)
        raise SystemExit(1)

    # Scaffold
    print(f"Creating DocType: {to_pascal_case(name)}")
    print(f"  Location: {output_dir}")

    created = scaffold_doctype(name, output_dir)

    print()
    print("✓ Created files:")
    for filename in created:
        print(f"  - {output_dir / filename}")


# =============================================================================
# New App Command
# =============================================================================

# App template files (embedded for simplicity)
APP_PYPROJECT_TEMPLATE = """\
[project]
name = "{{ app_name }}"
version = "0.1.0"
description = "A Framework M application"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "framework-m>=0.1.0",
]

[project.entry-points."framework_m.apps"]
{{ app_name }} = "doctypes:app"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/doctypes"]
"""

APP_README_TEMPLATE = """\
# {{ class_name }}

A Framework M application.

## Getting Started

```bash
cd {{ app_name }}
uv sync
m studio --port 8000
```

## Structure

```
{{ app_name }}/
├── src/
│   └── doctypes/     # Your DocTypes go here
├── pyproject.toml
└── README.md
```
"""


def scaffold_app(
    app_name: str,
    output_dir: Path,
) -> dict[str, Path]:
    """Create app scaffold files.

    Args:
        app_name: Name of the app (e.g., "myapp")
        output_dir: Directory to create app in

    Returns:
        Dict mapping file type to created path
    """
    class_name = to_pascal_case(app_name)
    snake_name = to_snake_case(app_name)

    context = {
        "app_name": snake_name,
        "class_name": class_name,
    }

    # Create directory structure
    app_dir = output_dir / snake_name
    app_dir.mkdir(parents=True, exist_ok=True)

    # Create src/doctypes directory
    doctypes_dir = app_dir / "src" / "doctypes"
    doctypes_dir.mkdir(parents=True, exist_ok=True)

    created_files: dict[str, Path] = {}

    # Create doctypes/__init__.py with app configuration
    doctypes_init_content = f'''"""{class_name} App - DocTypes Package."""

# App configuration
app = {{
    "name": "{snake_name}",
    "title": "{class_name}",
    "description": "A Framework M application",
}}
'''
    doctypes_init_path = doctypes_dir / "__init__.py"
    doctypes_init_path.write_text(doctypes_init_content)
    created_files["src/doctypes/__init__.py"] = doctypes_init_path

    # Create pyproject.toml
    pyproject_content = render_template(APP_PYPROJECT_TEMPLATE, context)
    pyproject_path = app_dir / "pyproject.toml"
    pyproject_path.write_text(pyproject_content)
    created_files["pyproject.toml"] = pyproject_path

    # Create README.md
    readme_content = render_template(APP_README_TEMPLATE, context)
    readme_path = app_dir / "README.md"
    readme_path.write_text(readme_content)
    created_files["README.md"] = readme_path

    return created_files


def new_app_command(
    name: Annotated[str, cyclopts.Parameter(help="Name of the new app")],
    output_dir: Annotated[
        Path,
        cyclopts.Parameter(
            name="--output-dir", help="Parent directory for the new app"
        ),
    ] = Path(),
) -> None:
    """Create a new Framework M app.

    Creates a minimal app structure with:
    - pyproject.toml (with Framework M dependency)
    - README.md
    - src/doctypes/ (for your DocTypes)

    Examples:
        m new:app myapp
        m new:app myapp --output-dir ./apps
    """
    snake_name = to_snake_case(name)
    app_path = output_dir / snake_name

    # Check if directory already exists
    if app_path.exists():
        print(f"Error: Directory already exists: {app_path}", file=sys.stderr)
        raise SystemExit(1)

    print(f"Creating new app: {name}")
    print(f"  Location: {app_path}")
    print()

    created = scaffold_app(name, output_dir)

    print("✓ Created files:")
    for filepath in created.values():
        print(f"  - {filepath}")

    print()
    print("✓ Created directory structure:")
    print(f"  - {app_path}/src/doctypes/")
    print()
    print("Next steps:")
    print(f"  cd {snake_name}")
    print("  m studio --port 8000")


__all__ = [
    "APPS_ENTRY_POINT_GROUP",
    "detect_app",
    "detect_app_from_cwd",
    "is_interactive",
    "list_installed_apps",
    "new_app_command",
    "new_doctype_command",
    "prompt_select",
    "require_app",
    "scaffold_app",
    "scaffold_doctype",
    "to_pascal_case",
    "to_snake_case",
]
