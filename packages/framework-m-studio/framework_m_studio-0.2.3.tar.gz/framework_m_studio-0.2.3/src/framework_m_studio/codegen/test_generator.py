"""DocType Test Generator.

This module generates comprehensive test files for DocTypes, including:
- CRUD tests (Create, Read, Update, Delete)
- Validation tests for required fields
- Integration test scaffolding

Usage:
    from framework_m_studio.codegen.test_generator import generate_test

    test_code = generate_test({
        "name": "Todo",
        "module": "myapp.doctypes.todo",
        "fields": [{"name": "title", "type": "str", "required": True}],
    })
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import Any

from jinja2 import Environment, FileSystemLoader, select_autoescape

# Template directory
TEMPLATE_DIR = Path(__file__).parent / "templates"


def _get_jinja_env() -> Environment:
    """Get configured Jinja2 environment."""
    return Environment(
        loader=FileSystemLoader(str(TEMPLATE_DIR)),
        autoescape=select_autoescape(enabled_extensions=()),
        trim_blocks=True,
        lstrip_blocks=True,
        keep_trailing_newline=True,
    )


def _to_snake_case(name: str) -> str:
    """Convert PascalCase to snake_case."""
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def _get_test_value(field_type: str, field_name: str = "") -> str:
    """Get a test value for a field type."""
    # Handle common field types
    base_type = field_type.split("[")[0].split("|")[0].strip()

    type_values = {
        "str": f'"{field_name or "test"}_value"',
        "int": "42",
        "float": "3.14",
        "bool": "True",
        "date": "date.today()",
        "datetime": "datetime.now()",
        "UUID": "uuid4()",
        "uuid": "uuid4()",
        "Decimal": 'Decimal("100.00")',
    }

    return type_values.get(base_type, '"test"')


def _get_update_value(field_type: str, field_name: str = "") -> str:
    """Get an updated test value for a field type."""
    base_type = field_type.split("[")[0].split("|")[0].strip()

    type_values = {
        "str": f'"{field_name or "test"}_updated"',
        "int": "99",
        "float": "9.99",
        "bool": "False",
        "date": "date.today()",
        "datetime": "datetime.now()",
        "UUID": "uuid4()",
        "uuid": "uuid4()",
        "Decimal": 'Decimal("999.99")',
    }

    return type_values.get(base_type, '"updated"')


def generate_test(schema: dict[str, Any]) -> str:
    """Generate comprehensive test file for a DocType.

    Args:
        schema: Dictionary with DocType schema:
            - name: str - Class name (PascalCase)
            - module: str - Python module path
            - fields: list[dict] - Field definitions

    Returns:
        Generated Python test file source code.

    The generated tests include:
    - test_create_{doctype}: Basic creation test
    - test_{doctype}_defaults: Default value verification
    - test_{doctype}_validation: Required field validation
    - test_update_{doctype}: Field update test
    - test_{doctype}_crud: Full CRUD cycle (if repository available)

    Example:
        >>> code = generate_test({
        ...     "name": "Todo",
        ...     "module": "myapp.doctypes.todo",
        ...     "fields": [{"name": "title", "type": "str", "required": True}],
        ... })
    """
    name = schema["name"]
    snake_name = _to_snake_case(name)
    module = schema.get("module", f"doctypes.{snake_name}")
    fields = schema.get("fields", [])

    # Prepare field data with test values
    required_fields = []
    optional_fields = []

    for field in fields:
        field_data = {
            "name": field["name"],
            "type": field.get("type", "str"),
            "required": field.get("required", True),
            "default": field.get("default"),
            "test_value": _get_test_value(field.get("type", "str"), field["name"]),
            "update_value": _get_update_value(field.get("type", "str"), field["name"]),
        }

        if field_data["required"] and not field_data["default"]:
            required_fields.append(field_data)
        else:
            optional_fields.append(field_data)

    # Build test code
    lines = [
        f'"""Tests for {name} DocType.',
        "",
        "Auto-generated by Framework M Studio.",
        '"""',
        "",
        "from __future__ import annotations",
        "",
    ]

    # Add imports based on field types
    imports_needed = set()
    for field in fields:
        field_type = field.get("type", "str")
        if "date" in field_type.lower() and "datetime" not in field_type.lower():
            imports_needed.add("from datetime import date")
        if "datetime" in field_type.lower():
            imports_needed.add("from datetime import datetime")
        if "uuid" in field_type.lower():
            imports_needed.add("from uuid import uuid4")
        if "decimal" in field_type.lower():
            imports_needed.add("from decimal import Decimal")

    if imports_needed:
        lines.extend(sorted(imports_needed))
        lines.append("")

    lines.extend(
        [
            "import pytest",
            "",
            f"from {module} import {name}",
            "",
            "",
            f"class Test{name}:",
            f'    """Tests for {name} DocType."""',
            "",
        ]
    )

    # Test: Create with required fields
    lines.extend(
        [
            f"    def test_create_{snake_name}(self) -> None:",
            f'        """Test creating a {name} instance with required fields."""',
            f"        doc = {name}(",
        ]
    )

    for field in required_fields:
        lines.append(f"            {field['name']}={field['test_value']},")

    lines.extend(
        [
            "        )",
            "        assert doc is not None",
        ]
    )

    for field in required_fields:
        lines.append(f"        assert doc.{field['name']} == {field['test_value']}")

    lines.append("")

    # Test: Default values
    if optional_fields:
        lines.extend(
            [
                f"    def test_{snake_name}_defaults(self) -> None:",
                '        """Test default values for optional fields."""',
                f"        doc = {name}(",
            ]
        )

        for field in required_fields:
            lines.append(f"            {field['name']}={field['test_value']},")

        lines.extend(
            [
                "        )",
            ]
        )

        for field in optional_fields:
            if field["default"]:
                lines.append(
                    f"        assert doc.{field['name']} == {field['default']}"
                )
            else:
                lines.append(f"        assert doc.{field['name']} is None")

        lines.append("")

    # Test: Validation (required fields)
    if required_fields:
        lines.extend(
            [
                f"    def test_{snake_name}_validation(self) -> None:",
                '        """Test validation error when required fields are missing."""',
                "        import pydantic",
                "",
                "        with pytest.raises(pydantic.ValidationError):",
                f"            {name}()  # Missing required fields",
                "",
            ]
        )

    # Test: Update fields
    if required_fields:
        lines.extend(
            [
                f"    def test_update_{snake_name}(self) -> None:",
                f'        """Test updating {name} fields."""',
                f"        doc = {name}(",
            ]
        )

        for field in required_fields:
            lines.append(f"            {field['name']}={field['test_value']},")

        lines.extend(
            [
                "        )",
                "",
            ]
        )

        # Update the first required field
        if required_fields:
            first_field = required_fields[0]
            lines.extend(
                [
                    f"        doc.{first_field['name']} = {first_field['update_value']}",
                    f"        assert doc.{first_field['name']} == {first_field['update_value']}",
                ]
            )

        lines.append("")

    # Test: CRUD cycle (integration test stub)
    lines.extend(
        [
            "    @pytest.mark.skip(reason='Integration test - requires database')",
            f"    async def test_{snake_name}_crud(self) -> None:",
            f'        """Test full CRUD cycle for {name}."""',
            "        # Create",
            f"        doc = {name}(",
        ]
    )

    for field in required_fields:
        lines.append(f"            {field['name']}={field['test_value']},")

    lines.extend(
        [
            "        )",
            "        # saved_doc = await repository.save(doc)",
            "        # assert saved_doc.id is not None",
            "",
            "        # Read",
            "        # fetched = await repository.get(saved_doc.id)",
            "        # assert fetched is not None",
        ]
    )

    if required_fields:
        first_field = required_fields[0]
        lines.append(
            f"        # assert fetched.{first_field['name']} == {first_field['test_value']}"
        )

    lines.extend(
        [
            "",
            "        # Update",
        ]
    )

    if required_fields:
        first_field = required_fields[0]
        lines.extend(
            [
                f"        # fetched.{first_field['name']} = {first_field['update_value']}",
                "        # updated = await repository.save(fetched)",
                f"        # assert updated.{first_field['name']} == {first_field['update_value']}",
            ]
        )

    lines.extend(
        [
            "",
            "        # Delete",
            "        # await repository.delete(saved_doc.id)",
            "        # deleted = await repository.get(saved_doc.id)",
            "        # assert deleted is None",
            "",
        ]
    )

    return "\n".join(lines)


def generate_test_file(
    schema: dict[str, Any],
    output_dir: Path | str,
) -> Path:
    """Generate and write a test file for a DocType.

    Args:
        schema: DocType schema dictionary
        output_dir: Directory to write test file to

    Returns:
        Path to the created test file
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    name = schema["name"]
    snake_name = _to_snake_case(name)

    test_code = generate_test(schema)
    test_path = output_dir / f"test_{snake_name}.py"
    test_path.write_text(test_code, encoding="utf-8")

    return test_path


__all__ = [
    "generate_test",
    "generate_test_file",
]
