"""Client SDK Generator for Framework M.

Generates TypeScript and Python client code from OpenAPI schemas.
Uses stdlib only - no external dependencies required.
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any
from urllib.request import Request, urlopen


def fetch_openapi_schema(openapi_url: str, *, timeout: int = 30) -> dict[str, Any]:
    """Fetch OpenAPI schema from a running server.

    Args:
        openapi_url: URL to fetch OpenAPI schema from.
        timeout: Request timeout in seconds.

    Returns:
        OpenAPI schema as dict.
    """
    request = Request(openapi_url)
    request.add_header("Accept", "application/json")

    with urlopen(request, timeout=timeout) as response:
        data: dict[str, Any] = json.loads(response.read().decode("utf-8"))
        return data


def _openapi_type_to_typescript(openapi_type: str, format_: str | None = None) -> str:
    """Convert OpenAPI type to TypeScript type."""
    type_map = {
        "string": "string",
        "integer": "number",
        "number": "number",
        "boolean": "boolean",
        "array": "any[]",
        "object": "Record<string, any>",
    }
    if format_ == "date" or format_ == "date-time":
        return "string"  # ISO date strings
    return type_map.get(openapi_type, "any")


def _openapi_type_to_python(openapi_type: str, format_: str | None = None) -> str:
    """Convert OpenAPI type to Python type."""
    type_map = {
        "string": "str",
        "integer": "int",
        "number": "float",
        "boolean": "bool",
        "array": "list",
        "object": "dict",
    }
    if format_ == "date":
        return "date"
    if format_ == "date-time":
        return "datetime"
    return type_map.get(openapi_type, "Any")


def generate_typescript_types(schema: dict[str, Any]) -> str:
    """Generate TypeScript interface definitions from OpenAPI schemas.

    Args:
        schema: OpenAPI schema dict.

    Returns:
        TypeScript code string.
    """
    lines = [
        "// Auto-generated TypeScript types from OpenAPI schema",
        "// Generated by Framework M Studio",
        "",
    ]

    components = schema.get("components", {})
    schemas = components.get("schemas", {})

    for name, definition in schemas.items():
        if definition.get("type") == "object":
            lines.append(f"export interface {name} {{")
            properties = definition.get("properties", {})
            required = definition.get("required", [])

            for prop_name, prop_def in properties.items():
                prop_type = _openapi_type_to_typescript(
                    prop_def.get("type", "any"),
                    prop_def.get("format"),
                )
                optional = "" if prop_name in required else "?"
                lines.append(f"  {prop_name}{optional}: {prop_type};")

            lines.append("}")
            lines.append("")

    return "\n".join(lines)


def generate_typescript_client(schema: dict[str, Any]) -> str:
    """Generate TypeScript fetch client from OpenAPI schema.

    Args:
        schema: OpenAPI schema dict.

    Returns:
        TypeScript client code string.
    """
    lines = [
        "// Auto-generated TypeScript client from OpenAPI schema",
        "// Generated by Framework M Studio",
        "",
        "const BASE_URL = '';",
        "",
        "async function fetchAPI<T>(path: string, options?: RequestInit): Promise<T> {",
        "  const response = await fetch(`${BASE_URL}${path}`, options);",
        "  if (!response.ok) throw new Error(`HTTP ${response.status}`);",
        "  return response.json();",
        "}",
        "",
    ]

    paths = schema.get("paths", {})

    for path, methods in paths.items():
        for method, operation in methods.items():
            if isinstance(operation, dict) and "operationId" in operation:
                op_id = operation["operationId"]
                http_method = method.upper()

                lines.append(f"export async function {op_id}(): Promise<any> {{")
                lines.append(
                    f"  return fetchAPI('{path}', {{ method: '{http_method}' }});"
                )
                lines.append("}")
                lines.append("")

    return "\n".join(lines)


def generate_python_models(schema: dict[str, Any]) -> str:
    """Generate Python Pydantic models from OpenAPI schemas.

    Args:
        schema: OpenAPI schema dict.

    Returns:
        Python code string.
    """
    lines = [
        '"""Auto-generated Pydantic models from OpenAPI schema.',
        "",
        "Generated by Framework M Studio",
        '"""',
        "",
        "from __future__ import annotations",
        "",
        "from datetime import date, datetime",
        "from typing import Any, Optional",
        "",
        "from pydantic import BaseModel",
        "",
    ]

    components = schema.get("components", {})
    schemas = components.get("schemas", {})

    for name, definition in schemas.items():
        if definition.get("type") == "object":
            lines.append(f"class {name}(BaseModel):")

            properties = definition.get("properties", {})
            required = definition.get("required", [])

            if not properties:
                lines.append("    pass")
            else:
                for prop_name, prop_def in properties.items():
                    prop_type = _openapi_type_to_python(
                        prop_def.get("type", "Any"),
                        prop_def.get("format"),
                    )
                    if prop_name not in required:
                        prop_type = f"Optional[{prop_type}]"
                    lines.append(f"    {prop_name}: {prop_type}")

            lines.append("")

    return "\n".join(lines)


def run_codegen(
    lang: str = "ts",
    out: str = "./generated",
    openapi_url: str = "http://localhost:8000/schema/openapi.json",
) -> None:
    """Run the client SDK generator.

    Args:
        lang: Target language (ts or py).
        out: Output directory.
        openapi_url: URL to fetch OpenAPI schema from.
    """
    output_dir = Path(out)
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"üîß Generating {lang.upper()} client from {openapi_url}")

    # Fetch schema
    schema = fetch_openapi_schema(openapi_url)
    print(f"   ‚úì Fetched OpenAPI schema: {schema.get('info', {}).get('title', 'API')}")

    if lang == "ts":
        # Generate TypeScript
        types_code = generate_typescript_types(schema)
        client_code = generate_typescript_client(schema)

        (output_dir / "types.ts").write_text(types_code)
        (output_dir / "client.ts").write_text(client_code)

        print(f"   ‚úì Generated: {output_dir}/types.ts")
        print(f"   ‚úì Generated: {output_dir}/client.ts")

    elif lang == "py":
        # Generate Python
        models_code = generate_python_models(schema)
        (output_dir / "models.py").write_text(models_code)

        print(f"   ‚úì Generated: {output_dir}/models.py")

    else:
        print(f"   ‚ùå Unknown language: {lang}")
        print("      Supported: ts (TypeScript), py (Python)")
        return

    print("   ‚úÖ Code generation complete!")
