<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<h1 align="center">
<p>üí• bunker-stats</p>
</h1>
<p align="center">
</p><p>A Rust powered statistical toolkit with a Python API and pandas Styler integration.</p>
<p></p>
<p align="center">
</p><p><img src="https://img.shields.io/badge/language-Rust-orange.svg"> <img src="https://img.shields.io/badge/binding-Python-blue.svg"> <img src="https://img.shields.io/badge/status-v0.1-green.svg"> <img src="https://img.shields.io/badge/build-maturin-red.svg"></p>
<p></p>
<hr>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">üîß Overview</h2>
<p><strong>bunker-stats</strong> is a hybrid Rust and Python library providing:</p>
<ul>
<li>Fast statistical primitives<br>
</li>
<li>Rolling window analytics<br>
</li>
<li>Distribution tools<br>
</li>
<li>pandas Styler visualizations</li>
</ul>
<p>Everything runs on Rust for speed and correctness.</p>
<hr>
</section>
<section id="project-philosophy-and-status" class="level2">
<h2 class="anchored" data-anchor-id="project-philosophy-and-status">üß≠ Project Philosophy and Status</h2>
<p><strong>v0.1 is an intentional early release.</strong></p>
<p>This library focuses on correctness, clean APIs, and solid statistical foundations.</p>
<section id="future-focus" class="level3">
<h3 class="anchored" data-anchor-id="future-focus">üîÆ Future Focus</h3>
<ul>
<li>Performance tuning (SIMD, fused loops, BLAS ops)<br>
</li>
<li>Smarter rolling window engines<br>
</li>
<li>More visualization helpers<br>
</li>
<li>NaN safe variants<br>
</li>
<li>Multi column Rust kernels<br>
</li>
<li>Faster correlation matrix engine</li>
</ul>
<hr>
</section>
</section>
<section id="features" class="level2">
<h2 class="anchored" data-anchor-id="features">üöÄ Features</h2>
<section id="core-statistics-rust" class="level3">
<h3 class="anchored" data-anchor-id="core-statistics-rust">Core statistics (Rust)</h3>
<ul>
<li>Mean, variance, standard deviation<br>
</li>
<li>Sample vs population versions<br>
</li>
<li>Z scores<br>
</li>
<li>MAD<br>
</li>
<li>Percentiles and quantiles<br>
</li>
<li>IQR and Tukey fences<br>
</li>
<li>Covariance, correlation<br>
</li>
<li>Welford one pass algorithms<br>
</li>
<li>EWMA</li>
</ul>
</section>
<section id="rolling-analytics" class="level3">
<h3 class="anchored" data-anchor-id="rolling-analytics">Rolling analytics</h3>
<ul>
<li>Rolling mean, std, z score<br>
</li>
<li>Rolling covariance, correlation<br>
</li>
<li>Planned fused pipelines</li>
</ul>
</section>
<section id="distribution-tools" class="level3">
<h3 class="anchored" data-anchor-id="distribution-tools">Distribution tools</h3>
<ul>
<li>ECDF<br>
</li>
<li>Gaussian KDE<br>
</li>
<li>Quantile binning<br>
</li>
<li>Winsorization</li>
</ul>
</section>
<section id="transforms" class="level3">
<h3 class="anchored" data-anchor-id="transforms">Transforms</h3>
<ul>
<li>Robust scaling using Median and MAD<br>
</li>
<li>diff, pct_change, cumsum, cummean</li>
</ul>
</section>
<section id="pandas-styler" class="level3">
<h3 class="anchored" data-anchor-id="pandas-styler">pandas Styler</h3>
<ul>
<li><code>demean_style(df, column)</code><br>
</li>
<li><code>zscore_style(df, column, threshold=...)</code><br>
</li>
<li><code>iqr_outlier_style(df, column)</code><br>
</li>
<li><code>corr_heatmap(df)</code><br>
</li>
<li><code>robust_scale_column(df, column)</code></li>
</ul>
<hr>
<table class="table">
<colgroup>
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Bunker-stats syntax</th>
<th>NumPy equivalent</th>
<th>pandas equivalent</th>
<th>Unique feature in <code>bunker-stats</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mean</code></td>
<td><code>bs.mean(x)</code></td>
<td><code>np.mean(x)</code></td>
<td><code>s.mean()</code></td>
<td>1D mean helper; always treats input as 1D numeric, thin Rust-backed wrapper.</td>
</tr>
<tr class="even">
<td><code>mean_skipna</code></td>
<td><code>bs.mean_skipna(x)</code></td>
<td><code>np.nanmean(x)</code> / manual mask</td>
<td><code>s.mean(skipna=True)</code></td>
<td>NaN-aware mean with explicit ‚Äúskipna‚Äù semantics, matching pandas mental model.</td>
</tr>
<tr class="odd">
<td><code>var</code></td>
<td><code>bs.var(x)</code></td>
<td><code>np.var(x, ddof=1)</code></td>
<td><code>s.var(ddof=1)</code></td>
<td>1D <strong>sample</strong> variance (<code>ddof=1</code>) by default; matches stats textbooks.</td>
</tr>
<tr class="even">
<td><code>var_skipna</code></td>
<td><code>bs.var_skipna(x)</code></td>
<td><code>np.nanvar(x, ddof=1)</code> / mask</td>
<td><code>s.var(skipna=True, ddof=1)</code></td>
<td>NaN-aware sample variance in one call.</td>
</tr>
<tr class="odd">
<td><code>std</code></td>
<td><code>bs.std(x)</code></td>
<td><code>np.std(x, ddof=1)</code></td>
<td><code>s.std(ddof=1)</code></td>
<td>1D sample std with fixed <code>ddof=1</code>, consistent with <code>var</code>.</td>
</tr>
<tr class="even">
<td><code>std_skipna</code></td>
<td><code>bs.std_skipna(x)</code></td>
<td><code>np.nanstd(x, ddof=1)</code> / mask</td>
<td><code>s.std(skipna=True, ddof=1)</code></td>
<td>NaN-aware sample std; avoids writing masks every time.</td>
</tr>
<tr class="odd">
<td><code>percentile</code></td>
<td><code>bs.percentile(x, q=0.95)</code></td>
<td><code>np.quantile(x, 0.95)</code> / <code>np.percentile</code></td>
<td><code>np.quantile(s, 0.95)</code></td>
<td>Clean 1D percentile with your interpolation; integrated with other robust stats.</td>
</tr>
<tr class="even">
<td><code>mad</code></td>
<td><code>bs.mad(x)</code></td>
<td>manual median/MAD</td>
<td>custom or <code>s.mad()</code> (mean abs dev, not median)</td>
<td>True median absolute deviation used by <code>robust_scale</code>.</td>
</tr>
<tr class="odd">
<td><code>iqr</code></td>
<td><code>q1, q3, iqr = bs.iqr(x)</code></td>
<td><code>scipy.stats.iqr(x, rng=(25,75))</code></td>
<td><code>s.quantile([0.25, 0.75])</code></td>
<td>Returns <code>(q1, q3, iqr)</code> in one go; no juggling multiple calls / indices.</td>
</tr>
<tr class="even">
<td><code>mean_axis</code></td>
<td><code>bs.mean_axis(X, axis=0, skipna=False)</code></td>
<td><code>np.mean(X, axis=0)</code></td>
<td><code>df.mean(axis=0, skipna=...)</code></td>
<td>Axis-wise mean for 1D/2D arrays with optional <code>skipna</code>.</td>
</tr>
<tr class="odd">
<td><code>var_axis</code></td>
<td><code>bs.var_axis(X, axis=1, skipna=True)</code></td>
<td><code>np.var(X, axis=1, ddof=1)</code> (no native skipna)</td>
<td><code>df.var(axis=1, skipna=...)</code></td>
<td>Axis-wise sample variance with built-in NaN handling.</td>
</tr>
<tr class="even">
<td><code>std_axis</code></td>
<td><code>bs.std_axis(X, axis=1, skipna=True)</code></td>
<td><code>np.std(X, axis=1, ddof=1)</code> (no native skipna)</td>
<td><code>df.std(axis=1, skipna=...)</code></td>
<td>Axis-wise sample std + <code>skipna</code>; aligns pandas mental model with NumPy arrays.</td>
</tr>
<tr class="odd">
<td><code>mean_last_axis</code>*</td>
<td><code>bs.mean_last_axis(X)</code> <em>(if exposed)</em></td>
<td><code>np.mean(X, axis=-1)</code></td>
<td><code>df.to_numpy().mean(axis=-1)</code></td>
<td>N-D mean over last axis, consistent with your N-D rolling API.</td>
</tr>
<tr class="even">
<td><code>rolling_mean_last_axis</code></td>
<td><code>bs.rolling_mean_last_axis(X, window=3)</code></td>
<td>manual reshape + loop / <code>np.apply_along_axis</code></td>
<td>no built-in; need groupby+apply / custom logic</td>
<td>Shape-preserving N-D rolling mean over <strong>last axis</strong> (e.g.&nbsp;<code>(batch, feat, time)</code>).</td>
</tr>
<tr class="odd">
<td><code>rolling_std_last_axis</code></td>
<td><code>bs.rolling_std_last_axis(X, window=3)</code></td>
<td>same as above</td>
<td>same</td>
<td>N-D rolling std over last axis; perfect for batched time-series / ML tensors.</td>
</tr>
<tr class="even">
<td><code>rolling_mean</code></td>
<td><code>bs.rolling_mean(x, window=5)</code></td>
<td>manual loop or <code>np.convolve</code> trick</td>
<td><code>s.rolling(5).mean()</code></td>
<td>Fast 1D rolling mean (truncated length) with no index overhead.</td>
</tr>
<tr class="odd">
<td><code>rolling_std</code></td>
<td><code>bs.rolling_std(x, window=5)</code></td>
<td>manual loop</td>
<td><code>s.rolling(5).std()</code></td>
<td>1D rolling std at Rust speed, sample variance convention.</td>
</tr>
<tr class="even">
<td><code>rolling_zscore</code></td>
<td><code>bs.rolling_zscore(x, window=20)</code></td>
<td>manual window loop</td>
<td><code>s.rolling(20).apply(custom)</code></td>
<td>Rolling z-score in a single function; avoids <code>apply</code>/UDF overhead.</td>
</tr>
<tr class="odd">
<td><code>ewma</code></td>
<td><code>bs.ewma(x, alpha=0.1)</code></td>
<td>manual recurrence</td>
<td><code>s.ewm(alpha=0.1).mean()</code></td>
<td>Minimal EWMA for pure numeric arrays, no pandas object overhead.</td>
</tr>
<tr class="even">
<td><code>df_rolling_mean</code></td>
<td><code>bs.df_rolling_mean(df, window=5)</code></td>
<td><code>np.convolve</code> per column</td>
<td><code>df.rolling(5).mean()</code></td>
<td>DataFrame in / out, but columns powered by Rust rolling mean.</td>
</tr>
<tr class="odd">
<td><code>df_rolling_std</code></td>
<td><code>bs.df_rolling_std(df, window=5)</code></td>
<td>manual per-column</td>
<td><code>df.rolling(5).std()</code></td>
<td>Same for std; uses your rolling core but preserves pandas index.</td>
</tr>
<tr class="even">
<td><code>df_ewma</code></td>
<td><code>bs.df_ewma(df, alpha=0.1)</code></td>
<td>manual per-column EWMA</td>
<td><code>df.ewm(alpha=0.1).mean()</code></td>
<td>Per-column EWMA with Rust engine, lighter than full pandas EWM machinery.</td>
</tr>
<tr class="odd">
<td><code>col_mean</code></td>
<td><code>bs.col_mean(df, skipna=True)</code></td>
<td><code>np.mean(df.to_numpy(), axis=0)</code></td>
<td><code>df.mean(axis=0, skipna=True)</code></td>
<td>Column-wise mean; internally uses <code>mean_axis</code> + <code>skipna</code>, returns labeled Series.</td>
</tr>
<tr class="even">
<td><code>row_mean</code></td>
<td><code>bs.row_mean(df, skipna=True)</code></td>
<td><code>np.mean(df.to_numpy(), axis=1)</code></td>
<td><code>df.mean(axis=1, skipna=True)</code></td>
<td>Row-wise mean with Rust numeric core + pandas index.</td>
</tr>
<tr class="odd">
<td><code>cov_df</code></td>
<td><code>bs.cov_df(df)</code></td>
<td><code>np.cov(df.to_numpy().T, ddof=1)</code></td>
<td><code>df.cov()</code></td>
<td>Full covariance matrix via Rust <code>cov_matrix</code>, but returned as a DataFrame.</td>
</tr>
<tr class="even">
<td><code>corr_df</code></td>
<td><code>bs.corr_df(df)</code></td>
<td><code>np.corrcoef(df.to_numpy().T)</code></td>
<td><code>df.corr()</code></td>
<td>Correlation matrix backed by your Rust correlation engine.</td>
</tr>
<tr class="odd">
<td><code>rolling_mean_series</code></td>
<td><code>bs.rolling_mean_series(s, window=10)</code></td>
<td>manual 1D loop</td>
<td><code>s.rolling(10).mean()</code></td>
<td>Series-in / Series-out convenience wrapper around Rust rolling mean.</td>
</tr>
<tr class="even">
<td><code>rolling_std_series</code></td>
<td><code>bs.rolling_std_series(s, window=10)</code></td>
<td>manual 1D loop</td>
<td><code>s.rolling(10).std()</code></td>
<td>Same for std; keeps index alignment, uses Rust core.</td>
</tr>
<tr class="odd">
<td><code>iqr_outliers</code></td>
<td><code>bs.iqr_outliers(x, k=1.5)</code></td>
<td><code>iqr = scipy.stats.iqr(x); mask = ...</code></td>
<td>quantiles + boolean mask</td>
<td>Returns a boolean outlier mask in one call using IQR rule.</td>
</tr>
<tr class="even">
<td><code>zscore_outliers</code></td>
<td><code>bs.zscore_outliers(x, threshold=3.0)</code></td>
<td><code>(np.abs((x-x.mean())/x.std()) &gt; 3)</code></td>
<td>same logic on <code>Series</code></td>
<td>One-liner z-score outlier mask; integrates with your <code>mean</code>/<code>std</code> semantics.</td>
</tr>
<tr class="odd">
<td><code>minmax_scale</code></td>
<td><code>scaled, mn, mx = bs.minmax_scale(x)</code></td>
<td>manual <code>(x-mn)/(mx-mn)</code></td>
<td>use <code>MinMaxScaler</code> from sklearn</td>
<td>Returns both <strong>scaled data</strong> and the <code>(min, max)</code> used (for inverse-transform/reuse).</td>
</tr>
<tr class="even">
<td><code>robust_scale</code></td>
<td><code>scaled, med, mad = bs.robust_scale(x, scale_factor)</code></td>
<td>manual MAD calculation</td>
<td><code>RobustScaler</code> or custom</td>
<td>All-in-one robust scaling with returned <code>(median, MAD)</code>; pairs with your <code>mad</code>.</td>
</tr>
<tr class="odd">
<td><code>winsorize</code></td>
<td><code>bs.winsorize(x, lower_q=0.05, upper_q=0.95)</code></td>
<td><code>scipy.stats.mstats.winsorize(x, limits=...)</code></td>
<td>custom quantile clipping</td>
<td>1D winsorization in Rust, single call returning a full adjusted array.</td>
</tr>
<tr class="even">
<td><code>diff</code></td>
<td><code>bs.diff(x, periods=1)</code></td>
<td><code>np.diff(x, n=1)</code> (shorter) / manual padding</td>
<td><code>s.diff(periods=1)</code></td>
<td>Full-length diff with NaNs where necessary; supports negative <code>periods</code>.</td>
</tr>
<tr class="odd">
<td><code>pct_change</code></td>
<td><code>bs.pct_change(x, periods=1)</code></td>
<td>manual <code>(x[i]-x[i-p]) / x[i-p]</code></td>
<td><code>s.pct_change(periods=1)</code></td>
<td>Includes divide-by-zero ‚Üí NaN handling; symmetric for positive/negative lags.</td>
</tr>
<tr class="even">
<td><code>cumsum</code></td>
<td><code>bs.cumsum(x)</code></td>
<td><code>np.cumsum(x)</code></td>
<td><code>s.cumsum()</code></td>
<td>Rust implementation; value is performance on large 1D arrays.</td>
</tr>
<tr class="odd">
<td><code>cummean</code></td>
<td><code>bs.cummean(x)</code></td>
<td><code>np.cumsum(x)/np.arange(1,len(x)+1)</code></td>
<td><code>s.expanding().mean()</code></td>
<td>Streaming cumulative mean without constructing expanding windows.</td>
</tr>
<tr class="even">
<td><code>ecdf</code></td>
<td><code>vals, probs = bs.ecdf(x)</code></td>
<td>manual sort + rank</td>
<td>custom <code>rank</code>/<code>value_counts</code></td>
<td>Returns <strong>sorted values + CDF</strong> in one go; perfect for ECDF plots.</td>
</tr>
<tr class="odd">
<td><code>quantile_bins</code></td>
<td><code>bins = bs.quantile_bins(x, n_bins=10)</code></td>
<td>manual rank + binning</td>
<td><code>pd.qcut(x, q=10)</code> (Categorical)</td>
<td>Returns plain integer bin labels <code>0..n_bins-1</code> as a NumPy array (ML-friendly).</td>
</tr>
<tr class="even">
<td><code>sign_mask</code></td>
<td><code>mask = bs.sign_mask(x)</code></td>
<td><code>np.sign(x).astype(np.int8)</code></td>
<td><code>(s &gt; 0) - (s &lt; 0)</code></td>
<td>Encodes sign into <code>{-1, 0, 1}</code>; useful for discrete signal features.</td>
</tr>
<tr class="odd">
<td><code>demean_with_signs</code></td>
<td><code>demeaned, signs = bs.demean_with_signs(x)</code></td>
<td><code>(x - x.mean(), np.sign(x - x.mean()))</code></td>
<td>custom</td>
<td>Returns <strong>both</strong> demeaned data and sign mask in one pass.</td>
</tr>
<tr class="even">
<td><code>cov</code></td>
<td><code>bs.cov(x, y)</code></td>
<td><code>np.cov(x, y, ddof=1)[0,1]</code></td>
<td><code>s1.cov(s2)</code></td>
<td>1D sample covariance as a simple scalar function.</td>
</tr>
<tr class="odd">
<td><code>corr</code></td>
<td><code>bs.corr(x, y)</code></td>
<td><code>np.corrcoef(x, y)[0,1]</code></td>
<td><code>s1.corr(s2)</code></td>
<td>1D Pearson correlation using your var/std core.</td>
</tr>
<tr class="even">
<td><code>cov_skipna</code></td>
<td><code>bs.cov_skipna(x, y)</code></td>
<td>manual pairwise dropna + <code>np.cov</code></td>
<td><code>s1.cov(s2)</code> with aligned/dropna</td>
<td>Pairwise NaN dropping built in for 1D covariance.</td>
</tr>
<tr class="odd">
<td><code>corr_skipna</code></td>
<td><code>bs.corr_skipna(x, y)</code></td>
<td>manual pairwise dropna + <code>np.corrcoef</code></td>
<td><code>s1.corr(s2)</code> with dropna</td>
<td>Same but for correlation; hides the messy mask-bookkeeping.</td>
</tr>
<tr class="even">
<td><code>cov_matrix</code></td>
<td><code>bs.cov_matrix(X)</code></td>
<td><code>np.cov(X, rowvar=False, ddof=1)</code></td>
<td><code>df.cov()</code></td>
<td>Symmetric covariance matrix with Rust loops; tuned for tabular X.</td>
</tr>
<tr class="odd">
<td><code>corr_matrix</code></td>
<td><code>bs.corr_matrix(X)</code></td>
<td><code>np.corrcoef(X, rowvar=False)</code></td>
<td><code>df.corr()</code></td>
<td>Correlation matrix built on your cov/std stack; consistent behaviour across code paths.</td>
</tr>
<tr class="even">
<td><code>rolling_cov</code></td>
<td><code>bs.rolling_cov(x, y, window=50)</code></td>
<td>manual sliding window + <code>np.cov</code></td>
<td><code>df['x'].rolling(50).cov(df['y'])</code></td>
<td>Rolling 1D covariance without pandas overhead; good for streaming stats.</td>
</tr>
<tr class="odd">
<td><code>rolling_corr</code></td>
<td><code>bs.rolling_corr(x, y, window=50)</code></td>
<td>manual sliding window + <code>np.corrcoef</code></td>
<td><code>df['x'].rolling(50).corr(df['y'])</code></td>
<td>Rolling 1D correlation in one Rust call; no custom loop needed in Python.</td>
</tr>
<tr class="even">
<td><code>kde_gaussian</code></td>
<td><code>grid, dens = bs.kde_gaussian(x, n_points=256)</code></td>
<td><code>scipy.stats.gaussian_kde(x)</code> + evaluation</td>
<td>no direct builtin (need SciPy)</td>
<td>Lightweight 1D Gaussian KDE; returns <code>(grid, density)</code> using a simple bandwidth rule by default.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="installation" class="level2">
<h2 class="anchored" data-anchor-id="installation">üì¶ Installation</h2>
<p>```bash git clone https://github.com/bunker-stats.git cd bunker-stats</p>
<p>python -m venv .venv source .venv/bin/activate # Windows: .venv</p>
<p>pip install maturin maturin develop</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>