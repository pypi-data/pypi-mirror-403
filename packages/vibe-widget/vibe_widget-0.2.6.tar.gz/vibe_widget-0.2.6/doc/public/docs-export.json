{
  "generated_at": "2025-12-25T08:19:28.802Z",
  "site": {
    "name": "Vibe Widget",
    "description": "Interactive widgets for notebooks, generated from natural language and data.",
    "base_url": "https://vibewidget.dev"
  },
  "pages": [
    {
      "id": "installation",
      "path": "/docs",
      "title": "Installation",
      "description": "Get up and running with Vibe Widget in seconds.",
      "content_html": "<p>Get up and running with Vibe Widget in seconds.</p>\n<pre><code>pip install vibe-widget</code></pre>\n<p>Vibe Widget requires Python 3.8+ and an OpenRouter API key.</p>\n<pre><code class=\"language-bash\">export OPENROUTER_API_KEY=&#x27;your-key&#x27;\n</code></pre>\n<h2>Quick start</h2>\n<pre><code class=\"language-python\">import pandas as pd\nimport vibe_widget as vw\n\ndf = pd.read_csv(&quot;sales.csv&quot;)\n\nwidget = vw.create(\n    &quot;scatter plot with brush selection, and a linked histogram&quot;,\n    df,\n    outputs=vw.outputs(selected_indices=&quot;indices of selected points&quot;)\n)\n\nwidget\n</code></pre>",
      "content_text": "Get up and running with Vibe Widget in seconds. pip install vibe-widget Vibe Widget requires Python 3.8+ and an OpenRouter API key. export OPENROUTER_API_KEY=&#x27;your-key&#x27; Quick start import pandas as pd import vibe_widget as vw df = pd.read_csv(&quot;sales.csv&quot;) widget = vw.create( &quot;scatter plot with brush selection, and a linked histogram&quot;, df, outputs=vw.outputs(selected_indices=&quot;indices of selected points&quot;) ) widget"
    },
    {
      "id": "config",
      "path": "/docs/config",
      "title": "Configuration",
      "description": "Configure model settings and API keys.",
      "content_html": "<p>Configure model settings and API keys.</p>\n<h2>Set defaults</h2>\n<pre><code class=\"language-python\">import vibe_widget as vw\n\nvw.config(model=&quot;openai/gpt-5.2-codex&quot;)\nvw.config(mode=&quot;premium&quot;, model=&quot;openrouter&quot;)\nvw.config(execution=&quot;approve&quot;)\n</code></pre>\n<h2>API key setup</h2>\n<pre><code class=\"language-bash\">export OPENROUTER_API_KEY=&#x27;your-key&#x27;\n</code></pre>\n<pre><code class=\"language-python\">import os\nfrom dotenv import load_dotenv\nimport vibe_widget as vw\n\nload_dotenv()\napi_key = os.getenv(&quot;MY_SECRET_API_KEY&quot;)\n\nvw.config(api_key=api_key)\n</code></pre>\n<p>We recommend avoiding hardcoded keys in notebooks to prevent accidental leaks.</p>\n<h2>Models</h2>\n<pre><code class=\"language-python\">vw.models()\nvw.models(show=&quot;all&quot;)\nvw.models(verbose=False)\n</code></pre>\n<h2>Privacy and telemetry</h2>\n<p>Vibe Widget sends the following to the model provider:</p>\n<ul>\n<li>your prompt and theme prompt</li>\n<li>data schema (column names, dtypes)</li>\n<li>a small sample of rows (up to 3)</li>\n<li>outputs/inputs descriptors</li>\n<li>full widget code for edits, audits, and runtime fixes</li>\n<li>runtime error messages (when auto-fixing)</li>\n</ul>\n<p>No API keys are written to disk. Generated widgets and audit reports are stored locally in <code>.vibewidget/</code>.</p>",
      "content_text": "Configure model settings and API keys. Set defaults import vibe_widget as vw vw.config(model=&quot;openai/gpt-5.2-codex&quot;) vw.config(mode=&quot;premium&quot;, model=&quot;openrouter&quot;) vw.config(execution=&quot;approve&quot;) API key setup export OPENROUTER_API_KEY=&#x27;your-key&#x27; import os from dotenv import load_dotenv import vibe_widget as vw load_dotenv() api_key = os.getenv(&quot;MY_SECRET_API_KEY&quot;) vw.config(api_key=api_key) We recommend avoiding hardcoded keys in notebooks to prevent accidental leaks. Models vw.models() vw.models(show=&quot;all&quot;) vw.models(verbose=False) Privacy and telemetry Vibe Widget sends the following to the model provider: your prompt and theme prompt data schema (column names, dtypes) a small sample of rows (up to 3) outputs/inputs descriptors full widget code for edits, audits, and runtime fixes runtime error messages (when auto-fixing) No API keys are written to disk. Generated widgets and audit reports are stored locally in .vibewidget/."
    },
    {
      "id": "create",
      "path": "/docs/create",
      "title": "Create",
      "description": "Create widgets from natural language prompts and data sources.",
      "content_html": "<p>Create widgets from natural language prompts and data sources.</p>\n<pre><code class=\"language-python\">import vibe_widget as vw\n\nwidget = vw.create(\n    &quot;bar chart of revenue by region&quot;,\n    df\n)\n\nwidget\n</code></pre>\n<h2>Inputs and outputs</h2>\n<p>Use <code>vw.inputs</code> to pass multiple inputs, and <code>vw.outputs</code> to define reactive state your widget exposes.</p>\n<pre><code class=\"language-python\">vw.create(\n    &quot;...&quot;,\n    vw.inputs(df, selected_indices=other_widget.outputs.selected_indices)\n)\n</code></pre>\n<pre><code class=\"language-python\">scatter = vw.create(\n    &quot;scatter with brush selection&quot;,\n    df,\n    outputs=vw.outputs(selected_indices=&quot;indices of selected points&quot;)\n)\n\nscatter.outputs.selected_indices.value\n</code></pre>\n<h2>Dataflow and I/O contract</h2>\n<p><code>vw.create</code> converts data to a list of record dicts and cleans non-JSON values (NaN/NaT/inf to <code>None</code>). Inputs and outputs are synced traitlets. When providing another widget output, Vibe Widget reads the current value once, then keeps it in sync via trait updates. Outputs start as <code>None</code> and are updated by generated JS code.</p>\n<h2>Supported data sources</h2>\n<ul>\n<li><code>pandas.DataFrame</code></li>\n<li>local file paths (CSV/TSV, JSON/GeoJSON, Parquet, NetCDF, XML, ISF, Excel, PDF, TXT)</li>\n<li>URLs (via <code>crawl4ai</code>, best-effort)</li>\n</ul>\n<p>Some loaders require optional dependencies (for example, <code>xarray</code> for NetCDF or <code>camelot</code> for PDF).</p>\n<h2>Theming</h2>\n<p>Themes are natural-language design specs that guide code generation.</p>\n<pre><code class=\"language-python\">vw.create(&quot;...&quot;, df, theme=&quot;financial_times&quot;)\n\nvw.create(&quot;...&quot;, df, theme=&quot;like national geographic but greener&quot;)\n</code></pre>\n<p>Built-in themes are listed via <code>vw.themes()</code>. Theme prompts are cached for the session and can be saved locally.</p>\n<h2>Safety warning</h2>\n<p>Widgets execute LLM-generated JavaScript in the notebook frontend. Treat generated code as untrusted. Use audits and your own verification when the output informs decisions.</p>",
      "content_text": "Create widgets from natural language prompts and data sources. import vibe_widget as vw widget = vw.create( &quot;bar chart of revenue by region&quot;, df ) widget Inputs and outputs Use vw.inputs to pass multiple inputs, and vw.outputs to define reactive state your widget exposes. vw.create( &quot;...&quot;, vw.inputs(df, selected_indices=other_widget.outputs.selected_indices) ) scatter = vw.create( &quot;scatter with brush selection&quot;, df, outputs=vw.outputs(selected_indices=&quot;indices of selected points&quot;) ) scatter.outputs.selected_indices.value Dataflow and I/O contract vw.create converts data to a list of record dicts and cleans non-JSON values (NaN/NaT/inf to None). Inputs and outputs are synced traitlets. When providing another widget output, Vibe Widget reads the current value once, then keeps it in sync via trait updates. Outputs start as None and are updated by generated JS code. Supported data sources pandas.DataFrame local file paths (CSV/TSV, JSON/GeoJSON, Parquet, NetCDF, XML, ISF, Excel, PDF, TXT) URLs (via crawl4ai, best-effort) Some loaders require optional dependencies (for example, xarray for NetCDF or camelot for PDF). Theming Themes are natural-language design specs that guide code generation. vw.create(&quot;...&quot;, df, theme=&quot;financial_times&quot;) vw.create(&quot;...&quot;, df, theme=&quot;like national geographic but greener&quot;) Built-in themes are listed via vw.themes(). Theme prompts are cached for the session and can be saved locally. Safety warning Widgets execute LLM-generated JavaScript in the notebook frontend. Treat generated code as untrusted. Use audits and your own verification when the output informs decisions."
    },
    {
      "id": "edit",
      "path": "/docs/edit",
      "title": "Edit",
      "description": "Iterate on generated widgets using code or the UI.",
      "content_html": "<p>While developing interactive widgets, we often do not know what to fully specify until after the first version exists. Vibe Widget makes iteration a first-class workflow by letting you edit generated widgets through code or the UI.</p>\n<p>Edits reuse existing code and optionally the theme, then apply requested changes. Each edit produces a new widget instance and persists a new version in the widget store.</p>\n<h2>Python edits</h2>\n<p>Use Python edits when you want structural changes, broader logic refactors, or to preserve edits as code in notebooks and scripts. Python edits are ideal for larger, explicit changes you want to keep versioned and reproducible.</p>\n<pre><code class=\"language-python\">v1 = vw.create(&quot;basic scatter&quot;, df)\n\n# Large or structural changes\nv2 = v1.edit(&quot;add hover tooltips and a right-side legend&quot;)\n</code></pre>\n<p>Component-level edits are ideal when the widget exposes named subcomponents and you want precise changes without rewriting the full widget.</p>\n<pre><code class=\"language-python\"># Example: targeted edits via components\nv3 = v1.component.colo_legend.edit(&quot;style the legend with a muted palette&quot;, inputs=df)\n</code></pre>\n<h2>UI edits</h2>\n<p>Use UI edits for fast, interactive iteration inside the widget runtime. These are best for targeted adjustments, quick fixes, and diagnostics without switching to code.</p>\n<h3>Source code editing</h3>\n<p>Make precise changes in the generated JS/HTML/CSS when you need direct control over logic or styling.</p>\n\n<h3>Visual editing (Edit Element)</h3>\n<p>Select a specific element by its bounding box and issue an edit scoped to that element, using full context from the widget.</p>\n\n<h3>Auditing</h3>\n<p>Detect issues, get recommendations, and optionally turn a concern into a fix request. See <a href=\"/docs/audit\">the Audit docs</a> for more information.</p>\n",
      "content_text": "While developing interactive widgets, we often do not know what to fully specify until after the first version exists. Vibe Widget makes iteration a first-class workflow by letting you edit generated widgets through code or the UI. Edits reuse existing code and optionally the theme, then apply requested changes. Each edit produces a new widget instance and persists a new version in the widget store. Python edits Use Python edits when you want structural changes, broader logic refactors, or to preserve edits as code in notebooks and scripts. Python edits are ideal for larger, explicit changes you want to keep versioned and reproducible. v1 = vw.create(&quot;basic scatter&quot;, df) # Large or structural changes v2 = v1.edit(&quot;add hover tooltips and a right-side legend&quot;) Component-level edits are ideal when the widget exposes named subcomponents and you want precise changes without rewriting the full widget. # Example: targeted edits via components v3 = v1.component.colo_legend.edit(&quot;style the legend with a muted palette&quot;, inputs=df) UI edits Use UI edits for fast, interactive iteration inside the widget runtime. These are best for targeted adjustments, quick fixes, and diagnostics without switching to code. Source code editing Make precise changes in the generated JS/HTML/CSS when you need direct control over logic or styling. Visual editing (Edit Element) Select a specific element by its bounding box and issue an edit scoped to that element, using full context from the widget. Auditing Detect issues, get recommendations, and optionally turn a concern into a fix request. See the Audit docs for more information."
    },
    {
      "id": "audit",
      "path": "/docs/audit",
      "title": "Audit",
      "description": "Review widget code and behavior for risks, usability issues, and design gaps.",
      "content_html": "<p>Audits review widget code and behavior through a set of lenses to surface risks, usability issues, and design gaps before you ship.</p>\n<h2>Audit framework</h2>\n<p>Each audit runs across domains and lenses so you get feedback that is both technical and experiential.</p>\n<table><thead><tr><th>Domain</th><th>What It Covers</th><th>Key Questions</th></tr></thead><tbody><tr><td>DATA</td><td>Input, filtering, transformations, formatting. Subdomains: <code>data.input</code>, <code>data.filtering</code>, <code>data.transformations</code>, <code>data.formatting</code>.</td><td>What goes in? What gets dropped? How is it changed?</td></tr><tr><td>COMPUTATION</td><td>Algorithms, parameters, assumptions. Subdomains: <code>computation.algorithm</code>, <code>computation.parameters</code>, <code>computation.assumptions</code>.</td><td>What runs? With what settings? What does it assume?</td></tr><tr><td>PRESENTATION</td><td>Visual encoding, scales, projection. Subdomains: <code>presentation.encoding</code>, <code>presentation.scales</code>, <code>presentation.projection</code>.</td><td>How are results shown? What is hidden or over-emphasized?</td></tr><tr><td>INTERACTION</td><td>Triggers, state, propagation. Subdomains: <code>interaction.triggers</code>, <code>interaction.state</code>, <code>interaction.propagation</code>.</td><td>What changes on input? What persists? What updates downstream?</td></tr><tr><td>SYSTEM</td><td>Accessibility, performance, reliability. Subdomains: <code>system.accessibility</code>, <code>system.performance</code>, <code>system.reliability</code>.</td><td>Is it usable for everyone? Is it fast and stable?</td></tr></tbody></table>\n<p>Each domain is reviewed at a second level to pinpoint the issue scope, such as <code>data.transformations</code> or <code>computation.parameters.bin_size</code>, so fixes stay targeted and explainable.</p>\n<h2>Audit lenses</h2>\n<p>Lenses are the perspectives applied during auditing. You can think of them as different expert reviews running together, such as accessibility, data integrity, or interaction design.</p>\n<h2>Fast vs full audits</h2>\n<p><strong>Fast</strong> audits provide quick issue scans for early iteration. <strong>Full</strong> audits dig deeper with alternatives and higher coverage for pre-share polish.</p>\n<pre><code class=\"language-python\"># Fast audit for quick checks\nreport = widget.audit(level=&quot;fast&quot;, display=False)\n\n# Full audit for deeper review\nfull_report = widget.audit(level=&quot;full&quot;, reuse=True, display=False)\n</code></pre>\n<p>Audit outputs are stored in <code>.vibewidget/audits</code> as JSON and YAML.</p>\n<h2>How to use auditing</h2>\n<p>You can run audits from Python to get a structured report without needing to run the widget UI.</p>\n<pre><code class=\"language-python\"># Run a fast audit and return a report\nreport = widget.audit(level=&quot;fast&quot;, display=False)\n\n# Deep audit for detailed alternatives\nfull_report = widget.audit(level=&quot;full&quot;, reuse=True, display=False)\n</code></pre>\n<p>In the UI, audit recommendations can be surfaced as a checklist inside the <code>Edit Code</code> view. You can then turn a specific concern into an edit request or keep it as a TODO for later.</p>\n\n\n\n\n\n\n",
      "content_text": "Audits review widget code and behavior through a set of lenses to surface risks, usability issues, and design gaps before you ship. Audit framework Each audit runs across domains and lenses so you get feedback that is both technical and experiential. DomainWhat It CoversKey QuestionsDATAInput, filtering, transformations, formatting. Subdomains: data.input, data.filtering, data.transformations, data.formatting.What goes in? What gets dropped? How is it changed?COMPUTATIONAlgorithms, parameters, assumptions. Subdomains: computation.algorithm, computation.parameters, computation.assumptions.What runs? With what settings? What does it assume?PRESENTATIONVisual encoding, scales, projection. Subdomains: presentation.encoding, presentation.scales, presentation.projection.How are results shown? What is hidden or over-emphasized?INTERACTIONTriggers, state, propagation. Subdomains: interaction.triggers, interaction.state, interaction.propagation.What changes on input? What persists? What updates downstream?SYSTEMAccessibility, performance, reliability. Subdomains: system.accessibility, system.performance, system.reliability.Is it usable for everyone? Is it fast and stable? Each domain is reviewed at a second level to pinpoint the issue scope, such as data.transformations or computation.parameters.bin_size, so fixes stay targeted and explainable. Audit lenses Lenses are the perspectives applied during auditing. You can think of them as different expert reviews running together, such as accessibility, data integrity, or interaction design. Fast vs full audits Fast audits provide quick issue scans for early iteration. Full audits dig deeper with alternatives and higher coverage for pre-share polish. # Fast audit for quick checks report = widget.audit(level=&quot;fast&quot;, display=False) # Full audit for deeper review full_report = widget.audit(level=&quot;full&quot;, reuse=True, display=False) Audit outputs are stored in .vibewidget/audits as JSON and YAML. How to use auditing You can run audits from Python to get a structured report without needing to run the widget UI. # Run a fast audit and return a report report = widget.audit(level=&quot;fast&quot;, display=False) # Deep audit for detailed alternatives full_report = widget.audit(level=&quot;full&quot;, reuse=True, display=False) In the UI, audit recommendations can be surfaced as a checklist inside the Edit Code view. You can then turn a specific concern into an edit request or keep it as a TODO for later."
    },
    {
      "id": "reactivity",
      "path": "/docs/reactivity",
      "title": "Reactivity",
      "description": "Connect widgets with reactive inputs and outputs.",
      "content_html": "<p>Outputs are reactive state handles that can be passed into other widgets.</p>\n<pre><code class=\"language-python\">scatter = vw.create(\n    &quot;scatter plot with brush selection tool&quot;,\n    df,\n    outputs=vw.outputs(selected_indices=&quot;indices of selected points&quot;)\n)\n\nhistogram = vw.create(\n    &quot;histogram with highlighted bars for selected data&quot;,\n    vw.inputs(df, selected_indices=scatter.outputs.selected_indices)\n)\n</code></pre>\n<p>When you select points in the scatter plot, the histogram updates via trait syncing. Outputs are exposed under <code>widget.outputs.&lt;name&gt;</code>.</p>",
      "content_text": "Outputs are reactive state handles that can be passed into other widgets. scatter = vw.create( &quot;scatter plot with brush selection tool&quot;, df, outputs=vw.outputs(selected_indices=&quot;indices of selected points&quot;) ) histogram = vw.create( &quot;histogram with highlighted bars for selected data&quot;, vw.inputs(df, selected_indices=scatter.outputs.selected_indices) ) When you select points in the scatter plot, the histogram updates via trait syncing. Outputs are exposed under widget.outputs.&lt;name&gt;."
    },
    {
      "id": "data-sources",
      "path": "/docs/data-sources",
      "title": "Data Sources",
      "description": "Supported inputs and loaders.",
      "content_html": "<p>This documentation section is under construction.</p>",
      "content_text": "This documentation section is under construction."
    },
    {
      "id": "composability",
      "path": "/docs/composability",
      "title": "Composability",
      "description": "Compose widgets using components and outputs.",
      "content_html": "<p>This documentation section is under construction.</p>",
      "content_text": "This documentation section is under construction."
    },
    {
      "id": "theming",
      "path": "/docs/theming",
      "title": "Theming",
      "description": "Style widgets with natural-language design specs.",
      "content_html": "<p>Themes are natural-language design specs that guide code generation.</p>\n<h2>List available themes</h2>\n<pre><code class=\"language-python\">import vibe_widget as vw\n\nvw.themes()\n</code></pre>\n<h2>Create a custom theme</h2>\n<pre><code class=\"language-python\">theme = vw.theme(&quot;like national geographic but greener&quot;)\n\n# Inspect or reuse the generated description\nprint(theme.description)\n\nvw.create(&quot;...&quot;, df, theme=theme.description)\n</code></pre>\n<h2>Use a theme in create</h2>\n<pre><code class=\"language-python\">vw.create(&quot;...&quot;, df, theme=&quot;financial_times&quot;)\n</code></pre>",
      "content_text": "Themes are natural-language design specs that guide code generation. List available themes import vibe_widget as vw vw.themes() Create a custom theme theme = vw.theme(&quot;like national geographic but greener&quot;) # Inspect or reuse the generated description print(theme.description) vw.create(&quot;...&quot;, df, theme=theme.description) Use a theme in create vw.create(&quot;...&quot;, df, theme=&quot;financial_times&quot;)"
    },
    {
      "id": "examples-cross-widget",
      "path": "/docs/examples/cross-widget",
      "title": "Cross-Widget Interactions",
      "description": "Interactive notebook example for cross-widget state sharing.",
      "content_html": "<div class=\"placeholder\"><div class=\"placeholder-label\">Interactive Notebook</div><div class=\"placeholder-caption\">Cross-Widget Interactions</div></div>",
      "content_text": "Interactive NotebookCross-Widget Interactions"
    },
    {
      "id": "examples-tictactoe",
      "path": "/docs/examples/tictactoe",
      "title": "Tic-Tac-Toe AI",
      "description": "Interactive notebook example for game logic and UI.",
      "content_html": "<div class=\"placeholder\"><div class=\"placeholder-label\">Interactive Notebook</div><div class=\"placeholder-caption\">Tic-Tac-Toe AI</div></div>",
      "content_text": "Interactive NotebookTic-Tac-Toe AI"
    },
    {
      "id": "examples-pdf-web",
      "path": "/docs/examples/pdf-web",
      "title": "PDF & Web Data Extraction",
      "description": "Interactive notebook example for scraping and parsing.",
      "content_html": "<div class=\"placeholder\"><div class=\"placeholder-label\">Interactive Notebook</div><div class=\"placeholder-caption\">PDF &amp; Web Data Extraction</div></div>",
      "content_text": "Interactive NotebookPDF &amp; Web Data Extraction"
    },
    {
      "id": "examples-edit",
      "path": "/docs/examples/edit",
      "title": "Widget Editing",
      "description": "Interactive notebook example for editing workflows.",
      "content_html": "<div class=\"placeholder\"><div class=\"placeholder-label\">Interactive Notebook</div><div class=\"placeholder-caption\">Widget Editing</div></div>",
      "content_text": "Interactive NotebookWidget Editing"
    },
    {
      "id": "widgetarium",
      "path": "/docs/widgetarium",
      "title": "Widgetarium",
      "description": "The ecosystem of widgets and templates.",
      "content_html": "<p>This documentation section is under construction.</p>",
      "content_text": "This documentation section is under construction."
    }
  ]
}