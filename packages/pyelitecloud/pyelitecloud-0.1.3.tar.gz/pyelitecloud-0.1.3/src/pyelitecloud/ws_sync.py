# Do not edit this file directly. It has been autogenerated from
# src\pyelitecloud\ws_async.py
import asyncio
import logging

import httpx
import httpx_ws

from pyelitecloud.const import PANEL_API_WS

from .tasks import (
    AsyncTaskHelper,
    TaskHelper,
)
import queue
import threading


_LOGGER = logging.getLogger(__name__)

WS_WAKEUP_TIMEOUT = 1    # 1 second


class EliteCloudWebSocket:
    """
    Async websocket to send requests and receive responses
    """

    def __init__(self):
        """
        Initialize instance
        """
        self._ws_task = None
        self._token = None
        self._restart_requested = threading.Event()

        self._request_queue = queue.Queue()
        self._response_queue = queue.Queue()
        self._response_queued_callback = None


    @property
    def request_queue(self):
        """Make request queue available to parent"""
        return self._request_queue    
    
    @property
    def response_queue(self):
        """Make response queue available to parent"""
        return self._response_queue
    

    def on_response_queued(self, callback):
        """Called to inform parent that a response has been queued"""
        self._response_queued_callback = callback

    
    def start(self, token:str):
        """Start the websocket handling"""
        self._token = token

        # If needed, start the handler task, or alert it that a new token has become availble
        if self._ws_task is None:
            self._ws_task = TaskHelper(self._handler)
            self._ws_task.start()
        else:
            self._restart_requested.set()
            self._ws_task.wakeup()


    def pause(self):
        """Temporary pause the websocket handling. Typically called when token is expected to change."""
        self._token = None


    def stop(self):
        """Stop the websocket handling"""
        self._token = None

        if self._ws_task is not None:
            self._ws_task.stop()
            self._ws_task = None


    def _handler(self):
        """
        Parallel task that will handle all websocket operations
        """
        _LOGGER.debug(f"Websocket handler started")

        while not self._ws_task.is_stop_requested():
            try:
                # Wait until we get an access token
                if self._token is None:
                    self._ws_task.wait_for_wakeup(timeout=WS_WAKEUP_TIMEOUT)
                    continue

                # (re-)connect
                url = PANEL_API_WS + '/ws/panel/'
                headers = {
                    "Authorization": f"Bearer {self._token}",
                    "Origin": url,
                }
                client = httpx.Client(verify=False)

                with httpx_ws.connect_ws(url=url, headers=headers, client=client) as ws:

                    self._restart_requested.clear()

                    # Process requests and responses.
                    # Note that requests are not time critical and we expect far less requests than responses 
                    # (a single subscribe can lead to many responses).
                    # Therefore we allocate most time waiting for responses.
                    while self._token and not self._restart_requested.is_set() and not self._ws_task.is_stop_requested():
                        try:
                            self._process_request(ws)

                            # If we could have more requests waiting, only get already available reponse,
                            # otherwise wait and listen for a response to come in
                            self._process_response(ws, timeout=0 if self.request_queue.qsize()>0 else WS_WAKEUP_TIMEOUT)

                        except (httpx_ws.WebSocketDisconnect, httpx_ws.WebSocketNetworkError):
                             break   # Exit inner loop and reconnect in outer loop

            except Exception as ex:
                _LOGGER.debug(f"WebSocket handler caught exception: {ex}")
                self._token = None
                continue   # continue outer loop

        _LOGGER.debug(f"Websocket handler stopped")


    def _process_request(self, ws:httpx_ws.WebSocketSession):
        """Send a request (if any) over the websocket"""
        try:
            # Send if a request is queued
            request = self._request_queue.get_nowait()
            req_data = request["json"]

            ws.send_json(req_data)
            #_LOGGER.debug(f"req: {req_data}")

            return True
        
        except (queue.Empty, TimeoutError):
            return False


    def _process_response(self, ws:httpx_ws.WebSocketSession, timeout:float):
        """Receive a response (if any) over the websocket"""
        try:
            rsp_data = ws.receive_json(timeout=timeout)
            #_LOGGER.debug(f"rsp: {rsp_data}")

            response = {
                "method": "WS",
                "json": rsp_data,
            }
            self._response_queue.put(response)

            # Alert our parent class that a response is awailable
            if self._response_queued_callback is not None:
                self._response_queued_callback()

            return True
        
        except (queue.Empty, TimeoutError):
            return False
