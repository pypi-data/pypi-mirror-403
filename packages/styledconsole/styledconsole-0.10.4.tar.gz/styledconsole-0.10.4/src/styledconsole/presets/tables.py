"""Table presets and wrapper classes.

This module provides specialized Table classes that pre-configure styles
or add visual effects like gradients.
"""

from io import StringIO
from typing import Any

from rich.console import Console, ConsoleOptions, RenderResult
from rich.text import Text

from styledconsole.core.styles import get_border_chars
from styledconsole.effects.engine import apply_gradient
from styledconsole.effects.strategies import (
    BorderOnly,
    DiagonalPosition,
    HorizontalPosition,
    LinearGradient,
    VerticalPosition,
)
from styledconsole.table import StyledTable


class GradientTable(StyledTable):
    """A StyledTable that automatically applies a gradient to its borders.

    This class wraps standard table rendering with a post-processing step
    that colors the border characters using the specified gradient.

    Example:
        >>> table = GradientTable(
        ...     border_style="heavy",
        ...     border_gradient_start="cyan",
        ...     border_gradient_end="magenta"
        ... )
        >>> table.add_column("Col A")
        >>> console.print(table)
    """

    def __init__(
        self,
        *args: Any,
        border_gradient_start: str = "cyan",
        border_gradient_end: str = "magenta",
        border_gradient_direction: str = "diagonal",
        target: str = "border",  # "border", "content", "both"
        **kwargs: Any,
    ) -> None:
        """Initialize GradientTable.

        Args:
            *args: Arguments passed to StyledTable/rich.Table
            border_gradient_start: Start color for gradient
            border_gradient_end: End color for gradient
            border_gradient_direction: "vertical", "horizontal", or "diagonal"
            target: What to apply gradient to ("border" is default/recommended)
            **kwargs: Keyword arguments passed to StyledTable
        """
        # Default to heavy border if not specified, as it looks best with gradients
        if "border_style" not in kwargs and "box" not in kwargs:
            kwargs["border_style"] = "heavy"

        super().__init__(*args, **kwargs)

        self.border_gradient_start = border_gradient_start
        self.border_gradient_end = border_gradient_end
        self.border_gradient_direction = border_gradient_direction
        self.target = target

    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:
        """Render the table and apply gradient filter."""
        # 1. Capture the standard table output
        # We use a temporary console to render the table to a buffer
        width = options.max_width or console.width
        buffer = StringIO()

        # Force terminal/truecolor to ensure ANSI codes are generated and preserved
        capture_console = Console(
            file=buffer, force_terminal=True, width=width, color_system="truecolor"
        )

        # Render 'self' (the StyledTable) into the buffer
        # We need to call super().__rich_console__ via helper or just print self
        # Since we are inside __rich_console__, 'self' is the renderable.
        # But we can't print 'self' via capture_console because that would recurse indefinitely
        # if capture_console calls __rich_console__ on self.

        # Solution: Delegate to the parent class's __rich_console__ generator
        # or render it as a generic Renderable.
        # However, calling super().__rich_console__ yields segments.
        # We need to turn those segments into a string.

        # Easiest way: Create a copy or proxy that is just a StyledTable (not GradientTable)
        # to break recursion, OR explicitly use the super implementation.
        # Let's use a proxy approach by making a shallow copy and changing class,
        # or extracting data. Actually, simpler:

        # We can iterate over the segments generated by StyledTable.__rich_console__
        # and print them to the capture console.
        segments = super().__rich_console__(capture_console, options)
        from rich.segment import Segment

        for segment in segments:
            if isinstance(segment, Segment):
                capture_console.print(segment.text, style=segment.style, end="")

        output = buffer.getvalue()
        if not output.strip():
            return

        lines = output.splitlines()

        # 2. Configure strategies
        from styledconsole.effects.strategies import PositionStrategy

        pos_strategy: PositionStrategy
        if self.border_gradient_direction == "vertical":
            pos_strategy = VerticalPosition()
        elif self.border_gradient_direction == "horizontal":
            pos_strategy = HorizontalPosition()
        else:
            pos_strategy = DiagonalPosition()

        color_source = LinearGradient(self.border_gradient_start, self.border_gradient_end)

        # Resolve target filter
        from styledconsole.effects.strategies import TargetFilter

        target_filter: TargetFilter
        if self.target == "content":
            from styledconsole.effects.strategies import ContentOnly

            target_filter = ContentOnly()
        elif self.target == "both":
            from styledconsole.effects.strategies import Both

            target_filter = Both()
        else:
            target_filter = BorderOnly()

        # Get border chars for the current box style
        # We try to determine the style from self.box or self.border_style (stored in StyledTable?)
        # StyledTable stores 'box'. We can try to map 'box' back to chars or just get generic set.
        # Best effort: use the box object's render characters if possible,
        # or just use the heavy set if we know it's heavy.
        # Since we can't easily reverse lookup Box -> chars, we'll try to guess key ones
        # or rely on the `get_border_chars` for standard styles if we know the name.

        # Actually `StyledTable` logic resolved the box.
        # Let's inspect self.box.
        # It's hard to get chars from rich.Box universally without some hacks.
        # However, `apply_gradient` takes a set of chars.
        # If we used `border_style="heavy"` in init, we can assume heavy chars.
        # Let's be smart: gather unique chars from the top/bottom lines of the output
        # that are likely borders? No, that's risky.

        # Fallback: Use HEAVY chars union ROUNDED union ASCII etc.
        # Or just require the user to stick to known styles for perfect gradients.
        # For now, let's include all standard border chars in our detection set to be safe.
        from styledconsole.core.styles import BORDERS

        all_border_chars = set()
        for style_name in BORDERS.list_all():
            all_border_chars.update(get_border_chars(BORDERS.get(style_name)))

        # 3. Apply gradient
        colored_lines = apply_gradient(
            lines=lines,
            position_strategy=pos_strategy,
            color_source=color_source,
            target_filter=target_filter,
            border_chars=all_border_chars,
        )

        # 4. Yield result as Text objects (parsing ANSI)
        for line in colored_lines:
            yield Text.from_ansi(line + "\n")


def cyberpunk_table(**kwargs: Any) -> GradientTable:
    """Create a pre-configured 'Cyberpunk' style table."""
    defaults = {
        "border_style": "heavy",
        "border_gradient_start": "cyan",  # Cyan
        "border_gradient_end": "deep_pink1",  # Neon Pink
        "border_gradient_direction": "diagonal",
    }
    defaults.update(kwargs)
    return GradientTable(**defaults)


def create_table_from_config(theme: dict[str, Any], data: dict[str, Any]) -> GradientTable:
    """Create a populated GradientTable from configuration dictionaries.

    Acts as a factory for creating tables from JSON/YAML data.

    Args:
        theme: Styling configuration.
            Keys:
                border_style (str): Default "heavy".
                gradient (dict): Keys start, end, direction.
                padding (int|tuple): Default (0, 1).
                title (str): Table title.
                title_style (str): Style for the title.
                target (str): Gradient target ("border", "content", "both").
        data: Content configuration.
            Keys:
                columns (list): List of column configs (header, style, justify, no_wrap).
                rows (list): List of rows. Each row is a list of cells.
                             Cells can be strings or dicts (text, icon, color, style).

    Returns:
        Configured and populated GradientTable instance.
    """
    from styledconsole import icons

    # 1. Parse Theme
    gradient_config = theme.get("gradient", {})

    # Construct title with style if provided
    title = theme.get("title")
    title_style = theme.get("title_style")
    if title and title_style:
        title = f"[{title_style}]{title}[/]"

    table = GradientTable(
        title=title,
        border_style=theme.get("border_style", "heavy"),
        border_gradient_start=gradient_config.get("start", "cyan"),
        border_gradient_end=gradient_config.get("end", "magenta"),
        border_gradient_direction=gradient_config.get("direction", "diagonal"),
        target=theme.get("target", "border"),
        padding=theme.get("padding", (0, 1)),
    )

    # 2. Add Columns
    for col in data.get("columns", []):
        table.add_column(
            header=col.get("header", ""),
            style=col.get("style"),
            justify=col.get("justify", "left"),
            no_wrap=col.get("no_wrap", False),
        )

    # 3. Add Rows
    for row_data in data.get("rows", []):
        renderables = []
        for cell in row_data:
            if isinstance(cell, str):
                renderables.append(cell)
            elif isinstance(cell, dict):
                # Construct cell content from parts
                parts = []

                # Icon
                icon_name = cell.get("icon")
                if icon_name:
                    # Look up icon constant from icons module
                    icon_val = getattr(icons, icon_name, "")
                    if icon_val:
                        parts.append(str(icon_val))

                # Text
                text = cell.get("text", "")
                if text:
                    parts.append(text)

                content = " ".join(parts)

                # Color/Style
                color = cell.get("color")
                style = cell.get("style")

                if color:
                    content = f"[{color}]{content}[/]"
                elif style:
                    content = f"[{style}]{content}[/]"

                renderables.append(content)
            else:
                renderables.append(str(cell))

        table.add_row(*renderables)

    return table
