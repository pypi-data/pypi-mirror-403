"""Cron install/render utilities (Phase 3)."""

from __future__ import annotations

import os
import shlex
import subprocess
from typing import Any

from cronctrl import config


class CronError(Exception):
    pass


BEGIN_MARKER = "# BEGIN CRONCTRL MANAGED"
END_MARKER = "# END CRONCTRL MANAGED"


def render_etc_crond(cfg: dict[str, Any], *, config_path: str | None = None, user: str | None = None) -> str:
    config_path = _resolve_config_path(cfg, config_path)
    user_value = user or cfg.get("user")
    if not isinstance(user_value, str) or not user_value.strip():
        raise CronError("user: required for /etc/cron.d mode")

    lines = _render_cron_lines(cfg, config_path, include_user=True, user=user_value)
    header = [
        "# Generated by cronctrl. DO NOT EDIT.",
    ]
    return _join_lines(header + lines)


def apply_etc_crond(cfg: dict[str, Any], *, config_path: str | None = None, user: str | None = None) -> str:
    _ensure_dirs(cfg)
    content = render_etc_crond(cfg, config_path=config_path, user=user)
    path = "/etc/cron.d/cronctrl"
    tmp_path = f"{path}.tmp"
    with open(tmp_path, "w", encoding="utf-8") as handle:
        handle.write(content)
    os.chmod(tmp_path, 0o644)
    os.replace(tmp_path, path)
    return path


def remove_etc_crond() -> str | None:
    path = "/etc/cron.d/cronctrl"
    try:
        os.remove(path)
    except FileNotFoundError:
        return None
    return path


def apply_user_crontab(
    cfg: dict[str, Any],
    *,
    config_path: str | None = None,
    remove_missing: bool = False,
) -> None:
    _ensure_dirs(cfg)
    merged = render_user_crontab(cfg, config_path=config_path, remove_missing=remove_missing)
    _write_crontab(merged)


def render_user_crontab(
    cfg: dict[str, Any],
    *,
    config_path: str | None = None,
    remove_missing: bool = False,
    existing_crontab: str | None = None,
) -> str:
    config_path = _resolve_config_path(cfg, config_path)
    existing = existing_crontab if existing_crontab is not None else _read_crontab()
    block = _render_managed_block(cfg, config_path, existing, remove_missing)
    return _merge_managed_block(existing, block)


def remove_user_crontab() -> None:
    existing = _read_crontab()
    cleaned = _remove_managed_block(existing)
    if cleaned != existing:
        _write_crontab(cleaned)


def _render_managed_block(
    cfg: dict[str, Any],
    config_path: str,
    existing: str,
    remove_missing: bool,
) -> str:
    lines = _render_cron_lines(cfg, config_path, include_user=False)
    if not remove_missing:
        preserved = _preserve_existing_lines(existing, cfg)
        if preserved:
            lines.extend(preserved)
    block_lines = [
        BEGIN_MARKER,
        "# This section is managed by cronctrl.",
    ]
    if lines:
        block_lines.extend(lines)
    else:
        block_lines.append("# (no enabled jobs)")
    block_lines.append(END_MARKER)
    return _join_lines(block_lines)


def _render_cron_lines(
    cfg: dict[str, Any],
    config_path: str,
    *,
    include_user: bool,
    user: str | None = None,
) -> list[str]:
    jobs = cfg.get("jobs")
    if not isinstance(jobs, dict):
        raise CronError("jobs: missing or invalid in config")

    lines: list[str] = []
    for job_name in sorted(jobs.keys()):
        job = jobs[job_name]
        if not isinstance(job, dict):
            continue
        if job.get("disabled") is True:
            continue
        schedule = job.get("schedule")
        if not isinstance(schedule, str) or not schedule.strip():
            raise CronError(f"jobs.{job_name}.schedule: required")
        command = _cron_command(job_name, config_path)
        if include_user:
            if not user:
                raise CronError("user: required for /etc/cron.d mode")
            lines.append(f"{schedule} {user} {command}")
        else:
            lines.append(f"{schedule} {command}")
    return lines


def _cron_command(job_name: str, config_path: str) -> str:
    return " ".join(
        [
            shlex.quote("cronctrl"),
            "--config",
            shlex.quote(config_path),
            "run",
            shlex.quote(job_name),
        ]
    )


def _resolve_config_path(cfg: dict[str, Any], config_path: str | None) -> str:
    path = None
    if config_path:
        path = config_path
    elif "_config_path" in cfg and isinstance(cfg.get("_config_path"), str):
        path = cfg["_config_path"]
    else:
        path = config.DEFAULT_CONFIG_PATH
    return os.path.abspath(os.path.expanduser(path))


def _ensure_dirs(cfg: dict[str, Any]) -> None:
    log_dir = cfg.get("log_dir")
    state_dir = cfg.get("state_dir")
    if not isinstance(log_dir, str) or not isinstance(state_dir, str):
        raise CronError("log_dir/state_dir must be set")
    locks_dir = cfg.get("locks_dir")
    if not isinstance(locks_dir, str):
        locks_dir = os.path.join(state_dir, "locks")
    os.makedirs(log_dir, exist_ok=True)
    os.makedirs(state_dir, exist_ok=True)
    os.makedirs(locks_dir, exist_ok=True)


def _read_crontab() -> str:
    result = subprocess.run(["crontab", "-l"], capture_output=True, text=True)
    if result.returncode == 0:
        return result.stdout or ""
    if "no crontab for" in (result.stderr or "").lower():
        return ""
    raise CronError(f"crontab -l failed: {result.stderr.strip()}")


def _write_crontab(content: str) -> None:
    result = subprocess.run(["crontab", "-"], input=content, text=True, capture_output=True)
    if result.returncode != 0:
        raise CronError(f"crontab install failed: {result.stderr.strip()}")


def _merge_managed_block(existing: str, block: str) -> str:
    existing_lines = existing.splitlines()
    block_lines = block.splitlines()

    begin_index = None
    end_index = None
    for idx, line in enumerate(existing_lines):
        if line.strip() == BEGIN_MARKER:
            begin_index = idx
        if line.strip() == END_MARKER:
            end_index = idx
            break

    if begin_index is not None and end_index is not None and end_index >= begin_index:
        new_lines = existing_lines[:begin_index] + block_lines + existing_lines[end_index + 1 :]
    else:
        new_lines = existing_lines[:]
        if new_lines and new_lines[-1].strip():
            new_lines.append("")
        new_lines.extend(block_lines)

    return _join_lines(new_lines)


def _join_lines(lines: list[str]) -> str:
    text = "\n".join(line.rstrip("\n") for line in lines)
    return text.rstrip() + "\n"


def _preserve_existing_lines(existing: str, cfg: dict[str, Any]) -> list[str]:
    jobs = cfg.get("jobs")
    if not isinstance(jobs, dict):
        return []
    existing_block = _extract_managed_block(existing)
    preserved: list[str] = []
    for line in existing_block:
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            preserved.append(line)
            continue
        job_name = _extract_job_name_from_line(stripped)
        if job_name and job_name in jobs:
            continue
        preserved.append(line)
    return preserved


def _extract_managed_block(existing: str) -> list[str]:
    lines = existing.splitlines()
    begin_index = None
    end_index = None
    for idx, line in enumerate(lines):
        if line.strip() == BEGIN_MARKER:
            begin_index = idx
        if line.strip() == END_MARKER:
            end_index = idx
            break
    if begin_index is None or end_index is None or end_index < begin_index:
        return []
    return lines[begin_index + 1 : end_index]


def _remove_managed_block(existing: str) -> str:
    lines = existing.splitlines()
    begin_index = None
    end_index = None
    for idx, line in enumerate(lines):
        if line.strip() == BEGIN_MARKER:
            begin_index = idx
        if line.strip() == END_MARKER:
            end_index = idx
            break
    if begin_index is None or end_index is None or end_index < begin_index:
        return _join_lines(lines)

    new_lines = lines[:begin_index] + lines[end_index + 1 :]
    if new_lines and not new_lines[-1].strip():
        new_lines = new_lines[:-1]
    return _join_lines(new_lines)


def _extract_job_name_from_line(line: str) -> str | None:
    try:
        tokens = shlex.split(line)
    except ValueError:
        return None
    if "cronctrl" not in tokens or "run" not in tokens:
        return None
    run_index = tokens.index("run")
    if run_index + 1 >= len(tokens):
        return None
    return tokens[run_index + 1]
