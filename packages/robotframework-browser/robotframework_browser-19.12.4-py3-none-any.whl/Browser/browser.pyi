# Copyright 2020-     Robot Framework Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from datetime import datetime
from concurrent.futures import Future
from os import PathLike

from assertionengine import AssertionOperator

from robot.utils import DotDict

from Browser.utils import (
    ClockType, CLockAdvanceType, FormatterTypes, CookieType, CookieSameSite, DownloadInfo, NewPageDetails,
    BrowserInfo, PageLoadStates,ViewportDimensions, ServiceWorkersPermissions,
    ReduceMotion, RecordVideo, RecordHar, Proxy, Permission, HttpCredentials,
    GeoLocation, ForcedColors, ColorScheme, ClientCertificate, HighlightMode, ScreenshotReturnType,
    Scale, ScreenshotFileTypes, BoundingBox, ReducedMotion, Media, PdfMarging,
    PdfFormat, CoverageType, RequestMethod, ElementState, ScrollPosition,
    SelectAttribute, SelectOptions, ConditionInputs, FileUploadBuffer, SelectAttribute
)
from Browser.utils .data_types import (
    MouseButton, KeyboardModifier, ScrollBehavior, ScrollBehavior, DialogAction, MouseButtonAction, NotSet, Dimensions,
    SizeFields, AreaFields, BoundingBoxFields, SelectionStrategy, ElementRole, AriaSnapshotReturnType,
    KeyboardInputAction, KeyAction
)
from .base import ContextCache as ContextCache, LibraryComponent as LibraryComponent
from .generated.playwright_pb2 import Request as Request, Response as Response
from .keywords import Clock as Clock, Control as Control, Cookie as Cookie, Coverage as Coverage, Devices as Devices, Evaluation as Evaluation, Formatter as Formatter, Getters as Getters, Interaction as Interaction, LocatorHandler as LocatorHandler, Network as Network, Pdf as Pdf, PlaywrightState as PlaywrightState, Promises as Promises, RunOnFailureKeywords as RunOnFailureKeywords, StrictMode as StrictMode, Waiter as Waiter, WebAppState as WebAppState
from .keywords.crawling import Crawling as Crawling
from .playwright import Playwright as Playwright
from .utils import AutoClosingLevel as AutoClosingLevel, PlaywrightLogTypes as PlaywrightLogTypes, Scope as Scope, SettingsStack as SettingsStack, get_normalized_keyword as get_normalized_keyword, is_falsy as is_falsy, keyword as keyword, logger as logger, suppress_logging as suppress_logging
from .utils.data_types import DelayedKeyword as DelayedKeyword, HighLightElement as HighLightElement, KeywordCallStackEntry as KeywordCallStackEntry, LambdaFunction as LambdaFunction, RegExp as RegExp, SelectionType as SelectionType, SupportedBrowsers as SupportedBrowsers, TracingGroupMode as TracingGroupMode
from .version import __version__ as VERSION
from _typeshed import Incomplete
from datetime import timedelta
from overrides import overrides
from pathlib import Path
from robotlibcore import DynamicCore # type: ignore
from typing import Any, Literal

KW_CALL_CONTENT_TEMPLATE: str
KW_CALL_BANNER_FUNCTION: str

class Browser(DynamicCore):
    ROBOT_LIBRARY_VERSION = VERSION
    ROBOT_LISTENER_API_VERSION: int
    ROBOT_LIBRARY_LISTENER: Browser
    ROBOT_LIBRARY_SCOPE: str
    scope_stack: dict
    suite_ids: dict[str, None]
    current_test_id: str | None
    enable_playwright_debug: Incomplete
    playwright_process_host: Incomplete
    playwright_process_port: Incomplete
    auto_delete_passed_tracing: Incomplete
    external_browser_executable: dict[SupportedBrowsers, str]
    presenter_mode: HighLightElement | bool
    tracing_group_mode: Incomplete
    pause_on_failure: set[str]
    is_test_case_running: bool
    auto_closing_default_run_before_unload: bool
    keyword_call_stack: list[KeywordCallStackEntry]
    tracing_contexts: list[str]
    def __init__(self, *_, auto_closing_level: AutoClosingLevel = ..., auto_delete_passed_tracing: bool = False, enable_playwright_debug: PlaywrightLogTypes | bool = ..., enable_presenter_mode: HighLightElement | bool = False, external_browser_executable: dict[SupportedBrowsers, str] | None = None, highlight_on_failure: bool = False, jsextension: list[str] | str | None = None, language: str | None = None, playwright_process_host: str | None = None, playwright_process_port: int | None = None, plugins: list[str] | str | None = None, retry_assertions_for: timedelta = ..., run_on_failure: str = 'Take Screenshot  fail-screenshot-{index}', selector_prefix: str | None = None, show_keyword_call_banner: bool | None = None, strict: bool = True, timeout: timedelta = ..., tracing_group_mode: TracingGroupMode = ...) -> None: ...
    @property
    def playwright(self) -> Playwright: ...
    @property
    def keyword_call_banner_add_style(self): ...
    @property
    def show_keyword_call_banner(self): ...
    @property
    def run_on_failure_keyword(self) -> DelayedKeyword: ...
    @property
    def highlight_on_failure(self) -> bool: ...
    @property
    def timeout(self): ...
    def init_js_extension(self, js_extension_path: Path | str) -> Response.Keywords: ...
    def call_js_keyword(self, keyword_name: str, **args) -> Any: ...
    @property
    def outputdir(self) -> str: ...
    @outputdir.setter
    def outputdir(self, value: str): ...
    @property
    def browser_output(self) -> Path: ...
    @property
    def screenshots_output(self) -> Path: ...
    @property
    def video_output(self) -> Path: ...
    @property
    def traces_output(self) -> Path: ...
    @property
    def traces_temp(self) -> Path: ...
    @property
    def state_file(self): ...
    @property
    def coverage_output(self) -> Path: ...
    def run_keyword(self, name, args, kwargs=None): ...
    def get_keyword_tags(self, name: str) -> list: ...
    def execute_auto_closing(self, name: str, attrs: dict, typ: Literal['Test', 'Suite'], status: str): ...
    def set_keyword_call_banner(self, keyword_call=None) -> None: ...
    def keyword_error(self, selector) -> None: ...
    def get_timeout(self, timeout: timedelta | None) -> float: ...
    def convert_timeout(self, timeout: timedelta | float, to_ms: bool = True) -> float: ...
    def millisecs_to_timestr(self, timeout: float) -> str: ...
    @overrides
    def get_keyword_documentation(self, name): ...
    def execute_npx_playwright(self, command: str, *args: str): ...

    def set_time(self, time: datetime, clock_type: ClockType = ...): ...
    def resume_clock(self) -> None: ...
    def pause_at(self, time: datetime): ...
    def advance_clock(self, time: timedelta, advance_type: CLockAdvanceType = ...): ...
    def add_locator_handler_click(self, selector: str, click_selector: str, *, noWaitAfter: bool = True, times: int | None = None, click_clickCount: int = 1, click_delay: int = 0, click_force: bool = False): ...
    def remove_locator_handler(self, locator: str): ...
    def add_locator_handler_custom(self, selector: str, handler_spec: list[dict], noWaitAfter: bool = True, times: int | None = None): ...
    def evaluate_javascript(self, selector: str | None = None, *function: str, arg: Any = None, all_elements: bool = False) -> Any: ...
    def highlight_elements(self, selector: str, duration: timedelta = ..., width: str = '2px', style: str = 'dotted', color: str = 'blue', *, mode: HighlightMode = ...): ...
    def add_style_tag(self, content: str): ...
    def download(self, url: str, saveAs: str = '', wait_for_finished: bool = True, download_timeout: timedelta | None = None) -> DownloadInfo: ...
    def get_devices(self) -> dict: ...
    def get_device(self, name: str) -> dict: ...
    def type_text(self, selector: str, txt: str, delay: timedelta = ..., clear: bool = True): ...
    def fill_text(self, selector: str, txt: str, force: bool = False): ...
    def clear_text(self, selector: str): ...
    def type_secret(self, selector: str, secret: str, delay: timedelta = ..., clear: bool = True): ...
    def fill_secret(self, selector: str, secret: str, force: bool = False): ...
    def press_keys(self, selector: str, *keys: str, press_duration: timedelta = ..., key_delay: timedelta = ...): ...
    def click(self, selector: str, button: MouseButton = ...): ...
    def click_with_options(self, selector: str, button: MouseButton = ..., *modifiers: KeyboardModifier, clickCount: int = 1, delay: timedelta | None = None, force: bool = False, noWaitAfter: bool = False, position_x: float | None = None, position_y: float | None = None, trial: bool = False): ...
    def tap(self, selector: str, *modifiers: KeyboardModifier, force: bool = False, noWaitAfter: bool = False, position_x: int | None = None, position_y: int | None = None, trial: bool = False): ...
    def record_selector(self, label: str | None = None): ...
    def hover(self, selector: str, position_x: float | None = None, position_y: float | None = None, force: bool = False, *modifiers: KeyboardModifier): ...
    def focus(self, selector: str): ...
    def scroll_to(self, selector: str | None = None, vertical: str = 'top', horizontal: str = 'left', behavior: ScrollBehavior = ...): ...
    def scroll_by(self, selector: str | None = None, vertical: str = 'height', horizontal: str = '0', behavior: ScrollBehavior = ...): ...
    def scroll_to_element(self, selector: str): ...
    def check_checkbox(self, selector: str, force: bool = False): ...
    def uncheck_checkbox(self, selector: str, force: bool = False): ...
    def select_options_by(self, selector: str, attribute: SelectAttribute, *values) -> list[Any]: ...
    def deselect_options(self, selector: str): ...
    def handle_future_dialogs(self, action: DialogAction, prompt_input: str = ''): ...
    def wait_for_alert(self, action: DialogAction, prompt_input: str = '', text: str | None = None, timeout: timedelta | None = None): ...
    def wait_for_alerts(self, actions: list[DialogAction], prompt_inputs: list[None | str], texts: list[None | str], timeout: timedelta | None = None) -> list[str]: ...
    def mouse_button(self, action: MouseButtonAction, x: float | None = None, y: float | None = None, button: MouseButton = ..., clickCount: int = 1, delay: int | timedelta = ...): ...
    def drag_and_drop(self, selector_from: str, selector_to: str, steps: int = 1): ...
    def drag_and_drop_by_coordinates(self, from_x: float, from_y: float, to_x: float, to_y: float, steps: int = 1): ...
    def drag_and_drop_relative_to(self, selector_from: str, x: float = 0.0, y: float = 0.0, steps: int = 1): ...
    def mouse_move_relative_to(self, selector: str, x: float = 0.0, y: float = 0.0, steps: int = 1): ...
    def mouse_move(self, x: float, y: float, steps: int = 1): ...
    def mouse_wheel(self, deltaX: int, deltaY: int): ...
    def keyboard_key(self, action: KeyAction, key: str): ...
    def keyboard_input(self, action: KeyboardInputAction, input: str, delay: int | timedelta = ...): ...
    def upload_file_by_selector(self, selector: str, path: PathLike | FileUploadBuffer, *extra_paths: PathLike): ...
    def crawl_site(self, url: str | None = None, page_crawl_keyword: str = 'take_screenshot', max_number_of_page_to_crawl: int = 1000, max_depth_to_crawl: int = 50): ...
    def set_strict_mode(self, mode: bool, scope: Scope = ...): ...
    def get_aria_snapshot(self, selector: str, return_type: AriaSnapshotReturnType = ..., assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> str | dict: ...
    def get_url(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> str: ...
    def get_page_source(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> str: ...
    def get_title(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> str: ...
    def get_text(self, selector: str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> str: ...
    def get_property(self, selector: str, property: str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> Any: ...
    def get_attribute(self, selector: str, attribute: str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> str | None: ...
    def get_attribute_names(self, selector: str, assertion_operator: AssertionOperator | None = None, *assertion_expected, message: str | None = None) -> list[str]: ...
    def get_classes(self, selector: str, assertion_operator: AssertionOperator | None = None, *assertion_expected, message: str | None = None) -> list[str]: ...
    def get_select_options(self, selector: str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> list[SelectOptions]: ...
    def get_selected_options(self, selector: str, option_attribute: SelectAttribute = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected, message: str | None = None) -> list[str | int]: ...
    def get_checkbox_state(self, selector: str, assertion_operator: AssertionOperator | None = None, assertion_expected: bool | str = 'Unchecked', message: str | None = None) -> bool: ...
    def get_element_count(self, selector: str, assertion_operator: AssertionOperator | None = None, assertion_expected: int | str = 0, message: str | None = None) -> int: ...
    def get_viewport_size(self, key: SizeFields = ..., assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> ViewportDimensions | None: ...
    def get_table_cell_element(self, table: str, column: str, row: str) -> str: ...
    def get_table_cell_index(self, selector: str, assertion_operator: AssertionOperator | None = None, assertion_expected: int | str = 0, message: str | None = None) -> int: ...
    def get_table_row_index(self, selector: str, assertion_operator: AssertionOperator | None = None, assertion_expected: int | str = 0, message: str | None = None) -> int: ...
    def get_element(self, selector: str) -> str: ...
    def get_elements(self, selector: str) -> list[str]: ...
    def get_element_by_role(self, role: ElementRole, *, all_elements: bool = False, checked: bool | None = None, disabled: bool | None = None, exact: bool | None = None, expanded: bool | None = None, include_hidden: bool | None = None, level: int | None = None, name: str | RegExp | None = None, pressed: bool | None = None, selected: bool | None = None) -> str: ...
    def get_element_by(self, selection_strategy: SelectionStrategy, text: str | RegExp, exact: bool = False, all_elements: bool = False) -> str: ...
    def get_style(self, selector: str, key: str | None = 'ALL', assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, pseudo_element: str | None = None) -> dict[str, str] | str: ...
    def get_boundingbox(self, selector: str, key: BoundingBoxFields = ..., assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, *, allow_hidden: bool = False) -> BoundingBox | float | int | None: ...
    def get_scroll_size(self, selector: str | None = None, key: SizeFields = ..., assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> Dimensions | float | int: ...
    def get_scroll_position(self, selector: str | None = None, key: AreaFields = ..., assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> ScrollPosition | float: ...
    def get_client_size(self, selector: str | None = None, key: SizeFields = ..., assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> Dimensions: ...
    def get_element_states(self, selector: str, assertion_operator: AssertionOperator | None = None, *assertion_expected: ElementState | str, message: str | None = None, return_names: bool = True) -> list[str] | ElementState: ...
    def get_download_state(self, download: DownloadInfo | str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> DownloadInfo: ...
    def local_storage_get_item(self, key: str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, frame_selector: str | None = None) -> Any: ...
    def local_storage_set_item(self, key: str, value: str, frame_selector: str | None = None): ...
    def local_storage_remove_item(self, key: str, frame_selector: str | None = None): ...
    def local_storage_clear(self, frame_selector: str | None = None): ...
    def session_storage_get_item(self, key: str, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, frame_selector: str | None = None) -> Any: ...
    def session_storage_set_item(self, key: str, value: str, frame_selector: str | None = None): ...
    def session_storage_remove_item(self, key: str, frame_selector: str | None = None): ...
    def session_storage_clear(self, frame_selector: str | None = None): ...
    def start_coverage(self, *, config_file: PathLike | None = None, coverage_type: CoverageType = ..., path: Path = ..., raw: bool = False, reportAnonymousScripts: bool = False, resetOnNavigation: bool = True) -> str: ...
    def stop_coverage(self) -> Path: ...
    def merge_coverage_reports(self, input_folder: Path, output_folder: Path, config_file: Path | None = None, name: str | None = None, reports: list[str] | None = None) -> Path: ...
    def go_forward(self) -> None: ...
    def go_back(self) -> None: ...
    def go_to(self, url: str, timeout: timedelta | None = None, wait_until: PageLoadStates = ...): ...
    def take_screenshot(self, filename: str | None = 'robotframework-browser-screenshot-{index}', selector: str | None = None, *, crop: BoundingBox | None = None, disableAnimations: bool = False, fileType: ScreenshotFileTypes = ..., fullPage: bool = False, highlight_selector: str | None = None, log_screenshot: bool = True, mask: list[str] | str = '', maskColor: str | None = None, omitBackground: bool = False, quality: int | None = None, scale: Scale | None = None, return_as: ScreenshotReturnType = ..., timeout: timedelta | None = None) -> str | bytes | Path | None: ...
    def set_browser_timeout(self, timeout: timedelta, scope: Scope = ...) -> str: ...
    def set_retry_assertions_for(self, timeout: timedelta, scope: Scope = ...) -> str: ...
    def set_selector_prefix(self, prefix: str | None, scope: Scope = ...) -> str: ...
    def set_highlight_on_failure(self, highlight: bool = True, scope: Scope = ...) -> bool: ...
    def show_keyword_banner(self, show: bool = True, style: str = '', scope: Scope = ...) -> dict[str, None | bool | str]: ...
    def set_viewport_size(self, width: int, height: int): ...
    def set_offline(self, offline: bool = True): ...
    def set_geolocation(self, latitude: float, longitude: float, accuracy: float | None = None): ...
    def reload(self, timeout: timedelta | None = None, waitUntil: PageLoadStates = ...): ...
    def grant_permissions(self, *permissions: Permission, origin: str | None = None): ...
    def clear_permissions(self) -> None: ...
    def get_cookies(self, return_type: CookieType = ...) -> list[DotDict] | str: ...
    def add_cookie(self, name: str, value: str, url: str | None = None, domain: str | None = None, path: str | None = None, expires: str | datetime | None = None, httpOnly: bool | None = None, secure: bool | None = None, sameSite: CookieSameSite | None = None): ...
    def delete_all_cookies(self) -> None: ...
    def eat_all_cookies(self) -> None: ...
    def get_cookie(self, cookie: str, return_type: CookieType = ...) -> DotDict | str: ...
    def promise_to(self, kw: str, *args) -> Future: ...
    def promise_to_wait_for_download(self, saveAs: str = '', wait_for_finished: bool = True, download_timeout: timedelta | None = None) -> Future: ...
    def wait_for(self, *promises: Future): ...
    def wait_for_all_promises(self) -> None: ...
    def promise_to_upload_file(self, path: PathLike) -> Future: ...
    def save_page_as_pdf(self, path: PathLike, *, displayHeaderFooter: bool = False, footerTemplate: str = '', format: PdfFormat = ..., headerTemplate: str = '', height: str = '0px', landscape: bool = False, margin: PdfMarging = ..., outline: bool = False, pageRanges: str = '', preferCSSPageSize: bool = False, printBackground: bool = False, scale: float = 1, tagged: bool = False, width: str = '0px') -> str: ...
    def emulate_media(self, colorScheme: ColorScheme | None = None, forcedColors: ForcedColors | NotSet = ..., media: Media | None = None, reducedMotion: ReducedMotion | None = None) -> None: ...
    def open_browser(self, url: str | None = None, browser: SupportedBrowsers = ..., headless: bool = False, pause_on_failure: bool = True, bypassCSP: bool = True): ...
    def close_browser(self, browser: SelectionType | str = ...): ...
    def close_context(self, context: SelectionType | str = ..., browser: SelectionType | str = ..., *, save_trace: bool = True): ...
    def close_page(self, page: SelectionType | NewPageDetails | str = ..., context: SelectionType | str = ..., browser: SelectionType | str = ..., runBeforeUnload: bool = False) -> list[dict]: ...
    def set_default_run_before_unload(self, runBeforeUnload: bool) -> bool: ...
    def connect_to_browser(self, wsEndpoint: str, browser: SupportedBrowsers = ..., use_cdp: bool = False, *, timeout: timedelta = ...): ...
    def new_browser(self, browser: SupportedBrowsers = ..., headless: bool = True, *, args: list[str] | None = None, channel: str | None = None, chromiumSandbox: bool = False, devtools: bool = False, downloadsPath: str | None = None, env: dict | None = None, executablePath: str | None = None, firefoxUserPrefs: dict[str, str | int | float | bool] | None = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, ignoreDefaultArgs: list[str] | bool | None = None, proxy: Proxy | None = None, reuse_existing: bool = True, slowMo: timedelta = ..., timeout: timedelta = ...) -> str: ...
    def launch_browser_server(self, browser: SupportedBrowsers = ..., headless: bool = True, *, args: list[str] | None = None, channel: str | None = None, chromiumSandbox: bool = False, devtools: bool = False, downloadsPath: str | None = None, env: dict | None = None, executablePath: str | None = None, firefoxUserPrefs: dict[str, str | int | float | bool] | None = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, ignoreDefaultArgs: list[str] | bool | None = None, port: int | None = None, proxy: Proxy | None = None, reuse_existing: bool = True, slowMo: timedelta = ..., timeout: timedelta = ..., wsPath: str | None = None) -> str: ...
    def close_browser_server(self, wsEndpoint: str) -> None: ...
    def new_context(self, *, acceptDownloads: bool = True, baseURL: str | None = None, bypassCSP: bool = False, clientCertificates: list[ClientCertificate] | None = None, colorScheme: ColorScheme | None = None, defaultBrowserType: SupportedBrowsers | None = None, deviceScaleFactor: float | None = None, extraHTTPHeaders: dict[str, str] | None = None, forcedColors: ForcedColors = ..., geolocation: GeoLocation | None = None, hasTouch: bool | None = None, httpCredentials: HttpCredentials | None = None, ignoreHTTPSErrors: bool = False, isMobile: bool | None = None, javaScriptEnabled: bool = True, locale: str | None = None, offline: bool = False, permissions: list[Permission] | None = None, proxy: Proxy | None = None, recordHar: RecordHar | None = None, recordVideo: RecordVideo | None = None, reducedMotion: ReduceMotion = ..., screen: dict[str, int] | None = None, serviceWorkers: ServiceWorkersPermissions | None = ..., storageState: str | None = None, timezoneId: str | None = None, tracing: bool | Path | None = None, userAgent: str | None = None, viewport: ViewportDimensions | None = ...) -> str: ...
    def new_persistent_context(self, userDataDir: str = '', browser: SupportedBrowsers = ..., headless: bool = True, *, acceptDownloads: bool = True, args: list[str] | None = None, baseURL: str | None = None, bypassCSP: bool = False, channel: str | None = None, chromiumSandbox: bool = False, colorScheme: ColorScheme | None = None, defaultBrowserType: SupportedBrowsers | None = None, deviceScaleFactor: float | None = None, devtools: bool = False, downloadsPath: str | None = None, env: dict | None = None, executablePath: str | None = None, extraHTTPHeaders: dict[str, str] | None = None, forcedColors: ForcedColors = ..., geolocation: GeoLocation | None = None, handleSIGHUP: bool = True, handleSIGINT: bool = True, handleSIGTERM: bool = True, hasTouch: bool | None = None, httpCredentials: HttpCredentials | None = None, ignoreDefaultArgs: list[str] | bool | None = None, ignoreHTTPSErrors: bool = False, isMobile: bool | None = None, javaScriptEnabled: bool = True, locale: str | None = None, offline: bool = False, permissions: list[Permission] | None = None, proxy: Proxy | None = None, recordHar: RecordHar | None = None, recordVideo: RecordVideo | None = None, reducedMotion: ReduceMotion = ..., screen: dict[str, int] | None = None, serviceWorkers: ServiceWorkersPermissions | None = ..., slowMo: timedelta = ..., timeout: timedelta = ..., timezoneId: str | None = None, tracing: bool | Path | None = None, url: str | None = None, userAgent: str | None = None, viewport: ViewportDimensions | None = ...): ...
    def new_page(self, url: str | None = None, wait_until: PageLoadStates = ...) -> NewPageDetails: ...
    def get_browser_catalog(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None) -> list[BrowserInfo]: ...
    def get_console_log(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, *, full: bool = False, last: int | timedelta | None = None) -> list[dict]: ...
    def get_page_errors(self, assertion_operator: AssertionOperator | None = None, assertion_expected: Any | None = None, message: str | None = None, *, full: bool = False, last: int | timedelta | None = None) -> dict: ...
    def switch_browser(self, id: str) -> str: ...
    def switch_context(self, id: str, browser: SelectionType | str = ...) -> str: ...
    def switch_page(self, id: NewPageDetails | SelectionType | str, context: SelectionType | str = ..., browser: SelectionType | str = ...) -> str: ...
    def get_browser_ids(self, browser: SelectionType = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected: Any | None, message: str | None = None) -> list[str]: ...
    def get_context_ids(self, context: SelectionType = ..., browser: SelectionType | str = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected: Any | None, message: str | None = None) -> list: ...
    def get_page_ids(self, page: SelectionType = ..., context: SelectionType | str = ..., browser: SelectionType | str = ..., assertion_operator: AssertionOperator | None = None, *assertion_expected: Any | None, message: str | None = None) -> list: ...
    def save_storage_state(self) -> str: ...
    def cancel_download(self, download: DownloadInfo | str): ...
    def register_keyword_to_run_on_failure(self, keyword: str | None, *args: str, scope: Scope = ...) -> DelayedKeyword: ...
    def wait_for_elements_state(self, selector: str, state: ElementState = ..., timeout: timedelta | None = None, message: str | None = None): ...
    def wait_for_function(self, function: str, selector: str = '', polling: str | timedelta = 'raf', timeout: timedelta | None = None, message: str | None = None): ...
    def wait_for_condition(self, condition: ConditionInputs, *args: Any, timeout: timedelta | None = None, message: str | None = None) -> Any: ...
    def wait_for_load_state(self, state: PageLoadStates = ..., timeout: timedelta | None = None): ...
    def http(self, url: str, method: RequestMethod = ..., body: str | None = None, headers: dict | None = None) -> Any: ...
    def wait_for_request(self, matcher: str | RegExp = '', timeout: timedelta | None = None) -> Any: ...
    def wait_for_response(self, matcher: str | RegExp = '', timeout: timedelta | None = None) -> DotDict | Any: ...
    def wait_until_network_is_idle(self, timeout: timedelta | None = None): ...
    def wait_for_navigation(self, url: str | RegExp, timeout: timedelta | None = None, wait_until: PageLoadStates = ...): ...
    def set_assertion_formatters(self, formatters: FormatterTypes, scope: Scope = ...) -> dict[str, list[str]]: ...
