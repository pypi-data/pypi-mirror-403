# coding: utf-8

"""
    Coinbase Developer Platform APIs

    The Coinbase Developer Platform APIs - leading the world's transition onchain.

    The version of the OpenAPI document: 2.0.0
    Contact: cdp@coinbase.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from cdp.openapi_client.models.onramp_order_payment_method_type_id import OnrampOrderPaymentMethodTypeId
from typing import Optional, Set
from typing_extensions import Self

class CreateOnrampOrderRequest(BaseModel):
    """
    CreateOnrampOrderRequest
    """ # noqa: E501
    agreement_accepted_at: datetime = Field(description="The timestamp of when the user acknowledged that by using Coinbase Onramp they are accepting the Coinbase Terms  (https://www.coinbase.com/legal/guest-checkout/us), User Agreement (https://www.coinbase.com/legal/user_agreement),  and Privacy Policy (https://www.coinbase.com/legal/privacy).", alias="agreementAcceptedAt")
    destination_address: Annotated[str, Field(min_length=1, strict=True, max_length=128)] = Field(description="The address the purchased crypto will be sent to.", alias="destinationAddress")
    destination_network: StrictStr = Field(description="The name of the crypto network the purchased currency will be sent on.  Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.", alias="destinationNetwork")
    email: StrictStr = Field(description="The verified email address of the user requesting the onramp transaction. This email must be verified by your app (via OTP) before being used with the Onramp API.")
    is_quote: Optional[StrictBool] = Field(default=False, description="If true, this API will return a quote without creating any transaction.", alias="isQuote")
    partner_order_ref: Optional[StrictStr] = Field(default=None, description="Optional partner order reference ID.", alias="partnerOrderRef")
    partner_user_ref: StrictStr = Field(description="A unique string that represents the user in your app. This can be used to link individual transactions  together so you can retrieve the transaction history for your users. Prefix this string with “sandbox-”  (e.g. \"sandbox-user-1234\") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.  This value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.", alias="partnerUserRef")
    payment_amount: Optional[StrictStr] = Field(default=None, description="A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using  this parameter, the returned quote will be inclusive of fees i.e. the user will pay this exact amount  of the payment currency.", alias="paymentAmount")
    payment_currency: StrictStr = Field(description="The fiat currency to be converted to crypto.", alias="paymentCurrency")
    payment_method: OnrampOrderPaymentMethodTypeId = Field(alias="paymentMethod")
    phone_number: StrictStr = Field(description="The phone number of the user requesting the onramp transaction in E.164 format. This phone number must  be verified by your app (via OTP) before being used with the Onramp API.  Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api) for more details on phone number verification requirements and best practices.", alias="phoneNumber")
    phone_number_verified_at: datetime = Field(description="Timestamp of when the user's phone number was verified via OTP. User phone number must be verified  every 60 days. If this timestamp is older than 60 days, an error will be returned.", alias="phoneNumberVerifiedAt")
    purchase_amount: Optional[StrictStr] = Field(default=None, description="A string representing the amount of crypto the user wishes to purchase. When using this parameter the  returned quote will be exclusive of fees i.e. the user will receive this exact amount of the purchase  currency.", alias="purchaseAmount")
    purchase_currency: StrictStr = Field(description="The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.  Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.", alias="purchaseCurrency")
    client_ip: Optional[StrictStr] = Field(default=None, description="The IP address of the end user requesting the onramp transaction.", alias="clientIp")
    domain: Optional[StrictStr] = Field(default=None, description="The domain that the Apple Pay button will be rendered on. Required when using the `GUEST_CHECKOUT_APPLE_PAY`  payment method and embedding the payment link in an iframe.")
    __properties: ClassVar[List[str]] = ["agreementAcceptedAt", "destinationAddress", "destinationNetwork", "email", "isQuote", "partnerOrderRef", "partnerUserRef", "paymentAmount", "paymentCurrency", "paymentMethod", "phoneNumber", "phoneNumberVerifiedAt", "purchaseAmount", "purchaseCurrency", "clientIp", "domain"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateOnrampOrderRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateOnrampOrderRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "agreementAcceptedAt": obj.get("agreementAcceptedAt"),
            "destinationAddress": obj.get("destinationAddress"),
            "destinationNetwork": obj.get("destinationNetwork"),
            "email": obj.get("email"),
            "isQuote": obj.get("isQuote") if obj.get("isQuote") is not None else False,
            "partnerOrderRef": obj.get("partnerOrderRef"),
            "partnerUserRef": obj.get("partnerUserRef"),
            "paymentAmount": obj.get("paymentAmount"),
            "paymentCurrency": obj.get("paymentCurrency"),
            "paymentMethod": obj.get("paymentMethod"),
            "phoneNumber": obj.get("phoneNumber"),
            "phoneNumberVerifiedAt": obj.get("phoneNumberVerifiedAt"),
            "purchaseAmount": obj.get("purchaseAmount"),
            "purchaseCurrency": obj.get("purchaseCurrency"),
            "clientIp": obj.get("clientIp"),
            "domain": obj.get("domain")
        })
        return _obj


