"""
Metadata file handling for AI-SCRM.

Supports loading and saving enrichment metadata from YAML files,
and generating template files for user editing.

AI-SCRM Supply Chain Tooling for AI Architecture
Version: 1.0.1
By: Shawn Kahalewai Reilly
Repo: HTTPS://github.com/kahalewai/ai-scrm
License: Apache License 2.0
"""

import os
import re
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)

# Try to import yaml, provide fallback
try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


@dataclass
class MetadataConfig:
    """Parsed metadata configuration."""
    
    # Model patterns: filename pattern -> metadata
    models: Dict[str, Dict[str, str]] = field(default_factory=dict)
    
    # Trust boundary patterns: endpoint pattern -> boundary
    trust_boundaries: Dict[str, str] = field(default_factory=dict)
    
    # Agent configurations
    agents: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    
    # Dataset declarations (cannot be auto-discovered)
    datasets: List[Dict[str, str]] = field(default_factory=list)
    
    # Default values
    defaults: Dict[str, str] = field(default_factory=dict)


def load_metadata(filepath: str) -> MetadataConfig:
    """
    Load metadata configuration from YAML file.
    
    Args:
        filepath: Path to metadata YAML file
        
    Returns:
        MetadataConfig object
    """
    if not YAML_AVAILABLE:
        raise ImportError("PyYAML is required for metadata files. Install with: pip install pyyaml")
    
    path = Path(filepath).expanduser()
    
    if not path.exists():
        logger.warning(f"Metadata file not found: {path}")
        return MetadataConfig()
    
    with open(path, 'r') as f:
        data = yaml.safe_load(f) or {}
    
    return MetadataConfig(
        models=data.get("models", {}),
        trust_boundaries=data.get("trust_boundaries", {}),
        agents=data.get("agents", {}),
        datasets=data.get("datasets", []),
        defaults=data.get("defaults", {})
    )


def save_metadata(config: MetadataConfig, filepath: str) -> None:
    """
    Save metadata configuration to YAML file.
    
    Args:
        config: MetadataConfig to save
        filepath: Output path
    """
    if not YAML_AVAILABLE:
        raise ImportError("PyYAML is required for metadata files. Install with: pip install pyyaml")
    
    data = {
        "models": config.models,
        "trust_boundaries": config.trust_boundaries,
        "agents": config.agents,
        "datasets": config.datasets,
        "defaults": config.defaults,
    }
    
    # Remove empty sections
    data = {k: v for k, v in data.items() if v}
    
    path = Path(filepath).expanduser()
    path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(path, 'w') as f:
        yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
    
    logger.info(f"Saved metadata to {path}")


def generate_template(
    scan_result: Any,
    output_path: str = "./ai-scrm-metadata.yaml"
) -> str:
    """
    Generate a metadata template file based on scan results.
    
    Creates a YAML file with:
    - Discovered models that need supplier info (marked with TODO)
    - Trust boundary patterns with sensible defaults
    - Placeholder sections for agents and datasets
    
    Args:
        scan_result: ScanResult from scanner
        output_path: Where to write the template
        
    Returns:
        Path to generated file
    """
    lines = []
    
    # Header
    lines.extend([
        "# AI-SCRM Metadata Configuration",
        "# Generated by ai-scrm init",
        "#",
        "# This file provides metadata that cannot be auto-discovered.",
        "# Review and update the TODO items below.",
        "",
    ])
    
    # Models section
    lines.extend([
        "# ============================================================",
        "# Model Metadata",
        "# ============================================================",
        "# Map filename patterns to supplier and other metadata.",
        "# Patterns support * (any characters) and ? (single character).",
        "",
        "models:",
    ])
    
    # Group models by whether they need review
    needs_review = [m for m in scan_result.models if m.needs_review]
    complete = [m for m in scan_result.models if not m.needs_review]
    
    if needs_review:
        lines.append("  # TODO: Add supplier information for these models:")
        for model in needs_review:
            lines.extend([
                f'  "{model.name}*":',
                f'    supplier: "TODO"  # <-- Add supplier name',
            ])
            if model.model_type != "base":
                lines.append(f'    type: {model.model_type}')
            lines.append("")
    
    if complete:
        lines.append("  # These models have inferred metadata (review if needed):")
        for model in complete:
            lines.extend([
                f'  "{model.name}*":',
                f'    supplier: "{model.supplier}"',
            ])
            if model.model_type != "base":
                lines.append(f'    type: {model.model_type}')
            if model.family:
                lines.append(f'    family: "{model.family}"')
            lines.append("")
    
    if not scan_result.models:
        lines.extend([
            '  # Example:',
            '  # "llama*.safetensors":',
            '  #   supplier: "Meta"',
            '  #   type: base',
            "",
        ])
    
    # Trust boundaries section
    lines.extend([
        "",
        "# ============================================================",
        "# Trust Boundaries",
        "# ============================================================",
        "# Map endpoint patterns to trust boundaries.",
        "# Valid boundaries: internal, external, hybrid",
        "# Default: external (most restrictive)",
        "",
        "trust_boundaries:",
        '  # Localhost is internal by default',
        '  "localhost:*": internal',
        '  "127.0.0.1:*": internal',
        "",
        '  # Private networks',
        '  "10.*": internal',
        '  "192.168.*": internal',
        "",
        '  # Add your internal domains:',
        '  # "*.internal.mycompany.com": internal',
        "",
        '  # Everything else defaults to external',
        '  "*": external',
        "",
    ])
    
    # MCP servers discovered
    if scan_result.mcp_servers:
        lines.extend([
            "# Discovered MCP servers and their classified boundaries:",
        ])
        for mcp in scan_result.mcp_servers:
            lines.append(f'  # {mcp.name}: {mcp.endpoint} -> {mcp.trust_boundary}')
        lines.append("")
    
    # Agents section
    lines.extend([
        "",
        "# ============================================================",
        "# Agent Configurations",
        "# ============================================================",
        "# Define which tools/MCP servers each agent can use.",
        "# This is a design decision - cannot be auto-discovered.",
        "",
        "agents:",
        "  # Example:",
        "  # research-agent:",
        "  #   permitted_tools:",
        "  #     - web-search",
        "  #     - file-reader",
        "  #   permitted_mcp:",
        "  #     - filesystem-mcp",
        "  #     - database-mcp",
        "  #   autonomy_level: supervised",
        "",
    ])
    
    # Datasets section
    lines.extend([
        "",
        "# ============================================================",
        "# Datasets",
        "# ============================================================",
        "# Datasets used for training/fine-tuning cannot be discovered",
        "# at runtime. Declare them here for compliance.",
        "",
        "datasets:",
        "  # Example:",
        "  # - name: training-data-v1",
        "  #   version: \"2024-01\"",
        "  #   source: internal",
        "  #   type: fine-tuning",
        "  #   license: proprietary",
        "",
    ])
    
    # Defaults section
    lines.extend([
        "",
        "# ============================================================",
        "# Default Values",
        "# ============================================================",
        "# Defaults applied when metadata is missing.",
        "",
        "defaults:",
        '  trust_boundary: external',
        '  model_type: base',
        "",
    ])
    
    # Write file
    content = "\n".join(lines)
    
    path = Path(output_path).expanduser()
    path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(path, 'w') as f:
        f.write(content)
    
    logger.info(f"Generated metadata template: {path}")
    return str(path)


class MetadataEnricher:
    """
    Enriches scan results with metadata from configuration.
    
    Example:
        >>> enricher = MetadataEnricher("./ai-scrm-metadata.yaml")
        >>> enricher.enrich(scan_result)
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize enricher.
        
        Args:
            config_path: Path to metadata YAML file
        """
        self.config: Optional[MetadataConfig] = None
        
        if config_path:
            self.load_config(config_path)
    
    def load_config(self, config_path: str) -> None:
        """Load configuration from file."""
        self.config = load_metadata(config_path)
    
    def enrich(self, scan_result: Any) -> None:
        """
        Enrich scan results in-place with metadata.
        
        Args:
            scan_result: ScanResult to enrich
        """
        if not self.config:
            logger.warning("No metadata config loaded, skipping enrichment")
            return
        
        # Enrich models
        for model in scan_result.models:
            self._enrich_model(model)
        
        # Enrich MCP trust boundaries
        for mcp in scan_result.mcp_servers:
            self._enrich_mcp(mcp)
    
    def _enrich_model(self, model: Any) -> None:
        """Enrich a single model with metadata."""
        if not self.config:
            return
        
        # Find matching pattern
        for pattern, metadata in self.config.models.items():
            if self._match_pattern(pattern, model.name):
                # Apply metadata
                if "supplier" in metadata and metadata["supplier"] != "TODO":
                    model.supplier = metadata["supplier"]
                    if "supplier" in model.needs_review:
                        model.needs_review.remove("supplier")
                
                if "type" in metadata:
                    model.model_type = metadata["type"]
                
                if "family" in metadata:
                    model.family = metadata["family"]
                
                if "architecture" in metadata:
                    model.architecture = metadata["architecture"]
                
                break
        
        # Apply defaults
        if not model.supplier and "supplier" in self.config.defaults:
            default_supplier = self.config.defaults["supplier"]
            if default_supplier != "TODO":
                model.supplier = default_supplier
    
    def _enrich_mcp(self, mcp: Any) -> None:
        """Enrich MCP server with trust boundary."""
        if not self.config:
            return
        
        # Find matching pattern
        for pattern, boundary in self.config.trust_boundaries.items():
            if self._match_pattern(pattern, mcp.endpoint):
                mcp.trust_boundary = boundary
                return
        
        # Apply default
        if "trust_boundary" in self.config.defaults:
            mcp.trust_boundary = self.config.defaults["trust_boundary"]
    
    def _match_pattern(self, pattern: str, value: str) -> bool:
        """Match a glob-style pattern against a value."""
        # Convert glob to regex
        regex = pattern.replace(".", r"\.")
        regex = regex.replace("*", ".*")
        regex = regex.replace("?", ".")
        regex = f"^{regex}$"
        
        return bool(re.match(regex, value, re.IGNORECASE))
    
    def get_datasets(self) -> List[Dict[str, str]]:
        """Get declared datasets from config."""
        if not self.config:
            return []
        return self.config.datasets
    
    def get_agents(self) -> Dict[str, Dict[str, Any]]:
        """Get agent configurations from config."""
        if not self.config:
            return {}
        return self.config.agents
