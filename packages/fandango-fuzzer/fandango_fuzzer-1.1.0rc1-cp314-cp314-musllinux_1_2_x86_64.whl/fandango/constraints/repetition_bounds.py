from copy import copy
from typing import Optional, Any, Unpack
from itertools import zip_longest
import random
from fandango.constraints.base import GeneticBaseInitArgs
from fandango.constraints.constraint import Constraint
from fandango.constraints.constraint_visitor import ConstraintVisitor
from fandango.constraints.failing_tree import (
    ApplyAllSuggestions,
    FailingTree,
    NopSuggestion,
    Suggestion,
)
from fandango.constraints.fitness import ConstraintFitness
from fandango.errors import FandangoValueError
from fandango.language.grammar.grammar import Grammar
from fandango.language.grammar.nodes.repetition import Repetition
from fandango.language.search import NonTerminalSearch
from fandango.language.symbols.non_terminal import NonTerminal
from fandango.language.tree import DerivationTree, index_by_reference


def _get_first_common_node(
    tree_a: DerivationTree, tree_b: DerivationTree
) -> DerivationTree:
    common_node = tree_a.get_root(True)
    for a_path, b_path in zip(tree_a.get_choices_path(), tree_b.get_choices_path()):
        if a_path.index == b_path.index:
            common_node = common_node.children[a_path.index]
        else:
            break
    return common_node


class RepetitionBoundsSuggestion(Suggestion):
    def __init__(
        self,
        ending_rep_tree: DerivationTree,
        starting_rep_value: DerivationTree,
        ending_rep_value: DerivationTree,
        bound_len: int,
        goal_len: int,
        iter_id: int,
        repetition_id: str,
        repetition_node: Repetition,
    ):
        """
        Suggestion to fix a failing tree for a repetition bounds constraint.
        :param DerivationTree starting_rep_tree: The first tree generated by the repetition.
        :param DerivationTree ending_rep_tree: The last tree generated by the repetition.
        :param DerivationTree starting_rep_value: The reference to the subtree giving min repetition value
        :param DerivationTree ending_rep_value: A reference to the subtree giving max repetition value
        :param int bound_len: The length of the repetition bounds.
        :param int goal_len: The goal length of the repetition.
        :param int iter_id: The iteration ID of the repetition.
        :param str repetition_id: The ID of the repetition.
        :param Repetition repetition_node: The repetition node.
        """
        self._ending_rep_tree = ending_rep_tree
        self._starting_rep_value = starting_rep_value
        self._ending_rep_value = ending_rep_value
        self._bound_len = bound_len
        self._goal_len = goal_len
        self._iter_id = iter_id
        self._repetition_id = repetition_id
        self._repetition_node = repetition_node
        self.allow_repetition_full_delete = False

    def rec_set_allow_repetition_full_delete(
        self, allow_repetition_full_delete: bool
    ) -> None:
        self.allow_repetition_full_delete = allow_repetition_full_delete

    def _insert_repetitions(
        self,
        *,
        nr_to_insert: int,
        rep_iteration: int,
        grammar: "Grammar",
    ) -> tuple[DerivationTree, DerivationTree]:
        tree = self._ending_rep_tree.parent
        assert tree is not None, "end_rep must have a parent"
        index = index_by_reference(tree, self._ending_rep_tree)

        if index is None:
            raise ValueError("end_rep not found in its parent's children")
        insertion_index = index + 1

        starting_rep = 0
        for ref in self._ending_rep_tree.origin_repetitions:
            if ref[0] == self._repetition_id and ref[1] == rep_iteration:
                assert ref[2] is not None, "repetition index (ref[2]) must not be None"
                starting_rep = ref[2] + 1

        old_tree_children = tree.children
        tree.set_children([])

        self._repetition_node.fuzz(
            tree,
            grammar,
            override_starting_repetition=starting_rep,
            override_current_iteration=rep_iteration,
            override_iterations_to_perform=starting_rep + nr_to_insert,
        )

        insert_children = tree.children
        tree.set_children(old_tree_children)

        copy_parent = tree.deepcopy(
            copy_children=True,
            copy_parent=False,
            copy_params=False,
        )
        copy_parent.set_children(
            copy_parent.children[:insertion_index]
            + insert_children
            + copy_parent.children[insertion_index:]
        )

        return tree, copy_parent

    def _delete_repetitions(
        self, *, nr_to_delete: int, rep_iteration: int
    ) -> tuple[DerivationTree, DerivationTree]:
        assert self._ending_rep_tree.parent is not None
        tree = self._ending_rep_tree.parent
        copy_parent = tree.deepcopy(
            copy_children=True, copy_parent=False, copy_params=False
        )
        curr_rep_id = None
        reps_deleted = 0
        new_children: list[DerivationTree] = []
        for child in copy_parent.children[::-1]:
            repetition_node_id = self._repetition_id
            matching_o_nodes = list(
                filter(
                    lambda x: x[0] == repetition_node_id and x[1] == rep_iteration,
                    child.origin_repetitions,
                )
            )
            if len(matching_o_nodes) == 0:
                new_children.insert(0, child)
                continue
            matching_o_node = matching_o_nodes[0]
            rep_id = matching_o_node[2]
            if curr_rep_id != rep_id and reps_deleted >= nr_to_delete:
                # We have deleted enough repetitions iteratively add all remaining children
                new_children.insert(0, child)
                continue
            curr_rep_id = rep_id
            reps_deleted += 1
        copy_parent.set_children(new_children)
        return tree, copy_parent

    def get_replacements(
        self, individual: DerivationTree, grammar: Grammar
    ) -> list[tuple[DerivationTree, DerivationTree]]:
        """
        Get the replacements for the failing tree.
        :param individual: The individual to get the replacements for.
        :return: Replacements (target, source) pairs.
        """
        replacements: list[tuple[DerivationTree, DerivationTree]] = []
        if self._goal_len > self._bound_len:
            replacements.append(
                self._insert_repetitions(
                    nr_to_insert=self._goal_len - self._bound_len,
                    rep_iteration=self._iter_id,
                    grammar=grammar,
                )
            )
        else:
            if self._goal_len == 0 and not self.allow_repetition_full_delete:
                self._goal_len = 1
            if self._goal_len == self._bound_len:
                return []
            delete_replace_pair = self._delete_repetitions(
                nr_to_delete=self._bound_len - self._goal_len,
                rep_iteration=self._iter_id,
            )
            if self._goal_len == 0:
                repetition_parent = self._ending_rep_tree.parent
                assert repetition_parent is not None
                delete_replacement: DerivationTree = delete_replace_pair[1]
                node_a = _get_first_common_node(
                    repetition_parent, self._starting_rep_value
                )
                node_b = _get_first_common_node(
                    repetition_parent, self._ending_rep_value
                )
                node_c = _get_first_common_node(
                    self._starting_rep_value, self._ending_rep_value
                )
                # Get the node that is closest to root
                first_node = sorted(
                    [node_a, node_b, node_c], key=lambda x: len(x.get_path())
                )[0]
                replacement = first_node.deepcopy(
                    copy_children=True, copy_params=False, copy_parent=False
                )
                replacement = replacement.replace_multiple(
                    grammar=grammar,
                    replacements=[(repetition_parent, delete_replacement)],
                    current_path=first_node.get_choices_path(),
                )

                read_only_start_idx = len(first_node.get_path()) - 1
                current_node = replacement
                for path_node in repetition_parent.get_choices_path()[
                    read_only_start_idx:
                ]:
                    current_node = current_node.children[path_node.index]
                    current_node.read_only = True
                current_node = replacement
                for path_node in self._starting_rep_value.get_choices_path()[
                    read_only_start_idx:
                ]:
                    current_node = current_node.children[path_node.index]
                    current_node.read_only = True
                current_node.set_all_read_only(True)
                current_node = replacement
                for path_node in self._ending_rep_value.get_choices_path()[
                    read_only_start_idx:
                ]:
                    current_node = current_node.children[path_node.index]
                    current_node.read_only = True
                current_node.set_all_read_only(True)
                replacements.append((first_node, replacement))
            else:
                replacements.append(delete_replace_pair)

        return replacements


class RepetitionBoundsConstraint(Constraint):
    """
    Represents a constraint that checks the number of repetitions of a certain pattern in a tree.
    This is useful for ensuring that certain patterns do not occur too frequently or too infrequently.
    """

    def __init__(
        self,
        repetition_id: str,
        expr_data_min: tuple[
            str, list[NonTerminalSearch], dict[str, NonTerminalSearch]
        ],
        expr_data_max: tuple[
            str, list[NonTerminalSearch], dict[str, NonTerminalSearch]
        ],
        repetition_node: Repetition,
        **kwargs: Unpack[GeneticBaseInitArgs],
    ):
        """
        Initializes the repetition bounds constraint with the given pattern and repetition bounds.
        :param NonTerminalSearch pattern: The pattern to check for repetitions.
        :param int min_reps: The minimum number of repetitions allowed.
        :param int max_reps: The maximum number of repetitions allowed.
        :param args: Additional arguments.
        :param kwargs: Additional keyword arguments.
        """
        super().__init__(**kwargs)
        self.repetition_id = repetition_id
        self.expr_data_min = expr_data_min
        self.expr_data_max = expr_data_max
        self.search_min: Optional[NonTerminalSearch] = None
        self.search_max: Optional[NonTerminalSearch] = None
        if len(expr_data_min[1]) == 0:
            self.search_min = None
        elif len(expr_data_min[1]) == 1:
            self.search_min = expr_data_min[1][0]
        else:
            raise FandangoValueError(
                "RepetitionBoundsConstraint requires exactly one or zero searches for expr_data_max bound"
            )

        if len(expr_data_max[1]) == 0:
            self.search_max = None
        elif len(expr_data_max[1]) == 1:
            self.search_max = expr_data_max[1][0]
        else:
            raise FandangoValueError(
                "RepetitionBoundsConstraint requires exactly one or zero searches for expr_data_max bound"
            )
        self.repetition_node = repetition_node

    def _compute_rep_bound(
        self,
        tree_rightmost_relevant_node: "DerivationTree",
        expr_data: tuple[str, list[NonTerminalSearch], dict[str, NonTerminalSearch]],
    ) -> tuple[Any, "DerivationTree"]:
        expr, _, searches = expr_data
        local_cpy = self.local_variables.copy()

        if len(searches) == 0:
            return (
                eval(expr, self.global_variables, local_cpy),
                tree_rightmost_relevant_node,
            )

        nodes = []
        if len(searches) != 1:
            raise FandangoValueError(
                "Computed repetition requires exactly one or zero searches"
            )

        search_name, search = next(iter(searches.items()))
        max_path = tree_rightmost_relevant_node.get_choices_path()
        for container in search.find(tree_rightmost_relevant_node.get_root()):
            container_tree: DerivationTree = container.evaluate()
            search_in_bounds = True
            zip_var = list(zip_longest(max_path, container_tree.get_choices_path()))
            for i, (max_step, search_step) in enumerate(zip_var):
                if max_step is None:
                    break
                if search_step is None:
                    break
                if max_step.index > search_step.index:
                    break
                if max_step.index < search_step.index:
                    search_in_bounds = False
                    break
            if not search_in_bounds:
                continue
            nodes.append(container_tree)

        if len(nodes) == 0:
            raise FandangoValueError(
                f"Couldn't find search target ({search.format_as_spec()}) in prefixed DerivationTree for computed repetition"
            )

        target = nodes[-1]
        local_cpy[search_name] = target
        return eval(expr, self.global_variables, local_cpy), target

    def min(self, tree_stop_before: DerivationTree) -> tuple[Any, DerivationTree]:
        return self._compute_rep_bound(tree_stop_before, self.expr_data_min)

    def max(self, tree_stop_before: DerivationTree) -> tuple[Any, DerivationTree]:
        return self._compute_rep_bound(tree_stop_before, self.expr_data_max)

    def group_by_repetition_id(
        self, id_trees: list[DerivationTree]
    ) -> dict[tuple[str, int], dict[int, list[DerivationTree]]]:
        reference_trees: dict[tuple[str, int], dict[int, list[DerivationTree]]] = {}
        for id_tree in id_trees:
            iteration_ids: list[tuple[str, int, int]] = list(
                filter(lambda x: x[0] == self.repetition_id, id_tree.origin_repetitions)
            )
            for i_id in iteration_ids:
                call_id = tuple[str, int](i_id[:2])
                rep_round = i_id[2]
                # Group by id and repetition round

                if call_id not in reference_trees:
                    reference_trees[call_id] = dict()
                iter_list = reference_trees[call_id]
                if rep_round not in iter_list:
                    iter_list[rep_round] = []
                iter_list[rep_round].append(id_tree)
        return reference_trees

    def fitness(
        self,
        tree: DerivationTree,
        scope: Optional[dict[NonTerminal, DerivationTree]] = None,
        local_variables: Optional[dict[str, Any]] = None,
    ) -> ConstraintFitness:
        """
        Calculate the fitness of the tree based on the number of repetitions of the pattern.
        :param DerivationTree tree: The tree to evaluate.
        :param Optional[dict[NonTerminal, DerivationTree]] scope: The scope of the tree.
        :param Optional[dict[str, Any]] local_variables: Local variables to use in the evaluation.
        :return ConstraintFitness: The fitness of the tree.
        """
        tree_hash = self.get_hash(tree, scope, local_variables)
        # If the fitness has already been calculated, return the cached value
        if tree_hash in self.cache:
            return copy(self.cache[tree_hash])

        id_trees = tree.find_by_origin(self.repetition_id)
        if len(id_trees) == 0:
            # Assume that the field containing the nr of repetitions is zero.
            # This is the case where we might have deleted all repetitions from the tree.
            fitness = ConstraintFitness(1, 1, True, NopSuggestion())
            self.cache[tree_hash] = fitness
            return fitness

        reference_trees = self.group_by_repetition_id(id_trees)
        failing_trees = []
        suggestions = []

        solved = 0
        total = len(reference_trees.keys())

        for call_id in reference_trees.keys():
            iter_list = reference_trees[call_id]
            smallest_rep = min(iter_list.keys())
            highest_rep = max(iter_list.keys())
            first_iteration = iter_list[smallest_rep][0]
            last_iteration = iter_list[highest_rep][-1]

            max_bounds_search = first_iteration
            assert max_bounds_search.parent is not None
            while (
                index_by_reference(max_bounds_search.parent.children, max_bounds_search)
                == 0
            ):
                max_bounds_search = max_bounds_search.parent
                assert max_bounds_search.parent is not None

            parent = max_bounds_search.parent
            assert parent is not None
            index = index_by_reference(parent.children, max_bounds_search)
            assert (
                index is not None and index > 0
            ), "Invalid child index for bounds search"
            max_bounds_search = parent.children[index - 1]

            bound_min, min_ref_tree = self.min(max_bounds_search)
            bound_max, max_ref_tree = self.max(max_bounds_search)
            bound_len = len(iter_list)

            if bound_min <= bound_len <= bound_max:
                solved += 1
            else:
                iter_id = call_id[1]
                goal_len = random.randint(bound_min, bound_max)

                assert first_iteration.parent is not None
                if not first_iteration.parent.read_only:
                    suggestions.append(
                        RepetitionBoundsSuggestion(
                            ending_rep_tree=last_iteration,
                            starting_rep_value=min_ref_tree,
                            ending_rep_value=max_ref_tree,
                            bound_len=bound_len,
                            goal_len=goal_len,
                            iter_id=iter_id,
                            repetition_id=self.repetition_id,
                            repetition_node=self.repetition_node,
                        )
                    )
                failing_trees.append(FailingTree(first_iteration.parent, self))

        fitness = ConstraintFitness(
            solved,
            total,
            solved == total,
            failing_trees=failing_trees,
            suggestion=ApplyAllSuggestions(suggestions),
        )
        self.cache[tree_hash] = fitness
        return fitness

    def format_as_spec(self) -> str:
        if self.search_min is None:
            print_min, _, _ = self.expr_data_min
        else:
            print_min = self.search_min.format_as_spec()
        if self.search_max is None:
            print_max, _, _ = self.expr_data_max
        else:
            print_max = self.search_max.format_as_spec()
        return f"RepetitionBounds({print_min} <= |{self.repetition_node.node.format_as_spec()}| <= {print_max})"

    def accept(self, visitor: ConstraintVisitor) -> None:
        """Accepts a visitor to traverse the constraint structure."""
        visitor.visit_repetition_bounds_constraint(self)

    def invert(self) -> "RepetitionBoundsConstraint":
        """
        RepetitionBoundsConstraint are not inverted.
        """
        raise NotImplementedError("RepetitionBoundsConstraints should not be inverted.")
