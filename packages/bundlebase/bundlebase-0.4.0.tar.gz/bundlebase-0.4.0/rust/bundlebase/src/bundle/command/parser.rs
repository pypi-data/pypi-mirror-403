//! Command parsing module.
//!
//! This module provides the entry point for parsing command statements into `BundleCommand`.
//!
//! # Architecture
//!
//! The parser uses a Pest grammar to handle all bundlebase commands (FILTER, ATTACH, JOIN, etc.).
//!
//! Each command struct implements parsing methods via the `CommandParsing` trait:
//! - `rule()` - Returns the pest Rule for this command
//! - `from_statement(pair)` - Parses from a pest Pair
//! - `to_statement()` - Serializes back to command string (round-trip support)
//!
//! Most commands are parsed via the centralized `parse_from_rule()` function generated by the
//! `register_commands!` macro. Commands with special parsing needs (like FETCH/FETCH ALL which
//! share the same grammar rule) are handled explicitly in `parse_command()`.

mod pest_parser;

// Re-export pest parser infrastructure
pub use pest_parser::{
    available_commands, escape_string, extract_string_content, format_pest_error,
    is_command_statement, parse_join_type, BundlebaseParser, Rule,
};

use crate::bundle::command::{
    parse_from_rule, BundleCommand, CommandParsing, FetchAllCommand, FetchCommand,
};
use crate::BundlebaseError;
use pest::Parser;

/// Parse a command statement into a BundleCommand.
///
/// This is the main entry point for parsing command statements into BundleCommand that can be
/// executed on a BundleBuilder.
///
/// Most rules are handled by `parse_from_rule()` which is generated by the `register_commands!`
/// macro. Special cases (like fetch_stmt which maps to either Fetch or FetchAll) are handled
/// explicitly here.
///
/// # Arguments
///
/// * `command_str` - The command statement string to parse
///
/// # Returns
///
/// * `Ok(BundleCommand)` - Successfully parsed command
/// * `Err(BundlebaseError)` - Parsing failed or statement type not supported
///
/// # Examples
///
/// ```ignore
/// use bundlebase::bundle::{parse_command, BundleCommand};
///
/// // Parse a FILTER statement
/// let cmd = parse_command("FILTER WHERE country = 'USA'").unwrap();
///
/// // Parse a SELECT statement
/// let cmd = parse_command("SELECT name, email FROM bundle").unwrap();
///
/// // Parse an ATTACH statement
/// let cmd = parse_command("ATTACH 'data.parquet'").unwrap();
///
/// // Execute on a BundleBuilder
/// cmd.execute(&mut bundle).await?;
/// ```
pub fn parse_command(command_str: &str) -> Result<BundleCommand, BundlebaseError> {
    let mut pairs = BundlebaseParser::parse(Rule::statement, command_str)
        .map_err(|e| format_pest_error(e, command_str))?;

    // Get the top-level statement rule
    let statement = pairs
        .next()
        .ok_or_else(|| BundlebaseError::from("Parser produced empty result"))?;

    // Get the category rule (data_modification_stmt, schema_stmt, etc.)
    let category_stmt = statement
        .into_inner()
        .next()
        .ok_or_else(|| BundlebaseError::from("Parser produced empty inner statement"))?;

    // Get the actual statement type from the category
    let inner_stmt = category_stmt
        .into_inner()
        .next()
        .ok_or_else(|| BundlebaseError::from("Parser produced empty statement in category"))?;

    let rule = inner_stmt.as_rule();

    // Handle special cases first
    match rule {
        // FETCH can be either FetchCommand or FetchAllCommand - determined by content
        Rule::fetch_stmt => {
            let raw = inner_stmt.as_str().to_uppercase();
            if raw.contains("ALL") {
                Ok(BundleCommand::FetchAll(FetchAllCommand::from_statement(
                    inner_stmt,
                )?))
            } else {
                Ok(BundleCommand::Fetch(FetchCommand::from_statement(inner_stmt)?))
            }
        }

        // All other rules use the centralized parse_from_rule() function
        _ => {
            match parse_from_rule(rule, inner_stmt)? {
                Some(cmd) => Ok(cmd),
                None => Err("Unexpected statement type".into()),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_sql_empty() {
        let result = parse_command("");
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("Syntax error"));
    }

    #[test]
    fn test_parse_create_view() {
        let cmd = parse_command("CREATE VIEW adults AS SELECT * FROM bundle WHERE age > 21");
        assert!(cmd.is_ok(), "CREATE VIEW should parse successfully: {:?}", cmd.err());
        let cmd = cmd.unwrap();
        assert!(matches!(cmd, BundleCommand::CreateView(_)));
    }
}
