//! Pest parser infrastructure for bundlebase custom SQL grammar.
//!
//! This module provides:
//! - The `BundlebaseParser` struct generated by pest
//! - Helper functions for parsing common elements (strings, identifiers, etc.)
//! - Error formatting utilities

use crate::bundle::pack::JoinTypeOption;
use crate::BundlebaseError;
use pest_derive::Parser;

/// Pest parser for bundlebase custom SQL grammar.
///
/// This parser handles bundlebase-specific syntax like FILTER, ATTACH, JOIN, etc.
/// Standard SQL is handled by sqlparser-rs.
#[derive(Parser)]
#[grammar = "bundle/command/parser/grammar.pest"]
pub struct BundlebaseParser;

/// Format a pest error into a user-friendly BundlebaseError.
pub fn format_pest_error(error: pest::error::Error<Rule>, sql: &str) -> BundlebaseError {
    let (line, col) = match &error.line_col {
        pest::error::LineColLocation::Pos((l, c)) => (*l, *c),
        pest::error::LineColLocation::Span((l, c), _) => (*l, *c),
    };

    format!(
        "Syntax error at line {}, column {}:\n{}\n\nSQL:\n{}",
        line, col, error, sql
    )
    .into()
}

/// Extract string content from a quoted string, handling escape sequences.
///
/// Supports both single-quoted ('...') and double-quoted ("...") strings.
pub fn extract_string_content(quoted: &str) -> Result<String, BundlebaseError> {
    let trimmed = quoted.trim();

    // Remove surrounding quotes
    let content = if trimmed.starts_with('\'') && trimmed.ends_with('\'') {
        &trimmed[1..trimmed.len() - 1]
    } else if trimmed.starts_with('"') && trimmed.ends_with('"') {
        &trimmed[1..trimmed.len() - 1]
    } else {
        return Err(format!("Invalid quoted string: {}", quoted).into());
    };

    // Process escape sequences
    Ok(process_escapes(content))
}

/// Process escape sequences in a string.
pub fn process_escapes(s: &str) -> String {
    s.replace("\\\\", "\\")
        .replace("\\'", "'")
        .replace("\\\"", "\"")
        .replace("\\n", "\n")
        .replace("\\r", "\r")
        .replace("\\t", "\t")
}

/// Parse join type from string representation.
pub fn parse_join_type(s: &str) -> Result<JoinTypeOption, BundlebaseError> {
    let normalized = s.trim().to_lowercase();
    Ok(match normalized.as_str() {
        "inner" => JoinTypeOption::Inner,
        "left" => JoinTypeOption::Left,
        "right" => JoinTypeOption::Right,
        "full" | "outer" | "full outer" => JoinTypeOption::Full,
        _ => return Err(format!("Unknown join type: {}", s).into()),
    })
}

/// Escape a string value for use in a SQL statement.
///
/// Returns a single-quoted string with special characters escaped.
pub fn escape_string(s: &str) -> String {
    let escaped = s
        .replace('\\', "\\\\")
        .replace('\'', "\\'")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t");
    format!("'{}'", escaped)
}

/// Check if a SQL string appears to be a bundlebase command statement.
///
/// Returns true if the SQL starts with a bundlebase command keyword,
/// false if it appears to be standard SQL that should be passed to DataFusion.
///
/// This function does a quick keyword check without full parsing.
pub fn is_command_statement(sql: &str) -> bool {
    let first_keyword = first_keyword(sql);
    all_statement_keywords().contains(&first_keyword.as_str())
}

/// Extract the first keyword from a SQL string.
pub fn first_keyword(sql: &str) -> String {
    sql.trim()
        .split_whitespace()
        .next()
        .unwrap_or("")
        .to_uppercase()
}

/// Returns all statement keywords that indicate a bundlebase command.
///
/// Derived from the first word of each key in `available_commands()`.
pub fn all_statement_keywords() -> Vec<&'static str> {
    let mut seen = std::collections::HashSet::new();
    let mut keywords = Vec::new();
    for key in available_commands().keys() {
        let first_word = key.split_whitespace().next().unwrap_or(key);
        if seen.insert(first_word) {
            keywords.push(first_word);
        }
    }
    keywords
}

/// Returns a map of command keywords to their syntax descriptions.
///
/// This is the single source of truth for all bundlebase command metadata.
/// Used by `all_statement_keywords()`, `rule_to_syntax()`, and the CLI completer.
pub fn available_commands() -> std::collections::HashMap<&'static str, &'static str> {
    let mut map = std::collections::HashMap::new();
    map.insert("FILTER", "FILTER WHERE <condition>");
    map.insert("ATTACH", "ATTACH '<path>' [TO <pack>] [WITH (<options>)]");
    map.insert("DETACH", "DETACH '<location>'");
    map.insert("REPLACE", "REPLACE '<old_location>' WITH '<new_location>'");
    map.insert("JOIN", "[LEFT|RIGHT|FULL|INNER] JOIN '<path>' AS <name> ON <expression>");
    map.insert("DROP COLUMN", "DROP COLUMN <name>");
    map.insert("DROP INDEX", "DROP INDEX <column>");
    map.insert("DROP VIEW", "DROP VIEW <name>");
    map.insert("DROP JOIN", "DROP JOIN <name>");
    map.insert("RENAME COLUMN", "RENAME COLUMN <old> TO <new>");
    map.insert("RENAME VIEW", "RENAME VIEW <old> TO <new>");
    map.insert("RENAME JOIN", "RENAME JOIN <old> TO <new>");
    map.insert("CREATE SOURCE", "CREATE SOURCE <function> WITH (<args>) [ON <pack>]");
    map.insert("CREATE INDEX", "CREATE INDEX ON <column>");
    map.insert("CREATE VIEW", "CREATE VIEW <name> AS <sql>");
    map.insert("FETCH", "FETCH [<pack>] | FETCH ALL");
    map.insert("REINDEX", "REINDEX [ON data(<column>)]");
    map.insert("REBUILD INDEX", "REBUILD INDEX ON <column>");
    map.insert("COMMIT", "COMMIT '<message>'");
    map.insert("RESET", "RESET");
    map.insert("UNDO", "UNDO");
    map.insert("SET CONFIG", "SET CONFIG <key> = '<value>' [FOR '<url_prefix>']");
    map.insert("SET NAME", "SET NAME '<name>'");
    map.insert("SET DESCRIPTION", "SET DESCRIPTION '<description>'");
    map.insert("VERIFY DATA", "VERIFY DATA [UPDATE]");
    map.insert("EXPLAIN PLAN", "EXPLAIN PLAN");
    map
}

/// Convert a Rule to its syntax description if available.
pub fn rule_to_syntax(rule: Rule) -> Option<&'static str> {
    let map = available_commands();
    match rule {
        Rule::filter_stmt => map.get("FILTER").copied(),
        Rule::attach_stmt => map.get("ATTACH").copied(),
        Rule::detach_stmt => map.get("DETACH").copied(),
        Rule::replace_stmt => map.get("REPLACE").copied(),
        Rule::join_stmt => map.get("JOIN").copied(),
        Rule::drop_column_stmt => map.get("DROP COLUMN").copied(),
        Rule::drop_index_stmt => map.get("DROP INDEX").copied(),
        Rule::drop_view_stmt => map.get("DROP VIEW").copied(),
        Rule::drop_join_stmt => map.get("DROP JOIN").copied(),
        Rule::rename_column_stmt => map.get("RENAME COLUMN").copied(),
        Rule::rename_view_stmt => map.get("RENAME VIEW").copied(),
        Rule::rename_join_stmt => map.get("RENAME JOIN").copied(),
        Rule::create_source_stmt => map.get("CREATE SOURCE").copied(),
        Rule::create_index_stmt => map.get("CREATE INDEX").copied(),
        Rule::create_view_stmt => map.get("CREATE VIEW").copied(),
        Rule::fetch_stmt => map.get("FETCH").copied(),
        Rule::reindex_stmt => map.get("REINDEX").copied(),
        Rule::rebuild_index_stmt => map.get("REBUILD INDEX").copied(),
        Rule::commit_stmt => map.get("COMMIT").copied(),
        Rule::reset_stmt => map.get("RESET").copied(),
        Rule::undo_stmt => map.get("UNDO").copied(),
        Rule::set_config_stmt => map.get("SET CONFIG").copied(),
        Rule::set_name_stmt => map.get("SET NAME").copied(),
        Rule::set_description_stmt => map.get("SET DESCRIPTION").copied(),
        Rule::verify_data_stmt => map.get("VERIFY DATA").copied(),
        Rule::explain_stmt => map.get("EXPLAIN PLAN").copied(),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_command_statement() {
        assert!(is_command_statement("FILTER WHERE x = 1"));
        assert!(is_command_statement("ATTACH 'file.csv'"));
        assert!(is_command_statement("COMMIT 'message'"));
        // SELECT is standard SQL, not a bundlebase command
        assert!(!is_command_statement("SELECT * FROM bundle"));
        // Standard SQL that doesn't start with our keywords
        assert!(!is_command_statement("INSERT INTO table VALUES (1)"));
        assert!(!is_command_statement("UPDATE table SET x = 1"));
        assert!(!is_command_statement("DELETE FROM table"));
    }

    #[test]
    fn test_first_keyword() {
        assert_eq!(first_keyword("FILTER WHERE x = 1"), "FILTER");
        assert_eq!(first_keyword("  attach 'file.csv'"), "ATTACH");
        assert_eq!(first_keyword(""), "");
    }

    #[test]
    fn test_available_commands_has_entries() {
        let map = available_commands();
        assert!(map.len() > 20);
        assert!(map.contains_key("FILTER"));
        assert!(map.contains_key("ATTACH"));
    }

    #[test]
    fn test_rule_to_syntax() {
        assert_eq!(
            rule_to_syntax(Rule::filter_stmt),
            Some("FILTER WHERE <condition>")
        );
        assert_eq!(
            rule_to_syntax(Rule::attach_stmt),
            Some("ATTACH '<path>' [TO <pack>] [WITH (<options>)]")
        );
    }
}
