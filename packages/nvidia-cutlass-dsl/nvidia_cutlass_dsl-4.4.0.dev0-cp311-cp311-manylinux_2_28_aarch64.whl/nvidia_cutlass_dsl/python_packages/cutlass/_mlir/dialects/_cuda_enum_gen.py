
# Autogenerated by mlir-tblgen; don't manually edit.

from enum import IntEnum, auto, IntFlag
from ._ods_common import _cext as _ods_cext
from ..ir import register_attribute_builder
_ods_ir = _ods_cext.ir

class CUDeviceAttr(IntEnum):
    """Enumerated type describing CUDA device attributes can be set through Cuda Dialect"""

    maxThreadsPerBlock = 1
    maxBlockDimX = 2
    maxBlockDimY = 3
    maxBlockDimZ = 4
    maxGridDimX = 5
    maxGridDimY = 6
    maxGridDimZ = 7
    maxSharedMemoryPerBlock = 8
    totalConstantMemory = 9
    warpSize = 10
    maxPitch = 11
    maxRegistersPerBlock = 12
    clockRate = 13
    textureAlignment = 14
    gpuOverlap = 15
    multiProcessorCount = 16
    kernelExecTimeout = 17
    integrated = 18
    canMapHostMemory = 19
    computeMode = 20
    maxTexture1DWidth = 21
    maxTexture2DWidth = 22
    maxTexture2DHeight = 23
    maxTexture3DWidth = 24
    maxTexture3DHeight = 25
    maxTexture3DDepth = 26
    maxTexture2DLayeredWidth = 27
    maxTexture2DLayeredHeight = 28
    maxTexture2DLayeredLayers = 29
    surfaceAlignment = 30
    concurrentKernels = 31
    eccEnabled = 32
    pciBusId = 33
    pciDeviceId = 34
    tccDriver = 35
    memoryClockRate = 36
    globalMemoryBusWidth = 37
    l2CacheSize = 38
    maxThreadsPerMultiProcessor = 39
    asyncEngineCount = 40
    unifiedAddressing = 41
    maxTexture1DLayeredWidth = 42
    maxTexture1DLayeredLayers = 43
    maxTexture2DGatherWidth = 45
    maxTexture2DGatherHeight = 46
    maxTexture3DWidthAlt = 47
    maxTexture3DHeightAlt = 48
    maxTexture3DDepthAlt = 49
    pciDomainId = 50
    texturePitchAlignment = 51
    maxTextureCubemapWidth = 52
    maxTextureCubemapLayeredWidth = 53
    maxTextureCubemapLayeredLayers = 54
    maxSurface1DWidth = 55
    maxSurface2DWidth = 56
    maxSurface2DHeight = 57
    maxSurface3DWidth = 58
    maxSurface3DHeight = 59
    maxSurface3DDepth = 60
    maxSurface1DLayeredWidth = 61
    maxSurface1DLayeredLayers = 62
    maxSurface2DLayeredWidth = 63
    maxSurface2DLayeredHeight = 64
    maxSurface2DLayeredLayers = 65
    maxSurfaceCubemapWidth = 66
    maxSurfaceCubemapLayeredWidth = 67
    maxSurfaceCubemapLayeredLayers = 68
    maxTexture1DLinearWidth = 69
    maxTexture2DLinearWidth = 70
    maxTexture2DLinearHeight = 71
    maxTexture2DLinearPitch = 72
    maxTexture2DMipmappedWidth = 73
    maxTexture2DMipmappedHeight = 74
    computeCapabilityMajor = 75
    computeCapabilityMinor = 76
    maxTexture1DMipmappedWidth = 77
    streamPrioritiesSupported = 78
    globalL1CacheSupported = 79
    localL1CacheSupported = 80
    maxSharedMemoryPerMultiprocessor = 81
    maxRegistersPerMultiprocessor = 82
    managedMemory = 83
    isMultiGpuBoard = 84
    multiGpuBoardGroupID = 85
    hostNativeAtomicSupported = 86
    singleToDoublePrecisionPerfRatio = 87
    pageableMemoryAccess = 88
    concurrentManagedAccess = 89
    computePreemptionSupported = 90
    canUseHostPointerForRegisteredMem = 91
    reserved92 = 92
    reserved93 = 93
    reserved94 = 94
    cooperativeLaunch = 95
    reserved96 = 96
    maxSharedMemoryPerBlockOptin = 97
    canFlushRemoteWrites = 98
    hostRegisterSupported = 99
    pageableMemoryAccessUsesHostPageTables = 100
    directManagedMemAccessFromHost = 101
    maxBlocksPerMultiprocessor = 106
    maxPersistingL2CacheSize = 108
    maxAccessPolicyWindowSize = 109
    reservedSharedMemoryPerBlock = 111
    sparseCudaArraySupported = 112
    hostRegisterReadOnlySupported = 113
    timelineSemaphoreInteropSupported = 114
    memoryPoolsSupported = 115
    gpuDirectRdmaSupported = 116
    gpuDirectRdmaFlushWritesOptions = 117
    gpuDirectRdmaWritesOrdering = 118
    memoryPoolSupportedHandleTypes = 119
    clusterLaunch = 120
    deferredMappingCudaArraySupported = 121
    reserved122 = 122
    reserved123 = 123
    reserved124 = 124
    ipcEventSupport = 125
    memSyncDomainCount = 126
    reserved127 = 127
    reserved128 = 128
    reserved129 = 129
    numaConfig = 130
    numaId = 131
    reserved132 = 132
    mpsEnabled = 133
    hostNumaId = 134
    d3d12CigSupported = 135
    vulkanCigSupported = 138
    gpuPciDeviceId = 139
    gpuPciSubsystemId = 140
    reserved141 = 141
    hostNumaMemoryPoolsSupported = 142
    hostNumaMultinodeIpcSupported = 143
    hostMemoryPoolsSupported = 144
    reserved145 = 145
    onlyPartialHostNativeAtomicSupported = 147

    def __str__(self):
        if self is CUDeviceAttr.maxThreadsPerBlock:
            return "maxThreadsPerBlock"
        if self is CUDeviceAttr.maxBlockDimX:
            return "maxBlockDimX"
        if self is CUDeviceAttr.maxBlockDimY:
            return "maxBlockDimY"
        if self is CUDeviceAttr.maxBlockDimZ:
            return "maxBlockDimZ"
        if self is CUDeviceAttr.maxGridDimX:
            return "maxGridDimX"
        if self is CUDeviceAttr.maxGridDimY:
            return "maxGridDimY"
        if self is CUDeviceAttr.maxGridDimZ:
            return "maxGridDimZ"
        if self is CUDeviceAttr.maxSharedMemoryPerBlock:
            return "maxSharedMemoryPerBlock"
        if self is CUDeviceAttr.totalConstantMemory:
            return "totalConstantMemory"
        if self is CUDeviceAttr.warpSize:
            return "warpSize"
        if self is CUDeviceAttr.maxPitch:
            return "maxPitch"
        if self is CUDeviceAttr.maxRegistersPerBlock:
            return "maxRegistersPerBlock"
        if self is CUDeviceAttr.clockRate:
            return "clockRate"
        if self is CUDeviceAttr.textureAlignment:
            return "textureAlignment"
        if self is CUDeviceAttr.gpuOverlap:
            return "gpuOverlap"
        if self is CUDeviceAttr.multiProcessorCount:
            return "multiProcessorCount"
        if self is CUDeviceAttr.kernelExecTimeout:
            return "kernelExecTimeout"
        if self is CUDeviceAttr.integrated:
            return "integrated"
        if self is CUDeviceAttr.canMapHostMemory:
            return "canMapHostMemory"
        if self is CUDeviceAttr.computeMode:
            return "computeMode"
        if self is CUDeviceAttr.maxTexture1DWidth:
            return "maxTexture1DWidth"
        if self is CUDeviceAttr.maxTexture2DWidth:
            return "maxTexture2DWidth"
        if self is CUDeviceAttr.maxTexture2DHeight:
            return "maxTexture2DHeight"
        if self is CUDeviceAttr.maxTexture3DWidth:
            return "maxTexture3DWidth"
        if self is CUDeviceAttr.maxTexture3DHeight:
            return "maxTexture3DHeight"
        if self is CUDeviceAttr.maxTexture3DDepth:
            return "maxTexture3DDepth"
        if self is CUDeviceAttr.maxTexture2DLayeredWidth:
            return "maxTexture2DLayeredWidth"
        if self is CUDeviceAttr.maxTexture2DLayeredHeight:
            return "maxTexture2DLayeredHeight"
        if self is CUDeviceAttr.maxTexture2DLayeredLayers:
            return "maxTexture2DLayeredLayers"
        if self is CUDeviceAttr.surfaceAlignment:
            return "surfaceAlignment"
        if self is CUDeviceAttr.concurrentKernels:
            return "concurrentKernels"
        if self is CUDeviceAttr.eccEnabled:
            return "eccEnabled"
        if self is CUDeviceAttr.pciBusId:
            return "pciBusId"
        if self is CUDeviceAttr.pciDeviceId:
            return "pciDeviceId"
        if self is CUDeviceAttr.tccDriver:
            return "tccDriver"
        if self is CUDeviceAttr.memoryClockRate:
            return "memoryClockRate"
        if self is CUDeviceAttr.globalMemoryBusWidth:
            return "globalMemoryBusWidth"
        if self is CUDeviceAttr.l2CacheSize:
            return "l2CacheSize"
        if self is CUDeviceAttr.maxThreadsPerMultiProcessor:
            return "maxThreadsPerMultiProcessor"
        if self is CUDeviceAttr.asyncEngineCount:
            return "asyncEngineCount"
        if self is CUDeviceAttr.unifiedAddressing:
            return "unifiedAddressing"
        if self is CUDeviceAttr.maxTexture1DLayeredWidth:
            return "maxTexture1DLayeredWidth"
        if self is CUDeviceAttr.maxTexture1DLayeredLayers:
            return "maxTexture1DLayeredLayers"
        if self is CUDeviceAttr.maxTexture2DGatherWidth:
            return "maxTexture2DGatherWidth"
        if self is CUDeviceAttr.maxTexture2DGatherHeight:
            return "maxTexture2DGatherHeight"
        if self is CUDeviceAttr.maxTexture3DWidthAlt:
            return "maxTexture3DWidthAlt"
        if self is CUDeviceAttr.maxTexture3DHeightAlt:
            return "maxTexture3DHeightAlt"
        if self is CUDeviceAttr.maxTexture3DDepthAlt:
            return "maxTexture3DDepthAlt"
        if self is CUDeviceAttr.pciDomainId:
            return "pciDomainId"
        if self is CUDeviceAttr.texturePitchAlignment:
            return "texturePitchAlignment"
        if self is CUDeviceAttr.maxTextureCubemapWidth:
            return "maxTextureCubemapWidth"
        if self is CUDeviceAttr.maxTextureCubemapLayeredWidth:
            return "maxTextureCubemapLayeredWidth"
        if self is CUDeviceAttr.maxTextureCubemapLayeredLayers:
            return "maxTextureCubemapLayeredLayers"
        if self is CUDeviceAttr.maxSurface1DWidth:
            return "maxSurface1DWidth"
        if self is CUDeviceAttr.maxSurface2DWidth:
            return "maxSurface2DWidth"
        if self is CUDeviceAttr.maxSurface2DHeight:
            return "maxSurface2DHeight"
        if self is CUDeviceAttr.maxSurface3DWidth:
            return "maxSurface3DWidth"
        if self is CUDeviceAttr.maxSurface3DHeight:
            return "maxSurface3DHeight"
        if self is CUDeviceAttr.maxSurface3DDepth:
            return "maxSurface3DDepth"
        if self is CUDeviceAttr.maxSurface1DLayeredWidth:
            return "maxSurface1DLayeredWidth"
        if self is CUDeviceAttr.maxSurface1DLayeredLayers:
            return "maxSurface1DLayeredLayers"
        if self is CUDeviceAttr.maxSurface2DLayeredWidth:
            return "maxSurface2DLayeredWidth"
        if self is CUDeviceAttr.maxSurface2DLayeredHeight:
            return "maxSurface2DLayeredHeight"
        if self is CUDeviceAttr.maxSurface2DLayeredLayers:
            return "maxSurface2DLayeredLayers"
        if self is CUDeviceAttr.maxSurfaceCubemapWidth:
            return "maxSurfaceCubemapWidth"
        if self is CUDeviceAttr.maxSurfaceCubemapLayeredWidth:
            return "maxSurfaceCubemapLayeredWidth"
        if self is CUDeviceAttr.maxSurfaceCubemapLayeredLayers:
            return "maxSurfaceCubemapLayeredLayers"
        if self is CUDeviceAttr.maxTexture1DLinearWidth:
            return "maxTexture1DLinearWidth"
        if self is CUDeviceAttr.maxTexture2DLinearWidth:
            return "maxTexture2DLinearWidth"
        if self is CUDeviceAttr.maxTexture2DLinearHeight:
            return "maxTexture2DLinearHeight"
        if self is CUDeviceAttr.maxTexture2DLinearPitch:
            return "maxTexture2DLinearPitch"
        if self is CUDeviceAttr.maxTexture2DMipmappedWidth:
            return "maxTexture2DMipmappedWidth"
        if self is CUDeviceAttr.maxTexture2DMipmappedHeight:
            return "maxTexture2DMipmappedHeight"
        if self is CUDeviceAttr.computeCapabilityMajor:
            return "computeCapabilityMajor"
        if self is CUDeviceAttr.computeCapabilityMinor:
            return "computeCapabilityMinor"
        if self is CUDeviceAttr.maxTexture1DMipmappedWidth:
            return "maxTexture1DMipmappedWidth"
        if self is CUDeviceAttr.streamPrioritiesSupported:
            return "streamPrioritiesSupported"
        if self is CUDeviceAttr.globalL1CacheSupported:
            return "globalL1CacheSupported"
        if self is CUDeviceAttr.localL1CacheSupported:
            return "localL1CacheSupported"
        if self is CUDeviceAttr.maxSharedMemoryPerMultiprocessor:
            return "maxSharedMemoryPerMultiprocessor"
        if self is CUDeviceAttr.maxRegistersPerMultiprocessor:
            return "maxRegistersPerMultiprocessor"
        if self is CUDeviceAttr.managedMemory:
            return "managedMemory"
        if self is CUDeviceAttr.isMultiGpuBoard:
            return "isMultiGpuBoard"
        if self is CUDeviceAttr.multiGpuBoardGroupID:
            return "multiGpuBoardGroupID"
        if self is CUDeviceAttr.hostNativeAtomicSupported:
            return "hostNativeAtomicSupported"
        if self is CUDeviceAttr.singleToDoublePrecisionPerfRatio:
            return "singleToDoublePrecisionPerfRatio"
        if self is CUDeviceAttr.pageableMemoryAccess:
            return "pageableMemoryAccess"
        if self is CUDeviceAttr.concurrentManagedAccess:
            return "concurrentManagedAccess"
        if self is CUDeviceAttr.computePreemptionSupported:
            return "computePreemptionSupported"
        if self is CUDeviceAttr.canUseHostPointerForRegisteredMem:
            return "canUseHostPointerForRegisteredMem"
        if self is CUDeviceAttr.reserved92:
            return "reserved92"
        if self is CUDeviceAttr.reserved93:
            return "reserved93"
        if self is CUDeviceAttr.reserved94:
            return "reserved94"
        if self is CUDeviceAttr.cooperativeLaunch:
            return "cooperativeLaunch"
        if self is CUDeviceAttr.reserved96:
            return "reserved96"
        if self is CUDeviceAttr.maxSharedMemoryPerBlockOptin:
            return "maxSharedMemoryPerBlockOptin"
        if self is CUDeviceAttr.canFlushRemoteWrites:
            return "canFlushRemoteWrites"
        if self is CUDeviceAttr.hostRegisterSupported:
            return "hostRegisterSupported"
        if self is CUDeviceAttr.pageableMemoryAccessUsesHostPageTables:
            return "pageableMemoryAccessUsesHostPageTables"
        if self is CUDeviceAttr.directManagedMemAccessFromHost:
            return "directManagedMemAccessFromHost"
        if self is CUDeviceAttr.maxBlocksPerMultiprocessor:
            return "maxBlocksPerMultiprocessor"
        if self is CUDeviceAttr.maxPersistingL2CacheSize:
            return "maxPersistingL2CacheSize"
        if self is CUDeviceAttr.maxAccessPolicyWindowSize:
            return "maxAccessPolicyWindowSize"
        if self is CUDeviceAttr.reservedSharedMemoryPerBlock:
            return "reservedSharedMemoryPerBlock"
        if self is CUDeviceAttr.sparseCudaArraySupported:
            return "sparseCudaArraySupported"
        if self is CUDeviceAttr.hostRegisterReadOnlySupported:
            return "hostRegisterReadOnlySupported"
        if self is CUDeviceAttr.timelineSemaphoreInteropSupported:
            return "timelineSemaphoreInteropSupported"
        if self is CUDeviceAttr.memoryPoolsSupported:
            return "memoryPoolsSupported"
        if self is CUDeviceAttr.gpuDirectRdmaSupported:
            return "gpuDirectRdmaSupported"
        if self is CUDeviceAttr.gpuDirectRdmaFlushWritesOptions:
            return "gpuDirectRdmaFlushWritesOptions"
        if self is CUDeviceAttr.gpuDirectRdmaWritesOrdering:
            return "gpuDirectRdmaWritesOrdering"
        if self is CUDeviceAttr.memoryPoolSupportedHandleTypes:
            return "memoryPoolSupportedHandleTypes"
        if self is CUDeviceAttr.clusterLaunch:
            return "clusterLaunch"
        if self is CUDeviceAttr.deferredMappingCudaArraySupported:
            return "deferredMappingCudaArraySupported"
        if self is CUDeviceAttr.reserved122:
            return "reserved122"
        if self is CUDeviceAttr.reserved123:
            return "reserved123"
        if self is CUDeviceAttr.reserved124:
            return "reserved124"
        if self is CUDeviceAttr.ipcEventSupport:
            return "ipcEventSupport"
        if self is CUDeviceAttr.memSyncDomainCount:
            return "memSyncDomainCount"
        if self is CUDeviceAttr.reserved127:
            return "reserved127"
        if self is CUDeviceAttr.reserved128:
            return "reserved128"
        if self is CUDeviceAttr.reserved129:
            return "reserved129"
        if self is CUDeviceAttr.numaConfig:
            return "numaConfig"
        if self is CUDeviceAttr.numaId:
            return "numaId"
        if self is CUDeviceAttr.reserved132:
            return "reserved132"
        if self is CUDeviceAttr.mpsEnabled:
            return "mpsEnabled"
        if self is CUDeviceAttr.hostNumaId:
            return "hostNumaId"
        if self is CUDeviceAttr.d3d12CigSupported:
            return "d3d12CigSupported"
        if self is CUDeviceAttr.vulkanCigSupported:
            return "vulkanCigSupported"
        if self is CUDeviceAttr.gpuPciDeviceId:
            return "gpuPciDeviceId"
        if self is CUDeviceAttr.gpuPciSubsystemId:
            return "gpuPciSubsystemId"
        if self is CUDeviceAttr.reserved141:
            return "reserved141"
        if self is CUDeviceAttr.hostNumaMemoryPoolsSupported:
            return "hostNumaMemoryPoolsSupported"
        if self is CUDeviceAttr.hostNumaMultinodeIpcSupported:
            return "hostNumaMultinodeIpcSupported"
        if self is CUDeviceAttr.hostMemoryPoolsSupported:
            return "hostMemoryPoolsSupported"
        if self is CUDeviceAttr.reserved145:
            return "reserved145"
        if self is CUDeviceAttr.onlyPartialHostNativeAtomicSupported:
            return "onlyPartialHostNativeAtomicSupported"
        raise ValueError("Unknown CUDeviceAttr enum entry.")



@register_attribute_builder("CUDeviceAttrEnum")
def _cudeviceattrenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CUFunctionAttribute(IntEnum):
    """Enumerated type describing CUDA function attributes can be set through Cuda Dialect"""

    max_threads_per_block = 0
    shared_size_bytes = 1
    const_size_bytes = 2
    local_size_bytes = 3
    num_regs = 4
    ptx_version = 5
    binary_version = 6
    cache_mode_ca = 7
    max_dynamic_shared_size_bytes = 8
    preferred_shared_memory_carveout = 9
    cluster_size_must_be_set = 10
    required_cluster_width = 11
    required_cluster_height = 12
    required_cluster_depth = 13
    non_portable_cluster_size_allowed = 14
    cluster_scheduling_policy_preference = 15

    def __str__(self):
        if self is CUFunctionAttribute.max_threads_per_block:
            return "max_threads_per_block"
        if self is CUFunctionAttribute.shared_size_bytes:
            return "shared_size_bytes"
        if self is CUFunctionAttribute.const_size_bytes:
            return "const_size_bytes"
        if self is CUFunctionAttribute.local_size_bytes:
            return "local_size_bytes"
        if self is CUFunctionAttribute.num_regs:
            return "num_regs"
        if self is CUFunctionAttribute.ptx_version:
            return "ptx_version"
        if self is CUFunctionAttribute.binary_version:
            return "binary_version"
        if self is CUFunctionAttribute.cache_mode_ca:
            return "cache_mode_ca"
        if self is CUFunctionAttribute.max_dynamic_shared_size_bytes:
            return "max_dynamic_shared_size_bytes"
        if self is CUFunctionAttribute.preferred_shared_memory_carveout:
            return "preferred_shared_memory_carveout"
        if self is CUFunctionAttribute.cluster_size_must_be_set:
            return "cluster_size_must_be_set"
        if self is CUFunctionAttribute.required_cluster_width:
            return "required_cluster_width"
        if self is CUFunctionAttribute.required_cluster_height:
            return "required_cluster_height"
        if self is CUFunctionAttribute.required_cluster_depth:
            return "required_cluster_depth"
        if self is CUFunctionAttribute.non_portable_cluster_size_allowed:
            return "non_portable_cluster_size_allowed"
        if self is CUFunctionAttribute.cluster_scheduling_policy_preference:
            return "cluster_scheduling_policy_preference"
        raise ValueError("Unknown CUFunctionAttribute enum entry.")



@register_attribute_builder("CUFunctionAttributeEnum")
def _cufunctionattributeenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaABI(IntEnum):
    """Enumerated of the host library ABI"""

    LP64 = 0
    ILP64 = 1
    LLP64 = 2

    def __str__(self):
        if self is CudaABI.LP64:
            return "LP64"
        if self is CudaABI.ILP64:
            return "ILP64"
        if self is CudaABI.LLP64:
            return "LLP64"
        raise ValueError("Unknown CudaABI enum entry.")



@register_attribute_builder("CudaABI")
def _cudaabi(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaAccessProperty(IntEnum):
    """Specifies performance hint with cudaAccessPolicyWindow for hitProp and missProp members"""

    cudaAccessPropertyNormal = 0
    cudaAccessPropertyStreaming = 1
    cudaAccessPropertyPersisting = 2

    def __str__(self):
        if self is CudaAccessProperty.cudaAccessPropertyNormal:
            return "cudaAccessPropertyNormal"
        if self is CudaAccessProperty.cudaAccessPropertyStreaming:
            return "cudaAccessPropertyStreaming"
        if self is CudaAccessProperty.cudaAccessPropertyPersisting:
            return "cudaAccessPropertyPersisting"
        raise ValueError("Unknown CudaAccessProperty enum entry.")



@register_attribute_builder("CudaAccessProperty")
def _cudaaccessproperty(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class ArchPortability(IntEnum):
    """Enumerated type describing portability"""

    portable = 0
    conditional = 1
    family = 2

    def __str__(self):
        if self is ArchPortability.portable:
            return "portable"
        if self is ArchPortability.conditional:
            return "conditional"
        if self is ArchPortability.family:
            return "family"
        raise ValueError("Unknown ArchPortability enum entry.")



@register_attribute_builder("CudaArchPortabilityEnum")
def _cudaarchportabilityenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaClusterSchedulingPolicy(IntEnum):
    """Enumerated type describing CUDA cluster scheduling policy"""

    cudaClusterSchedulingPolicyDefault = 0
    cudaClusterSchedulingPolicySpread = 1
    cudaClusterSchedulingPolicyLoadBalancing = 2

    def __str__(self):
        if self is CudaClusterSchedulingPolicy.cudaClusterSchedulingPolicyDefault:
            return "cudaClusterSchedulingPolicyDefault"
        if self is CudaClusterSchedulingPolicy.cudaClusterSchedulingPolicySpread:
            return "cudaClusterSchedulingPolicySpread"
        if self is CudaClusterSchedulingPolicy.cudaClusterSchedulingPolicyLoadBalancing:
            return "cudaClusterSchedulingPolicyLoadBalancing"
        raise ValueError("Unknown CudaClusterSchedulingPolicy enum entry.")



@register_attribute_builder("CudaClusterSchedulingPolicy")
def _cudaclusterschedulingpolicy(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaDlcSplitMode(IntEnum):
    """Enumerated type describing CUDA DLC split mode"""

    CudaDlcSplitModeNone = 0
    CudaDlcSplitModeAny = 1
    CudaDlcSplitModeSingleDlcc = 2
    CudaDlcSplitModeDualDlcc = 3

    def __str__(self):
        if self is CudaDlcSplitMode.CudaDlcSplitModeNone:
            return "CudaDlcSplitModeNone"
        if self is CudaDlcSplitMode.CudaDlcSplitModeAny:
            return "CudaDlcSplitModeAny"
        if self is CudaDlcSplitMode.CudaDlcSplitModeSingleDlcc:
            return "CudaDlcSplitModeSingleDlcc"
        if self is CudaDlcSplitMode.CudaDlcSplitModeDualDlcc:
            return "CudaDlcSplitModeDualDlcc"
        raise ValueError("Unknown CudaDlcSplitMode enum entry.")



@register_attribute_builder("CudaDlcSplitModeEnum")
def _cudadlcsplitmodeenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class ExecutableFormat(IntEnum):
    """Enumerated type describing the format of an executable"""

    text = 0
    elf = 1
    bitcode = 2
    fatbin = 3

    def __str__(self):
        if self is ExecutableFormat.text:
            return "text"
        if self is ExecutableFormat.elf:
            return "elf"
        if self is ExecutableFormat.bitcode:
            return "bitcode"
        if self is ExecutableFormat.fatbin:
            return "fatbin"
        raise ValueError("Unknown ExecutableFormat enum entry.")



@register_attribute_builder("CudaExecutableFormatEnum")
def _cudaexecutableformatenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class ExecutableRepresentation(IntEnum):
    """Enumerated type describing the representation of an executable"""

    sass = 0
    ptx = 2
    nvvm = 3
    ltoir = 4
    mlir = 5
    llvm = 6
    hostobj = 7

    def __str__(self):
        if self is ExecutableRepresentation.sass:
            return "sass"
        if self is ExecutableRepresentation.ptx:
            return "ptx"
        if self is ExecutableRepresentation.nvvm:
            return "nvvm"
        if self is ExecutableRepresentation.ltoir:
            return "ltoir"
        if self is ExecutableRepresentation.mlir:
            return "mlir"
        if self is ExecutableRepresentation.llvm:
            return "llvm"
        if self is ExecutableRepresentation.hostobj:
            return "hostobj"
        raise ValueError("Unknown ExecutableRepresentation enum entry.")



@register_attribute_builder("CudaExecutableRepresentationEnum")
def _cudaexecutablerepresentationenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class GpuArchitecture(IntEnum):
    """Enumerated type denoting a GPU Architecture"""

    sm_80 = 80
    sm_86 = 86
    sm_87 = 87
    sm_89 = 89
    sm_90 = 90
    sm_100 = 100
    sm_103 = 103
    sm_101 = 101
    sm_120 = 120
    sm_121 = 121

    def __str__(self):
        if self is GpuArchitecture.sm_80:
            return "sm_80"
        if self is GpuArchitecture.sm_86:
            return "sm_86"
        if self is GpuArchitecture.sm_87:
            return "sm_87"
        if self is GpuArchitecture.sm_89:
            return "sm_89"
        if self is GpuArchitecture.sm_90:
            return "sm_90"
        if self is GpuArchitecture.sm_100:
            return "sm_100"
        if self is GpuArchitecture.sm_103:
            return "sm_103"
        if self is GpuArchitecture.sm_101:
            return "sm_101"
        if self is GpuArchitecture.sm_120:
            return "sm_120"
        if self is GpuArchitecture.sm_121:
            return "sm_121"
        raise ValueError("Unknown GpuArchitecture enum entry.")



@register_attribute_builder("CudaGpuArchitectureEnum")
def _cudagpuarchitectureenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaLaunchAttributeID(IntEnum):
    """Enumerated type mirroring CudaLaunchAttributeID from CUDA Runtime API"""

    cudaLaunchAttributeIgnore = 0
    cudaLaunchAttributeAccessPolicyWindow = 1
    cudaLaunchAttributeCooperative = 2
    cudaLaunchAttributeSynchronizationPolicy = 3
    cudaLaunchAttributeClusterDimension = 4
    cudaLaunchAttributeClusterSchedulingPolicyPreference = 5
    cudaLaunchAttributeProgrammaticStreamSerialization = 6
    cudaLaunchAttributeProgrammaticEvent = 7
    cudaLaunchAttributePriority = 8
    cudaLaunchAttributeMemSyncDomainMap = 9
    cudaLaunchAttributeMemSyncDomain = 10
    cudaLaunchAttributePreferredClusterDimension = 11
    cudaLaunchAttributeLaunchCompletionEvent = 12
    cudaLaunchAttributeDeviceUpdatableKernelNode = 13
    cudaLaunchAttributePreferredSharedMemoryCarveout = 14
    cudaLaunchAttributeNvlinkUtilCentricScheduling = 16

    def __str__(self):
        if self is CudaLaunchAttributeID.cudaLaunchAttributeIgnore:
            return "cudaLaunchAttributeIgnore"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeAccessPolicyWindow:
            return "cudaLaunchAttributeAccessPolicyWindow"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeCooperative:
            return "cudaLaunchAttributeCooperative"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeSynchronizationPolicy:
            return "cudaLaunchAttributeSynchronizationPolicy"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeClusterDimension:
            return "cudaLaunchAttributeClusterDimension"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeClusterSchedulingPolicyPreference:
            return "cudaLaunchAttributeClusterSchedulingPolicyPreference"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeProgrammaticStreamSerialization:
            return "cudaLaunchAttributeProgrammaticStreamSerialization"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeProgrammaticEvent:
            return "cudaLaunchAttributeProgrammaticEvent"
        if self is CudaLaunchAttributeID.cudaLaunchAttributePriority:
            return "cudaLaunchAttributePriority"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomainMap:
            return "cudaLaunchAttributeMemSyncDomainMap"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomain:
            return "cudaLaunchAttributeMemSyncDomain"
        if self is CudaLaunchAttributeID.cudaLaunchAttributePreferredClusterDimension:
            return "cudaLaunchAttributePreferredClusterDimension"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeLaunchCompletionEvent:
            return "cudaLaunchAttributeLaunchCompletionEvent"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeDeviceUpdatableKernelNode:
            return "cudaLaunchAttributeDeviceUpdatableKernelNode"
        if self is CudaLaunchAttributeID.cudaLaunchAttributePreferredSharedMemoryCarveout:
            return "cudaLaunchAttributePreferredSharedMemoryCarveout"
        if self is CudaLaunchAttributeID.cudaLaunchAttributeNvlinkUtilCentricScheduling:
            return "cudaLaunchAttributeNvlinkUtilCentricScheduling"
        raise ValueError("Unknown CudaLaunchAttributeID enum entry.")



@register_attribute_builder("CudaLaunchAttributeID")
def _cudalaunchattributeid(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaLaunchMemSyncDomain(IntEnum):
    """Enumerated type describing CUDA memory sync domain"""

    cudaLaunchMemSyncDomainDefault = 0
    cudaLaunchMemSyncDomainRemote = 1

    def __str__(self):
        if self is CudaLaunchMemSyncDomain.cudaLaunchMemSyncDomainDefault:
            return "cudaLaunchMemSyncDomainDefault"
        if self is CudaLaunchMemSyncDomain.cudaLaunchMemSyncDomainRemote:
            return "cudaLaunchMemSyncDomainRemote"
        raise ValueError("Unknown CudaLaunchMemSyncDomain enum entry.")



@register_attribute_builder("CudaLaunchMemSyncDomain")
def _cudalaunchmemsyncdomain(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class MemcpyKind(IntEnum):
    """Enumerated type describing memcpy directions"""

    HostToHost = 0
    HostToDevice = 1
    DeviceToHost = 2
    DeviceToDevice = 3
    Default = 4

    def __str__(self):
        if self is MemcpyKind.HostToHost:
            return "HostToHost"
        if self is MemcpyKind.HostToDevice:
            return "HostToDevice"
        if self is MemcpyKind.DeviceToHost:
            return "DeviceToHost"
        if self is MemcpyKind.DeviceToDevice:
            return "DeviceToDevice"
        if self is MemcpyKind.Default:
            return "Default"
        raise ValueError("Unknown MemcpyKind enum entry.")



@register_attribute_builder("CudaMemcpyKindEnum")
def _cudamemcpykindenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class StreamCaptureModeEnum(IntEnum):
    """Enumerated type describing CUDA stream capture modes"""

    Global = 0
    ThreadLocal = 1
    Relaxed = 2

    def __str__(self):
        if self is StreamCaptureModeEnum.Global:
            return "Global"
        if self is StreamCaptureModeEnum.ThreadLocal:
            return "ThreadLocal"
        if self is StreamCaptureModeEnum.Relaxed:
            return "Relaxed"
        raise ValueError("Unknown StreamCaptureModeEnum enum entry.")



@register_attribute_builder("CudaStreamCaptureModeEnum")
def _cudastreamcapturemodeenum(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class CudaSynchronizationPolicy(IntEnum):
    """Enumerated type describing CUDA synchronization policy"""

    cudaSyncPolicyAuto = 0
    cudaSyncPolicySpin = 1
    cudaSyncPolicyYield = 2
    cudaSyncPolicyBlockingSync = 3

    def __str__(self):
        if self is CudaSynchronizationPolicy.cudaSyncPolicyAuto:
            return "cudaSyncPolicyAuto"
        if self is CudaSynchronizationPolicy.cudaSyncPolicySpin:
            return "cudaSyncPolicySpin"
        if self is CudaSynchronizationPolicy.cudaSyncPolicyYield:
            return "cudaSyncPolicyYield"
        if self is CudaSynchronizationPolicy.cudaSyncPolicyBlockingSync:
            return "cudaSyncPolicyBlockingSync"
        raise ValueError("Unknown CudaSynchronizationPolicy enum entry.")



@register_attribute_builder("CudaSynchronizationPolicy")
def _cudasynchronizationpolicy(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

