
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "cute"

@_ods_cext.register_operation(_Dialect)
class AddOffsetOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.add_offset"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(offset))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def add_offset(src, offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return AddOffsetOp(src=src, offset=offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AlgorithmCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, copy_atom, src, dst, *, pred=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(copy_atom))
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(dst))
    if pred is not None: operands.append(_get_op_result_or_value(pred))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def copy_atom(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def dst(self):
    return self.operation.operands[2]

  @builtins.property
  def pred(self):
    return None if len(self.operation.operands) < 4 else self.operation.operands[3]

def copy(copy_atom, src, dst, *, pred=None, loc=None, ip=None) -> _ods_ir.Operation:
  return AlgorithmCopyOp(copy_atom=copy_atom, src=src, dst=dst, pred=pred, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AlgorithmGemmOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.gemm"

  _ODS_REGIONS = (0, True)

  def __init__(self, mma_atom, d, a, b, c, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(mma_atom))
    operands.append(_get_op_result_or_value(d))
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(c))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def mma_atom(self):
    return self.operation.operands[0]

  @builtins.property
  def d(self):
    return self.operation.operands[1]

  @builtins.property
  def a(self):
    return self.operation.operands[2]

  @builtins.property
  def b(self):
    return self.operation.operands[3]

  @builtins.property
  def c(self):
    return self.operation.operands[4]

def gemm(mma_atom, d, a, b, c, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AlgorithmGemmOp(mma_atom=mma_atom, d=d, a=a, b=b, c=c, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AlgorithmPrefetchOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.prefetch"

  _ODS_REGIONS = (0, True)

  def __init__(self, prefetch_atom, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(prefetch_atom))
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def prefetch_atom(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

def prefetch(prefetch_atom, src, *, loc=None, ip=None) -> _ods_ir.Operation:
  return AlgorithmPrefetchOp(prefetch_atom=prefetch_atom, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AppendToRankOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.append_to_rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, rank, input, element, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(element))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rank"] = (rank if (
    isinstance(rank, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(rank, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def element(self):
    return self.operation.operands[1]

  @builtins.property
  def rank(self):
    return self.operation.attributes["rank"]

  @rank.setter
  def rank(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rank"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def append_to_rank(rank, input, element, *, loc=None, ip=None) -> _ods_ir.Value:
  return AppendToRankOp(rank=rank, input=input, element=element, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ApplySwizzleOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.apply_swizzle"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def swizzled_ptr(self):
    return self.operation.results[0]

def apply_swizzle(ptr, *, loc=None, ip=None) -> _ods_ir.Value:
  return ApplySwizzleOp(ptr=ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssumeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.assume"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def assume(dst, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return AssumeOp(dst=dst, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BlockedProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.blocked_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def blocked_product(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return BlockedProductOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CeilDivOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.ceil_div"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ceil_div(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return CeilDivOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CoalesceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.coalesce"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, target_profile=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if target_profile is not None: operands.append(_get_op_result_or_value(target_profile))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def target_profile(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def coalesce(input, *, target_profile=None, loc=None, ip=None) -> _ods_ir.Value:
  return CoalesceOp(input=input, target_profile=target_profile, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComplementOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.complement"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, cotarget, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(cotarget))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def cotarget(self):
    return self.operation.operands[1]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def complement(input, cotarget, *, loc=None, ip=None) -> _ods_ir.Value:
  return ComplementOp(input=input, cotarget=cotarget, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComposedGetInnerOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.composed_get_inner"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def composed_get_inner(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ComposedGetInnerOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComposedGetOffsetOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.composed_get_offset"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def composed_get_offset(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ComposedGetOffsetOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComposedGetOuterOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.composed_get_outer"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def composed_get_outer(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ComposedGetOuterOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositionOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.composition"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def composition(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CompositionOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyAtomCallOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.copy_atom_call"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, src, dst, *, pred=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(dst))
    if pred is not None: operands.append(_get_op_result_or_value(pred))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def dst(self):
    return self.operation.operands[2]

  @builtins.property
  def pred(self):
    return None if len(self.operation.operands) < 4 else self.operation.operands[3]

def copy_atom_call(atom, src, dst, *, pred=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CopyAtomCallOp(atom=atom, src=src, dst=dst, pred=pred, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CosizeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.cosize"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cosize(input, *, mode=None, loc=None, ip=None) -> _ods_ir.Value:
  return CosizeOp(input=input, mode=mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Crd2IdxOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.crd2idx"

  _ODS_REGIONS = (0, True)

  def __init__(self, coord, layout, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(coord))
    operands.append(_get_op_result_or_value(layout))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def coord(self):
    return self.operation.operands[0]

  @builtins.property
  def layout(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.results[0]

def crd2idx(coord, layout, *, loc=None, ip=None) -> _ods_ir.Value:
  return Crd2IdxOp(coord=coord, layout=layout, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DereferenceArithTupleIteratorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.deref_arith_tuple_iter"

  _ODS_REGIONS = (0, True)

  def __init__(self, iter, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(iter))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def iter(self):
    return self.operation.operands[0]

  @builtins.property
  def arith_tuple(self):
    return self.operation.results[0]

def deref_arith_tuple_iter(iter, *, loc=None, ip=None) -> _ods_ir.Value:
  return DereferenceArithTupleIteratorOp(iter=iter, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DereferenceDescriptorIteratorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.deref_desc_iter"

  _ODS_REGIONS = (0, True)

  def __init__(self, iter, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(iter))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def iter(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def deref_desc_iter(iter, *, loc=None, ip=None) -> _ods_ir.Value:
  return DereferenceDescriptorIteratorOp(iter=iter, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DerefineOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.derefine"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def derefine(dst, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return DerefineOp(dst=dst, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DiceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.dice"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, coord, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["coord"] = (coord if (
    isinstance(coord, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StaticCoordAttr')) else
      _ods_ir.AttrBuilder.get('StaticCoordAttr')(coord, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def coord(self):
    return self.operation.attributes["coord"]

  @coord.setter
  def coord(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coord"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dice(input, coord, *, loc=None, ip=None) -> _ods_ir.Value:
  return DiceOp(input=input, coord=coord, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ElemLessOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.elem_less"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def elem_less(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return ElemLessOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqualOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def equal(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return EqualOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FastDivmodComputeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.fast_divmod.compute"

  _ODS_REGIONS = (0, True)

  def __init__(self, quotient, remainder, dividend, divisor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dividend))
    operands.append(_get_op_result_or_value(divisor))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(quotient)
    results.append(remainder)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dividend(self):
    return self.operation.operands[0]

  @builtins.property
  def divisor(self):
    return self.operation.operands[1]

  @builtins.property
  def quotient(self):
    return self.operation.results[0]

  @builtins.property
  def remainder(self):
    return self.operation.results[1]

def fast_divmod_compute(quotient, remainder, dividend, divisor, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return FastDivmodComputeOp(quotient=quotient, remainder=remainder, dividend=dividend, divisor=divisor, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class FastDivmodCreateDivisorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.fast_divmod.create_divisor"

  _ODS_REGIONS = (0, True)

  def __init__(self, fast_divmod_divisor, divisor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(divisor))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(fast_divmod_divisor)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def divisor(self):
    return self.operation.operands[0]

  @builtins.property
  def fast_divmod_divisor(self):
    return self.operation.results[0]

def fast_divmod_create_divisor(fast_divmod_divisor, divisor, *, loc=None, ip=None) -> _ods_ir.Value:
  return FastDivmodCreateDivisorOp(fast_divmod_divisor=fast_divmod_divisor, divisor=divisor, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FastDivmodDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.fast_divmod.divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, quotient, dividend, divisor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dividend))
    operands.append(_get_op_result_or_value(divisor))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(quotient)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dividend(self):
    return self.operation.operands[0]

  @builtins.property
  def divisor(self):
    return self.operation.operands[1]

  @builtins.property
  def quotient(self):
    return self.operation.results[0]

def fast_divmod_divide(quotient, dividend, divisor, *, loc=None, ip=None) -> _ods_ir.Value:
  return FastDivmodDivideOp(quotient=quotient, dividend=dividend, divisor=divisor, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FastDivmodGetAuxOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.fast_divmod.get_aux"

  _ODS_REGIONS = (0, True)

  def __init__(self, divisor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(divisor))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def divisor(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.results[0]

  @builtins.property
  def shift1(self):
    return self.operation.results[1]

  @builtins.property
  def shift2(self):
    return self.operation.results[2]

def fast_divmod_get_aux(divisor, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return FastDivmodGetAuxOp(divisor=divisor, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class FastDivmodGetDivisorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.fast_divmod.get_divisor"

  _ODS_REGIONS = (0, True)

  def __init__(self, fast_divmod_divisor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(fast_divmod_divisor))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def fast_divmod_divisor(self):
    return self.operation.operands[0]

  @builtins.property
  def divisor(self):
    return self.operation.results[0]

def fast_divmod_get_divisor(fast_divmod_divisor, *, loc=None, ip=None) -> _ods_ir.Value:
  return FastDivmodGetDivisorOp(fast_divmod_divisor=fast_divmod_divisor, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FastDivmodMakeDivisorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.fast_divmod.make_divisor"

  _ODS_REGIONS = (0, True)

  def __init__(self, fast_divmod_divisor, divisor, multiplier, sh1, sh2, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(divisor))
    operands.append(_get_op_result_or_value(multiplier))
    operands.append(_get_op_result_or_value(sh1))
    operands.append(_get_op_result_or_value(sh2))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(fast_divmod_divisor)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def divisor(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.operands[1]

  @builtins.property
  def sh1(self):
    return self.operation.operands[2]

  @builtins.property
  def sh2(self):
    return self.operation.operands[3]

  @builtins.property
  def fast_divmod_divisor(self):
    return self.operation.results[0]

def fast_divmod_make_divisor(fast_divmod_divisor, divisor, multiplier, sh1, sh2, *, loc=None, ip=None) -> _ods_ir.Value:
  return FastDivmodMakeDivisorOp(fast_divmod_divisor=fast_divmod_divisor, divisor=divisor, multiplier=multiplier, sh1=sh1, sh2=sh2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FilterOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.filter"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def filter(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return FilterOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FilterZerosOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.filter_zeros"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, target_profile=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if target_profile is not None: operands.append(_get_op_result_or_value(target_profile))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def target_profile(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def filter_zeros(input, *, target_profile=None, loc=None, ip=None) -> _ods_ir.Value:
  return FilterZerosOp(input=input, target_profile=target_profile, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FlatDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.flat_divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def flat_divide(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return FlatDivideOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FlatProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.flat_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def flat_product(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return FlatProductOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetFlatCoordOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_flat_coord"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(index))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_flat_coord(index, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetFlatCoordOp(index=index, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetHierCoordOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_hier_coord"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(index))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_hier_coord(index, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetHierCoordOp(index=index, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetIntegralCoordOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_integral_coord"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(index))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_integral_coord(index, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetIntegralCoordOp(index=index, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetIterOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_iter"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr(self):
    return self.operation.results[0]

def get_iter(source, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetIterOp(source=source, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def layout(self):
    return self.operation.results[0]

def get_layout(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetLayoutOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetLayoutsFromTileOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_layouts_from_tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, tile, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tile))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tile(self):
    return self.operation.operands[0]

  @builtins.property
  def layouts(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def get_layouts_from_tile(tile, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GetLayoutsFromTileOp(tile=tile, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GetLeavesOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_leaves"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def get_leaves(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GetLeavesOp(input=input, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GetOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(mode, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    if "mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is not None:
      self.operation.attributes["mode"] = value
    elif "mode" in self.operation.attributes:
      del self.operation.attributes["mode"]

  @mode.deleter
  def mode(self):
    del self.operation.attributes["mode"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get(result, input, *, mode=None, loc=None, ip=None) -> _ods_ir.Value:
  return GetOp(result=result, input=input, mode=mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetScalarsOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_scalars"

  _ODS_REGIONS = (0, True)

  def __init__(self, cute_value, *, only_dynamic=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cute_value))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(only_dynamic): attributes["only_dynamic"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cute_value(self):
    return self.operation.operands[0]

  @builtins.property
  def only_dynamic(self):
    return "only_dynamic" in self.operation.attributes

  @only_dynamic.setter
  def only_dynamic(self, value):
    if bool(value):
      self.operation.attributes["only_dynamic"] = _ods_ir.UnitAttr.get()
    elif "only_dynamic" in self.operation.attributes:
      del self.operation.attributes["only_dynamic"]

  @only_dynamic.deleter
  def only_dynamic(self):
    del self.operation.attributes["only_dynamic"]

  @builtins.property
  def scalars(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def get_scalars(cute_value, *, only_dynamic=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(GetScalarsOp(cute_value=cute_value, only_dynamic=only_dynamic, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class GetShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_shape(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetShapeOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetStrideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.get_stride"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_stride(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetStrideOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupModesOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.group_modes"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, begin, end, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["begin"] = (begin if (
    isinstance(begin, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(begin, context=_ods_context))
    attributes["end"] = (end if (
    isinstance(end, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(end, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def begin(self):
    return self.operation.attributes["begin"]

  @begin.setter
  def begin(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin"] = value

  @builtins.property
  def end(self):
    return self.operation.attributes["end"]

  @end.setter
  def end(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def group_modes(input, begin, end, *, loc=None, ip=None) -> _ods_ir.Value:
  return GroupModesOp(input=input, begin=begin, end=end, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Idx2CrdOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.idx2crd"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(index))
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.operands[1]

  @builtins.property
  def coord(self):
    return self.operation.results[0]

def idx2crd(index, shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return Idx2CrdOp(index=index, shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntToPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.inttoptr"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def inttoptr(dst, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return IntToPtrOp(dst=dst, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LeftInverseOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.left_inverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def left_inverse(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return LeftInverseOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoadScaledIndexOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.load_scaled_index"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr_a, ptr_b, index, stride, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr_a))
    operands.append(_get_op_result_or_value(ptr_b))
    operands.append(_get_op_result_or_value(index))
    operands.append(_get_op_result_or_value(stride))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr_a(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr_b(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def stride(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def load_scaled_index(ptr_a, ptr_b, index, stride, *, loc=None, ip=None) -> _ods_ir.Value:
  return LoadScaledIndexOp(ptr_a=ptr_a, ptr_b=ptr_b, index=index, stride=stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LocalPartitionOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.local_partition"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    operands.append(_get_op_result_or_value(index))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def index(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def local_partition(input, tiler, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return LocalPartitionOp(input=input, tiler=tiler, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LocalTileOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.local_tile"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, tile=None, static_tile=None, coord=None, static_coord=None, proj=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tile) if tile is not None else None)
    operands.append(_get_op_result_or_value(coord) if coord is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if static_tile is not None: attributes["static_tile"] = (static_tile if (
        isinstance(static_tile, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTileAttr')) else
          _ods_ir.AttrBuilder.get('CuteTileAttr')(static_tile, context=_ods_context))
    if static_coord is not None: attributes["static_coord"] = (static_coord if (
        isinstance(static_coord, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteCoordAttr')) else
          _ods_ir.AttrBuilder.get('CuteCoordAttr')(static_coord, context=_ods_context))
    if proj is not None: attributes["proj"] = (proj if (
        isinstance(proj, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteCoordAttr')) else
          _ods_ir.AttrBuilder.get('CuteCoordAttr')(proj, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def tile(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def coord(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def static_tile(self):
    if "static_tile" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_tile"]

  @static_tile.setter
  def static_tile(self, value):
    if value is not None:
      self.operation.attributes["static_tile"] = value
    elif "static_tile" in self.operation.attributes:
      del self.operation.attributes["static_tile"]

  @static_tile.deleter
  def static_tile(self):
    del self.operation.attributes["static_tile"]

  @builtins.property
  def static_coord(self):
    if "static_coord" not in self.operation.attributes:
      return None
    return self.operation.attributes["static_coord"]

  @static_coord.setter
  def static_coord(self, value):
    if value is not None:
      self.operation.attributes["static_coord"] = value
    elif "static_coord" in self.operation.attributes:
      del self.operation.attributes["static_coord"]

  @static_coord.deleter
  def static_coord(self):
    del self.operation.attributes["static_coord"]

  @builtins.property
  def proj(self):
    if "proj" not in self.operation.attributes:
      return None
    return self.operation.attributes["proj"]

  @proj.setter
  def proj(self, value):
    if value is not None:
      self.operation.attributes["proj"] = value
    elif "proj" in self.operation.attributes:
      del self.operation.attributes["proj"]

  @proj.deleter
  def proj(self):
    del self.operation.attributes["proj"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def local_tile(input, *, tile=None, static_tile=None, coord=None, static_coord=None, proj=None, loc=None, ip=None) -> _ods_ir.Value:
  return LocalTileOp(input=input, tile=tile, static_tile=static_tile, coord=coord, static_coord=static_coord, proj=proj, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.logical_divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def logical_divide(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalDivideOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.logical_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def logical_product(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return LogicalProductOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeArithTupleIteratorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_arith_tuple_iter"

  _ODS_REGIONS = (0, True)

  def __init__(self, iter, *, value=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if value is not None: operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(iter)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def iter(self):
    return self.operation.results[0]

def make_arith_tuple_iter(iter, *, value=None, loc=None, ip=None) -> _ods_ir.Value:
  return MakeArithTupleIteratorOp(iter=iter, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeAtomOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_atom"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(atom)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def atom(self):
    return self.operation.results[0]

def make_atom(atom, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeAtomOp(atom=atom, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeComposedLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_composed_layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, inner, offset, outer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(inner))
    operands.append(_get_op_result_or_value(offset))
    operands.append(_get_op_result_or_value(outer))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inner(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def outer(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_composed_layout(inner, offset, outer, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeComposedLayoutOp(inner=inner, offset=offset, outer=outer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeCoordOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_coord"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, dynamicElements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dynamicElements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dynamicElements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_coord(result, dynamic_elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeCoordOp(result=result, dynamicElements=dynamic_elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeDescriptorIteratorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_desc_iter"

  _ODS_REGIONS = (0, True)

  def __init__(self, iter, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(iter)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def iter(self):
    return self.operation.results[0]

def make_desc_iter(iter, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeDescriptorIteratorOp(iter=iter, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeFragmentLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_fragment_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def make_fragment_like(src, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeFragmentLikeOp(src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeIdentityLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_identity_layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_identity_layout(shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeIdentityLayoutOp(shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeIdentityTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_identity_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_identity_tensor(shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeIdentityTensorOp(shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeIntTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_int_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, dynamicElements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dynamicElements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dynamicElements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_int_tuple(result, dynamic_elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeIntTupleOp(result=result, dynamicElements=dynamic_elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeLayoutLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_layout_like"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def make_layout_like(src, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeLayoutLikeOp(src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_layout"

  _ODS_OPERAND_SEGMENTS = [0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, layout, *, shape=None, stride=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(shape) if shape is not None else None)
    operands.append(_get_op_result_or_value(stride) if stride is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(layout)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def shape(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def stride(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def layout(self):
    return self.operation.results[0]

def make_layout(layout, *, shape=None, stride=None, loc=None, ip=None) -> _ods_ir.Value:
  return MakeLayoutOp(layout=layout, shape=shape, stride=stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeOrderedLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_ordered_layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, shape, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(shape))
    operands.append(_get_op_result_or_value(order))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def shape(self):
    return self.operation.operands[0]

  @builtins.property
  def order(self):
    return self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.results[0]

def make_ordered_layout(shape, order, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeOrderedLayoutOp(shape=shape, order=order, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, dynamicElements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dynamicElements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dynamicElements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_shape(result, dynamic_elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeShapeOp(result=result, dynamicElements=dynamic_elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeSparseElemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_sparse_elem"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, physical_storage, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(physical_storage))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def physical_storage(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_sparse_elem(result, physical_storage, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeSparseElemOp(result=result, physical_storage=physical_storage, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeStrideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_stride"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, dynamicElements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dynamicElements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dynamicElements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_stride(result, dynamic_elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeStrideOp(result=result, dynamicElements=dynamic_elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTileOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, dynamicElements, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dynamicElements))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dynamicElements(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tile(result, dynamic_elements, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTileOp(result=result, dynamicElements=dynamic_elements, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTiledCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_tiled_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, atom, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tiled_copy(result, atom, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTiledCopyOp(result=result, atom=atom, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTiledMmaOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_tiled_mma"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, atom, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tiled_mma(result, atom, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTiledMmaOp(result=result, atom=atom, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTiledMmaV2Op(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_tiled_mma_v2"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, atom, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tiled_mma_v2(result, atom, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTiledMmaV2Op(result=result, atom=atom, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tuple(result, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTupleOp(result=result, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeViewOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.make_view"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, iter, *, layout=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(iter))
    if layout is not None: operands.append(_get_op_result_or_value(layout))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def iter(self):
    return self.operation.operands[0]

  @builtins.property
  def layout(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_view(result, iter, *, layout=None, loc=None, ip=None) -> _ods_ir.Value:
  return MakeViewOp(result=result, iter=iter, layout=layout, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefAllocSmemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.memref.alloc_smem"

  _ODS_REGIONS = (0, True)

  def __init__(self, memref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(memref)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def memref(self):
    return self.operation.results[0]

def memref_alloc_smem(memref, *, loc=None, ip=None) -> _ods_ir.Value:
  return MemRefAllocSmemOp(memref=memref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefAllocaOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.memref.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, layout=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if layout is not None: operands.append(_get_op_result_or_value(layout))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def layout(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def memref_alloca(result, *, layout=None, loc=None, ip=None) -> _ods_ir.Value:
  return MemRefAllocaOp(result=result, layout=layout, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.memref.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, coord, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(coord))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def coord(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def memref_load(src, coord, *, loc=None, ip=None) -> _ods_ir.Value:
  return MemRefLoadOp(src=src, coord=coord, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefLoadVecOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.memref.load_vec"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, *, row_major=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(row_major): attributes["row_major"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def row_major(self):
    return "row_major" in self.operation.attributes

  @row_major.setter
  def row_major(self, value):
    if bool(value):
      self.operation.attributes["row_major"] = _ods_ir.UnitAttr.get()
    elif "row_major" in self.operation.attributes:
      del self.operation.attributes["row_major"]

  @row_major.deleter
  def row_major(self):
    del self.operation.attributes["row_major"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def memref_load_vec(src, *, row_major=None, loc=None, ip=None) -> _ods_ir.Value:
  return MemRefLoadVecOp(src=src, row_major=row_major, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.memref.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, coord, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dst))
    operands.append(_get_op_result_or_value(coord))
    operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dst(self):
    return self.operation.operands[0]

  @builtins.property
  def coord(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

def memref_store(dst, coord, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MemRefStoreOp(dst=dst, coord=coord, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MemRefStoreVecOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.memref.store_vec"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, dst, *, row_major=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(dst))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(row_major): attributes["row_major"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.operands[1]

  @builtins.property
  def row_major(self):
    return "row_major" in self.operation.attributes

  @row_major.setter
  def row_major(self, value):
    if bool(value):
      self.operation.attributes["row_major"] = _ods_ir.UnitAttr.get()
    elif "row_major" in self.operation.attributes:
      del self.operation.attributes["row_major"]

  @row_major.deleter
  def row_major(self):
    del self.operation.attributes["row_major"]

def memref_store_vec(value, dst, *, row_major=None, loc=None, ip=None) -> _ods_ir.Operation:
  return MemRefStoreVecOp(value=value, dst=dst, row_major=row_major, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MmaAtomCallOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.mma_atom_call"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, d, a, b, c, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(d))
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(c))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def d(self):
    return self.operation.operands[1]

  @builtins.property
  def a(self):
    return self.operation.operands[2]

  @builtins.property
  def b(self):
    return self.operation.operands[3]

  @builtins.property
  def c(self):
    return self.operation.operands[4]

def mma_atom_call(atom, d, a, b, c, *, loc=None, ip=None) -> _ods_ir.Operation:
  return MmaAtomCallOp(atom=atom, d=d, a=a, b=b, c=c, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MmaMakeFragmentOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.mma.make_fragment"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_id, atom, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operand_id"] = (operand_id if (
    isinstance(operand_id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMmaOperandEnum')) else
      _ods_ir.AttrBuilder.get('CuteMmaOperandEnum')(operand_id, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def operand_id(self):
    return self.operation.attributes["operand_id"]

  @operand_id.setter
  def operand_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_id"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def mma_make_fragment(operand_id, atom, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return MmaMakeFragmentOp(operand_id=operand_id, atom=atom, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrefetchAtomCallOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.prefetch_atom_call"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

def prefetch_atom_call(atom, src, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrefetchAtomCallOp(atom=atom, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrependToRankOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.prepend_to_rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, rank, input, element, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(element))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rank"] = (rank if (
    isinstance(rank, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(rank, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def element(self):
    return self.operation.operands[1]

  @builtins.property
  def rank(self):
    return self.operation.attributes["rank"]

  @rank.setter
  def rank(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rank"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def prepend_to_rank(rank, input, element, *, loc=None, ip=None) -> _ods_ir.Value:
  return PrependToRankOp(rank=rank, input=input, element=element, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, *, fmt=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    if fmt is not None: attributes["fmt"] = (fmt if (
        isinstance(fmt, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(fmt, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def fmt(self):
    if "fmt" not in self.operation.attributes:
      return None
    return self.operation.attributes["fmt"]

  @fmt.setter
  def fmt(self, value):
    if value is not None:
      self.operation.attributes["fmt"] = value
    elif "fmt" in self.operation.attributes:
      del self.operation.attributes["fmt"]

  @fmt.deleter
  def fmt(self):
    del self.operation.attributes["fmt"]

def print_(values, *, fmt=None, loc=None, ip=None) -> _ods_ir.Operation:
  return PrintOp(values=values, fmt=fmt, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrintTMADescIm2ColOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.print_tma_desc_im2col"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, fd, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(fd))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def fd(self):
    return self.operation.operands[1]

def print_tma_desc_im2col(input, fd, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrintTMADescIm2ColOp(input=input, fd=fd, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrintTMADescTiledOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.print_tma_desc_tiled"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, fd, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(fd))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def fd(self):
    return self.operation.operands[1]

def print_tma_desc_tiled(input, fd, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrintTMADescTiledOp(input=input, fd=fd, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PrintViewOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.print_view"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, *, coord=None, verbose=None, is_signed=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    if coord is not None: operands.append(_get_op_result_or_value(coord))
    _ods_context = _ods_get_default_loc_context(loc)
    if verbose is not None: attributes["verbose"] = (verbose if (
        isinstance(verbose, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(verbose, context=_ods_context))
    if is_signed is not None: attributes["is_signed"] = (is_signed if (
        isinstance(is_signed, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_signed, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def coord(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def verbose(self):
    return self.operation.attributes["verbose"]

  @verbose.setter
  def verbose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbose"] = value

  @builtins.property
  def is_signed(self):
    return self.operation.attributes["is_signed"]

  @is_signed.setter
  def is_signed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_signed"] = value

def print_view(src, *, coord=None, verbose=None, is_signed=None, loc=None, ip=None) -> _ods_ir.Operation:
  return PrintViewOp(src=src, coord=coord, verbose=verbose, is_signed=is_signed, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PtrLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.ptr.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.results[0]

def ptr_load(ptr, *, loc=None, ip=None) -> _ods_ir.Value:
  return PtrLoadOp(ptr=ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PtrStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.ptr.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr(self):
    return self.operation.operands[1]

def ptr_store(value, ptr, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PtrStoreOp(value=value, ptr=ptr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PtrToIntOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.ptrtoint"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def ptrtoint(dst, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return PtrToIntOp(dst=dst, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RakedProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.raked_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def raked_product(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return RakedProductOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RecastIterOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.recast_iter"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def recast_iter(dst, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return RecastIterOp(dst=dst, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RecastLayoutOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.recast_layout"

  _ODS_REGIONS = (0, True)

  def __init__(self, new_type_bits, old_type_bits, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["new_type_bits"] = (new_type_bits if (
    isinstance(new_type_bits, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(new_type_bits, context=_ods_context))
    attributes["old_type_bits"] = (old_type_bits if (
    isinstance(old_type_bits, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(old_type_bits, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def new_type_bits(self):
    return self.operation.attributes["new_type_bits"]

  @new_type_bits.setter
  def new_type_bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["new_type_bits"] = value

  @builtins.property
  def old_type_bits(self):
    return self.operation.attributes["old_type_bits"]

  @old_type_bits.setter
  def old_type_bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["old_type_bits"] = value

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def recast_layout(new_type_bits, old_type_bits, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return RecastLayoutOp(new_type_bits=new_type_bits, old_type_bits=old_type_bits, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, shape, init_val, reduction_op, *, predication=None, reduction_profile=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(shape))
    operands.append(_get_op_result_or_value(init_val))
    if predication is not None: operands.append(_get_op_result_or_value(predication))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reduction_op"] = (reduction_op if (
    isinstance(reduction_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteReductionOpAttr')) else
      _ods_ir.AttrBuilder.get('CuteReductionOpAttr')(reduction_op, context=_ods_context))
    if reduction_profile is not None: attributes["reduction_profile"] = (reduction_profile if (
        isinstance(reduction_profile, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteCoordAttr')) else
          _ods_ir.AttrBuilder.get('CuteCoordAttr')(reduction_profile, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.operands[1]

  @builtins.property
  def init_val(self):
    return self.operation.operands[2]

  @builtins.property
  def predication(self):
    return None if len(self.operation.operands) < 4 else self.operation.operands[3]

  @builtins.property
  def reduction_op(self):
    return self.operation.attributes["reduction_op"]

  @reduction_op.setter
  def reduction_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction_op"] = value

  @builtins.property
  def reduction_profile(self):
    if "reduction_profile" not in self.operation.attributes:
      return None
    return self.operation.attributes["reduction_profile"]

  @reduction_profile.setter
  def reduction_profile(self, value):
    if value is not None:
      self.operation.attributes["reduction_profile"] = value
    elif "reduction_profile" in self.operation.attributes:
      del self.operation.attributes["reduction_profile"]

  @reduction_profile.deleter
  def reduction_profile(self):
    del self.operation.attributes["reduction_profile"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def reduced_shape(self):
    return None if len(self.operation.results) < 2 else self.operation.results[1]

def reduce(input, shape, init_val, reduction_op, *, predication=None, reduction_profile=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ReduceOp(input=input, shape=shape, init_val=init_val, reduction_op=reduction_op, predication=predication, reduction_profile=reduction_profile, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RightInverseOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.right_inverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def right_inverse(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return RightInverseOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def select(input, mode, *, loc=None, ip=None) -> _ods_ir.Value:
  return SelectOp(input=input, mode=mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShapeDivOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.shape_div"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def shape_div(a, b, *, loc=None, ip=None) -> _ods_ir.Value:
  return ShapeDivOp(a=a, b=b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SizeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if mode is not None: attributes["mode"] = (mode if (
        isinstance(mode, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def size(input, *, mode=None, loc=None, ip=None) -> _ods_ir.Value:
  return SizeOp(input=input, mode=mode, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, coord, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(coord))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def coord(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def slice(input, coord, *, loc=None, ip=None) -> _ods_ir.Value:
  return SliceOp(input=input, coord=coord, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StaticOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.static"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def result(self):
    return self.operation.results[0]

def static(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return StaticOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StencilDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.stencil_divide"

  _ODS_OPERAND_SEGMENTS = [1,1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, input, stencil, *, padding_upper=None, padding_lower=None, traversal_stride=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(stencil))
    operands.append(_get_op_result_or_value(padding_upper) if padding_upper is not None else None)
    operands.append(_get_op_result_or_value(padding_lower) if padding_lower is not None else None)
    operands.append(_get_op_result_or_value(traversal_stride) if traversal_stride is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def stencil(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def padding_upper(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def padding_lower(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def traversal_stride(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def result(self):
    return self.operation.results[0]

def stencil_divide(input, stencil, *, padding_upper=None, padding_lower=None, traversal_stride=None, loc=None, ip=None) -> _ods_ir.Value:
  return StencilDivideOp(input=input, stencil=stencil, padding_upper=padding_upper, padding_lower=padding_lower, traversal_stride=traversal_stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SymbolicOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.symbolic"

  _ODS_REGIONS = (0, True)

  def __init__(self, symbolic, name, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results.append(symbolic)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def symbolic(self):
    return self.operation.results[0]

def symbolic(symbolic, name, *, loc=None, ip=None) -> _ods_ir.Value:
  return SymbolicOp(symbolic=symbolic, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TileToShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tile_to_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, block, trg_shape, ord_shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(block))
    operands.append(_get_op_result_or_value(trg_shape))
    operands.append(_get_op_result_or_value(ord_shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def block(self):
    return self.operation.operands[0]

  @builtins.property
  def trg_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def ord_shape(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tile_to_shape(block, trg_shape, ord_shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return TileToShapeOp(block=block, trg_shape=trg_shape, ord_shape=ord_shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledCopyPartitionDOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled.copy.partition_D"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_copy, input, coord, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tiled_copy))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(coord))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tiled_copy(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def coord(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_copy_partition_D(tiled_copy, input, coord, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledCopyPartitionDOp(tiled_copy=tiled_copy, input=input, coord=coord, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledCopyPartitionSOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled.copy.partition_S"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_copy, input, coord, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tiled_copy))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(coord))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tiled_copy(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def coord(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_copy_partition_S(tiled_copy, input, coord, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledCopyPartitionSOp(tiled_copy=tiled_copy, input=input, coord=coord, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledCopyRetileOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled.copy.retile"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_copy, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tiled_copy))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tiled_copy(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_copy_retile(tiled_copy, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledCopyRetileOp(tiled_copy=tiled_copy, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled_divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_divide(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledDivideOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledMmaPartitionOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled.mma.partition"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_id, tiled_mma, input, coord, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tiled_mma))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(coord))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operand_id"] = (operand_id if (
    isinstance(operand_id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMmaOperandEnum')) else
      _ods_ir.AttrBuilder.get('CuteMmaOperandEnum')(operand_id, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tiled_mma(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def coord(self):
    return self.operation.operands[2]

  @builtins.property
  def operand_id(self):
    return self.operation.attributes["operand_id"]

  @operand_id.setter
  def operand_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_id"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_mma_partition(operand_id, tiled_mma, input, coord, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledMmaPartitionOp(operand_id=operand_id, tiled_mma=tiled_mma, input=input, coord=coord, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledMmaPartitionShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled.mma.partition_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand_id, tiled_mma, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tiled_mma))
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["operand_id"] = (operand_id if (
    isinstance(operand_id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMmaOperandEnum')) else
      _ods_ir.AttrBuilder.get('CuteMmaOperandEnum')(operand_id, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tiled_mma(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def operand_id(self):
    return self.operation.attributes["operand_id"]

  @operand_id.setter
  def operand_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_id"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_mma_partition_shape(operand_id, tiled_mma, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledMmaPartitionShapeOp(operand_id=operand_id, tiled_mma=tiled_mma, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TiledProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tiled_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tiled_product(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return TiledProductOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ToIntTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.to_int_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def to_int_tuple(src, *, loc=None, ip=None) -> _ods_ir.Value:
  return ToIntTupleOp(src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleAddOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple_add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_add(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleAddOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleDivOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple_div"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_div(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleDivOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleModOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple_mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_mod(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleModOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleMulOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple_mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_mul(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleMulOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleProductEachOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple.product_each"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_product_each(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleProductEachOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple.product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_product(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleProductOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TupleSubOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.tuple_sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tuple_sub(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return TupleSubOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnpackTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.unpack_tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tuple, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tuple))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tuple(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def unpack_tuple(result, tuple, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(UnpackTupleOp(result=result, tuple=tuple, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ZippedDivideOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.zipped_divide"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def zipped_divide(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return ZippedDivideOp(input=input, tiler=tiler, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ZippedProductOp(_ods_ir.OpView):
  OPERATION_NAME = "cute.zipped_product"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, tiler, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(tiler))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tiler(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def zipped_product(input, tiler, *, loc=None, ip=None) -> _ods_ir.Value:
  return ZippedProductOp(input=input, tiler=tiler, loc=loc, ip=ip).result
