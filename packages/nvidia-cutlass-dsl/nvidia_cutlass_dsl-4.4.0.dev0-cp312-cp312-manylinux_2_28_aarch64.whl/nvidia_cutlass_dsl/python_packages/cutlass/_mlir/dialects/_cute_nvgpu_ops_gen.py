
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "cute_nvgpu"

@_ods_cext.register_operation(_Dialect)
class ArchAllocRmemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.alloc_rmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(ptr)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr(self):
    return self.operation.results[0]

def arch_alloc_rmem(ptr, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ArchAllocRmemOp(ptr=ptr, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchAllocSmemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.alloc_smem"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["input"] = (input if (
    isinstance(input, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(input, context=_ods_context))
    results.append(ptr)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.attributes["input"]

  @input.setter
  def input(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input"] = value

  @builtins.property
  def ptr(self):
    return self.operation.results[0]

def arch_alloc_smem(ptr, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return ArchAllocSmemOp(ptr=ptr, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchCopyLdsmOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.ldsm"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, matrix_shape, sz_pattern, num_matrices, *, transpose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matrix_shape"] = (matrix_shape if (
    isinstance(matrix_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(matrix_shape, context=_ods_context))
    attributes["sz_pattern"] = (sz_pattern if (
    isinstance(sz_pattern, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteLdsmSzPatternEnumAttr')) else
      _ods_ir.AttrBuilder.get('CuteLdsmSzPatternEnumAttr')(sz_pattern, context=_ods_context))
    attributes["num_matrices"] = (num_matrices if (
    isinstance(num_matrices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(num_matrices, context=_ods_context))
    if bool(transpose): attributes["transpose"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def matrix_shape(self):
    return self.operation.attributes["matrix_shape"]

  @matrix_shape.setter
  def matrix_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matrix_shape"] = value

  @builtins.property
  def sz_pattern(self):
    return self.operation.attributes["sz_pattern"]

  @sz_pattern.setter
  def sz_pattern(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sz_pattern"] = value

  @builtins.property
  def num_matrices(self):
    return self.operation.attributes["num_matrices"]

  @num_matrices.setter
  def num_matrices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_matrices"] = value

  @builtins.property
  def transpose(self):
    return "transpose" in self.operation.attributes

  @transpose.setter
  def transpose(self, value):
    if bool(value):
      self.operation.attributes["transpose"] = _ods_ir.UnitAttr.get()
    elif "transpose" in self.operation.attributes:
      del self.operation.attributes["transpose"]

  @transpose.deleter
  def transpose(self):
    del self.operation.attributes["transpose"]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def arch_copy_ldsm(dst, src, matrix_shape, sz_pattern, num_matrices, *, transpose=None, loc=None, ip=None) -> _ods_ir.Value:
  return ArchCopyLdsmOp(dst=dst, src=src, matrix_shape=matrix_shape, sz_pattern=sz_pattern, num_matrices=num_matrices, transpose=transpose, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchCopySM80CpAsyncOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM80.cp_async"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, cache_mode, *, pred=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dst))
    operands.append(_get_op_result_or_value(src))
    if pred is not None: operands.append(_get_op_result_or_value(pred))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cache_mode"] = (cache_mode if (
    isinstance(cache_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteLoadCacheModeEnumAttr')) else
      _ods_ir.AttrBuilder.get('CuteLoadCacheModeEnumAttr')(cache_mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dst(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def pred(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def cache_mode(self):
    return self.operation.attributes["cache_mode"]

  @cache_mode.setter
  def cache_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cache_mode"] = value

def arch_copy_SM80_cp_async(dst, src, cache_mode, *, pred=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM80CpAsyncOp(dst=dst, src=src, cache_mode=cache_mode, pred=pred, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM90BulkCopyG2SOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM90.bulk_copy_g2s"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_data_addr, dsmem_data_addr, dsmem_bar_addr, size, *, multicast_mask=None, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_data_addr))
    operands.append(_get_op_result_or_value(dsmem_data_addr))
    operands.append(_get_op_result_or_value(dsmem_bar_addr))
    operands.append(_get_op_result_or_value(multicast_mask) if multicast_mask is not None else None)
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dsmem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def dsmem_bar_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def multicast_mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

def arch_copy_SM90_bulk_copy_g2s(gmem_data_addr, dsmem_data_addr, dsmem_bar_addr, size, *, multicast_mask=None, cache_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM90BulkCopyG2SOp(gmem_data_addr=gmem_data_addr, dsmem_data_addr=dsmem_data_addr, dsmem_bar_addr=dsmem_bar_addr, size=size, multicast_mask=multicast_mask, cache_policy=cache_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM90BulkCopyS2GOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM90.bulk_copy_s2g"

  _ODS_OPERAND_SEGMENTS = [1,1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, dsmem_data_addr, gmem_data_addr, size, *, byte_mask=None, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dsmem_data_addr))
    operands.append(_get_op_result_or_value(gmem_data_addr))
    operands.append(_get_op_result_or_value(byte_mask) if byte_mask is not None else None)
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    isinstance(size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(size, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dsmem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def gmem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def byte_mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

def arch_copy_SM90_bulk_copy_s2g(dsmem_data_addr, gmem_data_addr, size, *, byte_mask=None, cache_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM90BulkCopyS2GOp(dsmem_data_addr=dsmem_data_addr, gmem_data_addr=gmem_data_addr, size=size, byte_mask=byte_mask, cache_policy=cache_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM100CopyS2TOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM100.copy_s2t"

  _ODS_REGIONS = (0, True)

  def __init__(self, dp, bits, cta, broadcast, src, dst, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(dst))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dp"] = (dp if (
    isinstance(dp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100CopyS2TDpAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100CopyS2TDpAttr')(dp, context=_ods_context))
    attributes["bits"] = (bits if (
    isinstance(bits, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100CopyS2TBitAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100CopyS2TBitAttr')(bits, context=_ods_context))
    attributes["cta"] = (cta if (
    isinstance(cta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100CopyS2TCtaAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100CopyS2TCtaAttr')(cta, context=_ods_context))
    attributes["broadcast"] = (broadcast if (
    isinstance(broadcast, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100CopyS2TBroadcastEnumAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100CopyS2TBroadcastEnumAttr')(broadcast, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.operands[1]

  @builtins.property
  def dp(self):
    return self.operation.attributes["dp"]

  @dp.setter
  def dp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dp"] = value

  @builtins.property
  def bits(self):
    return self.operation.attributes["bits"]

  @bits.setter
  def bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bits"] = value

  @builtins.property
  def cta(self):
    return self.operation.attributes["cta"]

  @cta.setter
  def cta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cta"] = value

  @builtins.property
  def broadcast(self):
    return self.operation.attributes["broadcast"]

  @broadcast.setter
  def broadcast(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["broadcast"] = value

def arch_copy_SM100_copy_s2t(dp, bits, cta, broadcast, src, dst, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM100CopyS2TOp(dp=dp, bits=bits, cta=cta, broadcast=broadcast, src=src, dst=dst, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM100TmaLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM100.tma_load"

  _ODS_OPERAND_SEGMENTS = [1,1,1,-1,0,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, mode, num_cta, src_desc, dsmem_data_addr, dsmem_bar_addr, coord, offsets, *, multicast_mask=None, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src_desc))
    operands.append(_get_op_result_or_value(dsmem_data_addr))
    operands.append(_get_op_result_or_value(dsmem_bar_addr))
    operands.append(_get_op_results_or_values(coord))
    operands.append(_get_op_result_or_value(multicast_mask) if multicast_mask is not None else None)
    operands.append(_get_op_results_or_values(offsets))
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteTmaLoadModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteTmaLoadModeAttr')(mode, context=_ods_context))
    attributes["num_cta"] = (num_cta if (
    isinstance(num_cta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArchCopySM100TmaLoadOpNumCTAAttr')) else
      _ods_ir.AttrBuilder.get('ArchCopySM100TmaLoadOpNumCTAAttr')(num_cta, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src_desc(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dsmem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def dsmem_bar_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def coord(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def multicast_mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def num_cta(self):
    return self.operation.attributes["num_cta"]

  @num_cta.setter
  def num_cta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_cta"] = value

def arch_copy_SM100_tma_load(mode, num_cta, src_desc, dsmem_data_addr, dsmem_bar_addr, coord, offsets, *, multicast_mask=None, cache_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM100TmaLoadOp(mode=mode, num_cta=num_cta, src_desc=src_desc, dsmem_data_addr=dsmem_data_addr, dsmem_bar_addr=dsmem_bar_addr, coord=coord, offsets=offsets, multicast_mask=multicast_mask, cache_policy=cache_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM100TmaReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM100.tma_reduce"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, mode, kind, dst_desc, src_smem_data_addr, coord, *, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dst_desc))
    operands.append(_get_op_result_or_value(src_smem_data_addr))
    operands.append(_get_op_results_or_values(coord))
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteTmaStoreModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteTmaStoreModeAttr')(mode, context=_ods_context))
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteReductionKindAttr')) else
      _ods_ir.AttrBuilder.get('CuteReductionKindAttr')(kind, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dst_desc(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def src_smem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def coord(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def kind(self):
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

def arch_copy_SM100_tma_reduce(mode, kind, dst_desc, src_smem_data_addr, coord, *, cache_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM100TmaReduceOp(mode=mode, kind=kind, dst_desc=dst_desc, src_smem_data_addr=src_smem_data_addr, coord=coord, cache_policy=cache_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM100TmaStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM100.tma_store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, mode, dst_desc, src_smem_data_addr, coord, *, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dst_desc))
    operands.append(_get_op_result_or_value(src_smem_data_addr))
    operands.append(_get_op_results_or_values(coord))
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteTmaStoreModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteTmaStoreModeAttr')(mode, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dst_desc(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def src_smem_data_addr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def coord(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

def arch_copy_SM100_tma_store(mode, dst_desc, src_smem_data_addr, coord, *, cache_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM100TmaStoreOp(mode=mode, dst_desc=dst_desc, src_smem_data_addr=src_smem_data_addr, coord=coord, cache_policy=cache_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopySM100TmemLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM100.tmem_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, num_dp, num_b, num_rep, src, *, pack_16=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_dp"] = (num_dp if (
    isinstance(num_dp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100TMEMNumDpAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100TMEMNumDpAttr')(num_dp, context=_ods_context))
    attributes["num_b"] = (num_b if (
    isinstance(num_b, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100TMEMNumBAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100TMEMNumBAttr')(num_b, context=_ods_context))
    attributes["num_rep"] = (num_rep if (
    isinstance(num_rep, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100TMEMNumRepAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100TMEMNumRepAttr')(num_rep, context=_ods_context))
    if bool(pack_16): attributes["pack_16"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def num_dp(self):
    return self.operation.attributes["num_dp"]

  @num_dp.setter
  def num_dp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_dp"] = value

  @builtins.property
  def num_b(self):
    return self.operation.attributes["num_b"]

  @num_b.setter
  def num_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_b"] = value

  @builtins.property
  def num_rep(self):
    return self.operation.attributes["num_rep"]

  @num_rep.setter
  def num_rep(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_rep"] = value

  @builtins.property
  def pack_16(self):
    return "pack_16" in self.operation.attributes

  @pack_16.setter
  def pack_16(self, value):
    if bool(value):
      self.operation.attributes["pack_16"] = _ods_ir.UnitAttr.get()
    elif "pack_16" in self.operation.attributes:
      del self.operation.attributes["pack_16"]

  @pack_16.deleter
  def pack_16(self):
    del self.operation.attributes["pack_16"]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def arch_copy_SM100_tmem_load(dst, num_dp, num_b, num_rep, src, *, pack_16=None, loc=None, ip=None) -> _ods_ir.Value:
  return ArchCopySM100TmemLoadOp(dst=dst, num_dp=num_dp, num_b=num_b, num_rep=num_rep, src=src, pack_16=pack_16, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchCopySM100TmemStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.SM100.tmem_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, num_dp, num_b, num_rep, src, *, expand_16=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dst))
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_dp"] = (num_dp if (
    isinstance(num_dp, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100TMEMNumDpAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100TMEMNumDpAttr')(num_dp, context=_ods_context))
    attributes["num_b"] = (num_b if (
    isinstance(num_b, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100TMEMNumBAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100TMEMNumBAttr')(num_b, context=_ods_context))
    attributes["num_rep"] = (num_rep if (
    isinstance(num_rep, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteArchCopySM100TMEMNumRepAttr')) else
      _ods_ir.AttrBuilder.get('CuteArchCopySM100TMEMNumRepAttr')(num_rep, context=_ods_context))
    if bool(expand_16): attributes["expand_16"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dst(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def num_dp(self):
    return self.operation.attributes["num_dp"]

  @num_dp.setter
  def num_dp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_dp"] = value

  @builtins.property
  def num_b(self):
    return self.operation.attributes["num_b"]

  @num_b.setter
  def num_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_b"] = value

  @builtins.property
  def num_rep(self):
    return self.operation.attributes["num_rep"]

  @num_rep.setter
  def num_rep(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_rep"] = value

  @builtins.property
  def expand_16(self):
    return "expand_16" in self.operation.attributes

  @expand_16.setter
  def expand_16(self, value):
    if bool(value):
      self.operation.attributes["expand_16"] = _ods_ir.UnitAttr.get()
    elif "expand_16" in self.operation.attributes:
      del self.operation.attributes["expand_16"]

  @expand_16.deleter
  def expand_16(self):
    del self.operation.attributes["expand_16"]

def arch_copy_SM100_tmem_store(dst, num_dp, num_b, num_rep, src, *, expand_16=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopySM100TmemStoreOp(dst=dst, num_dp=num_dp, num_b=num_b, num_rep=num_rep, src=src, expand_16=expand_16, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchCopyStsmOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.copy.stsm"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, matrix_shape, num_matrices, src, *, transpose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(dst))
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matrix_shape"] = (matrix_shape if (
    isinstance(matrix_shape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(matrix_shape, context=_ods_context))
    attributes["num_matrices"] = (num_matrices if (
    isinstance(num_matrices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(num_matrices, context=_ods_context))
    if bool(transpose): attributes["transpose"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dst(self):
    return self.operation.operands[0]

  @builtins.property
  def src(self):
    return self.operation.operands[1]

  @builtins.property
  def matrix_shape(self):
    return self.operation.attributes["matrix_shape"]

  @matrix_shape.setter
  def matrix_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matrix_shape"] = value

  @builtins.property
  def num_matrices(self):
    return self.operation.attributes["num_matrices"]

  @num_matrices.setter
  def num_matrices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_matrices"] = value

  @builtins.property
  def transpose(self):
    return "transpose" in self.operation.attributes

  @transpose.setter
  def transpose(self, value):
    if bool(value):
      self.operation.attributes["transpose"] = _ods_ir.UnitAttr.get()
    elif "transpose" in self.operation.attributes:
      del self.operation.attributes["transpose"]

  @transpose.deleter
  def transpose(self):
    del self.operation.attributes["transpose"]

def arch_copy_stsm(dst, matrix_shape, num_matrices, src, *, transpose=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchCopyStsmOp(dst=dst, matrix_shape=matrix_shape, num_matrices=num_matrices, src=src, transpose=transpose, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchGetDynamicSmemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.get_dyn_smem"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(ptr)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr(self):
    return self.operation.results[0]

def arch_get_dyn_smem(ptr, *, loc=None, ip=None) -> _ods_ir.Value:
  return ArchGetDynamicSmemOp(ptr=ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchGetDynamicSmemSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.get_dyn_smem_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def size(self):
    return self.operation.results[0]

def arch_get_dyn_smem_size(*, loc=None, ip=None) -> _ods_ir.Value:
  return ArchGetDynamicSmemSizeOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchMakeWarpUniformOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.make_warp_uniform"

  _ODS_REGIONS = (0, True)

  def __init__(self, val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(val))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def val(self):
    return self.operation.operands[0]

  @builtins.property
  def res(self):
    return self.operation.results[0]

def arch_make_warp_uniform(val, *, loc=None, ip=None) -> _ods_ir.Value:
  return ArchMakeWarpUniformOp(val=val, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM80Op(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM80"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, res, shape_MNK, a_type, b_type, opA, opB, opC, *, int_overflow=None, binary_op=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(opA))
    operands.append(_get_op_results_or_values(opB))
    operands.append(_get_op_results_or_values(opC))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape_MNK"] = (shape_MNK if (
    isinstance(shape_MNK, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(shape_MNK, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1504')) else
      _ods_ir.AttrBuilder.get('anonymous_1504')(a_type, context=_ods_context))
    attributes["b_type"] = (b_type if (
    isinstance(b_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1504')) else
      _ods_ir.AttrBuilder.get('anonymous_1504')(b_type, context=_ods_context))
    if int_overflow is not None: attributes["int_overflow"] = (int_overflow if (
        isinstance(int_overflow, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteMMAIntOverflowAttr')) else
          _ods_ir.AttrBuilder.get('CuteMMAIntOverflowAttr')(int_overflow, context=_ods_context))
    if binary_op is not None: attributes["binary_op"] = (binary_op if (
        isinstance(binary_op, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteBinaryOpAttr')) else
          _ods_ir.AttrBuilder.get('CuteBinaryOpAttr')(binary_op, context=_ods_context))
    results.extend(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def opA(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def opB(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def opC(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def shape_MNK(self):
    return self.operation.attributes["shape_MNK"]

  @shape_MNK.setter
  def shape_MNK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape_MNK"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def b_type(self):
    return self.operation.attributes["b_type"]

  @b_type.setter
  def b_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b_type"] = value

  @builtins.property
  def int_overflow(self):
    if "int_overflow" not in self.operation.attributes:
      return None
    return self.operation.attributes["int_overflow"]

  @int_overflow.setter
  def int_overflow(self, value):
    if value is not None:
      self.operation.attributes["int_overflow"] = value
    elif "int_overflow" in self.operation.attributes:
      del self.operation.attributes["int_overflow"]

  @int_overflow.deleter
  def int_overflow(self):
    del self.operation.attributes["int_overflow"]

  @builtins.property
  def binary_op(self):
    if "binary_op" not in self.operation.attributes:
      return None
    return self.operation.attributes["binary_op"]

  @binary_op.setter
  def binary_op(self, value):
    if value is not None:
      self.operation.attributes["binary_op"] = value
    elif "binary_op" in self.operation.attributes:
      del self.operation.attributes["binary_op"]

  @binary_op.deleter
  def binary_op(self):
    del self.operation.attributes["binary_op"]

  @builtins.property
  def res(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def arch_mma_SM80(res, shape_mnk, a_type, b_type, op_a, op_b, op_c, *, int_overflow=None, binary_op=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ArchMmaSM80Op(res=res, shape_MNK=shape_mnk, a_type=a_type, b_type=b_type, opA=op_a, opB=op_b, opC=op_c, int_overflow=int_overflow, binary_op=binary_op, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM80SparseOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM80.sparse"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, res, shape_MNK, a_type, b_type, c_type, metadata, opA, opB, opC, opE, *, int_overflow=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(opA))
    operands.append(_get_op_results_or_values(opB))
    operands.append(_get_op_results_or_values(opC))
    operands.append(_get_op_results_or_values(opE))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape_MNK"] = (shape_MNK if (
    isinstance(shape_MNK, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(shape_MNK, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1511')) else
      _ods_ir.AttrBuilder.get('anonymous_1511')(a_type, context=_ods_context))
    attributes["b_type"] = (b_type if (
    isinstance(b_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1511')) else
      _ods_ir.AttrBuilder.get('anonymous_1511')(b_type, context=_ods_context))
    attributes["c_type"] = (c_type if (
    isinstance(c_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1514')) else
      _ods_ir.AttrBuilder.get('anonymous_1514')(c_type, context=_ods_context))
    attributes["metadata"] = (metadata if (
    isinstance(metadata, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1517')) else
      _ods_ir.AttrBuilder.get('anonymous_1517')(metadata, context=_ods_context))
    if int_overflow is not None: attributes["int_overflow"] = (int_overflow if (
        isinstance(int_overflow, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteMMAIntOverflowAttr')) else
          _ods_ir.AttrBuilder.get('CuteMMAIntOverflowAttr')(int_overflow, context=_ods_context))
    results.extend(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def opA(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def opB(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def opC(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def opE(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def shape_MNK(self):
    return self.operation.attributes["shape_MNK"]

  @shape_MNK.setter
  def shape_MNK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape_MNK"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def b_type(self):
    return self.operation.attributes["b_type"]

  @b_type.setter
  def b_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b_type"] = value

  @builtins.property
  def c_type(self):
    return self.operation.attributes["c_type"]

  @c_type.setter
  def c_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["c_type"] = value

  @builtins.property
  def metadata(self):
    return self.operation.attributes["metadata"]

  @metadata.setter
  def metadata(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["metadata"] = value

  @builtins.property
  def int_overflow(self):
    if "int_overflow" not in self.operation.attributes:
      return None
    return self.operation.attributes["int_overflow"]

  @int_overflow.setter
  def int_overflow(self, value):
    if value is not None:
      self.operation.attributes["int_overflow"] = value
    elif "int_overflow" in self.operation.attributes:
      del self.operation.attributes["int_overflow"]

  @int_overflow.deleter
  def int_overflow(self):
    del self.operation.attributes["int_overflow"]

  @builtins.property
  def res(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def arch_mma_SM80_sparse(res, shape_mnk, a_type, b_type, c_type, metadata, op_a, op_b, op_c, op_e, *, int_overflow=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ArchMmaSM80SparseOp(res=res, shape_MNK=shape_mnk, a_type=a_type, b_type=b_type, c_type=c_type, metadata=metadata, opA=op_a, opB=op_b, opC=op_c, opE=op_e, int_overflow=int_overflow, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM89Op(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM89"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, res, shape_MNK, a_type, b_type, opA, opB, opC, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(opA))
    operands.append(_get_op_results_or_values(opB))
    operands.append(_get_op_results_or_values(opC))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape_MNK"] = (shape_MNK if (
    isinstance(shape_MNK, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(shape_MNK, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1523')) else
      _ods_ir.AttrBuilder.get('anonymous_1523')(a_type, context=_ods_context))
    attributes["b_type"] = (b_type if (
    isinstance(b_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1523')) else
      _ods_ir.AttrBuilder.get('anonymous_1523')(b_type, context=_ods_context))
    results.extend(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def opA(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def opB(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def opC(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def shape_MNK(self):
    return self.operation.attributes["shape_MNK"]

  @shape_MNK.setter
  def shape_MNK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape_MNK"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def b_type(self):
    return self.operation.attributes["b_type"]

  @b_type.setter
  def b_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b_type"] = value

  @builtins.property
  def res(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def arch_mma_SM89(res, shape_mnk, a_type, b_type, op_a, op_b, op_c, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ArchMmaSM89Op(res=res, shape_MNK=shape_mnk, a_type=a_type, b_type=b_type, opA=op_a, opB=op_b, opC=op_c, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM90Op(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM90"

  _ODS_OPERAND_SEGMENTS = [-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, res, shapeMNK, a_op, a_type, a_major, b_op, b_type, b_major, c_op, cd_type, accum, *, a_neg=None, b_neg=None, saturate=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(a_op))
    operands.append(_get_op_result_or_value(b_op))
    operands.append(_get_op_results_or_values(c_op))
    operands.append(_get_op_result_or_value(accum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shapeMNK"] = (shapeMNK if (
    isinstance(shapeMNK, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(shapeMNK, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1553')) else
      _ods_ir.AttrBuilder.get('anonymous_1553')(a_type, context=_ods_context))
    attributes["a_major"] = (a_major if (
    isinstance(a_major, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMajorModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteMajorModeAttr')(a_major, context=_ods_context))
    if bool(a_neg): attributes["a_neg"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["b_type"] = (b_type if (
    isinstance(b_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1553')) else
      _ods_ir.AttrBuilder.get('anonymous_1553')(b_type, context=_ods_context))
    attributes["b_major"] = (b_major if (
    isinstance(b_major, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMajorModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteMajorModeAttr')(b_major, context=_ods_context))
    if bool(b_neg): attributes["b_neg"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["cd_type"] = (cd_type if (
    isinstance(cd_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1556')) else
      _ods_ir.AttrBuilder.get('anonymous_1556')(cd_type, context=_ods_context))
    if bool(saturate): attributes["saturate"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a_op(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def b_op(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def c_op(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def accum(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def shapeMNK(self):
    return self.operation.attributes["shapeMNK"]

  @shapeMNK.setter
  def shapeMNK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shapeMNK"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def a_major(self):
    return self.operation.attributes["a_major"]

  @a_major.setter
  def a_major(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_major"] = value

  @builtins.property
  def a_neg(self):
    return "a_neg" in self.operation.attributes

  @a_neg.setter
  def a_neg(self, value):
    if bool(value):
      self.operation.attributes["a_neg"] = _ods_ir.UnitAttr.get()
    elif "a_neg" in self.operation.attributes:
      del self.operation.attributes["a_neg"]

  @a_neg.deleter
  def a_neg(self):
    del self.operation.attributes["a_neg"]

  @builtins.property
  def b_type(self):
    return self.operation.attributes["b_type"]

  @b_type.setter
  def b_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b_type"] = value

  @builtins.property
  def b_major(self):
    return self.operation.attributes["b_major"]

  @b_major.setter
  def b_major(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b_major"] = value

  @builtins.property
  def b_neg(self):
    return "b_neg" in self.operation.attributes

  @b_neg.setter
  def b_neg(self, value):
    if bool(value):
      self.operation.attributes["b_neg"] = _ods_ir.UnitAttr.get()
    elif "b_neg" in self.operation.attributes:
      del self.operation.attributes["b_neg"]

  @b_neg.deleter
  def b_neg(self):
    del self.operation.attributes["b_neg"]

  @builtins.property
  def cd_type(self):
    return self.operation.attributes["cd_type"]

  @cd_type.setter
  def cd_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cd_type"] = value

  @builtins.property
  def saturate(self):
    return "saturate" in self.operation.attributes

  @saturate.setter
  def saturate(self, value):
    if bool(value):
      self.operation.attributes["saturate"] = _ods_ir.UnitAttr.get()
    elif "saturate" in self.operation.attributes:
      del self.operation.attributes["saturate"]

  @saturate.deleter
  def saturate(self):
    del self.operation.attributes["saturate"]

  @builtins.property
  def res(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def arch_mma_SM90(res, shape_mnk, a_op, a_type, a_major, b_op, b_type, b_major, c_op, cd_type, accum, *, a_neg=None, b_neg=None, saturate=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ArchMmaSM90Op(res=res, shapeMNK=shape_mnk, a_op=a_op, a_type=a_type, a_major=a_major, b_op=b_op, b_type=b_type, b_major=b_major, c_op=c_op, cd_type=cd_type, accum=accum, a_neg=a_neg, b_neg=b_neg, saturate=saturate, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM100UMMABlockScaledOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM100.umma_block_scaled"

  _ODS_REGIONS = (0, True)

  def __init__(self, num_cta, vec_size, a_type, shape_k, a, b, cd, sf_a, sf_b, idesc, accum, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(cd))
    operands.append(_get_op_result_or_value(sf_a))
    operands.append(_get_op_result_or_value(sf_b))
    operands.append(_get_op_result_or_value(idesc))
    operands.append(_get_op_result_or_value(accum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_cta"] = (num_cta if (
    isinstance(num_cta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(num_cta, context=_ods_context))
    attributes["vec_size"] = (vec_size if (
    isinstance(vec_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(vec_size, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(a_type, context=_ods_context))
    attributes["shape_k"] = (shape_k if (
    isinstance(shape_k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(shape_k, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def cd(self):
    return self.operation.operands[2]

  @builtins.property
  def sf_a(self):
    return self.operation.operands[3]

  @builtins.property
  def sf_b(self):
    return self.operation.operands[4]

  @builtins.property
  def idesc(self):
    return self.operation.operands[5]

  @builtins.property
  def accum(self):
    return self.operation.operands[6]

  @builtins.property
  def num_cta(self):
    return self.operation.attributes["num_cta"]

  @num_cta.setter
  def num_cta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_cta"] = value

  @builtins.property
  def vec_size(self):
    return self.operation.attributes["vec_size"]

  @vec_size.setter
  def vec_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["vec_size"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def shape_k(self):
    return self.operation.attributes["shape_k"]

  @shape_k.setter
  def shape_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape_k"] = value

def arch_mma_SM100_umma_block_scaled(num_cta, vec_size, a_type, shape_k, a, b, cd, sf_a, sf_b, idesc, accum, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchMmaSM100UMMABlockScaledOp(num_cta=num_cta, vec_size=vec_size, a_type=a_type, shape_k=shape_k, a=a, b=b, cd=cd, sf_a=sf_a, sf_b=sf_b, idesc=idesc, accum=accum, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM100UMMABlockScaledSparseOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM100.umma_block_scaled_sparse"

  _ODS_REGIONS = (0, True)

  def __init__(self, num_cta, vec_size, a_type, shape_k, a, b, cd, sf_a, sf_b, e_op, idesc, accum, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a))
    operands.append(_get_op_result_or_value(b))
    operands.append(_get_op_result_or_value(cd))
    operands.append(_get_op_result_or_value(sf_a))
    operands.append(_get_op_result_or_value(sf_b))
    operands.append(_get_op_result_or_value(e_op))
    operands.append(_get_op_result_or_value(idesc))
    operands.append(_get_op_result_or_value(accum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_cta"] = (num_cta if (
    isinstance(num_cta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(num_cta, context=_ods_context))
    attributes["vec_size"] = (vec_size if (
    isinstance(vec_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(vec_size, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(a_type, context=_ods_context))
    attributes["shape_k"] = (shape_k if (
    isinstance(shape_k, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(shape_k, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a(self):
    return self.operation.operands[0]

  @builtins.property
  def b(self):
    return self.operation.operands[1]

  @builtins.property
  def cd(self):
    return self.operation.operands[2]

  @builtins.property
  def sf_a(self):
    return self.operation.operands[3]

  @builtins.property
  def sf_b(self):
    return self.operation.operands[4]

  @builtins.property
  def e_op(self):
    return self.operation.operands[5]

  @builtins.property
  def idesc(self):
    return self.operation.operands[6]

  @builtins.property
  def accum(self):
    return self.operation.operands[7]

  @builtins.property
  def num_cta(self):
    return self.operation.attributes["num_cta"]

  @num_cta.setter
  def num_cta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_cta"] = value

  @builtins.property
  def vec_size(self):
    return self.operation.attributes["vec_size"]

  @vec_size.setter
  def vec_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["vec_size"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def shape_k(self):
    return self.operation.attributes["shape_k"]

  @shape_k.setter
  def shape_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape_k"] = value

def arch_mma_SM100_umma_block_scaled_sparse(num_cta, vec_size, a_type, shape_k, a, b, cd, sf_a, sf_b, e_op, idesc, accum, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchMmaSM100UMMABlockScaledSparseOp(num_cta=num_cta, vec_size=vec_size, a_type=a_type, shape_k=shape_k, a=a, b=b, cd=cd, sf_a=sf_a, sf_b=sf_b, e_op=e_op, idesc=idesc, accum=accum, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM100UMMAOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM100.umma"

  _ODS_REGIONS = (0, True)

  def __init__(self, num_cta, scale, a_type, a_op, b_op, cd_op, idesc, accum, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a_op))
    operands.append(_get_op_result_or_value(b_op))
    operands.append(_get_op_result_or_value(cd_op))
    operands.append(_get_op_result_or_value(idesc))
    operands.append(_get_op_result_or_value(accum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_cta"] = (num_cta if (
    isinstance(num_cta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(num_cta, context=_ods_context))
    attributes["scale"] = (scale if (
    isinstance(scale, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(scale, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(a_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a_op(self):
    return self.operation.operands[0]

  @builtins.property
  def b_op(self):
    return self.operation.operands[1]

  @builtins.property
  def cd_op(self):
    return self.operation.operands[2]

  @builtins.property
  def idesc(self):
    return self.operation.operands[3]

  @builtins.property
  def accum(self):
    return self.operation.operands[4]

  @builtins.property
  def num_cta(self):
    return self.operation.attributes["num_cta"]

  @num_cta.setter
  def num_cta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_cta"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

def arch_mma_SM100_umma(num_cta, scale, a_type, a_op, b_op, cd_op, idesc, accum, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchMmaSM100UMMAOp(num_cta=num_cta, scale=scale, a_type=a_type, a_op=a_op, b_op=b_op, cd_op=cd_op, idesc=idesc, accum=accum, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM100UMMASparseOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM100.umma_sparse"

  _ODS_REGIONS = (0, True)

  def __init__(self, num_cta, scale, a_type, a_op, b_op, cd_op, e_op, idesc, accum, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(a_op))
    operands.append(_get_op_result_or_value(b_op))
    operands.append(_get_op_result_or_value(cd_op))
    operands.append(_get_op_result_or_value(e_op))
    operands.append(_get_op_result_or_value(idesc))
    operands.append(_get_op_result_or_value(accum))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_cta"] = (num_cta if (
    isinstance(num_cta, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(num_cta, context=_ods_context))
    attributes["scale"] = (scale if (
    isinstance(scale, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(scale, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(a_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def a_op(self):
    return self.operation.operands[0]

  @builtins.property
  def b_op(self):
    return self.operation.operands[1]

  @builtins.property
  def cd_op(self):
    return self.operation.operands[2]

  @builtins.property
  def e_op(self):
    return self.operation.operands[3]

  @builtins.property
  def idesc(self):
    return self.operation.operands[4]

  @builtins.property
  def accum(self):
    return self.operation.operands[5]

  @builtins.property
  def num_cta(self):
    return self.operation.attributes["num_cta"]

  @num_cta.setter
  def num_cta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_cta"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

def arch_mma_SM100_umma_sparse(num_cta, scale, a_type, a_op, b_op, cd_op, e_op, idesc, accum, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchMmaSM100UMMASparseOp(num_cta=num_cta, scale=scale, a_type=a_type, a_op=a_op, b_op=b_op, cd_op=cd_op, e_op=e_op, idesc=idesc, accum=accum, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchMmaSM120BlockScaledOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.mma.SM120.block_scaled"

  _ODS_REGIONS = (0, True)

  def __init__(self, res, shape_MNK, vec_size, a_type, b_type, sf_type, opA, opB, opC, sfA, sfB, *, byte_id_a=None, byte_id_b=None, thread_id_a=None, thread_id_b=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(opA))
    operands.append(_get_op_result_or_value(opB))
    operands.append(_get_op_result_or_value(opC))
    operands.append(_get_op_result_or_value(sfA))
    operands.append(_get_op_result_or_value(sfB))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape_MNK"] = (shape_MNK if (
    isinstance(shape_MNK, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteShapeAttr')) else
      _ods_ir.AttrBuilder.get('CuteShapeAttr')(shape_MNK, context=_ods_context))
    attributes["vec_size"] = (vec_size if (
    isinstance(vec_size, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(vec_size, context=_ods_context))
    if byte_id_a is not None: attributes["byte_id_a"] = (byte_id_a if (
        isinstance(byte_id_a, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(byte_id_a, context=_ods_context))
    if byte_id_b is not None: attributes["byte_id_b"] = (byte_id_b if (
        isinstance(byte_id_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(byte_id_b, context=_ods_context))
    if thread_id_a is not None: attributes["thread_id_a"] = (thread_id_a if (
        isinstance(thread_id_a, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(thread_id_a, context=_ods_context))
    if thread_id_b is not None: attributes["thread_id_b"] = (thread_id_b if (
        isinstance(thread_id_b, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(thread_id_b, context=_ods_context))
    attributes["a_type"] = (a_type if (
    isinstance(a_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1534')) else
      _ods_ir.AttrBuilder.get('anonymous_1534')(a_type, context=_ods_context))
    attributes["b_type"] = (b_type if (
    isinstance(b_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1534')) else
      _ods_ir.AttrBuilder.get('anonymous_1534')(b_type, context=_ods_context))
    attributes["sf_type"] = (sf_type if (
    isinstance(sf_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1537')) else
      _ods_ir.AttrBuilder.get('anonymous_1537')(sf_type, context=_ods_context))
    results.append(res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def opA(self):
    return self.operation.operands[0]

  @builtins.property
  def opB(self):
    return self.operation.operands[1]

  @builtins.property
  def opC(self):
    return self.operation.operands[2]

  @builtins.property
  def sfA(self):
    return self.operation.operands[3]

  @builtins.property
  def sfB(self):
    return self.operation.operands[4]

  @builtins.property
  def shape_MNK(self):
    return self.operation.attributes["shape_MNK"]

  @shape_MNK.setter
  def shape_MNK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape_MNK"] = value

  @builtins.property
  def vec_size(self):
    return self.operation.attributes["vec_size"]

  @vec_size.setter
  def vec_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["vec_size"] = value

  @builtins.property
  def byte_id_a(self):
    return self.operation.attributes["byte_id_a"]

  @byte_id_a.setter
  def byte_id_a(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byte_id_a"] = value

  @builtins.property
  def byte_id_b(self):
    return self.operation.attributes["byte_id_b"]

  @byte_id_b.setter
  def byte_id_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["byte_id_b"] = value

  @builtins.property
  def thread_id_a(self):
    return self.operation.attributes["thread_id_a"]

  @thread_id_a.setter
  def thread_id_a(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["thread_id_a"] = value

  @builtins.property
  def thread_id_b(self):
    return self.operation.attributes["thread_id_b"]

  @thread_id_b.setter
  def thread_id_b(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["thread_id_b"] = value

  @builtins.property
  def a_type(self):
    return self.operation.attributes["a_type"]

  @a_type.setter
  def a_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["a_type"] = value

  @builtins.property
  def b_type(self):
    return self.operation.attributes["b_type"]

  @b_type.setter
  def b_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["b_type"] = value

  @builtins.property
  def sf_type(self):
    return self.operation.attributes["sf_type"]

  @sf_type.setter
  def sf_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sf_type"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def arch_mma_SM120_block_scaled(res, shape_mnk, vec_size, a_type, b_type, sf_type, op_a, op_b, op_c, sf_a, sf_b, *, byte_id_a=None, byte_id_b=None, thread_id_a=None, thread_id_b=None, loc=None, ip=None) -> _ods_ir.Value:
  return ArchMmaSM120BlockScaledOp(res=res, shape_MNK=shape_mnk, vec_size=vec_size, a_type=a_type, b_type=b_type, sf_type=sf_type, opA=op_a, opB=op_b, opC=op_c, sfA=sf_a, sfB=sf_b, byte_id_a=byte_id_a, byte_id_b=byte_id_b, thread_id_a=thread_id_a, thread_id_b=thread_id_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArchPrefetchTmaDescOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.prefetch_tma_desc"

  _ODS_REGIONS = (0, True)

  def __init__(self, tma_descriptor_ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_descriptor_ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_descriptor_ptr(self):
    return self.operation.operands[0]

def arch_prefetch_tma_desc(tma_descriptor_ptr, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchPrefetchTmaDescOp(tma_descriptor_ptr=tma_descriptor_ptr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchSM100AllocTmemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.sm100.alloc_tmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, n_cols, dst_ptr, *, is_two_cta=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(n_cols))
    operands.append(_get_op_result_or_value(dst_ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_two_cta): attributes["is_two_cta"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def n_cols(self):
    return self.operation.operands[0]

  @builtins.property
  def dst_ptr(self):
    return self.operation.operands[1]

  @builtins.property
  def is_two_cta(self):
    return "is_two_cta" in self.operation.attributes

  @is_two_cta.setter
  def is_two_cta(self, value):
    if bool(value):
      self.operation.attributes["is_two_cta"] = _ods_ir.UnitAttr.get()
    elif "is_two_cta" in self.operation.attributes:
      del self.operation.attributes["is_two_cta"]

  @is_two_cta.deleter
  def is_two_cta(self):
    del self.operation.attributes["is_two_cta"]

def arch_sm100_alloc_tmem(n_cols, dst_ptr, *, is_two_cta=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchSM100AllocTmemOp(n_cols=n_cols, dst_ptr=dst_ptr, is_two_cta=is_two_cta, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchSM100DeallocTmemOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.sm100.dealloc_tmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, tmem_ptr, n_cols, *, is_two_cta=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tmem_ptr))
    operands.append(_get_op_result_or_value(n_cols))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_two_cta): attributes["is_two_cta"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tmem_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def n_cols(self):
    return self.operation.operands[1]

  @builtins.property
  def is_two_cta(self):
    return "is_two_cta" in self.operation.attributes

  @is_two_cta.setter
  def is_two_cta(self, value):
    if bool(value):
      self.operation.attributes["is_two_cta"] = _ods_ir.UnitAttr.get()
    elif "is_two_cta" in self.operation.attributes:
      del self.operation.attributes["is_two_cta"]

  @is_two_cta.deleter
  def is_two_cta(self):
    del self.operation.attributes["is_two_cta"]

def arch_sm100_dealloc_tmem(tmem_ptr, n_cols, *, is_two_cta=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchSM100DeallocTmemOp(tmem_ptr=tmem_ptr, n_cols=n_cols, is_two_cta=is_two_cta, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchSM100RelinquishTmemAllocPermitOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.sm100.relinquish_tmem_alloc_permit"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, is_two_cta=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_two_cta): attributes["is_two_cta"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def is_two_cta(self):
    return "is_two_cta" in self.operation.attributes

  @is_two_cta.setter
  def is_two_cta(self, value):
    if bool(value):
      self.operation.attributes["is_two_cta"] = _ods_ir.UnitAttr.get()
    elif "is_two_cta" in self.operation.attributes:
      del self.operation.attributes["is_two_cta"]

  @is_two_cta.deleter
  def is_two_cta(self):
    del self.operation.attributes["is_two_cta"]

def arch_sm100_relinquish_tmem_alloc_permit(*, is_two_cta=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ArchSM100RelinquishTmemAllocPermitOp(is_two_cta=is_two_cta, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArchSM100RetrieveTmemPtrOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.arch.sm100.retrieve_tmem_ptr"

  _ODS_REGIONS = (0, True)

  def __init__(self, tmem_ptr, smem_ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(smem_ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(tmem_ptr)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def smem_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def tmem_ptr(self):
    return self.operation.results[0]

def arch_sm100_retrieve_tmem_ptr(tmem_ptr, smem_ptr, *, loc=None, ip=None) -> _ods_ir.Value:
  return ArchSM100RetrieveTmemPtrOp(tmem_ptr=tmem_ptr, smem_ptr=smem_ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeBulkCopyG2SOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_bulk_copy_g2s"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tma_bar, *, mcast_mask=None, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_bar))
    operands.append(_get_op_result_or_value(mcast_mask) if mcast_mask is not None else None)
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_bar(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def mcast_mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_bulk_copy_g2s(result, tma_bar, *, mcast_mask=None, cache_policy=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeBulkCopyG2SOp(result=result, tma_bar=tma_bar, mcast_mask=mcast_mask, cache_policy=cache_policy, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeBulkCopyS2GOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_bulk_copy_s2g"

  _ODS_OPERAND_SEGMENTS = [0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, byte_mask=None, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(byte_mask) if byte_mask is not None else None)
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def byte_mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_bulk_copy_s2g(result, *, byte_mask=None, cache_policy=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeBulkCopyS2GOp(result=result, byte_mask=byte_mask, cache_policy=cache_policy, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeExecTmaOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_exec_tma"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_exec_tma(input, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeExecTmaOp(input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeNonExecIm2ColTmaLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_non_exec_im2col_tma_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_tensor, smem_layout, cta_v_map, kind, lower_corner_whd, upper_corner_whd, lower_padding_whd, upper_padding_whd, stride_whd, lower_srt, stride_srt, *, num_multicast=None, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_tensor))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_v_map))
    operands.append(_get_op_result_or_value(lower_corner_whd))
    operands.append(_get_op_result_or_value(upper_corner_whd))
    operands.append(_get_op_result_or_value(lower_padding_whd))
    operands.append(_get_op_result_or_value(upper_padding_whd))
    operands.append(_get_op_result_or_value(stride_whd))
    operands.append(_get_op_result_or_value(lower_srt))
    operands.append(_get_op_result_or_value(stride_srt))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteIm2ColTmaLoadEnumAttr')) else
      _ods_ir.AttrBuilder.get('CuteIm2ColTmaLoadEnumAttr')(kind, context=_ods_context))
    if num_multicast is not None: attributes["num_multicast"] = (num_multicast if (
        isinstance(num_multicast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(num_multicast, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_v_map(self):
    return self.operation.operands[2]

  @builtins.property
  def lower_corner_whd(self):
    return self.operation.operands[3]

  @builtins.property
  def upper_corner_whd(self):
    return self.operation.operands[4]

  @builtins.property
  def lower_padding_whd(self):
    return self.operation.operands[5]

  @builtins.property
  def upper_padding_whd(self):
    return self.operation.operands[6]

  @builtins.property
  def stride_whd(self):
    return self.operation.operands[7]

  @builtins.property
  def lower_srt(self):
    return self.operation.operands[8]

  @builtins.property
  def stride_srt(self):
    return self.operation.operands[9]

  @builtins.property
  def kind(self):
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

  @builtins.property
  def num_multicast(self):
    if "num_multicast" not in self.operation.attributes:
      return None
    return self.operation.attributes["num_multicast"]

  @num_multicast.setter
  def num_multicast(self, value):
    if value is not None:
      self.operation.attributes["num_multicast"] = value
    elif "num_multicast" in self.operation.attributes:
      del self.operation.attributes["num_multicast"]

  @num_multicast.deleter
  def num_multicast(self):
    del self.operation.attributes["num_multicast"]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def non_exec_atom(self):
    return self.operation.results[0]

  @builtins.property
  def tma_tensor(self):
    return self.operation.results[1]

def atom_make_non_exec_im2col_tma_load(gmem_tensor, smem_layout, cta_v_map, kind, lower_corner_whd, upper_corner_whd, lower_padding_whd, upper_padding_whd, stride_whd, lower_srt, stride_srt, *, num_multicast=None, tma_format=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtomCopyMakeNonExecIm2ColTmaLoadOp(gmem_tensor=gmem_tensor, smem_layout=smem_layout, cta_v_map=cta_v_map, kind=kind, lower_corner_whd=lower_corner_whd, upper_corner_whd=upper_corner_whd, lower_padding_whd=lower_padding_whd, upper_padding_whd=upper_padding_whd, stride_whd=stride_whd, lower_srt=lower_srt, stride_srt=stride_srt, num_multicast=num_multicast, tma_format=tma_format, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeNonExecIm2ColTmaStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_non_exec_im2col_tma_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_tensor, smem_layout, cta_v_map, *, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_tensor))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_v_map))
    _ods_context = _ods_get_default_loc_context(loc)
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_v_map(self):
    return self.operation.operands[2]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def non_exec_atom(self):
    return self.operation.results[0]

  @builtins.property
  def tma_tensor(self):
    return self.operation.results[1]

def atom_make_non_exec_im2col_tma_store(gmem_tensor, smem_layout, cta_v_map, *, tma_format=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtomCopyMakeNonExecIm2ColTmaStoreOp(gmem_tensor=gmem_tensor, smem_layout=smem_layout, cta_v_map=cta_v_map, tma_format=tma_format, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeNonExecTiledTmaLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_non_exec_tiled_tma_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_tensor, smem_layout, cta_v_map, kind, *, num_multicast=None, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_tensor))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_v_map))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteTiledTmaLoadEnumAttr')) else
      _ods_ir.AttrBuilder.get('CuteTiledTmaLoadEnumAttr')(kind, context=_ods_context))
    if num_multicast is not None: attributes["num_multicast"] = (num_multicast if (
        isinstance(num_multicast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(num_multicast, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_v_map(self):
    return self.operation.operands[2]

  @builtins.property
  def kind(self):
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

  @builtins.property
  def num_multicast(self):
    if "num_multicast" not in self.operation.attributes:
      return None
    return self.operation.attributes["num_multicast"]

  @num_multicast.setter
  def num_multicast(self, value):
    if value is not None:
      self.operation.attributes["num_multicast"] = value
    elif "num_multicast" in self.operation.attributes:
      del self.operation.attributes["num_multicast"]

  @num_multicast.deleter
  def num_multicast(self):
    del self.operation.attributes["num_multicast"]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def non_exec_atom(self):
    return self.operation.results[0]

  @builtins.property
  def tma_tensor(self):
    return self.operation.results[1]

def atom_make_non_exec_tiled_tma_load(gmem_tensor, smem_layout, cta_v_map, kind, *, num_multicast=None, tma_format=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtomCopyMakeNonExecTiledTmaLoadOp(gmem_tensor=gmem_tensor, smem_layout=smem_layout, cta_v_map=cta_v_map, kind=kind, num_multicast=num_multicast, tma_format=tma_format, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeNonExecTiledTmaReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_non_exec_tiled_tma_reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_tensor, smem_layout, cta_v_map, kind, *, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_tensor))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_v_map))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteReductionKindAttr')) else
      _ods_ir.AttrBuilder.get('CuteReductionKindAttr')(kind, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_v_map(self):
    return self.operation.operands[2]

  @builtins.property
  def kind(self):
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def non_exec_atom(self):
    return self.operation.results[0]

  @builtins.property
  def tma_tensor(self):
    return self.operation.results[1]

def atom_make_non_exec_tiled_tma_reduce(gmem_tensor, smem_layout, cta_v_map, kind, *, tma_format=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtomCopyMakeNonExecTiledTmaReduceOp(gmem_tensor=gmem_tensor, smem_layout=smem_layout, cta_v_map=cta_v_map, kind=kind, tma_format=tma_format, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeNonExecTiledTmaStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_non_exec_tiled_tma_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_tensor, smem_layout, cta_v_map, *, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_tensor))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_v_map))
    _ods_context = _ods_get_default_loc_context(loc)
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_v_map(self):
    return self.operation.operands[2]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def non_exec_atom(self):
    return self.operation.results[0]

  @builtins.property
  def tma_tensor(self):
    return self.operation.results[1]

def atom_make_non_exec_tiled_tma_store(gmem_tensor, smem_layout, cta_v_map, *, tma_format=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtomCopyMakeNonExecTiledTmaStoreOp(gmem_tensor=gmem_tensor, smem_layout=smem_layout, cta_v_map=cta_v_map, tma_format=tma_format, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeS2TCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_s2t_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, copy_s2t_atom, tmem_memref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(copy_s2t_atom))
    operands.append(_get_op_result_or_value(tmem_memref))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def copy_s2t_atom(self):
    return self.operation.operands[0]

  @builtins.property
  def tmem_memref(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_s2t_copy(copy_s2t_atom, tmem_memref, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeS2TCopyOp(copy_s2t_atom=copy_s2t_atom, tmem_memref=tmem_memref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeTmaLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_tma_load"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tma_descriptor_ptr, tma_bar, g_stride, *, mcast_mask=None, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_descriptor_ptr))
    operands.append(_get_op_result_or_value(tma_bar))
    operands.append(_get_op_result_or_value(g_stride))
    operands.append(_get_op_result_or_value(mcast_mask) if mcast_mask is not None else None)
    operands.append(_get_op_result_or_value(cache_policy) if cache_policy is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_descriptor_ptr(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def tma_bar(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def g_stride(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def mcast_mask(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def cache_policy(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_tma_load(result, tma_descriptor_ptr, tma_bar, g_stride, *, mcast_mask=None, cache_policy=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeTmaLoadOp(result=result, tma_descriptor_ptr=tma_descriptor_ptr, tma_bar=tma_bar, g_stride=g_stride, mcast_mask=mcast_mask, cache_policy=cache_policy, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeTmaReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_tma_reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tma_descriptor_ptr, g_stride, *, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_descriptor_ptr))
    operands.append(_get_op_result_or_value(g_stride))
    if cache_policy is not None: operands.append(_get_op_result_or_value(cache_policy))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_descriptor_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def g_stride(self):
    return self.operation.operands[1]

  @builtins.property
  def cache_policy(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_tma_reduce(result, tma_descriptor_ptr, g_stride, *, cache_policy=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeTmaReduceOp(result=result, tma_descriptor_ptr=tma_descriptor_ptr, g_stride=g_stride, cache_policy=cache_policy, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeTmaStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_tma_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, tma_descriptor_ptr, g_stride, *, cache_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_descriptor_ptr))
    operands.append(_get_op_result_or_value(g_stride))
    if cache_policy is not None: operands.append(_get_op_result_or_value(cache_policy))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_descriptor_ptr(self):
    return self.operation.operands[0]

  @builtins.property
  def g_stride(self):
    return self.operation.operands[1]

  @builtins.property
  def cache_policy(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_tma_store(result, tma_descriptor_ptr, g_stride, *, cache_policy=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeTmaStoreOp(result=result, tma_descriptor_ptr=tma_descriptor_ptr, g_stride=g_stride, cache_policy=cache_policy, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomCopyMakeTmemCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.make_tmem_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, tmem_memref, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(tmem_memref))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def tmem_memref(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_make_tmem_copy(atom, tmem_memref, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomCopyMakeTmemCopyOp(atom=atom, tmem_memref=tmem_memref, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomGetCoordTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.get_coord_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, shape, *, offset_b=None, layout_b=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(shape))
    if offset_b is not None: operands.append(_get_op_result_or_value(offset_b))
    if layout_b is not None: operands.append(_get_op_result_or_value(layout_b))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def shape(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def offset_b(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def layout_b(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_get_coord_tensor(atom, shape, *, offset_b=None, layout_b=None, loc=None, ip=None) -> _ods_ir.Value:
  return AtomGetCoordTensorOp(atom=atom, shape=shape, offset_b=offset_b, layout_b=layout_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomGetCopyS2TSmemDescViewOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.get_copy_s2t_smem_desc_view"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, view, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(view))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def view(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_get_copy_s2t_smem_desc_view(atom, view, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomGetCopyS2TSmemDescViewOp(atom=atom, view=view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomGetValueOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.get_value"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, atom, field, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["field"] = (field if (
    isinstance(field, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(field, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def field(self):
    return self.operation.attributes["field"]

  @field.setter
  def field(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["field"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_get_value(result, atom, field, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomGetValueOp(result=result, atom=atom, field=field, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomMmaMakeSM120BlockScaledOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_sm120_mma_bs"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sf_a, sf_b, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(sf_a))
    operands.append(_get_op_result_or_value(sf_b))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sf_a(self):
    return self.operation.operands[0]

  @builtins.property
  def sf_b(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_sm120_mma_bs(result, sf_a, sf_b, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomMmaMakeSM120BlockScaledOp(result=result, sf_a=sf_a, sf_b=sf_b, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomSetValueOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.set_value"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, field, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["field"] = (field if (
    isinstance(field, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(field, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.operands[1]

  @builtins.property
  def field(self):
    return self.operation.attributes["field"]

  @field.setter
  def field(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["field"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def atom_set_value(atom, field, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AtomSetValueOp(atom=atom, field=field, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomTmaPartitionOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.atom.tma_partition"

  _ODS_REGIONS = (0, True)

  def __init__(self, tma_atom, cta_coord, cta_layout, smem_tensor, gmem_tensor, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_atom))
    operands.append(_get_op_result_or_value(cta_coord))
    operands.append(_get_op_result_or_value(cta_layout))
    operands.append(_get_op_result_or_value(smem_tensor))
    operands.append(_get_op_result_or_value(gmem_tensor))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_atom(self):
    return self.operation.operands[0]

  @builtins.property
  def cta_coord(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_layout(self):
    return self.operation.operands[2]

  @builtins.property
  def smem_tensor(self):
    return self.operation.operands[3]

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[4]

  @builtins.property
  def res_smem_tensor(self):
    return self.operation.results[0]

  @builtins.property
  def res_gmem_tensor(self):
    return self.operation.results[1]

def atom_tma_partition(tma_atom, cta_coord, cta_layout, smem_tensor, gmem_tensor, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AtomTmaPartitionOp(tma_atom=tma_atom, cta_coord=cta_coord, cta_layout=cta_layout, smem_tensor=smem_tensor, gmem_tensor=gmem_tensor, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class CastTMADescToIntegerOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.cast_tma_desc_to_integer"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(dst)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def dst(self):
    return self.operation.results[0]

def cast_tma_desc_to_integer(dst, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return CastTMADescToIntegerOp(dst=dst, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyTMADescriptorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.copy_tma_desc"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, tma_desc_ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    operands.append(_get_op_result_or_value(tma_desc_ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

  @builtins.property
  def tma_desc_ptr(self):
    return self.operation.operands[1]

def copy_tma_desc(atom, tma_desc_ptr, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CopyTMADescriptorOp(atom=atom, tma_desc_ptr=tma_desc_ptr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GetGridConstantPointerOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.get_grid_constant_pointer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def get_grid_constant_pointer(result, input, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetGridConstantPointerOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetTmaDescAddrOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.get_tma_desc_addr"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, src, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(ptr)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr(self):
    return self.operation.results[0]

def get_tma_desc_addr(ptr, src, *, loc=None, ip=None) -> _ods_ir.Value:
  return GetTmaDescAddrOp(ptr=ptr, src=src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeGMMASmemDescOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_gmma_smem_desc"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, layout, major, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteLayoutAttr')) else
      _ods_ir.AttrBuilder.get('CuteLayoutAttr')(layout, context=_ods_context))
    attributes["major"] = (major if (
    isinstance(major, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMajorModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteMajorModeAttr')(major, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def major(self):
    return self.operation.attributes["major"]

  @major.setter
  def major(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["major"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def make_gmma_smem_desc(src, layout, major, *, loc=None, ip=None) -> _ods_ir.Value:
  return MakeGMMASmemDescOp(src=src, layout=layout, major=major, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTmaDescIm2ColAtOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_tma_desc_im2col_at"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_view, smem_layout, cta_value_tile, lower_corner_whd, upper_corner_whd, lower_padding_whd, upper_padding_whd, stride_whd, lower_srt, stride_srt, tma_desc_addr, *, num_multicast=None, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_view))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_value_tile))
    operands.append(_get_op_result_or_value(lower_corner_whd))
    operands.append(_get_op_result_or_value(upper_corner_whd))
    operands.append(_get_op_result_or_value(lower_padding_whd))
    operands.append(_get_op_result_or_value(upper_padding_whd))
    operands.append(_get_op_result_or_value(stride_whd))
    operands.append(_get_op_result_or_value(lower_srt))
    operands.append(_get_op_result_or_value(stride_srt))
    operands.append(_get_op_result_or_value(tma_desc_addr))
    _ods_context = _ods_get_default_loc_context(loc)
    if num_multicast is not None: attributes["num_multicast"] = (num_multicast if (
        isinstance(num_multicast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(num_multicast, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_view(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_value_tile(self):
    return self.operation.operands[2]

  @builtins.property
  def lower_corner_whd(self):
    return self.operation.operands[3]

  @builtins.property
  def upper_corner_whd(self):
    return self.operation.operands[4]

  @builtins.property
  def lower_padding_whd(self):
    return self.operation.operands[5]

  @builtins.property
  def upper_padding_whd(self):
    return self.operation.operands[6]

  @builtins.property
  def stride_whd(self):
    return self.operation.operands[7]

  @builtins.property
  def lower_srt(self):
    return self.operation.operands[8]

  @builtins.property
  def stride_srt(self):
    return self.operation.operands[9]

  @builtins.property
  def tma_desc_addr(self):
    return self.operation.operands[10]

  @builtins.property
  def num_multicast(self):
    if "num_multicast" not in self.operation.attributes:
      return None
    return self.operation.attributes["num_multicast"]

  @num_multicast.setter
  def num_multicast(self, value):
    if value is not None:
      self.operation.attributes["num_multicast"] = value
    elif "num_multicast" in self.operation.attributes:
      del self.operation.attributes["num_multicast"]

  @num_multicast.deleter
  def num_multicast(self):
    del self.operation.attributes["num_multicast"]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

def make_tma_desc_im2col_at(gmem_view, smem_layout, cta_value_tile, lower_corner_whd, upper_corner_whd, lower_padding_whd, upper_padding_whd, stride_whd, lower_srt, stride_srt, tma_desc_addr, *, num_multicast=None, tma_format=None, loc=None, ip=None) -> _ods_ir.Operation:
  return MakeTmaDescIm2ColAtOp(gmem_view=gmem_view, smem_layout=smem_layout, cta_value_tile=cta_value_tile, lower_corner_whd=lower_corner_whd, upper_corner_whd=upper_corner_whd, lower_padding_whd=lower_padding_whd, upper_padding_whd=upper_padding_whd, stride_whd=stride_whd, lower_srt=lower_srt, stride_srt=stride_srt, tma_desc_addr=tma_desc_addr, num_multicast=num_multicast, tma_format=tma_format, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MakeTmaDescIm2ColOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_tma_desc_im2col"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, gmem_view, smem_layout, cta_value_tile, lower_corner_whd, upper_corner_whd, lower_padding_whd, upper_padding_whd, stride_whd, lower_srt, stride_srt, *, num_multicast=None, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_view))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_value_tile))
    operands.append(_get_op_result_or_value(lower_corner_whd))
    operands.append(_get_op_result_or_value(upper_corner_whd))
    operands.append(_get_op_result_or_value(lower_padding_whd))
    operands.append(_get_op_result_or_value(upper_padding_whd))
    operands.append(_get_op_result_or_value(stride_whd))
    operands.append(_get_op_result_or_value(lower_srt))
    operands.append(_get_op_result_or_value(stride_srt))
    _ods_context = _ods_get_default_loc_context(loc)
    if num_multicast is not None: attributes["num_multicast"] = (num_multicast if (
        isinstance(num_multicast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(num_multicast, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_view(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_value_tile(self):
    return self.operation.operands[2]

  @builtins.property
  def lower_corner_whd(self):
    return self.operation.operands[3]

  @builtins.property
  def upper_corner_whd(self):
    return self.operation.operands[4]

  @builtins.property
  def lower_padding_whd(self):
    return self.operation.operands[5]

  @builtins.property
  def upper_padding_whd(self):
    return self.operation.operands[6]

  @builtins.property
  def stride_whd(self):
    return self.operation.operands[7]

  @builtins.property
  def lower_srt(self):
    return self.operation.operands[8]

  @builtins.property
  def stride_srt(self):
    return self.operation.operands[9]

  @builtins.property
  def num_multicast(self):
    if "num_multicast" not in self.operation.attributes:
      return None
    return self.operation.attributes["num_multicast"]

  @num_multicast.setter
  def num_multicast(self, value):
    if value is not None:
      self.operation.attributes["num_multicast"] = value
    elif "num_multicast" in self.operation.attributes:
      del self.operation.attributes["num_multicast"]

  @num_multicast.deleter
  def num_multicast(self):
    del self.operation.attributes["num_multicast"]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tma_desc_im2col(result, gmem_view, smem_layout, cta_value_tile, lower_corner_whd, upper_corner_whd, lower_padding_whd, upper_padding_whd, stride_whd, lower_srt, stride_srt, *, num_multicast=None, tma_format=None, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTmaDescIm2ColOp(result=result, gmem_view=gmem_view, smem_layout=smem_layout, cta_value_tile=cta_value_tile, lower_corner_whd=lower_corner_whd, upper_corner_whd=upper_corner_whd, lower_padding_whd=lower_padding_whd, upper_padding_whd=upper_padding_whd, stride_whd=stride_whd, lower_srt=lower_srt, stride_srt=stride_srt, num_multicast=num_multicast, tma_format=tma_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeTmaDescTiledAtOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_tma_desc_tiled_at"

  _ODS_REGIONS = (0, True)

  def __init__(self, gmem_view, smem_layout, cta_value_tile, tma_desc_addr, mode, *, num_multicast=None, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_view))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_value_tile))
    operands.append(_get_op_result_or_value(tma_desc_addr))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteTmaLoadModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteTmaLoadModeAttr')(mode, context=_ods_context))
    if num_multicast is not None: attributes["num_multicast"] = (num_multicast if (
        isinstance(num_multicast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(num_multicast, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_view(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_value_tile(self):
    return self.operation.operands[2]

  @builtins.property
  def tma_desc_addr(self):
    return self.operation.operands[3]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def num_multicast(self):
    if "num_multicast" not in self.operation.attributes:
      return None
    return self.operation.attributes["num_multicast"]

  @num_multicast.setter
  def num_multicast(self, value):
    if value is not None:
      self.operation.attributes["num_multicast"] = value
    elif "num_multicast" in self.operation.attributes:
      del self.operation.attributes["num_multicast"]

  @num_multicast.deleter
  def num_multicast(self):
    del self.operation.attributes["num_multicast"]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

def make_tma_desc_tiled_at(gmem_view, smem_layout, cta_value_tile, tma_desc_addr, mode, *, num_multicast=None, tma_format=None, loc=None, ip=None) -> _ods_ir.Operation:
  return MakeTmaDescTiledAtOp(gmem_view=gmem_view, smem_layout=smem_layout, cta_value_tile=cta_value_tile, tma_desc_addr=tma_desc_addr, mode=mode, num_multicast=num_multicast, tma_format=tma_format, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MakeTmaDescTiledOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_tma_desc_tiled"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, gmem_view, smem_layout, cta_value_tile, mode, *, num_multicast=None, tma_format=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(gmem_view))
    operands.append(_get_op_result_or_value(smem_layout))
    operands.append(_get_op_result_or_value(cta_value_tile))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    isinstance(mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteTmaLoadModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteTmaLoadModeAttr')(mode, context=_ods_context))
    if num_multicast is not None: attributes["num_multicast"] = (num_multicast if (
        isinstance(num_multicast, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(num_multicast, context=_ods_context))
    if tma_format is not None: attributes["tma_format"] = (tma_format if (
        isinstance(tma_format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CuteTmaDataFormatAttr')) else
          _ods_ir.AttrBuilder.get('CuteTmaDataFormatAttr')(tma_format, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def gmem_view(self):
    return self.operation.operands[0]

  @builtins.property
  def smem_layout(self):
    return self.operation.operands[1]

  @builtins.property
  def cta_value_tile(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def num_multicast(self):
    if "num_multicast" not in self.operation.attributes:
      return None
    return self.operation.attributes["num_multicast"]

  @num_multicast.setter
  def num_multicast(self, value):
    if value is not None:
      self.operation.attributes["num_multicast"] = value
    elif "num_multicast" in self.operation.attributes:
      del self.operation.attributes["num_multicast"]

  @num_multicast.deleter
  def num_multicast(self):
    del self.operation.attributes["num_multicast"]

  @builtins.property
  def tma_format(self):
    if "tma_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["tma_format"]

  @tma_format.setter
  def tma_format(self, value):
    if value is not None:
      self.operation.attributes["tma_format"] = value
    elif "tma_format" in self.operation.attributes:
      del self.operation.attributes["tma_format"]

  @tma_format.deleter
  def tma_format(self):
    del self.operation.attributes["tma_format"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def make_tma_desc_tiled(result, gmem_view, smem_layout, cta_value_tile, mode, *, num_multicast=None, tma_format=None, loc=None, ip=None) -> _ods_ir.Value:
  return MakeTmaDescTiledOp(result=result, gmem_view=gmem_view, smem_layout=smem_layout, cta_value_tile=cta_value_tile, mode=mode, num_multicast=num_multicast, tma_format=tma_format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MakeUMMASmemDescOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.make_umma_smem_desc"

  _ODS_REGIONS = (0, True)

  def __init__(self, src, layout, major, *, nextSrc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    if nextSrc is not None: operands.append(_get_op_result_or_value(nextSrc))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteLayoutAttr')) else
      _ods_ir.AttrBuilder.get('CuteLayoutAttr')(layout, context=_ods_context))
    attributes["major"] = (major if (
    isinstance(major, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CuteMajorModeAttr')) else
      _ods_ir.AttrBuilder.get('CuteMajorModeAttr')(major, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    return self.operation.operands[0]

  @builtins.property
  def nextSrc(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def major(self):
    return self.operation.attributes["major"]

  @major.setter
  def major(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["major"] = value

  @builtins.property
  def res(self):
    return self.operation.results[0]

def make_umma_smem_desc(src, layout, major, *, next_src=None, loc=None, ip=None) -> _ods_ir.Value:
  return MakeUMMASmemDescOp(src=src, layout=layout, major=major, nextSrc=next_src, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrefetchTmaDescriptorOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.prefetch_tma_desc"

  _ODS_REGIONS = (0, True)

  def __init__(self, atom, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(atom))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def atom(self):
    return self.operation.operands[0]

def prefetch_tma_desc(atom, *, loc=None, ip=None) -> _ods_ir.Operation:
  return PrefetchTmaDescriptorOp(atom=atom, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UpdateTMADescOp(_ods_ir.OpView):
  OPERATION_NAME = "cute_nvgpu.update_tma_desc"

  _ODS_REGIONS = (0, True)

  def __init__(self, tma_atom, gmem_tensor, tma_desc_ptr, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(tma_atom))
    operands.append(_get_op_result_or_value(gmem_tensor))
    operands.append(_get_op_result_or_value(tma_desc_ptr))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tma_atom(self):
    return self.operation.operands[0]

  @builtins.property
  def gmem_tensor(self):
    return self.operation.operands[1]

  @builtins.property
  def tma_desc_ptr(self):
    return self.operation.operands[2]

def update_tma_desc(tma_atom, gmem_tensor, tma_desc_ptr, *, loc=None, ip=None) -> _ods_ir.Operation:
  return UpdateTMADescOp(tma_atom=tma_atom, gmem_tensor=gmem_tensor, tma_desc_ptr=tma_desc_ptr, loc=loc, ip=ip)
