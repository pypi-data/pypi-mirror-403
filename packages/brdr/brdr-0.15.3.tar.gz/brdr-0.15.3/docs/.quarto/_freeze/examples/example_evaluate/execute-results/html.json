{
  "hash": "38a4ba5bf5c7daf6992b43ab4932d773",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Evaluation\ndescription: Example of a simple Evaluation by using **brdr**\nauthor: Karel Dieussaert\ndate: '2026-01-07'\ncategories:\n  - Evaluation\nformat:\n  html:\n    code-fold: false\n---\n\n# Evaluation\nThis example shows a simple Evaluation by using **brdr**\n\n::: {#fig-plots .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nfrom brdr.aligner import Aligner\nfrom brdr.be.grb.enums import GRBType\nfrom brdr.be.grb.loader import GRBActualLoader\nfrom brdr.constants import (\n    EVALUATION_FIELD_NAME,\n    RELEVANT_DISTANCE_FIELD_NAME,\n    PREDICTION_SCORE,\n)\nfrom brdr.enums import AlignerResultType, FullReferenceStrategy\nfrom brdr.geometry_utils import geom_from_wkt\nfrom brdr.loader import DictLoader\n\n# Press the green button in the gutter to run the script.\nif __name__ == \"__main__\":\n    \"\"\"\n    EXAMPLE of the 'evaluate()-function of 'brdr': This function evaluates thematic objects with a former brdr_observation and compares them with an actual observation; and adds evaluation-properties to the result\n    \"\"\"\n\n    # Start an aligner to align thematic objects on the actual parcels\n    aligner = Aligner(crs=\"EPSG:31370\")\n    # Define the range of relevant distances to search for predictions\n    relevant_distances = np.arange(0, 400, 10, dtype=int) / 100\n    # Define the input geometry\n    input_geometry_wkt = \"POLYGON ((174099.53572337731020525 179375.43192003236617893, 174116.23475504826637916 179372.81056040961993858, 174109.5357249012158718 179324.16977629828033969, 174094.68135370552772656 179324.75230065890355036, 174099.53572337731020525 179375.43192003236617893))\"\n    thematic_dict = {\"id_1\": geom_from_wkt(input_geometry_wkt)}\n    loader = DictLoader(data_dict=thematic_dict)\n\n    # Load the input geometry into the Aligner\n    aligner.load_thematic_data(loader)\n\n    # Load reference data (in this case we use a on-the-fly reference loader to load the actual parcels of Flanders (GRB)\n    aligner.load_reference_data(\n        GRBActualLoader(grb_type=GRBType.ADP, partition=1000, aligner=aligner)\n    )\n\n    # Use the EVALUATE-function\n    aligner_result = aligner.evaluate(\n        relevant_distances=relevant_distances,\n        thematic_ids=None,\n        metadata_field=None,\n        full_reference_strategy=FullReferenceStrategy.PREFER_FULL_REFERENCE,\n    )\n\n    # Get the EVALUATED results as GEOJSON\n    fc = aligner_result.get_results_as_geojson(\n        result_type=AlignerResultType.EVALUATED_PREDICTIONS,\n        add_metadata=True,\n        add_original_attributes=True,\n        aligner=aligner,\n    )\n    # Loop these results to print the results\n    for feature in fc[\"result\"][\"features\"]:\n        print(\n            feature[\"properties\"][aligner.thematic_data.id_fieldname]\n            + \": \"\n            + feature[\"properties\"][EVALUATION_FIELD_NAME]\n            + \" - score \"\n            + str(feature[\"properties\"][PREDICTION_SCORE])\n            + \" - distance \"\n            + str(feature[\"properties\"][RELEVANT_DISTANCE_FIELD_NAME])\n        )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nid_1: prediction_unique_full - score 100 - distance 1.4\n```\n:::\n:::\n\n\n",
    "supporting": [
      "example_evaluate_files"
    ],
    "filters": [],
    "includes": {}
  }
}