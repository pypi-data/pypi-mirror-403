from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ..._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import constructs as _constructs_77d1e7e8
from ...core import IMixin as _IMixin_11e4b965, Mixin as _Mixin_a69446c0
from ...mixins import (
    CfnPropertyMixinOptions as _CfnPropertyMixinOptions_9cbff649,
    PropertyMergeStrategy as _PropertyMergeStrategy_49c157e8,
)


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "account_id": "accountId",
        "audit_check_configurations": "auditCheckConfigurations",
        "audit_notification_target_configurations": "auditNotificationTargetConfigurations",
        "role_arn": "roleArn",
    },
)
class CfnAccountAuditConfigurationMixinProps:
    def __init__(
        self,
        *,
        account_id: typing.Optional[builtins.str] = None,
        audit_check_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        audit_notification_target_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        role_arn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnAccountAuditConfigurationPropsMixin.

        :param account_id: The ID of the account. You can use the expression ``!Sub "${AWS::AccountId}"`` to use your account ID.
        :param audit_check_configurations: Specifies which audit checks are enabled and disabled for this account. Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted. To disable a check, set the value of the ``Enabled:`` key to ``false`` . If an enabled check is removed from the template, it will also be disabled. You can't disable a check if it's used by any scheduled audit. You must delete the check from the scheduled audit or delete the scheduled audit itself to disable the check. For more information on available audit checks see `AWS::IoT::AccountAuditConfiguration AuditCheckConfigurations <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html>`_
        :param audit_notification_target_configurations: Information about the targets to which audit notifications are sent.
        :param role_arn: The Amazon Resource Name (ARN) of the role that grants permission to AWS IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_account_audit_configuration_mixin_props = iot_mixins.CfnAccountAuditConfigurationMixinProps(
                account_id="accountId",
                audit_check_configurations=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty(
                    authenticated_cognito_role_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    ca_certificate_expiring_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    ca_certificate_key_quality_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    conflicting_client_ids_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    device_certificate_age_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty(
                        configuration=iot_mixins.CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty(
                            cert_age_threshold_in_days="certAgeThresholdInDays"
                        ),
                        enabled=False
                    ),
                    device_certificate_expiring_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    device_certificate_key_quality_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    device_certificate_shared_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    intermediate_ca_revoked_for_active_device_certificates_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    iot_policy_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    io_tPolicy_potential_mis_configuration_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    iot_role_alias_allows_access_to_unused_services_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    iot_role_alias_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    logging_disabled_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    revoked_ca_certificate_still_active_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    revoked_device_certificate_still_active_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    unauthenticated_cognito_role_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    )
                ),
                audit_notification_target_configurations=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty(
                    sns=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty(
                        enabled=False,
                        role_arn="roleArn",
                        target_arn="targetArn"
                    )
                ),
                role_arn="roleArn"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de1be116e36defd0db9ab597939940b477859ac83c99632b8c593b3ebafc0b0b)
            check_type(argname="argument account_id", value=account_id, expected_type=type_hints["account_id"])
            check_type(argname="argument audit_check_configurations", value=audit_check_configurations, expected_type=type_hints["audit_check_configurations"])
            check_type(argname="argument audit_notification_target_configurations", value=audit_notification_target_configurations, expected_type=type_hints["audit_notification_target_configurations"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if account_id is not None:
            self._values["account_id"] = account_id
        if audit_check_configurations is not None:
            self._values["audit_check_configurations"] = audit_check_configurations
        if audit_notification_target_configurations is not None:
            self._values["audit_notification_target_configurations"] = audit_notification_target_configurations
        if role_arn is not None:
            self._values["role_arn"] = role_arn

    @builtins.property
    def account_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the account.

        You can use the expression ``!Sub "${AWS::AccountId}"`` to use your account ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html#cfn-iot-accountauditconfiguration-accountid
        '''
        result = self._values.get("account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def audit_check_configurations(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty"]]:
        '''Specifies which audit checks are enabled and disabled for this account.

        Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted. To disable a check, set the value of the ``Enabled:`` key to ``false`` .

        If an enabled check is removed from the template, it will also be disabled.

        You can't disable a check if it's used by any scheduled audit. You must delete the check from the scheduled audit or delete the scheduled audit itself to disable the check.

        For more information on available audit checks see `AWS::IoT::AccountAuditConfiguration AuditCheckConfigurations <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations
        '''
        result = self._values.get("audit_check_configurations")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty"]], result)

    @builtins.property
    def audit_notification_target_configurations(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty"]]:
        '''Information about the targets to which audit notifications are sent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html#cfn-iot-accountauditconfiguration-auditnotificationtargetconfigurations
        '''
        result = self._values.get("audit_notification_target_configurations")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty"]], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the role that grants permission to AWS IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html#cfn-iot-accountauditconfiguration-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnAccountAuditConfigurationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnAccountAuditConfigurationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin",
):
    '''Use the ``AWS::IoT::AccountAuditConfiguration`` resource to configure or reconfigure the Device Defender audit settings for your account.

    Settings include how audit notifications are sent and which audit checks are enabled or disabled. For API reference, see `UpdateAccountAuditConfiguration <https://docs.aws.amazon.com/iot/latest/apireference/API_UpdateAccountAuditConfiguration.html>`_ and for detailed information on all available audit checks, see `Audit checks <https://docs.aws.amazon.com/iot/latest/developerguide/device-defender-audit-checks.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html
    :cloudformationResource: AWS::IoT::AccountAuditConfiguration
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_account_audit_configuration_props_mixin = iot_mixins.CfnAccountAuditConfigurationPropsMixin(iot_mixins.CfnAccountAuditConfigurationMixinProps(
            account_id="accountId",
            audit_check_configurations=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty(
                authenticated_cognito_role_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                ca_certificate_expiring_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                ca_certificate_key_quality_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                conflicting_client_ids_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                device_certificate_age_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty(
                    configuration=iot_mixins.CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty(
                        cert_age_threshold_in_days="certAgeThresholdInDays"
                    ),
                    enabled=False
                ),
                device_certificate_expiring_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                device_certificate_key_quality_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                device_certificate_shared_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                intermediate_ca_revoked_for_active_device_certificates_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                iot_policy_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                io_tPolicy_potential_mis_configuration_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                iot_role_alias_allows_access_to_unused_services_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                iot_role_alias_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                logging_disabled_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                revoked_ca_certificate_still_active_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                revoked_device_certificate_still_active_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                ),
                unauthenticated_cognito_role_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                )
            ),
            audit_notification_target_configurations=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty(
                sns=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty(
                    enabled=False,
                    role_arn="roleArn",
                    target_arn="targetArn"
                )
            ),
            role_arn="roleArn"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnAccountAuditConfigurationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::AccountAuditConfiguration``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f7c4aed6881efe8f21dd3828d4ec73410f1898b04708818c2fc360b0f77f2d9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ccb486ef57a4f68c84d58c40dbaf0164d5af10bca464d407322ec6f05291ef5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9296feb9b3f0cf501cda053d4e717322fbeb43085fee49d5b7411b9bfecd043b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnAccountAuditConfigurationMixinProps":
        return typing.cast("CfnAccountAuditConfigurationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class AuditCheckConfigurationProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Which audit checks are enabled and disabled for this account.

            :param enabled: True if this audit check is enabled for this account.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                audit_check_configuration_property = iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2865d13c19787979ffe8edca41a146f0b42eb8cb6d49443ce7c43c4bf8a6b794)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''True if this audit check is enabled for this account.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfiguration.html#cfn-iot-accountauditconfiguration-auditcheckconfiguration-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AuditCheckConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "authenticated_cognito_role_overly_permissive_check": "authenticatedCognitoRoleOverlyPermissiveCheck",
            "ca_certificate_expiring_check": "caCertificateExpiringCheck",
            "ca_certificate_key_quality_check": "caCertificateKeyQualityCheck",
            "conflicting_client_ids_check": "conflictingClientIdsCheck",
            "device_certificate_age_check": "deviceCertificateAgeCheck",
            "device_certificate_expiring_check": "deviceCertificateExpiringCheck",
            "device_certificate_key_quality_check": "deviceCertificateKeyQualityCheck",
            "device_certificate_shared_check": "deviceCertificateSharedCheck",
            "intermediate_ca_revoked_for_active_device_certificates_check": "intermediateCaRevokedForActiveDeviceCertificatesCheck",
            "iot_policy_overly_permissive_check": "iotPolicyOverlyPermissiveCheck",
            "io_t_policy_potential_mis_configuration_check": "ioTPolicyPotentialMisConfigurationCheck",
            "iot_role_alias_allows_access_to_unused_services_check": "iotRoleAliasAllowsAccessToUnusedServicesCheck",
            "iot_role_alias_overly_permissive_check": "iotRoleAliasOverlyPermissiveCheck",
            "logging_disabled_check": "loggingDisabledCheck",
            "revoked_ca_certificate_still_active_check": "revokedCaCertificateStillActiveCheck",
            "revoked_device_certificate_still_active_check": "revokedDeviceCertificateStillActiveCheck",
            "unauthenticated_cognito_role_overly_permissive_check": "unauthenticatedCognitoRoleOverlyPermissiveCheck",
        },
    )
    class AuditCheckConfigurationsProperty:
        def __init__(
            self,
            *,
            authenticated_cognito_role_overly_permissive_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ca_certificate_expiring_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ca_certificate_key_quality_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            conflicting_client_ids_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            device_certificate_age_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            device_certificate_expiring_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            device_certificate_key_quality_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            device_certificate_shared_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            intermediate_ca_revoked_for_active_device_certificates_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iot_policy_overly_permissive_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            io_t_policy_potential_mis_configuration_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iot_role_alias_allows_access_to_unused_services_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iot_role_alias_overly_permissive_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            logging_disabled_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            revoked_ca_certificate_still_active_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            revoked_device_certificate_still_active_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            unauthenticated_cognito_role_overly_permissive_check: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The types of audit checks that can be performed.

            :param authenticated_cognito_role_overly_permissive_check: Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.
            :param ca_certificate_expiring_check: Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.
            :param ca_certificate_key_quality_check: Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are ``ACTIVE`` or ``PENDING_TRANSFER`` .
            :param conflicting_client_ids_check: Checks if multiple devices connect using the same client ID.
            :param device_certificate_age_check: Checks when a device certificate has been active for a number of days greater than or equal to the number you specify.
            :param device_certificate_expiring_check: Checks if a device certificate is expiring. By default, this check applies to device certificates expiring within 30 days or that have expired. You can modify this threshold by configuring the DeviceCertExpirationAuditCheckConfiguration.
            :param device_certificate_key_quality_check: Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.
            :param device_certificate_shared_check: Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .
            :param intermediate_ca_revoked_for_active_device_certificates_check: Checks if device certificates are still active despite being revoked by an intermediate CA.
            :param iot_policy_overly_permissive_check: Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.
            :param io_t_policy_potential_mis_configuration_check: Checks if an AWS IoT policy is potentially misconfigured. Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.
            :param iot_role_alias_allows_access_to_unused_services_check: Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.
            :param iot_role_alias_overly_permissive_check: Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.
            :param logging_disabled_check: Checks if AWS IoT logs are disabled.
            :param revoked_ca_certificate_still_active_check: Checks if a revoked CA certificate is still active.
            :param revoked_device_certificate_still_active_check: Checks if a revoked device certificate is still active.
            :param unauthenticated_cognito_role_overly_permissive_check: Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                audit_check_configurations_property = iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty(
                    authenticated_cognito_role_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    ca_certificate_expiring_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    ca_certificate_key_quality_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    conflicting_client_ids_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    device_certificate_age_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty(
                        configuration=iot_mixins.CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty(
                            cert_age_threshold_in_days="certAgeThresholdInDays"
                        ),
                        enabled=False
                    ),
                    device_certificate_expiring_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    device_certificate_key_quality_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    device_certificate_shared_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    intermediate_ca_revoked_for_active_device_certificates_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    iot_policy_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    io_tPolicy_potential_mis_configuration_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    iot_role_alias_allows_access_to_unused_services_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    iot_role_alias_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    logging_disabled_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    revoked_ca_certificate_still_active_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    revoked_device_certificate_still_active_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    ),
                    unauthenticated_cognito_role_overly_permissive_check=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty(
                        enabled=False
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3df4090a778b3ae0a128804cd08bb6b9c9f811f09f529f4ddfd9a5e452fb03f0)
                check_type(argname="argument authenticated_cognito_role_overly_permissive_check", value=authenticated_cognito_role_overly_permissive_check, expected_type=type_hints["authenticated_cognito_role_overly_permissive_check"])
                check_type(argname="argument ca_certificate_expiring_check", value=ca_certificate_expiring_check, expected_type=type_hints["ca_certificate_expiring_check"])
                check_type(argname="argument ca_certificate_key_quality_check", value=ca_certificate_key_quality_check, expected_type=type_hints["ca_certificate_key_quality_check"])
                check_type(argname="argument conflicting_client_ids_check", value=conflicting_client_ids_check, expected_type=type_hints["conflicting_client_ids_check"])
                check_type(argname="argument device_certificate_age_check", value=device_certificate_age_check, expected_type=type_hints["device_certificate_age_check"])
                check_type(argname="argument device_certificate_expiring_check", value=device_certificate_expiring_check, expected_type=type_hints["device_certificate_expiring_check"])
                check_type(argname="argument device_certificate_key_quality_check", value=device_certificate_key_quality_check, expected_type=type_hints["device_certificate_key_quality_check"])
                check_type(argname="argument device_certificate_shared_check", value=device_certificate_shared_check, expected_type=type_hints["device_certificate_shared_check"])
                check_type(argname="argument intermediate_ca_revoked_for_active_device_certificates_check", value=intermediate_ca_revoked_for_active_device_certificates_check, expected_type=type_hints["intermediate_ca_revoked_for_active_device_certificates_check"])
                check_type(argname="argument iot_policy_overly_permissive_check", value=iot_policy_overly_permissive_check, expected_type=type_hints["iot_policy_overly_permissive_check"])
                check_type(argname="argument io_t_policy_potential_mis_configuration_check", value=io_t_policy_potential_mis_configuration_check, expected_type=type_hints["io_t_policy_potential_mis_configuration_check"])
                check_type(argname="argument iot_role_alias_allows_access_to_unused_services_check", value=iot_role_alias_allows_access_to_unused_services_check, expected_type=type_hints["iot_role_alias_allows_access_to_unused_services_check"])
                check_type(argname="argument iot_role_alias_overly_permissive_check", value=iot_role_alias_overly_permissive_check, expected_type=type_hints["iot_role_alias_overly_permissive_check"])
                check_type(argname="argument logging_disabled_check", value=logging_disabled_check, expected_type=type_hints["logging_disabled_check"])
                check_type(argname="argument revoked_ca_certificate_still_active_check", value=revoked_ca_certificate_still_active_check, expected_type=type_hints["revoked_ca_certificate_still_active_check"])
                check_type(argname="argument revoked_device_certificate_still_active_check", value=revoked_device_certificate_still_active_check, expected_type=type_hints["revoked_device_certificate_still_active_check"])
                check_type(argname="argument unauthenticated_cognito_role_overly_permissive_check", value=unauthenticated_cognito_role_overly_permissive_check, expected_type=type_hints["unauthenticated_cognito_role_overly_permissive_check"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if authenticated_cognito_role_overly_permissive_check is not None:
                self._values["authenticated_cognito_role_overly_permissive_check"] = authenticated_cognito_role_overly_permissive_check
            if ca_certificate_expiring_check is not None:
                self._values["ca_certificate_expiring_check"] = ca_certificate_expiring_check
            if ca_certificate_key_quality_check is not None:
                self._values["ca_certificate_key_quality_check"] = ca_certificate_key_quality_check
            if conflicting_client_ids_check is not None:
                self._values["conflicting_client_ids_check"] = conflicting_client_ids_check
            if device_certificate_age_check is not None:
                self._values["device_certificate_age_check"] = device_certificate_age_check
            if device_certificate_expiring_check is not None:
                self._values["device_certificate_expiring_check"] = device_certificate_expiring_check
            if device_certificate_key_quality_check is not None:
                self._values["device_certificate_key_quality_check"] = device_certificate_key_quality_check
            if device_certificate_shared_check is not None:
                self._values["device_certificate_shared_check"] = device_certificate_shared_check
            if intermediate_ca_revoked_for_active_device_certificates_check is not None:
                self._values["intermediate_ca_revoked_for_active_device_certificates_check"] = intermediate_ca_revoked_for_active_device_certificates_check
            if iot_policy_overly_permissive_check is not None:
                self._values["iot_policy_overly_permissive_check"] = iot_policy_overly_permissive_check
            if io_t_policy_potential_mis_configuration_check is not None:
                self._values["io_t_policy_potential_mis_configuration_check"] = io_t_policy_potential_mis_configuration_check
            if iot_role_alias_allows_access_to_unused_services_check is not None:
                self._values["iot_role_alias_allows_access_to_unused_services_check"] = iot_role_alias_allows_access_to_unused_services_check
            if iot_role_alias_overly_permissive_check is not None:
                self._values["iot_role_alias_overly_permissive_check"] = iot_role_alias_overly_permissive_check
            if logging_disabled_check is not None:
                self._values["logging_disabled_check"] = logging_disabled_check
            if revoked_ca_certificate_still_active_check is not None:
                self._values["revoked_ca_certificate_still_active_check"] = revoked_ca_certificate_still_active_check
            if revoked_device_certificate_still_active_check is not None:
                self._values["revoked_device_certificate_still_active_check"] = revoked_device_certificate_still_active_check
            if unauthenticated_cognito_role_overly_permissive_check is not None:
                self._values["unauthenticated_cognito_role_overly_permissive_check"] = unauthenticated_cognito_role_overly_permissive_check

        @builtins.property
        def authenticated_cognito_role_overly_permissive_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks the permissiveness of an authenticated Amazon Cognito identity pool role.

            For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-authenticatedcognitoroleoverlypermissivecheck
            '''
            result = self._values.get("authenticated_cognito_role_overly_permissive_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def ca_certificate_expiring_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if a CA certificate is expiring.

            This check applies to CA certificates expiring within 30 days or that have expired.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-cacertificateexpiringcheck
            '''
            result = self._values.get("ca_certificate_expiring_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def ca_certificate_key_quality_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks the quality of the CA certificate key.

            The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are ``ACTIVE`` or ``PENDING_TRANSFER`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-cacertificatekeyqualitycheck
            '''
            result = self._values.get("ca_certificate_key_quality_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def conflicting_client_ids_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if multiple devices connect using the same client ID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-conflictingclientidscheck
            '''
            result = self._values.get("conflicting_client_ids_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def device_certificate_age_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty"]]:
            '''Checks when a device certificate has been active for a number of days greater than or equal to the number you specify.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-devicecertificateagecheck
            '''
            result = self._values.get("device_certificate_age_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty"]], result)

        @builtins.property
        def device_certificate_expiring_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if a device certificate is expiring.

            By default, this check applies to device certificates expiring within 30 days or that have expired. You can modify this threshold by configuring the DeviceCertExpirationAuditCheckConfiguration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-devicecertificateexpiringcheck
            '''
            result = self._values.get("device_certificate_expiring_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def device_certificate_key_quality_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks the quality of the device certificate key.

            The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-devicecertificatekeyqualitycheck
            '''
            result = self._values.get("device_certificate_key_quality_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def device_certificate_shared_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-devicecertificatesharedcheck
            '''
            result = self._values.get("device_certificate_shared_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def intermediate_ca_revoked_for_active_device_certificates_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if device certificates are still active despite being revoked by an intermediate CA.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-intermediatecarevokedforactivedevicecertificatescheck
            '''
            result = self._values.get("intermediate_ca_revoked_for_active_device_certificates_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def iot_policy_overly_permissive_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-iotpolicyoverlypermissivecheck
            '''
            result = self._values.get("iot_policy_overly_permissive_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def io_t_policy_potential_mis_configuration_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if an AWS IoT policy is potentially misconfigured.

            Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-iotpolicypotentialmisconfigurationcheck
            '''
            result = self._values.get("io_t_policy_potential_mis_configuration_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def iot_role_alias_allows_access_to_unused_services_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-iotrolealiasallowsaccesstounusedservicescheck
            '''
            result = self._values.get("iot_role_alias_allows_access_to_unused_services_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def iot_role_alias_overly_permissive_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-iotrolealiasoverlypermissivecheck
            '''
            result = self._values.get("iot_role_alias_overly_permissive_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def logging_disabled_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if AWS IoT logs are disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-loggingdisabledcheck
            '''
            result = self._values.get("logging_disabled_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def revoked_ca_certificate_still_active_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if a revoked CA certificate is still active.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-revokedcacertificatestillactivecheck
            '''
            result = self._values.get("revoked_ca_certificate_still_active_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def revoked_device_certificate_still_active_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if a revoked device certificate is still active.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-revokeddevicecertificatestillactivecheck
            '''
            result = self._values.get("revoked_device_certificate_still_active_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        @builtins.property
        def unauthenticated_cognito_role_overly_permissive_check(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]]:
            '''Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html#cfn-iot-accountauditconfiguration-auditcheckconfigurations-unauthenticatedcognitoroleoverlypermissivecheck
            '''
            result = self._values.get("unauthenticated_cognito_role_overly_permissive_check")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AuditCheckConfigurationsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty",
        jsii_struct_bases=[],
        name_mapping={"sns": "sns"},
    )
    class AuditNotificationTargetConfigurationsProperty:
        def __init__(
            self,
            *,
            sns: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the audit notification target.

            :param sns: The ``Sns`` notification target.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtargetconfigurations.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                audit_notification_target_configurations_property = iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty(
                    sns=iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty(
                        enabled=False,
                        role_arn="roleArn",
                        target_arn="targetArn"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d54e393f14d2f122911f5230252deb15c10f1094ee1b9f3cc96998628cc13932)
                check_type(argname="argument sns", value=sns, expected_type=type_hints["sns"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if sns is not None:
                self._values["sns"] = sns

        @builtins.property
        def sns(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty"]]:
            '''The ``Sns`` notification target.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtargetconfigurations.html#cfn-iot-accountauditconfiguration-auditnotificationtargetconfigurations-sns
            '''
            result = self._values.get("sns")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AuditNotificationTargetConfigurationsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enabled": "enabled",
            "role_arn": "roleArn",
            "target_arn": "targetArn",
        },
    )
    class AuditNotificationTargetProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            role_arn: typing.Optional[builtins.str] = None,
            target_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Information about the targets to which audit notifications are sent.

            :param enabled: True if notifications to the target are enabled.
            :param role_arn: The ARN of the role that grants permission to send notifications to the target.
            :param target_arn: The ARN of the target (SNS topic) to which audit notifications are sent.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtarget.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                audit_notification_target_property = iot_mixins.CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty(
                    enabled=False,
                    role_arn="roleArn",
                    target_arn="targetArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bd4b946424347337d8db9afa587bbc5ece570da0a128af33b8d62f9d9bccf64f)
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument target_arn", value=target_arn, expected_type=type_hints["target_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if target_arn is not None:
                self._values["target_arn"] = target_arn

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''True if notifications to the target are enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtarget.html#cfn-iot-accountauditconfiguration-auditnotificationtarget-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role that grants permission to send notifications to the target.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtarget.html#cfn-iot-accountauditconfiguration-auditnotificationtarget-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the target (SNS topic) to which audit notifications are sent.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtarget.html#cfn-iot-accountauditconfiguration-auditnotificationtarget-targetarn
            '''
            result = self._values.get("target_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AuditNotificationTargetProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"cert_age_threshold_in_days": "certAgeThresholdInDays"},
    )
    class CertAgeCheckCustomConfigurationProperty:
        def __init__(
            self,
            *,
            cert_age_threshold_in_days: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration structure containing settings for the device certificate age check.

            :param cert_age_threshold_in_days: The number of days that defines when a device certificate is considered to have aged. The check will report a finding if a certificate has been active for a number of days greater than or equal to this threshold value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-certagecheckcustomconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                cert_age_check_custom_configuration_property = iot_mixins.CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty(
                    cert_age_threshold_in_days="certAgeThresholdInDays"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4f683595f2e39255ea67081ed623823ddbee5b5e852a4514f89e96586f3ee6f0)
                check_type(argname="argument cert_age_threshold_in_days", value=cert_age_threshold_in_days, expected_type=type_hints["cert_age_threshold_in_days"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cert_age_threshold_in_days is not None:
                self._values["cert_age_threshold_in_days"] = cert_age_threshold_in_days

        @builtins.property
        def cert_age_threshold_in_days(self) -> typing.Optional[builtins.str]:
            '''The number of days that defines when a device certificate is considered to have aged.

            The check will report a finding if a certificate has been active for a number of days greater than or equal to this threshold value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-certagecheckcustomconfiguration.html#cfn-iot-accountauditconfiguration-certagecheckcustomconfiguration-certagethresholdindays
            '''
            result = self._values.get("cert_age_threshold_in_days")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CertAgeCheckCustomConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"configuration": "configuration", "enabled": "enabled"},
    )
    class DeviceCertAgeAuditCheckConfigurationProperty:
        def __init__(
            self,
            *,
            configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Configuration for the device certificate age audit check.

            :param configuration: Configuration settings for the device certificate age check, including the threshold in days for certificate age. This configuration is of type ``CertAgeCheckCustomConfiguration`` .
            :param enabled: True if this audit check is enabled for this account.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-devicecertageauditcheckconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                device_cert_age_audit_check_configuration_property = iot_mixins.CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty(
                    configuration=iot_mixins.CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty(
                        cert_age_threshold_in_days="certAgeThresholdInDays"
                    ),
                    enabled=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8a6e49ab10d774dc080a5352577cdf4c85529aa60ee50fa269d68d4ecba46235)
                check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configuration is not None:
                self._values["configuration"] = configuration
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty"]]:
            '''Configuration settings for the device certificate age check, including the threshold in days for certificate age.

            This configuration is of type ``CertAgeCheckCustomConfiguration`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-devicecertageauditcheckconfiguration.html#cfn-iot-accountauditconfiguration-devicecertageauditcheckconfiguration-configuration
            '''
            result = self._values.get("configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty"]], result)

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''True if this audit check is enabled for this account.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-devicecertageauditcheckconfiguration.html#cfn-iot-accountauditconfiguration-devicecertageauditcheckconfiguration-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DeviceCertAgeAuditCheckConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAuthorizerMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "authorizer_function_arn": "authorizerFunctionArn",
        "authorizer_name": "authorizerName",
        "enable_caching_for_http": "enableCachingForHttp",
        "signing_disabled": "signingDisabled",
        "status": "status",
        "tags": "tags",
        "token_key_name": "tokenKeyName",
        "token_signing_public_keys": "tokenSigningPublicKeys",
    },
)
class CfnAuthorizerMixinProps:
    def __init__(
        self,
        *,
        authorizer_function_arn: typing.Optional[builtins.str] = None,
        authorizer_name: typing.Optional[builtins.str] = None,
        enable_caching_for_http: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        signing_disabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        status: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        token_key_name: typing.Optional[builtins.str] = None,
        token_signing_public_keys: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
    ) -> None:
        '''Properties for CfnAuthorizerPropsMixin.

        :param authorizer_function_arn: The authorizer's Lambda function ARN.
        :param authorizer_name: The authorizer name.
        :param enable_caching_for_http: When ``true`` , the result from the authorizer's Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in ``refreshAfterInSeconds`` . This value doesn't affect authorization of clients that use MQTT connections.
        :param signing_disabled: Specifies whether AWS IoT validates the token signature in an authorization request.
        :param status: The status of the authorizer. Valid values: ``ACTIVE`` | ``INACTIVE``
        :param tags: Metadata which can be used to manage the custom authorizer. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
        :param token_key_name: The key used to extract the token from the HTTP headers.
        :param token_signing_public_keys: The public keys used to validate the token signature returned by your custom authentication service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_authorizer_mixin_props = iot_mixins.CfnAuthorizerMixinProps(
                authorizer_function_arn="authorizerFunctionArn",
                authorizer_name="authorizerName",
                enable_caching_for_http=False,
                signing_disabled=False,
                status="status",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                token_key_name="tokenKeyName",
                token_signing_public_keys={
                    "token_signing_public_keys_key": "tokenSigningPublicKeys"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90a36dd8738ac0745c8fde3f93f2d56f064ba30eccae3d055cce2e041a89403f)
            check_type(argname="argument authorizer_function_arn", value=authorizer_function_arn, expected_type=type_hints["authorizer_function_arn"])
            check_type(argname="argument authorizer_name", value=authorizer_name, expected_type=type_hints["authorizer_name"])
            check_type(argname="argument enable_caching_for_http", value=enable_caching_for_http, expected_type=type_hints["enable_caching_for_http"])
            check_type(argname="argument signing_disabled", value=signing_disabled, expected_type=type_hints["signing_disabled"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument token_key_name", value=token_key_name, expected_type=type_hints["token_key_name"])
            check_type(argname="argument token_signing_public_keys", value=token_signing_public_keys, expected_type=type_hints["token_signing_public_keys"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorizer_function_arn is not None:
            self._values["authorizer_function_arn"] = authorizer_function_arn
        if authorizer_name is not None:
            self._values["authorizer_name"] = authorizer_name
        if enable_caching_for_http is not None:
            self._values["enable_caching_for_http"] = enable_caching_for_http
        if signing_disabled is not None:
            self._values["signing_disabled"] = signing_disabled
        if status is not None:
            self._values["status"] = status
        if tags is not None:
            self._values["tags"] = tags
        if token_key_name is not None:
            self._values["token_key_name"] = token_key_name
        if token_signing_public_keys is not None:
            self._values["token_signing_public_keys"] = token_signing_public_keys

    @builtins.property
    def authorizer_function_arn(self) -> typing.Optional[builtins.str]:
        '''The authorizer's Lambda function ARN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-authorizerfunctionarn
        '''
        result = self._values.get("authorizer_function_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def authorizer_name(self) -> typing.Optional[builtins.str]:
        '''The authorizer name.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-authorizername
        '''
        result = self._values.get("authorizer_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_caching_for_http(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''When ``true`` , the result from the authorizer's Lambda function is cached for clients that use persistent HTTP connections.

        The results are cached for the time specified by the Lambda function in ``refreshAfterInSeconds`` . This value doesn't affect authorization of clients that use MQTT connections.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-enablecachingforhttp
        '''
        result = self._values.get("enable_caching_for_http")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def signing_disabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Specifies whether AWS IoT validates the token signature in an authorization request.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-signingdisabled
        '''
        result = self._values.get("signing_disabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def status(self) -> typing.Optional[builtins.str]:
        '''The status of the authorizer.

        Valid values: ``ACTIVE`` | ``INACTIVE``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the custom authorizer.

        .. epigraph::

           For URI Request parameters use format: ...key1=value1&key2=value2...

           For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..."

           For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def token_key_name(self) -> typing.Optional[builtins.str]:
        '''The key used to extract the token from the HTTP headers.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-tokenkeyname
        '''
        result = self._values.get("token_key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_signing_public_keys(
        self,
    ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
        '''The public keys used to validate the token signature returned by your custom authentication service.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html#cfn-iot-authorizer-tokensigningpublickeys
        '''
        result = self._values.get("token_signing_public_keys")
        return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnAuthorizerMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnAuthorizerPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnAuthorizerPropsMixin",
):
    '''Specifies an authorizer.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html
    :cloudformationResource: AWS::IoT::Authorizer
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_authorizer_props_mixin = iot_mixins.CfnAuthorizerPropsMixin(iot_mixins.CfnAuthorizerMixinProps(
            authorizer_function_arn="authorizerFunctionArn",
            authorizer_name="authorizerName",
            enable_caching_for_http=False,
            signing_disabled=False,
            status="status",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            token_key_name="tokenKeyName",
            token_signing_public_keys={
                "token_signing_public_keys_key": "tokenSigningPublicKeys"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnAuthorizerMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Authorizer``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1060ecc86e62625bd9620e44251575625aae4b60c952c2799a47e42411a18971)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5427ae3093deee88a3e11850cceb29cf8315291e16c395a32fc83aaa6d8598af)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__765043cb42c7689c66300495115edfa7d6d2eae42b4a9f1a0511ca772d8d6c6d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnAuthorizerMixinProps":
        return typing.cast("CfnAuthorizerMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnBillingGroupMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "billing_group_name": "billingGroupName",
        "billing_group_properties": "billingGroupProperties",
        "tags": "tags",
    },
)
class CfnBillingGroupMixinProps:
    def __init__(
        self,
        *,
        billing_group_name: typing.Optional[builtins.str] = None,
        billing_group_properties: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnBillingGroupPropsMixin.

        :param billing_group_name: The name of the billing group.
        :param billing_group_properties: The properties of the billing group.
        :param tags: Metadata which can be used to manage the billing group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-billinggroup.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_billing_group_mixin_props = iot_mixins.CfnBillingGroupMixinProps(
                billing_group_name="billingGroupName",
                billing_group_properties=iot_mixins.CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty(
                    billing_group_description="billingGroupDescription"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50f41c99407f91a8b033df1a3ef942a9babbbc1a48b9bb79ec55384c3935b5df)
            check_type(argname="argument billing_group_name", value=billing_group_name, expected_type=type_hints["billing_group_name"])
            check_type(argname="argument billing_group_properties", value=billing_group_properties, expected_type=type_hints["billing_group_properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if billing_group_name is not None:
            self._values["billing_group_name"] = billing_group_name
        if billing_group_properties is not None:
            self._values["billing_group_properties"] = billing_group_properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def billing_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the billing group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-billinggroup.html#cfn-iot-billinggroup-billinggroupname
        '''
        result = self._values.get("billing_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def billing_group_properties(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty"]]:
        '''The properties of the billing group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-billinggroup.html#cfn-iot-billinggroup-billinggroupproperties
        '''
        result = self._values.get("billing_group_properties")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the billing group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-billinggroup.html#cfn-iot-billinggroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnBillingGroupMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnBillingGroupPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnBillingGroupPropsMixin",
):
    '''Creates a new billing group.

    Requires permission to access the `CreateBillingGroup <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-billinggroup.html
    :cloudformationResource: AWS::IoT::BillingGroup
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_billing_group_props_mixin = iot_mixins.CfnBillingGroupPropsMixin(iot_mixins.CfnBillingGroupMixinProps(
            billing_group_name="billingGroupName",
            billing_group_properties=iot_mixins.CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty(
                billing_group_description="billingGroupDescription"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnBillingGroupMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::BillingGroup``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c7cbbad1175f0fa4c93b26e59a0b7142892f1da4669df286fa8953990a61b55)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8da60cb5f6fe5ae25646ab7ee2379d0b33589691d5af625909fcf835b0ae40ae)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__278743e72de1e310c4afa70438b18c82a593123f35165e2a1ffb21b86e5fe2ae)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnBillingGroupMixinProps":
        return typing.cast("CfnBillingGroupMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty",
        jsii_struct_bases=[],
        name_mapping={"billing_group_description": "billingGroupDescription"},
    )
    class BillingGroupPropertiesProperty:
        def __init__(
            self,
            *,
            billing_group_description: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The properties of a billing group.

            :param billing_group_description: The description of the billing group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-billinggroup-billinggroupproperties.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                billing_group_properties_property = iot_mixins.CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty(
                    billing_group_description="billingGroupDescription"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__94d001cdcd948bb4d4d7c8b1970d60c0f8b4f1873da8be92c9aa36a4e660e34f)
                check_type(argname="argument billing_group_description", value=billing_group_description, expected_type=type_hints["billing_group_description"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if billing_group_description is not None:
                self._values["billing_group_description"] = billing_group_description

        @builtins.property
        def billing_group_description(self) -> typing.Optional[builtins.str]:
            '''The description of the billing group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-billinggroup-billinggroupproperties.html#cfn-iot-billinggroup-billinggroupproperties-billinggroupdescription
            '''
            result = self._values.get("billing_group_description")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BillingGroupPropertiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCACertificateMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_registration_status": "autoRegistrationStatus",
        "ca_certificate_pem": "caCertificatePem",
        "certificate_mode": "certificateMode",
        "registration_config": "registrationConfig",
        "remove_auto_registration": "removeAutoRegistration",
        "status": "status",
        "tags": "tags",
        "verification_certificate_pem": "verificationCertificatePem",
    },
)
class CfnCACertificateMixinProps:
    def __init__(
        self,
        *,
        auto_registration_status: typing.Optional[builtins.str] = None,
        ca_certificate_pem: typing.Optional[builtins.str] = None,
        certificate_mode: typing.Optional[builtins.str] = None,
        registration_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCACertificatePropsMixin.RegistrationConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        remove_auto_registration: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        status: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        verification_certificate_pem: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnCACertificatePropsMixin.

        :param auto_registration_status: Whether the CA certificate is configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE".
        :param ca_certificate_pem: The certificate data in PEM format.
        :param certificate_mode: The mode of the CA. All the device certificates that are registered using this CA will be registered in the same mode as the CA. For more information about certificate mode for device certificates, see `certificate mode <https://docs.aws.amazon.com//iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode>`_ . Valid values are "DEFAULT" and "SNI_ONLY".
        :param registration_config: Information about the registration configuration.
        :param remove_auto_registration: If true, removes auto registration.
        :param status: The status of the CA certificate. Valid values are "ACTIVE" and "INACTIVE".
        :param tags: An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .
        :param verification_certificate_pem: The private key verification certificate.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_cACertificate_mixin_props = iot_mixins.CfnCACertificateMixinProps(
                auto_registration_status="autoRegistrationStatus",
                ca_certificate_pem="caCertificatePem",
                certificate_mode="certificateMode",
                registration_config=iot_mixins.CfnCACertificatePropsMixin.RegistrationConfigProperty(
                    role_arn="roleArn",
                    template_body="templateBody",
                    template_name="templateName"
                ),
                remove_auto_registration=False,
                status="status",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                verification_certificate_pem="verificationCertificatePem"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f21c7480ca326adcaa61db3958a782c4b216f211c1cdd2f4fd74f22bd718229f)
            check_type(argname="argument auto_registration_status", value=auto_registration_status, expected_type=type_hints["auto_registration_status"])
            check_type(argname="argument ca_certificate_pem", value=ca_certificate_pem, expected_type=type_hints["ca_certificate_pem"])
            check_type(argname="argument certificate_mode", value=certificate_mode, expected_type=type_hints["certificate_mode"])
            check_type(argname="argument registration_config", value=registration_config, expected_type=type_hints["registration_config"])
            check_type(argname="argument remove_auto_registration", value=remove_auto_registration, expected_type=type_hints["remove_auto_registration"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument verification_certificate_pem", value=verification_certificate_pem, expected_type=type_hints["verification_certificate_pem"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_registration_status is not None:
            self._values["auto_registration_status"] = auto_registration_status
        if ca_certificate_pem is not None:
            self._values["ca_certificate_pem"] = ca_certificate_pem
        if certificate_mode is not None:
            self._values["certificate_mode"] = certificate_mode
        if registration_config is not None:
            self._values["registration_config"] = registration_config
        if remove_auto_registration is not None:
            self._values["remove_auto_registration"] = remove_auto_registration
        if status is not None:
            self._values["status"] = status
        if tags is not None:
            self._values["tags"] = tags
        if verification_certificate_pem is not None:
            self._values["verification_certificate_pem"] = verification_certificate_pem

    @builtins.property
    def auto_registration_status(self) -> typing.Optional[builtins.str]:
        '''Whether the CA certificate is configured for auto registration of device certificates.

        Valid values are "ENABLE" and "DISABLE".

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-autoregistrationstatus
        '''
        result = self._values.get("auto_registration_status")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_certificate_pem(self) -> typing.Optional[builtins.str]:
        '''The certificate data in PEM format.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-cacertificatepem
        '''
        result = self._values.get("ca_certificate_pem")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def certificate_mode(self) -> typing.Optional[builtins.str]:
        '''The mode of the CA.

        All the device certificates that are registered using this CA will be registered in the same mode as the CA. For more information about certificate mode for device certificates, see `certificate mode <https://docs.aws.amazon.com//iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode>`_ .

        Valid values are "DEFAULT" and "SNI_ONLY".

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-certificatemode
        '''
        result = self._values.get("certificate_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def registration_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCACertificatePropsMixin.RegistrationConfigProperty"]]:
        '''Information about the registration configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-registrationconfig
        '''
        result = self._values.get("registration_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCACertificatePropsMixin.RegistrationConfigProperty"]], result)

    @builtins.property
    def remove_auto_registration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''If true, removes auto registration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-removeautoregistration
        '''
        result = self._values.get("remove_auto_registration")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def status(self) -> typing.Optional[builtins.str]:
        '''The status of the CA certificate.

        Valid values are "ACTIVE" and "INACTIVE".

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''An array of key-value pairs to apply to this resource.

        For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def verification_certificate_pem(self) -> typing.Optional[builtins.str]:
        '''The private key verification certificate.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html#cfn-iot-cacertificate-verificationcertificatepem
        '''
        result = self._values.get("verification_certificate_pem")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCACertificateMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCACertificatePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCACertificatePropsMixin",
):
    '''Specifies a CA certificate.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html
    :cloudformationResource: AWS::IoT::CACertificate
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_cACertificate_props_mixin = iot_mixins.CfnCACertificatePropsMixin(iot_mixins.CfnCACertificateMixinProps(
            auto_registration_status="autoRegistrationStatus",
            ca_certificate_pem="caCertificatePem",
            certificate_mode="certificateMode",
            registration_config=iot_mixins.CfnCACertificatePropsMixin.RegistrationConfigProperty(
                role_arn="roleArn",
                template_body="templateBody",
                template_name="templateName"
            ),
            remove_auto_registration=False,
            status="status",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            verification_certificate_pem="verificationCertificatePem"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCACertificateMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::CACertificate``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51e82e31461f2bd0c43f98e9a7566907e4e9e8b4355ada66b69d4a55bdc00a1b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f336091ceb8415d2343f0a736e03fbe26cbc023d240d8726a47815c7498ca1a1)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5282433d789231bdff0b36f935fb93b3ebe6abe56bab93a184a3c772f369b136)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCACertificateMixinProps":
        return typing.cast("CfnCACertificateMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCACertificatePropsMixin.RegistrationConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "role_arn": "roleArn",
            "template_body": "templateBody",
            "template_name": "templateName",
        },
    )
    class RegistrationConfigProperty:
        def __init__(
            self,
            *,
            role_arn: typing.Optional[builtins.str] = None,
            template_body: typing.Optional[builtins.str] = None,
            template_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The registration configuration.

            :param role_arn: The ARN of the role.
            :param template_body: The template body.
            :param template_name: The name of the provisioning template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-cacertificate-registrationconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                registration_config_property = iot_mixins.CfnCACertificatePropsMixin.RegistrationConfigProperty(
                    role_arn="roleArn",
                    template_body="templateBody",
                    template_name="templateName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f621b9ab21c38beace2a0175d2d2dc53086458f95a0b2966527d8d672ca627eb)
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument template_body", value=template_body, expected_type=type_hints["template_body"])
                check_type(argname="argument template_name", value=template_name, expected_type=type_hints["template_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if template_body is not None:
                self._values["template_body"] = template_body
            if template_name is not None:
                self._values["template_name"] = template_name

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-cacertificate-registrationconfig.html#cfn-iot-cacertificate-registrationconfig-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def template_body(self) -> typing.Optional[builtins.str]:
            '''The template body.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-cacertificate-registrationconfig.html#cfn-iot-cacertificate-registrationconfig-templatebody
            '''
            result = self._values.get("template_body")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the provisioning template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-cacertificate-registrationconfig.html#cfn-iot-cacertificate-registrationconfig-templatename
            '''
            result = self._values.get("template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RegistrationConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCertificateMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "ca_certificate_pem": "caCertificatePem",
        "certificate_mode": "certificateMode",
        "certificate_pem": "certificatePem",
        "certificate_signing_request": "certificateSigningRequest",
        "status": "status",
    },
)
class CfnCertificateMixinProps:
    def __init__(
        self,
        *,
        ca_certificate_pem: typing.Optional[builtins.str] = None,
        certificate_mode: typing.Optional[builtins.str] = None,
        certificate_pem: typing.Optional[builtins.str] = None,
        certificate_signing_request: typing.Optional[builtins.str] = None,
        status: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnCertificatePropsMixin.

        :param ca_certificate_pem: The CA certificate used to sign the device certificate being registered, not available when CertificateMode is SNI_ONLY.
        :param certificate_mode: Specifies which mode of certificate registration to use with this resource. Valid options are DEFAULT with CaCertificatePem and CertificatePem, SNI_ONLY with CertificatePem, and Default with CertificateSigningRequest. ``DEFAULT`` : A certificate in ``DEFAULT`` mode is either generated by AWS IoT Core or registered with an issuer certificate authority (CA). Devices with certificates in ``DEFAULT`` mode aren't required to send the Server Name Indication (SNI) extension when connecting to AWS IoT Core . However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to AWS IoT Core . ``SNI_ONLY`` : A certificate in ``SNI_ONLY`` mode is registered without an issuer CA. Devices with certificates in ``SNI_ONLY`` mode must send the SNI extension when connecting to AWS IoT Core .
        :param certificate_pem: The certificate data in PEM format. Requires SNI_ONLY for the certificate mode or the accompanying CACertificatePem for registration.
        :param certificate_signing_request: The certificate signing request (CSR).
        :param status: The status of the certificate. Valid values are ACTIVE, INACTIVE, REVOKED, PENDING_TRANSFER, and PENDING_ACTIVATION. The status value REGISTER_INACTIVE is deprecated and should not be used.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_certificate_mixin_props = iot_mixins.CfnCertificateMixinProps(
                ca_certificate_pem="caCertificatePem",
                certificate_mode="certificateMode",
                certificate_pem="certificatePem",
                certificate_signing_request="certificateSigningRequest",
                status="status"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc807134a8297f687bf07101d8fd6f848784d35a38f812abbe8a58d4140d83ba)
            check_type(argname="argument ca_certificate_pem", value=ca_certificate_pem, expected_type=type_hints["ca_certificate_pem"])
            check_type(argname="argument certificate_mode", value=certificate_mode, expected_type=type_hints["certificate_mode"])
            check_type(argname="argument certificate_pem", value=certificate_pem, expected_type=type_hints["certificate_pem"])
            check_type(argname="argument certificate_signing_request", value=certificate_signing_request, expected_type=type_hints["certificate_signing_request"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_certificate_pem is not None:
            self._values["ca_certificate_pem"] = ca_certificate_pem
        if certificate_mode is not None:
            self._values["certificate_mode"] = certificate_mode
        if certificate_pem is not None:
            self._values["certificate_pem"] = certificate_pem
        if certificate_signing_request is not None:
            self._values["certificate_signing_request"] = certificate_signing_request
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def ca_certificate_pem(self) -> typing.Optional[builtins.str]:
        '''The CA certificate used to sign the device certificate being registered, not available when CertificateMode is SNI_ONLY.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html#cfn-iot-certificate-cacertificatepem
        '''
        result = self._values.get("ca_certificate_pem")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def certificate_mode(self) -> typing.Optional[builtins.str]:
        '''Specifies which mode of certificate registration to use with this resource.

        Valid options are DEFAULT with CaCertificatePem and CertificatePem, SNI_ONLY with CertificatePem, and Default with CertificateSigningRequest.

        ``DEFAULT`` : A certificate in ``DEFAULT`` mode is either generated by AWS IoT Core or registered with an issuer certificate authority (CA). Devices with certificates in ``DEFAULT`` mode aren't required to send the Server Name Indication (SNI) extension when connecting to AWS IoT Core . However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to AWS IoT Core .

        ``SNI_ONLY`` : A certificate in ``SNI_ONLY`` mode is registered without an issuer CA. Devices with certificates in ``SNI_ONLY`` mode must send the SNI extension when connecting to AWS IoT Core .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html#cfn-iot-certificate-certificatemode
        '''
        result = self._values.get("certificate_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def certificate_pem(self) -> typing.Optional[builtins.str]:
        '''The certificate data in PEM format.

        Requires SNI_ONLY for the certificate mode or the accompanying CACertificatePem for registration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html#cfn-iot-certificate-certificatepem
        '''
        result = self._values.get("certificate_pem")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def certificate_signing_request(self) -> typing.Optional[builtins.str]:
        '''The certificate signing request (CSR).

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html#cfn-iot-certificate-certificatesigningrequest
        '''
        result = self._values.get("certificate_signing_request")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def status(self) -> typing.Optional[builtins.str]:
        '''The status of the certificate.

        Valid values are ACTIVE, INACTIVE, REVOKED, PENDING_TRANSFER, and PENDING_ACTIVATION.

        The status value REGISTER_INACTIVE is deprecated and should not be used.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html#cfn-iot-certificate-status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCertificateMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCertificatePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCertificatePropsMixin",
):
    '''Use the ``AWS::IoT::Certificate`` resource to declare an AWS IoT X.509 certificate. For information about working with X.509 certificates, see `X.509 Client Certificates <https://docs.aws.amazon.com/iot/latest/developerguide/x509-client-certs.html>`_ in the *AWS IoT Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html
    :cloudformationResource: AWS::IoT::Certificate
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_certificate_props_mixin = iot_mixins.CfnCertificatePropsMixin(iot_mixins.CfnCertificateMixinProps(
            ca_certificate_pem="caCertificatePem",
            certificate_mode="certificateMode",
            certificate_pem="certificatePem",
            certificate_signing_request="certificateSigningRequest",
            status="status"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCertificateMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Certificate``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__227b32c83a5010d5de825f43280eb561e6f2eb6c4a6dcc1357f979ef793fb320)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85f15948a7f7672378e20765b3e0873546272ac08cec8d4c5f8775786ecdf975)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eab1fda7a099c4e8149db62b057ddbac77a30c57d0996bf2067f10ee42c47816)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCertificateMixinProps":
        return typing.cast("CfnCertificateMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCertificateProviderMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "account_default_for_operations": "accountDefaultForOperations",
        "certificate_provider_name": "certificateProviderName",
        "lambda_function_arn": "lambdaFunctionArn",
        "tags": "tags",
    },
)
class CfnCertificateProviderMixinProps:
    def __init__(
        self,
        *,
        account_default_for_operations: typing.Optional[typing.Sequence[builtins.str]] = None,
        certificate_provider_name: typing.Optional[builtins.str] = None,
        lambda_function_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnCertificateProviderPropsMixin.

        :param account_default_for_operations: A list of the operations that the certificate provider will use to generate certificates. Valid value: ``CreateCertificateFromCsr`` .
        :param certificate_provider_name: The name of the certificate provider.
        :param lambda_function_arn: The ARN of the Lambda function.
        :param tags: Metadata that can be used to manage the certificate provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificateprovider.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_certificate_provider_mixin_props = iot_mixins.CfnCertificateProviderMixinProps(
                account_default_for_operations=["accountDefaultForOperations"],
                certificate_provider_name="certificateProviderName",
                lambda_function_arn="lambdaFunctionArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a4a7c6fe6eba7db55fa3abe138b440e0cb1c039b9db91976c5daa8270dde669)
            check_type(argname="argument account_default_for_operations", value=account_default_for_operations, expected_type=type_hints["account_default_for_operations"])
            check_type(argname="argument certificate_provider_name", value=certificate_provider_name, expected_type=type_hints["certificate_provider_name"])
            check_type(argname="argument lambda_function_arn", value=lambda_function_arn, expected_type=type_hints["lambda_function_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if account_default_for_operations is not None:
            self._values["account_default_for_operations"] = account_default_for_operations
        if certificate_provider_name is not None:
            self._values["certificate_provider_name"] = certificate_provider_name
        if lambda_function_arn is not None:
            self._values["lambda_function_arn"] = lambda_function_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def account_default_for_operations(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of the operations that the certificate provider will use to generate certificates.

        Valid value: ``CreateCertificateFromCsr`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificateprovider.html#cfn-iot-certificateprovider-accountdefaultforoperations
        '''
        result = self._values.get("account_default_for_operations")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def certificate_provider_name(self) -> typing.Optional[builtins.str]:
        '''The name of the certificate provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificateprovider.html#cfn-iot-certificateprovider-certificateprovidername
        '''
        result = self._values.get("certificate_provider_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lambda_function_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the Lambda function.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificateprovider.html#cfn-iot-certificateprovider-lambdafunctionarn
        '''
        result = self._values.get("lambda_function_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the certificate provider.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificateprovider.html#cfn-iot-certificateprovider-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCertificateProviderMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCertificateProviderPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCertificateProviderPropsMixin",
):
    '''Creates a certificate provider.

    AWS IoT Core certificate provider lets you customize how to sign a certificate signing request (CSR) in fleet provisioning. For more information, see `Self-managed certificate signing using AWS IoT Core certificate provider <https://docs.aws.amazon.com/iot/latest/developerguide/provisioning-cert-provider.html>`_ from the *AWS IoT Core Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificateprovider.html
    :cloudformationResource: AWS::IoT::CertificateProvider
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_certificate_provider_props_mixin = iot_mixins.CfnCertificateProviderPropsMixin(iot_mixins.CfnCertificateProviderMixinProps(
            account_default_for_operations=["accountDefaultForOperations"],
            certificate_provider_name="certificateProviderName",
            lambda_function_arn="lambdaFunctionArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCertificateProviderMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::CertificateProvider``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3f075becfd6266df5a812bb4d8d5c8a7f91bcfcc7a1f49067e0dc0c9c0f4330)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f738bedba0063cead406f73be5761f29efc8766b5fa961535bac0fb8598ee0ac)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5744e5b72615523c8b7155b375e8466615149cf5dcda891e5f31b1eb30325548)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCertificateProviderMixinProps":
        return typing.cast("CfnCertificateProviderMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCommandMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "command_id": "commandId",
        "created_at": "createdAt",
        "deprecated": "deprecated",
        "description": "description",
        "display_name": "displayName",
        "last_updated_at": "lastUpdatedAt",
        "mandatory_parameters": "mandatoryParameters",
        "namespace": "namespace",
        "payload": "payload",
        "pending_deletion": "pendingDeletion",
        "role_arn": "roleArn",
        "tags": "tags",
    },
)
class CfnCommandMixinProps:
    def __init__(
        self,
        *,
        command_id: typing.Optional[builtins.str] = None,
        created_at: typing.Optional[builtins.str] = None,
        deprecated: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        last_updated_at: typing.Optional[builtins.str] = None,
        mandatory_parameters: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCommandPropsMixin.CommandParameterProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        namespace: typing.Optional[builtins.str] = None,
        payload: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCommandPropsMixin.CommandPayloadProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        pending_deletion: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        role_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnCommandPropsMixin.

        :param command_id: The unique identifier of the command.
        :param created_at: The timestamp, when the command was created.
        :param deprecated: Indicates whether the command has been deprecated.
        :param description: The description of the command parameter.
        :param display_name: The display name of the command.
        :param last_updated_at: The timestamp, when the command was last updated.
        :param mandatory_parameters: 
        :param namespace: The namespace to which the command belongs.
        :param payload: 
        :param pending_deletion: Indicates whether the command is pending deletion.
        :param role_arn: The customer role associated with the command.
        :param tags: The tags to be associated with the command.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_command_mixin_props = iot_mixins.CfnCommandMixinProps(
                command_id="commandId",
                created_at="createdAt",
                deprecated=False,
                description="description",
                display_name="displayName",
                last_updated_at="lastUpdatedAt",
                mandatory_parameters=[iot_mixins.CfnCommandPropsMixin.CommandParameterProperty(
                    default_value=iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                        b=False,
                        bin="bin",
                        d=123,
                        i=123,
                        l="l",
                        s="s",
                        ul="ul"
                    ),
                    description="description",
                    name="name",
                    value=iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                        b=False,
                        bin="bin",
                        d=123,
                        i=123,
                        l="l",
                        s="s",
                        ul="ul"
                    )
                )],
                namespace="namespace",
                payload=iot_mixins.CfnCommandPropsMixin.CommandPayloadProperty(
                    content="content",
                    content_type="contentType"
                ),
                pending_deletion=False,
                role_arn="roleArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22e8838b72b0e146c252cf0683db881d4cbe902f91e4dbf28122d9fd8f561ad5)
            check_type(argname="argument command_id", value=command_id, expected_type=type_hints["command_id"])
            check_type(argname="argument created_at", value=created_at, expected_type=type_hints["created_at"])
            check_type(argname="argument deprecated", value=deprecated, expected_type=type_hints["deprecated"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument last_updated_at", value=last_updated_at, expected_type=type_hints["last_updated_at"])
            check_type(argname="argument mandatory_parameters", value=mandatory_parameters, expected_type=type_hints["mandatory_parameters"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
            check_type(argname="argument pending_deletion", value=pending_deletion, expected_type=type_hints["pending_deletion"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command_id is not None:
            self._values["command_id"] = command_id
        if created_at is not None:
            self._values["created_at"] = created_at
        if deprecated is not None:
            self._values["deprecated"] = deprecated
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if last_updated_at is not None:
            self._values["last_updated_at"] = last_updated_at
        if mandatory_parameters is not None:
            self._values["mandatory_parameters"] = mandatory_parameters
        if namespace is not None:
            self._values["namespace"] = namespace
        if payload is not None:
            self._values["payload"] = payload
        if pending_deletion is not None:
            self._values["pending_deletion"] = pending_deletion
        if role_arn is not None:
            self._values["role_arn"] = role_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def command_id(self) -> typing.Optional[builtins.str]:
        '''The unique identifier of the command.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-commandid
        '''
        result = self._values.get("command_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def created_at(self) -> typing.Optional[builtins.str]:
        '''The timestamp, when the command was created.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-createdat
        '''
        result = self._values.get("created_at")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deprecated(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the command has been deprecated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-deprecated
        '''
        result = self._values.get("deprecated")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the command parameter.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The display name of the command.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-displayname
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def last_updated_at(self) -> typing.Optional[builtins.str]:
        '''The timestamp, when the command was last updated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-lastupdatedat
        '''
        result = self._values.get("last_updated_at")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mandatory_parameters(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandParameterProperty"]]]]:
        '''
        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-mandatoryparameters
        '''
        result = self._values.get("mandatory_parameters")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandParameterProperty"]]]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace to which the command belongs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def payload(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandPayloadProperty"]]:
        '''
        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-payload
        '''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandPayloadProperty"]], result)

    @builtins.property
    def pending_deletion(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Indicates whether the command is pending deletion.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-pendingdeletion
        '''
        result = self._values.get("pending_deletion")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The customer role associated with the command.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags to be associated with the command.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html#cfn-iot-command-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCommandMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCommandPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCommandPropsMixin",
):
    '''Represents the resource definition of AWS IoT Command.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-command.html
    :cloudformationResource: AWS::IoT::Command
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_command_props_mixin = iot_mixins.CfnCommandPropsMixin(iot_mixins.CfnCommandMixinProps(
            command_id="commandId",
            created_at="createdAt",
            deprecated=False,
            description="description",
            display_name="displayName",
            last_updated_at="lastUpdatedAt",
            mandatory_parameters=[iot_mixins.CfnCommandPropsMixin.CommandParameterProperty(
                default_value=iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                    b=False,
                    bin="bin",
                    d=123,
                    i=123,
                    l="l",
                    s="s",
                    ul="ul"
                ),
                description="description",
                name="name",
                value=iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                    b=False,
                    bin="bin",
                    d=123,
                    i=123,
                    l="l",
                    s="s",
                    ul="ul"
                )
            )],
            namespace="namespace",
            payload=iot_mixins.CfnCommandPropsMixin.CommandPayloadProperty(
                content="content",
                content_type="contentType"
            ),
            pending_deletion=False,
            role_arn="roleArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCommandMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Command``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68609224e8a5cbfc0c3ef57cfb1e92f4321251996e1fb75e2a47c452615df2e6)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88e70adc791e46cc3f8caded3fb99e1034a21ec2cc68c504ead1afe1c9dad1d3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ea2bfdd2b7aa273e5b11430425d0cfebf8d194f331b77652dbd9bea740332c4)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCommandMixinProps":
        return typing.cast("CfnCommandMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCommandPropsMixin.CommandParameterProperty",
        jsii_struct_bases=[],
        name_mapping={
            "default_value": "defaultValue",
            "description": "description",
            "name": "name",
            "value": "value",
        },
    )
    class CommandParameterProperty:
        def __init__(
            self,
            *,
            default_value: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCommandPropsMixin.CommandParameterValueProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            description: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            value: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnCommandPropsMixin.CommandParameterValueProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''
            :param default_value: 
            :param description: 
            :param name: 
            :param value: 

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparameter.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                command_parameter_property = iot_mixins.CfnCommandPropsMixin.CommandParameterProperty(
                    default_value=iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                        b=False,
                        bin="bin",
                        d=123,
                        i=123,
                        l="l",
                        s="s",
                        ul="ul"
                    ),
                    description="description",
                    name="name",
                    value=iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                        b=False,
                        bin="bin",
                        d=123,
                        i=123,
                        l="l",
                        s="s",
                        ul="ul"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7cd914e82375db5b5c9c5031b01ffc8d8bd5a8cb5d6eda7b79d9e27fb9b42905)
                check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if default_value is not None:
                self._values["default_value"] = default_value
            if description is not None:
                self._values["description"] = description
            if name is not None:
                self._values["name"] = name
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def default_value(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandParameterValueProperty"]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparameter.html#cfn-iot-command-commandparameter-defaultvalue
            '''
            result = self._values.get("default_value")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandParameterValueProperty"]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparameter.html#cfn-iot-command-commandparameter-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparameter.html#cfn-iot-command-commandparameter-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandParameterValueProperty"]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparameter.html#cfn-iot-command-commandparameter-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnCommandPropsMixin.CommandParameterValueProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CommandParameterProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCommandPropsMixin.CommandParameterValueProperty",
        jsii_struct_bases=[],
        name_mapping={
            "b": "b",
            "bin": "bin",
            "d": "d",
            "i": "i",
            "l": "l",
            "s": "s",
            "ul": "ul",
        },
    )
    class CommandParameterValueProperty:
        def __init__(
            self,
            *,
            b: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            bin: typing.Optional[builtins.str] = None,
            d: typing.Optional[jsii.Number] = None,
            i: typing.Optional[jsii.Number] = None,
            l: typing.Optional[builtins.str] = None,
            s: typing.Optional[builtins.str] = None,
            ul: typing.Optional[builtins.str] = None,
        ) -> None:
            '''
            :param b: 
            :param bin: 
            :param d: 
            :param i: 
            :param l: 
            :param s: 
            :param ul: 

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                command_parameter_value_property = iot_mixins.CfnCommandPropsMixin.CommandParameterValueProperty(
                    b=False,
                    bin="bin",
                    d=123,
                    i=123,
                    l="l",
                    s="s",
                    ul="ul"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4a4c4d1c1dbbcf570a95a119fe074a5c841f87770c82f08b47fec1646b0f9c46)
                check_type(argname="argument b", value=b, expected_type=type_hints["b"])
                check_type(argname="argument bin", value=bin, expected_type=type_hints["bin"])
                check_type(argname="argument d", value=d, expected_type=type_hints["d"])
                check_type(argname="argument i", value=i, expected_type=type_hints["i"])
                check_type(argname="argument l", value=l, expected_type=type_hints["l"])
                check_type(argname="argument s", value=s, expected_type=type_hints["s"])
                check_type(argname="argument ul", value=ul, expected_type=type_hints["ul"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if b is not None:
                self._values["b"] = b
            if bin is not None:
                self._values["bin"] = bin
            if d is not None:
                self._values["d"] = d
            if i is not None:
                self._values["i"] = i
            if l is not None:
                self._values["l"] = l
            if s is not None:
                self._values["s"] = s
            if ul is not None:
                self._values["ul"] = ul

        @builtins.property
        def b(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-b
            '''
            result = self._values.get("b")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def bin(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-bin
            '''
            result = self._values.get("bin")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def d(self) -> typing.Optional[jsii.Number]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-d
            '''
            result = self._values.get("d")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def i(self) -> typing.Optional[jsii.Number]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-i
            '''
            result = self._values.get("i")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def l(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-l
            '''
            result = self._values.get("l")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def s(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-s
            '''
            result = self._values.get("s")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ul(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandparametervalue.html#cfn-iot-command-commandparametervalue-ul
            '''
            result = self._values.get("ul")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CommandParameterValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCommandPropsMixin.CommandPayloadProperty",
        jsii_struct_bases=[],
        name_mapping={"content": "content", "content_type": "contentType"},
    )
    class CommandPayloadProperty:
        def __init__(
            self,
            *,
            content: typing.Optional[builtins.str] = None,
            content_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''
            :param content: 
            :param content_type: 

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandpayload.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                command_payload_property = iot_mixins.CfnCommandPropsMixin.CommandPayloadProperty(
                    content="content",
                    content_type="contentType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__13a16db055afa979ec8efc5b45c6f17bc9a7513ce0059ad050eae71ae098ee0b)
                check_type(argname="argument content", value=content, expected_type=type_hints["content"])
                check_type(argname="argument content_type", value=content_type, expected_type=type_hints["content_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if content is not None:
                self._values["content"] = content
            if content_type is not None:
                self._values["content_type"] = content_type

        @builtins.property
        def content(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandpayload.html#cfn-iot-command-commandpayload-content
            '''
            result = self._values.get("content")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def content_type(self) -> typing.Optional[builtins.str]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-command-commandpayload.html#cfn-iot-command-commandpayload-contenttype
            '''
            result = self._values.get("content_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CommandPayloadProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCustomMetricMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "display_name": "displayName",
        "metric_name": "metricName",
        "metric_type": "metricType",
        "tags": "tags",
    },
)
class CfnCustomMetricMixinProps:
    def __init__(
        self,
        *,
        display_name: typing.Optional[builtins.str] = None,
        metric_name: typing.Optional[builtins.str] = None,
        metric_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnCustomMetricPropsMixin.

        :param display_name: The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.
        :param metric_name: The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with ``aws:`` . You cant change the name after you define it.
        :param metric_type: The type of the custom metric. Types include ``string-list`` , ``ip-address-list`` , ``number-list`` , and ``number`` . .. epigraph:: The type ``number`` only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.
        :param tags: Metadata that can be used to manage the custom metric.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_custom_metric_mixin_props = iot_mixins.CfnCustomMetricMixinProps(
                display_name="displayName",
                metric_name="metricName",
                metric_type="metricType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1bacef4538b9877448a0ff6f3b60a70f99be1eacfc87c2bc92eb0451601d7336)
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument metric_type", value=metric_type, expected_type=type_hints["metric_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if display_name is not None:
            self._values["display_name"] = display_name
        if metric_name is not None:
            self._values["metric_name"] = metric_name
        if metric_type is not None:
            self._values["metric_type"] = metric_type
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The friendly name in the console for the custom metric.

        This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html#cfn-iot-custommetric-displayname
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric_name(self) -> typing.Optional[builtins.str]:
        '''The name of the custom metric.

        This will be used in the metric report submitted from the device/thing. The name can't begin with ``aws:`` . You cant change the name after you define it.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html#cfn-iot-custommetric-metricname
        '''
        result = self._values.get("metric_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric_type(self) -> typing.Optional[builtins.str]:
        '''The type of the custom metric. Types include ``string-list`` , ``ip-address-list`` , ``number-list`` , and ``number`` .

        .. epigraph::

           The type ``number`` only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html#cfn-iot-custommetric-metrictype
        '''
        result = self._values.get("metric_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the custom metric.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html#cfn-iot-custommetric-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCustomMetricMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnCustomMetricPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnCustomMetricPropsMixin",
):
    '''Use the ``AWS::IoT::CustomMetric`` resource to define a custom metric published by your devices to Device Defender.

    For API reference, see `CreateCustomMetric <https://docs.aws.amazon.com/iot/latest/apireference/API_CreateCustomMetric.html>`_ and for general information, see `Custom metrics <https://docs.aws.amazon.com/iot/latest/developerguide/dd-detect-custom-metrics.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html
    :cloudformationResource: AWS::IoT::CustomMetric
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_custom_metric_props_mixin = iot_mixins.CfnCustomMetricPropsMixin(iot_mixins.CfnCustomMetricMixinProps(
            display_name="displayName",
            metric_name="metricName",
            metric_type="metricType",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnCustomMetricMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::CustomMetric``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__924c2af48e269cb5ebbfd6e3d4c22a03948239f4bd6a0667ee7daa3b39027d2a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16b5f7958fdae714abe11b1d0156a43bedf59c2178e0375102ca92fd29fd17de)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41e2cb1c655fc338ec3b85815c290e880b5c7ee8bec44c5f9f727df3f4b544a4)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnCustomMetricMixinProps":
        return typing.cast("CfnCustomMetricMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDimensionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "string_values": "stringValues",
        "tags": "tags",
        "type": "type",
    },
)
class CfnDimensionMixinProps:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        string_values: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnDimensionPropsMixin.

        :param name: A unique identifier for the dimension.
        :param string_values: Specifies the value or list of values for the dimension. For ``TOPIC_FILTER`` dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
        :param tags: Metadata that can be used to manage the dimension.
        :param type: Specifies the type of dimension. Supported types: ``TOPIC_FILTER.``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_dimension_mixin_props = iot_mixins.CfnDimensionMixinProps(
                name="name",
                string_values=["stringValues"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a5b5a103f8bf274c2faa04d088153e85a1cb656c538e129a0d1e24987339a34)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument string_values", value=string_values, expected_type=type_hints["string_values"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if string_values is not None:
            self._values["string_values"] = string_values
        if tags is not None:
            self._values["tags"] = tags
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''A unique identifier for the dimension.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html#cfn-iot-dimension-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def string_values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Specifies the value or list of values for the dimension.

        For ``TOPIC_FILTER`` dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html#cfn-iot-dimension-stringvalues
        '''
        result = self._values.get("string_values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the dimension.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html#cfn-iot-dimension-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''Specifies the type of dimension.

        Supported types: ``TOPIC_FILTER.``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html#cfn-iot-dimension-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDimensionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnDimensionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDimensionPropsMixin",
):
    '''Use the ``AWS::IoT::Dimension`` to limit the scope of a metric used in a security profile for AWS IoT Device Defender .

    For example, using a ``TOPIC_FILTER`` dimension, you can narrow down the scope of the metric to only MQTT topics where the name matches the pattern specified in the dimension. For API reference, see `CreateDimension <https://docs.aws.amazon.com/iot/latest/apireference/API_CreateDimension.html>`_ and for general information, see `Scoping metrics in security profiles using dimensions <https://docs.aws.amazon.com/iot/latest/developerguide/scoping-security-behavior.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html
    :cloudformationResource: AWS::IoT::Dimension
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_dimension_props_mixin = iot_mixins.CfnDimensionPropsMixin(iot_mixins.CfnDimensionMixinProps(
            name="name",
            string_values=["stringValues"],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            type="type"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnDimensionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Dimension``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0eb2d0930b3354ce8080696b7cb87a3d1c4e6c3dab95c6bde6ca36c4ebebb5c7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b48cf9e12b0c24b1f9408530df0d0067d924942976366a6cad3784cc3d1d6fcb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0f9848f344dfaef2b2d2cce18a00375ae57b05f962ed8e368d531f81be0bbef)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnDimensionMixinProps":
        return typing.cast("CfnDimensionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "application_protocol": "applicationProtocol",
        "authentication_type": "authenticationType",
        "authorizer_config": "authorizerConfig",
        "client_certificate_config": "clientCertificateConfig",
        "domain_configuration_name": "domainConfigurationName",
        "domain_configuration_status": "domainConfigurationStatus",
        "domain_name": "domainName",
        "server_certificate_arns": "serverCertificateArns",
        "server_certificate_config": "serverCertificateConfig",
        "service_type": "serviceType",
        "tags": "tags",
        "tls_config": "tlsConfig",
        "validation_certificate_arn": "validationCertificateArn",
    },
)
class CfnDomainConfigurationMixinProps:
    def __init__(
        self,
        *,
        application_protocol: typing.Optional[builtins.str] = None,
        authentication_type: typing.Optional[builtins.str] = None,
        authorizer_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        client_certificate_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        domain_configuration_name: typing.Optional[builtins.str] = None,
        domain_configuration_status: typing.Optional[builtins.str] = None,
        domain_name: typing.Optional[builtins.str] = None,
        server_certificate_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        server_certificate_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        service_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        tls_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDomainConfigurationPropsMixin.TlsConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        validation_certificate_arn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnDomainConfigurationPropsMixin.

        :param application_protocol: An enumerated string that species the application-layer protocol.
        :param authentication_type: An enumerated string that species the authentication type.
        :param authorizer_config: An object that specifies the authorization service for a domain.
        :param client_certificate_config: An object that species the client certificate conguration for a domain.
        :param domain_configuration_name: The name of the domain configuration. This value must be unique to a region.
        :param domain_configuration_status: The status to which the domain configuration should be updated. Valid values: ``ENABLED`` | ``DISABLED``
        :param domain_name: The name of the domain.
        :param server_certificate_arns: The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.
        :param server_certificate_config: The server certificate configuration. For more information, see `Configurable endpoints <https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html>`_ from the AWS IoT Core Developer Guide.
        :param service_type: The type of service delivered by the endpoint. .. epigraph:: AWS IoT Core currently supports only the ``DATA`` service type.
        :param tags: Metadata which can be used to manage the domain configuration. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
        :param tls_config: An object that specifies the TLS configuration for a domain.
        :param validation_certificate_arn: The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for AWS -managed domains.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_domain_configuration_mixin_props = iot_mixins.CfnDomainConfigurationMixinProps(
                application_protocol="applicationProtocol",
                authentication_type="authenticationType",
                authorizer_config=iot_mixins.CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty(
                    allow_authorizer_override=False,
                    default_authorizer_name="defaultAuthorizerName"
                ),
                client_certificate_config=iot_mixins.CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty(
                    client_certificate_callback_arn="clientCertificateCallbackArn"
                ),
                domain_configuration_name="domainConfigurationName",
                domain_configuration_status="domainConfigurationStatus",
                domain_name="domainName",
                server_certificate_arns=["serverCertificateArns"],
                server_certificate_config=iot_mixins.CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty(
                    enable_ocsp_check=False,
                    ocsp_authorized_responder_arn="ocspAuthorizedResponderArn",
                    ocsp_lambda_arn="ocspLambdaArn"
                ),
                service_type="serviceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                tls_config=iot_mixins.CfnDomainConfigurationPropsMixin.TlsConfigProperty(
                    security_policy="securityPolicy"
                ),
                validation_certificate_arn="validationCertificateArn"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e179e0c1c000cbf031890308a2b82a44c17e97dca6cad5660fb096a9e2a5e768)
            check_type(argname="argument application_protocol", value=application_protocol, expected_type=type_hints["application_protocol"])
            check_type(argname="argument authentication_type", value=authentication_type, expected_type=type_hints["authentication_type"])
            check_type(argname="argument authorizer_config", value=authorizer_config, expected_type=type_hints["authorizer_config"])
            check_type(argname="argument client_certificate_config", value=client_certificate_config, expected_type=type_hints["client_certificate_config"])
            check_type(argname="argument domain_configuration_name", value=domain_configuration_name, expected_type=type_hints["domain_configuration_name"])
            check_type(argname="argument domain_configuration_status", value=domain_configuration_status, expected_type=type_hints["domain_configuration_status"])
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
            check_type(argname="argument server_certificate_arns", value=server_certificate_arns, expected_type=type_hints["server_certificate_arns"])
            check_type(argname="argument server_certificate_config", value=server_certificate_config, expected_type=type_hints["server_certificate_config"])
            check_type(argname="argument service_type", value=service_type, expected_type=type_hints["service_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument tls_config", value=tls_config, expected_type=type_hints["tls_config"])
            check_type(argname="argument validation_certificate_arn", value=validation_certificate_arn, expected_type=type_hints["validation_certificate_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if application_protocol is not None:
            self._values["application_protocol"] = application_protocol
        if authentication_type is not None:
            self._values["authentication_type"] = authentication_type
        if authorizer_config is not None:
            self._values["authorizer_config"] = authorizer_config
        if client_certificate_config is not None:
            self._values["client_certificate_config"] = client_certificate_config
        if domain_configuration_name is not None:
            self._values["domain_configuration_name"] = domain_configuration_name
        if domain_configuration_status is not None:
            self._values["domain_configuration_status"] = domain_configuration_status
        if domain_name is not None:
            self._values["domain_name"] = domain_name
        if server_certificate_arns is not None:
            self._values["server_certificate_arns"] = server_certificate_arns
        if server_certificate_config is not None:
            self._values["server_certificate_config"] = server_certificate_config
        if service_type is not None:
            self._values["service_type"] = service_type
        if tags is not None:
            self._values["tags"] = tags
        if tls_config is not None:
            self._values["tls_config"] = tls_config
        if validation_certificate_arn is not None:
            self._values["validation_certificate_arn"] = validation_certificate_arn

    @builtins.property
    def application_protocol(self) -> typing.Optional[builtins.str]:
        '''An enumerated string that species the application-layer protocol.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-applicationprotocol
        '''
        result = self._values.get("application_protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def authentication_type(self) -> typing.Optional[builtins.str]:
        '''An enumerated string that species the authentication type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-authenticationtype
        '''
        result = self._values.get("authentication_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def authorizer_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty"]]:
        '''An object that specifies the authorization service for a domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-authorizerconfig
        '''
        result = self._values.get("authorizer_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty"]], result)

    @builtins.property
    def client_certificate_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty"]]:
        '''An object that species the client certificate conguration for a domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-clientcertificateconfig
        '''
        result = self._values.get("client_certificate_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty"]], result)

    @builtins.property
    def domain_configuration_name(self) -> typing.Optional[builtins.str]:
        '''The name of the domain configuration.

        This value must be unique to a region.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-domainconfigurationname
        '''
        result = self._values.get("domain_configuration_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_configuration_status(self) -> typing.Optional[builtins.str]:
        '''The status to which the domain configuration should be updated.

        Valid values: ``ENABLED`` | ``DISABLED``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-domainconfigurationstatus
        '''
        result = self._values.get("domain_configuration_status")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_name(self) -> typing.Optional[builtins.str]:
        '''The name of the domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-domainname
        '''
        result = self._values.get("domain_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server_certificate_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake.

        Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-servercertificatearns
        '''
        result = self._values.get("server_certificate_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def server_certificate_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty"]]:
        '''The server certificate configuration.

        For more information, see `Configurable endpoints <https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html>`_ from the AWS IoT Core Developer Guide.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-servercertificateconfig
        '''
        result = self._values.get("server_certificate_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty"]], result)

    @builtins.property
    def service_type(self) -> typing.Optional[builtins.str]:
        '''The type of service delivered by the endpoint.

        .. epigraph::

           AWS IoT Core currently supports only the ``DATA`` service type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-servicetype
        '''
        result = self._values.get("service_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the domain configuration.

        .. epigraph::

           For URI Request parameters use format: ...key1=value1&key2=value2...

           For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..."

           For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def tls_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.TlsConfigProperty"]]:
        '''An object that specifies the TLS configuration for a domain.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-tlsconfig
        '''
        result = self._values.get("tls_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDomainConfigurationPropsMixin.TlsConfigProperty"]], result)

    @builtins.property
    def validation_certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The certificate used to validate the server certificate and prove domain name ownership.

        This certificate must be signed by a public certificate authority. This value is not required for AWS -managed domains.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html#cfn-iot-domainconfiguration-validationcertificatearn
        '''
        result = self._values.get("validation_certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDomainConfigurationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnDomainConfigurationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationPropsMixin",
):
    '''Specifies a domain configuration.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html
    :cloudformationResource: AWS::IoT::DomainConfiguration
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_domain_configuration_props_mixin = iot_mixins.CfnDomainConfigurationPropsMixin(iot_mixins.CfnDomainConfigurationMixinProps(
            application_protocol="applicationProtocol",
            authentication_type="authenticationType",
            authorizer_config=iot_mixins.CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty(
                allow_authorizer_override=False,
                default_authorizer_name="defaultAuthorizerName"
            ),
            client_certificate_config=iot_mixins.CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty(
                client_certificate_callback_arn="clientCertificateCallbackArn"
            ),
            domain_configuration_name="domainConfigurationName",
            domain_configuration_status="domainConfigurationStatus",
            domain_name="domainName",
            server_certificate_arns=["serverCertificateArns"],
            server_certificate_config=iot_mixins.CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty(
                enable_ocsp_check=False,
                ocsp_authorized_responder_arn="ocspAuthorizedResponderArn",
                ocsp_lambda_arn="ocspLambdaArn"
            ),
            service_type="serviceType",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            tls_config=iot_mixins.CfnDomainConfigurationPropsMixin.TlsConfigProperty(
                security_policy="securityPolicy"
            ),
            validation_certificate_arn="validationCertificateArn"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnDomainConfigurationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::DomainConfiguration``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26069dc7055a567e33b65dc10c39bb3dbccb1a56aa191781dda5c3ee8885b17d)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc0f9e80c710b5f1446af64b7a67966477fbe47772aae6b831433e9063414d89)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d8d15bebf40d8a9b22a378f1cbc4bb5ba8bddf395592358f26c175bf928ad0e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnDomainConfigurationMixinProps":
        return typing.cast("CfnDomainConfigurationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allow_authorizer_override": "allowAuthorizerOverride",
            "default_authorizer_name": "defaultAuthorizerName",
        },
    )
    class AuthorizerConfigProperty:
        def __init__(
            self,
            *,
            allow_authorizer_override: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            default_authorizer_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An object that specifies the authorization service for a domain.

            :param allow_authorizer_override: A Boolean that specifies whether the domain configuration's authorization service can be overridden.
            :param default_authorizer_name: The name of the authorization service for a domain configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-authorizerconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                authorizer_config_property = iot_mixins.CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty(
                    allow_authorizer_override=False,
                    default_authorizer_name="defaultAuthorizerName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8020f970ed22d520e6baad064adb05dd146f566e80a3512546711c4dbfd046cd)
                check_type(argname="argument allow_authorizer_override", value=allow_authorizer_override, expected_type=type_hints["allow_authorizer_override"])
                check_type(argname="argument default_authorizer_name", value=default_authorizer_name, expected_type=type_hints["default_authorizer_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if allow_authorizer_override is not None:
                self._values["allow_authorizer_override"] = allow_authorizer_override
            if default_authorizer_name is not None:
                self._values["default_authorizer_name"] = default_authorizer_name

        @builtins.property
        def allow_authorizer_override(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''A Boolean that specifies whether the domain configuration's authorization service can be overridden.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-authorizerconfig.html#cfn-iot-domainconfiguration-authorizerconfig-allowauthorizeroverride
            '''
            result = self._values.get("allow_authorizer_override")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def default_authorizer_name(self) -> typing.Optional[builtins.str]:
            '''The name of the authorization service for a domain configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-authorizerconfig.html#cfn-iot-domainconfiguration-authorizerconfig-defaultauthorizername
            '''
            result = self._values.get("default_authorizer_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AuthorizerConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "client_certificate_callback_arn": "clientCertificateCallbackArn",
        },
    )
    class ClientCertificateConfigProperty:
        def __init__(
            self,
            *,
            client_certificate_callback_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An object that species the client certificate conguration for a domain.

            :param client_certificate_callback_arn: The ARN of the Lambda function that IoT invokes after mutual TLS authentication during the connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-clientcertificateconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                client_certificate_config_property = iot_mixins.CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty(
                    client_certificate_callback_arn="clientCertificateCallbackArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8b426fadd3ec6dd7153cc9950f4377b98d24250fb1f1f2d1be57f4e221175dff)
                check_type(argname="argument client_certificate_callback_arn", value=client_certificate_callback_arn, expected_type=type_hints["client_certificate_callback_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if client_certificate_callback_arn is not None:
                self._values["client_certificate_callback_arn"] = client_certificate_callback_arn

        @builtins.property
        def client_certificate_callback_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the Lambda function that IoT invokes after mutual TLS authentication during the connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-clientcertificateconfig.html#cfn-iot-domainconfiguration-clientcertificateconfig-clientcertificatecallbackarn
            '''
            result = self._values.get("client_certificate_callback_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientCertificateConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_ocsp_check": "enableOcspCheck",
            "ocsp_authorized_responder_arn": "ocspAuthorizedResponderArn",
            "ocsp_lambda_arn": "ocspLambdaArn",
        },
    )
    class ServerCertificateConfigProperty:
        def __init__(
            self,
            *,
            enable_ocsp_check: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ocsp_authorized_responder_arn: typing.Optional[builtins.str] = None,
            ocsp_lambda_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The server certificate configuration.

            For more information, see `Configurable endpoints <https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html>`_ from the AWS IoT Core Developer Guide.

            :param enable_ocsp_check: A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see `Configurable endpoints <https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html>`_ from the AWS IoT Core Developer Guide.
            :param ocsp_authorized_responder_arn: The Amazon Resource Name (ARN) for an X.509 certificate stored in ACM. If provided, AWS IoT Core will use this certificate to validate the signature of the received OCSP response. The OCSP responder must sign responses using either this authorized responder certificate or the issuing certificate, depending on whether the ARN is provided or not. The certificate must be in the same account and region as the domain configuration.
            :param ocsp_lambda_arn: The Amazon Resource Name (ARN) for a Lambda function that acts as a Request for Comments (RFC) 6960-compliant Online Certificate Status Protocol (OCSP) responder, supporting basic OCSP responses. The Lambda function accepts a base64-encoding of the OCSP request in the Distinguished Encoding Rules (DER) format. The Lambda function's response is also a base64-encoded OCSP response in the DER format. The response size must not exceed 4 kilobytes (KiB). The Lambda function must be in the same account and region as the domain configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificateconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                server_certificate_config_property = iot_mixins.CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty(
                    enable_ocsp_check=False,
                    ocsp_authorized_responder_arn="ocspAuthorizedResponderArn",
                    ocsp_lambda_arn="ocspLambdaArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0bbd88e0d48869d5c52db7ffbb92bdd09e29fc4bb53e854a7ce97d517e8d5943)
                check_type(argname="argument enable_ocsp_check", value=enable_ocsp_check, expected_type=type_hints["enable_ocsp_check"])
                check_type(argname="argument ocsp_authorized_responder_arn", value=ocsp_authorized_responder_arn, expected_type=type_hints["ocsp_authorized_responder_arn"])
                check_type(argname="argument ocsp_lambda_arn", value=ocsp_lambda_arn, expected_type=type_hints["ocsp_lambda_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enable_ocsp_check is not None:
                self._values["enable_ocsp_check"] = enable_ocsp_check
            if ocsp_authorized_responder_arn is not None:
                self._values["ocsp_authorized_responder_arn"] = ocsp_authorized_responder_arn
            if ocsp_lambda_arn is not None:
                self._values["ocsp_lambda_arn"] = ocsp_lambda_arn

        @builtins.property
        def enable_ocsp_check(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not.

            For more information, see `Configurable endpoints <https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html>`_ from the AWS IoT Core Developer Guide.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificateconfig.html#cfn-iot-domainconfiguration-servercertificateconfig-enableocspcheck
            '''
            result = self._values.get("enable_ocsp_check")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ocsp_authorized_responder_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) for an X.509 certificate stored in ACM. If provided, AWS IoT Core will use this certificate to validate the signature of the received OCSP response. The OCSP responder must sign responses using either this authorized responder certificate or the issuing certificate, depending on whether the ARN is provided or not. The certificate must be in the same account and region as the domain configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificateconfig.html#cfn-iot-domainconfiguration-servercertificateconfig-ocspauthorizedresponderarn
            '''
            result = self._values.get("ocsp_authorized_responder_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ocsp_lambda_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) for a Lambda function that acts as a Request for Comments (RFC) 6960-compliant Online Certificate Status Protocol (OCSP) responder, supporting basic OCSP responses.

            The Lambda function accepts a base64-encoding of the OCSP request in the Distinguished Encoding Rules (DER) format. The Lambda function's response is also a base64-encoded OCSP response in the DER format. The response size must not exceed 4 kilobytes (KiB). The Lambda function must be in the same account and region as the domain configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificateconfig.html#cfn-iot-domainconfiguration-servercertificateconfig-ocsplambdaarn
            '''
            result = self._values.get("ocsp_lambda_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ServerCertificateConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationPropsMixin.ServerCertificateSummaryProperty",
        jsii_struct_bases=[],
        name_mapping={
            "server_certificate_arn": "serverCertificateArn",
            "server_certificate_status": "serverCertificateStatus",
            "server_certificate_status_detail": "serverCertificateStatusDetail",
        },
    )
    class ServerCertificateSummaryProperty:
        def __init__(
            self,
            *,
            server_certificate_arn: typing.Optional[builtins.str] = None,
            server_certificate_status: typing.Optional[builtins.str] = None,
            server_certificate_status_detail: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An object that contains information about a server certificate.

            :param server_certificate_arn: The ARN of the server certificate.
            :param server_certificate_status: The status of the server certificate.
            :param server_certificate_status_detail: Details that explain the status of the server certificate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificatesummary.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                server_certificate_summary_property = iot_mixins.CfnDomainConfigurationPropsMixin.ServerCertificateSummaryProperty(
                    server_certificate_arn="serverCertificateArn",
                    server_certificate_status="serverCertificateStatus",
                    server_certificate_status_detail="serverCertificateStatusDetail"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__159831730ae307e14fe9b506ffbe0c733613784b43a0a0eea41603cbd4904580)
                check_type(argname="argument server_certificate_arn", value=server_certificate_arn, expected_type=type_hints["server_certificate_arn"])
                check_type(argname="argument server_certificate_status", value=server_certificate_status, expected_type=type_hints["server_certificate_status"])
                check_type(argname="argument server_certificate_status_detail", value=server_certificate_status_detail, expected_type=type_hints["server_certificate_status_detail"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if server_certificate_arn is not None:
                self._values["server_certificate_arn"] = server_certificate_arn
            if server_certificate_status is not None:
                self._values["server_certificate_status"] = server_certificate_status
            if server_certificate_status_detail is not None:
                self._values["server_certificate_status_detail"] = server_certificate_status_detail

        @builtins.property
        def server_certificate_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the server certificate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificatesummary.html#cfn-iot-domainconfiguration-servercertificatesummary-servercertificatearn
            '''
            result = self._values.get("server_certificate_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def server_certificate_status(self) -> typing.Optional[builtins.str]:
            '''The status of the server certificate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificatesummary.html#cfn-iot-domainconfiguration-servercertificatesummary-servercertificatestatus
            '''
            result = self._values.get("server_certificate_status")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def server_certificate_status_detail(self) -> typing.Optional[builtins.str]:
            '''Details that explain the status of the server certificate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificatesummary.html#cfn-iot-domainconfiguration-servercertificatesummary-servercertificatestatusdetail
            '''
            result = self._values.get("server_certificate_status_detail")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ServerCertificateSummaryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnDomainConfigurationPropsMixin.TlsConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"security_policy": "securityPolicy"},
    )
    class TlsConfigProperty:
        def __init__(
            self,
            *,
            security_policy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An object that specifies the TLS configuration for a domain.

            :param security_policy: The security policy for a domain configuration. For more information, see `Security policies <https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table>`_ in the *AWS IoT Core developer guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-tlsconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                tls_config_property = iot_mixins.CfnDomainConfigurationPropsMixin.TlsConfigProperty(
                    security_policy="securityPolicy"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__75a342c56fedabbaf1a663a243ab9126bde6164e226e703af35ba0c5b819c1c3)
                check_type(argname="argument security_policy", value=security_policy, expected_type=type_hints["security_policy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if security_policy is not None:
                self._values["security_policy"] = security_policy

        @builtins.property
        def security_policy(self) -> typing.Optional[builtins.str]:
            '''The security policy for a domain configuration.

            For more information, see `Security policies <https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table>`_ in the *AWS IoT Core developer guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-tlsconfig.html#cfn-iot-domainconfiguration-tlsconfig-securitypolicy
            '''
            result = self._values.get("security_policy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TlsConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnEncryptionConfigurationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "encryption_type": "encryptionType",
        "kms_access_role_arn": "kmsAccessRoleArn",
        "kms_key_arn": "kmsKeyArn",
    },
)
class CfnEncryptionConfigurationMixinProps:
    def __init__(
        self,
        *,
        encryption_type: typing.Optional[builtins.str] = None,
        kms_access_role_arn: typing.Optional[builtins.str] = None,
        kms_key_arn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnEncryptionConfigurationPropsMixin.

        :param encryption_type: The type of the KMS key.
        :param kms_access_role_arn: The Amazon Resource Name (ARN) of the IAM role assumed by AWS IoT Core to call AWS on behalf of the customer.
        :param kms_key_arn: The ARN of the customer managed KMS key.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-encryptionconfiguration.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_encryption_configuration_mixin_props = iot_mixins.CfnEncryptionConfigurationMixinProps(
                encryption_type="encryptionType",
                kms_access_role_arn="kmsAccessRoleArn",
                kms_key_arn="kmsKeyArn"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5939c84a52e6d3a8fa77e30d07cc9d8cacddbcad72754e96971694e8c6151a83)
            check_type(argname="argument encryption_type", value=encryption_type, expected_type=type_hints["encryption_type"])
            check_type(argname="argument kms_access_role_arn", value=kms_access_role_arn, expected_type=type_hints["kms_access_role_arn"])
            check_type(argname="argument kms_key_arn", value=kms_key_arn, expected_type=type_hints["kms_key_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encryption_type is not None:
            self._values["encryption_type"] = encryption_type
        if kms_access_role_arn is not None:
            self._values["kms_access_role_arn"] = kms_access_role_arn
        if kms_key_arn is not None:
            self._values["kms_key_arn"] = kms_key_arn

    @builtins.property
    def encryption_type(self) -> typing.Optional[builtins.str]:
        '''The type of the KMS key.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-encryptionconfiguration.html#cfn-iot-encryptionconfiguration-encryptiontype
        '''
        result = self._values.get("encryption_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kms_access_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the IAM role assumed by AWS IoT Core to call AWS  on behalf of the customer.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-encryptionconfiguration.html#cfn-iot-encryptionconfiguration-kmsaccessrolearn
        '''
        result = self._values.get("kms_access_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kms_key_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the customer managed KMS key.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-encryptionconfiguration.html#cfn-iot-encryptionconfiguration-kmskeyarn
        '''
        result = self._values.get("kms_key_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEncryptionConfigurationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnEncryptionConfigurationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnEncryptionConfigurationPropsMixin",
):
    '''Retrieves the encryption configuration for resources and data of your AWS account in AWS IoT Core .

    For more information, see `Data encryption at rest <https://docs.aws.amazon.com/iot/latest/developerguide/encryption-at-rest.html>`_ in the *AWS IoT Core Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-encryptionconfiguration.html
    :cloudformationResource: AWS::IoT::EncryptionConfiguration
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_encryption_configuration_props_mixin = iot_mixins.CfnEncryptionConfigurationPropsMixin(iot_mixins.CfnEncryptionConfigurationMixinProps(
            encryption_type="encryptionType",
            kms_access_role_arn="kmsAccessRoleArn",
            kms_key_arn="kmsKeyArn"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnEncryptionConfigurationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::EncryptionConfiguration``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2db42c6d4b9bbfc3d353b0e9d2e99350fc013c9b2d9aba859b87ea758c287b64)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34d8aa20fcf49dcb1cb1303dd0bb9c551ef3ab1a2194ac137bc1a40591c83df0)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3537472d34295df31fb76c9656ca4c8089bf6cf7aaf480349db9be6141017a8d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnEncryptionConfigurationMixinProps":
        return typing.cast("CfnEncryptionConfigurationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnEncryptionConfigurationPropsMixin.ConfigurationDetailsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "configuration_status": "configurationStatus",
            "error_code": "errorCode",
            "error_message": "errorMessage",
        },
    )
    class ConfigurationDetailsProperty:
        def __init__(
            self,
            *,
            configuration_status: typing.Optional[builtins.str] = None,
            error_code: typing.Optional[builtins.str] = None,
            error_message: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The encryption configuration details that include the status information of the AWS Key Management Service ( AWS  ) key and the AWS  access role.

            :param configuration_status: The health status of KMS key and AWS access role. If either KMS key or AWS access role is ``UNHEALTHY`` , the return value will be ``UNHEALTHY`` . To use a customer managed KMS key, the value of ``configurationStatus`` must be ``HEALTHY`` .
            :param error_code: The error code that indicates either the KMS key or the AWS access role is ``UNHEALTHY`` . Valid values: ``KMS_KEY_VALIDATION_ERROR`` and ``ROLE_VALIDATION_ERROR`` .
            :param error_message: The detailed error message that corresponds to the ``errorCode`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-encryptionconfiguration-configurationdetails.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                configuration_details_property = iot_mixins.CfnEncryptionConfigurationPropsMixin.ConfigurationDetailsProperty(
                    configuration_status="configurationStatus",
                    error_code="errorCode",
                    error_message="errorMessage"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__96d32469a173c24e2564e429c30aa39110c7cc4ad362f3af9a07a7a16b272ea4)
                check_type(argname="argument configuration_status", value=configuration_status, expected_type=type_hints["configuration_status"])
                check_type(argname="argument error_code", value=error_code, expected_type=type_hints["error_code"])
                check_type(argname="argument error_message", value=error_message, expected_type=type_hints["error_message"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configuration_status is not None:
                self._values["configuration_status"] = configuration_status
            if error_code is not None:
                self._values["error_code"] = error_code
            if error_message is not None:
                self._values["error_message"] = error_message

        @builtins.property
        def configuration_status(self) -> typing.Optional[builtins.str]:
            '''The health status of KMS key and AWS  access role.

            If either KMS key or AWS  access role is ``UNHEALTHY`` , the return value will be ``UNHEALTHY`` . To use a customer managed KMS key, the value of ``configurationStatus`` must be ``HEALTHY`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-encryptionconfiguration-configurationdetails.html#cfn-iot-encryptionconfiguration-configurationdetails-configurationstatus
            '''
            result = self._values.get("configuration_status")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def error_code(self) -> typing.Optional[builtins.str]:
            '''The error code that indicates either the KMS key or the AWS  access role is ``UNHEALTHY`` .

            Valid values: ``KMS_KEY_VALIDATION_ERROR`` and ``ROLE_VALIDATION_ERROR`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-encryptionconfiguration-configurationdetails.html#cfn-iot-encryptionconfiguration-configurationdetails-errorcode
            '''
            result = self._values.get("error_code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def error_message(self) -> typing.Optional[builtins.str]:
            '''The detailed error message that corresponds to the ``errorCode`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-encryptionconfiguration-configurationdetails.html#cfn-iot-encryptionconfiguration-configurationdetails-errormessage
            '''
            result = self._values.get("error_message")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConfigurationDetailsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnFleetMetricMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation_field": "aggregationField",
        "aggregation_type": "aggregationType",
        "description": "description",
        "index_name": "indexName",
        "metric_name": "metricName",
        "period": "period",
        "query_string": "queryString",
        "query_version": "queryVersion",
        "tags": "tags",
        "unit": "unit",
    },
)
class CfnFleetMetricMixinProps:
    def __init__(
        self,
        *,
        aggregation_field: typing.Optional[builtins.str] = None,
        aggregation_type: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFleetMetricPropsMixin.AggregationTypeProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        index_name: typing.Optional[builtins.str] = None,
        metric_name: typing.Optional[builtins.str] = None,
        period: typing.Optional[jsii.Number] = None,
        query_string: typing.Optional[builtins.str] = None,
        query_version: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnFleetMetricPropsMixin.

        :param aggregation_field: The field to aggregate.
        :param aggregation_type: The type of the aggregation query.
        :param description: The fleet metric description.
        :param index_name: The name of the index to search.
        :param metric_name: The name of the fleet metric to create.
        :param period: The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
        :param query_string: The search query string.
        :param query_version: The query version.
        :param tags: Metadata which can be used to manage the fleet metric.
        :param unit: Used to support unit transformation such as milliseconds to seconds. Must be a unit supported by CW metric. Default to null.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_fleet_metric_mixin_props = iot_mixins.CfnFleetMetricMixinProps(
                aggregation_field="aggregationField",
                aggregation_type=iot_mixins.CfnFleetMetricPropsMixin.AggregationTypeProperty(
                    name="name",
                    values=["values"]
                ),
                description="description",
                index_name="indexName",
                metric_name="metricName",
                period=123,
                query_string="queryString",
                query_version="queryVersion",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                unit="unit"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87a28f246d63013d50ef6b88b0262a6e07d493491cd7d8a3fbc01582ef9191b5)
            check_type(argname="argument aggregation_field", value=aggregation_field, expected_type=type_hints["aggregation_field"])
            check_type(argname="argument aggregation_type", value=aggregation_type, expected_type=type_hints["aggregation_type"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument index_name", value=index_name, expected_type=type_hints["index_name"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument query_string", value=query_string, expected_type=type_hints["query_string"])
            check_type(argname="argument query_version", value=query_version, expected_type=type_hints["query_version"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument unit", value=unit, expected_type=type_hints["unit"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if aggregation_field is not None:
            self._values["aggregation_field"] = aggregation_field
        if aggregation_type is not None:
            self._values["aggregation_type"] = aggregation_type
        if description is not None:
            self._values["description"] = description
        if index_name is not None:
            self._values["index_name"] = index_name
        if metric_name is not None:
            self._values["metric_name"] = metric_name
        if period is not None:
            self._values["period"] = period
        if query_string is not None:
            self._values["query_string"] = query_string
        if query_version is not None:
            self._values["query_version"] = query_version
        if tags is not None:
            self._values["tags"] = tags
        if unit is not None:
            self._values["unit"] = unit

    @builtins.property
    def aggregation_field(self) -> typing.Optional[builtins.str]:
        '''The field to aggregate.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-aggregationfield
        '''
        result = self._values.get("aggregation_field")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def aggregation_type(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFleetMetricPropsMixin.AggregationTypeProperty"]]:
        '''The type of the aggregation query.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-aggregationtype
        '''
        result = self._values.get("aggregation_type")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFleetMetricPropsMixin.AggregationTypeProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The fleet metric description.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def index_name(self) -> typing.Optional[builtins.str]:
        '''The name of the index to search.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-indexname
        '''
        result = self._values.get("index_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric_name(self) -> typing.Optional[builtins.str]:
        '''The name of the fleet metric to create.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-metricname
        '''
        result = self._values.get("metric_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        '''The time in seconds between fleet metric emissions.

        Range [60(1 min), 86400(1 day)] and must be multiple of 60.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-period
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def query_string(self) -> typing.Optional[builtins.str]:
        '''The search query string.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-querystring
        '''
        result = self._values.get("query_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query_version(self) -> typing.Optional[builtins.str]:
        '''The query version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-queryversion
        '''
        result = self._values.get("query_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the fleet metric.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def unit(self) -> typing.Optional[builtins.str]:
        '''Used to support unit transformation such as milliseconds to seconds.

        Must be a unit supported by CW metric. Default to null.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html#cfn-iot-fleetmetric-unit
        '''
        result = self._values.get("unit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnFleetMetricMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnFleetMetricPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnFleetMetricPropsMixin",
):
    '''Use the ``AWS::IoT::FleetMetric`` resource to declare a fleet metric.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html
    :cloudformationResource: AWS::IoT::FleetMetric
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_fleet_metric_props_mixin = iot_mixins.CfnFleetMetricPropsMixin(iot_mixins.CfnFleetMetricMixinProps(
            aggregation_field="aggregationField",
            aggregation_type=iot_mixins.CfnFleetMetricPropsMixin.AggregationTypeProperty(
                name="name",
                values=["values"]
            ),
            description="description",
            index_name="indexName",
            metric_name="metricName",
            period=123,
            query_string="queryString",
            query_version="queryVersion",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            unit="unit"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnFleetMetricMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::FleetMetric``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf20c80124d26d8092b6950df44aa8b75de6b6ec59d5db741459e9d1b57991e4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04c3f0e4430483fd1bd1de67ab0cbe792558b5cfaee1ce07d9b5c9f318e24b86)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9561fb9ccacaf7fdd5ea0e9b52f2fe34eb69c68e406eb9768f832b5bc739bd5e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnFleetMetricMixinProps":
        return typing.cast("CfnFleetMetricMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnFleetMetricPropsMixin.AggregationTypeProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "values": "values"},
    )
    class AggregationTypeProperty:
        def __init__(
            self,
            *,
            name: typing.Optional[builtins.str] = None,
            values: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''The type of aggregation queries.

            :param name: The name of the aggregation type.
            :param values: A list of the values of aggregation types.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-fleetmetric-aggregationtype.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                aggregation_type_property = iot_mixins.CfnFleetMetricPropsMixin.AggregationTypeProperty(
                    name="name",
                    values=["values"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__888de911ead46d9b0aa6b82b7810251450bcc4d49395a2aec23898facca7ac27)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument values", value=values, expected_type=type_hints["values"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name
            if values is not None:
                self._values["values"] = values

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the aggregation type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-fleetmetric-aggregationtype.html#cfn-iot-fleetmetric-aggregationtype-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def values(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of the values of aggregation types.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-fleetmetric-aggregationtype.html#cfn-iot-fleetmetric-aggregationtype-values
            '''
            result = self._values.get("values")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AggregationTypeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplateMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "abort_config": "abortConfig",
        "description": "description",
        "destination_package_versions": "destinationPackageVersions",
        "document": "document",
        "document_source": "documentSource",
        "job_arn": "jobArn",
        "job_executions_retry_config": "jobExecutionsRetryConfig",
        "job_executions_rollout_config": "jobExecutionsRolloutConfig",
        "job_template_id": "jobTemplateId",
        "maintenance_windows": "maintenanceWindows",
        "presigned_url_config": "presignedUrlConfig",
        "tags": "tags",
        "timeout_config": "timeoutConfig",
    },
)
class CfnJobTemplateMixinProps:
    def __init__(
        self,
        *,
        abort_config: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        destination_package_versions: typing.Optional[typing.Sequence[builtins.str]] = None,
        document: typing.Optional[builtins.str] = None,
        document_source: typing.Optional[builtins.str] = None,
        job_arn: typing.Optional[builtins.str] = None,
        job_executions_retry_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        job_executions_rollout_config: typing.Any = None,
        job_template_id: typing.Optional[builtins.str] = None,
        maintenance_windows: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnJobTemplatePropsMixin.MaintenanceWindowProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        presigned_url_config: typing.Any = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        timeout_config: typing.Any = None,
    ) -> None:
        '''Properties for CfnJobTemplatePropsMixin.

        :param abort_config: The criteria that determine when and how a job abort takes place.
        :param description: A description of the job template.
        :param destination_package_versions: The package version Amazon Resource Names (ARNs) that are installed on the devices reserved named shadow ( ``$package`` ) when the job successfully completes. *Note:* Up to 25 package version ARNS are allowed.
        :param document: The job document. Required if you don't specify a value for ``documentSource`` .
        :param document_source: An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for ``document`` . For example, ``--document-source https://s3. *region-code* .amazonaws.com/example-firmware/device-firmware.1.0`` For more information, see `Methods for accessing a bucket <https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html>`_ .
        :param job_arn: The ARN of the job to use as the basis for the job template.
        :param job_executions_retry_config: Allows you to create the criteria to retry a job.
        :param job_executions_rollout_config: Allows you to create a staged rollout of a job.
        :param job_template_id: A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.
        :param maintenance_windows: An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.
        :param presigned_url_config: Configuration for pre-signed S3 URLs.
        :param tags: Metadata that can be used to manage the job template.
        :param timeout_config: Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to ``IN_PROGRESS`` . If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to ``TIMED_OUT`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            # abort_config: Any
            # job_executions_rollout_config: Any
            # presigned_url_config: Any
            # timeout_config: Any
            
            cfn_job_template_mixin_props = iot_mixins.CfnJobTemplateMixinProps(
                abort_config=abort_config,
                description="description",
                destination_package_versions=["destinationPackageVersions"],
                document="document",
                document_source="documentSource",
                job_arn="jobArn",
                job_executions_retry_config=iot_mixins.CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty(
                    retry_criteria_list=[iot_mixins.CfnJobTemplatePropsMixin.RetryCriteriaProperty(
                        failure_type="failureType",
                        number_of_retries=123
                    )]
                ),
                job_executions_rollout_config=job_executions_rollout_config,
                job_template_id="jobTemplateId",
                maintenance_windows=[iot_mixins.CfnJobTemplatePropsMixin.MaintenanceWindowProperty(
                    duration_in_minutes=123,
                    start_time="startTime"
                )],
                presigned_url_config=presigned_url_config,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                timeout_config=timeout_config
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aeb9a1e7dcff174c7875a2a1b9ffe85855ef5d40a242326fe430639fe65e6096)
            check_type(argname="argument abort_config", value=abort_config, expected_type=type_hints["abort_config"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_package_versions", value=destination_package_versions, expected_type=type_hints["destination_package_versions"])
            check_type(argname="argument document", value=document, expected_type=type_hints["document"])
            check_type(argname="argument document_source", value=document_source, expected_type=type_hints["document_source"])
            check_type(argname="argument job_arn", value=job_arn, expected_type=type_hints["job_arn"])
            check_type(argname="argument job_executions_retry_config", value=job_executions_retry_config, expected_type=type_hints["job_executions_retry_config"])
            check_type(argname="argument job_executions_rollout_config", value=job_executions_rollout_config, expected_type=type_hints["job_executions_rollout_config"])
            check_type(argname="argument job_template_id", value=job_template_id, expected_type=type_hints["job_template_id"])
            check_type(argname="argument maintenance_windows", value=maintenance_windows, expected_type=type_hints["maintenance_windows"])
            check_type(argname="argument presigned_url_config", value=presigned_url_config, expected_type=type_hints["presigned_url_config"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument timeout_config", value=timeout_config, expected_type=type_hints["timeout_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if abort_config is not None:
            self._values["abort_config"] = abort_config
        if description is not None:
            self._values["description"] = description
        if destination_package_versions is not None:
            self._values["destination_package_versions"] = destination_package_versions
        if document is not None:
            self._values["document"] = document
        if document_source is not None:
            self._values["document_source"] = document_source
        if job_arn is not None:
            self._values["job_arn"] = job_arn
        if job_executions_retry_config is not None:
            self._values["job_executions_retry_config"] = job_executions_retry_config
        if job_executions_rollout_config is not None:
            self._values["job_executions_rollout_config"] = job_executions_rollout_config
        if job_template_id is not None:
            self._values["job_template_id"] = job_template_id
        if maintenance_windows is not None:
            self._values["maintenance_windows"] = maintenance_windows
        if presigned_url_config is not None:
            self._values["presigned_url_config"] = presigned_url_config
        if tags is not None:
            self._values["tags"] = tags
        if timeout_config is not None:
            self._values["timeout_config"] = timeout_config

    @builtins.property
    def abort_config(self) -> typing.Any:
        '''The criteria that determine when and how a job abort takes place.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-abortconfig
        '''
        result = self._values.get("abort_config")
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the job template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_package_versions(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The package version Amazon Resource Names (ARNs) that are installed on the devices reserved named shadow ( ``$package`` ) when the job successfully completes.

        *Note:* Up to 25 package version ARNS are allowed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-destinationpackageversions
        '''
        result = self._values.get("destination_package_versions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def document(self) -> typing.Optional[builtins.str]:
        '''The job document.

        Required if you don't specify a value for ``documentSource`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-document
        '''
        result = self._values.get("document")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def document_source(self) -> typing.Optional[builtins.str]:
        '''An S3 link, or S3 object URL, to the job document.

        The link is an Amazon S3 object URL and is required if you don't specify a value for ``document`` .

        For example, ``--document-source https://s3. *region-code* .amazonaws.com/example-firmware/device-firmware.1.0``

        For more information, see `Methods for accessing a bucket <https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-documentsource
        '''
        result = self._values.get("document_source")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def job_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the job to use as the basis for the job template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-jobarn
        '''
        result = self._values.get("job_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def job_executions_retry_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty"]]:
        '''Allows you to create the criteria to retry a job.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-jobexecutionsretryconfig
        '''
        result = self._values.get("job_executions_retry_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty"]], result)

    @builtins.property
    def job_executions_rollout_config(self) -> typing.Any:
        '''Allows you to create a staged rollout of a job.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-jobexecutionsrolloutconfig
        '''
        result = self._values.get("job_executions_rollout_config")
        return typing.cast(typing.Any, result)

    @builtins.property
    def job_template_id(self) -> typing.Optional[builtins.str]:
        '''A unique identifier for the job template.

        We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-jobtemplateid
        '''
        result = self._values.get("job_template_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def maintenance_windows(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.MaintenanceWindowProperty"]]]]:
        '''An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-maintenancewindows
        '''
        result = self._values.get("maintenance_windows")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.MaintenanceWindowProperty"]]]], result)

    @builtins.property
    def presigned_url_config(self) -> typing.Any:
        '''Configuration for pre-signed S3 URLs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-presignedurlconfig
        '''
        result = self._values.get("presigned_url_config")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the job template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def timeout_config(self) -> typing.Any:
        '''Specifies the amount of time each device has to finish its execution of the job.

        A timer is started when the job execution status is set to ``IN_PROGRESS`` . If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to ``TIMED_OUT`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html#cfn-iot-jobtemplate-timeoutconfig
        '''
        result = self._values.get("timeout_config")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnJobTemplateMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnJobTemplatePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin",
):
    '''Represents a job template.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html
    :cloudformationResource: AWS::IoT::JobTemplate
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        # abort_config: Any
        # job_executions_rollout_config: Any
        # presigned_url_config: Any
        # timeout_config: Any
        
        cfn_job_template_props_mixin = iot_mixins.CfnJobTemplatePropsMixin(iot_mixins.CfnJobTemplateMixinProps(
            abort_config=abort_config,
            description="description",
            destination_package_versions=["destinationPackageVersions"],
            document="document",
            document_source="documentSource",
            job_arn="jobArn",
            job_executions_retry_config=iot_mixins.CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty(
                retry_criteria_list=[iot_mixins.CfnJobTemplatePropsMixin.RetryCriteriaProperty(
                    failure_type="failureType",
                    number_of_retries=123
                )]
            ),
            job_executions_rollout_config=job_executions_rollout_config,
            job_template_id="jobTemplateId",
            maintenance_windows=[iot_mixins.CfnJobTemplatePropsMixin.MaintenanceWindowProperty(
                duration_in_minutes=123,
                start_time="startTime"
            )],
            presigned_url_config=presigned_url_config,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            timeout_config=timeout_config
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnJobTemplateMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::JobTemplate``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4729cefa94efc854c352d30682b4dd96c4750f0565c8a0f7529b11149a2b9090)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7248f85ced016c44e3c842e3a66409e594ddfc8fbdfa8d63bf173d26e42785c6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fb182fa7de811d2f788767cee8807ca64960b9a02e0722722574737bf4f38e1)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnJobTemplateMixinProps":
        return typing.cast("CfnJobTemplateMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.AbortConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"criteria_list": "criteriaList"},
    )
    class AbortConfigProperty:
        def __init__(
            self,
            *,
            criteria_list: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnJobTemplatePropsMixin.AbortCriteriaProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The criteria that determine when and how a job abort takes place.

            :param criteria_list: The list of criteria that determine when and how to abort the job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                abort_config_property = iot_mixins.CfnJobTemplatePropsMixin.AbortConfigProperty(
                    criteria_list=[iot_mixins.CfnJobTemplatePropsMixin.AbortCriteriaProperty(
                        action="action",
                        failure_type="failureType",
                        min_number_of_executed_things=123,
                        threshold_percentage=123
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1ac36ec54e7adf86a2e7c3ff1f155695d7fbb26ffefddf9fedce8a2e85809c7f)
                check_type(argname="argument criteria_list", value=criteria_list, expected_type=type_hints["criteria_list"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if criteria_list is not None:
                self._values["criteria_list"] = criteria_list

        @builtins.property
        def criteria_list(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.AbortCriteriaProperty"]]]]:
            '''The list of criteria that determine when and how to abort the job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortconfig.html#cfn-iot-jobtemplate-abortconfig-criterialist
            '''
            result = self._values.get("criteria_list")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.AbortCriteriaProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AbortConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.AbortCriteriaProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "failure_type": "failureType",
            "min_number_of_executed_things": "minNumberOfExecutedThings",
            "threshold_percentage": "thresholdPercentage",
        },
    )
    class AbortCriteriaProperty:
        def __init__(
            self,
            *,
            action: typing.Optional[builtins.str] = None,
            failure_type: typing.Optional[builtins.str] = None,
            min_number_of_executed_things: typing.Optional[jsii.Number] = None,
            threshold_percentage: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The criteria that determine when and how a job abort takes place.

            :param action: The type of job action to take to initiate the job abort.
            :param failure_type: The type of job execution failures that can initiate a job abort.
            :param min_number_of_executed_things: The minimum number of things which must receive job execution notifications before the job can be aborted.
            :param threshold_percentage: The minimum percentage of job execution failures that must occur to initiate the job abort. AWS IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortcriteria.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                abort_criteria_property = iot_mixins.CfnJobTemplatePropsMixin.AbortCriteriaProperty(
                    action="action",
                    failure_type="failureType",
                    min_number_of_executed_things=123,
                    threshold_percentage=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__210dee595cc959d930be685c8bc1a7d4ef70faa60ba0c5624121c028fddfd1b0)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument failure_type", value=failure_type, expected_type=type_hints["failure_type"])
                check_type(argname="argument min_number_of_executed_things", value=min_number_of_executed_things, expected_type=type_hints["min_number_of_executed_things"])
                check_type(argname="argument threshold_percentage", value=threshold_percentage, expected_type=type_hints["threshold_percentage"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action is not None:
                self._values["action"] = action
            if failure_type is not None:
                self._values["failure_type"] = failure_type
            if min_number_of_executed_things is not None:
                self._values["min_number_of_executed_things"] = min_number_of_executed_things
            if threshold_percentage is not None:
                self._values["threshold_percentage"] = threshold_percentage

        @builtins.property
        def action(self) -> typing.Optional[builtins.str]:
            '''The type of job action to take to initiate the job abort.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortcriteria.html#cfn-iot-jobtemplate-abortcriteria-action
            '''
            result = self._values.get("action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def failure_type(self) -> typing.Optional[builtins.str]:
            '''The type of job execution failures that can initiate a job abort.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortcriteria.html#cfn-iot-jobtemplate-abortcriteria-failuretype
            '''
            result = self._values.get("failure_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def min_number_of_executed_things(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of things which must receive job execution notifications before the job can be aborted.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortcriteria.html#cfn-iot-jobtemplate-abortcriteria-minnumberofexecutedthings
            '''
            result = self._values.get("min_number_of_executed_things")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def threshold_percentage(self) -> typing.Optional[jsii.Number]:
            '''The minimum percentage of job execution failures that must occur to initiate the job abort.

            AWS IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortcriteria.html#cfn-iot-jobtemplate-abortcriteria-thresholdpercentage
            '''
            result = self._values.get("threshold_percentage")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AbortCriteriaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty",
        jsii_struct_bases=[],
        name_mapping={
            "base_rate_per_minute": "baseRatePerMinute",
            "increment_factor": "incrementFactor",
            "rate_increase_criteria": "rateIncreaseCriteria",
        },
    )
    class ExponentialRolloutRateProperty:
        def __init__(
            self,
            *,
            base_rate_per_minute: typing.Optional[jsii.Number] = None,
            increment_factor: typing.Optional[jsii.Number] = None,
            rate_increase_criteria: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Allows you to create an exponential rate of rollout for a job.

            :param base_rate_per_minute: The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
            :param increment_factor: The exponential factor to increase the rate of rollout for a job. AWS IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).
            :param rate_increase_criteria: The criteria to initiate the increase in rate of rollout for a job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-exponentialrolloutrate.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                exponential_rollout_rate_property = iot_mixins.CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty(
                    base_rate_per_minute=123,
                    increment_factor=123,
                    rate_increase_criteria=iot_mixins.CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty(
                        number_of_notified_things=123,
                        number_of_succeeded_things=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fe805b0ccd305a6ae460cfc3747a29e277069b35f0296f822d03f828f3d157f4)
                check_type(argname="argument base_rate_per_minute", value=base_rate_per_minute, expected_type=type_hints["base_rate_per_minute"])
                check_type(argname="argument increment_factor", value=increment_factor, expected_type=type_hints["increment_factor"])
                check_type(argname="argument rate_increase_criteria", value=rate_increase_criteria, expected_type=type_hints["rate_increase_criteria"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if base_rate_per_minute is not None:
                self._values["base_rate_per_minute"] = base_rate_per_minute
            if increment_factor is not None:
                self._values["increment_factor"] = increment_factor
            if rate_increase_criteria is not None:
                self._values["rate_increase_criteria"] = rate_increase_criteria

        @builtins.property
        def base_rate_per_minute(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of things that will be notified of a pending job, per minute at the start of job rollout.

            This parameter allows you to define the initial rate of rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-exponentialrolloutrate.html#cfn-iot-jobtemplate-exponentialrolloutrate-baserateperminute
            '''
            result = self._values.get("base_rate_per_minute")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def increment_factor(self) -> typing.Optional[jsii.Number]:
            '''The exponential factor to increase the rate of rollout for a job.

            AWS IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-exponentialrolloutrate.html#cfn-iot-jobtemplate-exponentialrolloutrate-incrementfactor
            '''
            result = self._values.get("increment_factor")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def rate_increase_criteria(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty"]]:
            '''The criteria to initiate the increase in rate of rollout for a job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-exponentialrolloutrate.html#cfn-iot-jobtemplate-exponentialrolloutrate-rateincreasecriteria
            '''
            result = self._values.get("rate_increase_criteria")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ExponentialRolloutRateProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"retry_criteria_list": "retryCriteriaList"},
    )
    class JobExecutionsRetryConfigProperty:
        def __init__(
            self,
            *,
            retry_criteria_list: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnJobTemplatePropsMixin.RetryCriteriaProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The configuration that determines how many retries are allowed for each failure type for a job.

            :param retry_criteria_list: The list of criteria that determines how many retries are allowed for each failure type for a job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsretryconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                job_executions_retry_config_property = iot_mixins.CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty(
                    retry_criteria_list=[iot_mixins.CfnJobTemplatePropsMixin.RetryCriteriaProperty(
                        failure_type="failureType",
                        number_of_retries=123
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__013e3e1f699fd5fa866ae58efdd5eebc36e087b7e80fb4aa5ffcf89ad927721a)
                check_type(argname="argument retry_criteria_list", value=retry_criteria_list, expected_type=type_hints["retry_criteria_list"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if retry_criteria_list is not None:
                self._values["retry_criteria_list"] = retry_criteria_list

        @builtins.property
        def retry_criteria_list(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.RetryCriteriaProperty"]]]]:
            '''The list of criteria that determines how many retries are allowed for each failure type for a job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsretryconfig.html#cfn-iot-jobtemplate-jobexecutionsretryconfig-retrycriterialist
            '''
            result = self._values.get("retry_criteria_list")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.RetryCriteriaProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "JobExecutionsRetryConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.JobExecutionsRolloutConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "exponential_rollout_rate": "exponentialRolloutRate",
            "maximum_per_minute": "maximumPerMinute",
        },
    )
    class JobExecutionsRolloutConfigProperty:
        def __init__(
            self,
            *,
            exponential_rollout_rate: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            maximum_per_minute: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Allows you to create a staged rollout of a job.

            :param exponential_rollout_rate: The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
            :param maximum_per_minute: The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsrolloutconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                job_executions_rollout_config_property = iot_mixins.CfnJobTemplatePropsMixin.JobExecutionsRolloutConfigProperty(
                    exponential_rollout_rate=iot_mixins.CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty(
                        base_rate_per_minute=123,
                        increment_factor=123,
                        rate_increase_criteria=iot_mixins.CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty(
                            number_of_notified_things=123,
                            number_of_succeeded_things=123
                        )
                    ),
                    maximum_per_minute=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__744d75e04e14f1b0a4dd227b2e308bcbd53c0fefb6192be3fb6fd2e3c5bc65bd)
                check_type(argname="argument exponential_rollout_rate", value=exponential_rollout_rate, expected_type=type_hints["exponential_rollout_rate"])
                check_type(argname="argument maximum_per_minute", value=maximum_per_minute, expected_type=type_hints["maximum_per_minute"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if exponential_rollout_rate is not None:
                self._values["exponential_rollout_rate"] = exponential_rollout_rate
            if maximum_per_minute is not None:
                self._values["maximum_per_minute"] = maximum_per_minute

        @builtins.property
        def exponential_rollout_rate(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty"]]:
            '''The rate of increase for a job rollout.

            This parameter allows you to define an exponential rate for a job rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsrolloutconfig.html#cfn-iot-jobtemplate-jobexecutionsrolloutconfig-exponentialrolloutrate
            '''
            result = self._values.get("exponential_rollout_rate")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty"]], result)

        @builtins.property
        def maximum_per_minute(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of things that will be notified of a pending job, per minute.

            This parameter allows you to create a staged rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsrolloutconfig.html#cfn-iot-jobtemplate-jobexecutionsrolloutconfig-maximumperminute
            '''
            result = self._values.get("maximum_per_minute")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "JobExecutionsRolloutConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.MaintenanceWindowProperty",
        jsii_struct_bases=[],
        name_mapping={
            "duration_in_minutes": "durationInMinutes",
            "start_time": "startTime",
        },
    )
    class MaintenanceWindowProperty:
        def __init__(
            self,
            *,
            duration_in_minutes: typing.Optional[jsii.Number] = None,
            start_time: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An optional configuration within the ``SchedulingConfig`` to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.

            :param duration_in_minutes: Displays the duration of the next maintenance window.
            :param start_time: Displays the start time of the next maintenance window.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-maintenancewindow.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                maintenance_window_property = iot_mixins.CfnJobTemplatePropsMixin.MaintenanceWindowProperty(
                    duration_in_minutes=123,
                    start_time="startTime"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__91b861dffe1858ac2024521dffa1932c0037b8b9504e9360d1a76d44c5a08320)
                check_type(argname="argument duration_in_minutes", value=duration_in_minutes, expected_type=type_hints["duration_in_minutes"])
                check_type(argname="argument start_time", value=start_time, expected_type=type_hints["start_time"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if duration_in_minutes is not None:
                self._values["duration_in_minutes"] = duration_in_minutes
            if start_time is not None:
                self._values["start_time"] = start_time

        @builtins.property
        def duration_in_minutes(self) -> typing.Optional[jsii.Number]:
            '''Displays the duration of the next maintenance window.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-maintenancewindow.html#cfn-iot-jobtemplate-maintenancewindow-durationinminutes
            '''
            result = self._values.get("duration_in_minutes")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def start_time(self) -> typing.Optional[builtins.str]:
            '''Displays the start time of the next maintenance window.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-maintenancewindow.html#cfn-iot-jobtemplate-maintenancewindow-starttime
            '''
            result = self._values.get("start_time")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MaintenanceWindowProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.PresignedUrlConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"expires_in_sec": "expiresInSec", "role_arn": "roleArn"},
    )
    class PresignedUrlConfigProperty:
        def __init__(
            self,
            *,
            expires_in_sec: typing.Optional[jsii.Number] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration for pre-signed S3 URLs.

            :param expires_in_sec: How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
            :param role_arn: The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files. .. epigraph:: For information about addressing the confused deputy problem, see `cross-service confused deputy prevention <https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html>`_ in the *AWS IoT Core developer guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-presignedurlconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                presigned_url_config_property = iot_mixins.CfnJobTemplatePropsMixin.PresignedUrlConfigProperty(
                    expires_in_sec=123,
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dbb99c6e24a9633bed497d244e38f7a3cdbda8b4a789f8fc4fb7244b64e61987)
                check_type(argname="argument expires_in_sec", value=expires_in_sec, expected_type=type_hints["expires_in_sec"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if expires_in_sec is not None:
                self._values["expires_in_sec"] = expires_in_sec
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def expires_in_sec(self) -> typing.Optional[jsii.Number]:
            '''How long (in seconds) pre-signed URLs are valid.

            Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-presignedurlconfig.html#cfn-iot-jobtemplate-presignedurlconfig-expiresinsec
            '''
            result = self._values.get("expires_in_sec")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored.

            The role must also grant permission for IoT to download the files.
            .. epigraph::

               For information about addressing the confused deputy problem, see `cross-service confused deputy prevention <https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html>`_ in the *AWS IoT Core developer guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-presignedurlconfig.html#cfn-iot-jobtemplate-presignedurlconfig-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PresignedUrlConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty",
        jsii_struct_bases=[],
        name_mapping={
            "number_of_notified_things": "numberOfNotifiedThings",
            "number_of_succeeded_things": "numberOfSucceededThings",
        },
    )
    class RateIncreaseCriteriaProperty:
        def __init__(
            self,
            *,
            number_of_notified_things: typing.Optional[jsii.Number] = None,
            number_of_succeeded_things: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Allows you to define a criteria to initiate the increase in rate of rollout for a job.

            :param number_of_notified_things: The threshold for number of notified things that will initiate the increase in rate of rollout.
            :param number_of_succeeded_things: The threshold for number of succeeded things that will initiate the increase in rate of rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-rateincreasecriteria.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                rate_increase_criteria_property = iot_mixins.CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty(
                    number_of_notified_things=123,
                    number_of_succeeded_things=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__69384ea90cb704330df84502f8bd98b20b065f7ab97b06e7bf4a7010ec03cd4b)
                check_type(argname="argument number_of_notified_things", value=number_of_notified_things, expected_type=type_hints["number_of_notified_things"])
                check_type(argname="argument number_of_succeeded_things", value=number_of_succeeded_things, expected_type=type_hints["number_of_succeeded_things"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if number_of_notified_things is not None:
                self._values["number_of_notified_things"] = number_of_notified_things
            if number_of_succeeded_things is not None:
                self._values["number_of_succeeded_things"] = number_of_succeeded_things

        @builtins.property
        def number_of_notified_things(self) -> typing.Optional[jsii.Number]:
            '''The threshold for number of notified things that will initiate the increase in rate of rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-rateincreasecriteria.html#cfn-iot-jobtemplate-rateincreasecriteria-numberofnotifiedthings
            '''
            result = self._values.get("number_of_notified_things")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def number_of_succeeded_things(self) -> typing.Optional[jsii.Number]:
            '''The threshold for number of succeeded things that will initiate the increase in rate of rollout.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-rateincreasecriteria.html#cfn-iot-jobtemplate-rateincreasecriteria-numberofsucceededthings
            '''
            result = self._values.get("number_of_succeeded_things")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RateIncreaseCriteriaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.RetryCriteriaProperty",
        jsii_struct_bases=[],
        name_mapping={
            "failure_type": "failureType",
            "number_of_retries": "numberOfRetries",
        },
    )
    class RetryCriteriaProperty:
        def __init__(
            self,
            *,
            failure_type: typing.Optional[builtins.str] = None,
            number_of_retries: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The criteria that determines how many retries are allowed for each failure type for a job.

            :param failure_type: The type of job execution failures that can initiate a job retry.
            :param number_of_retries: The number of retries allowed for a failure type for the job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-retrycriteria.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                retry_criteria_property = iot_mixins.CfnJobTemplatePropsMixin.RetryCriteriaProperty(
                    failure_type="failureType",
                    number_of_retries=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1b9cafa52b1bfe6f7708e4ca2e7af14b538c4a5b495e494ac8d454b023b8ff9b)
                check_type(argname="argument failure_type", value=failure_type, expected_type=type_hints["failure_type"])
                check_type(argname="argument number_of_retries", value=number_of_retries, expected_type=type_hints["number_of_retries"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if failure_type is not None:
                self._values["failure_type"] = failure_type
            if number_of_retries is not None:
                self._values["number_of_retries"] = number_of_retries

        @builtins.property
        def failure_type(self) -> typing.Optional[builtins.str]:
            '''The type of job execution failures that can initiate a job retry.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-retrycriteria.html#cfn-iot-jobtemplate-retrycriteria-failuretype
            '''
            result = self._values.get("failure_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def number_of_retries(self) -> typing.Optional[jsii.Number]:
            '''The number of retries allowed for a failure type for the job.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-retrycriteria.html#cfn-iot-jobtemplate-retrycriteria-numberofretries
            '''
            result = self._values.get("number_of_retries")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetryCriteriaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnJobTemplatePropsMixin.TimeoutConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"in_progress_timeout_in_minutes": "inProgressTimeoutInMinutes"},
    )
    class TimeoutConfigProperty:
        def __init__(
            self,
            *,
            in_progress_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the amount of time each device has to finish its execution of the job.

            A timer is started when the job execution status is set to ``IN_PROGRESS`` . If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to ``TIMED_OUT`` .

            :param in_progress_timeout_in_minutes: Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal ``TIMED_OUT`` status.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-timeoutconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                timeout_config_property = iot_mixins.CfnJobTemplatePropsMixin.TimeoutConfigProperty(
                    in_progress_timeout_in_minutes=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bf9d810f74b671ff125301fb538282ab61d37e3f2382b42893c12146c269ab1b)
                check_type(argname="argument in_progress_timeout_in_minutes", value=in_progress_timeout_in_minutes, expected_type=type_hints["in_progress_timeout_in_minutes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if in_progress_timeout_in_minutes is not None:
                self._values["in_progress_timeout_in_minutes"] = in_progress_timeout_in_minutes

        @builtins.property
        def in_progress_timeout_in_minutes(self) -> typing.Optional[jsii.Number]:
            '''Specifies the amount of time, in minutes, this device has to finish execution of this job.

            The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal ``TIMED_OUT`` status.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-timeoutconfig.html#cfn-iot-jobtemplate-timeoutconfig-inprogresstimeoutinminutes
            '''
            result = self._values.get("in_progress_timeout_in_minutes")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TimeoutConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnLoggingMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "account_id": "accountId",
        "default_log_level": "defaultLogLevel",
        "role_arn": "roleArn",
    },
)
class CfnLoggingMixinProps:
    def __init__(
        self,
        *,
        account_id: typing.Optional[builtins.str] = None,
        default_log_level: typing.Optional[builtins.str] = None,
        role_arn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnLoggingPropsMixin.

        :param account_id: The account ID.
        :param default_log_level: The default log level. Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``
        :param role_arn: The role ARN used for the log.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-logging.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_logging_mixin_props = iot_mixins.CfnLoggingMixinProps(
                account_id="accountId",
                default_log_level="defaultLogLevel",
                role_arn="roleArn"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c74fa4e99c8031cf693ac11cf7406fa6f137cdd034f766e1c4fc4a55afa7986)
            check_type(argname="argument account_id", value=account_id, expected_type=type_hints["account_id"])
            check_type(argname="argument default_log_level", value=default_log_level, expected_type=type_hints["default_log_level"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if account_id is not None:
            self._values["account_id"] = account_id
        if default_log_level is not None:
            self._values["default_log_level"] = default_log_level
        if role_arn is not None:
            self._values["role_arn"] = role_arn

    @builtins.property
    def account_id(self) -> typing.Optional[builtins.str]:
        '''The account ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-logging.html#cfn-iot-logging-accountid
        '''
        result = self._values.get("account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_log_level(self) -> typing.Optional[builtins.str]:
        '''The default log level.

        Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-logging.html#cfn-iot-logging-defaultloglevel
        '''
        result = self._values.get("default_log_level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The role ARN used for the log.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-logging.html#cfn-iot-logging-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLoggingMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnLoggingPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnLoggingPropsMixin",
):
    '''Configure logging.

    .. epigraph::

       If you already set the log function of AWS IoT Core , you can't deploy the Cloud Development Kit  to change the logging settings. You can change the logging settings by either:

       - Importing the existing logging resource into your CloudFormation stack, such as with the `infrastructure as code generator (IaC generator) <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/generate-IaC.html>`_ .
       - Calling ``aws iot set-v2-logging-options --disable-all-logs`` before creating a new CloudFormation stack. This command disables all AWS IoT logging. As a result, no AWS IoT logs will be delivered to Amazon CloudWatch until you re-enable logging.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-logging.html
    :cloudformationResource: AWS::IoT::Logging
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_logging_props_mixin = iot_mixins.CfnLoggingPropsMixin(iot_mixins.CfnLoggingMixinProps(
            account_id="accountId",
            default_log_level="defaultLogLevel",
            role_arn="roleArn"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnLoggingMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Logging``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b24803efcf5e08b1513ebc7547c591e1cc08b68540ca3ba1b48ee8e62d780853)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33ef7480f00d63b7b7f25c1d7a7435419443200f9cf2b1b5302fa314f92485f2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8ba75922a849e500972df8bf34457012cfac9677bb2635d92fb78c88d0f8a47)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnLoggingMixinProps":
        return typing.cast("CfnLoggingMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "action_name": "actionName",
        "action_params": "actionParams",
        "role_arn": "roleArn",
        "tags": "tags",
    },
)
class CfnMitigationActionMixinProps:
    def __init__(
        self,
        *,
        action_name: typing.Optional[builtins.str] = None,
        action_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.ActionParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        role_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnMitigationActionPropsMixin.

        :param action_name: The friendly name of the mitigation action.
        :param action_params: The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.
        :param role_arn: The IAM role ARN used to apply this mitigation action.
        :param tags: Metadata that can be used to manage the mitigation action.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_mitigation_action_mixin_props = iot_mixins.CfnMitigationActionMixinProps(
                action_name="actionName",
                action_params=iot_mixins.CfnMitigationActionPropsMixin.ActionParamsProperty(
                    add_things_to_thing_group_params=iot_mixins.CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty(
                        override_dynamic_groups=False,
                        thing_group_names=["thingGroupNames"]
                    ),
                    enable_io_tLogging_params=iot_mixins.CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty(
                        log_level="logLevel",
                        role_arn_for_logging="roleArnForLogging"
                    ),
                    publish_finding_to_sns_params=iot_mixins.CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty(
                        topic_arn="topicArn"
                    ),
                    replace_default_policy_version_params=iot_mixins.CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty(
                        template_name="templateName"
                    ),
                    update_ca_certificate_params=iot_mixins.CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty(
                        action="action"
                    ),
                    update_device_certificate_params=iot_mixins.CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty(
                        action="action"
                    )
                ),
                role_arn="roleArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a82d78d87277416479d01f5d60130ee1b1161b1bceb9fcb19bb985d649596a0f)
            check_type(argname="argument action_name", value=action_name, expected_type=type_hints["action_name"])
            check_type(argname="argument action_params", value=action_params, expected_type=type_hints["action_params"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if action_name is not None:
            self._values["action_name"] = action_name
        if action_params is not None:
            self._values["action_params"] = action_params
        if role_arn is not None:
            self._values["role_arn"] = role_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def action_name(self) -> typing.Optional[builtins.str]:
        '''The friendly name of the mitigation action.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html#cfn-iot-mitigationaction-actionname
        '''
        result = self._values.get("action_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def action_params(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.ActionParamsProperty"]]:
        '''The set of parameters for this mitigation action.

        The parameters vary, depending on the kind of action you apply.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html#cfn-iot-mitigationaction-actionparams
        '''
        result = self._values.get("action_params")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.ActionParamsProperty"]], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The IAM role ARN used to apply this mitigation action.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html#cfn-iot-mitigationaction-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the mitigation action.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html#cfn-iot-mitigationaction-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnMitigationActionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnMitigationActionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin",
):
    '''Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask.

    For API reference, see `CreateMitigationAction <https://docs.aws.amazon.com/iot/latest/apireference/API_CreateMitigationAction.html>`_ and for general information, see `Mitigation actions <https://docs.aws.amazon.com/iot/latest/developerguide/dd-mitigation-actions.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html
    :cloudformationResource: AWS::IoT::MitigationAction
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_mitigation_action_props_mixin = iot_mixins.CfnMitigationActionPropsMixin(iot_mixins.CfnMitigationActionMixinProps(
            action_name="actionName",
            action_params=iot_mixins.CfnMitigationActionPropsMixin.ActionParamsProperty(
                add_things_to_thing_group_params=iot_mixins.CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty(
                    override_dynamic_groups=False,
                    thing_group_names=["thingGroupNames"]
                ),
                enable_io_tLogging_params=iot_mixins.CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty(
                    log_level="logLevel",
                    role_arn_for_logging="roleArnForLogging"
                ),
                publish_finding_to_sns_params=iot_mixins.CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty(
                    topic_arn="topicArn"
                ),
                replace_default_policy_version_params=iot_mixins.CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty(
                    template_name="templateName"
                ),
                update_ca_certificate_params=iot_mixins.CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty(
                    action="action"
                ),
                update_device_certificate_params=iot_mixins.CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty(
                    action="action"
                )
            ),
            role_arn="roleArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnMitigationActionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::MitigationAction``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecddac8aad555479f9c0a4c01b8949628f6db0907797194ecd0066ad8ccc08ae)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c91558c267d4f8d3326043b14fef1f4bb7f4c8d74e521cb9e4a358588b4944d3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e72b174e93969881302fd3c868c74b363afd660d5bbcfb58ba4318701c44cad8)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnMitigationActionMixinProps":
        return typing.cast("CfnMitigationActionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.ActionParamsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "add_things_to_thing_group_params": "addThingsToThingGroupParams",
            "enable_io_t_logging_params": "enableIoTLoggingParams",
            "publish_finding_to_sns_params": "publishFindingToSnsParams",
            "replace_default_policy_version_params": "replaceDefaultPolicyVersionParams",
            "update_ca_certificate_params": "updateCaCertificateParams",
            "update_device_certificate_params": "updateDeviceCertificateParams",
        },
    )
    class ActionParamsProperty:
        def __init__(
            self,
            *,
            add_things_to_thing_group_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            enable_io_t_logging_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            publish_finding_to_sns_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            replace_default_policy_version_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            update_ca_certificate_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            update_device_certificate_params: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Defines the type of action and the parameters for that action.

            :param add_things_to_thing_group_params: Specifies the group to which you want to add the devices.
            :param enable_io_t_logging_params: Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of ``DISABLED`` .
            :param publish_finding_to_sns_params: Specifies the topic to which the finding should be published.
            :param replace_default_policy_version_params: Replaces the policy version with a default or blank policy. You specify the template name. Only a value of ``BLANK_POLICY`` is currently supported.
            :param update_ca_certificate_params: Specifies the new state for the CA certificate. Only a value of ``DEACTIVATE`` is currently supported.
            :param update_device_certificate_params: Specifies the new state for a device certificate. Only a value of ``DEACTIVATE`` is currently supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                action_params_property = iot_mixins.CfnMitigationActionPropsMixin.ActionParamsProperty(
                    add_things_to_thing_group_params=iot_mixins.CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty(
                        override_dynamic_groups=False,
                        thing_group_names=["thingGroupNames"]
                    ),
                    enable_io_tLogging_params=iot_mixins.CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty(
                        log_level="logLevel",
                        role_arn_for_logging="roleArnForLogging"
                    ),
                    publish_finding_to_sns_params=iot_mixins.CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty(
                        topic_arn="topicArn"
                    ),
                    replace_default_policy_version_params=iot_mixins.CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty(
                        template_name="templateName"
                    ),
                    update_ca_certificate_params=iot_mixins.CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty(
                        action="action"
                    ),
                    update_device_certificate_params=iot_mixins.CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty(
                        action="action"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__765f99b3adf47b262cf0eee2dbb6ddecb0116dfee862a309cf58e35456d5e49b)
                check_type(argname="argument add_things_to_thing_group_params", value=add_things_to_thing_group_params, expected_type=type_hints["add_things_to_thing_group_params"])
                check_type(argname="argument enable_io_t_logging_params", value=enable_io_t_logging_params, expected_type=type_hints["enable_io_t_logging_params"])
                check_type(argname="argument publish_finding_to_sns_params", value=publish_finding_to_sns_params, expected_type=type_hints["publish_finding_to_sns_params"])
                check_type(argname="argument replace_default_policy_version_params", value=replace_default_policy_version_params, expected_type=type_hints["replace_default_policy_version_params"])
                check_type(argname="argument update_ca_certificate_params", value=update_ca_certificate_params, expected_type=type_hints["update_ca_certificate_params"])
                check_type(argname="argument update_device_certificate_params", value=update_device_certificate_params, expected_type=type_hints["update_device_certificate_params"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if add_things_to_thing_group_params is not None:
                self._values["add_things_to_thing_group_params"] = add_things_to_thing_group_params
            if enable_io_t_logging_params is not None:
                self._values["enable_io_t_logging_params"] = enable_io_t_logging_params
            if publish_finding_to_sns_params is not None:
                self._values["publish_finding_to_sns_params"] = publish_finding_to_sns_params
            if replace_default_policy_version_params is not None:
                self._values["replace_default_policy_version_params"] = replace_default_policy_version_params
            if update_ca_certificate_params is not None:
                self._values["update_ca_certificate_params"] = update_ca_certificate_params
            if update_device_certificate_params is not None:
                self._values["update_device_certificate_params"] = update_device_certificate_params

        @builtins.property
        def add_things_to_thing_group_params(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty"]]:
            '''Specifies the group to which you want to add the devices.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html#cfn-iot-mitigationaction-actionparams-addthingstothinggroupparams
            '''
            result = self._values.get("add_things_to_thing_group_params")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty"]], result)

        @builtins.property
        def enable_io_t_logging_params(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty"]]:
            '''Specifies the logging level and the role with permissions for logging.

            You cannot specify a logging level of ``DISABLED`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html#cfn-iot-mitigationaction-actionparams-enableiotloggingparams
            '''
            result = self._values.get("enable_io_t_logging_params")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty"]], result)

        @builtins.property
        def publish_finding_to_sns_params(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty"]]:
            '''Specifies the topic to which the finding should be published.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html#cfn-iot-mitigationaction-actionparams-publishfindingtosnsparams
            '''
            result = self._values.get("publish_finding_to_sns_params")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty"]], result)

        @builtins.property
        def replace_default_policy_version_params(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty"]]:
            '''Replaces the policy version with a default or blank policy.

            You specify the template name. Only a value of ``BLANK_POLICY`` is currently supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html#cfn-iot-mitigationaction-actionparams-replacedefaultpolicyversionparams
            '''
            result = self._values.get("replace_default_policy_version_params")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty"]], result)

        @builtins.property
        def update_ca_certificate_params(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty"]]:
            '''Specifies the new state for the CA certificate.

            Only a value of ``DEACTIVATE`` is currently supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html#cfn-iot-mitigationaction-actionparams-updatecacertificateparams
            '''
            result = self._values.get("update_ca_certificate_params")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty"]], result)

        @builtins.property
        def update_device_certificate_params(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty"]]:
            '''Specifies the new state for a device certificate.

            Only a value of ``DEACTIVATE`` is currently supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html#cfn-iot-mitigationaction-actionparams-updatedevicecertificateparams
            '''
            result = self._values.get("update_device_certificate_params")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ActionParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "override_dynamic_groups": "overrideDynamicGroups",
            "thing_group_names": "thingGroupNames",
        },
    )
    class AddThingsToThingGroupParamsProperty:
        def __init__(
            self,
            *,
            override_dynamic_groups: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            thing_group_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Parameters used when defining a mitigation action that move a set of things to a thing group.

            :param override_dynamic_groups: Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic thing groups.
            :param thing_group_names: The list of groups to which you want to add the things that triggered the mitigation action. You can add a thing to a maximum of 10 groups, but you can't add a thing to more than one group in the same hierarchy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-addthingstothinggroupparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                add_things_to_thing_group_params_property = iot_mixins.CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty(
                    override_dynamic_groups=False,
                    thing_group_names=["thingGroupNames"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__65f6ed60bc27dc602355bc3c69be3067930ea99d1182d0ca163206454fe02de6)
                check_type(argname="argument override_dynamic_groups", value=override_dynamic_groups, expected_type=type_hints["override_dynamic_groups"])
                check_type(argname="argument thing_group_names", value=thing_group_names, expected_type=type_hints["thing_group_names"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if override_dynamic_groups is not None:
                self._values["override_dynamic_groups"] = override_dynamic_groups
            if thing_group_names is not None:
                self._values["thing_group_names"] = thing_group_names

        @builtins.property
        def override_dynamic_groups(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic thing groups.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-addthingstothinggroupparams.html#cfn-iot-mitigationaction-addthingstothinggroupparams-overridedynamicgroups
            '''
            result = self._values.get("override_dynamic_groups")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def thing_group_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The list of groups to which you want to add the things that triggered the mitigation action.

            You can add a thing to a maximum of 10 groups, but you can't add a thing to more than one group in the same hierarchy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-addthingstothinggroupparams.html#cfn-iot-mitigationaction-addthingstothinggroupparams-thinggroupnames
            '''
            result = self._values.get("thing_group_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AddThingsToThingGroupParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "log_level": "logLevel",
            "role_arn_for_logging": "roleArnForLogging",
        },
    )
    class EnableIoTLoggingParamsProperty:
        def __init__(
            self,
            *,
            log_level: typing.Optional[builtins.str] = None,
            role_arn_for_logging: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Parameters used when defining a mitigation action that enable AWS IoT Core logging.

            :param log_level: Specifies the type of information to be logged.
            :param role_arn_for_logging: The Amazon Resource Name (ARN) of the IAM role used for logging.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-enableiotloggingparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                enable_io_tLogging_params_property = iot_mixins.CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty(
                    log_level="logLevel",
                    role_arn_for_logging="roleArnForLogging"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__93f3489cd842c5cd0787023017af5e6bf3a0a3f2e3ebe10b117a1e4675dfcef2)
                check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
                check_type(argname="argument role_arn_for_logging", value=role_arn_for_logging, expected_type=type_hints["role_arn_for_logging"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if log_level is not None:
                self._values["log_level"] = log_level
            if role_arn_for_logging is not None:
                self._values["role_arn_for_logging"] = role_arn_for_logging

        @builtins.property
        def log_level(self) -> typing.Optional[builtins.str]:
            '''Specifies the type of information to be logged.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-enableiotloggingparams.html#cfn-iot-mitigationaction-enableiotloggingparams-loglevel
            '''
            result = self._values.get("log_level")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn_for_logging(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the IAM role used for logging.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-enableiotloggingparams.html#cfn-iot-mitigationaction-enableiotloggingparams-rolearnforlogging
            '''
            result = self._values.get("role_arn_for_logging")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnableIoTLoggingParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty",
        jsii_struct_bases=[],
        name_mapping={"topic_arn": "topicArn"},
    )
    class PublishFindingToSnsParamsProperty:
        def __init__(self, *, topic_arn: typing.Optional[builtins.str] = None) -> None:
            '''Parameters to define a mitigation action that publishes findings to Amazon SNS.

            You can implement your own custom actions in response to the Amazon SNS messages.

            :param topic_arn: The ARN of the topic to which you want to publish the findings.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-publishfindingtosnsparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                publish_finding_to_sns_params_property = iot_mixins.CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty(
                    topic_arn="topicArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7f266d758944b700d9e00b91d8eb1e46e63936c30fdb819cafc309d897ff8148)
                check_type(argname="argument topic_arn", value=topic_arn, expected_type=type_hints["topic_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if topic_arn is not None:
                self._values["topic_arn"] = topic_arn

        @builtins.property
        def topic_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the topic to which you want to publish the findings.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-publishfindingtosnsparams.html#cfn-iot-mitigationaction-publishfindingtosnsparams-topicarn
            '''
            result = self._values.get("topic_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PublishFindingToSnsParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty",
        jsii_struct_bases=[],
        name_mapping={"template_name": "templateName"},
    )
    class ReplaceDefaultPolicyVersionParamsProperty:
        def __init__(
            self,
            *,
            template_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Parameters to define a mitigation action that adds a blank policy to restrict permissions.

            :param template_name: The name of the template to be applied. The only supported value is ``BLANK_POLICY`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-replacedefaultpolicyversionparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                replace_default_policy_version_params_property = iot_mixins.CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty(
                    template_name="templateName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1ce8f000a7cb7cb9e444ca6e8ee2934fbe6d15a640a0e8a265aa5e59e97d1902)
                check_type(argname="argument template_name", value=template_name, expected_type=type_hints["template_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if template_name is not None:
                self._values["template_name"] = template_name

        @builtins.property
        def template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the template to be applied.

            The only supported value is ``BLANK_POLICY`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-replacedefaultpolicyversionparams.html#cfn-iot-mitigationaction-replacedefaultpolicyversionparams-templatename
            '''
            result = self._values.get("template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ReplaceDefaultPolicyVersionParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty",
        jsii_struct_bases=[],
        name_mapping={"action": "action"},
    )
    class UpdateCACertificateParamsProperty:
        def __init__(self, *, action: typing.Optional[builtins.str] = None) -> None:
            '''Parameters to define a mitigation action that changes the state of the CA certificate to inactive.

            :param action: The action that you want to apply to the CA certificate. The only supported value is ``DEACTIVATE`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-updatecacertificateparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                update_cACertificate_params_property = iot_mixins.CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty(
                    action="action"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dbbb7f872c88e4faa8a955e1c752da81dfbe509cf07c4060898768fedee5676e)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action is not None:
                self._values["action"] = action

        @builtins.property
        def action(self) -> typing.Optional[builtins.str]:
            '''The action that you want to apply to the CA certificate.

            The only supported value is ``DEACTIVATE`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-updatecacertificateparams.html#cfn-iot-mitigationaction-updatecacertificateparams-action
            '''
            result = self._values.get("action")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "UpdateCACertificateParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty",
        jsii_struct_bases=[],
        name_mapping={"action": "action"},
    )
    class UpdateDeviceCertificateParamsProperty:
        def __init__(self, *, action: typing.Optional[builtins.str] = None) -> None:
            '''Parameters to define a mitigation action that changes the state of the device certificate to inactive.

            :param action: The action that you want to apply to the device certificate. The only supported value is ``DEACTIVATE`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-updatedevicecertificateparams.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                update_device_certificate_params_property = iot_mixins.CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty(
                    action="action"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__96c2bd4e280fc7869312bb134b89392ed122c4922bfaf64bffd7b4088cbd73a6)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action is not None:
                self._values["action"] = action

        @builtins.property
        def action(self) -> typing.Optional[builtins.str]:
            '''The action that you want to apply to the device certificate.

            The only supported value is ``DEACTIVATE`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-updatedevicecertificateparams.html#cfn-iot-mitigationaction-updatedevicecertificateparams-action
            '''
            result = self._values.get("action")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "UpdateDeviceCertificateParamsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnPolicyMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "policy_document": "policyDocument",
        "policy_name": "policyName",
        "tags": "tags",
    },
)
class CfnPolicyMixinProps:
    def __init__(
        self,
        *,
        policy_document: typing.Any = None,
        policy_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnPolicyPropsMixin.

        :param policy_document: The JSON document that describes the policy.
        :param policy_name: The policy name.
        :param tags: 

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policy.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            # policy_document: Any
            
            cfn_policy_mixin_props = iot_mixins.CfnPolicyMixinProps(
                policy_document=policy_document,
                policy_name="policyName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b808fca0e1c8501cdc11b0ba727446ff79da44b63eed42a45d35796a733a88b)
            check_type(argname="argument policy_document", value=policy_document, expected_type=type_hints["policy_document"])
            check_type(argname="argument policy_name", value=policy_name, expected_type=type_hints["policy_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if policy_document is not None:
            self._values["policy_document"] = policy_document
        if policy_name is not None:
            self._values["policy_name"] = policy_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def policy_document(self) -> typing.Any:
        '''The JSON document that describes the policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policy.html#cfn-iot-policy-policydocument
        '''
        result = self._values.get("policy_document")
        return typing.cast(typing.Any, result)

    @builtins.property
    def policy_name(self) -> typing.Optional[builtins.str]:
        '''The policy name.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policy.html#cfn-iot-policy-policyname
        '''
        result = self._values.get("policy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''
        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policy.html#cfn-iot-policy-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPolicyMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnPolicyPrincipalAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={"policy_name": "policyName", "principal": "principal"},
)
class CfnPolicyPrincipalAttachmentMixinProps:
    def __init__(
        self,
        *,
        policy_name: typing.Optional[builtins.str] = None,
        principal: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnPolicyPrincipalAttachmentPropsMixin.

        :param policy_name: The name of the AWS IoT policy.
        :param principal: The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policyprincipalattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_policy_principal_attachment_mixin_props = iot_mixins.CfnPolicyPrincipalAttachmentMixinProps(
                policy_name="policyName",
                principal="principal"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfb48cd026ef2dcfa9861b87f9cc97800de6c87ebbe7efc75fd40c9e5368e99e)
            check_type(argname="argument policy_name", value=policy_name, expected_type=type_hints["policy_name"])
            check_type(argname="argument principal", value=principal, expected_type=type_hints["principal"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if policy_name is not None:
            self._values["policy_name"] = policy_name
        if principal is not None:
            self._values["principal"] = principal

    @builtins.property
    def policy_name(self) -> typing.Optional[builtins.str]:
        '''The name of the AWS IoT policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policyprincipalattachment.html#cfn-iot-policyprincipalattachment-policyname
        '''
        result = self._values.get("policy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def principal(self) -> typing.Optional[builtins.str]:
        '''The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policyprincipalattachment.html#cfn-iot-policyprincipalattachment-principal
        '''
        result = self._values.get("principal")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPolicyPrincipalAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnPolicyPrincipalAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnPolicyPrincipalAttachmentPropsMixin",
):
    '''Use the ``AWS::IoT::PolicyPrincipalAttachment`` resource to attach an AWS IoT policy to a principal (an X.509 certificate or other credential).

    For information about working with AWS IoT policies and principals, see `Authorization <https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html>`_ in the *AWS IoT Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policyprincipalattachment.html
    :cloudformationResource: AWS::IoT::PolicyPrincipalAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_policy_principal_attachment_props_mixin = iot_mixins.CfnPolicyPrincipalAttachmentPropsMixin(iot_mixins.CfnPolicyPrincipalAttachmentMixinProps(
            policy_name="policyName",
            principal="principal"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnPolicyPrincipalAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::PolicyPrincipalAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d24928a4fee4314a9396580cfc1273c91f05d909a5eaae953bd04c9b5207d8e1)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ed4075d27004572d5d10d5a7616994d221c54ba1fd5eb019bdeaf057f454605)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b54f6b1da2100047d40be28262e20542d4fc6a62419e163086fd1a7cc275587)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnPolicyPrincipalAttachmentMixinProps":
        return typing.cast("CfnPolicyPrincipalAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnPolicyPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnPolicyPropsMixin",
):
    '''Use the ``AWS::IoT::Policy`` resource to declare an AWS IoT policy.

    For more information about working with AWS IoT policies, see `Authorization <https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html>`_ in the *AWS IoT Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policy.html
    :cloudformationResource: AWS::IoT::Policy
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        # policy_document: Any
        
        cfn_policy_props_mixin = iot_mixins.CfnPolicyPropsMixin(iot_mixins.CfnPolicyMixinProps(
            policy_document=policy_document,
            policy_name="policyName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnPolicyMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Policy``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd58f40bb8b0696c6f4f4d8e60d2a45c419bfa32fc1e7a7cb79f9cca2eae5515)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6457776f8e57e846a2b9664e6e8f65bab904fc3b4f62f37b555a5fe83cbe092d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da7fe80a386a33a866f89fd246f97b08629f0bc9675091b771dc360e6797a5b9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnPolicyMixinProps":
        return typing.cast("CfnPolicyMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnProvisioningTemplateMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "enabled": "enabled",
        "pre_provisioning_hook": "preProvisioningHook",
        "provisioning_role_arn": "provisioningRoleArn",
        "tags": "tags",
        "template_body": "templateBody",
        "template_name": "templateName",
        "template_type": "templateType",
    },
)
class CfnProvisioningTemplateMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        pre_provisioning_hook: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        provisioning_role_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        template_body: typing.Optional[builtins.str] = None,
        template_name: typing.Optional[builtins.str] = None,
        template_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnProvisioningTemplatePropsMixin.

        :param description: The description of the fleet provisioning template.
        :param enabled: True to enable the fleet provisioning template, otherwise false.
        :param pre_provisioning_hook: Creates a pre-provisioning hook template.
        :param provisioning_role_arn: The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.
        :param tags: Metadata that can be used to manage the fleet provisioning template.
        :param template_body: The JSON formatted contents of the fleet provisioning template version.
        :param template_name: The name of the fleet provisioning template.
        :param template_type: The type of the provisioning template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_provisioning_template_mixin_props = iot_mixins.CfnProvisioningTemplateMixinProps(
                description="description",
                enabled=False,
                pre_provisioning_hook=iot_mixins.CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty(
                    payload_version="payloadVersion",
                    target_arn="targetArn"
                ),
                provisioning_role_arn="provisioningRoleArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                template_body="templateBody",
                template_name="templateName",
                template_type="templateType"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54f2ac30018cc2a04a9f83c8c7eda5dfbb221739198a66a813634404323afd67)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument pre_provisioning_hook", value=pre_provisioning_hook, expected_type=type_hints["pre_provisioning_hook"])
            check_type(argname="argument provisioning_role_arn", value=provisioning_role_arn, expected_type=type_hints["provisioning_role_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument template_body", value=template_body, expected_type=type_hints["template_body"])
            check_type(argname="argument template_name", value=template_name, expected_type=type_hints["template_name"])
            check_type(argname="argument template_type", value=template_type, expected_type=type_hints["template_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if enabled is not None:
            self._values["enabled"] = enabled
        if pre_provisioning_hook is not None:
            self._values["pre_provisioning_hook"] = pre_provisioning_hook
        if provisioning_role_arn is not None:
            self._values["provisioning_role_arn"] = provisioning_role_arn
        if tags is not None:
            self._values["tags"] = tags
        if template_body is not None:
            self._values["template_body"] = template_body
        if template_name is not None:
            self._values["template_name"] = template_name
        if template_type is not None:
            self._values["template_type"] = template_type

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the fleet provisioning template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''True to enable the fleet provisioning template, otherwise false.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-enabled
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def pre_provisioning_hook(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty"]]:
        '''Creates a pre-provisioning hook template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-preprovisioninghook
        '''
        result = self._values.get("pre_provisioning_hook")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty"]], result)

    @builtins.property
    def provisioning_role_arn(self) -> typing.Optional[builtins.str]:
        '''The role ARN for the role associated with the fleet provisioning template.

        This IoT role grants permission to provision a device.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-provisioningrolearn
        '''
        result = self._values.get("provisioning_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the fleet provisioning template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def template_body(self) -> typing.Optional[builtins.str]:
        '''The JSON formatted contents of the fleet provisioning template version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-templatebody
        '''
        result = self._values.get("template_body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template_name(self) -> typing.Optional[builtins.str]:
        '''The name of the fleet provisioning template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-templatename
        '''
        result = self._values.get("template_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template_type(self) -> typing.Optional[builtins.str]:
        '''The type of the provisioning template.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html#cfn-iot-provisioningtemplate-templatetype
        '''
        result = self._values.get("template_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnProvisioningTemplateMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnProvisioningTemplatePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnProvisioningTemplatePropsMixin",
):
    '''Creates a fleet provisioning template.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html
    :cloudformationResource: AWS::IoT::ProvisioningTemplate
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_provisioning_template_props_mixin = iot_mixins.CfnProvisioningTemplatePropsMixin(iot_mixins.CfnProvisioningTemplateMixinProps(
            description="description",
            enabled=False,
            pre_provisioning_hook=iot_mixins.CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty(
                payload_version="payloadVersion",
                target_arn="targetArn"
            ),
            provisioning_role_arn="provisioningRoleArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            template_body="templateBody",
            template_name="templateName",
            template_type="templateType"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnProvisioningTemplateMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::ProvisioningTemplate``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5aba21ff1c16a3c0878f45627eb4ef6933abf844d696ad09fedf2a31c6b1c7a0)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b861304960ad303ba727d63e892a60dc5e933e11a2c0daf1ad47bee99209dfb)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7b0ee6b0e936ad1c9ca03567ccbc41adfa84cd928b7967f2c92f1517e892932)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnProvisioningTemplateMixinProps":
        return typing.cast("CfnProvisioningTemplateMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty",
        jsii_struct_bases=[],
        name_mapping={"payload_version": "payloadVersion", "target_arn": "targetArn"},
    )
    class ProvisioningHookProperty:
        def __init__(
            self,
            *,
            payload_version: typing.Optional[builtins.str] = None,
            target_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Structure that contains payloadVersion and targetArn.

            Provisioning hooks can be used when fleet provisioning to validate device parameters before allowing the device to be provisioned.

            :param payload_version: The payload that was sent to the target function. The valid payload is ``"2020-04-01"`` .
            :param target_arn: The ARN of the target function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-provisioningtemplate-provisioninghook.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                provisioning_hook_property = iot_mixins.CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty(
                    payload_version="payloadVersion",
                    target_arn="targetArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7c2158df7cb0e358604e02259b9ead048c93b2a0bbf69b000615b5c5cf40bbfe)
                check_type(argname="argument payload_version", value=payload_version, expected_type=type_hints["payload_version"])
                check_type(argname="argument target_arn", value=target_arn, expected_type=type_hints["target_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if payload_version is not None:
                self._values["payload_version"] = payload_version
            if target_arn is not None:
                self._values["target_arn"] = target_arn

        @builtins.property
        def payload_version(self) -> typing.Optional[builtins.str]:
            '''The payload that was sent to the target function.

            The valid payload is ``"2020-04-01"`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-provisioningtemplate-provisioninghook.html#cfn-iot-provisioningtemplate-provisioninghook-payloadversion
            '''
            result = self._values.get("payload_version")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the target function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-provisioningtemplate-provisioninghook.html#cfn-iot-provisioningtemplate-provisioninghook-targetarn
            '''
            result = self._values.get("target_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ProvisioningHookProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnResourceSpecificLoggingMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "log_level": "logLevel",
        "target_name": "targetName",
        "target_type": "targetType",
    },
)
class CfnResourceSpecificLoggingMixinProps:
    def __init__(
        self,
        *,
        log_level: typing.Optional[builtins.str] = None,
        target_name: typing.Optional[builtins.str] = None,
        target_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnResourceSpecificLoggingPropsMixin.

        :param log_level: The default log level.Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``.
        :param target_name: The target name.
        :param target_type: The target type. Valid Values: ``DEFAULT | THING_GROUP``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-resourcespecificlogging.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_resource_specific_logging_mixin_props = iot_mixins.CfnResourceSpecificLoggingMixinProps(
                log_level="logLevel",
                target_name="targetName",
                target_type="targetType"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d83c67145bbd8353159524dc2c91b208602b40a73b3040307f31bbab4e61c0cd)
            check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
            check_type(argname="argument target_name", value=target_name, expected_type=type_hints["target_name"])
            check_type(argname="argument target_type", value=target_type, expected_type=type_hints["target_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if log_level is not None:
            self._values["log_level"] = log_level
        if target_name is not None:
            self._values["target_name"] = target_name
        if target_type is not None:
            self._values["target_type"] = target_type

    @builtins.property
    def log_level(self) -> typing.Optional[builtins.str]:
        '''The default log level.Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-resourcespecificlogging.html#cfn-iot-resourcespecificlogging-loglevel
        '''
        result = self._values.get("log_level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_name(self) -> typing.Optional[builtins.str]:
        '''The target name.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-resourcespecificlogging.html#cfn-iot-resourcespecificlogging-targetname
        '''
        result = self._values.get("target_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_type(self) -> typing.Optional[builtins.str]:
        '''The target type.

        Valid Values: ``DEFAULT | THING_GROUP``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-resourcespecificlogging.html#cfn-iot-resourcespecificlogging-targettype
        '''
        result = self._values.get("target_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnResourceSpecificLoggingMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnResourceSpecificLoggingPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnResourceSpecificLoggingPropsMixin",
):
    '''Configure resource-specific logging.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-resourcespecificlogging.html
    :cloudformationResource: AWS::IoT::ResourceSpecificLogging
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_resource_specific_logging_props_mixin = iot_mixins.CfnResourceSpecificLoggingPropsMixin(iot_mixins.CfnResourceSpecificLoggingMixinProps(
            log_level="logLevel",
            target_name="targetName",
            target_type="targetType"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnResourceSpecificLoggingMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::ResourceSpecificLogging``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f18e7cd515b39934b1b8dbe34ae9e0983a5a48f687d67dfc720d6086824ed97)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d68dfdffc2b2e2f72162e7e438bdb192cab33c450c51a459e3cd6f6055a88e9b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__044dfae98e2573db1665dab2a77afc6afe8666dda5291f01a54518349bf27a10)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnResourceSpecificLoggingMixinProps":
        return typing.cast("CfnResourceSpecificLoggingMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnRoleAliasMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "credential_duration_seconds": "credentialDurationSeconds",
        "role_alias": "roleAlias",
        "role_arn": "roleArn",
        "tags": "tags",
    },
)
class CfnRoleAliasMixinProps:
    def __init__(
        self,
        *,
        credential_duration_seconds: typing.Optional[jsii.Number] = None,
        role_alias: typing.Optional[builtins.str] = None,
        role_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnRoleAliasPropsMixin.

        :param credential_duration_seconds: The number of seconds for which the credential is valid. Default: - 3600
        :param role_alias: The role alias.
        :param role_arn: The role ARN.
        :param tags: An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_role_alias_mixin_props = iot_mixins.CfnRoleAliasMixinProps(
                credential_duration_seconds=123,
                role_alias="roleAlias",
                role_arn="roleArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53323d47f3ac0f5eb7669be37b2677cb305285a9a50fdd0812ce17c505d1a85e)
            check_type(argname="argument credential_duration_seconds", value=credential_duration_seconds, expected_type=type_hints["credential_duration_seconds"])
            check_type(argname="argument role_alias", value=role_alias, expected_type=type_hints["role_alias"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credential_duration_seconds is not None:
            self._values["credential_duration_seconds"] = credential_duration_seconds
        if role_alias is not None:
            self._values["role_alias"] = role_alias
        if role_arn is not None:
            self._values["role_arn"] = role_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def credential_duration_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds for which the credential is valid.

        :default: - 3600

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html#cfn-iot-rolealias-credentialdurationseconds
        '''
        result = self._values.get("credential_duration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def role_alias(self) -> typing.Optional[builtins.str]:
        '''The role alias.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html#cfn-iot-rolealias-rolealias
        '''
        result = self._values.get("role_alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The role ARN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html#cfn-iot-rolealias-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''An array of key-value pairs to apply to this resource.

        For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html#cfn-iot-rolealias-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRoleAliasMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnRoleAliasPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnRoleAliasPropsMixin",
):
    '''Specifies a role alias.

    Requires permission to access the `CreateRoleAlias <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html
    :cloudformationResource: AWS::IoT::RoleAlias
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_role_alias_props_mixin = iot_mixins.CfnRoleAliasPropsMixin(iot_mixins.CfnRoleAliasMixinProps(
            credential_duration_seconds=123,
            role_alias="roleAlias",
            role_arn="roleArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnRoleAliasMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::RoleAlias``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7901bf0889377480ea0e74b4211cd959da54ef43eff7ce0fd53a1ee8e383bcea)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8557fbcc417d7d9b40570874ca6bb93fa0816bcb22b54e799b0264a3a41274d8)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37a12634f009bf2fc094c7c180bc477f8baa2cf55ce01106e4e8fe802f5e0c8d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnRoleAliasMixinProps":
        return typing.cast("CfnRoleAliasMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnScheduledAuditMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "day_of_month": "dayOfMonth",
        "day_of_week": "dayOfWeek",
        "frequency": "frequency",
        "scheduled_audit_name": "scheduledAuditName",
        "tags": "tags",
        "target_check_names": "targetCheckNames",
    },
)
class CfnScheduledAuditMixinProps:
    def __init__(
        self,
        *,
        day_of_month: typing.Optional[builtins.str] = None,
        day_of_week: typing.Optional[builtins.str] = None,
        frequency: typing.Optional[builtins.str] = None,
        scheduled_audit_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        target_check_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for CfnScheduledAuditPropsMixin.

        :param day_of_month: The day of the month on which the scheduled audit is run (if the ``frequency`` is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.
        :param day_of_week: The day of the week on which the scheduled audit is run (if the ``frequency`` is "WEEKLY" or "BIWEEKLY").
        :param frequency: How often the scheduled audit occurs.
        :param scheduled_audit_name: The name of the scheduled audit.
        :param tags: Metadata that can be used to manage the scheduled audit.
        :param target_check_names: Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use ``DescribeAccountAuditConfiguration`` to see the list of all checks, including those that are enabled or use ``UpdateAccountAuditConfiguration`` to select which checks are enabled.) The following checks are currently available: - ``AUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK`` - ``CA_CERTIFICATE_EXPIRING_CHECK`` - ``CA_CERTIFICATE_KEY_QUALITY_CHECK`` - ``CONFLICTING_CLIENT_IDS_CHECK`` - ``DEVICE_CERTIFICATE_EXPIRING_CHECK`` - ``DEVICE_CERTIFICATE_KEY_QUALITY_CHECK`` - ``DEVICE_CERTIFICATE_SHARED_CHECK`` - ``IOT_POLICY_OVERLY_PERMISSIVE_CHECK`` - ``IOT_ROLE_ALIAS_ALLOWS_ACCESS_TO_UNUSED_SERVICES_CHECK`` - ``IOT_ROLE_ALIAS_OVERLY_PERMISSIVE_CHECK`` - ``LOGGING_DISABLED_CHECK`` - ``REVOKED_CA_CERTIFICATE_STILL_ACTIVE_CHECK`` - ``REVOKED_DEVICE_CERTIFICATE_STILL_ACTIVE_CHECK`` - ``UNAUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_scheduled_audit_mixin_props = iot_mixins.CfnScheduledAuditMixinProps(
                day_of_month="dayOfMonth",
                day_of_week="dayOfWeek",
                frequency="frequency",
                scheduled_audit_name="scheduledAuditName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                target_check_names=["targetCheckNames"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1ee91a00f9152628adf008e6f8ef0a508720977aedaffa4154f94eabc2f3367)
            check_type(argname="argument day_of_month", value=day_of_month, expected_type=type_hints["day_of_month"])
            check_type(argname="argument day_of_week", value=day_of_week, expected_type=type_hints["day_of_week"])
            check_type(argname="argument frequency", value=frequency, expected_type=type_hints["frequency"])
            check_type(argname="argument scheduled_audit_name", value=scheduled_audit_name, expected_type=type_hints["scheduled_audit_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_check_names", value=target_check_names, expected_type=type_hints["target_check_names"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if day_of_month is not None:
            self._values["day_of_month"] = day_of_month
        if day_of_week is not None:
            self._values["day_of_week"] = day_of_week
        if frequency is not None:
            self._values["frequency"] = frequency
        if scheduled_audit_name is not None:
            self._values["scheduled_audit_name"] = scheduled_audit_name
        if tags is not None:
            self._values["tags"] = tags
        if target_check_names is not None:
            self._values["target_check_names"] = target_check_names

    @builtins.property
    def day_of_month(self) -> typing.Optional[builtins.str]:
        '''The day of the month on which the scheduled audit is run (if the ``frequency`` is "MONTHLY").

        If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html#cfn-iot-scheduledaudit-dayofmonth
        '''
        result = self._values.get("day_of_month")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def day_of_week(self) -> typing.Optional[builtins.str]:
        '''The day of the week on which the scheduled audit is run (if the ``frequency`` is "WEEKLY" or "BIWEEKLY").

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html#cfn-iot-scheduledaudit-dayofweek
        '''
        result = self._values.get("day_of_week")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def frequency(self) -> typing.Optional[builtins.str]:
        '''How often the scheduled audit occurs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html#cfn-iot-scheduledaudit-frequency
        '''
        result = self._values.get("frequency")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheduled_audit_name(self) -> typing.Optional[builtins.str]:
        '''The name of the scheduled audit.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html#cfn-iot-scheduledaudit-scheduledauditname
        '''
        result = self._values.get("scheduled_audit_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the scheduled audit.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html#cfn-iot-scheduledaudit-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def target_check_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Which checks are performed during the scheduled audit.

        Checks must be enabled for your account. (Use ``DescribeAccountAuditConfiguration`` to see the list of all checks, including those that are enabled or use ``UpdateAccountAuditConfiguration`` to select which checks are enabled.)

        The following checks are currently available:

        - ``AUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK``
        - ``CA_CERTIFICATE_EXPIRING_CHECK``
        - ``CA_CERTIFICATE_KEY_QUALITY_CHECK``
        - ``CONFLICTING_CLIENT_IDS_CHECK``
        - ``DEVICE_CERTIFICATE_EXPIRING_CHECK``
        - ``DEVICE_CERTIFICATE_KEY_QUALITY_CHECK``
        - ``DEVICE_CERTIFICATE_SHARED_CHECK``
        - ``IOT_POLICY_OVERLY_PERMISSIVE_CHECK``
        - ``IOT_ROLE_ALIAS_ALLOWS_ACCESS_TO_UNUSED_SERVICES_CHECK``
        - ``IOT_ROLE_ALIAS_OVERLY_PERMISSIVE_CHECK``
        - ``LOGGING_DISABLED_CHECK``
        - ``REVOKED_CA_CERTIFICATE_STILL_ACTIVE_CHECK``
        - ``REVOKED_DEVICE_CERTIFICATE_STILL_ACTIVE_CHECK``
        - ``UNAUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html#cfn-iot-scheduledaudit-targetchecknames
        '''
        result = self._values.get("target_check_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnScheduledAuditMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnScheduledAuditPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnScheduledAuditPropsMixin",
):
    '''Use the ``AWS::IoT::ScheduledAudit`` resource to create a scheduled audit that is run at a specified time interval.

    For API reference, see `CreateScheduleAudit <https://docs.aws.amazon.com/iot/latest/apireference/API_CreateScheduledAudit.html>`_ and for general information, see `Audit <https://docs.aws.amazon.com/iot/latest/developerguide/device-defender-audit.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html
    :cloudformationResource: AWS::IoT::ScheduledAudit
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_scheduled_audit_props_mixin = iot_mixins.CfnScheduledAuditPropsMixin(iot_mixins.CfnScheduledAuditMixinProps(
            day_of_month="dayOfMonth",
            day_of_week="dayOfWeek",
            frequency="frequency",
            scheduled_audit_name="scheduledAuditName",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            target_check_names=["targetCheckNames"]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnScheduledAuditMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::ScheduledAudit``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d601508e0a534dff978a42fe6cec7767b574cc9840aaf566a65631bb9e1d94e4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fd1aeb5951816c46da455e1faa67b291e713895a80ab27c7d10903e63677f00)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45502f5bfc77a8cc51ce90f2e7dee02571625a8308b12cc98c3626f298b85539)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnScheduledAuditMixinProps":
        return typing.cast("CfnScheduledAuditMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfileMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "additional_metrics_to_retain_v2": "additionalMetricsToRetainV2",
        "alert_targets": "alertTargets",
        "behaviors": "behaviors",
        "metrics_export_config": "metricsExportConfig",
        "security_profile_description": "securityProfileDescription",
        "security_profile_name": "securityProfileName",
        "tags": "tags",
        "target_arns": "targetArns",
    },
)
class CfnSecurityProfileMixinProps:
    def __init__(
        self,
        *,
        additional_metrics_to_retain_v2: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.MetricToRetainProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        alert_targets: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.AlertTargetProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        behaviors: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.BehaviorProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        metrics_export_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.MetricsExportConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        security_profile_description: typing.Optional[builtins.str] = None,
        security_profile_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        target_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for CfnSecurityProfilePropsMixin.

        :param additional_metrics_to_retain_v2: A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's ``behaviors`` , but it's also retained for any metric specified here. Can be used with custom metrics; can't be used with dimensions.
        :param alert_targets: Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.
        :param behaviors: Specifies the behaviors that, when violated by a device (thing), cause an alert.
        :param metrics_export_config: Specifies the MQTT topic and role ARN required for metric export.
        :param security_profile_description: A description of the security profile.
        :param security_profile_name: The name you gave to the security profile.
        :param tags: Metadata that can be used to manage the security profile.
        :param target_arns: The ARN of the target (thing group) to which the security profile is attached.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_security_profile_mixin_props = iot_mixins.CfnSecurityProfileMixinProps(
                additional_metrics_to_retain_v2=[iot_mixins.CfnSecurityProfilePropsMixin.MetricToRetainProperty(
                    export_metric=False,
                    metric="metric",
                    metric_dimension=iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                        dimension_name="dimensionName",
                        operator="operator"
                    )
                )],
                alert_targets={
                    "alert_targets_key": iot_mixins.CfnSecurityProfilePropsMixin.AlertTargetProperty(
                        alert_target_arn="alertTargetArn",
                        role_arn="roleArn"
                    )
                },
                behaviors=[iot_mixins.CfnSecurityProfilePropsMixin.BehaviorProperty(
                    criteria=iot_mixins.CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty(
                        comparison_operator="comparisonOperator",
                        consecutive_datapoints_to_alarm=123,
                        consecutive_datapoints_to_clear=123,
                        duration_seconds=123,
                        ml_detection_config=iot_mixins.CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty(
                            confidence_level="confidenceLevel"
                        ),
                        statistical_threshold=iot_mixins.CfnSecurityProfilePropsMixin.StatisticalThresholdProperty(
                            statistic="statistic"
                        ),
                        value=iot_mixins.CfnSecurityProfilePropsMixin.MetricValueProperty(
                            cidrs=["cidrs"],
                            count="count",
                            number=123,
                            numbers=[123],
                            ports=[123],
                            strings=["strings"]
                        )
                    ),
                    export_metric=False,
                    metric="metric",
                    metric_dimension=iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                        dimension_name="dimensionName",
                        operator="operator"
                    ),
                    name="name",
                    suppress_alerts=False
                )],
                metrics_export_config=iot_mixins.CfnSecurityProfilePropsMixin.MetricsExportConfigProperty(
                    mqtt_topic="mqttTopic",
                    role_arn="roleArn"
                ),
                security_profile_description="securityProfileDescription",
                security_profile_name="securityProfileName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                target_arns=["targetArns"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cd5cabbf6bd7a6a48f0f215589790ff4b6efd3e7766f2362b76950feed3f602)
            check_type(argname="argument additional_metrics_to_retain_v2", value=additional_metrics_to_retain_v2, expected_type=type_hints["additional_metrics_to_retain_v2"])
            check_type(argname="argument alert_targets", value=alert_targets, expected_type=type_hints["alert_targets"])
            check_type(argname="argument behaviors", value=behaviors, expected_type=type_hints["behaviors"])
            check_type(argname="argument metrics_export_config", value=metrics_export_config, expected_type=type_hints["metrics_export_config"])
            check_type(argname="argument security_profile_description", value=security_profile_description, expected_type=type_hints["security_profile_description"])
            check_type(argname="argument security_profile_name", value=security_profile_name, expected_type=type_hints["security_profile_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_arns", value=target_arns, expected_type=type_hints["target_arns"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_metrics_to_retain_v2 is not None:
            self._values["additional_metrics_to_retain_v2"] = additional_metrics_to_retain_v2
        if alert_targets is not None:
            self._values["alert_targets"] = alert_targets
        if behaviors is not None:
            self._values["behaviors"] = behaviors
        if metrics_export_config is not None:
            self._values["metrics_export_config"] = metrics_export_config
        if security_profile_description is not None:
            self._values["security_profile_description"] = security_profile_description
        if security_profile_name is not None:
            self._values["security_profile_name"] = security_profile_name
        if tags is not None:
            self._values["tags"] = tags
        if target_arns is not None:
            self._values["target_arns"] = target_arns

    @builtins.property
    def additional_metrics_to_retain_v2(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricToRetainProperty"]]]]:
        '''A list of metrics whose data is retained (stored).

        By default, data is retained for any metric used in the profile's ``behaviors`` , but it's also retained for any metric specified here. Can be used with custom metrics; can't be used with dimensions.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-additionalmetricstoretainv2
        '''
        result = self._values.get("additional_metrics_to_retain_v2")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricToRetainProperty"]]]], result)

    @builtins.property
    def alert_targets(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.AlertTargetProperty"]]]]:
        '''Specifies the destinations to which alerts are sent.

        (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-alerttargets
        '''
        result = self._values.get("alert_targets")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.AlertTargetProperty"]]]], result)

    @builtins.property
    def behaviors(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.BehaviorProperty"]]]]:
        '''Specifies the behaviors that, when violated by a device (thing), cause an alert.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-behaviors
        '''
        result = self._values.get("behaviors")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.BehaviorProperty"]]]], result)

    @builtins.property
    def metrics_export_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricsExportConfigProperty"]]:
        '''Specifies the MQTT topic and role ARN required for metric export.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-metricsexportconfig
        '''
        result = self._values.get("metrics_export_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricsExportConfigProperty"]], result)

    @builtins.property
    def security_profile_description(self) -> typing.Optional[builtins.str]:
        '''A description of the security profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-securityprofiledescription
        '''
        result = self._values.get("security_profile_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_profile_name(self) -> typing.Optional[builtins.str]:
        '''The name you gave to the security profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-securityprofilename
        '''
        result = self._values.get("security_profile_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the security profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def target_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The ARN of the target (thing group) to which the security profile is attached.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html#cfn-iot-securityprofile-targetarns
        '''
        result = self._values.get("target_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityProfileMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSecurityProfilePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin",
):
    '''Use the ``AWS::IoT::SecurityProfile`` resource to create a Device Defender security profile.

    For API reference, see `CreateSecurityProfile <https://docs.aws.amazon.com/iot/latest/apireference/API_CreateSecurityProfile.html>`_ and for general information, see `Detect <https://docs.aws.amazon.com/iot/latest/developerguide/device-defender-detect.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html
    :cloudformationResource: AWS::IoT::SecurityProfile
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_security_profile_props_mixin = iot_mixins.CfnSecurityProfilePropsMixin(iot_mixins.CfnSecurityProfileMixinProps(
            additional_metrics_to_retain_v2=[iot_mixins.CfnSecurityProfilePropsMixin.MetricToRetainProperty(
                export_metric=False,
                metric="metric",
                metric_dimension=iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                    dimension_name="dimensionName",
                    operator="operator"
                )
            )],
            alert_targets={
                "alert_targets_key": iot_mixins.CfnSecurityProfilePropsMixin.AlertTargetProperty(
                    alert_target_arn="alertTargetArn",
                    role_arn="roleArn"
                )
            },
            behaviors=[iot_mixins.CfnSecurityProfilePropsMixin.BehaviorProperty(
                criteria=iot_mixins.CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty(
                    comparison_operator="comparisonOperator",
                    consecutive_datapoints_to_alarm=123,
                    consecutive_datapoints_to_clear=123,
                    duration_seconds=123,
                    ml_detection_config=iot_mixins.CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty(
                        confidence_level="confidenceLevel"
                    ),
                    statistical_threshold=iot_mixins.CfnSecurityProfilePropsMixin.StatisticalThresholdProperty(
                        statistic="statistic"
                    ),
                    value=iot_mixins.CfnSecurityProfilePropsMixin.MetricValueProperty(
                        cidrs=["cidrs"],
                        count="count",
                        number=123,
                        numbers=[123],
                        ports=[123],
                        strings=["strings"]
                    )
                ),
                export_metric=False,
                metric="metric",
                metric_dimension=iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                    dimension_name="dimensionName",
                    operator="operator"
                ),
                name="name",
                suppress_alerts=False
            )],
            metrics_export_config=iot_mixins.CfnSecurityProfilePropsMixin.MetricsExportConfigProperty(
                mqtt_topic="mqttTopic",
                role_arn="roleArn"
            ),
            security_profile_description="securityProfileDescription",
            security_profile_name="securityProfileName",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            target_arns=["targetArns"]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSecurityProfileMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::SecurityProfile``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f53807dc7b8cc63d641c74b3e2e89cd03c8c7d6d323a95f74772c9f68cde6d9c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31a4d69dfb6fd7ba1d3f7ac3693bec8fdaefa2b20d978f8ffb83d044bc4fb89f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__327cf0745b944c0ce6aa0138bb0b24d6478983543222f746a7643646881f6ac2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSecurityProfileMixinProps":
        return typing.cast("CfnSecurityProfileMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.AlertTargetProperty",
        jsii_struct_bases=[],
        name_mapping={"alert_target_arn": "alertTargetArn", "role_arn": "roleArn"},
    )
    class AlertTargetProperty:
        def __init__(
            self,
            *,
            alert_target_arn: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A structure containing the alert target ARN and the role ARN.

            :param alert_target_arn: The Amazon Resource Name (ARN) of the notification target to which alerts are sent.
            :param role_arn: The ARN of the role that grants permission to send alerts to the notification target.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-alerttarget.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                alert_target_property = iot_mixins.CfnSecurityProfilePropsMixin.AlertTargetProperty(
                    alert_target_arn="alertTargetArn",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8eddc350bb65844c60652598df29d2b1d94d72b00502e72900dd7c36b29af5b7)
                check_type(argname="argument alert_target_arn", value=alert_target_arn, expected_type=type_hints["alert_target_arn"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if alert_target_arn is not None:
                self._values["alert_target_arn"] = alert_target_arn
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def alert_target_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the notification target to which alerts are sent.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-alerttarget.html#cfn-iot-securityprofile-alerttarget-alerttargetarn
            '''
            result = self._values.get("alert_target_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role that grants permission to send alerts to the notification target.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-alerttarget.html#cfn-iot-securityprofile-alerttarget-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AlertTargetProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty",
        jsii_struct_bases=[],
        name_mapping={
            "comparison_operator": "comparisonOperator",
            "consecutive_datapoints_to_alarm": "consecutiveDatapointsToAlarm",
            "consecutive_datapoints_to_clear": "consecutiveDatapointsToClear",
            "duration_seconds": "durationSeconds",
            "ml_detection_config": "mlDetectionConfig",
            "statistical_threshold": "statisticalThreshold",
            "value": "value",
        },
    )
    class BehaviorCriteriaProperty:
        def __init__(
            self,
            *,
            comparison_operator: typing.Optional[builtins.str] = None,
            consecutive_datapoints_to_alarm: typing.Optional[jsii.Number] = None,
            consecutive_datapoints_to_clear: typing.Optional[jsii.Number] = None,
            duration_seconds: typing.Optional[jsii.Number] = None,
            ml_detection_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            statistical_threshold: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.StatisticalThresholdProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            value: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.MetricValueProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The criteria by which the behavior is determined to be normal.

            :param comparison_operator: The operator that relates the thing measured ( ``metric`` ) to the criteria (containing a ``value`` or ``statisticalThreshold`` ). Valid operators include: - ``string-list`` : ``in-set`` and ``not-in-set`` - ``number-list`` : ``in-set`` and ``not-in-set`` - ``ip-address-list`` : ``in-cidr-set`` and ``not-in-cidr-set`` - ``number`` : ``less-than`` , ``less-than-equals`` , ``greater-than`` , and ``greater-than-equals``
            :param consecutive_datapoints_to_alarm: If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
            :param consecutive_datapoints_to_clear: If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
            :param duration_seconds: Use this to specify the time duration over which the behavior is evaluated, for those criteria that have a time dimension (for example, ``NUM_MESSAGES_SENT`` ). For a ``statisticalThreshhold`` metric comparison, measurements from all devices are accumulated over this time duration before being used to calculate percentiles, and later, measurements from an individual device are also accumulated over this time duration before being given a percentile rank. Cannot be used with list-based metric datatypes.
            :param ml_detection_config: The confidence level of the detection model.
            :param statistical_threshold: A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
            :param value: The value to be compared with the ``metric`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                behavior_criteria_property = iot_mixins.CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty(
                    comparison_operator="comparisonOperator",
                    consecutive_datapoints_to_alarm=123,
                    consecutive_datapoints_to_clear=123,
                    duration_seconds=123,
                    ml_detection_config=iot_mixins.CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty(
                        confidence_level="confidenceLevel"
                    ),
                    statistical_threshold=iot_mixins.CfnSecurityProfilePropsMixin.StatisticalThresholdProperty(
                        statistic="statistic"
                    ),
                    value=iot_mixins.CfnSecurityProfilePropsMixin.MetricValueProperty(
                        cidrs=["cidrs"],
                        count="count",
                        number=123,
                        numbers=[123],
                        ports=[123],
                        strings=["strings"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0bf0fa2ef4518c1a20104e3639352fe58069524d24bcf1e77ba6e633ac2b61a2)
                check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
                check_type(argname="argument consecutive_datapoints_to_alarm", value=consecutive_datapoints_to_alarm, expected_type=type_hints["consecutive_datapoints_to_alarm"])
                check_type(argname="argument consecutive_datapoints_to_clear", value=consecutive_datapoints_to_clear, expected_type=type_hints["consecutive_datapoints_to_clear"])
                check_type(argname="argument duration_seconds", value=duration_seconds, expected_type=type_hints["duration_seconds"])
                check_type(argname="argument ml_detection_config", value=ml_detection_config, expected_type=type_hints["ml_detection_config"])
                check_type(argname="argument statistical_threshold", value=statistical_threshold, expected_type=type_hints["statistical_threshold"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if comparison_operator is not None:
                self._values["comparison_operator"] = comparison_operator
            if consecutive_datapoints_to_alarm is not None:
                self._values["consecutive_datapoints_to_alarm"] = consecutive_datapoints_to_alarm
            if consecutive_datapoints_to_clear is not None:
                self._values["consecutive_datapoints_to_clear"] = consecutive_datapoints_to_clear
            if duration_seconds is not None:
                self._values["duration_seconds"] = duration_seconds
            if ml_detection_config is not None:
                self._values["ml_detection_config"] = ml_detection_config
            if statistical_threshold is not None:
                self._values["statistical_threshold"] = statistical_threshold
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def comparison_operator(self) -> typing.Optional[builtins.str]:
            '''The operator that relates the thing measured ( ``metric`` ) to the criteria (containing a ``value`` or ``statisticalThreshold`` ).

            Valid operators include:

            - ``string-list`` : ``in-set`` and ``not-in-set``
            - ``number-list`` : ``in-set`` and ``not-in-set``
            - ``ip-address-list`` : ``in-cidr-set`` and ``not-in-cidr-set``
            - ``number`` : ``less-than`` , ``less-than-equals`` , ``greater-than`` , and ``greater-than-equals``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-comparisonoperator
            '''
            result = self._values.get("comparison_operator")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def consecutive_datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
            '''If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs.

            If not specified, the default is 1.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-consecutivedatapointstoalarm
            '''
            result = self._values.get("consecutive_datapoints_to_alarm")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def consecutive_datapoints_to_clear(self) -> typing.Optional[jsii.Number]:
            '''If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared.

            If not specified, the default is 1.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-consecutivedatapointstoclear
            '''
            result = self._values.get("consecutive_datapoints_to_clear")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def duration_seconds(self) -> typing.Optional[jsii.Number]:
            '''Use this to specify the time duration over which the behavior is evaluated, for those criteria that have a time dimension (for example, ``NUM_MESSAGES_SENT`` ).

            For a ``statisticalThreshhold`` metric comparison, measurements from all devices are accumulated over this time duration before being used to calculate percentiles, and later, measurements from an individual device are also accumulated over this time duration before being given a percentile rank. Cannot be used with list-based metric datatypes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-durationseconds
            '''
            result = self._values.get("duration_seconds")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ml_detection_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty"]]:
            '''The confidence level of the detection model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-mldetectionconfig
            '''
            result = self._values.get("ml_detection_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty"]], result)

        @builtins.property
        def statistical_threshold(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.StatisticalThresholdProperty"]]:
            '''A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-statisticalthreshold
            '''
            result = self._values.get("statistical_threshold")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.StatisticalThresholdProperty"]], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricValueProperty"]]:
            '''The value to be compared with the ``metric`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html#cfn-iot-securityprofile-behaviorcriteria-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricValueProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BehaviorCriteriaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.BehaviorProperty",
        jsii_struct_bases=[],
        name_mapping={
            "criteria": "criteria",
            "export_metric": "exportMetric",
            "metric": "metric",
            "metric_dimension": "metricDimension",
            "name": "name",
            "suppress_alerts": "suppressAlerts",
        },
    )
    class BehaviorProperty:
        def __init__(
            self,
            *,
            criteria: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            export_metric: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            metric: typing.Optional[builtins.str] = None,
            metric_dimension: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.MetricDimensionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            name: typing.Optional[builtins.str] = None,
            suppress_alerts: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''A Device Defender security profile behavior.

            :param criteria: The criteria that determine if a device is behaving normally in regard to the ``metric`` . .. epigraph:: In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.
            :param export_metric: Value indicates exporting metrics related to the behavior when it is true.
            :param metric: What is measured by the behavior.
            :param metric_dimension: The dimension of the metric.
            :param name: The name you've given to the behavior.
            :param suppress_alerts: The alert status. If you set the value to ``true`` , alerts will be suppressed.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                behavior_property = iot_mixins.CfnSecurityProfilePropsMixin.BehaviorProperty(
                    criteria=iot_mixins.CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty(
                        comparison_operator="comparisonOperator",
                        consecutive_datapoints_to_alarm=123,
                        consecutive_datapoints_to_clear=123,
                        duration_seconds=123,
                        ml_detection_config=iot_mixins.CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty(
                            confidence_level="confidenceLevel"
                        ),
                        statistical_threshold=iot_mixins.CfnSecurityProfilePropsMixin.StatisticalThresholdProperty(
                            statistic="statistic"
                        ),
                        value=iot_mixins.CfnSecurityProfilePropsMixin.MetricValueProperty(
                            cidrs=["cidrs"],
                            count="count",
                            number=123,
                            numbers=[123],
                            ports=[123],
                            strings=["strings"]
                        )
                    ),
                    export_metric=False,
                    metric="metric",
                    metric_dimension=iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                        dimension_name="dimensionName",
                        operator="operator"
                    ),
                    name="name",
                    suppress_alerts=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__68168d253bab0cc33e754d8535bf2062764cb2fe7ee4ed148ef20c8a7b8d07f2)
                check_type(argname="argument criteria", value=criteria, expected_type=type_hints["criteria"])
                check_type(argname="argument export_metric", value=export_metric, expected_type=type_hints["export_metric"])
                check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
                check_type(argname="argument metric_dimension", value=metric_dimension, expected_type=type_hints["metric_dimension"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument suppress_alerts", value=suppress_alerts, expected_type=type_hints["suppress_alerts"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if criteria is not None:
                self._values["criteria"] = criteria
            if export_metric is not None:
                self._values["export_metric"] = export_metric
            if metric is not None:
                self._values["metric"] = metric
            if metric_dimension is not None:
                self._values["metric_dimension"] = metric_dimension
            if name is not None:
                self._values["name"] = name
            if suppress_alerts is not None:
                self._values["suppress_alerts"] = suppress_alerts

        @builtins.property
        def criteria(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty"]]:
            '''The criteria that determine if a device is behaving normally in regard to the ``metric`` .

            .. epigraph::

               In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html#cfn-iot-securityprofile-behavior-criteria
            '''
            result = self._values.get("criteria")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty"]], result)

        @builtins.property
        def export_metric(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Value indicates exporting metrics related to the behavior when it is true.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html#cfn-iot-securityprofile-behavior-exportmetric
            '''
            result = self._values.get("export_metric")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def metric(self) -> typing.Optional[builtins.str]:
            '''What is measured by the behavior.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html#cfn-iot-securityprofile-behavior-metric
            '''
            result = self._values.get("metric")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metric_dimension(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricDimensionProperty"]]:
            '''The dimension of the metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html#cfn-iot-securityprofile-behavior-metricdimension
            '''
            result = self._values.get("metric_dimension")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricDimensionProperty"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name you've given to the behavior.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html#cfn-iot-securityprofile-behavior-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def suppress_alerts(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''The alert status.

            If you set the value to ``true`` , alerts will be suppressed.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html#cfn-iot-securityprofile-behavior-suppressalerts
            '''
            result = self._values.get("suppress_alerts")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BehaviorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"confidence_level": "confidenceLevel"},
    )
    class MachineLearningDetectionConfigProperty:
        def __init__(
            self,
            *,
            confidence_level: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``MachineLearningDetectionConfig`` property type controls confidence of the machine learning model.

            :param confidence_level: The model confidence level. There are three levels of confidence, ``"high"`` , ``"medium"`` , and ``"low"`` . The higher the confidence level, the lower the sensitivity, and the lower the alarm frequency will be.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-machinelearningdetectionconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                machine_learning_detection_config_property = iot_mixins.CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty(
                    confidence_level="confidenceLevel"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1e497357f7d31908b0566e95901794535add9692da8a65115d07d5c0be094a60)
                check_type(argname="argument confidence_level", value=confidence_level, expected_type=type_hints["confidence_level"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if confidence_level is not None:
                self._values["confidence_level"] = confidence_level

        @builtins.property
        def confidence_level(self) -> typing.Optional[builtins.str]:
            '''The model confidence level.

            There are three levels of confidence, ``"high"`` , ``"medium"`` , and ``"low"`` .

            The higher the confidence level, the lower the sensitivity, and the lower the alarm frequency will be.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-machinelearningdetectionconfig.html#cfn-iot-securityprofile-machinelearningdetectionconfig-confidencelevel
            '''
            result = self._values.get("confidence_level")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MachineLearningDetectionConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty",
        jsii_struct_bases=[],
        name_mapping={"dimension_name": "dimensionName", "operator": "operator"},
    )
    class MetricDimensionProperty:
        def __init__(
            self,
            *,
            dimension_name: typing.Optional[builtins.str] = None,
            operator: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The dimension of the metric.

            :param dimension_name: The name of the dimension.
            :param operator: Operators are constructs that perform logical operations. Valid values are ``IN`` and ``NOT_IN`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricdimension.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                metric_dimension_property = iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                    dimension_name="dimensionName",
                    operator="operator"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c890e5775d2badbc6235afcdc260bce0481c7e4bd8be9f28e04d9d1d4579e83f)
                check_type(argname="argument dimension_name", value=dimension_name, expected_type=type_hints["dimension_name"])
                check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if dimension_name is not None:
                self._values["dimension_name"] = dimension_name
            if operator is not None:
                self._values["operator"] = operator

        @builtins.property
        def dimension_name(self) -> typing.Optional[builtins.str]:
            '''The name of the dimension.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricdimension.html#cfn-iot-securityprofile-metricdimension-dimensionname
            '''
            result = self._values.get("dimension_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def operator(self) -> typing.Optional[builtins.str]:
            '''Operators are constructs that perform logical operations.

            Valid values are ``IN`` and ``NOT_IN`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricdimension.html#cfn-iot-securityprofile-metricdimension-operator
            '''
            result = self._values.get("operator")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetricDimensionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.MetricToRetainProperty",
        jsii_struct_bases=[],
        name_mapping={
            "export_metric": "exportMetric",
            "metric": "metric",
            "metric_dimension": "metricDimension",
        },
    )
    class MetricToRetainProperty:
        def __init__(
            self,
            *,
            export_metric: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            metric: typing.Optional[builtins.str] = None,
            metric_dimension: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSecurityProfilePropsMixin.MetricDimensionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The metric you want to retain.

            Dimensions are optional.

            :param export_metric: The value indicates exporting metrics related to the ``MetricToRetain`` when it's true.
            :param metric: A standard of measurement.
            :param metric_dimension: The dimension of the metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metrictoretain.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                metric_to_retain_property = iot_mixins.CfnSecurityProfilePropsMixin.MetricToRetainProperty(
                    export_metric=False,
                    metric="metric",
                    metric_dimension=iot_mixins.CfnSecurityProfilePropsMixin.MetricDimensionProperty(
                        dimension_name="dimensionName",
                        operator="operator"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__27dccc2f59314822103ff9caaacd9cdeb28eb7a50f2dcc8504dc4bebb78a1a4d)
                check_type(argname="argument export_metric", value=export_metric, expected_type=type_hints["export_metric"])
                check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
                check_type(argname="argument metric_dimension", value=metric_dimension, expected_type=type_hints["metric_dimension"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if export_metric is not None:
                self._values["export_metric"] = export_metric
            if metric is not None:
                self._values["metric"] = metric
            if metric_dimension is not None:
                self._values["metric_dimension"] = metric_dimension

        @builtins.property
        def export_metric(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''The value indicates exporting metrics related to the ``MetricToRetain`` when it's true.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metrictoretain.html#cfn-iot-securityprofile-metrictoretain-exportmetric
            '''
            result = self._values.get("export_metric")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def metric(self) -> typing.Optional[builtins.str]:
            '''A standard of measurement.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metrictoretain.html#cfn-iot-securityprofile-metrictoretain-metric
            '''
            result = self._values.get("metric")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metric_dimension(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricDimensionProperty"]]:
            '''The dimension of the metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metrictoretain.html#cfn-iot-securityprofile-metrictoretain-metricdimension
            '''
            result = self._values.get("metric_dimension")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSecurityProfilePropsMixin.MetricDimensionProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetricToRetainProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.MetricValueProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidrs": "cidrs",
            "count": "count",
            "number": "number",
            "numbers": "numbers",
            "ports": "ports",
            "strings": "strings",
        },
    )
    class MetricValueProperty:
        def __init__(
            self,
            *,
            cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
            count: typing.Optional[builtins.str] = None,
            number: typing.Optional[jsii.Number] = None,
            numbers: typing.Optional[typing.Union[typing.Sequence[jsii.Number], "_aws_cdk_ceddda9d.IResolvable"]] = None,
            ports: typing.Optional[typing.Union[typing.Sequence[jsii.Number], "_aws_cdk_ceddda9d.IResolvable"]] = None,
            strings: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''The value to be compared with the ``metric`` .

            :param cidrs: If the ``comparisonOperator`` calls for a set of CIDRs, use this to specify that set to be compared with the ``metric`` .
            :param count: If the ``comparisonOperator`` calls for a numeric value, use this to specify that numeric value to be compared with the ``metric`` .
            :param number: The numeric values of a metric.
            :param numbers: The numeric value of a metric.
            :param ports: If the ``comparisonOperator`` calls for a set of ports, use this to specify that set to be compared with the ``metric`` .
            :param strings: The string values of a metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                metric_value_property = iot_mixins.CfnSecurityProfilePropsMixin.MetricValueProperty(
                    cidrs=["cidrs"],
                    count="count",
                    number=123,
                    numbers=[123],
                    ports=[123],
                    strings=["strings"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__66582d48116f3b144006693b14eb1aae8baf89dc02c6b7128c48d71e7da91e0e)
                check_type(argname="argument cidrs", value=cidrs, expected_type=type_hints["cidrs"])
                check_type(argname="argument count", value=count, expected_type=type_hints["count"])
                check_type(argname="argument number", value=number, expected_type=type_hints["number"])
                check_type(argname="argument numbers", value=numbers, expected_type=type_hints["numbers"])
                check_type(argname="argument ports", value=ports, expected_type=type_hints["ports"])
                check_type(argname="argument strings", value=strings, expected_type=type_hints["strings"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidrs is not None:
                self._values["cidrs"] = cidrs
            if count is not None:
                self._values["count"] = count
            if number is not None:
                self._values["number"] = number
            if numbers is not None:
                self._values["numbers"] = numbers
            if ports is not None:
                self._values["ports"] = ports
            if strings is not None:
                self._values["strings"] = strings

        @builtins.property
        def cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
            '''If the ``comparisonOperator`` calls for a set of CIDRs, use this to specify that set to be compared with the ``metric`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html#cfn-iot-securityprofile-metricvalue-cidrs
            '''
            result = self._values.get("cidrs")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def count(self) -> typing.Optional[builtins.str]:
            '''If the ``comparisonOperator`` calls for a numeric value, use this to specify that numeric value to be compared with the ``metric`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html#cfn-iot-securityprofile-metricvalue-count
            '''
            result = self._values.get("count")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def number(self) -> typing.Optional[jsii.Number]:
            '''The numeric values of a metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html#cfn-iot-securityprofile-metricvalue-number
            '''
            result = self._values.get("number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def numbers(
            self,
        ) -> typing.Optional[typing.Union[typing.List[jsii.Number], "_aws_cdk_ceddda9d.IResolvable"]]:
            '''The numeric value of a metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html#cfn-iot-securityprofile-metricvalue-numbers
            '''
            result = self._values.get("numbers")
            return typing.cast(typing.Optional[typing.Union[typing.List[jsii.Number], "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def ports(
            self,
        ) -> typing.Optional[typing.Union[typing.List[jsii.Number], "_aws_cdk_ceddda9d.IResolvable"]]:
            '''If the ``comparisonOperator`` calls for a set of ports, use this to specify that set to be compared with the ``metric`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html#cfn-iot-securityprofile-metricvalue-ports
            '''
            result = self._values.get("ports")
            return typing.cast(typing.Optional[typing.Union[typing.List[jsii.Number], "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def strings(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The string values of a metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html#cfn-iot-securityprofile-metricvalue-strings
            '''
            result = self._values.get("strings")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetricValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.MetricsExportConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"mqtt_topic": "mqttTopic", "role_arn": "roleArn"},
    )
    class MetricsExportConfigProperty:
        def __init__(
            self,
            *,
            mqtt_topic: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the MQTT topic and role ARN required for metric export.

            :param mqtt_topic: The MQTT topic that Device Defender Detect should publish messages to for metrics export.
            :param role_arn: This role ARN has permission to publish MQTT messages, after which Device Defender Detect can assume the role and publish messages on your behalf.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricsexportconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                metrics_export_config_property = iot_mixins.CfnSecurityProfilePropsMixin.MetricsExportConfigProperty(
                    mqtt_topic="mqttTopic",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__205b3ba4aa26f583a9294a86b2b36e303ce9a8491d84e11b75873428deec1fa1)
                check_type(argname="argument mqtt_topic", value=mqtt_topic, expected_type=type_hints["mqtt_topic"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if mqtt_topic is not None:
                self._values["mqtt_topic"] = mqtt_topic
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def mqtt_topic(self) -> typing.Optional[builtins.str]:
            '''The MQTT topic that Device Defender Detect should publish messages to for metrics export.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricsexportconfig.html#cfn-iot-securityprofile-metricsexportconfig-mqtttopic
            '''
            result = self._values.get("mqtt_topic")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''This role ARN has permission to publish MQTT messages, after which Device Defender Detect can assume the role and publish messages on your behalf.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricsexportconfig.html#cfn-iot-securityprofile-metricsexportconfig-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetricsExportConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSecurityProfilePropsMixin.StatisticalThresholdProperty",
        jsii_struct_bases=[],
        name_mapping={"statistic": "statistic"},
    )
    class StatisticalThresholdProperty:
        def __init__(self, *, statistic: typing.Optional[builtins.str] = None) -> None:
            '''A statistical ranking (percentile) that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.

            :param statistic: The percentile that resolves to a threshold value by which compliance with a behavior is determined. Metrics are collected over the specified period ( ``durationSeconds`` ) from all reporting devices in your account and statistical ranks are calculated. Then, the measurements from a device are collected over the same period. If the accumulated measurements from the device fall above or below ( ``comparisonOperator`` ) the value associated with the percentile specified, then the device is considered to be in compliance with the behavior, otherwise a violation occurs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-statisticalthreshold.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                statistical_threshold_property = iot_mixins.CfnSecurityProfilePropsMixin.StatisticalThresholdProperty(
                    statistic="statistic"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5efca579bebc261caa670c4cf844e1f6181227aebe7d97ce4ace5f8f6a0e63d1)
                check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if statistic is not None:
                self._values["statistic"] = statistic

        @builtins.property
        def statistic(self) -> typing.Optional[builtins.str]:
            '''The percentile that resolves to a threshold value by which compliance with a behavior is determined.

            Metrics are collected over the specified period ( ``durationSeconds`` ) from all reporting devices in your account and statistical ranks are calculated. Then, the measurements from a device are collected over the same period. If the accumulated measurements from the device fall above or below ( ``comparisonOperator`` ) the value associated with the percentile specified, then the device is considered to be in compliance with the behavior, otherwise a violation occurs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-statisticalthreshold.html#cfn-iot-securityprofile-statisticalthreshold-statistic
            '''
            result = self._values.get("statistic")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StatisticalThresholdProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackageMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "package_name": "packageName",
        "tags": "tags",
    },
)
class CfnSoftwarePackageMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        package_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnSoftwarePackagePropsMixin.

        :param description: A summary of the package being created. This can be used to outline the package's contents or purpose.
        :param package_name: The name of the new software package.
        :param tags: Metadata that can be used to manage the package.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackage.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_software_package_mixin_props = iot_mixins.CfnSoftwarePackageMixinProps(
                description="description",
                package_name="packageName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1869b0b282709bd26bf8b18a8e7628640c59ad25eccbb0387e552a4c3169311)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument package_name", value=package_name, expected_type=type_hints["package_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if package_name is not None:
            self._values["package_name"] = package_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A summary of the package being created.

        This can be used to outline the package's contents or purpose.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackage.html#cfn-iot-softwarepackage-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def package_name(self) -> typing.Optional[builtins.str]:
        '''The name of the new software package.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackage.html#cfn-iot-softwarepackage-packagename
        '''
        result = self._values.get("package_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the package.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackage.html#cfn-iot-softwarepackage-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSoftwarePackageMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSoftwarePackagePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackagePropsMixin",
):
    '''Use the ``AWS::IoT::SoftwarePackage`` resource to create a software package.

    For information about working with software packages, see `AWS IoT Device Management Software Package Catalog <https://docs.aws.amazon.com/iot/latest/developerguide/software-package-catalog.html>`_ and `Creating a software package and package version <https://docs.aws.amazon.com/iot/latest/developerguide/creating-package-and-version.html>`_ in the *AWS IoT Developer Guide* . See also, `CreatePackage <https://docs.aws.amazon.com/iot/latest/apireference/API_CreatePackage.html>`_ in the *API Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackage.html
    :cloudformationResource: AWS::IoT::SoftwarePackage
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_software_package_props_mixin = iot_mixins.CfnSoftwarePackagePropsMixin(iot_mixins.CfnSoftwarePackageMixinProps(
            description="description",
            package_name="packageName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSoftwarePackageMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::SoftwarePackage``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23d7174ff31e0db0b9b6605c44d7f774c77ca78bbb18f91d262310bdabb0f38b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73551716a2bb232a81de44975912b0444c053b0e7949c1e69717354a72702c9d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec3eaccbd784ff59ce2e448d9410991a8c26efb1c8253744bd1bfcbf8139ed28)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSoftwarePackageMixinProps":
        return typing.cast("CfnSoftwarePackageMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackageVersionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "artifact": "artifact",
        "attributes": "attributes",
        "description": "description",
        "package_name": "packageName",
        "recipe": "recipe",
        "sbom": "sbom",
        "tags": "tags",
        "version_name": "versionName",
    },
)
class CfnSoftwarePackageVersionMixinProps:
    def __init__(
        self,
        *,
        artifact: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        attributes: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
        description: typing.Optional[builtins.str] = None,
        package_name: typing.Optional[builtins.str] = None,
        recipe: typing.Optional[builtins.str] = None,
        sbom: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSoftwarePackageVersionPropsMixin.SbomProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnSoftwarePackageVersionPropsMixin.

        :param artifact: The artifact location of the package version.
        :param attributes: Metadata that can be used to define a package versions configuration. For example, the S3 file location, configuration options that are being sent to the device or fleet. The combined size of all the attributes on a package version is limited to 3KB.
        :param description: A summary of the package version being created. This can be used to outline the package's contents or purpose.
        :param package_name: The name of the associated software package.
        :param recipe: The inline json job document associated with a software package version.
        :param sbom: The sbom zip archive location of the package version.
        :param tags: Metadata that can be used to manage the package version.
        :param version_name: The name of the new package version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_software_package_version_mixin_props = iot_mixins.CfnSoftwarePackageVersionMixinProps(
                artifact=iot_mixins.CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty(
                    s3_location=iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                        bucket="bucket",
                        key="key",
                        version="version"
                    )
                ),
                attributes={
                    "attributes_key": "attributes"
                },
                description="description",
                package_name="packageName",
                recipe="recipe",
                sbom=iot_mixins.CfnSoftwarePackageVersionPropsMixin.SbomProperty(
                    s3_location=iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                        bucket="bucket",
                        key="key",
                        version="version"
                    )
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                version_name="versionName"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f38dfc19187b5fb4176d349fed3d060e257505692a332903233398800dadabf9)
            check_type(argname="argument artifact", value=artifact, expected_type=type_hints["artifact"])
            check_type(argname="argument attributes", value=attributes, expected_type=type_hints["attributes"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument package_name", value=package_name, expected_type=type_hints["package_name"])
            check_type(argname="argument recipe", value=recipe, expected_type=type_hints["recipe"])
            check_type(argname="argument sbom", value=sbom, expected_type=type_hints["sbom"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument version_name", value=version_name, expected_type=type_hints["version_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if artifact is not None:
            self._values["artifact"] = artifact
        if attributes is not None:
            self._values["attributes"] = attributes
        if description is not None:
            self._values["description"] = description
        if package_name is not None:
            self._values["package_name"] = package_name
        if recipe is not None:
            self._values["recipe"] = recipe
        if sbom is not None:
            self._values["sbom"] = sbom
        if tags is not None:
            self._values["tags"] = tags
        if version_name is not None:
            self._values["version_name"] = version_name

    @builtins.property
    def artifact(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty"]]:
        '''The artifact location of the package version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-artifact
        '''
        result = self._values.get("artifact")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty"]], result)

    @builtins.property
    def attributes(
        self,
    ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Metadata that can be used to define a package versions configuration.

        For example, the S3 file location, configuration options that are being sent to the device or fleet.

        The combined size of all the attributes on a package version is limited to 3KB.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-attributes
        '''
        result = self._values.get("attributes")
        return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A summary of the package version being created.

        This can be used to outline the package's contents or purpose.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def package_name(self) -> typing.Optional[builtins.str]:
        '''The name of the associated software package.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-packagename
        '''
        result = self._values.get("package_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def recipe(self) -> typing.Optional[builtins.str]:
        '''The inline json job document associated with a software package version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-recipe
        '''
        result = self._values.get("recipe")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sbom(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.SbomProperty"]]:
        '''The sbom zip archive location of the package version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-sbom
        '''
        result = self._values.get("sbom")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.SbomProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata that can be used to manage the package version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def version_name(self) -> typing.Optional[builtins.str]:
        '''The name of the new package version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html#cfn-iot-softwarepackageversion-versionname
        '''
        result = self._values.get("version_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSoftwarePackageVersionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnSoftwarePackageVersionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackageVersionPropsMixin",
):
    '''Use the ``AWS::IoT::SoftwarePackageVersion`` resource to create a software package version.

    For information about working with software package versions, see `AWS IoT Device Management Software Package Catalog <https://docs.aws.amazon.com/iot/latest/developerguide/software-package-catalog.html>`_ and `Creating a software package and package version <https://docs.aws.amazon.com/iot/latest/developerguide/creating-package-and-version.html>`_ in the *AWS IoT Developer Guide* . See also, `CreatePackageVersion <https://docs.aws.amazon.com/iot/latest/apireference/API_CreatePackageVersion.html>`_ in the *API Guide* .
    .. epigraph::

       The associated software package must exist before the package version is created. If you create a software package and package version in the same CloudFormation template, set the software package as a `dependency <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ of the package version. If they are created out of sequence, you will receive an error.

       Package versions and created in a ``draft`` state, for more information, see `Package version lifecycle <https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle>`_ . To change the package version state after its created, use the `UpdatePackageVersionAPI <https://docs.aws.amazon.com/iot/latest/apireference/API_UpdatePackageVersion.html>`_ command.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html
    :cloudformationResource: AWS::IoT::SoftwarePackageVersion
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_software_package_version_props_mixin = iot_mixins.CfnSoftwarePackageVersionPropsMixin(iot_mixins.CfnSoftwarePackageVersionMixinProps(
            artifact=iot_mixins.CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty(
                s3_location=iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                    bucket="bucket",
                    key="key",
                    version="version"
                )
            ),
            attributes={
                "attributes_key": "attributes"
            },
            description="description",
            package_name="packageName",
            recipe="recipe",
            sbom=iot_mixins.CfnSoftwarePackageVersionPropsMixin.SbomProperty(
                s3_location=iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                    bucket="bucket",
                    key="key",
                    version="version"
                )
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            version_name="versionName"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnSoftwarePackageVersionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::SoftwarePackageVersion``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38d37038891a68390ce9c76ea640cbeb57f9001928ecc46961e6146eb672ae89)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c67a58d076354c2afe1fd78088d63ec97949fa5cc6899b19d0fe23a73f29e432)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93f21adc30c078bebdde9f9f026c0f0926cd8cc8abfb191da8fff885028d2cf6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnSoftwarePackageVersionMixinProps":
        return typing.cast("CfnSoftwarePackageVersionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty",
        jsii_struct_bases=[],
        name_mapping={"s3_location": "s3Location"},
    )
    class PackageVersionArtifactProperty:
        def __init__(
            self,
            *,
            s3_location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSoftwarePackageVersionPropsMixin.S3LocationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The artifact location of the package version.

            :param s3_location: The Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-packageversionartifact.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                package_version_artifact_property = iot_mixins.CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty(
                    s3_location=iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                        bucket="bucket",
                        key="key",
                        version="version"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e0037bbe4ab940285f3f79efb3d4167bbe25c4b35f0e76ce37bb66dabc958ac1)
                check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3_location is not None:
                self._values["s3_location"] = s3_location

        @builtins.property
        def s3_location(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.S3LocationProperty"]]:
            '''The Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-packageversionartifact.html#cfn-iot-softwarepackageversion-packageversionartifact-s3location
            '''
            result = self._values.get("s3_location")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.S3LocationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PackageVersionArtifactProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket": "bucket", "key": "key", "version": "version"},
    )
    class S3LocationProperty:
        def __init__(
            self,
            *,
            bucket: typing.Optional[builtins.str] = None,
            key: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The Amazon S3 location.

            :param bucket: The S3 bucket.
            :param key: The S3 key.
            :param version: The S3 version.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-s3location.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                s3_location_property = iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                    bucket="bucket",
                    key="key",
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2029463f8ebbd92e6be94c11e71b2823e77972c482683d8a0feb6cd9f60dc9f6)
                check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket is not None:
                self._values["bucket"] = bucket
            if key is not None:
                self._values["key"] = key
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def bucket(self) -> typing.Optional[builtins.str]:
            '''The S3 bucket.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-s3location.html#cfn-iot-softwarepackageversion-s3location-bucket
            '''
            result = self._values.get("bucket")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The S3 key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-s3location.html#cfn-iot-softwarepackageversion-s3location-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The S3 version.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-s3location.html#cfn-iot-softwarepackageversion-s3location-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3LocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnSoftwarePackageVersionPropsMixin.SbomProperty",
        jsii_struct_bases=[],
        name_mapping={"s3_location": "s3Location"},
    )
    class SbomProperty:
        def __init__(
            self,
            *,
            s3_location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnSoftwarePackageVersionPropsMixin.S3LocationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The sbom zip archive location of the package version.

            :param s3_location: The Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-sbom.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                sbom_property = iot_mixins.CfnSoftwarePackageVersionPropsMixin.SbomProperty(
                    s3_location=iot_mixins.CfnSoftwarePackageVersionPropsMixin.S3LocationProperty(
                        bucket="bucket",
                        key="key",
                        version="version"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2561318b4309f98c259871011e1ac9683dd95481041b464dd66b95332b1dbdff)
                check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3_location is not None:
                self._values["s3_location"] = s3_location

        @builtins.property
        def s3_location(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.S3LocationProperty"]]:
            '''The Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-softwarepackageversion-sbom.html#cfn-iot-softwarepackageversion-sbom-s3location
            '''
            result = self._values.get("s3_location")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnSoftwarePackageVersionPropsMixin.S3LocationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SbomProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingGroupMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "parent_group_name": "parentGroupName",
        "query_string": "queryString",
        "tags": "tags",
        "thing_group_name": "thingGroupName",
        "thing_group_properties": "thingGroupProperties",
    },
)
class CfnThingGroupMixinProps:
    def __init__(
        self,
        *,
        parent_group_name: typing.Optional[builtins.str] = None,
        query_string: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        thing_group_name: typing.Optional[builtins.str] = None,
        thing_group_properties: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnThingGroupPropsMixin.ThingGroupPropertiesProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnThingGroupPropsMixin.

        :param parent_group_name: The parent thing group name. A Dynamic Thing Group does not have ``parentGroupName`` defined.
        :param query_string: The dynamic thing group search query string. The ``queryString`` attribute *is* required for ``CreateDynamicThingGroup`` . The ``queryString`` attribute *is not* required for ``CreateThingGroup`` .
        :param tags: Metadata which can be used to manage the thing group or dynamic thing group.
        :param thing_group_name: The thing group name.
        :param thing_group_properties: Thing group properties.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_thing_group_mixin_props = iot_mixins.CfnThingGroupMixinProps(
                parent_group_name="parentGroupName",
                query_string="queryString",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                thing_group_name="thingGroupName",
                thing_group_properties=iot_mixins.CfnThingGroupPropsMixin.ThingGroupPropertiesProperty(
                    attribute_payload=iot_mixins.CfnThingGroupPropsMixin.AttributePayloadProperty(
                        attributes={
                            "attributes_key": "attributes"
                        }
                    ),
                    thing_group_description="thingGroupDescription"
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__618a45ccd8056e3248c59a2c2818ecc9b5a5a630ac7ac7e7f4d83244e3d1cc59)
            check_type(argname="argument parent_group_name", value=parent_group_name, expected_type=type_hints["parent_group_name"])
            check_type(argname="argument query_string", value=query_string, expected_type=type_hints["query_string"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument thing_group_name", value=thing_group_name, expected_type=type_hints["thing_group_name"])
            check_type(argname="argument thing_group_properties", value=thing_group_properties, expected_type=type_hints["thing_group_properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if parent_group_name is not None:
            self._values["parent_group_name"] = parent_group_name
        if query_string is not None:
            self._values["query_string"] = query_string
        if tags is not None:
            self._values["tags"] = tags
        if thing_group_name is not None:
            self._values["thing_group_name"] = thing_group_name
        if thing_group_properties is not None:
            self._values["thing_group_properties"] = thing_group_properties

    @builtins.property
    def parent_group_name(self) -> typing.Optional[builtins.str]:
        '''The parent thing group name.

        A Dynamic Thing Group does not have ``parentGroupName`` defined.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html#cfn-iot-thinggroup-parentgroupname
        '''
        result = self._values.get("parent_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query_string(self) -> typing.Optional[builtins.str]:
        '''The dynamic thing group search query string.

        The ``queryString`` attribute *is* required for ``CreateDynamicThingGroup`` . The ``queryString`` attribute *is not* required for ``CreateThingGroup`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html#cfn-iot-thinggroup-querystring
        '''
        result = self._values.get("query_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the thing group or dynamic thing group.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html#cfn-iot-thinggroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def thing_group_name(self) -> typing.Optional[builtins.str]:
        '''The thing group name.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html#cfn-iot-thinggroup-thinggroupname
        '''
        result = self._values.get("thing_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def thing_group_properties(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingGroupPropsMixin.ThingGroupPropertiesProperty"]]:
        '''Thing group properties.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html#cfn-iot-thinggroup-thinggroupproperties
        '''
        result = self._values.get("thing_group_properties")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingGroupPropsMixin.ThingGroupPropertiesProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnThingGroupMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnThingGroupPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingGroupPropsMixin",
):
    '''Creates a new thing group.

    A dynamic thing group is created if the resource template contains the ``QueryString`` attribute. A dynamic thing group will not contain the ``ParentGroupName`` attribute. A static thing group and dynamic thing group can't be converted to each other via the addition or removal of the ``QueryString`` attribute.
    .. epigraph::

       This is a control plane operation. See `Authorization <https://docs.aws.amazon.com/iot/latest/developerguide/iot-authorization.html>`_ for information about authorizing control plane actions.

    Requires permission to access the `CreateThingGroup <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html
    :cloudformationResource: AWS::IoT::ThingGroup
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_thing_group_props_mixin = iot_mixins.CfnThingGroupPropsMixin(iot_mixins.CfnThingGroupMixinProps(
            parent_group_name="parentGroupName",
            query_string="queryString",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            thing_group_name="thingGroupName",
            thing_group_properties=iot_mixins.CfnThingGroupPropsMixin.ThingGroupPropertiesProperty(
                attribute_payload=iot_mixins.CfnThingGroupPropsMixin.AttributePayloadProperty(
                    attributes={
                        "attributes_key": "attributes"
                    }
                ),
                thing_group_description="thingGroupDescription"
            )
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnThingGroupMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::ThingGroup``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f3df340d4d875e5012c6bc65b5162c4c554a1c8552f78d3735c3e914e0c3624)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19de54215a737919f8963db2f09904087994d784ff3547be1de067f972da6f0f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9299ec1fc2f94b3c8348a51c1287c3cc34433b0a20d0e1a0e2a899c53d72b3ab)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnThingGroupMixinProps":
        return typing.cast("CfnThingGroupMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingGroupPropsMixin.AttributePayloadProperty",
        jsii_struct_bases=[],
        name_mapping={"attributes": "attributes"},
    )
    class AttributePayloadProperty:
        def __init__(
            self,
            *,
            attributes: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''The attribute payload.

            :param attributes: A JSON string containing up to three key-value pair in JSON format. For example:. ``{\\"attributes\\":{\\"string1\\":\\"string2\\"}}``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-attributepayload.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                attribute_payload_property = iot_mixins.CfnThingGroupPropsMixin.AttributePayloadProperty(
                    attributes={
                        "attributes_key": "attributes"
                    }
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__062dcdfdcbfdbaadb83cd60a2aa0381c3fc753d3c6fe19ec78bb760b57e388e5)
                check_type(argname="argument attributes", value=attributes, expected_type=type_hints["attributes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if attributes is not None:
                self._values["attributes"] = attributes

        @builtins.property
        def attributes(
            self,
        ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
            '''A JSON string containing up to three key-value pair in JSON format. For example:.

            ``{\\"attributes\\":{\\"string1\\":\\"string2\\"}}``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-attributepayload.html#cfn-iot-thinggroup-attributepayload-attributes
            '''
            result = self._values.get("attributes")
            return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AttributePayloadProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingGroupPropsMixin.ThingGroupPropertiesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "attribute_payload": "attributePayload",
            "thing_group_description": "thingGroupDescription",
        },
    )
    class ThingGroupPropertiesProperty:
        def __init__(
            self,
            *,
            attribute_payload: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnThingGroupPropsMixin.AttributePayloadProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            thing_group_description: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Thing group properties.

            :param attribute_payload: The thing group attributes in JSON format.
            :param thing_group_description: The thing group description.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-thinggroupproperties.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                thing_group_properties_property = iot_mixins.CfnThingGroupPropsMixin.ThingGroupPropertiesProperty(
                    attribute_payload=iot_mixins.CfnThingGroupPropsMixin.AttributePayloadProperty(
                        attributes={
                            "attributes_key": "attributes"
                        }
                    ),
                    thing_group_description="thingGroupDescription"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b7e0de6a1911327ac835e97645d5da087ccf725f931aac818a510b06d9e3b863)
                check_type(argname="argument attribute_payload", value=attribute_payload, expected_type=type_hints["attribute_payload"])
                check_type(argname="argument thing_group_description", value=thing_group_description, expected_type=type_hints["thing_group_description"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if attribute_payload is not None:
                self._values["attribute_payload"] = attribute_payload
            if thing_group_description is not None:
                self._values["thing_group_description"] = thing_group_description

        @builtins.property
        def attribute_payload(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingGroupPropsMixin.AttributePayloadProperty"]]:
            '''The thing group attributes in JSON format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-thinggroupproperties.html#cfn-iot-thinggroup-thinggroupproperties-attributepayload
            '''
            result = self._values.get("attribute_payload")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingGroupPropsMixin.AttributePayloadProperty"]], result)

        @builtins.property
        def thing_group_description(self) -> typing.Optional[builtins.str]:
            '''The thing group description.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-thinggroupproperties.html#cfn-iot-thinggroup-thinggroupproperties-thinggroupdescription
            '''
            result = self._values.get("thing_group_description")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ThingGroupPropertiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingMixinProps",
    jsii_struct_bases=[],
    name_mapping={"attribute_payload": "attributePayload", "thing_name": "thingName"},
)
class CfnThingMixinProps:
    def __init__(
        self,
        *,
        attribute_payload: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnThingPropsMixin.AttributePayloadProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        thing_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnThingPropsMixin.

        :param attribute_payload: A string that contains up to three key value pairs. Maximum length of 800. Duplicates not allowed.
        :param thing_name: The name of the thing to update. You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thing.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_thing_mixin_props = iot_mixins.CfnThingMixinProps(
                attribute_payload=iot_mixins.CfnThingPropsMixin.AttributePayloadProperty(
                    attributes={
                        "attributes_key": "attributes"
                    }
                ),
                thing_name="thingName"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17984d2f22d0156778b05d1cd3554a781c3ee8c1fc198f426b38b91f60797fba)
            check_type(argname="argument attribute_payload", value=attribute_payload, expected_type=type_hints["attribute_payload"])
            check_type(argname="argument thing_name", value=thing_name, expected_type=type_hints["thing_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if attribute_payload is not None:
            self._values["attribute_payload"] = attribute_payload
        if thing_name is not None:
            self._values["thing_name"] = thing_name

    @builtins.property
    def attribute_payload(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingPropsMixin.AttributePayloadProperty"]]:
        '''A string that contains up to three key value pairs.

        Maximum length of 800. Duplicates not allowed.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thing.html#cfn-iot-thing-attributepayload
        '''
        result = self._values.get("attribute_payload")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingPropsMixin.AttributePayloadProperty"]], result)

    @builtins.property
    def thing_name(self) -> typing.Optional[builtins.str]:
        '''The name of the thing to update.

        You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thing.html#cfn-iot-thing-thingname
        '''
        result = self._values.get("thing_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnThingMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingPrincipalAttachmentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "principal": "principal",
        "thing_name": "thingName",
        "thing_principal_type": "thingPrincipalType",
    },
)
class CfnThingPrincipalAttachmentMixinProps:
    def __init__(
        self,
        *,
        principal: typing.Optional[builtins.str] = None,
        thing_name: typing.Optional[builtins.str] = None,
        thing_principal_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnThingPrincipalAttachmentPropsMixin.

        :param principal: The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.
        :param thing_name: The name of the AWS IoT thing.
        :param thing_principal_type: 

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingprincipalattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_thing_principal_attachment_mixin_props = iot_mixins.CfnThingPrincipalAttachmentMixinProps(
                principal="principal",
                thing_name="thingName",
                thing_principal_type="thingPrincipalType"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e565a71d14f8170716226b76d70953b85ca6e72be9f8762b41bca5f228367f0)
            check_type(argname="argument principal", value=principal, expected_type=type_hints["principal"])
            check_type(argname="argument thing_name", value=thing_name, expected_type=type_hints["thing_name"])
            check_type(argname="argument thing_principal_type", value=thing_principal_type, expected_type=type_hints["thing_principal_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if principal is not None:
            self._values["principal"] = principal
        if thing_name is not None:
            self._values["thing_name"] = thing_name
        if thing_principal_type is not None:
            self._values["thing_principal_type"] = thing_principal_type

    @builtins.property
    def principal(self) -> typing.Optional[builtins.str]:
        '''The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingprincipalattachment.html#cfn-iot-thingprincipalattachment-principal
        '''
        result = self._values.get("principal")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def thing_name(self) -> typing.Optional[builtins.str]:
        '''The name of the AWS IoT thing.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingprincipalattachment.html#cfn-iot-thingprincipalattachment-thingname
        '''
        result = self._values.get("thing_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def thing_principal_type(self) -> typing.Optional[builtins.str]:
        '''
        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingprincipalattachment.html#cfn-iot-thingprincipalattachment-thingprincipaltype
        '''
        result = self._values.get("thing_principal_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnThingPrincipalAttachmentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnThingPrincipalAttachmentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingPrincipalAttachmentPropsMixin",
):
    '''Use the ``AWS::IoT::ThingPrincipalAttachment`` resource to attach a principal (an X.509 certificate or another credential) to a thing.

    For more information about working with AWS IoT things and principals, see `Authorization <https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html>`_ in the *AWS IoT Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingprincipalattachment.html
    :cloudformationResource: AWS::IoT::ThingPrincipalAttachment
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_thing_principal_attachment_props_mixin = iot_mixins.CfnThingPrincipalAttachmentPropsMixin(iot_mixins.CfnThingPrincipalAttachmentMixinProps(
            principal="principal",
            thing_name="thingName",
            thing_principal_type="thingPrincipalType"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnThingPrincipalAttachmentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::ThingPrincipalAttachment``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed3376ac55723de5a7182bb336920b6c7f97156986db5a12fc907e9cd8621360)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd2218eb09fffe711a4367e28bb75f31804bb5fdedb24d0b1bbc6278615ec280)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a979990def0751fdbf538c5456d00e43e2299192770b77c69bf9d826fafdd18)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnThingPrincipalAttachmentMixinProps":
        return typing.cast("CfnThingPrincipalAttachmentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.implements(_IMixin_11e4b965)
class CfnThingPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingPropsMixin",
):
    '''Use the ``AWS::IoT::Thing`` resource to declare an AWS IoT thing.

    For information about working with things, see `How AWS IoT Works <https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html>`_ and `Device Registry for AWS IoT <https://docs.aws.amazon.com/iot/latest/developerguide/thing-registry.html>`_ in the *AWS IoT Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thing.html
    :cloudformationResource: AWS::IoT::Thing
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_thing_props_mixin = iot_mixins.CfnThingPropsMixin(iot_mixins.CfnThingMixinProps(
            attribute_payload=iot_mixins.CfnThingPropsMixin.AttributePayloadProperty(
                attributes={
                    "attributes_key": "attributes"
                }
            ),
            thing_name="thingName"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnThingMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::Thing``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d6ea5647fd43f2b65b4b9bc38129a97c905922f35b65804888237259f048c51)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af52519a675719dea0d6c78c43184f69a601923344020628db51bbd9c173434d)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c95a0af05239dfb780d5829c2fba913eed364baa7abdd043f23d4f9302055696)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnThingMixinProps":
        return typing.cast("CfnThingMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingPropsMixin.AttributePayloadProperty",
        jsii_struct_bases=[],
        name_mapping={"attributes": "attributes"},
    )
    class AttributePayloadProperty:
        def __init__(
            self,
            *,
            attributes: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''The AttributePayload property specifies up to three attributes for an AWS IoT as key-value pairs.

            AttributePayload is a property of the `AWS::IoT::Thing <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thing.html>`_ resource.

            :param attributes: A JSON string containing up to three key-value pair in JSON format. For example:. ``{\\"attributes\\":{\\"string1\\":\\"string2\\"}}``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thing-attributepayload.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                attribute_payload_property = iot_mixins.CfnThingPropsMixin.AttributePayloadProperty(
                    attributes={
                        "attributes_key": "attributes"
                    }
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ea7301de30a4a0862a1fb0a3c72a1381605637301c9def60607f1dd53e98dc5c)
                check_type(argname="argument attributes", value=attributes, expected_type=type_hints["attributes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if attributes is not None:
                self._values["attributes"] = attributes

        @builtins.property
        def attributes(
            self,
        ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
            '''A JSON string containing up to three key-value pair in JSON format. For example:.

            ``{\\"attributes\\":{\\"string1\\":\\"string2\\"}}``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thing-attributepayload.html#cfn-iot-thing-attributepayload-attributes
            '''
            result = self._values.get("attributes")
            return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AttributePayloadProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingTypeMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "deprecate_thing_type": "deprecateThingType",
        "tags": "tags",
        "thing_type_name": "thingTypeName",
        "thing_type_properties": "thingTypeProperties",
    },
)
class CfnThingTypeMixinProps:
    def __init__(
        self,
        *,
        deprecate_thing_type: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        thing_type_name: typing.Optional[builtins.str] = None,
        thing_type_properties: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnThingTypePropsMixin.ThingTypePropertiesProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnThingTypePropsMixin.

        :param deprecate_thing_type: Deprecates a thing type. You can not associate new things with deprecated thing type. Requires permission to access the `DeprecateThingType <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.
        :param tags: Metadata which can be used to manage the thing type.
        :param thing_type_name: The name of the thing type.
        :param thing_type_properties: The thing type properties for the thing type to create. It contains information about the new thing type including a description, a list of searchable thing attribute names, and a list of propagating attributes. After a thing type is created, you can only update ``Mqtt5Configuration`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_thing_type_mixin_props = iot_mixins.CfnThingTypeMixinProps(
                deprecate_thing_type=False,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                thing_type_name="thingTypeName",
                thing_type_properties=iot_mixins.CfnThingTypePropsMixin.ThingTypePropertiesProperty(
                    mqtt5_configuration=iot_mixins.CfnThingTypePropsMixin.Mqtt5ConfigurationProperty(
                        propagating_attributes=[iot_mixins.CfnThingTypePropsMixin.PropagatingAttributeProperty(
                            connection_attribute="connectionAttribute",
                            thing_attribute="thingAttribute",
                            user_property_key="userPropertyKey"
                        )]
                    ),
                    searchable_attributes=["searchableAttributes"],
                    thing_type_description="thingTypeDescription"
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85c49f0301795ffb7cfab2b094e95ddaeda08b4fb393820e43487f0ae1b0d501)
            check_type(argname="argument deprecate_thing_type", value=deprecate_thing_type, expected_type=type_hints["deprecate_thing_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument thing_type_name", value=thing_type_name, expected_type=type_hints["thing_type_name"])
            check_type(argname="argument thing_type_properties", value=thing_type_properties, expected_type=type_hints["thing_type_properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if deprecate_thing_type is not None:
            self._values["deprecate_thing_type"] = deprecate_thing_type
        if tags is not None:
            self._values["tags"] = tags
        if thing_type_name is not None:
            self._values["thing_type_name"] = thing_type_name
        if thing_type_properties is not None:
            self._values["thing_type_properties"] = thing_type_properties

    @builtins.property
    def deprecate_thing_type(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Deprecates a thing type. You can not associate new things with deprecated thing type.

        Requires permission to access the `DeprecateThingType <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html#cfn-iot-thingtype-deprecatethingtype
        '''
        result = self._values.get("deprecate_thing_type")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the thing type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html#cfn-iot-thingtype-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def thing_type_name(self) -> typing.Optional[builtins.str]:
        '''The name of the thing type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html#cfn-iot-thingtype-thingtypename
        '''
        result = self._values.get("thing_type_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def thing_type_properties(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingTypePropsMixin.ThingTypePropertiesProperty"]]:
        '''The thing type properties for the thing type to create.

        It contains information about the new thing type including a description, a list of searchable thing attribute names, and a list of propagating attributes. After a thing type is created, you can only update ``Mqtt5Configuration`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html#cfn-iot-thingtype-thingtypeproperties
        '''
        result = self._values.get("thing_type_properties")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingTypePropsMixin.ThingTypePropertiesProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnThingTypeMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnThingTypePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingTypePropsMixin",
):
    '''Creates a new thing type.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html
    :cloudformationResource: AWS::IoT::ThingType
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_thing_type_props_mixin = iot_mixins.CfnThingTypePropsMixin(iot_mixins.CfnThingTypeMixinProps(
            deprecate_thing_type=False,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            thing_type_name="thingTypeName",
            thing_type_properties=iot_mixins.CfnThingTypePropsMixin.ThingTypePropertiesProperty(
                mqtt5_configuration=iot_mixins.CfnThingTypePropsMixin.Mqtt5ConfigurationProperty(
                    propagating_attributes=[iot_mixins.CfnThingTypePropsMixin.PropagatingAttributeProperty(
                        connection_attribute="connectionAttribute",
                        thing_attribute="thingAttribute",
                        user_property_key="userPropertyKey"
                    )]
                ),
                searchable_attributes=["searchableAttributes"],
                thing_type_description="thingTypeDescription"
            )
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnThingTypeMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::ThingType``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1bb494c036ab3eaf008b783d3d66e1295767f99775ea6a94ab4dea7d800bf02)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d105e09e131aeca051f244834940d7ce9523b8655c952d67605cb4600ee2fb81)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e219a2c4773a78a193b7d79e6b712b01757f99fc4359ef6dafaa069a5e95d7fe)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnThingTypeMixinProps":
        return typing.cast("CfnThingTypeMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingTypePropsMixin.Mqtt5ConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"propagating_attributes": "propagatingAttributes"},
    )
    class Mqtt5ConfigurationProperty:
        def __init__(
            self,
            *,
            propagating_attributes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnThingTypePropsMixin.PropagatingAttributeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The configuration to add user-defined properties to enrich MQTT 5 messages.

            :param propagating_attributes: An object that represents the connection attribute, the thing attribute, and the MQTT 5 user property key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-mqtt5configuration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                mqtt5_configuration_property = iot_mixins.CfnThingTypePropsMixin.Mqtt5ConfigurationProperty(
                    propagating_attributes=[iot_mixins.CfnThingTypePropsMixin.PropagatingAttributeProperty(
                        connection_attribute="connectionAttribute",
                        thing_attribute="thingAttribute",
                        user_property_key="userPropertyKey"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4f5533b21279300997b36bb5d029382173a433ece44eb5b394ca2e88b33c7b7d)
                check_type(argname="argument propagating_attributes", value=propagating_attributes, expected_type=type_hints["propagating_attributes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if propagating_attributes is not None:
                self._values["propagating_attributes"] = propagating_attributes

        @builtins.property
        def propagating_attributes(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingTypePropsMixin.PropagatingAttributeProperty"]]]]:
            '''An object that represents the connection attribute, the thing attribute, and the MQTT 5 user property key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-mqtt5configuration.html#cfn-iot-thingtype-mqtt5configuration-propagatingattributes
            '''
            result = self._values.get("propagating_attributes")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingTypePropsMixin.PropagatingAttributeProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Mqtt5ConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingTypePropsMixin.PropagatingAttributeProperty",
        jsii_struct_bases=[],
        name_mapping={
            "connection_attribute": "connectionAttribute",
            "thing_attribute": "thingAttribute",
            "user_property_key": "userPropertyKey",
        },
    )
    class PropagatingAttributeProperty:
        def __init__(
            self,
            *,
            connection_attribute: typing.Optional[builtins.str] = None,
            thing_attribute: typing.Optional[builtins.str] = None,
            user_property_key: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An object that represents the connection attribute, the thing attribute, and the MQTT 5 user property key.

            :param connection_attribute: The attribute associated with the connection details.
            :param thing_attribute: The thing attribute that is propagating for MQTT 5 message enrichment.
            :param user_property_key: The key of the MQTT 5 user property, which is a key-value pair.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-propagatingattribute.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                propagating_attribute_property = iot_mixins.CfnThingTypePropsMixin.PropagatingAttributeProperty(
                    connection_attribute="connectionAttribute",
                    thing_attribute="thingAttribute",
                    user_property_key="userPropertyKey"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__418bf25ed3a84beea84c0c22271fe26e39c513330abb08f9e584ca7cc1ce121c)
                check_type(argname="argument connection_attribute", value=connection_attribute, expected_type=type_hints["connection_attribute"])
                check_type(argname="argument thing_attribute", value=thing_attribute, expected_type=type_hints["thing_attribute"])
                check_type(argname="argument user_property_key", value=user_property_key, expected_type=type_hints["user_property_key"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if connection_attribute is not None:
                self._values["connection_attribute"] = connection_attribute
            if thing_attribute is not None:
                self._values["thing_attribute"] = thing_attribute
            if user_property_key is not None:
                self._values["user_property_key"] = user_property_key

        @builtins.property
        def connection_attribute(self) -> typing.Optional[builtins.str]:
            '''The attribute associated with the connection details.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-propagatingattribute.html#cfn-iot-thingtype-propagatingattribute-connectionattribute
            '''
            result = self._values.get("connection_attribute")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def thing_attribute(self) -> typing.Optional[builtins.str]:
            '''The thing attribute that is propagating for MQTT 5 message enrichment.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-propagatingattribute.html#cfn-iot-thingtype-propagatingattribute-thingattribute
            '''
            result = self._values.get("thing_attribute")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_property_key(self) -> typing.Optional[builtins.str]:
            '''The key of the MQTT 5 user property, which is a key-value pair.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-propagatingattribute.html#cfn-iot-thingtype-propagatingattribute-userpropertykey
            '''
            result = self._values.get("user_property_key")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PropagatingAttributeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnThingTypePropsMixin.ThingTypePropertiesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "mqtt5_configuration": "mqtt5Configuration",
            "searchable_attributes": "searchableAttributes",
            "thing_type_description": "thingTypeDescription",
        },
    )
    class ThingTypePropertiesProperty:
        def __init__(
            self,
            *,
            mqtt5_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnThingTypePropsMixin.Mqtt5ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            searchable_attributes: typing.Optional[typing.Sequence[builtins.str]] = None,
            thing_type_description: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ThingTypeProperties contains information about the thing type including: a thing type description, and a list of searchable thing attribute names.

            :param mqtt5_configuration: The configuration to add user-defined properties to enrich MQTT 5 messages.
            :param searchable_attributes: A list of searchable thing attribute names.
            :param thing_type_description: The description of the thing type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-thingtypeproperties.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                thing_type_properties_property = iot_mixins.CfnThingTypePropsMixin.ThingTypePropertiesProperty(
                    mqtt5_configuration=iot_mixins.CfnThingTypePropsMixin.Mqtt5ConfigurationProperty(
                        propagating_attributes=[iot_mixins.CfnThingTypePropsMixin.PropagatingAttributeProperty(
                            connection_attribute="connectionAttribute",
                            thing_attribute="thingAttribute",
                            user_property_key="userPropertyKey"
                        )]
                    ),
                    searchable_attributes=["searchableAttributes"],
                    thing_type_description="thingTypeDescription"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f0add793f003c490b2976bbc5055ad372ae3f3cdec82b02d13bec845f31515ae)
                check_type(argname="argument mqtt5_configuration", value=mqtt5_configuration, expected_type=type_hints["mqtt5_configuration"])
                check_type(argname="argument searchable_attributes", value=searchable_attributes, expected_type=type_hints["searchable_attributes"])
                check_type(argname="argument thing_type_description", value=thing_type_description, expected_type=type_hints["thing_type_description"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if mqtt5_configuration is not None:
                self._values["mqtt5_configuration"] = mqtt5_configuration
            if searchable_attributes is not None:
                self._values["searchable_attributes"] = searchable_attributes
            if thing_type_description is not None:
                self._values["thing_type_description"] = thing_type_description

        @builtins.property
        def mqtt5_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingTypePropsMixin.Mqtt5ConfigurationProperty"]]:
            '''The configuration to add user-defined properties to enrich MQTT 5 messages.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-thingtypeproperties.html#cfn-iot-thingtype-thingtypeproperties-mqtt5configuration
            '''
            result = self._values.get("mqtt5_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnThingTypePropsMixin.Mqtt5ConfigurationProperty"]], result)

        @builtins.property
        def searchable_attributes(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of searchable thing attribute names.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-thingtypeproperties.html#cfn-iot-thingtype-thingtypeproperties-searchableattributes
            '''
            result = self._values.get("searchable_attributes")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def thing_type_description(self) -> typing.Optional[builtins.str]:
            '''The description of the thing type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-thingtypeproperties.html#cfn-iot-thingtype-thingtypeproperties-thingtypedescription
            '''
            result = self._values.get("thing_type_description")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ThingTypePropertiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRuleDestinationMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "http_url_properties": "httpUrlProperties",
        "status": "status",
        "vpc_properties": "vpcProperties",
    },
)
class CfnTopicRuleDestinationMixinProps:
    def __init__(
        self,
        *,
        http_url_properties: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        status: typing.Optional[builtins.str] = None,
        vpc_properties: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnTopicRuleDestinationPropsMixin.

        :param http_url_properties: Properties of the HTTP URL.
        :param status: - **IN_PROGRESS** - A topic rule destination was created but has not been confirmed. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint. - **ENABLED** - Confirmation was completed, and traffic to this destination is allowed. You can set status to ``DISABLED`` by calling ``UpdateTopicRuleDestination`` . - **DISABLED** - Confirmation was completed, and traffic to this destination is not allowed. You can set status to ``ENABLED`` by calling ``UpdateTopicRuleDestination`` . - **ERROR** - Confirmation could not be completed; for example, if the confirmation timed out. You can call ``GetTopicRuleDestination`` for details about the error. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint.
        :param vpc_properties: Properties of the virtual private cloud (VPC) connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicruledestination.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_topic_rule_destination_mixin_props = iot_mixins.CfnTopicRuleDestinationMixinProps(
                http_url_properties=iot_mixins.CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty(
                    confirmation_url="confirmationUrl"
                ),
                status="status",
                vpc_properties=iot_mixins.CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty(
                    role_arn="roleArn",
                    security_groups=["securityGroups"],
                    subnet_ids=["subnetIds"],
                    vpc_id="vpcId"
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__142e1dd8cee9096451c2e8311c478c1ee5b7dc4440e82fd191b0a4cdd8ff0edf)
            check_type(argname="argument http_url_properties", value=http_url_properties, expected_type=type_hints["http_url_properties"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument vpc_properties", value=vpc_properties, expected_type=type_hints["vpc_properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if http_url_properties is not None:
            self._values["http_url_properties"] = http_url_properties
        if status is not None:
            self._values["status"] = status
        if vpc_properties is not None:
            self._values["vpc_properties"] = vpc_properties

    @builtins.property
    def http_url_properties(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty"]]:
        '''Properties of the HTTP URL.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicruledestination.html#cfn-iot-topicruledestination-httpurlproperties
        '''
        result = self._values.get("http_url_properties")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty"]], result)

    @builtins.property
    def status(self) -> typing.Optional[builtins.str]:
        '''- **IN_PROGRESS** - A topic rule destination was created but has not been confirmed.

        You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint.

        - **ENABLED** - Confirmation was completed, and traffic to this destination is allowed. You can set status to ``DISABLED`` by calling ``UpdateTopicRuleDestination`` .
        - **DISABLED** - Confirmation was completed, and traffic to this destination is not allowed. You can set status to ``ENABLED`` by calling ``UpdateTopicRuleDestination`` .
        - **ERROR** - Confirmation could not be completed; for example, if the confirmation timed out. You can call ``GetTopicRuleDestination`` for details about the error. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicruledestination.html#cfn-iot-topicruledestination-status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_properties(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty"]]:
        '''Properties of the virtual private cloud (VPC) connection.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicruledestination.html#cfn-iot-topicruledestination-vpcproperties
        '''
        result = self._values.get("vpc_properties")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTopicRuleDestinationMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTopicRuleDestinationPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRuleDestinationPropsMixin",
):
    '''A topic rule destination.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicruledestination.html
    :cloudformationResource: AWS::IoT::TopicRuleDestination
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_topic_rule_destination_props_mixin = iot_mixins.CfnTopicRuleDestinationPropsMixin(iot_mixins.CfnTopicRuleDestinationMixinProps(
            http_url_properties=iot_mixins.CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty(
                confirmation_url="confirmationUrl"
            ),
            status="status",
            vpc_properties=iot_mixins.CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty(
                role_arn="roleArn",
                security_groups=["securityGroups"],
                subnet_ids=["subnetIds"],
                vpc_id="vpcId"
            )
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTopicRuleDestinationMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::TopicRuleDestination``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5e8229c7d2c63ebfc0a38faecbe7cac8698cfb84e41f1b821936ab7263fae1a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc77aaeef64055a7a6cf205e76985374052d4c7168c634fab610a208af3575ce)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cc98ea4b399eac97cb4d53c8da21df62d4f673f4400e87052f92a02eafe8ed2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTopicRuleDestinationMixinProps":
        return typing.cast("CfnTopicRuleDestinationMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty",
        jsii_struct_bases=[],
        name_mapping={"confirmation_url": "confirmationUrl"},
    )
    class HttpUrlDestinationSummaryProperty:
        def __init__(
            self,
            *,
            confirmation_url: typing.Optional[builtins.str] = None,
        ) -> None:
            '''HTTP URL destination properties.

            :param confirmation_url: The URL used to confirm the HTTP topic rule destination URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-httpurldestinationsummary.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                http_url_destination_summary_property = iot_mixins.CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty(
                    confirmation_url="confirmationUrl"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__649cf4a70a1ad6dfbcb9f552d29ebbb6039251d318f30ebaf4a306efe25c30c1)
                check_type(argname="argument confirmation_url", value=confirmation_url, expected_type=type_hints["confirmation_url"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if confirmation_url is not None:
                self._values["confirmation_url"] = confirmation_url

        @builtins.property
        def confirmation_url(self) -> typing.Optional[builtins.str]:
            '''The URL used to confirm the HTTP topic rule destination URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-httpurldestinationsummary.html#cfn-iot-topicruledestination-httpurldestinationsummary-confirmationurl
            '''
            result = self._values.get("confirmation_url")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HttpUrlDestinationSummaryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "role_arn": "roleArn",
            "security_groups": "securityGroups",
            "subnet_ids": "subnetIds",
            "vpc_id": "vpcId",
        },
    )
    class VpcDestinationPropertiesProperty:
        def __init__(
            self,
            *,
            role_arn: typing.Optional[builtins.str] = None,
            security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
            vpc_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The properties of a virtual private cloud (VPC) destination.

            :param role_arn: The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
            :param security_groups: The security groups of the VPC destination.
            :param subnet_ids: The subnet IDs of the VPC destination.
            :param vpc_id: The ID of the VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-vpcdestinationproperties.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                vpc_destination_properties_property = iot_mixins.CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty(
                    role_arn="roleArn",
                    security_groups=["securityGroups"],
                    subnet_ids=["subnetIds"],
                    vpc_id="vpcId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9c4d501bc7a2c98ead89de76d6780a8543eba359902cd6c56245573fa2848320)
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
                check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
                check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if subnet_ids is not None:
                self._values["subnet_ids"] = subnet_ids
            if vpc_id is not None:
                self._values["vpc_id"] = vpc_id

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-vpcdestinationproperties.html#cfn-iot-topicruledestination-vpcdestinationproperties-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The security groups of the VPC destination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-vpcdestinationproperties.html#cfn-iot-topicruledestination-vpcdestinationproperties-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The subnet IDs of the VPC destination.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-vpcdestinationproperties.html#cfn-iot-topicruledestination-vpcdestinationproperties-subnetids
            '''
            result = self._values.get("subnet_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def vpc_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the VPC.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-vpcdestinationproperties.html#cfn-iot-topicruledestination-vpcdestinationproperties-vpcid
            '''
            result = self._values.get("vpc_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VpcDestinationPropertiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRuleMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "rule_name": "ruleName",
        "tags": "tags",
        "topic_rule_payload": "topicRulePayload",
    },
)
class CfnTopicRuleMixinProps:
    def __init__(
        self,
        *,
        rule_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        topic_rule_payload: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.TopicRulePayloadProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnTopicRulePropsMixin.

        :param rule_name: The name of the rule.
        :param tags: Metadata which can be used to manage the topic rule. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
        :param topic_rule_payload: The rule payload.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicrule.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
            
            cfn_topic_rule_mixin_props = iot_mixins.CfnTopicRuleMixinProps(
                rule_name="ruleName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                topic_rule_payload=iot_mixins.CfnTopicRulePropsMixin.TopicRulePayloadProperty(
                    actions=[iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                        cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                            alarm_name="alarmName",
                            role_arn="roleArn",
                            state_reason="stateReason",
                            state_value="stateValue"
                        ),
                        cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                            batch_mode=False,
                            log_group_name="logGroupName",
                            role_arn="roleArn"
                        ),
                        cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                            metric_name="metricName",
                            metric_namespace="metricNamespace",
                            metric_timestamp="metricTimestamp",
                            metric_unit="metricUnit",
                            metric_value="metricValue",
                            role_arn="roleArn"
                        ),
                        dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                            hash_key_field="hashKeyField",
                            hash_key_type="hashKeyType",
                            hash_key_value="hashKeyValue",
                            payload_field="payloadField",
                            range_key_field="rangeKeyField",
                            range_key_type="rangeKeyType",
                            range_key_value="rangeKeyValue",
                            role_arn="roleArn",
                            table_name="tableName"
                        ),
                        dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                            put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                                table_name="tableName"
                            ),
                            role_arn="roleArn"
                        ),
                        elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                            batch_mode=False,
                            delivery_stream_name="deliveryStreamName",
                            role_arn="roleArn",
                            separator="separator"
                        ),
                        http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                            auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                                sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                    role_arn="roleArn",
                                    service_name="serviceName",
                                    signing_region="signingRegion"
                                )
                            ),
                            batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                                max_batch_open_ms=123,
                                max_batch_size=123,
                                max_batch_size_bytes=123
                            ),
                            confirmation_url="confirmationUrl",
                            enable_batching=False,
                            headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            url="url"
                        ),
                        iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                            batch_mode=False,
                            channel_name="channelName",
                            role_arn="roleArn"
                        ),
                        iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                            batch_mode=False,
                            input_name="inputName",
                            message_id="messageId",
                            role_arn="roleArn"
                        ),
                        iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                            put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                                asset_id="assetId",
                                entry_id="entryId",
                                property_alias="propertyAlias",
                                property_id="propertyId",
                                property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                    quality="quality",
                                    timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                        offset_in_nanos="offsetInNanos",
                                        time_in_seconds="timeInSeconds"
                                    ),
                                    value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                        boolean_value="booleanValue",
                                        double_value="doubleValue",
                                        integer_value="integerValue",
                                        string_value="stringValue"
                                    )
                                )]
                            )],
                            role_arn="roleArn"
                        ),
                        kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                            client_properties={
                                "client_properties_key": "clientProperties"
                            },
                            destination_arn="destinationArn",
                            headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            key="key",
                            partition="partition",
                            topic="topic"
                        ),
                        kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                            partition_key="partitionKey",
                            role_arn="roleArn",
                            stream_name="streamName"
                        ),
                        lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                            function_arn="functionArn"
                        ),
                        location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                            device_id="deviceId",
                            latitude="latitude",
                            longitude="longitude",
                            role_arn="roleArn",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                                unit="unit",
                                value="value"
                            ),
                            tracker_name="trackerName"
                        ),
                        open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                            headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                                content_type="contentType",
                                correlation_data="correlationData",
                                message_expiry="messageExpiry",
                                payload_format_indicator="payloadFormatIndicator",
                                response_topic="responseTopic",
                                user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                    key="key",
                                    value="value"
                                )]
                            ),
                            qos=123,
                            role_arn="roleArn",
                            topic="topic"
                        ),
                        s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                            bucket_name="bucketName",
                            canned_acl="cannedAcl",
                            key="key",
                            role_arn="roleArn"
                        ),
                        sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                            message_format="messageFormat",
                            role_arn="roleArn",
                            target_arn="targetArn"
                        ),
                        sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                            queue_url="queueUrl",
                            role_arn="roleArn",
                            use_base64=False
                        ),
                        step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                            execution_name_prefix="executionNamePrefix",
                            role_arn="roleArn",
                            state_machine_name="stateMachineName"
                        ),
                        timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                            database_name="databaseName",
                            dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                                name="name",
                                value="value"
                            )],
                            role_arn="roleArn",
                            table_name="tableName",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                                unit="unit",
                                value="value"
                            )
                        )
                    )],
                    aws_iot_sql_version="awsIotSqlVersion",
                    description="description",
                    error_action=iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                        cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                            alarm_name="alarmName",
                            role_arn="roleArn",
                            state_reason="stateReason",
                            state_value="stateValue"
                        ),
                        cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                            batch_mode=False,
                            log_group_name="logGroupName",
                            role_arn="roleArn"
                        ),
                        cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                            metric_name="metricName",
                            metric_namespace="metricNamespace",
                            metric_timestamp="metricTimestamp",
                            metric_unit="metricUnit",
                            metric_value="metricValue",
                            role_arn="roleArn"
                        ),
                        dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                            hash_key_field="hashKeyField",
                            hash_key_type="hashKeyType",
                            hash_key_value="hashKeyValue",
                            payload_field="payloadField",
                            range_key_field="rangeKeyField",
                            range_key_type="rangeKeyType",
                            range_key_value="rangeKeyValue",
                            role_arn="roleArn",
                            table_name="tableName"
                        ),
                        dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                            put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                                table_name="tableName"
                            ),
                            role_arn="roleArn"
                        ),
                        elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                            batch_mode=False,
                            delivery_stream_name="deliveryStreamName",
                            role_arn="roleArn",
                            separator="separator"
                        ),
                        http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                            auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                                sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                    role_arn="roleArn",
                                    service_name="serviceName",
                                    signing_region="signingRegion"
                                )
                            ),
                            batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                                max_batch_open_ms=123,
                                max_batch_size=123,
                                max_batch_size_bytes=123
                            ),
                            confirmation_url="confirmationUrl",
                            enable_batching=False,
                            headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            url="url"
                        ),
                        iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                            batch_mode=False,
                            channel_name="channelName",
                            role_arn="roleArn"
                        ),
                        iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                            batch_mode=False,
                            input_name="inputName",
                            message_id="messageId",
                            role_arn="roleArn"
                        ),
                        iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                            put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                                asset_id="assetId",
                                entry_id="entryId",
                                property_alias="propertyAlias",
                                property_id="propertyId",
                                property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                    quality="quality",
                                    timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                        offset_in_nanos="offsetInNanos",
                                        time_in_seconds="timeInSeconds"
                                    ),
                                    value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                        boolean_value="booleanValue",
                                        double_value="doubleValue",
                                        integer_value="integerValue",
                                        string_value="stringValue"
                                    )
                                )]
                            )],
                            role_arn="roleArn"
                        ),
                        kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                            client_properties={
                                "client_properties_key": "clientProperties"
                            },
                            destination_arn="destinationArn",
                            headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            key="key",
                            partition="partition",
                            topic="topic"
                        ),
                        kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                            partition_key="partitionKey",
                            role_arn="roleArn",
                            stream_name="streamName"
                        ),
                        lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                            function_arn="functionArn"
                        ),
                        location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                            device_id="deviceId",
                            latitude="latitude",
                            longitude="longitude",
                            role_arn="roleArn",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                                unit="unit",
                                value="value"
                            ),
                            tracker_name="trackerName"
                        ),
                        open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                            headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                                content_type="contentType",
                                correlation_data="correlationData",
                                message_expiry="messageExpiry",
                                payload_format_indicator="payloadFormatIndicator",
                                response_topic="responseTopic",
                                user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                    key="key",
                                    value="value"
                                )]
                            ),
                            qos=123,
                            role_arn="roleArn",
                            topic="topic"
                        ),
                        s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                            bucket_name="bucketName",
                            canned_acl="cannedAcl",
                            key="key",
                            role_arn="roleArn"
                        ),
                        sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                            message_format="messageFormat",
                            role_arn="roleArn",
                            target_arn="targetArn"
                        ),
                        sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                            queue_url="queueUrl",
                            role_arn="roleArn",
                            use_base64=False
                        ),
                        step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                            execution_name_prefix="executionNamePrefix",
                            role_arn="roleArn",
                            state_machine_name="stateMachineName"
                        ),
                        timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                            database_name="databaseName",
                            dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                                name="name",
                                value="value"
                            )],
                            role_arn="roleArn",
                            table_name="tableName",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                                unit="unit",
                                value="value"
                            )
                        )
                    ),
                    rule_disabled=False,
                    sql="sql"
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5da12e161858141e3f8888dc93a17cd539d06aec7bc3691f4471e0a82e12922)
            check_type(argname="argument rule_name", value=rule_name, expected_type=type_hints["rule_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument topic_rule_payload", value=topic_rule_payload, expected_type=type_hints["topic_rule_payload"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rule_name is not None:
            self._values["rule_name"] = rule_name
        if tags is not None:
            self._values["tags"] = tags
        if topic_rule_payload is not None:
            self._values["topic_rule_payload"] = topic_rule_payload

    @builtins.property
    def rule_name(self) -> typing.Optional[builtins.str]:
        '''The name of the rule.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicrule.html#cfn-iot-topicrule-rulename
        '''
        result = self._values.get("rule_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''Metadata which can be used to manage the topic rule.

        .. epigraph::

           For URI Request parameters use format: ...key1=value1&key2=value2...

           For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..."

           For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicrule.html#cfn-iot-topicrule-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def topic_rule_payload(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TopicRulePayloadProperty"]]:
        '''The rule payload.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicrule.html#cfn-iot-topicrule-topicrulepayload
        '''
        result = self._values.get("topic_rule_payload")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TopicRulePayloadProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTopicRuleMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnTopicRulePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin",
):
    '''Use the ``AWS::IoT::TopicRule`` resource to declare an AWS IoT rule.

    For information about working with AWS IoT rules, see `Rules for AWS IoT <https://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html>`_ in the *AWS IoT Developer Guide* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicrule.html
    :cloudformationResource: AWS::IoT::TopicRule
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
        
        cfn_topic_rule_props_mixin = iot_mixins.CfnTopicRulePropsMixin(iot_mixins.CfnTopicRuleMixinProps(
            rule_name="ruleName",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            topic_rule_payload=iot_mixins.CfnTopicRulePropsMixin.TopicRulePayloadProperty(
                actions=[iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                    cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                        alarm_name="alarmName",
                        role_arn="roleArn",
                        state_reason="stateReason",
                        state_value="stateValue"
                    ),
                    cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                        batch_mode=False,
                        log_group_name="logGroupName",
                        role_arn="roleArn"
                    ),
                    cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                        metric_name="metricName",
                        metric_namespace="metricNamespace",
                        metric_timestamp="metricTimestamp",
                        metric_unit="metricUnit",
                        metric_value="metricValue",
                        role_arn="roleArn"
                    ),
                    dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                        hash_key_field="hashKeyField",
                        hash_key_type="hashKeyType",
                        hash_key_value="hashKeyValue",
                        payload_field="payloadField",
                        range_key_field="rangeKeyField",
                        range_key_type="rangeKeyType",
                        range_key_value="rangeKeyValue",
                        role_arn="roleArn",
                        table_name="tableName"
                    ),
                    dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                        put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                            table_name="tableName"
                        ),
                        role_arn="roleArn"
                    ),
                    elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                        endpoint="endpoint",
                        id="id",
                        index="index",
                        role_arn="roleArn",
                        type="type"
                    ),
                    firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                        batch_mode=False,
                        delivery_stream_name="deliveryStreamName",
                        role_arn="roleArn",
                        separator="separator"
                    ),
                    http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                        auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                            sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                role_arn="roleArn",
                                service_name="serviceName",
                                signing_region="signingRegion"
                            )
                        ),
                        batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                            max_batch_open_ms=123,
                            max_batch_size=123,
                            max_batch_size_bytes=123
                        ),
                        confirmation_url="confirmationUrl",
                        enable_batching=False,
                        headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                            key="key",
                            value="value"
                        )],
                        url="url"
                    ),
                    iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                        batch_mode=False,
                        channel_name="channelName",
                        role_arn="roleArn"
                    ),
                    iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                        batch_mode=False,
                        input_name="inputName",
                        message_id="messageId",
                        role_arn="roleArn"
                    ),
                    iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                        put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                            asset_id="assetId",
                            entry_id="entryId",
                            property_alias="propertyAlias",
                            property_id="propertyId",
                            property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                quality="quality",
                                timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                    offset_in_nanos="offsetInNanos",
                                    time_in_seconds="timeInSeconds"
                                ),
                                value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                    boolean_value="booleanValue",
                                    double_value="doubleValue",
                                    integer_value="integerValue",
                                    string_value="stringValue"
                                )
                            )]
                        )],
                        role_arn="roleArn"
                    ),
                    kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                        client_properties={
                            "client_properties_key": "clientProperties"
                        },
                        destination_arn="destinationArn",
                        headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                            key="key",
                            value="value"
                        )],
                        key="key",
                        partition="partition",
                        topic="topic"
                    ),
                    kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                        partition_key="partitionKey",
                        role_arn="roleArn",
                        stream_name="streamName"
                    ),
                    lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                        function_arn="functionArn"
                    ),
                    location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                        device_id="deviceId",
                        latitude="latitude",
                        longitude="longitude",
                        role_arn="roleArn",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                            unit="unit",
                            value="value"
                        ),
                        tracker_name="trackerName"
                    ),
                    open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                        endpoint="endpoint",
                        id="id",
                        index="index",
                        role_arn="roleArn",
                        type="type"
                    ),
                    republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                        headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                            content_type="contentType",
                            correlation_data="correlationData",
                            message_expiry="messageExpiry",
                            payload_format_indicator="payloadFormatIndicator",
                            response_topic="responseTopic",
                            user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                key="key",
                                value="value"
                            )]
                        ),
                        qos=123,
                        role_arn="roleArn",
                        topic="topic"
                    ),
                    s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                        bucket_name="bucketName",
                        canned_acl="cannedAcl",
                        key="key",
                        role_arn="roleArn"
                    ),
                    sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                        message_format="messageFormat",
                        role_arn="roleArn",
                        target_arn="targetArn"
                    ),
                    sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                        queue_url="queueUrl",
                        role_arn="roleArn",
                        use_base64=False
                    ),
                    step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                        execution_name_prefix="executionNamePrefix",
                        role_arn="roleArn",
                        state_machine_name="stateMachineName"
                    ),
                    timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                        database_name="databaseName",
                        dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                            name="name",
                            value="value"
                        )],
                        role_arn="roleArn",
                        table_name="tableName",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                            unit="unit",
                            value="value"
                        )
                    )
                )],
                aws_iot_sql_version="awsIotSqlVersion",
                description="description",
                error_action=iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                    cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                        alarm_name="alarmName",
                        role_arn="roleArn",
                        state_reason="stateReason",
                        state_value="stateValue"
                    ),
                    cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                        batch_mode=False,
                        log_group_name="logGroupName",
                        role_arn="roleArn"
                    ),
                    cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                        metric_name="metricName",
                        metric_namespace="metricNamespace",
                        metric_timestamp="metricTimestamp",
                        metric_unit="metricUnit",
                        metric_value="metricValue",
                        role_arn="roleArn"
                    ),
                    dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                        hash_key_field="hashKeyField",
                        hash_key_type="hashKeyType",
                        hash_key_value="hashKeyValue",
                        payload_field="payloadField",
                        range_key_field="rangeKeyField",
                        range_key_type="rangeKeyType",
                        range_key_value="rangeKeyValue",
                        role_arn="roleArn",
                        table_name="tableName"
                    ),
                    dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                        put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                            table_name="tableName"
                        ),
                        role_arn="roleArn"
                    ),
                    elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                        endpoint="endpoint",
                        id="id",
                        index="index",
                        role_arn="roleArn",
                        type="type"
                    ),
                    firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                        batch_mode=False,
                        delivery_stream_name="deliveryStreamName",
                        role_arn="roleArn",
                        separator="separator"
                    ),
                    http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                        auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                            sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                role_arn="roleArn",
                                service_name="serviceName",
                                signing_region="signingRegion"
                            )
                        ),
                        batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                            max_batch_open_ms=123,
                            max_batch_size=123,
                            max_batch_size_bytes=123
                        ),
                        confirmation_url="confirmationUrl",
                        enable_batching=False,
                        headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                            key="key",
                            value="value"
                        )],
                        url="url"
                    ),
                    iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                        batch_mode=False,
                        channel_name="channelName",
                        role_arn="roleArn"
                    ),
                    iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                        batch_mode=False,
                        input_name="inputName",
                        message_id="messageId",
                        role_arn="roleArn"
                    ),
                    iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                        put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                            asset_id="assetId",
                            entry_id="entryId",
                            property_alias="propertyAlias",
                            property_id="propertyId",
                            property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                quality="quality",
                                timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                    offset_in_nanos="offsetInNanos",
                                    time_in_seconds="timeInSeconds"
                                ),
                                value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                    boolean_value="booleanValue",
                                    double_value="doubleValue",
                                    integer_value="integerValue",
                                    string_value="stringValue"
                                )
                            )]
                        )],
                        role_arn="roleArn"
                    ),
                    kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                        client_properties={
                            "client_properties_key": "clientProperties"
                        },
                        destination_arn="destinationArn",
                        headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                            key="key",
                            value="value"
                        )],
                        key="key",
                        partition="partition",
                        topic="topic"
                    ),
                    kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                        partition_key="partitionKey",
                        role_arn="roleArn",
                        stream_name="streamName"
                    ),
                    lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                        function_arn="functionArn"
                    ),
                    location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                        device_id="deviceId",
                        latitude="latitude",
                        longitude="longitude",
                        role_arn="roleArn",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                            unit="unit",
                            value="value"
                        ),
                        tracker_name="trackerName"
                    ),
                    open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                        endpoint="endpoint",
                        id="id",
                        index="index",
                        role_arn="roleArn",
                        type="type"
                    ),
                    republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                        headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                            content_type="contentType",
                            correlation_data="correlationData",
                            message_expiry="messageExpiry",
                            payload_format_indicator="payloadFormatIndicator",
                            response_topic="responseTopic",
                            user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                key="key",
                                value="value"
                            )]
                        ),
                        qos=123,
                        role_arn="roleArn",
                        topic="topic"
                    ),
                    s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                        bucket_name="bucketName",
                        canned_acl="cannedAcl",
                        key="key",
                        role_arn="roleArn"
                    ),
                    sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                        message_format="messageFormat",
                        role_arn="roleArn",
                        target_arn="targetArn"
                    ),
                    sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                        queue_url="queueUrl",
                        role_arn="roleArn",
                        use_base64=False
                    ),
                    step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                        execution_name_prefix="executionNamePrefix",
                        role_arn="roleArn",
                        state_machine_name="stateMachineName"
                    ),
                    timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                        database_name="databaseName",
                        dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                            name="name",
                            value="value"
                        )],
                        role_arn="roleArn",
                        table_name="tableName",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                            unit="unit",
                            value="value"
                        )
                    )
                ),
                rule_disabled=False,
                sql="sql"
            )
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnTopicRuleMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::IoT::TopicRule``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5a3fcaa917c6ab265e5b5219bf547f60c85bfcc5b609f690a8bad7f3de1bddc)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c65269687955e541ede51c52c9d136c4bd0177b6f2ced9477f280a5ab4c5345)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21714536c75a963eb607909855450fb7025545c86173425067e0d029b34a2d8b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnTopicRuleMixinProps":
        return typing.cast("CfnTopicRuleMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.ActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cloudwatch_alarm": "cloudwatchAlarm",
            "cloudwatch_logs": "cloudwatchLogs",
            "cloudwatch_metric": "cloudwatchMetric",
            "dynamo_db": "dynamoDb",
            "dynamo_d_bv2": "dynamoDBv2",
            "elasticsearch": "elasticsearch",
            "firehose": "firehose",
            "http": "http",
            "iot_analytics": "iotAnalytics",
            "iot_events": "iotEvents",
            "iot_site_wise": "iotSiteWise",
            "kafka": "kafka",
            "kinesis": "kinesis",
            "lambda_": "lambda",
            "location": "location",
            "open_search": "openSearch",
            "republish": "republish",
            "s3": "s3",
            "sns": "sns",
            "sqs": "sqs",
            "step_functions": "stepFunctions",
            "timestream": "timestream",
        },
    )
    class ActionProperty:
        def __init__(
            self,
            *,
            cloudwatch_alarm: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            cloudwatch_logs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.CloudwatchLogsActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            cloudwatch_metric: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.CloudwatchMetricActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            dynamo_db: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.DynamoDBActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            dynamo_d_bv2: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.DynamoDBv2ActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            elasticsearch: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.ElasticsearchActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            firehose: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.FirehoseActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            http: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.HttpActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iot_analytics: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.IotAnalyticsActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iot_events: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.IotEventsActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            iot_site_wise: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.IotSiteWiseActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            kafka: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.KafkaActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            kinesis: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.KinesisActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            lambda_: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.LambdaActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.LocationActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            open_search: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.OpenSearchActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            republish: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.RepublishActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.S3ActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sns: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.SnsActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sqs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.SqsActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            step_functions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.StepFunctionsActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            timestream: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.TimestreamActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes the actions associated with a rule.

            :param cloudwatch_alarm: Change the state of a CloudWatch alarm.
            :param cloudwatch_logs: Sends data to CloudWatch.
            :param cloudwatch_metric: Capture a CloudWatch metric.
            :param dynamo_db: Write to a DynamoDB table.
            :param dynamo_d_bv2: Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
            :param elasticsearch: Write data to an Amazon OpenSearch Service domain. .. epigraph:: The ``Elasticsearch`` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the ``OpenSearch`` rule action instead. For more information, see `OpenSearchAction <https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html>`_ .
            :param firehose: Write to an Amazon Kinesis Firehose stream.
            :param http: Send data to an HTTPS endpoint.
            :param iot_analytics: Sends message data to an AWS IoT Analytics channel.
            :param iot_events: Sends an input to an AWS IoT Events detector.
            :param iot_site_wise: Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.
            :param kafka: Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
            :param kinesis: Write data to an Amazon Kinesis stream.
            :param lambda_: Invoke a Lambda function.
            :param location: Sends device location data to `Amazon Location Service <https://docs.aws.amazon.com//location/latest/developerguide/welcome.html>`_ .
            :param open_search: Write data to an Amazon OpenSearch Service domain.
            :param republish: Publish to another MQTT topic.
            :param s3: Write to an Amazon S3 bucket.
            :param sns: Publish to an Amazon SNS topic.
            :param sqs: Publish to an Amazon SQS queue.
            :param step_functions: Starts execution of a Step Functions state machine.
            :param timestream: Writes attributes from an MQTT message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                action_property = iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                    cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                        alarm_name="alarmName",
                        role_arn="roleArn",
                        state_reason="stateReason",
                        state_value="stateValue"
                    ),
                    cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                        batch_mode=False,
                        log_group_name="logGroupName",
                        role_arn="roleArn"
                    ),
                    cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                        metric_name="metricName",
                        metric_namespace="metricNamespace",
                        metric_timestamp="metricTimestamp",
                        metric_unit="metricUnit",
                        metric_value="metricValue",
                        role_arn="roleArn"
                    ),
                    dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                        hash_key_field="hashKeyField",
                        hash_key_type="hashKeyType",
                        hash_key_value="hashKeyValue",
                        payload_field="payloadField",
                        range_key_field="rangeKeyField",
                        range_key_type="rangeKeyType",
                        range_key_value="rangeKeyValue",
                        role_arn="roleArn",
                        table_name="tableName"
                    ),
                    dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                        put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                            table_name="tableName"
                        ),
                        role_arn="roleArn"
                    ),
                    elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                        endpoint="endpoint",
                        id="id",
                        index="index",
                        role_arn="roleArn",
                        type="type"
                    ),
                    firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                        batch_mode=False,
                        delivery_stream_name="deliveryStreamName",
                        role_arn="roleArn",
                        separator="separator"
                    ),
                    http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                        auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                            sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                role_arn="roleArn",
                                service_name="serviceName",
                                signing_region="signingRegion"
                            )
                        ),
                        batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                            max_batch_open_ms=123,
                            max_batch_size=123,
                            max_batch_size_bytes=123
                        ),
                        confirmation_url="confirmationUrl",
                        enable_batching=False,
                        headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                            key="key",
                            value="value"
                        )],
                        url="url"
                    ),
                    iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                        batch_mode=False,
                        channel_name="channelName",
                        role_arn="roleArn"
                    ),
                    iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                        batch_mode=False,
                        input_name="inputName",
                        message_id="messageId",
                        role_arn="roleArn"
                    ),
                    iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                        put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                            asset_id="assetId",
                            entry_id="entryId",
                            property_alias="propertyAlias",
                            property_id="propertyId",
                            property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                quality="quality",
                                timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                    offset_in_nanos="offsetInNanos",
                                    time_in_seconds="timeInSeconds"
                                ),
                                value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                    boolean_value="booleanValue",
                                    double_value="doubleValue",
                                    integer_value="integerValue",
                                    string_value="stringValue"
                                )
                            )]
                        )],
                        role_arn="roleArn"
                    ),
                    kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                        client_properties={
                            "client_properties_key": "clientProperties"
                        },
                        destination_arn="destinationArn",
                        headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                            key="key",
                            value="value"
                        )],
                        key="key",
                        partition="partition",
                        topic="topic"
                    ),
                    kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                        partition_key="partitionKey",
                        role_arn="roleArn",
                        stream_name="streamName"
                    ),
                    lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                        function_arn="functionArn"
                    ),
                    location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                        device_id="deviceId",
                        latitude="latitude",
                        longitude="longitude",
                        role_arn="roleArn",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                            unit="unit",
                            value="value"
                        ),
                        tracker_name="trackerName"
                    ),
                    open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                        endpoint="endpoint",
                        id="id",
                        index="index",
                        role_arn="roleArn",
                        type="type"
                    ),
                    republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                        headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                            content_type="contentType",
                            correlation_data="correlationData",
                            message_expiry="messageExpiry",
                            payload_format_indicator="payloadFormatIndicator",
                            response_topic="responseTopic",
                            user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                key="key",
                                value="value"
                            )]
                        ),
                        qos=123,
                        role_arn="roleArn",
                        topic="topic"
                    ),
                    s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                        bucket_name="bucketName",
                        canned_acl="cannedAcl",
                        key="key",
                        role_arn="roleArn"
                    ),
                    sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                        message_format="messageFormat",
                        role_arn="roleArn",
                        target_arn="targetArn"
                    ),
                    sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                        queue_url="queueUrl",
                        role_arn="roleArn",
                        use_base64=False
                    ),
                    step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                        execution_name_prefix="executionNamePrefix",
                        role_arn="roleArn",
                        state_machine_name="stateMachineName"
                    ),
                    timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                        database_name="databaseName",
                        dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                            name="name",
                            value="value"
                        )],
                        role_arn="roleArn",
                        table_name="tableName",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                            unit="unit",
                            value="value"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a4250961d0f728dd42397adf406587879400eeb803ec820466043e341062fee9)
                check_type(argname="argument cloudwatch_alarm", value=cloudwatch_alarm, expected_type=type_hints["cloudwatch_alarm"])
                check_type(argname="argument cloudwatch_logs", value=cloudwatch_logs, expected_type=type_hints["cloudwatch_logs"])
                check_type(argname="argument cloudwatch_metric", value=cloudwatch_metric, expected_type=type_hints["cloudwatch_metric"])
                check_type(argname="argument dynamo_db", value=dynamo_db, expected_type=type_hints["dynamo_db"])
                check_type(argname="argument dynamo_d_bv2", value=dynamo_d_bv2, expected_type=type_hints["dynamo_d_bv2"])
                check_type(argname="argument elasticsearch", value=elasticsearch, expected_type=type_hints["elasticsearch"])
                check_type(argname="argument firehose", value=firehose, expected_type=type_hints["firehose"])
                check_type(argname="argument http", value=http, expected_type=type_hints["http"])
                check_type(argname="argument iot_analytics", value=iot_analytics, expected_type=type_hints["iot_analytics"])
                check_type(argname="argument iot_events", value=iot_events, expected_type=type_hints["iot_events"])
                check_type(argname="argument iot_site_wise", value=iot_site_wise, expected_type=type_hints["iot_site_wise"])
                check_type(argname="argument kafka", value=kafka, expected_type=type_hints["kafka"])
                check_type(argname="argument kinesis", value=kinesis, expected_type=type_hints["kinesis"])
                check_type(argname="argument lambda_", value=lambda_, expected_type=type_hints["lambda_"])
                check_type(argname="argument location", value=location, expected_type=type_hints["location"])
                check_type(argname="argument open_search", value=open_search, expected_type=type_hints["open_search"])
                check_type(argname="argument republish", value=republish, expected_type=type_hints["republish"])
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
                check_type(argname="argument sns", value=sns, expected_type=type_hints["sns"])
                check_type(argname="argument sqs", value=sqs, expected_type=type_hints["sqs"])
                check_type(argname="argument step_functions", value=step_functions, expected_type=type_hints["step_functions"])
                check_type(argname="argument timestream", value=timestream, expected_type=type_hints["timestream"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cloudwatch_alarm is not None:
                self._values["cloudwatch_alarm"] = cloudwatch_alarm
            if cloudwatch_logs is not None:
                self._values["cloudwatch_logs"] = cloudwatch_logs
            if cloudwatch_metric is not None:
                self._values["cloudwatch_metric"] = cloudwatch_metric
            if dynamo_db is not None:
                self._values["dynamo_db"] = dynamo_db
            if dynamo_d_bv2 is not None:
                self._values["dynamo_d_bv2"] = dynamo_d_bv2
            if elasticsearch is not None:
                self._values["elasticsearch"] = elasticsearch
            if firehose is not None:
                self._values["firehose"] = firehose
            if http is not None:
                self._values["http"] = http
            if iot_analytics is not None:
                self._values["iot_analytics"] = iot_analytics
            if iot_events is not None:
                self._values["iot_events"] = iot_events
            if iot_site_wise is not None:
                self._values["iot_site_wise"] = iot_site_wise
            if kafka is not None:
                self._values["kafka"] = kafka
            if kinesis is not None:
                self._values["kinesis"] = kinesis
            if lambda_ is not None:
                self._values["lambda_"] = lambda_
            if location is not None:
                self._values["location"] = location
            if open_search is not None:
                self._values["open_search"] = open_search
            if republish is not None:
                self._values["republish"] = republish
            if s3 is not None:
                self._values["s3"] = s3
            if sns is not None:
                self._values["sns"] = sns
            if sqs is not None:
                self._values["sqs"] = sqs
            if step_functions is not None:
                self._values["step_functions"] = step_functions
            if timestream is not None:
                self._values["timestream"] = timestream

        @builtins.property
        def cloudwatch_alarm(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty"]]:
            '''Change the state of a CloudWatch alarm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-cloudwatchalarm
            '''
            result = self._values.get("cloudwatch_alarm")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty"]], result)

        @builtins.property
        def cloudwatch_logs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.CloudwatchLogsActionProperty"]]:
            '''Sends data to CloudWatch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-cloudwatchlogs
            '''
            result = self._values.get("cloudwatch_logs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.CloudwatchLogsActionProperty"]], result)

        @builtins.property
        def cloudwatch_metric(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.CloudwatchMetricActionProperty"]]:
            '''Capture a CloudWatch metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-cloudwatchmetric
            '''
            result = self._values.get("cloudwatch_metric")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.CloudwatchMetricActionProperty"]], result)

        @builtins.property
        def dynamo_db(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.DynamoDBActionProperty"]]:
            '''Write to a DynamoDB table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-dynamodb
            '''
            result = self._values.get("dynamo_db")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.DynamoDBActionProperty"]], result)

        @builtins.property
        def dynamo_d_bv2(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.DynamoDBv2ActionProperty"]]:
            '''Write to a DynamoDB table.

            This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-dynamodbv2
            '''
            result = self._values.get("dynamo_d_bv2")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.DynamoDBv2ActionProperty"]], result)

        @builtins.property
        def elasticsearch(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.ElasticsearchActionProperty"]]:
            '''Write data to an Amazon OpenSearch Service domain.

            .. epigraph::

               The ``Elasticsearch`` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the ``OpenSearch`` rule action instead. For more information, see `OpenSearchAction <https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-elasticsearch
            '''
            result = self._values.get("elasticsearch")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.ElasticsearchActionProperty"]], result)

        @builtins.property
        def firehose(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.FirehoseActionProperty"]]:
            '''Write to an Amazon Kinesis Firehose stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-firehose
            '''
            result = self._values.get("firehose")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.FirehoseActionProperty"]], result)

        @builtins.property
        def http(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.HttpActionProperty"]]:
            '''Send data to an HTTPS endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-http
            '''
            result = self._values.get("http")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.HttpActionProperty"]], result)

        @builtins.property
        def iot_analytics(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.IotAnalyticsActionProperty"]]:
            '''Sends message data to an AWS IoT Analytics channel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-iotanalytics
            '''
            result = self._values.get("iot_analytics")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.IotAnalyticsActionProperty"]], result)

        @builtins.property
        def iot_events(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.IotEventsActionProperty"]]:
            '''Sends an input to an AWS IoT Events detector.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-iotevents
            '''
            result = self._values.get("iot_events")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.IotEventsActionProperty"]], result)

        @builtins.property
        def iot_site_wise(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.IotSiteWiseActionProperty"]]:
            '''Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-iotsitewise
            '''
            result = self._values.get("iot_site_wise")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.IotSiteWiseActionProperty"]], result)

        @builtins.property
        def kafka(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.KafkaActionProperty"]]:
            '''Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-kafka
            '''
            result = self._values.get("kafka")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.KafkaActionProperty"]], result)

        @builtins.property
        def kinesis(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.KinesisActionProperty"]]:
            '''Write data to an Amazon Kinesis stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-kinesis
            '''
            result = self._values.get("kinesis")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.KinesisActionProperty"]], result)

        @builtins.property
        def lambda_(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.LambdaActionProperty"]]:
            '''Invoke a Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-lambda
            '''
            result = self._values.get("lambda_")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.LambdaActionProperty"]], result)

        @builtins.property
        def location(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.LocationActionProperty"]]:
            '''Sends device location data to `Amazon Location Service <https://docs.aws.amazon.com//location/latest/developerguide/welcome.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-location
            '''
            result = self._values.get("location")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.LocationActionProperty"]], result)

        @builtins.property
        def open_search(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.OpenSearchActionProperty"]]:
            '''Write data to an Amazon OpenSearch Service domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-opensearch
            '''
            result = self._values.get("open_search")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.OpenSearchActionProperty"]], result)

        @builtins.property
        def republish(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.RepublishActionProperty"]]:
            '''Publish to another MQTT topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-republish
            '''
            result = self._values.get("republish")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.RepublishActionProperty"]], result)

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.S3ActionProperty"]]:
            '''Write to an Amazon S3 bucket.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.S3ActionProperty"]], result)

        @builtins.property
        def sns(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.SnsActionProperty"]]:
            '''Publish to an Amazon SNS topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-sns
            '''
            result = self._values.get("sns")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.SnsActionProperty"]], result)

        @builtins.property
        def sqs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.SqsActionProperty"]]:
            '''Publish to an Amazon SQS queue.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-sqs
            '''
            result = self._values.get("sqs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.SqsActionProperty"]], result)

        @builtins.property
        def step_functions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.StepFunctionsActionProperty"]]:
            '''Starts execution of a Step Functions state machine.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-stepfunctions
            '''
            result = self._values.get("step_functions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.StepFunctionsActionProperty"]], result)

        @builtins.property
        def timestream(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestreamActionProperty"]]:
            '''Writes attributes from an MQTT message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html#cfn-iot-topicrule-action-timestream
            '''
            result = self._values.get("timestream")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestreamActionProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty",
        jsii_struct_bases=[],
        name_mapping={
            "offset_in_nanos": "offsetInNanos",
            "time_in_seconds": "timeInSeconds",
        },
    )
    class AssetPropertyTimestampProperty:
        def __init__(
            self,
            *,
            offset_in_nanos: typing.Optional[builtins.str] = None,
            time_in_seconds: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An asset property timestamp entry containing the following information.

            :param offset_in_nanos: Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
            :param time_in_seconds: A string that contains the time in seconds since epoch. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertytimestamp.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                asset_property_timestamp_property = iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                    offset_in_nanos="offsetInNanos",
                    time_in_seconds="timeInSeconds"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ac66ca627fe9878e8def5aa10b7c79201fe22422167ddd9ba59184cfc8d72bb7)
                check_type(argname="argument offset_in_nanos", value=offset_in_nanos, expected_type=type_hints["offset_in_nanos"])
                check_type(argname="argument time_in_seconds", value=time_in_seconds, expected_type=type_hints["time_in_seconds"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if offset_in_nanos is not None:
                self._values["offset_in_nanos"] = offset_in_nanos
            if time_in_seconds is not None:
                self._values["time_in_seconds"] = time_in_seconds

        @builtins.property
        def offset_in_nanos(self) -> typing.Optional[builtins.str]:
            '''Optional.

            A string that contains the nanosecond time offset. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertytimestamp.html#cfn-iot-topicrule-assetpropertytimestamp-offsetinnanos
            '''
            result = self._values.get("offset_in_nanos")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def time_in_seconds(self) -> typing.Optional[builtins.str]:
            '''A string that contains the time in seconds since epoch.

            Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertytimestamp.html#cfn-iot-topicrule-assetpropertytimestamp-timeinseconds
            '''
            result = self._values.get("time_in_seconds")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AssetPropertyTimestampProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty",
        jsii_struct_bases=[],
        name_mapping={
            "quality": "quality",
            "timestamp": "timestamp",
            "value": "value",
        },
    )
    class AssetPropertyValueProperty:
        def __init__(
            self,
            *,
            quality: typing.Optional[builtins.str] = None,
            timestamp: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.AssetPropertyTimestampProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            value: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.AssetPropertyVariantProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''An asset property value entry containing the following information.

            :param quality: Optional. A string that describes the quality of the value. Accepts substitution templates. Must be ``GOOD`` , ``BAD`` , or ``UNCERTAIN`` .
            :param timestamp: The asset property value timestamp.
            :param value: The value of the asset property.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                asset_property_value_property = iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                    quality="quality",
                    timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                        offset_in_nanos="offsetInNanos",
                        time_in_seconds="timeInSeconds"
                    ),
                    value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                        boolean_value="booleanValue",
                        double_value="doubleValue",
                        integer_value="integerValue",
                        string_value="stringValue"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__033acfaa011aa9492a5a350f649786370635a78713d06b6b2a2695c2491e68a2)
                check_type(argname="argument quality", value=quality, expected_type=type_hints["quality"])
                check_type(argname="argument timestamp", value=timestamp, expected_type=type_hints["timestamp"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if quality is not None:
                self._values["quality"] = quality
            if timestamp is not None:
                self._values["timestamp"] = timestamp
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def quality(self) -> typing.Optional[builtins.str]:
            '''Optional.

            A string that describes the quality of the value. Accepts substitution templates. Must be ``GOOD`` , ``BAD`` , or ``UNCERTAIN`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvalue.html#cfn-iot-topicrule-assetpropertyvalue-quality
            '''
            result = self._values.get("quality")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def timestamp(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.AssetPropertyTimestampProperty"]]:
            '''The asset property value timestamp.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvalue.html#cfn-iot-topicrule-assetpropertyvalue-timestamp
            '''
            result = self._values.get("timestamp")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.AssetPropertyTimestampProperty"]], result)

        @builtins.property
        def value(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.AssetPropertyVariantProperty"]]:
            '''The value of the asset property.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvalue.html#cfn-iot-topicrule-assetpropertyvalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.AssetPropertyVariantProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AssetPropertyValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty",
        jsii_struct_bases=[],
        name_mapping={
            "boolean_value": "booleanValue",
            "double_value": "doubleValue",
            "integer_value": "integerValue",
            "string_value": "stringValue",
        },
    )
    class AssetPropertyVariantProperty:
        def __init__(
            self,
            *,
            boolean_value: typing.Optional[builtins.str] = None,
            double_value: typing.Optional[builtins.str] = None,
            integer_value: typing.Optional[builtins.str] = None,
            string_value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains an asset property value (of a single type).

            :param boolean_value: Optional. A string that contains the boolean value ( ``true`` or ``false`` ) of the value entry. Accepts substitution templates.
            :param double_value: Optional. A string that contains the double value of the value entry. Accepts substitution templates.
            :param integer_value: Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
            :param string_value: Optional. The string value of the value entry. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvariant.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                asset_property_variant_property = iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                    boolean_value="booleanValue",
                    double_value="doubleValue",
                    integer_value="integerValue",
                    string_value="stringValue"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d926b74eb02589ab712da211df35057ae72bc7f4db1b74b4f02466ab8b8c1b05)
                check_type(argname="argument boolean_value", value=boolean_value, expected_type=type_hints["boolean_value"])
                check_type(argname="argument double_value", value=double_value, expected_type=type_hints["double_value"])
                check_type(argname="argument integer_value", value=integer_value, expected_type=type_hints["integer_value"])
                check_type(argname="argument string_value", value=string_value, expected_type=type_hints["string_value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if boolean_value is not None:
                self._values["boolean_value"] = boolean_value
            if double_value is not None:
                self._values["double_value"] = double_value
            if integer_value is not None:
                self._values["integer_value"] = integer_value
            if string_value is not None:
                self._values["string_value"] = string_value

        @builtins.property
        def boolean_value(self) -> typing.Optional[builtins.str]:
            '''Optional.

            A string that contains the boolean value ( ``true`` or ``false`` ) of the value entry. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvariant.html#cfn-iot-topicrule-assetpropertyvariant-booleanvalue
            '''
            result = self._values.get("boolean_value")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def double_value(self) -> typing.Optional[builtins.str]:
            '''Optional.

            A string that contains the double value of the value entry. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvariant.html#cfn-iot-topicrule-assetpropertyvariant-doublevalue
            '''
            result = self._values.get("double_value")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def integer_value(self) -> typing.Optional[builtins.str]:
            '''Optional.

            A string that contains the integer value of the value entry. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvariant.html#cfn-iot-topicrule-assetpropertyvariant-integervalue
            '''
            result = self._values.get("integer_value")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def string_value(self) -> typing.Optional[builtins.str]:
            '''Optional.

            The string value of the value entry. Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvariant.html#cfn-iot-topicrule-assetpropertyvariant-stringvalue
            '''
            result = self._values.get("string_value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AssetPropertyVariantProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.BatchConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_batch_open_ms": "maxBatchOpenMs",
            "max_batch_size": "maxBatchSize",
            "max_batch_size_bytes": "maxBatchSizeBytes",
        },
    )
    class BatchConfigProperty:
        def __init__(
            self,
            *,
            max_batch_open_ms: typing.Optional[jsii.Number] = None,
            max_batch_size: typing.Optional[jsii.Number] = None,
            max_batch_size_bytes: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''
            :param max_batch_open_ms: 
            :param max_batch_size: 
            :param max_batch_size_bytes: 

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-batchconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                batch_config_property = iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                    max_batch_open_ms=123,
                    max_batch_size=123,
                    max_batch_size_bytes=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7f660ab4eeb9ee18337ac5b4e0f5cb210d6fa7d428e799aeb8417d03dfb8598e)
                check_type(argname="argument max_batch_open_ms", value=max_batch_open_ms, expected_type=type_hints["max_batch_open_ms"])
                check_type(argname="argument max_batch_size", value=max_batch_size, expected_type=type_hints["max_batch_size"])
                check_type(argname="argument max_batch_size_bytes", value=max_batch_size_bytes, expected_type=type_hints["max_batch_size_bytes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_batch_open_ms is not None:
                self._values["max_batch_open_ms"] = max_batch_open_ms
            if max_batch_size is not None:
                self._values["max_batch_size"] = max_batch_size
            if max_batch_size_bytes is not None:
                self._values["max_batch_size_bytes"] = max_batch_size_bytes

        @builtins.property
        def max_batch_open_ms(self) -> typing.Optional[jsii.Number]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-batchconfig.html#cfn-iot-topicrule-batchconfig-maxbatchopenms
            '''
            result = self._values.get("max_batch_open_ms")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def max_batch_size(self) -> typing.Optional[jsii.Number]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-batchconfig.html#cfn-iot-topicrule-batchconfig-maxbatchsize
            '''
            result = self._values.get("max_batch_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def max_batch_size_bytes(self) -> typing.Optional[jsii.Number]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-batchconfig.html#cfn-iot-topicrule-batchconfig-maxbatchsizebytes
            '''
            result = self._values.get("max_batch_size_bytes")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BatchConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "alarm_name": "alarmName",
            "role_arn": "roleArn",
            "state_reason": "stateReason",
            "state_value": "stateValue",
        },
    )
    class CloudwatchAlarmActionProperty:
        def __init__(
            self,
            *,
            alarm_name: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            state_reason: typing.Optional[builtins.str] = None,
            state_value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action that updates a CloudWatch alarm.

            :param alarm_name: The CloudWatch alarm name.
            :param role_arn: The IAM role that allows access to the CloudWatch alarm.
            :param state_reason: The reason for the alarm change.
            :param state_value: The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchalarmaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                cloudwatch_alarm_action_property = iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                    alarm_name="alarmName",
                    role_arn="roleArn",
                    state_reason="stateReason",
                    state_value="stateValue"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bcea33c643e5f662af45146d7c7d6951f631551c6532757aba0d65062358260a)
                check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument state_reason", value=state_reason, expected_type=type_hints["state_reason"])
                check_type(argname="argument state_value", value=state_value, expected_type=type_hints["state_value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if alarm_name is not None:
                self._values["alarm_name"] = alarm_name
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if state_reason is not None:
                self._values["state_reason"] = state_reason
            if state_value is not None:
                self._values["state_value"] = state_value

        @builtins.property
        def alarm_name(self) -> typing.Optional[builtins.str]:
            '''The CloudWatch alarm name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchalarmaction.html#cfn-iot-topicrule-cloudwatchalarmaction-alarmname
            '''
            result = self._values.get("alarm_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role that allows access to the CloudWatch alarm.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchalarmaction.html#cfn-iot-topicrule-cloudwatchalarmaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def state_reason(self) -> typing.Optional[builtins.str]:
            '''The reason for the alarm change.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchalarmaction.html#cfn-iot-topicrule-cloudwatchalarmaction-statereason
            '''
            result = self._values.get("state_reason")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def state_value(self) -> typing.Optional[builtins.str]:
            '''The value of the alarm state.

            Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchalarmaction.html#cfn-iot-topicrule-cloudwatchalarmaction-statevalue
            '''
            result = self._values.get("state_value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CloudwatchAlarmActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "batch_mode": "batchMode",
            "log_group_name": "logGroupName",
            "role_arn": "roleArn",
        },
    )
    class CloudwatchLogsActionProperty:
        def __init__(
            self,
            *,
            batch_mode: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            log_group_name: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action that updates a CloudWatch log.

            :param batch_mode: Indicates whether batches of log records will be extracted and uploaded into CloudWatch.
            :param log_group_name: The CloudWatch log name.
            :param role_arn: The IAM role that allows access to the CloudWatch log.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchlogsaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                cloudwatch_logs_action_property = iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                    batch_mode=False,
                    log_group_name="logGroupName",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cbbd133f7cecbcb3cc087bfdcb8835bbdded0c5b8974ca5534fd7f64a03116e2)
                check_type(argname="argument batch_mode", value=batch_mode, expected_type=type_hints["batch_mode"])
                check_type(argname="argument log_group_name", value=log_group_name, expected_type=type_hints["log_group_name"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if batch_mode is not None:
                self._values["batch_mode"] = batch_mode
            if log_group_name is not None:
                self._values["log_group_name"] = log_group_name
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def batch_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether batches of log records will be extracted and uploaded into CloudWatch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchlogsaction.html#cfn-iot-topicrule-cloudwatchlogsaction-batchmode
            '''
            result = self._values.get("batch_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def log_group_name(self) -> typing.Optional[builtins.str]:
            '''The CloudWatch log name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchlogsaction.html#cfn-iot-topicrule-cloudwatchlogsaction-loggroupname
            '''
            result = self._values.get("log_group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role that allows access to the CloudWatch log.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchlogsaction.html#cfn-iot-topicrule-cloudwatchlogsaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CloudwatchLogsActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metric_name": "metricName",
            "metric_namespace": "metricNamespace",
            "metric_timestamp": "metricTimestamp",
            "metric_unit": "metricUnit",
            "metric_value": "metricValue",
            "role_arn": "roleArn",
        },
    )
    class CloudwatchMetricActionProperty:
        def __init__(
            self,
            *,
            metric_name: typing.Optional[builtins.str] = None,
            metric_namespace: typing.Optional[builtins.str] = None,
            metric_timestamp: typing.Optional[builtins.str] = None,
            metric_unit: typing.Optional[builtins.str] = None,
            metric_value: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action that captures a CloudWatch metric.

            :param metric_name: The CloudWatch metric name.
            :param metric_namespace: The CloudWatch metric namespace name.
            :param metric_timestamp: An optional `Unix timestamp <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp>`_ .
            :param metric_unit: The `metric unit <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit>`_ supported by CloudWatch.
            :param metric_value: The CloudWatch metric value.
            :param role_arn: The IAM role that allows access to the CloudWatch metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                cloudwatch_metric_action_property = iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                    metric_name="metricName",
                    metric_namespace="metricNamespace",
                    metric_timestamp="metricTimestamp",
                    metric_unit="metricUnit",
                    metric_value="metricValue",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dc1013d3f96561f93ea08229efb4804e57343abf28fbb546ded940458bfc78ba)
                check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
                check_type(argname="argument metric_namespace", value=metric_namespace, expected_type=type_hints["metric_namespace"])
                check_type(argname="argument metric_timestamp", value=metric_timestamp, expected_type=type_hints["metric_timestamp"])
                check_type(argname="argument metric_unit", value=metric_unit, expected_type=type_hints["metric_unit"])
                check_type(argname="argument metric_value", value=metric_value, expected_type=type_hints["metric_value"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metric_name is not None:
                self._values["metric_name"] = metric_name
            if metric_namespace is not None:
                self._values["metric_namespace"] = metric_namespace
            if metric_timestamp is not None:
                self._values["metric_timestamp"] = metric_timestamp
            if metric_unit is not None:
                self._values["metric_unit"] = metric_unit
            if metric_value is not None:
                self._values["metric_value"] = metric_value
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def metric_name(self) -> typing.Optional[builtins.str]:
            '''The CloudWatch metric name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html#cfn-iot-topicrule-cloudwatchmetricaction-metricname
            '''
            result = self._values.get("metric_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metric_namespace(self) -> typing.Optional[builtins.str]:
            '''The CloudWatch metric namespace name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html#cfn-iot-topicrule-cloudwatchmetricaction-metricnamespace
            '''
            result = self._values.get("metric_namespace")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metric_timestamp(self) -> typing.Optional[builtins.str]:
            '''An optional `Unix timestamp <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html#cfn-iot-topicrule-cloudwatchmetricaction-metrictimestamp
            '''
            result = self._values.get("metric_timestamp")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metric_unit(self) -> typing.Optional[builtins.str]:
            '''The `metric unit <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit>`_ supported by CloudWatch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html#cfn-iot-topicrule-cloudwatchmetricaction-metricunit
            '''
            result = self._values.get("metric_unit")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metric_value(self) -> typing.Optional[builtins.str]:
            '''The CloudWatch metric value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html#cfn-iot-topicrule-cloudwatchmetricaction-metricvalue
            '''
            result = self._values.get("metric_value")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role that allows access to the CloudWatch metric.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html#cfn-iot-topicrule-cloudwatchmetricaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CloudwatchMetricActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "hash_key_field": "hashKeyField",
            "hash_key_type": "hashKeyType",
            "hash_key_value": "hashKeyValue",
            "payload_field": "payloadField",
            "range_key_field": "rangeKeyField",
            "range_key_type": "rangeKeyType",
            "range_key_value": "rangeKeyValue",
            "role_arn": "roleArn",
            "table_name": "tableName",
        },
    )
    class DynamoDBActionProperty:
        def __init__(
            self,
            *,
            hash_key_field: typing.Optional[builtins.str] = None,
            hash_key_type: typing.Optional[builtins.str] = None,
            hash_key_value: typing.Optional[builtins.str] = None,
            payload_field: typing.Optional[builtins.str] = None,
            range_key_field: typing.Optional[builtins.str] = None,
            range_key_type: typing.Optional[builtins.str] = None,
            range_key_value: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            table_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to write to a DynamoDB table.

            The ``tableName`` , ``hashKeyField`` , and ``rangeKeyField`` values must match the values used when you created the table.

            The ``hashKeyValue`` and ``rangeKeyvalue`` fields use a substitution template syntax. These templates provide data at runtime. The syntax is as follows: ${ *sql-expression* }.

            You can specify any valid expression in a WHERE or SELECT clause, including JSON properties, comparisons, calculations, and functions. For example, the following field uses the third level of the topic:

            ``"hashKeyValue": "${topic(3)}"``

            The following field uses the timestamp:

            ``"rangeKeyValue": "${timestamp()}"``

            For more information, see `DynamoDBv2 Action <https://docs.aws.amazon.com/iot/latest/developerguide/iot-rule-actions.html>`_ in the *AWS IoT Developer Guide* .

            :param hash_key_field: The hash key name.
            :param hash_key_type: The hash key type. Valid values are "STRING" or "NUMBER"
            :param hash_key_value: The hash key value.
            :param payload_field: The action payload. This name can be customized.
            :param range_key_field: The range key name.
            :param range_key_type: The range key type. Valid values are "STRING" or "NUMBER"
            :param range_key_value: The range key value.
            :param role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
            :param table_name: The name of the DynamoDB table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                dynamo_dBAction_property = iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                    hash_key_field="hashKeyField",
                    hash_key_type="hashKeyType",
                    hash_key_value="hashKeyValue",
                    payload_field="payloadField",
                    range_key_field="rangeKeyField",
                    range_key_type="rangeKeyType",
                    range_key_value="rangeKeyValue",
                    role_arn="roleArn",
                    table_name="tableName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b5869903d9e9062c61fd7965ffbc0846f8834bd15d1ff9588baea5fa15cd5e1a)
                check_type(argname="argument hash_key_field", value=hash_key_field, expected_type=type_hints["hash_key_field"])
                check_type(argname="argument hash_key_type", value=hash_key_type, expected_type=type_hints["hash_key_type"])
                check_type(argname="argument hash_key_value", value=hash_key_value, expected_type=type_hints["hash_key_value"])
                check_type(argname="argument payload_field", value=payload_field, expected_type=type_hints["payload_field"])
                check_type(argname="argument range_key_field", value=range_key_field, expected_type=type_hints["range_key_field"])
                check_type(argname="argument range_key_type", value=range_key_type, expected_type=type_hints["range_key_type"])
                check_type(argname="argument range_key_value", value=range_key_value, expected_type=type_hints["range_key_value"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument table_name", value=table_name, expected_type=type_hints["table_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if hash_key_field is not None:
                self._values["hash_key_field"] = hash_key_field
            if hash_key_type is not None:
                self._values["hash_key_type"] = hash_key_type
            if hash_key_value is not None:
                self._values["hash_key_value"] = hash_key_value
            if payload_field is not None:
                self._values["payload_field"] = payload_field
            if range_key_field is not None:
                self._values["range_key_field"] = range_key_field
            if range_key_type is not None:
                self._values["range_key_type"] = range_key_type
            if range_key_value is not None:
                self._values["range_key_value"] = range_key_value
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if table_name is not None:
                self._values["table_name"] = table_name

        @builtins.property
        def hash_key_field(self) -> typing.Optional[builtins.str]:
            '''The hash key name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-hashkeyfield
            '''
            result = self._values.get("hash_key_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def hash_key_type(self) -> typing.Optional[builtins.str]:
            '''The hash key type.

            Valid values are "STRING" or "NUMBER"

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-hashkeytype
            '''
            result = self._values.get("hash_key_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def hash_key_value(self) -> typing.Optional[builtins.str]:
            '''The hash key value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-hashkeyvalue
            '''
            result = self._values.get("hash_key_value")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def payload_field(self) -> typing.Optional[builtins.str]:
            '''The action payload.

            This name can be customized.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-payloadfield
            '''
            result = self._values.get("payload_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def range_key_field(self) -> typing.Optional[builtins.str]:
            '''The range key name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-rangekeyfield
            '''
            result = self._values.get("range_key_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def range_key_type(self) -> typing.Optional[builtins.str]:
            '''The range key type.

            Valid values are "STRING" or "NUMBER"

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-rangekeytype
            '''
            result = self._values.get("range_key_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def range_key_value(self) -> typing.Optional[builtins.str]:
            '''The range key value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-rangekeyvalue
            '''
            result = self._values.get("range_key_value")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access to the DynamoDB table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def table_name(self) -> typing.Optional[builtins.str]:
            '''The name of the DynamoDB table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html#cfn-iot-topicrule-dynamodbaction-tablename
            '''
            result = self._values.get("table_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DynamoDBActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty",
        jsii_struct_bases=[],
        name_mapping={"put_item": "putItem", "role_arn": "roleArn"},
    )
    class DynamoDBv2ActionProperty:
        def __init__(
            self,
            *,
            put_item: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.PutItemInputProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to write to a DynamoDB table.

            This DynamoDB action writes each attribute in the message payload into it's own column in the DynamoDB table.

            :param put_item: Specifies the DynamoDB table to which the message data will be written. For example:. ``{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`` Each attribute in the message payload will be written to a separate column in the DynamoDB database.
            :param role_arn: The ARN of the IAM role that grants access to the DynamoDB table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbv2action.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                dynamo_dBv2_action_property = iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                    put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                        table_name="tableName"
                    ),
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__289c2c71364f9f602bd1082167d71a7cd02bf832a3b2be6abfab9bf0b458e2af)
                check_type(argname="argument put_item", value=put_item, expected_type=type_hints["put_item"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if put_item is not None:
                self._values["put_item"] = put_item
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def put_item(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.PutItemInputProperty"]]:
            '''Specifies the DynamoDB table to which the message data will be written. For example:.

            ``{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }``

            Each attribute in the message payload will be written to a separate column in the DynamoDB database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbv2action.html#cfn-iot-topicrule-dynamodbv2action-putitem
            '''
            result = self._values.get("put_item")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.PutItemInputProperty"]], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access to the DynamoDB table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbv2action.html#cfn-iot-topicrule-dynamodbv2action-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DynamoDBv2ActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "endpoint": "endpoint",
            "id": "id",
            "index": "index",
            "role_arn": "roleArn",
            "type": "type",
        },
    )
    class ElasticsearchActionProperty:
        def __init__(
            self,
            *,
            endpoint: typing.Optional[builtins.str] = None,
            id: typing.Optional[builtins.str] = None,
            index: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action that writes data to an Amazon OpenSearch Service domain.

            .. epigraph::

               The ``Elasticsearch`` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the ``OpenSearch`` rule action instead. For more information, see `OpenSearchAction <https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html>`_ .

            :param endpoint: The endpoint of your OpenSearch domain.
            :param id: The unique identifier for the document you are storing.
            :param index: The index where you want to store your data.
            :param role_arn: The IAM role ARN that has access to OpenSearch.
            :param type: The type of document you are storing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                elasticsearch_action_property = iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                    endpoint="endpoint",
                    id="id",
                    index="index",
                    role_arn="roleArn",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f8abdf24255e29936018687e12f28c67d5b7ee9f56d42750e02a89288c8bbe11)
                check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
                check_type(argname="argument id", value=id, expected_type=type_hints["id"])
                check_type(argname="argument index", value=index, expected_type=type_hints["index"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if endpoint is not None:
                self._values["endpoint"] = endpoint
            if id is not None:
                self._values["id"] = id
            if index is not None:
                self._values["index"] = index
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def endpoint(self) -> typing.Optional[builtins.str]:
            '''The endpoint of your OpenSearch domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html#cfn-iot-topicrule-elasticsearchaction-endpoint
            '''
            result = self._values.get("endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier for the document you are storing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html#cfn-iot-topicrule-elasticsearchaction-id
            '''
            result = self._values.get("id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def index(self) -> typing.Optional[builtins.str]:
            '''The index where you want to store your data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html#cfn-iot-topicrule-elasticsearchaction-index
            '''
            result = self._values.get("index")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role ARN that has access to OpenSearch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html#cfn-iot-topicrule-elasticsearchaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of document you are storing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html#cfn-iot-topicrule-elasticsearchaction-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticsearchActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.FirehoseActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "batch_mode": "batchMode",
            "delivery_stream_name": "deliveryStreamName",
            "role_arn": "roleArn",
            "separator": "separator",
        },
    )
    class FirehoseActionProperty:
        def __init__(
            self,
            *,
            batch_mode: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            delivery_stream_name: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            separator: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action that writes data to an Amazon Kinesis Firehose stream.

            :param batch_mode: Whether to deliver the Kinesis Data Firehose stream as a batch by using ```PutRecordBatch`` <https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html>`_ . The default value is ``false`` . When ``batchMode`` is ``true`` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the ```PutRecordBatch`` <https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html>`_ request. The resulting array can't have more than 500 records.
            :param delivery_stream_name: The delivery stream name.
            :param role_arn: The IAM role that grants access to the Amazon Kinesis Firehose stream.
            :param separator: A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-firehoseaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                firehose_action_property = iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                    batch_mode=False,
                    delivery_stream_name="deliveryStreamName",
                    role_arn="roleArn",
                    separator="separator"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6f52ebe6610d03e60a673b85d859e8d46415ffd936e20efb65f7e721865adfca)
                check_type(argname="argument batch_mode", value=batch_mode, expected_type=type_hints["batch_mode"])
                check_type(argname="argument delivery_stream_name", value=delivery_stream_name, expected_type=type_hints["delivery_stream_name"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument separator", value=separator, expected_type=type_hints["separator"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if batch_mode is not None:
                self._values["batch_mode"] = batch_mode
            if delivery_stream_name is not None:
                self._values["delivery_stream_name"] = delivery_stream_name
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if separator is not None:
                self._values["separator"] = separator

        @builtins.property
        def batch_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Whether to deliver the Kinesis Data Firehose stream as a batch by using ```PutRecordBatch`` <https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html>`_ . The default value is ``false`` .

            When ``batchMode`` is ``true`` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the ```PutRecordBatch`` <https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html>`_ request. The resulting array can't have more than 500 records.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-firehoseaction.html#cfn-iot-topicrule-firehoseaction-batchmode
            '''
            result = self._values.get("batch_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def delivery_stream_name(self) -> typing.Optional[builtins.str]:
            '''The delivery stream name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-firehoseaction.html#cfn-iot-topicrule-firehoseaction-deliverystreamname
            '''
            result = self._values.get("delivery_stream_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role that grants access to the Amazon Kinesis Firehose stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-firehoseaction.html#cfn-iot-topicrule-firehoseaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def separator(self) -> typing.Optional[builtins.str]:
            '''A character separator that will be used to separate records written to the Firehose stream.

            Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-firehoseaction.html#cfn-iot-topicrule-firehoseaction-separator
            '''
            result = self._values.get("separator")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FirehoseActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class HttpActionHeaderProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The HTTP action header.

            :param key: The HTTP header key.
            :param value: The HTTP header value. Substitution templates are supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpactionheader.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                http_action_header_property = iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b558f297170f9827d73643fe3a3157df93bdcecc76fdc5a18c7b70e2809722f6)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The HTTP header key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpactionheader.html#cfn-iot-topicrule-httpactionheader-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The HTTP header value.

            Substitution templates are supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpactionheader.html#cfn-iot-topicrule-httpactionheader-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HttpActionHeaderProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.HttpActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth": "auth",
            "batch_config": "batchConfig",
            "confirmation_url": "confirmationUrl",
            "enable_batching": "enableBatching",
            "headers": "headers",
            "url": "url",
        },
    )
    class HttpActionProperty:
        def __init__(
            self,
            *,
            auth: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.HttpAuthorizationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            batch_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.BatchConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            confirmation_url: typing.Optional[builtins.str] = None,
            enable_batching: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            headers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.HttpActionHeaderProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            url: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Send data to an HTTPS endpoint.

            :param auth: The authentication method to use when sending data to an HTTPS endpoint.
            :param batch_config: 
            :param confirmation_url: The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
            :param enable_batching: 
            :param headers: The HTTP headers to send with the message data.
            :param url: The endpoint URL. If substitution templates are used in the URL, you must also specify a ``confirmationUrl`` . If this is a new destination, a new ``TopicRuleDestination`` is created if possible.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                http_action_property = iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                    auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                        sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                            role_arn="roleArn",
                            service_name="serviceName",
                            signing_region="signingRegion"
                        )
                    ),
                    batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                        max_batch_open_ms=123,
                        max_batch_size=123,
                        max_batch_size_bytes=123
                    ),
                    confirmation_url="confirmationUrl",
                    enable_batching=False,
                    headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                        key="key",
                        value="value"
                    )],
                    url="url"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f9d5e39bdf745b367f76ddfb5d1e2ffbd415679b9a12d029987de220a3265503)
                check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
                check_type(argname="argument batch_config", value=batch_config, expected_type=type_hints["batch_config"])
                check_type(argname="argument confirmation_url", value=confirmation_url, expected_type=type_hints["confirmation_url"])
                check_type(argname="argument enable_batching", value=enable_batching, expected_type=type_hints["enable_batching"])
                check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
                check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth is not None:
                self._values["auth"] = auth
            if batch_config is not None:
                self._values["batch_config"] = batch_config
            if confirmation_url is not None:
                self._values["confirmation_url"] = confirmation_url
            if enable_batching is not None:
                self._values["enable_batching"] = enable_batching
            if headers is not None:
                self._values["headers"] = headers
            if url is not None:
                self._values["url"] = url

        @builtins.property
        def auth(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.HttpAuthorizationProperty"]]:
            '''The authentication method to use when sending data to an HTTPS endpoint.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html#cfn-iot-topicrule-httpaction-auth
            '''
            result = self._values.get("auth")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.HttpAuthorizationProperty"]], result)

        @builtins.property
        def batch_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.BatchConfigProperty"]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html#cfn-iot-topicrule-httpaction-batchconfig
            '''
            result = self._values.get("batch_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.BatchConfigProperty"]], result)

        @builtins.property
        def confirmation_url(self) -> typing.Optional[builtins.str]:
            '''The URL to which AWS IoT sends a confirmation message.

            The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html#cfn-iot-topicrule-httpaction-confirmationurl
            '''
            result = self._values.get("confirmation_url")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def enable_batching(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''
            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html#cfn-iot-topicrule-httpaction-enablebatching
            '''
            result = self._values.get("enable_batching")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def headers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.HttpActionHeaderProperty"]]]]:
            '''The HTTP headers to send with the message data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html#cfn-iot-topicrule-httpaction-headers
            '''
            result = self._values.get("headers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.HttpActionHeaderProperty"]]]], result)

        @builtins.property
        def url(self) -> typing.Optional[builtins.str]:
            '''The endpoint URL.

            If substitution templates are used in the URL, you must also specify a ``confirmationUrl`` . If this is a new destination, a new ``TopicRuleDestination`` is created if possible.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html#cfn-iot-topicrule-httpaction-url
            '''
            result = self._values.get("url")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HttpActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty",
        jsii_struct_bases=[],
        name_mapping={"sigv4": "sigv4"},
    )
    class HttpAuthorizationProperty:
        def __init__(
            self,
            *,
            sigv4: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.SigV4AuthorizationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The authorization method used to send messages.

            :param sigv4: Use Sig V4 authorization. For more information, see `Signature Version 4 Signing Process <https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpauthorization.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                http_authorization_property = iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                    sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                        role_arn="roleArn",
                        service_name="serviceName",
                        signing_region="signingRegion"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__06b79bd9af0c00128283b3985758a3b41979b30ee5d07ee058bf1920ea0d5d2e)
                check_type(argname="argument sigv4", value=sigv4, expected_type=type_hints["sigv4"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if sigv4 is not None:
                self._values["sigv4"] = sigv4

        @builtins.property
        def sigv4(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.SigV4AuthorizationProperty"]]:
            '''Use Sig V4 authorization.

            For more information, see `Signature Version 4 Signing Process <https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpauthorization.html#cfn-iot-topicrule-httpauthorization-sigv4
            '''
            result = self._values.get("sigv4")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.SigV4AuthorizationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HttpAuthorizationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "batch_mode": "batchMode",
            "channel_name": "channelName",
            "role_arn": "roleArn",
        },
    )
    class IotAnalyticsActionProperty:
        def __init__(
            self,
            *,
            batch_mode: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            channel_name: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Sends message data to an AWS IoT Analytics channel.

            :param batch_mode: Whether to process the action as a batch. The default value is ``false`` . When ``batchMode`` is ``true`` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by ```BatchPutMessage`` <https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html>`_ The resulting array can't have more than 100 messages.
            :param channel_name: The name of the IoT Analytics channel to which message data will be sent.
            :param role_arn: The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotanalyticsaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                iot_analytics_action_property = iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                    batch_mode=False,
                    channel_name="channelName",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__abc5d21f56fc096378bdef84ec00218c2d3da6cad32718ef57ebba982b9da041)
                check_type(argname="argument batch_mode", value=batch_mode, expected_type=type_hints["batch_mode"])
                check_type(argname="argument channel_name", value=channel_name, expected_type=type_hints["channel_name"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if batch_mode is not None:
                self._values["batch_mode"] = batch_mode
            if channel_name is not None:
                self._values["channel_name"] = channel_name
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def batch_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Whether to process the action as a batch. The default value is ``false`` .

            When ``batchMode`` is ``true`` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by ```BatchPutMessage`` <https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html>`_ The resulting array can't have more than 100 messages.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotanalyticsaction.html#cfn-iot-topicrule-iotanalyticsaction-batchmode
            '''
            result = self._values.get("batch_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def channel_name(self) -> typing.Optional[builtins.str]:
            '''The name of the IoT Analytics channel to which message data will be sent.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotanalyticsaction.html#cfn-iot-topicrule-iotanalyticsaction-channelname
            '''
            result = self._values.get("channel_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotanalyticsaction.html#cfn-iot-topicrule-iotanalyticsaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IotAnalyticsActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.IotEventsActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "batch_mode": "batchMode",
            "input_name": "inputName",
            "message_id": "messageId",
            "role_arn": "roleArn",
        },
    )
    class IotEventsActionProperty:
        def __init__(
            self,
            *,
            batch_mode: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            input_name: typing.Optional[builtins.str] = None,
            message_id: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Sends an input to an AWS IoT Events detector.

            :param batch_mode: Whether to process the event actions as a batch. The default value is ``false`` . When ``batchMode`` is ``true`` , you can't specify a ``messageId`` . When ``batchMode`` is ``true`` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling ```BatchPutMessage`` <https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html>`_ . The resulting array can't have more than 10 messages.
            :param input_name: The name of the AWS IoT Events input.
            :param message_id: The ID of the message. The default ``messageId`` is a new UUID value. When ``batchMode`` is ``true`` , you can't specify a ``messageId`` --a new UUID value will be assigned. Assign a value to this property to ensure that only one input (message) with a given ``messageId`` will be processed by an AWS IoT Events detector.
            :param role_arn: The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-ioteventsaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                iot_events_action_property = iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                    batch_mode=False,
                    input_name="inputName",
                    message_id="messageId",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__454121c75e3d91b85e47c9a647eb516ca17528aa515fc534f431a082dae7ec94)
                check_type(argname="argument batch_mode", value=batch_mode, expected_type=type_hints["batch_mode"])
                check_type(argname="argument input_name", value=input_name, expected_type=type_hints["input_name"])
                check_type(argname="argument message_id", value=message_id, expected_type=type_hints["message_id"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if batch_mode is not None:
                self._values["batch_mode"] = batch_mode
            if input_name is not None:
                self._values["input_name"] = input_name
            if message_id is not None:
                self._values["message_id"] = message_id
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def batch_mode(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Whether to process the event actions as a batch. The default value is ``false`` .

            When ``batchMode`` is ``true`` , you can't specify a ``messageId`` .

            When ``batchMode`` is ``true`` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling ```BatchPutMessage`` <https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html>`_ . The resulting array can't have more than 10 messages.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-ioteventsaction.html#cfn-iot-topicrule-ioteventsaction-batchmode
            '''
            result = self._values.get("batch_mode")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def input_name(self) -> typing.Optional[builtins.str]:
            '''The name of the AWS IoT Events input.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-ioteventsaction.html#cfn-iot-topicrule-ioteventsaction-inputname
            '''
            result = self._values.get("input_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def message_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the message. The default ``messageId`` is a new UUID value.

            When ``batchMode`` is ``true`` , you can't specify a ``messageId`` --a new UUID value will be assigned.

            Assign a value to this property to ensure that only one input (message) with a given ``messageId`` will be processed by an AWS IoT Events detector.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-ioteventsaction.html#cfn-iot-topicrule-ioteventsaction-messageid
            '''
            result = self._values.get("message_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector.

            ("Action":"iotevents:BatchPutMessage").

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-ioteventsaction.html#cfn-iot-topicrule-ioteventsaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IotEventsActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "put_asset_property_value_entries": "putAssetPropertyValueEntries",
            "role_arn": "roleArn",
        },
    )
    class IotSiteWiseActionProperty:
        def __init__(
            self,
            *,
            put_asset_property_value_entries: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to send data from an MQTT message that triggered the rule to AWS IoT SiteWise asset properties.

            :param put_asset_property_value_entries: A list of asset property value entries.
            :param role_arn: The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( ``"Action": "iotsitewise:BatchPutAssetPropertyValue"`` ). The trust policy can restrict access to specific asset hierarchy paths.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotsitewiseaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                iot_site_wise_action_property = iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                    put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                        asset_id="assetId",
                        entry_id="entryId",
                        property_alias="propertyAlias",
                        property_id="propertyId",
                        property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                            quality="quality",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                offset_in_nanos="offsetInNanos",
                                time_in_seconds="timeInSeconds"
                            ),
                            value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                boolean_value="booleanValue",
                                double_value="doubleValue",
                                integer_value="integerValue",
                                string_value="stringValue"
                            )
                        )]
                    )],
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cfe853ca3f5f4f9530b48cbd2b473172c5bf9c61eaf45bf44e7a9d2d63965b8f)
                check_type(argname="argument put_asset_property_value_entries", value=put_asset_property_value_entries, expected_type=type_hints["put_asset_property_value_entries"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if put_asset_property_value_entries is not None:
                self._values["put_asset_property_value_entries"] = put_asset_property_value_entries
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def put_asset_property_value_entries(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty"]]]]:
            '''A list of asset property value entries.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotsitewiseaction.html#cfn-iot-topicrule-iotsitewiseaction-putassetpropertyvalueentries
            '''
            result = self._values.get("put_asset_property_value_entries")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty"]]]], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise.

            ( ``"Action": "iotsitewise:BatchPutAssetPropertyValue"`` ). The trust policy can restrict access to specific asset hierarchy paths.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotsitewiseaction.html#cfn-iot-topicrule-iotsitewiseaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IotSiteWiseActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class KafkaActionHeaderProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a Kafka header using key-value pairs when you create a Rules Kafka Action.

            You can use these headers to route data from IoT clients to downstream Kafka clusters without modifying your message payload.

            :param key: The key of the Kafka header.
            :param value: The value of the Kafka header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaactionheader.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                kafka_action_header_property = iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ff78de4a183bad9579bd1ae8cc3d7df0ceb3ca278b09bbb7c3fb1684b3298bf3)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The key of the Kafka header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaactionheader.html#cfn-iot-topicrule-kafkaactionheader-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value of the Kafka header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaactionheader.html#cfn-iot-topicrule-kafkaactionheader-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KafkaActionHeaderProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.KafkaActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "client_properties": "clientProperties",
            "destination_arn": "destinationArn",
            "headers": "headers",
            "key": "key",
            "partition": "partition",
            "topic": "topic",
        },
    )
    class KafkaActionProperty:
        def __init__(
            self,
            *,
            client_properties: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
            destination_arn: typing.Optional[builtins.str] = None,
            headers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.KafkaActionHeaderProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            key: typing.Optional[builtins.str] = None,
            partition: typing.Optional[builtins.str] = None,
            topic: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.

            :param client_properties: Properties of the Apache Kafka producer client.
            :param destination_arn: The ARN of Kafka action's VPC ``TopicRuleDestination`` .
            :param headers: The list of Kafka headers that you specify.
            :param key: The Kafka message key.
            :param partition: The Kafka message partition.
            :param topic: The Kafka topic for messages to be sent to the Kafka broker.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                kafka_action_property = iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                    client_properties={
                        "client_properties_key": "clientProperties"
                    },
                    destination_arn="destinationArn",
                    headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                        key="key",
                        value="value"
                    )],
                    key="key",
                    partition="partition",
                    topic="topic"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e1af626a119add27c4c857d0ecc2befaae7e6c405e7495a58d692565f0c229d2)
                check_type(argname="argument client_properties", value=client_properties, expected_type=type_hints["client_properties"])
                check_type(argname="argument destination_arn", value=destination_arn, expected_type=type_hints["destination_arn"])
                check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument partition", value=partition, expected_type=type_hints["partition"])
                check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if client_properties is not None:
                self._values["client_properties"] = client_properties
            if destination_arn is not None:
                self._values["destination_arn"] = destination_arn
            if headers is not None:
                self._values["headers"] = headers
            if key is not None:
                self._values["key"] = key
            if partition is not None:
                self._values["partition"] = partition
            if topic is not None:
                self._values["topic"] = topic

        @builtins.property
        def client_properties(
            self,
        ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Properties of the Apache Kafka producer client.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html#cfn-iot-topicrule-kafkaaction-clientproperties
            '''
            result = self._values.get("client_properties")
            return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def destination_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of Kafka action's VPC ``TopicRuleDestination`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html#cfn-iot-topicrule-kafkaaction-destinationarn
            '''
            result = self._values.get("destination_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def headers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.KafkaActionHeaderProperty"]]]]:
            '''The list of Kafka headers that you specify.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html#cfn-iot-topicrule-kafkaaction-headers
            '''
            result = self._values.get("headers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.KafkaActionHeaderProperty"]]]], result)

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The Kafka message key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html#cfn-iot-topicrule-kafkaaction-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def partition(self) -> typing.Optional[builtins.str]:
            '''The Kafka message partition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html#cfn-iot-topicrule-kafkaaction-partition
            '''
            result = self._values.get("partition")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def topic(self) -> typing.Optional[builtins.str]:
            '''The Kafka topic for messages to be sent to the Kafka broker.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html#cfn-iot-topicrule-kafkaaction-topic
            '''
            result = self._values.get("topic")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KafkaActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.KinesisActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "partition_key": "partitionKey",
            "role_arn": "roleArn",
            "stream_name": "streamName",
        },
    )
    class KinesisActionProperty:
        def __init__(
            self,
            *,
            partition_key: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            stream_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to write data to an Amazon Kinesis stream.

            :param partition_key: The partition key.
            :param role_arn: The ARN of the IAM role that grants access to the Amazon Kinesis stream.
            :param stream_name: The name of the Amazon Kinesis stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kinesisaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                kinesis_action_property = iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                    partition_key="partitionKey",
                    role_arn="roleArn",
                    stream_name="streamName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cd2e28691b62b49426b74775f3d5f4c90700274caf142934b40ebf78a9f4a3d5)
                check_type(argname="argument partition_key", value=partition_key, expected_type=type_hints["partition_key"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument stream_name", value=stream_name, expected_type=type_hints["stream_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if partition_key is not None:
                self._values["partition_key"] = partition_key
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if stream_name is not None:
                self._values["stream_name"] = stream_name

        @builtins.property
        def partition_key(self) -> typing.Optional[builtins.str]:
            '''The partition key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kinesisaction.html#cfn-iot-topicrule-kinesisaction-partitionkey
            '''
            result = self._values.get("partition_key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access to the Amazon Kinesis stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kinesisaction.html#cfn-iot-topicrule-kinesisaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def stream_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Amazon Kinesis stream.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kinesisaction.html#cfn-iot-topicrule-kinesisaction-streamname
            '''
            result = self._values.get("stream_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KinesisActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.LambdaActionProperty",
        jsii_struct_bases=[],
        name_mapping={"function_arn": "functionArn"},
    )
    class LambdaActionProperty:
        def __init__(
            self,
            *,
            function_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to invoke a Lambda function.

            :param function_arn: The ARN of the Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-lambdaaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                lambda_action_property = iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                    function_arn="functionArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__699f1b0d5283b3f687f69eff90640a2088323d970ecef79ca6e46ec1952f36ae)
                check_type(argname="argument function_arn", value=function_arn, expected_type=type_hints["function_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if function_arn is not None:
                self._values["function_arn"] = function_arn

        @builtins.property
        def function_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-lambdaaction.html#cfn-iot-topicrule-lambdaaction-functionarn
            '''
            result = self._values.get("function_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LambdaActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.LocationActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_id": "deviceId",
            "latitude": "latitude",
            "longitude": "longitude",
            "role_arn": "roleArn",
            "timestamp": "timestamp",
            "tracker_name": "trackerName",
        },
    )
    class LocationActionProperty:
        def __init__(
            self,
            *,
            device_id: typing.Optional[builtins.str] = None,
            latitude: typing.Optional[builtins.str] = None,
            longitude: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            timestamp: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.TimestampProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tracker_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to send device location updates from an MQTT message to an Amazon Location tracker resource.

            :param device_id: The unique ID of the device providing the location data.
            :param latitude: A string that evaluates to a double value that represents the latitude of the device's location.
            :param longitude: A string that evaluates to a double value that represents the longitude of the device's location.
            :param role_arn: The IAM role that grants permission to write to the Amazon Location resource.
            :param timestamp: The time that the location data was sampled. The default value is the time the MQTT message was processed.
            :param tracker_name: The name of the tracker resource in Amazon Location in which the location is updated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                location_action_property = iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                    device_id="deviceId",
                    latitude="latitude",
                    longitude="longitude",
                    role_arn="roleArn",
                    timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                        unit="unit",
                        value="value"
                    ),
                    tracker_name="trackerName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f619f9aebbf1883c2a75a2a27f8731414df91d47dd3ec8e54a26b2908b4a0ef7)
                check_type(argname="argument device_id", value=device_id, expected_type=type_hints["device_id"])
                check_type(argname="argument latitude", value=latitude, expected_type=type_hints["latitude"])
                check_type(argname="argument longitude", value=longitude, expected_type=type_hints["longitude"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument timestamp", value=timestamp, expected_type=type_hints["timestamp"])
                check_type(argname="argument tracker_name", value=tracker_name, expected_type=type_hints["tracker_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if device_id is not None:
                self._values["device_id"] = device_id
            if latitude is not None:
                self._values["latitude"] = latitude
            if longitude is not None:
                self._values["longitude"] = longitude
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if timestamp is not None:
                self._values["timestamp"] = timestamp
            if tracker_name is not None:
                self._values["tracker_name"] = tracker_name

        @builtins.property
        def device_id(self) -> typing.Optional[builtins.str]:
            '''The unique ID of the device providing the location data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html#cfn-iot-topicrule-locationaction-deviceid
            '''
            result = self._values.get("device_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def latitude(self) -> typing.Optional[builtins.str]:
            '''A string that evaluates to a double value that represents the latitude of the device's location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html#cfn-iot-topicrule-locationaction-latitude
            '''
            result = self._values.get("latitude")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def longitude(self) -> typing.Optional[builtins.str]:
            '''A string that evaluates to a double value that represents the longitude of the device's location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html#cfn-iot-topicrule-locationaction-longitude
            '''
            result = self._values.get("longitude")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role that grants permission to write to the Amazon Location resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html#cfn-iot-topicrule-locationaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def timestamp(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestampProperty"]]:
            '''The time that the location data was sampled.

            The default value is the time the MQTT message was processed.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html#cfn-iot-topicrule-locationaction-timestamp
            '''
            result = self._values.get("timestamp")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestampProperty"]], result)

        @builtins.property
        def tracker_name(self) -> typing.Optional[builtins.str]:
            '''The name of the tracker resource in Amazon Location in which the location is updated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html#cfn-iot-topicrule-locationaction-trackername
            '''
            result = self._values.get("tracker_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LocationActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "endpoint": "endpoint",
            "id": "id",
            "index": "index",
            "role_arn": "roleArn",
            "type": "type",
        },
    )
    class OpenSearchActionProperty:
        def __init__(
            self,
            *,
            endpoint: typing.Optional[builtins.str] = None,
            id: typing.Optional[builtins.str] = None,
            index: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action that writes data to an Amazon OpenSearch Service domain.

            :param endpoint: The endpoint of your OpenSearch domain.
            :param id: The unique identifier for the document you are storing.
            :param index: The OpenSearch index where you want to store your data.
            :param role_arn: The IAM role ARN that has access to OpenSearch.
            :param type: The type of document you are storing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                open_search_action_property = iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                    endpoint="endpoint",
                    id="id",
                    index="index",
                    role_arn="roleArn",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c090c0fb8e4ac896e4735c45c3bfb8e307f6de1a3b0c66dac195479fe832e147)
                check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
                check_type(argname="argument id", value=id, expected_type=type_hints["id"])
                check_type(argname="argument index", value=index, expected_type=type_hints["index"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if endpoint is not None:
                self._values["endpoint"] = endpoint
            if id is not None:
                self._values["id"] = id
            if index is not None:
                self._values["index"] = index
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def endpoint(self) -> typing.Optional[builtins.str]:
            '''The endpoint of your OpenSearch domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html#cfn-iot-topicrule-opensearchaction-endpoint
            '''
            result = self._values.get("endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier for the document you are storing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html#cfn-iot-topicrule-opensearchaction-id
            '''
            result = self._values.get("id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def index(self) -> typing.Optional[builtins.str]:
            '''The OpenSearch index where you want to store your data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html#cfn-iot-topicrule-opensearchaction-index
            '''
            result = self._values.get("index")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The IAM role ARN that has access to OpenSearch.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html#cfn-iot-topicrule-opensearchaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of document you are storing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html#cfn-iot-topicrule-opensearchaction-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OpenSearchActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty",
        jsii_struct_bases=[],
        name_mapping={
            "asset_id": "assetId",
            "entry_id": "entryId",
            "property_alias": "propertyAlias",
            "property_id": "propertyId",
            "property_values": "propertyValues",
        },
    )
    class PutAssetPropertyValueEntryProperty:
        def __init__(
            self,
            *,
            asset_id: typing.Optional[builtins.str] = None,
            entry_id: typing.Optional[builtins.str] = None,
            property_alias: typing.Optional[builtins.str] = None,
            property_id: typing.Optional[builtins.str] = None,
            property_values: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.AssetPropertyValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''An asset property value entry containing the following information.

            :param asset_id: The ID of the AWS IoT SiteWise asset. You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.
            :param entry_id: Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
            :param property_alias: The name of the property alias associated with your asset property. You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.
            :param property_id: The ID of the asset's property. You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.
            :param property_values: A list of property values to insert that each contain timestamp, quality, and value (TQV) information.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                put_asset_property_value_entry_property = iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                    asset_id="assetId",
                    entry_id="entryId",
                    property_alias="propertyAlias",
                    property_id="propertyId",
                    property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                        quality="quality",
                        timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                            offset_in_nanos="offsetInNanos",
                            time_in_seconds="timeInSeconds"
                        ),
                        value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                            boolean_value="booleanValue",
                            double_value="doubleValue",
                            integer_value="integerValue",
                            string_value="stringValue"
                        )
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__702785a23884b4ef3426cf86d1be2cca971e6e69ba0b3b722f795292ac7d7eaf)
                check_type(argname="argument asset_id", value=asset_id, expected_type=type_hints["asset_id"])
                check_type(argname="argument entry_id", value=entry_id, expected_type=type_hints["entry_id"])
                check_type(argname="argument property_alias", value=property_alias, expected_type=type_hints["property_alias"])
                check_type(argname="argument property_id", value=property_id, expected_type=type_hints["property_id"])
                check_type(argname="argument property_values", value=property_values, expected_type=type_hints["property_values"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if asset_id is not None:
                self._values["asset_id"] = asset_id
            if entry_id is not None:
                self._values["entry_id"] = entry_id
            if property_alias is not None:
                self._values["property_alias"] = property_alias
            if property_id is not None:
                self._values["property_id"] = property_id
            if property_values is not None:
                self._values["property_values"] = property_values

        @builtins.property
        def asset_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the AWS IoT SiteWise asset.

            You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html#cfn-iot-topicrule-putassetpropertyvalueentry-assetid
            '''
            result = self._values.get("asset_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def entry_id(self) -> typing.Optional[builtins.str]:
            '''Optional.

            A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html#cfn-iot-topicrule-putassetpropertyvalueentry-entryid
            '''
            result = self._values.get("entry_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def property_alias(self) -> typing.Optional[builtins.str]:
            '''The name of the property alias associated with your asset property.

            You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html#cfn-iot-topicrule-putassetpropertyvalueentry-propertyalias
            '''
            result = self._values.get("property_alias")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def property_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the asset's property.

            You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html#cfn-iot-topicrule-putassetpropertyvalueentry-propertyid
            '''
            result = self._values.get("property_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def property_values(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.AssetPropertyValueProperty"]]]]:
            '''A list of property values to insert that each contain timestamp, quality, and value (TQV) information.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html#cfn-iot-topicrule-putassetpropertyvalueentry-propertyvalues
            '''
            result = self._values.get("property_values")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.AssetPropertyValueProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PutAssetPropertyValueEntryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.PutItemInputProperty",
        jsii_struct_bases=[],
        name_mapping={"table_name": "tableName"},
    )
    class PutItemInputProperty:
        def __init__(self, *, table_name: typing.Optional[builtins.str] = None) -> None:
            '''The input for the DynamoActionVS action that specifies the DynamoDB table to which the message data will be written.

            :param table_name: The table where the message data will be written.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putiteminput.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                put_item_input_property = iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                    table_name="tableName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ff0e6a75f6a095e3fef6f99442f7fbe47310b95296759f229e13cdccb8513e6e)
                check_type(argname="argument table_name", value=table_name, expected_type=type_hints["table_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if table_name is not None:
                self._values["table_name"] = table_name

        @builtins.property
        def table_name(self) -> typing.Optional[builtins.str]:
            '''The table where the message data will be written.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putiteminput.html#cfn-iot-topicrule-putiteminput-tablename
            '''
            result = self._values.get("table_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PutItemInputProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty",
        jsii_struct_bases=[],
        name_mapping={
            "content_type": "contentType",
            "correlation_data": "correlationData",
            "message_expiry": "messageExpiry",
            "payload_format_indicator": "payloadFormatIndicator",
            "response_topic": "responseTopic",
            "user_properties": "userProperties",
        },
    )
    class RepublishActionHeadersProperty:
        def __init__(
            self,
            *,
            content_type: typing.Optional[builtins.str] = None,
            correlation_data: typing.Optional[builtins.str] = None,
            message_expiry: typing.Optional[builtins.str] = None,
            payload_format_indicator: typing.Optional[builtins.str] = None,
            response_topic: typing.Optional[builtins.str] = None,
            user_properties: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.UserPropertyProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Specifies MQTT Version 5.0 headers information. For more information, see `MQTT <https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html>`_ in the IoT Core Developer Guide.

            :param content_type: A UTF-8 encoded string that describes the content of the publishing message. For more information, see `Content Type <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118>`_ in the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .
            :param correlation_data: The base64-encoded binary data used by the sender of the request message to identify which request the response message is for. For more information, see `Correlation Data <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115>`_ in the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ . .. epigraph:: This binary data must be base64-encoded.
            :param message_expiry: A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of ``messageExpiry`` represents the number of seconds before it expires. For more information about the limits of ``messageExpiry`` , see `Message broker and protocol limits and quotas <https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot>`_ in the IoT Core Reference Guide. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .
            :param payload_format_indicator: An ``Enum`` string value that indicates whether the payload is formatted as UTF-8. Valid values are ``UNSPECIFIED_BYTES`` and ``UTF8_DATA`` . For more information, see `Payload Format Indicator <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111>`_ from the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .
            :param response_topic: A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters. For more information, see `Response Topic <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114>`_ in the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .
            :param user_properties: An array of key-value pairs that you define in the MQTT5 header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                republish_action_headers_property = iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                    content_type="contentType",
                    correlation_data="correlationData",
                    message_expiry="messageExpiry",
                    payload_format_indicator="payloadFormatIndicator",
                    response_topic="responseTopic",
                    user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                        key="key",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__08d9c0165aa2ec1002a8f24a0e96c4560d314a87789420a2e9892167fb85b2a5)
                check_type(argname="argument content_type", value=content_type, expected_type=type_hints["content_type"])
                check_type(argname="argument correlation_data", value=correlation_data, expected_type=type_hints["correlation_data"])
                check_type(argname="argument message_expiry", value=message_expiry, expected_type=type_hints["message_expiry"])
                check_type(argname="argument payload_format_indicator", value=payload_format_indicator, expected_type=type_hints["payload_format_indicator"])
                check_type(argname="argument response_topic", value=response_topic, expected_type=type_hints["response_topic"])
                check_type(argname="argument user_properties", value=user_properties, expected_type=type_hints["user_properties"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if content_type is not None:
                self._values["content_type"] = content_type
            if correlation_data is not None:
                self._values["correlation_data"] = correlation_data
            if message_expiry is not None:
                self._values["message_expiry"] = message_expiry
            if payload_format_indicator is not None:
                self._values["payload_format_indicator"] = payload_format_indicator
            if response_topic is not None:
                self._values["response_topic"] = response_topic
            if user_properties is not None:
                self._values["user_properties"] = user_properties

        @builtins.property
        def content_type(self) -> typing.Optional[builtins.str]:
            '''A UTF-8 encoded string that describes the content of the publishing message.

            For more information, see `Content Type <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118>`_ in the MQTT Version 5.0 specification.

            Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html#cfn-iot-topicrule-republishactionheaders-contenttype
            '''
            result = self._values.get("content_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def correlation_data(self) -> typing.Optional[builtins.str]:
            '''The base64-encoded binary data used by the sender of the request message to identify which request the response message is for.

            For more information, see `Correlation Data <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115>`_ in the MQTT Version 5.0 specification.

            Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .
            .. epigraph::

               This binary data must be base64-encoded.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html#cfn-iot-topicrule-republishactionheaders-correlationdata
            '''
            result = self._values.get("correlation_data")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def message_expiry(self) -> typing.Optional[builtins.str]:
            '''A user-defined integer value that represents the message expiry interval at the broker.

            If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of ``messageExpiry`` represents the number of seconds before it expires. For more information about the limits of ``messageExpiry`` , see `Message broker and protocol limits and quotas <https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot>`_ in the IoT Core Reference Guide.

            Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html#cfn-iot-topicrule-republishactionheaders-messageexpiry
            '''
            result = self._values.get("message_expiry")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def payload_format_indicator(self) -> typing.Optional[builtins.str]:
            '''An ``Enum`` string value that indicates whether the payload is formatted as UTF-8.

            Valid values are ``UNSPECIFIED_BYTES`` and ``UTF8_DATA`` .

            For more information, see `Payload Format Indicator <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111>`_ from the MQTT Version 5.0 specification.

            Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html#cfn-iot-topicrule-republishactionheaders-payloadformatindicator
            '''
            result = self._values.get("payload_format_indicator")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def response_topic(self) -> typing.Optional[builtins.str]:
            '''A UTF-8 encoded string that's used as the topic name for a response message.

            The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters.

            For more information, see `Response Topic <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114>`_ in the MQTT Version 5.0 specification.

            Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html#cfn-iot-topicrule-republishactionheaders-responsetopic
            '''
            result = self._values.get("response_topic")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_properties(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.UserPropertyProperty"]]]]:
            '''An array of key-value pairs that you define in the MQTT5 header.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html#cfn-iot-topicrule-republishactionheaders-userproperties
            '''
            result = self._values.get("user_properties")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.UserPropertyProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RepublishActionHeadersProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.RepublishActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "headers": "headers",
            "qos": "qos",
            "role_arn": "roleArn",
            "topic": "topic",
        },
    )
    class RepublishActionProperty:
        def __init__(
            self,
            *,
            headers: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.RepublishActionHeadersProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            qos: typing.Optional[jsii.Number] = None,
            role_arn: typing.Optional[builtins.str] = None,
            topic: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to republish to another topic.

            :param headers: MQTT Version 5.0 headers information. For more information, see `MQTT <https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html>`_ in the IoT Core Developer Guide.
            :param qos: The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
            :param role_arn: The ARN of the IAM role that grants access.
            :param topic: The name of the MQTT topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                republish_action_property = iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                    headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                        content_type="contentType",
                        correlation_data="correlationData",
                        message_expiry="messageExpiry",
                        payload_format_indicator="payloadFormatIndicator",
                        response_topic="responseTopic",
                        user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                            key="key",
                            value="value"
                        )]
                    ),
                    qos=123,
                    role_arn="roleArn",
                    topic="topic"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e368276a280cf3f41cc53ac876bce894fe5235858277e7c5050388590a0fc3db)
                check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
                check_type(argname="argument qos", value=qos, expected_type=type_hints["qos"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if headers is not None:
                self._values["headers"] = headers
            if qos is not None:
                self._values["qos"] = qos
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if topic is not None:
                self._values["topic"] = topic

        @builtins.property
        def headers(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.RepublishActionHeadersProperty"]]:
            '''MQTT Version 5.0 headers information. For more information, see `MQTT <https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html>`_ in the IoT Core Developer Guide.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishaction.html#cfn-iot-topicrule-republishaction-headers
            '''
            result = self._values.get("headers")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.RepublishActionHeadersProperty"]], result)

        @builtins.property
        def qos(self) -> typing.Optional[jsii.Number]:
            '''The Quality of Service (QoS) level to use when republishing messages.

            The default value is 0.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishaction.html#cfn-iot-topicrule-republishaction-qos
            '''
            result = self._values.get("qos")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishaction.html#cfn-iot-topicrule-republishaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def topic(self) -> typing.Optional[builtins.str]:
            '''The name of the MQTT topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishaction.html#cfn-iot-topicrule-republishaction-topic
            '''
            result = self._values.get("topic")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RepublishActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.S3ActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bucket_name": "bucketName",
            "canned_acl": "cannedAcl",
            "key": "key",
            "role_arn": "roleArn",
        },
    )
    class S3ActionProperty:
        def __init__(
            self,
            *,
            bucket_name: typing.Optional[builtins.str] = None,
            canned_acl: typing.Optional[builtins.str] = None,
            key: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to write data to an Amazon S3 bucket.

            :param bucket_name: The Amazon S3 bucket.
            :param canned_acl: The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see `S3 canned ACLs <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl>`_ .
            :param key: The object key. For more information, see `Actions, resources, and condition keys for Amazon S3 <https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html>`_ .
            :param role_arn: The ARN of the IAM role that grants access.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-s3action.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                s3_action_property = iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                    bucket_name="bucketName",
                    canned_acl="cannedAcl",
                    key="key",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d20f94201cb327d87efb266013415608a7c41c255e2d8974672e935fe6800cdb)
                check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
                check_type(argname="argument canned_acl", value=canned_acl, expected_type=type_hints["canned_acl"])
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_name is not None:
                self._values["bucket_name"] = bucket_name
            if canned_acl is not None:
                self._values["canned_acl"] = canned_acl
            if key is not None:
                self._values["key"] = key
            if role_arn is not None:
                self._values["role_arn"] = role_arn

        @builtins.property
        def bucket_name(self) -> typing.Optional[builtins.str]:
            '''The Amazon S3 bucket.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-s3action.html#cfn-iot-topicrule-s3action-bucketname
            '''
            result = self._values.get("bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def canned_acl(self) -> typing.Optional[builtins.str]:
            '''The Amazon S3 canned ACL that controls access to the object identified by the object key.

            For more information, see `S3 canned ACLs <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-s3action.html#cfn-iot-topicrule-s3action-cannedacl
            '''
            result = self._values.get("canned_acl")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The object key.

            For more information, see `Actions, resources, and condition keys for Amazon S3 <https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-s3action.html#cfn-iot-topicrule-s3action-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-s3action.html#cfn-iot-topicrule-s3action-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3ActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "role_arn": "roleArn",
            "service_name": "serviceName",
            "signing_region": "signingRegion",
        },
    )
    class SigV4AuthorizationProperty:
        def __init__(
            self,
            *,
            role_arn: typing.Optional[builtins.str] = None,
            service_name: typing.Optional[builtins.str] = None,
            signing_region: typing.Optional[builtins.str] = None,
        ) -> None:
            '''For more information, see `Signature Version 4 signing process <https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html>`_ .

            :param role_arn: The ARN of the signing role.
            :param service_name: The service name to use while signing with Sig V4.
            :param signing_region: The signing region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sigv4authorization.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                sig_v4_authorization_property = iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                    role_arn="roleArn",
                    service_name="serviceName",
                    signing_region="signingRegion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b98ade1443ea84fb7563b7079115234284e893332cba045effc7660c865c0feb)
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
                check_type(argname="argument signing_region", value=signing_region, expected_type=type_hints["signing_region"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if service_name is not None:
                self._values["service_name"] = service_name
            if signing_region is not None:
                self._values["signing_region"] = signing_region

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the signing role.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sigv4authorization.html#cfn-iot-topicrule-sigv4authorization-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def service_name(self) -> typing.Optional[builtins.str]:
            '''The service name to use while signing with Sig V4.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sigv4authorization.html#cfn-iot-topicrule-sigv4authorization-servicename
            '''
            result = self._values.get("service_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def signing_region(self) -> typing.Optional[builtins.str]:
            '''The signing region.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sigv4authorization.html#cfn-iot-topicrule-sigv4authorization-signingregion
            '''
            result = self._values.get("signing_region")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SigV4AuthorizationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.SnsActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "message_format": "messageFormat",
            "role_arn": "roleArn",
            "target_arn": "targetArn",
        },
    )
    class SnsActionProperty:
        def __init__(
            self,
            *,
            message_format: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            target_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an action to publish to an Amazon SNS topic.

            :param message_format: (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see `Amazon SNS Message and JSON Formats <https://docs.aws.amazon.com/sns/latest/dg/json-formats.html>`_ in the *Amazon Simple Notification Service Developer Guide* .
            :param role_arn: The ARN of the IAM role that grants access.
            :param target_arn: The ARN of the SNS topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-snsaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                sns_action_property = iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                    message_format="messageFormat",
                    role_arn="roleArn",
                    target_arn="targetArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6d8eb4d8ddbc709706040e79b6ad28d33cfacba178873bd75b7bbfedeb03815f)
                check_type(argname="argument message_format", value=message_format, expected_type=type_hints["message_format"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument target_arn", value=target_arn, expected_type=type_hints["target_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if message_format is not None:
                self._values["message_format"] = message_format
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if target_arn is not None:
                self._values["target_arn"] = target_arn

        @builtins.property
        def message_format(self) -> typing.Optional[builtins.str]:
            '''(Optional) The message format of the message to publish.

            Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see `Amazon SNS Message and JSON Formats <https://docs.aws.amazon.com/sns/latest/dg/json-formats.html>`_ in the *Amazon Simple Notification Service Developer Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-snsaction.html#cfn-iot-topicrule-snsaction-messageformat
            '''
            result = self._values.get("message_format")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-snsaction.html#cfn-iot-topicrule-snsaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the SNS topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-snsaction.html#cfn-iot-topicrule-snsaction-targetarn
            '''
            result = self._values.get("target_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SnsActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.SqsActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "queue_url": "queueUrl",
            "role_arn": "roleArn",
            "use_base64": "useBase64",
        },
    )
    class SqsActionProperty:
        def __init__(
            self,
            *,
            queue_url: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            use_base64: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Describes an action to publish data to an Amazon SQS queue.

            :param queue_url: The URL of the Amazon SQS queue.
            :param role_arn: The ARN of the IAM role that grants access.
            :param use_base64: Specifies whether to use Base64 encoding.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sqsaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                sqs_action_property = iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                    queue_url="queueUrl",
                    role_arn="roleArn",
                    use_base64=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__85be1f7a116fcd6cfeb04c8e740bf5075c1b758a62f4af45ab7a06835e110f2a)
                check_type(argname="argument queue_url", value=queue_url, expected_type=type_hints["queue_url"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument use_base64", value=use_base64, expected_type=type_hints["use_base64"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if queue_url is not None:
                self._values["queue_url"] = queue_url
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if use_base64 is not None:
                self._values["use_base64"] = use_base64

        @builtins.property
        def queue_url(self) -> typing.Optional[builtins.str]:
            '''The URL of the Amazon SQS queue.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sqsaction.html#cfn-iot-topicrule-sqsaction-queueurl
            '''
            result = self._values.get("queue_url")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the IAM role that grants access.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sqsaction.html#cfn-iot-topicrule-sqsaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def use_base64(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to use Base64 encoding.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sqsaction.html#cfn-iot-topicrule-sqsaction-usebase64
            '''
            result = self._values.get("use_base64")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SqsActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "execution_name_prefix": "executionNamePrefix",
            "role_arn": "roleArn",
            "state_machine_name": "stateMachineName",
        },
    )
    class StepFunctionsActionProperty:
        def __init__(
            self,
            *,
            execution_name_prefix: typing.Optional[builtins.str] = None,
            role_arn: typing.Optional[builtins.str] = None,
            state_machine_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Starts execution of a Step Functions state machine.

            :param execution_name_prefix: (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
            :param role_arn: The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
            :param state_machine_name: The name of the Step Functions state machine whose execution will be started.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-stepfunctionsaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                step_functions_action_property = iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                    execution_name_prefix="executionNamePrefix",
                    role_arn="roleArn",
                    state_machine_name="stateMachineName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e64da73f30da5972e0429b2014d9e02e296509fef067869066a129be58ee7ea3)
                check_type(argname="argument execution_name_prefix", value=execution_name_prefix, expected_type=type_hints["execution_name_prefix"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument state_machine_name", value=state_machine_name, expected_type=type_hints["state_machine_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if execution_name_prefix is not None:
                self._values["execution_name_prefix"] = execution_name_prefix
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if state_machine_name is not None:
                self._values["state_machine_name"] = state_machine_name

        @builtins.property
        def execution_name_prefix(self) -> typing.Optional[builtins.str]:
            '''(Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID.

            Step Functions automatically creates a unique name for each state machine execution if one is not provided.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-stepfunctionsaction.html#cfn-iot-topicrule-stepfunctionsaction-executionnameprefix
            '''
            result = self._values.get("execution_name_prefix")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-stepfunctionsaction.html#cfn-iot-topicrule-stepfunctionsaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def state_machine_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Step Functions state machine whose execution will be started.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-stepfunctionsaction.html#cfn-iot-topicrule-stepfunctionsaction-statemachinename
            '''
            result = self._values.get("state_machine_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StepFunctionsActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.TimestampProperty",
        jsii_struct_bases=[],
        name_mapping={"unit": "unit", "value": "value"},
    )
    class TimestampProperty:
        def __init__(
            self,
            *,
            unit: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes how to interpret an application-defined timestamp value from an MQTT message payload and the precision of that value.

            :param unit: The precision of the timestamp value that results from the expression described in ``value`` .
            :param value: An expression that returns a long epoch time value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestamp.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                timestamp_property = iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                    unit="unit",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8bf3c07d9f67090803b646d78be8ea7367c697f560337680307b182a4f8d1fea)
                check_type(argname="argument unit", value=unit, expected_type=type_hints["unit"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if unit is not None:
                self._values["unit"] = unit
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def unit(self) -> typing.Optional[builtins.str]:
            '''The precision of the timestamp value that results from the expression described in ``value`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestamp.html#cfn-iot-topicrule-timestamp-unit
            '''
            result = self._values.get("unit")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''An expression that returns a long epoch time value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestamp.html#cfn-iot-topicrule-timestamp-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TimestampProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.TimestreamActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "database_name": "databaseName",
            "dimensions": "dimensions",
            "role_arn": "roleArn",
            "table_name": "tableName",
            "timestamp": "timestamp",
        },
    )
    class TimestreamActionProperty:
        def __init__(
            self,
            *,
            database_name: typing.Optional[builtins.str] = None,
            dimensions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.TimestreamDimensionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            role_arn: typing.Optional[builtins.str] = None,
            table_name: typing.Optional[builtins.str] = None,
            timestamp: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.TimestreamTimestampProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Describes an action that writes records into an Amazon Timestream table.

            :param database_name: The name of an Amazon Timestream database that has the table to write records into.
            :param dimensions: Metadata attributes of the time series that are written in each measure record.
            :param role_arn: The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.
            :param table_name: The table where the message data will be written.
            :param timestamp: The value to use for the entry's timestamp. If blank, the time that the entry was processed is used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                timestream_action_property = iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                    database_name="databaseName",
                    dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                        name="name",
                        value="value"
                    )],
                    role_arn="roleArn",
                    table_name="tableName",
                    timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                        unit="unit",
                        value="value"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9a9027091210d0318d9c0923a5c5f0bfc14241f0a6113d577f3d95fe204bf337)
                check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
                check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument table_name", value=table_name, expected_type=type_hints["table_name"])
                check_type(argname="argument timestamp", value=timestamp, expected_type=type_hints["timestamp"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if database_name is not None:
                self._values["database_name"] = database_name
            if dimensions is not None:
                self._values["dimensions"] = dimensions
            if role_arn is not None:
                self._values["role_arn"] = role_arn
            if table_name is not None:
                self._values["table_name"] = table_name
            if timestamp is not None:
                self._values["timestamp"] = timestamp

        @builtins.property
        def database_name(self) -> typing.Optional[builtins.str]:
            '''The name of an Amazon Timestream database that has the table to write records into.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html#cfn-iot-topicrule-timestreamaction-databasename
            '''
            result = self._values.get("database_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def dimensions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestreamDimensionProperty"]]]]:
            '''Metadata attributes of the time series that are written in each measure record.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html#cfn-iot-topicrule-timestreamaction-dimensions
            '''
            result = self._values.get("dimensions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestreamDimensionProperty"]]]], result)

        @builtins.property
        def role_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html#cfn-iot-topicrule-timestreamaction-rolearn
            '''
            result = self._values.get("role_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def table_name(self) -> typing.Optional[builtins.str]:
            '''The table where the message data will be written.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html#cfn-iot-topicrule-timestreamaction-tablename
            '''
            result = self._values.get("table_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def timestamp(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestreamTimestampProperty"]]:
            '''The value to use for the entry's timestamp.

            If blank, the time that the entry was processed is used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html#cfn-iot-topicrule-timestreamaction-timestamp
            '''
            result = self._values.get("timestamp")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.TimestreamTimestampProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TimestreamActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "value": "value"},
    )
    class TimestreamDimensionProperty:
        def __init__(
            self,
            *,
            name: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Metadata attributes of the time series that are written in each measure record.

            :param name: The metadata dimension name. This is the name of the column in the Amazon Timestream database table record.
            :param value: The value to write in this column of the database record.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamdimension.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                timestream_dimension_property = iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                    name="name",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8e888cf062bd1bf59b9adc2260b8d4ba90a0a81a28c78cdb9b0a55551b6f6eda)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The metadata dimension name.

            This is the name of the column in the Amazon Timestream database table record.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamdimension.html#cfn-iot-topicrule-timestreamdimension-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value to write in this column of the database record.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamdimension.html#cfn-iot-topicrule-timestreamdimension-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TimestreamDimensionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty",
        jsii_struct_bases=[],
        name_mapping={"unit": "unit", "value": "value"},
    )
    class TimestreamTimestampProperty:
        def __init__(
            self,
            *,
            unit: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The value to use for the entry's timestamp.

            If blank, the time that the entry was processed is used.

            :param unit: The precision of the timestamp value that results from the expression described in ``value`` .
            :param value: An expression that returns a long epoch time value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamtimestamp.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                timestream_timestamp_property = iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                    unit="unit",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5ab51005b039854a4132b7857bef0e5ca61ca59b95e1f4b62ac26e9818aeb65e)
                check_type(argname="argument unit", value=unit, expected_type=type_hints["unit"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if unit is not None:
                self._values["unit"] = unit
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def unit(self) -> typing.Optional[builtins.str]:
            '''The precision of the timestamp value that results from the expression described in ``value`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamtimestamp.html#cfn-iot-topicrule-timestreamtimestamp-unit
            '''
            result = self._values.get("unit")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''An expression that returns a long epoch time value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamtimestamp.html#cfn-iot-topicrule-timestreamtimestamp-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TimestreamTimestampProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.TopicRulePayloadProperty",
        jsii_struct_bases=[],
        name_mapping={
            "actions": "actions",
            "aws_iot_sql_version": "awsIotSqlVersion",
            "description": "description",
            "error_action": "errorAction",
            "rule_disabled": "ruleDisabled",
            "sql": "sql",
        },
    )
    class TopicRulePayloadProperty:
        def __init__(
            self,
            *,
            actions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.ActionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            aws_iot_sql_version: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            error_action: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnTopicRulePropsMixin.ActionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            rule_disabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            sql: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a rule.

            :param actions: The actions associated with the rule.
            :param aws_iot_sql_version: The version of the SQL rules engine to use when evaluating the rule. The default value is 2015-10-08.
            :param description: The description of the rule.
            :param error_action: The action to take when an error occurs.
            :param rule_disabled: Specifies whether the rule is disabled.
            :param sql: The SQL statement used to query the topic. For more information, see `AWS IoT SQL Reference <https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html>`_ in the *AWS IoT Developer Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                topic_rule_payload_property = iot_mixins.CfnTopicRulePropsMixin.TopicRulePayloadProperty(
                    actions=[iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                        cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                            alarm_name="alarmName",
                            role_arn="roleArn",
                            state_reason="stateReason",
                            state_value="stateValue"
                        ),
                        cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                            batch_mode=False,
                            log_group_name="logGroupName",
                            role_arn="roleArn"
                        ),
                        cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                            metric_name="metricName",
                            metric_namespace="metricNamespace",
                            metric_timestamp="metricTimestamp",
                            metric_unit="metricUnit",
                            metric_value="metricValue",
                            role_arn="roleArn"
                        ),
                        dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                            hash_key_field="hashKeyField",
                            hash_key_type="hashKeyType",
                            hash_key_value="hashKeyValue",
                            payload_field="payloadField",
                            range_key_field="rangeKeyField",
                            range_key_type="rangeKeyType",
                            range_key_value="rangeKeyValue",
                            role_arn="roleArn",
                            table_name="tableName"
                        ),
                        dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                            put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                                table_name="tableName"
                            ),
                            role_arn="roleArn"
                        ),
                        elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                            batch_mode=False,
                            delivery_stream_name="deliveryStreamName",
                            role_arn="roleArn",
                            separator="separator"
                        ),
                        http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                            auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                                sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                    role_arn="roleArn",
                                    service_name="serviceName",
                                    signing_region="signingRegion"
                                )
                            ),
                            batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                                max_batch_open_ms=123,
                                max_batch_size=123,
                                max_batch_size_bytes=123
                            ),
                            confirmation_url="confirmationUrl",
                            enable_batching=False,
                            headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            url="url"
                        ),
                        iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                            batch_mode=False,
                            channel_name="channelName",
                            role_arn="roleArn"
                        ),
                        iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                            batch_mode=False,
                            input_name="inputName",
                            message_id="messageId",
                            role_arn="roleArn"
                        ),
                        iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                            put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                                asset_id="assetId",
                                entry_id="entryId",
                                property_alias="propertyAlias",
                                property_id="propertyId",
                                property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                    quality="quality",
                                    timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                        offset_in_nanos="offsetInNanos",
                                        time_in_seconds="timeInSeconds"
                                    ),
                                    value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                        boolean_value="booleanValue",
                                        double_value="doubleValue",
                                        integer_value="integerValue",
                                        string_value="stringValue"
                                    )
                                )]
                            )],
                            role_arn="roleArn"
                        ),
                        kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                            client_properties={
                                "client_properties_key": "clientProperties"
                            },
                            destination_arn="destinationArn",
                            headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            key="key",
                            partition="partition",
                            topic="topic"
                        ),
                        kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                            partition_key="partitionKey",
                            role_arn="roleArn",
                            stream_name="streamName"
                        ),
                        lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                            function_arn="functionArn"
                        ),
                        location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                            device_id="deviceId",
                            latitude="latitude",
                            longitude="longitude",
                            role_arn="roleArn",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                                unit="unit",
                                value="value"
                            ),
                            tracker_name="trackerName"
                        ),
                        open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                            headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                                content_type="contentType",
                                correlation_data="correlationData",
                                message_expiry="messageExpiry",
                                payload_format_indicator="payloadFormatIndicator",
                                response_topic="responseTopic",
                                user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                    key="key",
                                    value="value"
                                )]
                            ),
                            qos=123,
                            role_arn="roleArn",
                            topic="topic"
                        ),
                        s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                            bucket_name="bucketName",
                            canned_acl="cannedAcl",
                            key="key",
                            role_arn="roleArn"
                        ),
                        sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                            message_format="messageFormat",
                            role_arn="roleArn",
                            target_arn="targetArn"
                        ),
                        sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                            queue_url="queueUrl",
                            role_arn="roleArn",
                            use_base64=False
                        ),
                        step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                            execution_name_prefix="executionNamePrefix",
                            role_arn="roleArn",
                            state_machine_name="stateMachineName"
                        ),
                        timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                            database_name="databaseName",
                            dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                                name="name",
                                value="value"
                            )],
                            role_arn="roleArn",
                            table_name="tableName",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                                unit="unit",
                                value="value"
                            )
                        )
                    )],
                    aws_iot_sql_version="awsIotSqlVersion",
                    description="description",
                    error_action=iot_mixins.CfnTopicRulePropsMixin.ActionProperty(
                        cloudwatch_alarm=iot_mixins.CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty(
                            alarm_name="alarmName",
                            role_arn="roleArn",
                            state_reason="stateReason",
                            state_value="stateValue"
                        ),
                        cloudwatch_logs=iot_mixins.CfnTopicRulePropsMixin.CloudwatchLogsActionProperty(
                            batch_mode=False,
                            log_group_name="logGroupName",
                            role_arn="roleArn"
                        ),
                        cloudwatch_metric=iot_mixins.CfnTopicRulePropsMixin.CloudwatchMetricActionProperty(
                            metric_name="metricName",
                            metric_namespace="metricNamespace",
                            metric_timestamp="metricTimestamp",
                            metric_unit="metricUnit",
                            metric_value="metricValue",
                            role_arn="roleArn"
                        ),
                        dynamo_db=iot_mixins.CfnTopicRulePropsMixin.DynamoDBActionProperty(
                            hash_key_field="hashKeyField",
                            hash_key_type="hashKeyType",
                            hash_key_value="hashKeyValue",
                            payload_field="payloadField",
                            range_key_field="rangeKeyField",
                            range_key_type="rangeKeyType",
                            range_key_value="rangeKeyValue",
                            role_arn="roleArn",
                            table_name="tableName"
                        ),
                        dynamo_dBv2=iot_mixins.CfnTopicRulePropsMixin.DynamoDBv2ActionProperty(
                            put_item=iot_mixins.CfnTopicRulePropsMixin.PutItemInputProperty(
                                table_name="tableName"
                            ),
                            role_arn="roleArn"
                        ),
                        elasticsearch=iot_mixins.CfnTopicRulePropsMixin.ElasticsearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        firehose=iot_mixins.CfnTopicRulePropsMixin.FirehoseActionProperty(
                            batch_mode=False,
                            delivery_stream_name="deliveryStreamName",
                            role_arn="roleArn",
                            separator="separator"
                        ),
                        http=iot_mixins.CfnTopicRulePropsMixin.HttpActionProperty(
                            auth=iot_mixins.CfnTopicRulePropsMixin.HttpAuthorizationProperty(
                                sigv4=iot_mixins.CfnTopicRulePropsMixin.SigV4AuthorizationProperty(
                                    role_arn="roleArn",
                                    service_name="serviceName",
                                    signing_region="signingRegion"
                                )
                            ),
                            batch_config=iot_mixins.CfnTopicRulePropsMixin.BatchConfigProperty(
                                max_batch_open_ms=123,
                                max_batch_size=123,
                                max_batch_size_bytes=123
                            ),
                            confirmation_url="confirmationUrl",
                            enable_batching=False,
                            headers=[iot_mixins.CfnTopicRulePropsMixin.HttpActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            url="url"
                        ),
                        iot_analytics=iot_mixins.CfnTopicRulePropsMixin.IotAnalyticsActionProperty(
                            batch_mode=False,
                            channel_name="channelName",
                            role_arn="roleArn"
                        ),
                        iot_events=iot_mixins.CfnTopicRulePropsMixin.IotEventsActionProperty(
                            batch_mode=False,
                            input_name="inputName",
                            message_id="messageId",
                            role_arn="roleArn"
                        ),
                        iot_site_wise=iot_mixins.CfnTopicRulePropsMixin.IotSiteWiseActionProperty(
                            put_asset_property_value_entries=[iot_mixins.CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty(
                                asset_id="assetId",
                                entry_id="entryId",
                                property_alias="propertyAlias",
                                property_id="propertyId",
                                property_values=[iot_mixins.CfnTopicRulePropsMixin.AssetPropertyValueProperty(
                                    quality="quality",
                                    timestamp=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyTimestampProperty(
                                        offset_in_nanos="offsetInNanos",
                                        time_in_seconds="timeInSeconds"
                                    ),
                                    value=iot_mixins.CfnTopicRulePropsMixin.AssetPropertyVariantProperty(
                                        boolean_value="booleanValue",
                                        double_value="doubleValue",
                                        integer_value="integerValue",
                                        string_value="stringValue"
                                    )
                                )]
                            )],
                            role_arn="roleArn"
                        ),
                        kafka=iot_mixins.CfnTopicRulePropsMixin.KafkaActionProperty(
                            client_properties={
                                "client_properties_key": "clientProperties"
                            },
                            destination_arn="destinationArn",
                            headers=[iot_mixins.CfnTopicRulePropsMixin.KafkaActionHeaderProperty(
                                key="key",
                                value="value"
                            )],
                            key="key",
                            partition="partition",
                            topic="topic"
                        ),
                        kinesis=iot_mixins.CfnTopicRulePropsMixin.KinesisActionProperty(
                            partition_key="partitionKey",
                            role_arn="roleArn",
                            stream_name="streamName"
                        ),
                        lambda_=iot_mixins.CfnTopicRulePropsMixin.LambdaActionProperty(
                            function_arn="functionArn"
                        ),
                        location=iot_mixins.CfnTopicRulePropsMixin.LocationActionProperty(
                            device_id="deviceId",
                            latitude="latitude",
                            longitude="longitude",
                            role_arn="roleArn",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestampProperty(
                                unit="unit",
                                value="value"
                            ),
                            tracker_name="trackerName"
                        ),
                        open_search=iot_mixins.CfnTopicRulePropsMixin.OpenSearchActionProperty(
                            endpoint="endpoint",
                            id="id",
                            index="index",
                            role_arn="roleArn",
                            type="type"
                        ),
                        republish=iot_mixins.CfnTopicRulePropsMixin.RepublishActionProperty(
                            headers=iot_mixins.CfnTopicRulePropsMixin.RepublishActionHeadersProperty(
                                content_type="contentType",
                                correlation_data="correlationData",
                                message_expiry="messageExpiry",
                                payload_format_indicator="payloadFormatIndicator",
                                response_topic="responseTopic",
                                user_properties=[iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                                    key="key",
                                    value="value"
                                )]
                            ),
                            qos=123,
                            role_arn="roleArn",
                            topic="topic"
                        ),
                        s3=iot_mixins.CfnTopicRulePropsMixin.S3ActionProperty(
                            bucket_name="bucketName",
                            canned_acl="cannedAcl",
                            key="key",
                            role_arn="roleArn"
                        ),
                        sns=iot_mixins.CfnTopicRulePropsMixin.SnsActionProperty(
                            message_format="messageFormat",
                            role_arn="roleArn",
                            target_arn="targetArn"
                        ),
                        sqs=iot_mixins.CfnTopicRulePropsMixin.SqsActionProperty(
                            queue_url="queueUrl",
                            role_arn="roleArn",
                            use_base64=False
                        ),
                        step_functions=iot_mixins.CfnTopicRulePropsMixin.StepFunctionsActionProperty(
                            execution_name_prefix="executionNamePrefix",
                            role_arn="roleArn",
                            state_machine_name="stateMachineName"
                        ),
                        timestream=iot_mixins.CfnTopicRulePropsMixin.TimestreamActionProperty(
                            database_name="databaseName",
                            dimensions=[iot_mixins.CfnTopicRulePropsMixin.TimestreamDimensionProperty(
                                name="name",
                                value="value"
                            )],
                            role_arn="roleArn",
                            table_name="tableName",
                            timestamp=iot_mixins.CfnTopicRulePropsMixin.TimestreamTimestampProperty(
                                unit="unit",
                                value="value"
                            )
                        )
                    ),
                    rule_disabled=False,
                    sql="sql"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2902f22bdaa64d8d1b677b7e186b52e74d8a1f3e9217b7c1b87adc31f13d7811)
                check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
                check_type(argname="argument aws_iot_sql_version", value=aws_iot_sql_version, expected_type=type_hints["aws_iot_sql_version"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument error_action", value=error_action, expected_type=type_hints["error_action"])
                check_type(argname="argument rule_disabled", value=rule_disabled, expected_type=type_hints["rule_disabled"])
                check_type(argname="argument sql", value=sql, expected_type=type_hints["sql"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if actions is not None:
                self._values["actions"] = actions
            if aws_iot_sql_version is not None:
                self._values["aws_iot_sql_version"] = aws_iot_sql_version
            if description is not None:
                self._values["description"] = description
            if error_action is not None:
                self._values["error_action"] = error_action
            if rule_disabled is not None:
                self._values["rule_disabled"] = rule_disabled
            if sql is not None:
                self._values["sql"] = sql

        @builtins.property
        def actions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.ActionProperty"]]]]:
            '''The actions associated with the rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html#cfn-iot-topicrule-topicrulepayload-actions
            '''
            result = self._values.get("actions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.ActionProperty"]]]], result)

        @builtins.property
        def aws_iot_sql_version(self) -> typing.Optional[builtins.str]:
            '''The version of the SQL rules engine to use when evaluating the rule.

            The default value is 2015-10-08.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html#cfn-iot-topicrule-topicrulepayload-awsiotsqlversion
            '''
            result = self._values.get("aws_iot_sql_version")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html#cfn-iot-topicrule-topicrulepayload-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def error_action(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.ActionProperty"]]:
            '''The action to take when an error occurs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html#cfn-iot-topicrule-topicrulepayload-erroraction
            '''
            result = self._values.get("error_action")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnTopicRulePropsMixin.ActionProperty"]], result)

        @builtins.property
        def rule_disabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether the rule is disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html#cfn-iot-topicrule-topicrulepayload-ruledisabled
            '''
            result = self._values.get("rule_disabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def sql(self) -> typing.Optional[builtins.str]:
            '''The SQL statement used to query the topic.

            For more information, see `AWS IoT SQL Reference <https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html>`_ in the *AWS IoT Developer Guide* .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html#cfn-iot-topicrule-topicrulepayload-sql
            '''
            result = self._values.get("sql")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TopicRulePayloadProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_iot.mixins.CfnTopicRulePropsMixin.UserPropertyProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class UserPropertyProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A key-value pair that you define in the header.

            :param key: A key to be specified in ``UserProperty`` .
            :param value: A value to be specified in ``UserProperty`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-userproperty.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_iot import mixins as iot_mixins
                
                user_property_property = iot_mixins.CfnTopicRulePropsMixin.UserPropertyProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4ad7f1dd6700b5ef3bf4132519d88a9e3d5aea98686883b88ed47c25577798bc)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''A key to be specified in ``UserProperty`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-userproperty.html#cfn-iot-topicrule-userproperty-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''A value to be specified in ``UserProperty`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-userproperty.html#cfn-iot-topicrule-userproperty-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "UserPropertyProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


__all__ = [
    "CfnAccountAuditConfigurationMixinProps",
    "CfnAccountAuditConfigurationPropsMixin",
    "CfnAuthorizerMixinProps",
    "CfnAuthorizerPropsMixin",
    "CfnBillingGroupMixinProps",
    "CfnBillingGroupPropsMixin",
    "CfnCACertificateMixinProps",
    "CfnCACertificatePropsMixin",
    "CfnCertificateMixinProps",
    "CfnCertificatePropsMixin",
    "CfnCertificateProviderMixinProps",
    "CfnCertificateProviderPropsMixin",
    "CfnCommandMixinProps",
    "CfnCommandPropsMixin",
    "CfnCustomMetricMixinProps",
    "CfnCustomMetricPropsMixin",
    "CfnDimensionMixinProps",
    "CfnDimensionPropsMixin",
    "CfnDomainConfigurationMixinProps",
    "CfnDomainConfigurationPropsMixin",
    "CfnEncryptionConfigurationMixinProps",
    "CfnEncryptionConfigurationPropsMixin",
    "CfnFleetMetricMixinProps",
    "CfnFleetMetricPropsMixin",
    "CfnJobTemplateMixinProps",
    "CfnJobTemplatePropsMixin",
    "CfnLoggingMixinProps",
    "CfnLoggingPropsMixin",
    "CfnMitigationActionMixinProps",
    "CfnMitigationActionPropsMixin",
    "CfnPolicyMixinProps",
    "CfnPolicyPrincipalAttachmentMixinProps",
    "CfnPolicyPrincipalAttachmentPropsMixin",
    "CfnPolicyPropsMixin",
    "CfnProvisioningTemplateMixinProps",
    "CfnProvisioningTemplatePropsMixin",
    "CfnResourceSpecificLoggingMixinProps",
    "CfnResourceSpecificLoggingPropsMixin",
    "CfnRoleAliasMixinProps",
    "CfnRoleAliasPropsMixin",
    "CfnScheduledAuditMixinProps",
    "CfnScheduledAuditPropsMixin",
    "CfnSecurityProfileMixinProps",
    "CfnSecurityProfilePropsMixin",
    "CfnSoftwarePackageMixinProps",
    "CfnSoftwarePackagePropsMixin",
    "CfnSoftwarePackageVersionMixinProps",
    "CfnSoftwarePackageVersionPropsMixin",
    "CfnThingGroupMixinProps",
    "CfnThingGroupPropsMixin",
    "CfnThingMixinProps",
    "CfnThingPrincipalAttachmentMixinProps",
    "CfnThingPrincipalAttachmentPropsMixin",
    "CfnThingPropsMixin",
    "CfnThingTypeMixinProps",
    "CfnThingTypePropsMixin",
    "CfnTopicRuleDestinationMixinProps",
    "CfnTopicRuleDestinationPropsMixin",
    "CfnTopicRuleMixinProps",
    "CfnTopicRulePropsMixin",
]

publication.publish()

def _typecheckingstub__de1be116e36defd0db9ab597939940b477859ac83c99632b8c593b3ebafc0b0b(
    *,
    account_id: typing.Optional[builtins.str] = None,
    audit_check_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    audit_notification_target_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetConfigurationsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f7c4aed6881efe8f21dd3828d4ec73410f1898b04708818c2fc360b0f77f2d9(
    props: typing.Union[CfnAccountAuditConfigurationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ccb486ef57a4f68c84d58c40dbaf0164d5af10bca464d407322ec6f05291ef5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9296feb9b3f0cf501cda053d4e717322fbeb43085fee49d5b7411b9bfecd043b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2865d13c19787979ffe8edca41a146f0b42eb8cb6d49443ce7c43c4bf8a6b794(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3df4090a778b3ae0a128804cd08bb6b9c9f811f09f529f4ddfd9a5e452fb03f0(
    *,
    authenticated_cognito_role_overly_permissive_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ca_certificate_expiring_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ca_certificate_key_quality_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    conflicting_client_ids_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    device_certificate_age_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.DeviceCertAgeAuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    device_certificate_expiring_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    device_certificate_key_quality_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    device_certificate_shared_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    intermediate_ca_revoked_for_active_device_certificates_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iot_policy_overly_permissive_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    io_t_policy_potential_mis_configuration_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iot_role_alias_allows_access_to_unused_services_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iot_role_alias_overly_permissive_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    logging_disabled_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    revoked_ca_certificate_still_active_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    revoked_device_certificate_still_active_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    unauthenticated_cognito_role_overly_permissive_check: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditCheckConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d54e393f14d2f122911f5230252deb15c10f1094ee1b9f3cc96998628cc13932(
    *,
    sns: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.AuditNotificationTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd4b946424347337d8db9afa587bbc5ece570da0a128af33b8d62f9d9bccf64f(
    *,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    role_arn: typing.Optional[builtins.str] = None,
    target_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f683595f2e39255ea67081ed623823ddbee5b5e852a4514f89e96586f3ee6f0(
    *,
    cert_age_threshold_in_days: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a6e49ab10d774dc080a5352577cdf4c85529aa60ee50fa269d68d4ecba46235(
    *,
    configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAccountAuditConfigurationPropsMixin.CertAgeCheckCustomConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90a36dd8738ac0745c8fde3f93f2d56f064ba30eccae3d055cce2e041a89403f(
    *,
    authorizer_function_arn: typing.Optional[builtins.str] = None,
    authorizer_name: typing.Optional[builtins.str] = None,
    enable_caching_for_http: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    signing_disabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    status: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    token_key_name: typing.Optional[builtins.str] = None,
    token_signing_public_keys: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1060ecc86e62625bd9620e44251575625aae4b60c952c2799a47e42411a18971(
    props: typing.Union[CfnAuthorizerMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5427ae3093deee88a3e11850cceb29cf8315291e16c395a32fc83aaa6d8598af(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__765043cb42c7689c66300495115edfa7d6d2eae42b4a9f1a0511ca772d8d6c6d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50f41c99407f91a8b033df1a3ef942a9babbbc1a48b9bb79ec55384c3935b5df(
    *,
    billing_group_name: typing.Optional[builtins.str] = None,
    billing_group_properties: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnBillingGroupPropsMixin.BillingGroupPropertiesProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c7cbbad1175f0fa4c93b26e59a0b7142892f1da4669df286fa8953990a61b55(
    props: typing.Union[CfnBillingGroupMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8da60cb5f6fe5ae25646ab7ee2379d0b33589691d5af625909fcf835b0ae40ae(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__278743e72de1e310c4afa70438b18c82a593123f35165e2a1ffb21b86e5fe2ae(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94d001cdcd948bb4d4d7c8b1970d60c0f8b4f1873da8be92c9aa36a4e660e34f(
    *,
    billing_group_description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f21c7480ca326adcaa61db3958a782c4b216f211c1cdd2f4fd74f22bd718229f(
    *,
    auto_registration_status: typing.Optional[builtins.str] = None,
    ca_certificate_pem: typing.Optional[builtins.str] = None,
    certificate_mode: typing.Optional[builtins.str] = None,
    registration_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCACertificatePropsMixin.RegistrationConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    remove_auto_registration: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    status: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    verification_certificate_pem: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51e82e31461f2bd0c43f98e9a7566907e4e9e8b4355ada66b69d4a55bdc00a1b(
    props: typing.Union[CfnCACertificateMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f336091ceb8415d2343f0a736e03fbe26cbc023d240d8726a47815c7498ca1a1(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5282433d789231bdff0b36f935fb93b3ebe6abe56bab93a184a3c772f369b136(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f621b9ab21c38beace2a0175d2d2dc53086458f95a0b2966527d8d672ca627eb(
    *,
    role_arn: typing.Optional[builtins.str] = None,
    template_body: typing.Optional[builtins.str] = None,
    template_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc807134a8297f687bf07101d8fd6f848784d35a38f812abbe8a58d4140d83ba(
    *,
    ca_certificate_pem: typing.Optional[builtins.str] = None,
    certificate_mode: typing.Optional[builtins.str] = None,
    certificate_pem: typing.Optional[builtins.str] = None,
    certificate_signing_request: typing.Optional[builtins.str] = None,
    status: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__227b32c83a5010d5de825f43280eb561e6f2eb6c4a6dcc1357f979ef793fb320(
    props: typing.Union[CfnCertificateMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85f15948a7f7672378e20765b3e0873546272ac08cec8d4c5f8775786ecdf975(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eab1fda7a099c4e8149db62b057ddbac77a30c57d0996bf2067f10ee42c47816(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a4a7c6fe6eba7db55fa3abe138b440e0cb1c039b9db91976c5daa8270dde669(
    *,
    account_default_for_operations: typing.Optional[typing.Sequence[builtins.str]] = None,
    certificate_provider_name: typing.Optional[builtins.str] = None,
    lambda_function_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3f075becfd6266df5a812bb4d8d5c8a7f91bcfcc7a1f49067e0dc0c9c0f4330(
    props: typing.Union[CfnCertificateProviderMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f738bedba0063cead406f73be5761f29efc8766b5fa961535bac0fb8598ee0ac(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5744e5b72615523c8b7155b375e8466615149cf5dcda891e5f31b1eb30325548(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22e8838b72b0e146c252cf0683db881d4cbe902f91e4dbf28122d9fd8f561ad5(
    *,
    command_id: typing.Optional[builtins.str] = None,
    created_at: typing.Optional[builtins.str] = None,
    deprecated: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    last_updated_at: typing.Optional[builtins.str] = None,
    mandatory_parameters: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCommandPropsMixin.CommandParameterProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    namespace: typing.Optional[builtins.str] = None,
    payload: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCommandPropsMixin.CommandPayloadProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    pending_deletion: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    role_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68609224e8a5cbfc0c3ef57cfb1e92f4321251996e1fb75e2a47c452615df2e6(
    props: typing.Union[CfnCommandMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88e70adc791e46cc3f8caded3fb99e1034a21ec2cc68c504ead1afe1c9dad1d3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ea2bfdd2b7aa273e5b11430425d0cfebf8d194f331b77652dbd9bea740332c4(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7cd914e82375db5b5c9c5031b01ffc8d8bd5a8cb5d6eda7b79d9e27fb9b42905(
    *,
    default_value: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCommandPropsMixin.CommandParameterValueProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnCommandPropsMixin.CommandParameterValueProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a4c4d1c1dbbcf570a95a119fe074a5c841f87770c82f08b47fec1646b0f9c46(
    *,
    b: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    bin: typing.Optional[builtins.str] = None,
    d: typing.Optional[jsii.Number] = None,
    i: typing.Optional[jsii.Number] = None,
    l: typing.Optional[builtins.str] = None,
    s: typing.Optional[builtins.str] = None,
    ul: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13a16db055afa979ec8efc5b45c6f17bc9a7513ce0059ad050eae71ae098ee0b(
    *,
    content: typing.Optional[builtins.str] = None,
    content_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1bacef4538b9877448a0ff6f3b60a70f99be1eacfc87c2bc92eb0451601d7336(
    *,
    display_name: typing.Optional[builtins.str] = None,
    metric_name: typing.Optional[builtins.str] = None,
    metric_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__924c2af48e269cb5ebbfd6e3d4c22a03948239f4bd6a0667ee7daa3b39027d2a(
    props: typing.Union[CfnCustomMetricMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16b5f7958fdae714abe11b1d0156a43bedf59c2178e0375102ca92fd29fd17de(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41e2cb1c655fc338ec3b85815c290e880b5c7ee8bec44c5f9f727df3f4b544a4(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a5b5a103f8bf274c2faa04d088153e85a1cb656c538e129a0d1e24987339a34(
    *,
    name: typing.Optional[builtins.str] = None,
    string_values: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0eb2d0930b3354ce8080696b7cb87a3d1c4e6c3dab95c6bde6ca36c4ebebb5c7(
    props: typing.Union[CfnDimensionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b48cf9e12b0c24b1f9408530df0d0067d924942976366a6cad3784cc3d1d6fcb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0f9848f344dfaef2b2d2cce18a00375ae57b05f962ed8e368d531f81be0bbef(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e179e0c1c000cbf031890308a2b82a44c17e97dca6cad5660fb096a9e2a5e768(
    *,
    application_protocol: typing.Optional[builtins.str] = None,
    authentication_type: typing.Optional[builtins.str] = None,
    authorizer_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDomainConfigurationPropsMixin.AuthorizerConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    client_certificate_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDomainConfigurationPropsMixin.ClientCertificateConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    domain_configuration_name: typing.Optional[builtins.str] = None,
    domain_configuration_status: typing.Optional[builtins.str] = None,
    domain_name: typing.Optional[builtins.str] = None,
    server_certificate_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    server_certificate_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDomainConfigurationPropsMixin.ServerCertificateConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    service_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    tls_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDomainConfigurationPropsMixin.TlsConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    validation_certificate_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26069dc7055a567e33b65dc10c39bb3dbccb1a56aa191781dda5c3ee8885b17d(
    props: typing.Union[CfnDomainConfigurationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc0f9e80c710b5f1446af64b7a67966477fbe47772aae6b831433e9063414d89(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d8d15bebf40d8a9b22a378f1cbc4bb5ba8bddf395592358f26c175bf928ad0e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8020f970ed22d520e6baad064adb05dd146f566e80a3512546711c4dbfd046cd(
    *,
    allow_authorizer_override: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    default_authorizer_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b426fadd3ec6dd7153cc9950f4377b98d24250fb1f1f2d1be57f4e221175dff(
    *,
    client_certificate_callback_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bbd88e0d48869d5c52db7ffbb92bdd09e29fc4bb53e854a7ce97d517e8d5943(
    *,
    enable_ocsp_check: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    ocsp_authorized_responder_arn: typing.Optional[builtins.str] = None,
    ocsp_lambda_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__159831730ae307e14fe9b506ffbe0c733613784b43a0a0eea41603cbd4904580(
    *,
    server_certificate_arn: typing.Optional[builtins.str] = None,
    server_certificate_status: typing.Optional[builtins.str] = None,
    server_certificate_status_detail: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75a342c56fedabbaf1a663a243ab9126bde6164e226e703af35ba0c5b819c1c3(
    *,
    security_policy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5939c84a52e6d3a8fa77e30d07cc9d8cacddbcad72754e96971694e8c6151a83(
    *,
    encryption_type: typing.Optional[builtins.str] = None,
    kms_access_role_arn: typing.Optional[builtins.str] = None,
    kms_key_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2db42c6d4b9bbfc3d353b0e9d2e99350fc013c9b2d9aba859b87ea758c287b64(
    props: typing.Union[CfnEncryptionConfigurationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34d8aa20fcf49dcb1cb1303dd0bb9c551ef3ab1a2194ac137bc1a40591c83df0(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3537472d34295df31fb76c9656ca4c8089bf6cf7aaf480349db9be6141017a8d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96d32469a173c24e2564e429c30aa39110c7cc4ad362f3af9a07a7a16b272ea4(
    *,
    configuration_status: typing.Optional[builtins.str] = None,
    error_code: typing.Optional[builtins.str] = None,
    error_message: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87a28f246d63013d50ef6b88b0262a6e07d493491cd7d8a3fbc01582ef9191b5(
    *,
    aggregation_field: typing.Optional[builtins.str] = None,
    aggregation_type: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFleetMetricPropsMixin.AggregationTypeProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    index_name: typing.Optional[builtins.str] = None,
    metric_name: typing.Optional[builtins.str] = None,
    period: typing.Optional[jsii.Number] = None,
    query_string: typing.Optional[builtins.str] = None,
    query_version: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    unit: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf20c80124d26d8092b6950df44aa8b75de6b6ec59d5db741459e9d1b57991e4(
    props: typing.Union[CfnFleetMetricMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04c3f0e4430483fd1bd1de67ab0cbe792558b5cfaee1ce07d9b5c9f318e24b86(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9561fb9ccacaf7fdd5ea0e9b52f2fe34eb69c68e406eb9768f832b5bc739bd5e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__888de911ead46d9b0aa6b82b7810251450bcc4d49395a2aec23898facca7ac27(
    *,
    name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aeb9a1e7dcff174c7875a2a1b9ffe85855ef5d40a242326fe430639fe65e6096(
    *,
    abort_config: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    destination_package_versions: typing.Optional[typing.Sequence[builtins.str]] = None,
    document: typing.Optional[builtins.str] = None,
    document_source: typing.Optional[builtins.str] = None,
    job_arn: typing.Optional[builtins.str] = None,
    job_executions_retry_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnJobTemplatePropsMixin.JobExecutionsRetryConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    job_executions_rollout_config: typing.Any = None,
    job_template_id: typing.Optional[builtins.str] = None,
    maintenance_windows: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnJobTemplatePropsMixin.MaintenanceWindowProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    presigned_url_config: typing.Any = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    timeout_config: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4729cefa94efc854c352d30682b4dd96c4750f0565c8a0f7529b11149a2b9090(
    props: typing.Union[CfnJobTemplateMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7248f85ced016c44e3c842e3a66409e594ddfc8fbdfa8d63bf173d26e42785c6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fb182fa7de811d2f788767cee8807ca64960b9a02e0722722574737bf4f38e1(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ac36ec54e7adf86a2e7c3ff1f155695d7fbb26ffefddf9fedce8a2e85809c7f(
    *,
    criteria_list: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnJobTemplatePropsMixin.AbortCriteriaProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__210dee595cc959d930be685c8bc1a7d4ef70faa60ba0c5624121c028fddfd1b0(
    *,
    action: typing.Optional[builtins.str] = None,
    failure_type: typing.Optional[builtins.str] = None,
    min_number_of_executed_things: typing.Optional[jsii.Number] = None,
    threshold_percentage: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe805b0ccd305a6ae460cfc3747a29e277069b35f0296f822d03f828f3d157f4(
    *,
    base_rate_per_minute: typing.Optional[jsii.Number] = None,
    increment_factor: typing.Optional[jsii.Number] = None,
    rate_increase_criteria: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnJobTemplatePropsMixin.RateIncreaseCriteriaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__013e3e1f699fd5fa866ae58efdd5eebc36e087b7e80fb4aa5ffcf89ad927721a(
    *,
    retry_criteria_list: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnJobTemplatePropsMixin.RetryCriteriaProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__744d75e04e14f1b0a4dd227b2e308bcbd53c0fefb6192be3fb6fd2e3c5bc65bd(
    *,
    exponential_rollout_rate: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnJobTemplatePropsMixin.ExponentialRolloutRateProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    maximum_per_minute: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91b861dffe1858ac2024521dffa1932c0037b8b9504e9360d1a76d44c5a08320(
    *,
    duration_in_minutes: typing.Optional[jsii.Number] = None,
    start_time: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbb99c6e24a9633bed497d244e38f7a3cdbda8b4a789f8fc4fb7244b64e61987(
    *,
    expires_in_sec: typing.Optional[jsii.Number] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69384ea90cb704330df84502f8bd98b20b065f7ab97b06e7bf4a7010ec03cd4b(
    *,
    number_of_notified_things: typing.Optional[jsii.Number] = None,
    number_of_succeeded_things: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b9cafa52b1bfe6f7708e4ca2e7af14b538c4a5b495e494ac8d454b023b8ff9b(
    *,
    failure_type: typing.Optional[builtins.str] = None,
    number_of_retries: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf9d810f74b671ff125301fb538282ab61d37e3f2382b42893c12146c269ab1b(
    *,
    in_progress_timeout_in_minutes: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c74fa4e99c8031cf693ac11cf7406fa6f137cdd034f766e1c4fc4a55afa7986(
    *,
    account_id: typing.Optional[builtins.str] = None,
    default_log_level: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b24803efcf5e08b1513ebc7547c591e1cc08b68540ca3ba1b48ee8e62d780853(
    props: typing.Union[CfnLoggingMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33ef7480f00d63b7b7f25c1d7a7435419443200f9cf2b1b5302fa314f92485f2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8ba75922a849e500972df8bf34457012cfac9677bb2635d92fb78c88d0f8a47(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a82d78d87277416479d01f5d60130ee1b1161b1bceb9fcb19bb985d649596a0f(
    *,
    action_name: typing.Optional[builtins.str] = None,
    action_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.ActionParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    role_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecddac8aad555479f9c0a4c01b8949628f6db0907797194ecd0066ad8ccc08ae(
    props: typing.Union[CfnMitigationActionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c91558c267d4f8d3326043b14fef1f4bb7f4c8d74e521cb9e4a358588b4944d3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e72b174e93969881302fd3c868c74b363afd660d5bbcfb58ba4318701c44cad8(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__765f99b3adf47b262cf0eee2dbb6ddecb0116dfee862a309cf58e35456d5e49b(
    *,
    add_things_to_thing_group_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.AddThingsToThingGroupParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    enable_io_t_logging_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.EnableIoTLoggingParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    publish_finding_to_sns_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.PublishFindingToSnsParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    replace_default_policy_version_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.ReplaceDefaultPolicyVersionParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    update_ca_certificate_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.UpdateCACertificateParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    update_device_certificate_params: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnMitigationActionPropsMixin.UpdateDeviceCertificateParamsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65f6ed60bc27dc602355bc3c69be3067930ea99d1182d0ca163206454fe02de6(
    *,
    override_dynamic_groups: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    thing_group_names: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93f3489cd842c5cd0787023017af5e6bf3a0a3f2e3ebe10b117a1e4675dfcef2(
    *,
    log_level: typing.Optional[builtins.str] = None,
    role_arn_for_logging: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f266d758944b700d9e00b91d8eb1e46e63936c30fdb819cafc309d897ff8148(
    *,
    topic_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ce8f000a7cb7cb9e444ca6e8ee2934fbe6d15a640a0e8a265aa5e59e97d1902(
    *,
    template_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbbb7f872c88e4faa8a955e1c752da81dfbe509cf07c4060898768fedee5676e(
    *,
    action: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96c2bd4e280fc7869312bb134b89392ed122c4922bfaf64bffd7b4088cbd73a6(
    *,
    action: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b808fca0e1c8501cdc11b0ba727446ff79da44b63eed42a45d35796a733a88b(
    *,
    policy_document: typing.Any = None,
    policy_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfb48cd026ef2dcfa9861b87f9cc97800de6c87ebbe7efc75fd40c9e5368e99e(
    *,
    policy_name: typing.Optional[builtins.str] = None,
    principal: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d24928a4fee4314a9396580cfc1273c91f05d909a5eaae953bd04c9b5207d8e1(
    props: typing.Union[CfnPolicyPrincipalAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ed4075d27004572d5d10d5a7616994d221c54ba1fd5eb019bdeaf057f454605(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b54f6b1da2100047d40be28262e20542d4fc6a62419e163086fd1a7cc275587(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd58f40bb8b0696c6f4f4d8e60d2a45c419bfa32fc1e7a7cb79f9cca2eae5515(
    props: typing.Union[CfnPolicyMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6457776f8e57e846a2b9664e6e8f65bab904fc3b4f62f37b555a5fe83cbe092d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da7fe80a386a33a866f89fd246f97b08629f0bc9675091b771dc360e6797a5b9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54f2ac30018cc2a04a9f83c8c7eda5dfbb221739198a66a813634404323afd67(
    *,
    description: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    pre_provisioning_hook: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnProvisioningTemplatePropsMixin.ProvisioningHookProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    provisioning_role_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    template_body: typing.Optional[builtins.str] = None,
    template_name: typing.Optional[builtins.str] = None,
    template_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5aba21ff1c16a3c0878f45627eb4ef6933abf844d696ad09fedf2a31c6b1c7a0(
    props: typing.Union[CfnProvisioningTemplateMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b861304960ad303ba727d63e892a60dc5e933e11a2c0daf1ad47bee99209dfb(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7b0ee6b0e936ad1c9ca03567ccbc41adfa84cd928b7967f2c92f1517e892932(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c2158df7cb0e358604e02259b9ead048c93b2a0bbf69b000615b5c5cf40bbfe(
    *,
    payload_version: typing.Optional[builtins.str] = None,
    target_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d83c67145bbd8353159524dc2c91b208602b40a73b3040307f31bbab4e61c0cd(
    *,
    log_level: typing.Optional[builtins.str] = None,
    target_name: typing.Optional[builtins.str] = None,
    target_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f18e7cd515b39934b1b8dbe34ae9e0983a5a48f687d67dfc720d6086824ed97(
    props: typing.Union[CfnResourceSpecificLoggingMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d68dfdffc2b2e2f72162e7e438bdb192cab33c450c51a459e3cd6f6055a88e9b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__044dfae98e2573db1665dab2a77afc6afe8666dda5291f01a54518349bf27a10(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53323d47f3ac0f5eb7669be37b2677cb305285a9a50fdd0812ce17c505d1a85e(
    *,
    credential_duration_seconds: typing.Optional[jsii.Number] = None,
    role_alias: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7901bf0889377480ea0e74b4211cd959da54ef43eff7ce0fd53a1ee8e383bcea(
    props: typing.Union[CfnRoleAliasMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8557fbcc417d7d9b40570874ca6bb93fa0816bcb22b54e799b0264a3a41274d8(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37a12634f009bf2fc094c7c180bc477f8baa2cf55ce01106e4e8fe802f5e0c8d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1ee91a00f9152628adf008e6f8ef0a508720977aedaffa4154f94eabc2f3367(
    *,
    day_of_month: typing.Optional[builtins.str] = None,
    day_of_week: typing.Optional[builtins.str] = None,
    frequency: typing.Optional[builtins.str] = None,
    scheduled_audit_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_check_names: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d601508e0a534dff978a42fe6cec7767b574cc9840aaf566a65631bb9e1d94e4(
    props: typing.Union[CfnScheduledAuditMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fd1aeb5951816c46da455e1faa67b291e713895a80ab27c7d10903e63677f00(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45502f5bfc77a8cc51ce90f2e7dee02571625a8308b12cc98c3626f298b85539(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cd5cabbf6bd7a6a48f0f215589790ff4b6efd3e7766f2362b76950feed3f602(
    *,
    additional_metrics_to_retain_v2: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.MetricToRetainProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    alert_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Mapping[builtins.str, typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.AlertTargetProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    behaviors: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.BehaviorProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    metrics_export_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.MetricsExportConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_profile_description: typing.Optional[builtins.str] = None,
    security_profile_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f53807dc7b8cc63d641c74b3e2e89cd03c8c7d6d323a95f74772c9f68cde6d9c(
    props: typing.Union[CfnSecurityProfileMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31a4d69dfb6fd7ba1d3f7ac3693bec8fdaefa2b20d978f8ffb83d044bc4fb89f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__327cf0745b944c0ce6aa0138bb0b24d6478983543222f746a7643646881f6ac2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8eddc350bb65844c60652598df29d2b1d94d72b00502e72900dd7c36b29af5b7(
    *,
    alert_target_arn: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bf0fa2ef4518c1a20104e3639352fe58069524d24bcf1e77ba6e633ac2b61a2(
    *,
    comparison_operator: typing.Optional[builtins.str] = None,
    consecutive_datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    consecutive_datapoints_to_clear: typing.Optional[jsii.Number] = None,
    duration_seconds: typing.Optional[jsii.Number] = None,
    ml_detection_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.MachineLearningDetectionConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    statistical_threshold: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.StatisticalThresholdProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    value: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.MetricValueProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68168d253bab0cc33e754d8535bf2062764cb2fe7ee4ed148ef20c8a7b8d07f2(
    *,
    criteria: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.BehaviorCriteriaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    export_metric: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    metric: typing.Optional[builtins.str] = None,
    metric_dimension: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.MetricDimensionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[builtins.str] = None,
    suppress_alerts: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e497357f7d31908b0566e95901794535add9692da8a65115d07d5c0be094a60(
    *,
    confidence_level: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c890e5775d2badbc6235afcdc260bce0481c7e4bd8be9f28e04d9d1d4579e83f(
    *,
    dimension_name: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27dccc2f59314822103ff9caaacd9cdeb28eb7a50f2dcc8504dc4bebb78a1a4d(
    *,
    export_metric: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    metric: typing.Optional[builtins.str] = None,
    metric_dimension: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSecurityProfilePropsMixin.MetricDimensionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66582d48116f3b144006693b14eb1aae8baf89dc02c6b7128c48d71e7da91e0e(
    *,
    cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
    count: typing.Optional[builtins.str] = None,
    number: typing.Optional[jsii.Number] = None,
    numbers: typing.Optional[typing.Union[typing.Sequence[jsii.Number], _aws_cdk_ceddda9d.IResolvable]] = None,
    ports: typing.Optional[typing.Union[typing.Sequence[jsii.Number], _aws_cdk_ceddda9d.IResolvable]] = None,
    strings: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__205b3ba4aa26f583a9294a86b2b36e303ce9a8491d84e11b75873428deec1fa1(
    *,
    mqtt_topic: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5efca579bebc261caa670c4cf844e1f6181227aebe7d97ce4ace5f8f6a0e63d1(
    *,
    statistic: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1869b0b282709bd26bf8b18a8e7628640c59ad25eccbb0387e552a4c3169311(
    *,
    description: typing.Optional[builtins.str] = None,
    package_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23d7174ff31e0db0b9b6605c44d7f774c77ca78bbb18f91d262310bdabb0f38b(
    props: typing.Union[CfnSoftwarePackageMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73551716a2bb232a81de44975912b0444c053b0e7949c1e69717354a72702c9d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec3eaccbd784ff59ce2e448d9410991a8c26efb1c8253744bd1bfcbf8139ed28(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f38dfc19187b5fb4176d349fed3d060e257505692a332903233398800dadabf9(
    *,
    artifact: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSoftwarePackageVersionPropsMixin.PackageVersionArtifactProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    attributes: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
    description: typing.Optional[builtins.str] = None,
    package_name: typing.Optional[builtins.str] = None,
    recipe: typing.Optional[builtins.str] = None,
    sbom: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSoftwarePackageVersionPropsMixin.SbomProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38d37038891a68390ce9c76ea640cbeb57f9001928ecc46961e6146eb672ae89(
    props: typing.Union[CfnSoftwarePackageVersionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c67a58d076354c2afe1fd78088d63ec97949fa5cc6899b19d0fe23a73f29e432(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93f21adc30c078bebdde9f9f026c0f0926cd8cc8abfb191da8fff885028d2cf6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0037bbe4ab940285f3f79efb3d4167bbe25c4b35f0e76ce37bb66dabc958ac1(
    *,
    s3_location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSoftwarePackageVersionPropsMixin.S3LocationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2029463f8ebbd92e6be94c11e71b2823e77972c482683d8a0feb6cd9f60dc9f6(
    *,
    bucket: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2561318b4309f98c259871011e1ac9683dd95481041b464dd66b95332b1dbdff(
    *,
    s3_location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnSoftwarePackageVersionPropsMixin.S3LocationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__618a45ccd8056e3248c59a2c2818ecc9b5a5a630ac7ac7e7f4d83244e3d1cc59(
    *,
    parent_group_name: typing.Optional[builtins.str] = None,
    query_string: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    thing_group_name: typing.Optional[builtins.str] = None,
    thing_group_properties: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnThingGroupPropsMixin.ThingGroupPropertiesProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f3df340d4d875e5012c6bc65b5162c4c554a1c8552f78d3735c3e914e0c3624(
    props: typing.Union[CfnThingGroupMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19de54215a737919f8963db2f09904087994d784ff3547be1de067f972da6f0f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9299ec1fc2f94b3c8348a51c1287c3cc34433b0a20d0e1a0e2a899c53d72b3ab(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__062dcdfdcbfdbaadb83cd60a2aa0381c3fc753d3c6fe19ec78bb760b57e388e5(
    *,
    attributes: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7e0de6a1911327ac835e97645d5da087ccf725f931aac818a510b06d9e3b863(
    *,
    attribute_payload: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnThingGroupPropsMixin.AttributePayloadProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    thing_group_description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17984d2f22d0156778b05d1cd3554a781c3ee8c1fc198f426b38b91f60797fba(
    *,
    attribute_payload: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnThingPropsMixin.AttributePayloadProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    thing_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e565a71d14f8170716226b76d70953b85ca6e72be9f8762b41bca5f228367f0(
    *,
    principal: typing.Optional[builtins.str] = None,
    thing_name: typing.Optional[builtins.str] = None,
    thing_principal_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed3376ac55723de5a7182bb336920b6c7f97156986db5a12fc907e9cd8621360(
    props: typing.Union[CfnThingPrincipalAttachmentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd2218eb09fffe711a4367e28bb75f31804bb5fdedb24d0b1bbc6278615ec280(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a979990def0751fdbf538c5456d00e43e2299192770b77c69bf9d826fafdd18(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d6ea5647fd43f2b65b4b9bc38129a97c905922f35b65804888237259f048c51(
    props: typing.Union[CfnThingMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af52519a675719dea0d6c78c43184f69a601923344020628db51bbd9c173434d(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c95a0af05239dfb780d5829c2fba913eed364baa7abdd043f23d4f9302055696(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea7301de30a4a0862a1fb0a3c72a1381605637301c9def60607f1dd53e98dc5c(
    *,
    attributes: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85c49f0301795ffb7cfab2b094e95ddaeda08b4fb393820e43487f0ae1b0d501(
    *,
    deprecate_thing_type: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    thing_type_name: typing.Optional[builtins.str] = None,
    thing_type_properties: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnThingTypePropsMixin.ThingTypePropertiesProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1bb494c036ab3eaf008b783d3d66e1295767f99775ea6a94ab4dea7d800bf02(
    props: typing.Union[CfnThingTypeMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d105e09e131aeca051f244834940d7ce9523b8655c952d67605cb4600ee2fb81(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e219a2c4773a78a193b7d79e6b712b01757f99fc4359ef6dafaa069a5e95d7fe(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f5533b21279300997b36bb5d029382173a433ece44eb5b394ca2e88b33c7b7d(
    *,
    propagating_attributes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnThingTypePropsMixin.PropagatingAttributeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__418bf25ed3a84beea84c0c22271fe26e39c513330abb08f9e584ca7cc1ce121c(
    *,
    connection_attribute: typing.Optional[builtins.str] = None,
    thing_attribute: typing.Optional[builtins.str] = None,
    user_property_key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0add793f003c490b2976bbc5055ad372ae3f3cdec82b02d13bec845f31515ae(
    *,
    mqtt5_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnThingTypePropsMixin.Mqtt5ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    searchable_attributes: typing.Optional[typing.Sequence[builtins.str]] = None,
    thing_type_description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__142e1dd8cee9096451c2e8311c478c1ee5b7dc4440e82fd191b0a4cdd8ff0edf(
    *,
    http_url_properties: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRuleDestinationPropsMixin.HttpUrlDestinationSummaryProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    status: typing.Optional[builtins.str] = None,
    vpc_properties: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRuleDestinationPropsMixin.VpcDestinationPropertiesProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5e8229c7d2c63ebfc0a38faecbe7cac8698cfb84e41f1b821936ab7263fae1a(
    props: typing.Union[CfnTopicRuleDestinationMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc77aaeef64055a7a6cf205e76985374052d4c7168c634fab610a208af3575ce(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cc98ea4b399eac97cb4d53c8da21df62d4f673f4400e87052f92a02eafe8ed2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__649cf4a70a1ad6dfbcb9f552d29ebbb6039251d318f30ebaf4a306efe25c30c1(
    *,
    confirmation_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c4d501bc7a2c98ead89de76d6780a8543eba359902cd6c56245573fa2848320(
    *,
    role_arn: typing.Optional[builtins.str] = None,
    security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    vpc_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5da12e161858141e3f8888dc93a17cd539d06aec7bc3691f4471e0a82e12922(
    *,
    rule_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    topic_rule_payload: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.TopicRulePayloadProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5a3fcaa917c6ab265e5b5219bf547f60c85bfcc5b609f690a8bad7f3de1bddc(
    props: typing.Union[CfnTopicRuleMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c65269687955e541ede51c52c9d136c4bd0177b6f2ced9477f280a5ab4c5345(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21714536c75a963eb607909855450fb7025545c86173425067e0d029b34a2d8b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4250961d0f728dd42397adf406587879400eeb803ec820466043e341062fee9(
    *,
    cloudwatch_alarm: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.CloudwatchAlarmActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cloudwatch_logs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.CloudwatchLogsActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cloudwatch_metric: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.CloudwatchMetricActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    dynamo_db: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.DynamoDBActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    dynamo_d_bv2: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.DynamoDBv2ActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    elasticsearch: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.ElasticsearchActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    firehose: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.FirehoseActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    http: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.HttpActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iot_analytics: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.IotAnalyticsActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iot_events: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.IotEventsActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    iot_site_wise: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.IotSiteWiseActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    kafka: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.KafkaActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    kinesis: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.KinesisActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    lambda_: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.LambdaActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.LocationActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    open_search: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.OpenSearchActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    republish: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.RepublishActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.S3ActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sns: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.SnsActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sqs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.SqsActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    step_functions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.StepFunctionsActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    timestream: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.TimestreamActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac66ca627fe9878e8def5aa10b7c79201fe22422167ddd9ba59184cfc8d72bb7(
    *,
    offset_in_nanos: typing.Optional[builtins.str] = None,
    time_in_seconds: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__033acfaa011aa9492a5a350f649786370635a78713d06b6b2a2695c2491e68a2(
    *,
    quality: typing.Optional[builtins.str] = None,
    timestamp: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.AssetPropertyTimestampProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    value: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.AssetPropertyVariantProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d926b74eb02589ab712da211df35057ae72bc7f4db1b74b4f02466ab8b8c1b05(
    *,
    boolean_value: typing.Optional[builtins.str] = None,
    double_value: typing.Optional[builtins.str] = None,
    integer_value: typing.Optional[builtins.str] = None,
    string_value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f660ab4eeb9ee18337ac5b4e0f5cb210d6fa7d428e799aeb8417d03dfb8598e(
    *,
    max_batch_open_ms: typing.Optional[jsii.Number] = None,
    max_batch_size: typing.Optional[jsii.Number] = None,
    max_batch_size_bytes: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcea33c643e5f662af45146d7c7d6951f631551c6532757aba0d65062358260a(
    *,
    alarm_name: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    state_reason: typing.Optional[builtins.str] = None,
    state_value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbbd133f7cecbcb3cc087bfdcb8835bbdded0c5b8974ca5534fd7f64a03116e2(
    *,
    batch_mode: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    log_group_name: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc1013d3f96561f93ea08229efb4804e57343abf28fbb546ded940458bfc78ba(
    *,
    metric_name: typing.Optional[builtins.str] = None,
    metric_namespace: typing.Optional[builtins.str] = None,
    metric_timestamp: typing.Optional[builtins.str] = None,
    metric_unit: typing.Optional[builtins.str] = None,
    metric_value: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5869903d9e9062c61fd7965ffbc0846f8834bd15d1ff9588baea5fa15cd5e1a(
    *,
    hash_key_field: typing.Optional[builtins.str] = None,
    hash_key_type: typing.Optional[builtins.str] = None,
    hash_key_value: typing.Optional[builtins.str] = None,
    payload_field: typing.Optional[builtins.str] = None,
    range_key_field: typing.Optional[builtins.str] = None,
    range_key_type: typing.Optional[builtins.str] = None,
    range_key_value: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    table_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__289c2c71364f9f602bd1082167d71a7cd02bf832a3b2be6abfab9bf0b458e2af(
    *,
    put_item: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.PutItemInputProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8abdf24255e29936018687e12f28c67d5b7ee9f56d42750e02a89288c8bbe11(
    *,
    endpoint: typing.Optional[builtins.str] = None,
    id: typing.Optional[builtins.str] = None,
    index: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f52ebe6610d03e60a673b85d859e8d46415ffd936e20efb65f7e721865adfca(
    *,
    batch_mode: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    delivery_stream_name: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    separator: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b558f297170f9827d73643fe3a3157df93bdcecc76fdc5a18c7b70e2809722f6(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9d5e39bdf745b367f76ddfb5d1e2ffbd415679b9a12d029987de220a3265503(
    *,
    auth: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.HttpAuthorizationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    batch_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.BatchConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    confirmation_url: typing.Optional[builtins.str] = None,
    enable_batching: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    headers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.HttpActionHeaderProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06b79bd9af0c00128283b3985758a3b41979b30ee5d07ee058bf1920ea0d5d2e(
    *,
    sigv4: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.SigV4AuthorizationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abc5d21f56fc096378bdef84ec00218c2d3da6cad32718ef57ebba982b9da041(
    *,
    batch_mode: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    channel_name: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__454121c75e3d91b85e47c9a647eb516ca17528aa515fc534f431a082dae7ec94(
    *,
    batch_mode: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    input_name: typing.Optional[builtins.str] = None,
    message_id: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfe853ca3f5f4f9530b48cbd2b473172c5bf9c61eaf45bf44e7a9d2d63965b8f(
    *,
    put_asset_property_value_entries: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.PutAssetPropertyValueEntryProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff78de4a183bad9579bd1ae8cc3d7df0ceb3ca278b09bbb7c3fb1684b3298bf3(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1af626a119add27c4c857d0ecc2befaae7e6c405e7495a58d692565f0c229d2(
    *,
    client_properties: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
    destination_arn: typing.Optional[builtins.str] = None,
    headers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.KafkaActionHeaderProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    key: typing.Optional[builtins.str] = None,
    partition: typing.Optional[builtins.str] = None,
    topic: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd2e28691b62b49426b74775f3d5f4c90700274caf142934b40ebf78a9f4a3d5(
    *,
    partition_key: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    stream_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__699f1b0d5283b3f687f69eff90640a2088323d970ecef79ca6e46ec1952f36ae(
    *,
    function_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f619f9aebbf1883c2a75a2a27f8731414df91d47dd3ec8e54a26b2908b4a0ef7(
    *,
    device_id: typing.Optional[builtins.str] = None,
    latitude: typing.Optional[builtins.str] = None,
    longitude: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    timestamp: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.TimestampProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tracker_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c090c0fb8e4ac896e4735c45c3bfb8e307f6de1a3b0c66dac195479fe832e147(
    *,
    endpoint: typing.Optional[builtins.str] = None,
    id: typing.Optional[builtins.str] = None,
    index: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__702785a23884b4ef3426cf86d1be2cca971e6e69ba0b3b722f795292ac7d7eaf(
    *,
    asset_id: typing.Optional[builtins.str] = None,
    entry_id: typing.Optional[builtins.str] = None,
    property_alias: typing.Optional[builtins.str] = None,
    property_id: typing.Optional[builtins.str] = None,
    property_values: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.AssetPropertyValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff0e6a75f6a095e3fef6f99442f7fbe47310b95296759f229e13cdccb8513e6e(
    *,
    table_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08d9c0165aa2ec1002a8f24a0e96c4560d314a87789420a2e9892167fb85b2a5(
    *,
    content_type: typing.Optional[builtins.str] = None,
    correlation_data: typing.Optional[builtins.str] = None,
    message_expiry: typing.Optional[builtins.str] = None,
    payload_format_indicator: typing.Optional[builtins.str] = None,
    response_topic: typing.Optional[builtins.str] = None,
    user_properties: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.UserPropertyProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e368276a280cf3f41cc53ac876bce894fe5235858277e7c5050388590a0fc3db(
    *,
    headers: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.RepublishActionHeadersProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    qos: typing.Optional[jsii.Number] = None,
    role_arn: typing.Optional[builtins.str] = None,
    topic: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d20f94201cb327d87efb266013415608a7c41c255e2d8974672e935fe6800cdb(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
    canned_acl: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b98ade1443ea84fb7563b7079115234284e893332cba045effc7660c865c0feb(
    *,
    role_arn: typing.Optional[builtins.str] = None,
    service_name: typing.Optional[builtins.str] = None,
    signing_region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d8eb4d8ddbc709706040e79b6ad28d33cfacba178873bd75b7bbfedeb03815f(
    *,
    message_format: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    target_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85be1f7a116fcd6cfeb04c8e740bf5075c1b758a62f4af45ab7a06835e110f2a(
    *,
    queue_url: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    use_base64: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e64da73f30da5972e0429b2014d9e02e296509fef067869066a129be58ee7ea3(
    *,
    execution_name_prefix: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    state_machine_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bf3c07d9f67090803b646d78be8ea7367c697f560337680307b182a4f8d1fea(
    *,
    unit: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a9027091210d0318d9c0923a5c5f0bfc14241f0a6113d577f3d95fe204bf337(
    *,
    database_name: typing.Optional[builtins.str] = None,
    dimensions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.TimestreamDimensionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    role_arn: typing.Optional[builtins.str] = None,
    table_name: typing.Optional[builtins.str] = None,
    timestamp: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.TimestreamTimestampProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e888cf062bd1bf59b9adc2260b8d4ba90a0a81a28c78cdb9b0a55551b6f6eda(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ab51005b039854a4132b7857bef0e5ca61ca59b95e1f4b62ac26e9818aeb65e(
    *,
    unit: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2902f22bdaa64d8d1b677b7e186b52e74d8a1f3e9217b7c1b87adc31f13d7811(
    *,
    actions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.ActionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    aws_iot_sql_version: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    error_action: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnTopicRulePropsMixin.ActionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    rule_disabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    sql: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ad7f1dd6700b5ef3bf4132519d88a9e3d5aea98686883b88ed47c25577798bc(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass
