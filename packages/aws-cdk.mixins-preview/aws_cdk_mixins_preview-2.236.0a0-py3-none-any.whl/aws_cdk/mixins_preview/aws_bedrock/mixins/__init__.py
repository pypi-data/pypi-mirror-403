from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ..._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.interfaces.aws_kinesisfirehose as _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d
import aws_cdk.interfaces.aws_logs as _aws_cdk_interfaces_aws_logs_ceddda9d
import aws_cdk.interfaces.aws_s3 as _aws_cdk_interfaces_aws_s3_ceddda9d
import constructs as _constructs_77d1e7e8
from ...aws_logs import ILogsDelivery as _ILogsDelivery_0d3c9e29
from ...core import IMixin as _IMixin_11e4b965, Mixin as _Mixin_a69446c0
from ...mixins import (
    CfnPropertyMixinOptions as _CfnPropertyMixinOptions_9cbff649,
    PropertyMergeStrategy as _PropertyMergeStrategy_49c157e8,
)


class CfnAgentAliasEventLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentAliasEventLogs",
):
    '''Builder for CfnAgentAliasLogsMixin to generate EVENT_LOGS for CfnAgentAlias.

    :cloudformationResource: AWS::Bedrock::AgentAlias
    :logType: EVENT_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_agent_alias_event_logs = bedrock_mixins.CfnAgentAliasEventLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnAgentAliasLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89fe3387100b7fef91f835d4ac67e51d37bce801974e9fc63bc096063eaae034)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnAgentAliasLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnAgentAliasLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0822e466dbe077f51af762b4ffd98d4adb04de281eead916381c9ad178a8d43)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnAgentAliasLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnAgentAliasLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edd80dc0e7f99a00914b172307f25ba8a4bde538313860b19aee33d321fb7aa6)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnAgentAliasLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.implements(_IMixin_11e4b965)
class CfnAgentAliasLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentAliasLogsMixin",
):
    '''Specifies an agent alias as a resource in a top-level template. Minimally, you must specify the following properties:.

    - AgentAliasName – Specify a name for the alias.

    For more information about creating aliases for an agent in Amazon Bedrock , see `Deploy an Amazon Bedrock agent <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-deploy.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html
    :cloudformationResource: AWS::Bedrock::AgentAlias
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_agent_alias_logs_mixin = bedrock_mixins.CfnAgentAliasLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::Bedrock::AgentAlias``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0dfc7504d6bd1e63f0f9b026362c40a22d13b95bb24dac1c86258a5615339d5)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b47512ed5f12ab1ff859562ad2dcde301164852fe589bf0b679052679351e87)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92b917df052bc5cd7eecf47fb6deae8b8e7fa87e01a499b89e293452bbb757bd)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EVENT_LOGS")
    def EVENT_LOGS(cls) -> "CfnAgentAliasEventLogs":
        return typing.cast("CfnAgentAliasEventLogs", jsii.sget(cls, "EVENT_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentAliasMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "agent_alias_name": "agentAliasName",
        "agent_id": "agentId",
        "description": "description",
        "routing_configuration": "routingConfiguration",
        "tags": "tags",
    },
)
class CfnAgentAliasMixinProps:
    def __init__(
        self,
        *,
        agent_alias_name: typing.Optional[builtins.str] = None,
        agent_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        routing_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for CfnAgentAliasPropsMixin.

        :param agent_alias_name: The name of the alias of the agent.
        :param agent_id: The unique identifier of the agent.
        :param description: The description of the alias of the agent.
        :param routing_configuration: Contains details about the routing configuration of the alias.
        :param tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_agent_alias_mixin_props = bedrock_mixins.CfnAgentAliasMixinProps(
                agent_alias_name="agentAliasName",
                agent_id="agentId",
                description="description",
                routing_configuration=[bedrock_mixins.CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty(
                    agent_version="agentVersion"
                )],
                tags={
                    "tags_key": "tags"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef7eb0c31c8ed8ee1f4b6bf2df0d024ccf46ae1c7db5590368504cc1d697a45b)
            check_type(argname="argument agent_alias_name", value=agent_alias_name, expected_type=type_hints["agent_alias_name"])
            check_type(argname="argument agent_id", value=agent_id, expected_type=type_hints["agent_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument routing_configuration", value=routing_configuration, expected_type=type_hints["routing_configuration"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if agent_alias_name is not None:
            self._values["agent_alias_name"] = agent_alias_name
        if agent_id is not None:
            self._values["agent_id"] = agent_id
        if description is not None:
            self._values["description"] = description
        if routing_configuration is not None:
            self._values["routing_configuration"] = routing_configuration
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def agent_alias_name(self) -> typing.Optional[builtins.str]:
        '''The name of the alias of the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html#cfn-bedrock-agentalias-agentaliasname
        '''
        result = self._values.get("agent_alias_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def agent_id(self) -> typing.Optional[builtins.str]:
        '''The unique identifier of the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html#cfn-bedrock-agentalias-agentid
        '''
        result = self._values.get("agent_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the alias of the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html#cfn-bedrock-agentalias-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def routing_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty"]]]]:
        '''Contains details about the routing configuration of the alias.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html#cfn-bedrock-agentalias-routingconfiguration
        '''
        result = self._values.get("routing_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty"]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html#cfn-bedrock-agentalias-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnAgentAliasMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnAgentAliasPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentAliasPropsMixin",
):
    '''Specifies an agent alias as a resource in a top-level template. Minimally, you must specify the following properties:.

    - AgentAliasName – Specify a name for the alias.

    For more information about creating aliases for an agent in Amazon Bedrock , see `Deploy an Amazon Bedrock agent <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-deploy.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html
    :cloudformationResource: AWS::Bedrock::AgentAlias
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_agent_alias_props_mixin = bedrock_mixins.CfnAgentAliasPropsMixin(bedrock_mixins.CfnAgentAliasMixinProps(
            agent_alias_name="agentAliasName",
            agent_id="agentId",
            description="description",
            routing_configuration=[bedrock_mixins.CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty(
                agent_version="agentVersion"
            )],
            tags={
                "tags_key": "tags"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnAgentAliasMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::AgentAlias``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c62ab341e27c90826f848aa5e64ba52709d65e8a2dbc588c98a3d25812645d42)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38b44f3588766120940c93d262e591f95985fb520f0b2735c55a7820ec225d8f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ac233a87a399824eb6e2a0bb509a9a0aca9b669c50f2d9f0f3c0be32dfe7579)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnAgentAliasMixinProps":
        return typing.cast("CfnAgentAliasMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentAliasPropsMixin.AgentAliasHistoryEventProperty",
        jsii_struct_bases=[],
        name_mapping={
            "end_date": "endDate",
            "routing_configuration": "routingConfiguration",
            "start_date": "startDate",
        },
    )
    class AgentAliasHistoryEventProperty:
        def __init__(
            self,
            *,
            end_date: typing.Optional[builtins.str] = None,
            routing_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            start_date: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the history of the alias.

            :param end_date: The date that the alias stopped being associated to the version in the ``routingConfiguration`` object.
            :param routing_configuration: Contains details about the version of the agent with which the alias is associated.
            :param start_date: The date that the alias began being associated to the version in the ``routingConfiguration`` object.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliashistoryevent.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_alias_history_event_property = bedrock_mixins.CfnAgentAliasPropsMixin.AgentAliasHistoryEventProperty(
                    end_date="endDate",
                    routing_configuration=[bedrock_mixins.CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty(
                        agent_version="agentVersion"
                    )],
                    start_date="startDate"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__acce48cec56537cd7dcd965c93f022d2203d2c1684e85cf1a13120ad7a88f010)
                check_type(argname="argument end_date", value=end_date, expected_type=type_hints["end_date"])
                check_type(argname="argument routing_configuration", value=routing_configuration, expected_type=type_hints["routing_configuration"])
                check_type(argname="argument start_date", value=start_date, expected_type=type_hints["start_date"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if end_date is not None:
                self._values["end_date"] = end_date
            if routing_configuration is not None:
                self._values["routing_configuration"] = routing_configuration
            if start_date is not None:
                self._values["start_date"] = start_date

        @builtins.property
        def end_date(self) -> typing.Optional[builtins.str]:
            '''The date that the alias stopped being associated to the version in the ``routingConfiguration`` object.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliashistoryevent.html#cfn-bedrock-agentalias-agentaliashistoryevent-enddate
            '''
            result = self._values.get("end_date")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def routing_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty"]]]]:
            '''Contains details about the version of the agent with which the alias is associated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliashistoryevent.html#cfn-bedrock-agentalias-agentaliashistoryevent-routingconfiguration
            '''
            result = self._values.get("routing_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty"]]]], result)

        @builtins.property
        def start_date(self) -> typing.Optional[builtins.str]:
            '''The date that the alias began being associated to the version in the ``routingConfiguration`` object.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliashistoryevent.html#cfn-bedrock-agentalias-agentaliashistoryevent-startdate
            '''
            result = self._values.get("start_date")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentAliasHistoryEventProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty",
        jsii_struct_bases=[],
        name_mapping={"agent_version": "agentVersion"},
    )
    class AgentAliasRoutingConfigurationListItemProperty:
        def __init__(
            self,
            *,
            agent_version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the routing configuration of the alias.

            :param agent_version: The version of the agent with which the alias is associated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliasroutingconfigurationlistitem.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_alias_routing_configuration_list_item_property = bedrock_mixins.CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty(
                    agent_version="agentVersion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5799748ad012431ec1ed959b343efbb67e1709829130ea661cf229d8515c42d7)
                check_type(argname="argument agent_version", value=agent_version, expected_type=type_hints["agent_version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent_version is not None:
                self._values["agent_version"] = agent_version

        @builtins.property
        def agent_version(self) -> typing.Optional[builtins.str]:
            '''The version of the agent with which the alias is associated.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliasroutingconfigurationlistitem.html#cfn-bedrock-agentalias-agentaliasroutingconfigurationlistitem-agentversion
            '''
            result = self._values.get("agent_version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentAliasRoutingConfigurationListItemProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class CfnAgentApplicationLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentApplicationLogs",
):
    '''Builder for CfnAgentLogsMixin to generate APPLICATION_LOGS for CfnAgent.

    :cloudformationResource: AWS::Bedrock::Agent
    :logType: APPLICATION_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_agent_application_logs = bedrock_mixins.CfnAgentApplicationLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnAgentLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__668759f73023546dafab6830da9d9a44f666c4ce5ce44310cd7c2f5b20b81c51)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnAgentLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnAgentLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3acdd3056fd1e4fe07fdba191d267e85d58b79ae5cd53a6c31a92c14a325c393)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnAgentLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnAgentLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7cb005d92fbe0909b5e12178b9f22003bc5dbac9089ff567f5974729e18e0ff7)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnAgentLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.implements(_IMixin_11e4b965)
class CfnAgentLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentLogsMixin",
):
    '''Specifies an agent as a resource in a top-level template. Minimally, you must specify the following properties:.

    - AgentName – Specify a name for the agent.
    - AgentResourceRoleArn – Specify the Amazon Resource Name (ARN) of the service role with permissions to invoke API operations on the agent. For more information, see `Create a service role for Agents for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-permissions.html>`_ .
    - FoundationModel – Specify the model ID of a foundation model to use when invoking the agent. For more information, see `Supported regions and models for Agents for Amazon Bedrock <https://docs.aws.amazon.com//bedrock/latest/userguide/agents-supported.html>`_ .

    For more information about using agents in Amazon Bedrock , see `Agents for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html
    :cloudformationResource: AWS::Bedrock::Agent
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_agent_logs_mixin = bedrock_mixins.CfnAgentLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::Bedrock::Agent``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cbd06c78abcc78331db5ac9be0fdbf5e9781fb8372e3097f56896a00c68916d)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f50240ae7219a5ed674964ce0fadf836b752680cf01a226b2965968753c44ad)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfce9bb2653f196155d15a3ab3e29d6a2aa78c78f5f1a2d5c5299f6b5544df1e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_LOGS")
    def APPLICATION_LOGS(cls) -> "CfnAgentApplicationLogs":
        return typing.cast("CfnAgentApplicationLogs", jsii.sget(cls, "APPLICATION_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "action_groups": "actionGroups",
        "agent_collaboration": "agentCollaboration",
        "agent_collaborators": "agentCollaborators",
        "agent_name": "agentName",
        "agent_resource_role_arn": "agentResourceRoleArn",
        "auto_prepare": "autoPrepare",
        "customer_encryption_key_arn": "customerEncryptionKeyArn",
        "custom_orchestration": "customOrchestration",
        "description": "description",
        "foundation_model": "foundationModel",
        "guardrail_configuration": "guardrailConfiguration",
        "idle_session_ttl_in_seconds": "idleSessionTtlInSeconds",
        "instruction": "instruction",
        "knowledge_bases": "knowledgeBases",
        "memory_configuration": "memoryConfiguration",
        "orchestration_type": "orchestrationType",
        "prompt_override_configuration": "promptOverrideConfiguration",
        "skip_resource_in_use_check_on_delete": "skipResourceInUseCheckOnDelete",
        "tags": "tags",
        "test_alias_tags": "testAliasTags",
    },
)
class CfnAgentMixinProps:
    def __init__(
        self,
        *,
        action_groups: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.AgentActionGroupProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        agent_collaboration: typing.Optional[builtins.str] = None,
        agent_collaborators: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.AgentCollaboratorProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        agent_name: typing.Optional[builtins.str] = None,
        agent_resource_role_arn: typing.Optional[builtins.str] = None,
        auto_prepare: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        customer_encryption_key_arn: typing.Optional[builtins.str] = None,
        custom_orchestration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.CustomOrchestrationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        foundation_model: typing.Optional[builtins.str] = None,
        guardrail_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.GuardrailConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        idle_session_ttl_in_seconds: typing.Optional[jsii.Number] = None,
        instruction: typing.Optional[builtins.str] = None,
        knowledge_bases: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.AgentKnowledgeBaseProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        memory_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.MemoryConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        orchestration_type: typing.Optional[builtins.str] = None,
        prompt_override_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.PromptOverrideConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        skip_resource_in_use_check_on_delete: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        test_alias_tags: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
    ) -> None:
        '''Properties for CfnAgentPropsMixin.

        :param action_groups: The action groups that belong to an agent.
        :param agent_collaboration: The agent's collaboration settings.
        :param agent_collaborators: List of Agent Collaborators.
        :param agent_name: The name of the agent.
        :param agent_resource_role_arn: The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        :param auto_prepare: Specifies whether to automatically update the ``DRAFT`` version of the agent after making changes to the agent. The ``DRAFT`` version can be continually iterated upon during internal development. By default, this value is ``false`` . Default: - false
        :param customer_encryption_key_arn: The Amazon Resource Name (ARN) of the AWS key that encrypts the agent.
        :param custom_orchestration: Contains custom orchestration configurations for the agent.
        :param description: The description of the agent.
        :param foundation_model: The foundation model used for orchestration by the agent.
        :param guardrail_configuration: Details about the guardrail associated with the agent.
        :param idle_session_ttl_in_seconds: The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        :param instruction: Instructions that tell the agent what it should do and how it should interact with users.
        :param knowledge_bases: The knowledge bases associated with the agent.
        :param memory_configuration: Contains memory configuration for the agent.
        :param orchestration_type: Specifies the orchestration strategy for the agent.
        :param prompt_override_configuration: Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .
        :param skip_resource_in_use_check_on_delete: Specifies whether to delete the resource even if it's in use. By default, this value is ``false`` . Default: - false
        :param tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_
        :param test_alias_tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            # additional_model_request_fields: Any
            
            cfn_agent_mixin_props = bedrock_mixins.CfnAgentMixinProps(
                action_groups=[bedrock_mixins.CfnAgentPropsMixin.AgentActionGroupProperty(
                    action_group_executor=bedrock_mixins.CfnAgentPropsMixin.ActionGroupExecutorProperty(
                        custom_control="customControl",
                        lambda_="lambda"
                    ),
                    action_group_name="actionGroupName",
                    action_group_state="actionGroupState",
                    api_schema=bedrock_mixins.CfnAgentPropsMixin.APISchemaProperty(
                        payload="payload",
                        s3=bedrock_mixins.CfnAgentPropsMixin.S3IdentifierProperty(
                            s3_bucket_name="s3BucketName",
                            s3_object_key="s3ObjectKey"
                        )
                    ),
                    description="description",
                    function_schema=bedrock_mixins.CfnAgentPropsMixin.FunctionSchemaProperty(
                        functions=[bedrock_mixins.CfnAgentPropsMixin.FunctionProperty(
                            description="description",
                            name="name",
                            parameters={
                                "parameters_key": bedrock_mixins.CfnAgentPropsMixin.ParameterDetailProperty(
                                    description="description",
                                    required=False,
                                    type="type"
                                )
                            },
                            require_confirmation="requireConfirmation"
                        )]
                    ),
                    parent_action_group_signature="parentActionGroupSignature",
                    skip_resource_in_use_check_on_delete=False
                )],
                agent_collaboration="agentCollaboration",
                agent_collaborators=[bedrock_mixins.CfnAgentPropsMixin.AgentCollaboratorProperty(
                    agent_descriptor=bedrock_mixins.CfnAgentPropsMixin.AgentDescriptorProperty(
                        alias_arn="aliasArn"
                    ),
                    collaboration_instruction="collaborationInstruction",
                    collaborator_name="collaboratorName",
                    relay_conversation_history="relayConversationHistory"
                )],
                agent_name="agentName",
                agent_resource_role_arn="agentResourceRoleArn",
                auto_prepare=False,
                customer_encryption_key_arn="customerEncryptionKeyArn",
                custom_orchestration=bedrock_mixins.CfnAgentPropsMixin.CustomOrchestrationProperty(
                    executor=bedrock_mixins.CfnAgentPropsMixin.OrchestrationExecutorProperty(
                        lambda_="lambda"
                    )
                ),
                description="description",
                foundation_model="foundationModel",
                guardrail_configuration=bedrock_mixins.CfnAgentPropsMixin.GuardrailConfigurationProperty(
                    guardrail_identifier="guardrailIdentifier",
                    guardrail_version="guardrailVersion"
                ),
                idle_session_ttl_in_seconds=123,
                instruction="instruction",
                knowledge_bases=[bedrock_mixins.CfnAgentPropsMixin.AgentKnowledgeBaseProperty(
                    description="description",
                    knowledge_base_id="knowledgeBaseId",
                    knowledge_base_state="knowledgeBaseState"
                )],
                memory_configuration=bedrock_mixins.CfnAgentPropsMixin.MemoryConfigurationProperty(
                    enabled_memory_types=["enabledMemoryTypes"],
                    session_summary_configuration=bedrock_mixins.CfnAgentPropsMixin.SessionSummaryConfigurationProperty(
                        max_recent_sessions=123
                    ),
                    storage_days=123
                ),
                orchestration_type="orchestrationType",
                prompt_override_configuration=bedrock_mixins.CfnAgentPropsMixin.PromptOverrideConfigurationProperty(
                    override_lambda="overrideLambda",
                    prompt_configurations=[bedrock_mixins.CfnAgentPropsMixin.PromptConfigurationProperty(
                        additional_model_request_fields=additional_model_request_fields,
                        base_prompt_template="basePromptTemplate",
                        foundation_model="foundationModel",
                        inference_configuration=bedrock_mixins.CfnAgentPropsMixin.InferenceConfigurationProperty(
                            maximum_length=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_k=123,
                            top_p=123
                        ),
                        parser_mode="parserMode",
                        prompt_creation_mode="promptCreationMode",
                        prompt_state="promptState",
                        prompt_type="promptType"
                    )]
                ),
                skip_resource_in_use_check_on_delete=False,
                tags={
                    "tags_key": "tags"
                },
                test_alias_tags={
                    "test_alias_tags_key": "testAliasTags"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81096f663dfd53883abdba5d814904047cf7dc4a430d759e9cb0610273e5e1a6)
            check_type(argname="argument action_groups", value=action_groups, expected_type=type_hints["action_groups"])
            check_type(argname="argument agent_collaboration", value=agent_collaboration, expected_type=type_hints["agent_collaboration"])
            check_type(argname="argument agent_collaborators", value=agent_collaborators, expected_type=type_hints["agent_collaborators"])
            check_type(argname="argument agent_name", value=agent_name, expected_type=type_hints["agent_name"])
            check_type(argname="argument agent_resource_role_arn", value=agent_resource_role_arn, expected_type=type_hints["agent_resource_role_arn"])
            check_type(argname="argument auto_prepare", value=auto_prepare, expected_type=type_hints["auto_prepare"])
            check_type(argname="argument customer_encryption_key_arn", value=customer_encryption_key_arn, expected_type=type_hints["customer_encryption_key_arn"])
            check_type(argname="argument custom_orchestration", value=custom_orchestration, expected_type=type_hints["custom_orchestration"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument foundation_model", value=foundation_model, expected_type=type_hints["foundation_model"])
            check_type(argname="argument guardrail_configuration", value=guardrail_configuration, expected_type=type_hints["guardrail_configuration"])
            check_type(argname="argument idle_session_ttl_in_seconds", value=idle_session_ttl_in_seconds, expected_type=type_hints["idle_session_ttl_in_seconds"])
            check_type(argname="argument instruction", value=instruction, expected_type=type_hints["instruction"])
            check_type(argname="argument knowledge_bases", value=knowledge_bases, expected_type=type_hints["knowledge_bases"])
            check_type(argname="argument memory_configuration", value=memory_configuration, expected_type=type_hints["memory_configuration"])
            check_type(argname="argument orchestration_type", value=orchestration_type, expected_type=type_hints["orchestration_type"])
            check_type(argname="argument prompt_override_configuration", value=prompt_override_configuration, expected_type=type_hints["prompt_override_configuration"])
            check_type(argname="argument skip_resource_in_use_check_on_delete", value=skip_resource_in_use_check_on_delete, expected_type=type_hints["skip_resource_in_use_check_on_delete"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument test_alias_tags", value=test_alias_tags, expected_type=type_hints["test_alias_tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if action_groups is not None:
            self._values["action_groups"] = action_groups
        if agent_collaboration is not None:
            self._values["agent_collaboration"] = agent_collaboration
        if agent_collaborators is not None:
            self._values["agent_collaborators"] = agent_collaborators
        if agent_name is not None:
            self._values["agent_name"] = agent_name
        if agent_resource_role_arn is not None:
            self._values["agent_resource_role_arn"] = agent_resource_role_arn
        if auto_prepare is not None:
            self._values["auto_prepare"] = auto_prepare
        if customer_encryption_key_arn is not None:
            self._values["customer_encryption_key_arn"] = customer_encryption_key_arn
        if custom_orchestration is not None:
            self._values["custom_orchestration"] = custom_orchestration
        if description is not None:
            self._values["description"] = description
        if foundation_model is not None:
            self._values["foundation_model"] = foundation_model
        if guardrail_configuration is not None:
            self._values["guardrail_configuration"] = guardrail_configuration
        if idle_session_ttl_in_seconds is not None:
            self._values["idle_session_ttl_in_seconds"] = idle_session_ttl_in_seconds
        if instruction is not None:
            self._values["instruction"] = instruction
        if knowledge_bases is not None:
            self._values["knowledge_bases"] = knowledge_bases
        if memory_configuration is not None:
            self._values["memory_configuration"] = memory_configuration
        if orchestration_type is not None:
            self._values["orchestration_type"] = orchestration_type
        if prompt_override_configuration is not None:
            self._values["prompt_override_configuration"] = prompt_override_configuration
        if skip_resource_in_use_check_on_delete is not None:
            self._values["skip_resource_in_use_check_on_delete"] = skip_resource_in_use_check_on_delete
        if tags is not None:
            self._values["tags"] = tags
        if test_alias_tags is not None:
            self._values["test_alias_tags"] = test_alias_tags

    @builtins.property
    def action_groups(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentActionGroupProperty"]]]]:
        '''The action groups that belong to an agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-actiongroups
        '''
        result = self._values.get("action_groups")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentActionGroupProperty"]]]], result)

    @builtins.property
    def agent_collaboration(self) -> typing.Optional[builtins.str]:
        '''The agent's collaboration settings.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-agentcollaboration
        '''
        result = self._values.get("agent_collaboration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def agent_collaborators(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentCollaboratorProperty"]]]]:
        '''List of Agent Collaborators.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-agentcollaborators
        '''
        result = self._values.get("agent_collaborators")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentCollaboratorProperty"]]]], result)

    @builtins.property
    def agent_name(self) -> typing.Optional[builtins.str]:
        '''The name of the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-agentname
        '''
        result = self._values.get("agent_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def agent_resource_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-agentresourcerolearn
        '''
        result = self._values.get("agent_resource_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auto_prepare(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Specifies whether to automatically update the ``DRAFT`` version of the agent after making changes to the agent.

        The ``DRAFT`` version can be continually iterated upon during internal development. By default, this value is ``false`` .

        :default: - false

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-autoprepare
        '''
        result = self._values.get("auto_prepare")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def customer_encryption_key_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the AWS  key that encrypts the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-customerencryptionkeyarn
        '''
        result = self._values.get("customer_encryption_key_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_orchestration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.CustomOrchestrationProperty"]]:
        '''Contains custom orchestration configurations for the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-customorchestration
        '''
        result = self._values.get("custom_orchestration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.CustomOrchestrationProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def foundation_model(self) -> typing.Optional[builtins.str]:
        '''The foundation model used for orchestration by the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-foundationmodel
        '''
        result = self._values.get("foundation_model")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def guardrail_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.GuardrailConfigurationProperty"]]:
        '''Details about the guardrail associated with the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-guardrailconfiguration
        '''
        result = self._values.get("guardrail_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.GuardrailConfigurationProperty"]], result)

    @builtins.property
    def idle_session_ttl_in_seconds(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent.

        A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-idlesessionttlinseconds
        '''
        result = self._values.get("idle_session_ttl_in_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instruction(self) -> typing.Optional[builtins.str]:
        '''Instructions that tell the agent what it should do and how it should interact with users.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-instruction
        '''
        result = self._values.get("instruction")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def knowledge_bases(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentKnowledgeBaseProperty"]]]]:
        '''The knowledge bases associated with the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-knowledgebases
        '''
        result = self._values.get("knowledge_bases")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentKnowledgeBaseProperty"]]]], result)

    @builtins.property
    def memory_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.MemoryConfigurationProperty"]]:
        '''Contains memory configuration for the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-memoryconfiguration
        '''
        result = self._values.get("memory_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.MemoryConfigurationProperty"]], result)

    @builtins.property
    def orchestration_type(self) -> typing.Optional[builtins.str]:
        '''Specifies the orchestration strategy for the agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-orchestrationtype
        '''
        result = self._values.get("orchestration_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prompt_override_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.PromptOverrideConfigurationProperty"]]:
        '''Contains configurations to override prompt templates in different parts of an agent sequence.

        For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-promptoverrideconfiguration
        '''
        result = self._values.get("prompt_override_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.PromptOverrideConfigurationProperty"]], result)

    @builtins.property
    def skip_resource_in_use_check_on_delete(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Specifies whether to delete the resource even if it's in use.

        By default, this value is ``false`` .

        :default: - false

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-skipresourceinusecheckondelete
        '''
        result = self._values.get("skip_resource_in_use_check_on_delete")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def test_alias_tags(
        self,
    ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html#cfn-bedrock-agent-testaliastags
        '''
        result = self._values.get("test_alias_tags")
        return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnAgentMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnAgentPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin",
):
    '''Specifies an agent as a resource in a top-level template. Minimally, you must specify the following properties:.

    - AgentName – Specify a name for the agent.
    - AgentResourceRoleArn – Specify the Amazon Resource Name (ARN) of the service role with permissions to invoke API operations on the agent. For more information, see `Create a service role for Agents for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-permissions.html>`_ .
    - FoundationModel – Specify the model ID of a foundation model to use when invoking the agent. For more information, see `Supported regions and models for Agents for Amazon Bedrock <https://docs.aws.amazon.com//bedrock/latest/userguide/agents-supported.html>`_ .

    For more information about using agents in Amazon Bedrock , see `Agents for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html
    :cloudformationResource: AWS::Bedrock::Agent
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # additional_model_request_fields: Any
        
        cfn_agent_props_mixin = bedrock_mixins.CfnAgentPropsMixin(bedrock_mixins.CfnAgentMixinProps(
            action_groups=[bedrock_mixins.CfnAgentPropsMixin.AgentActionGroupProperty(
                action_group_executor=bedrock_mixins.CfnAgentPropsMixin.ActionGroupExecutorProperty(
                    custom_control="customControl",
                    lambda_="lambda"
                ),
                action_group_name="actionGroupName",
                action_group_state="actionGroupState",
                api_schema=bedrock_mixins.CfnAgentPropsMixin.APISchemaProperty(
                    payload="payload",
                    s3=bedrock_mixins.CfnAgentPropsMixin.S3IdentifierProperty(
                        s3_bucket_name="s3BucketName",
                        s3_object_key="s3ObjectKey"
                    )
                ),
                description="description",
                function_schema=bedrock_mixins.CfnAgentPropsMixin.FunctionSchemaProperty(
                    functions=[bedrock_mixins.CfnAgentPropsMixin.FunctionProperty(
                        description="description",
                        name="name",
                        parameters={
                            "parameters_key": bedrock_mixins.CfnAgentPropsMixin.ParameterDetailProperty(
                                description="description",
                                required=False,
                                type="type"
                            )
                        },
                        require_confirmation="requireConfirmation"
                    )]
                ),
                parent_action_group_signature="parentActionGroupSignature",
                skip_resource_in_use_check_on_delete=False
            )],
            agent_collaboration="agentCollaboration",
            agent_collaborators=[bedrock_mixins.CfnAgentPropsMixin.AgentCollaboratorProperty(
                agent_descriptor=bedrock_mixins.CfnAgentPropsMixin.AgentDescriptorProperty(
                    alias_arn="aliasArn"
                ),
                collaboration_instruction="collaborationInstruction",
                collaborator_name="collaboratorName",
                relay_conversation_history="relayConversationHistory"
            )],
            agent_name="agentName",
            agent_resource_role_arn="agentResourceRoleArn",
            auto_prepare=False,
            customer_encryption_key_arn="customerEncryptionKeyArn",
            custom_orchestration=bedrock_mixins.CfnAgentPropsMixin.CustomOrchestrationProperty(
                executor=bedrock_mixins.CfnAgentPropsMixin.OrchestrationExecutorProperty(
                    lambda_="lambda"
                )
            ),
            description="description",
            foundation_model="foundationModel",
            guardrail_configuration=bedrock_mixins.CfnAgentPropsMixin.GuardrailConfigurationProperty(
                guardrail_identifier="guardrailIdentifier",
                guardrail_version="guardrailVersion"
            ),
            idle_session_ttl_in_seconds=123,
            instruction="instruction",
            knowledge_bases=[bedrock_mixins.CfnAgentPropsMixin.AgentKnowledgeBaseProperty(
                description="description",
                knowledge_base_id="knowledgeBaseId",
                knowledge_base_state="knowledgeBaseState"
            )],
            memory_configuration=bedrock_mixins.CfnAgentPropsMixin.MemoryConfigurationProperty(
                enabled_memory_types=["enabledMemoryTypes"],
                session_summary_configuration=bedrock_mixins.CfnAgentPropsMixin.SessionSummaryConfigurationProperty(
                    max_recent_sessions=123
                ),
                storage_days=123
            ),
            orchestration_type="orchestrationType",
            prompt_override_configuration=bedrock_mixins.CfnAgentPropsMixin.PromptOverrideConfigurationProperty(
                override_lambda="overrideLambda",
                prompt_configurations=[bedrock_mixins.CfnAgentPropsMixin.PromptConfigurationProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    base_prompt_template="basePromptTemplate",
                    foundation_model="foundationModel",
                    inference_configuration=bedrock_mixins.CfnAgentPropsMixin.InferenceConfigurationProperty(
                        maximum_length=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_k=123,
                        top_p=123
                    ),
                    parser_mode="parserMode",
                    prompt_creation_mode="promptCreationMode",
                    prompt_state="promptState",
                    prompt_type="promptType"
                )]
            ),
            skip_resource_in_use_check_on_delete=False,
            tags={
                "tags_key": "tags"
            },
            test_alias_tags={
                "test_alias_tags_key": "testAliasTags"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnAgentMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::Agent``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13f7c49281453536c9114548e63a8faee493f76e3207419bf4c13c388f255809)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8414dffb43925b5fe4fa882cab91b3a07c5bbc837879036907899c0cd92dacf3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcd36a2c21e07d8b6153b44fe42068cebdab263dbe39c7967b3f45f402e42208)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnAgentMixinProps":
        return typing.cast("CfnAgentMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.APISchemaProperty",
        jsii_struct_bases=[],
        name_mapping={"payload": "payload", "s3": "s3"},
    )
    class APISchemaProperty:
        def __init__(
            self,
            *,
            payload: typing.Optional[builtins.str] = None,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.S3IdentifierProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains details about the OpenAPI schema for the action group.

            For more information, see `Action group OpenAPI schemas <https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html>`_ . You can either include the schema directly in the payload field or you can upload it to an S3 bucket and specify the S3 bucket location in the s3 field.

            :param payload: The JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
            :param s3: Contains details about the S3 object containing the OpenAPI schema for the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-apischema.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                a_pISchema_property = bedrock_mixins.CfnAgentPropsMixin.APISchemaProperty(
                    payload="payload",
                    s3=bedrock_mixins.CfnAgentPropsMixin.S3IdentifierProperty(
                        s3_bucket_name="s3BucketName",
                        s3_object_key="s3ObjectKey"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8d00895015dcec2190210aafae1ab997d7891d8a4117e6a4f937c4260f61f4ac)
                check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if payload is not None:
                self._values["payload"] = payload
            if s3 is not None:
                self._values["s3"] = s3

        @builtins.property
        def payload(self) -> typing.Optional[builtins.str]:
            '''The JSON or YAML-formatted payload defining the OpenAPI schema for the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-apischema.html#cfn-bedrock-agent-apischema-payload
            '''
            result = self._values.get("payload")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.S3IdentifierProperty"]]:
            '''Contains details about the S3 object containing the OpenAPI schema for the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-apischema.html#cfn-bedrock-agent-apischema-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.S3IdentifierProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "APISchemaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.ActionGroupExecutorProperty",
        jsii_struct_bases=[],
        name_mapping={"custom_control": "customControl", "lambda_": "lambda"},
    )
    class ActionGroupExecutorProperty:
        def __init__(
            self,
            *,
            custom_control: typing.Optional[builtins.str] = None,
            lambda_: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.

            :param custom_control: To return the action group invocation results directly in the ``InvokeInlineAgent`` response, specify ``RETURN_CONTROL`` .
            :param lambda_: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-actiongroupexecutor.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                action_group_executor_property = bedrock_mixins.CfnAgentPropsMixin.ActionGroupExecutorProperty(
                    custom_control="customControl",
                    lambda_="lambda"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__de1ee9ae7245cc7d40afcd41819ed45e7351e075e5f730bf4c1e7d1999ecd351)
                check_type(argname="argument custom_control", value=custom_control, expected_type=type_hints["custom_control"])
                check_type(argname="argument lambda_", value=lambda_, expected_type=type_hints["lambda_"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if custom_control is not None:
                self._values["custom_control"] = custom_control
            if lambda_ is not None:
                self._values["lambda_"] = lambda_

        @builtins.property
        def custom_control(self) -> typing.Optional[builtins.str]:
            '''To return the action group invocation results directly in the ``InvokeInlineAgent`` response, specify ``RETURN_CONTROL`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-actiongroupexecutor.html#cfn-bedrock-agent-actiongroupexecutor-customcontrol
            '''
            result = self._values.get("custom_control")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def lambda_(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-actiongroupexecutor.html#cfn-bedrock-agent-actiongroupexecutor-lambda
            '''
            result = self._values.get("lambda_")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ActionGroupExecutorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.AgentActionGroupProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action_group_executor": "actionGroupExecutor",
            "action_group_name": "actionGroupName",
            "action_group_state": "actionGroupState",
            "api_schema": "apiSchema",
            "description": "description",
            "function_schema": "functionSchema",
            "parent_action_group_signature": "parentActionGroupSignature",
            "skip_resource_in_use_check_on_delete": "skipResourceInUseCheckOnDelete",
        },
    )
    class AgentActionGroupProperty:
        def __init__(
            self,
            *,
            action_group_executor: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.ActionGroupExecutorProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            action_group_name: typing.Optional[builtins.str] = None,
            action_group_state: typing.Optional[builtins.str] = None,
            api_schema: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.APISchemaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            description: typing.Optional[builtins.str] = None,
            function_schema: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.FunctionSchemaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            parent_action_group_signature: typing.Optional[builtins.str] = None,
            skip_resource_in_use_check_on_delete: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        ) -> None:
            '''Contains details of the inline agent's action group.

            :param action_group_executor: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
            :param action_group_name: The name of the action group.
            :param action_group_state: Specifies whether the action group is available for the agent to invoke or not when sending an `InvokeAgent <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html>`_ request.
            :param api_schema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see `Action group OpenAPI schemas <https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html>`_ .
            :param description: A description of the action group.
            :param function_schema: Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
            :param parent_action_group_signature: If this field is set as ``AMAZON.UserInput`` , the agent can request the user for additional information when trying to complete a task. The ``description`` , ``apiSchema`` , and ``actionGroupExecutor`` fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an `Observation <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html>`_ reprompting the user for more information.
            :param skip_resource_in_use_check_on_delete: Specifies whether to delete the resource even if it's in use. By default, this value is ``false`` . Default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_action_group_property = bedrock_mixins.CfnAgentPropsMixin.AgentActionGroupProperty(
                    action_group_executor=bedrock_mixins.CfnAgentPropsMixin.ActionGroupExecutorProperty(
                        custom_control="customControl",
                        lambda_="lambda"
                    ),
                    action_group_name="actionGroupName",
                    action_group_state="actionGroupState",
                    api_schema=bedrock_mixins.CfnAgentPropsMixin.APISchemaProperty(
                        payload="payload",
                        s3=bedrock_mixins.CfnAgentPropsMixin.S3IdentifierProperty(
                            s3_bucket_name="s3BucketName",
                            s3_object_key="s3ObjectKey"
                        )
                    ),
                    description="description",
                    function_schema=bedrock_mixins.CfnAgentPropsMixin.FunctionSchemaProperty(
                        functions=[bedrock_mixins.CfnAgentPropsMixin.FunctionProperty(
                            description="description",
                            name="name",
                            parameters={
                                "parameters_key": bedrock_mixins.CfnAgentPropsMixin.ParameterDetailProperty(
                                    description="description",
                                    required=False,
                                    type="type"
                                )
                            },
                            require_confirmation="requireConfirmation"
                        )]
                    ),
                    parent_action_group_signature="parentActionGroupSignature",
                    skip_resource_in_use_check_on_delete=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fdad78b6cbb091ba8ff6c95b5c60e41ea88d1d2d16621805f58e81759bb6d5d2)
                check_type(argname="argument action_group_executor", value=action_group_executor, expected_type=type_hints["action_group_executor"])
                check_type(argname="argument action_group_name", value=action_group_name, expected_type=type_hints["action_group_name"])
                check_type(argname="argument action_group_state", value=action_group_state, expected_type=type_hints["action_group_state"])
                check_type(argname="argument api_schema", value=api_schema, expected_type=type_hints["api_schema"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument function_schema", value=function_schema, expected_type=type_hints["function_schema"])
                check_type(argname="argument parent_action_group_signature", value=parent_action_group_signature, expected_type=type_hints["parent_action_group_signature"])
                check_type(argname="argument skip_resource_in_use_check_on_delete", value=skip_resource_in_use_check_on_delete, expected_type=type_hints["skip_resource_in_use_check_on_delete"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action_group_executor is not None:
                self._values["action_group_executor"] = action_group_executor
            if action_group_name is not None:
                self._values["action_group_name"] = action_group_name
            if action_group_state is not None:
                self._values["action_group_state"] = action_group_state
            if api_schema is not None:
                self._values["api_schema"] = api_schema
            if description is not None:
                self._values["description"] = description
            if function_schema is not None:
                self._values["function_schema"] = function_schema
            if parent_action_group_signature is not None:
                self._values["parent_action_group_signature"] = parent_action_group_signature
            if skip_resource_in_use_check_on_delete is not None:
                self._values["skip_resource_in_use_check_on_delete"] = skip_resource_in_use_check_on_delete

        @builtins.property
        def action_group_executor(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.ActionGroupExecutorProperty"]]:
            '''The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-actiongroupexecutor
            '''
            result = self._values.get("action_group_executor")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.ActionGroupExecutorProperty"]], result)

        @builtins.property
        def action_group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-actiongroupname
            '''
            result = self._values.get("action_group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def action_group_state(self) -> typing.Optional[builtins.str]:
            '''Specifies whether the action group is available for the agent to invoke or not when sending an `InvokeAgent <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html>`_ request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-actiongroupstate
            '''
            result = self._values.get("action_group_state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def api_schema(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.APISchemaProperty"]]:
            '''Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema.

            For more information, see `Action group OpenAPI schemas <https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-apischema
            '''
            result = self._values.get("api_schema")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.APISchemaProperty"]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def function_schema(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.FunctionSchemaProperty"]]:
            '''Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-functionschema
            '''
            result = self._values.get("function_schema")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.FunctionSchemaProperty"]], result)

        @builtins.property
        def parent_action_group_signature(self) -> typing.Optional[builtins.str]:
            '''If this field is set as ``AMAZON.UserInput`` , the agent can request the user for additional information when trying to complete a task. The ``description`` , ``apiSchema`` , and ``actionGroupExecutor`` fields must be blank for this action group.

            During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an `Observation <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html>`_ reprompting the user for more information.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-parentactiongroupsignature
            '''
            result = self._values.get("parent_action_group_signature")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def skip_resource_in_use_check_on_delete(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to delete the resource even if it's in use.

            By default, this value is ``false`` .

            :default: - false

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html#cfn-bedrock-agent-agentactiongroup-skipresourceinusecheckondelete
            '''
            result = self._values.get("skip_resource_in_use_check_on_delete")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentActionGroupProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.AgentCollaboratorProperty",
        jsii_struct_bases=[],
        name_mapping={
            "agent_descriptor": "agentDescriptor",
            "collaboration_instruction": "collaborationInstruction",
            "collaborator_name": "collaboratorName",
            "relay_conversation_history": "relayConversationHistory",
        },
    )
    class AgentCollaboratorProperty:
        def __init__(
            self,
            *,
            agent_descriptor: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.AgentDescriptorProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            collaboration_instruction: typing.Optional[builtins.str] = None,
            collaborator_name: typing.Optional[builtins.str] = None,
            relay_conversation_history: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An agent collaborator.

            :param agent_descriptor: The collaborator's agent descriptor.
            :param collaboration_instruction: The collaborator's instructions.
            :param collaborator_name: The collaborator's collaborator name.
            :param relay_conversation_history: The collaborator's relay conversation history.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentcollaborator.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_collaborator_property = bedrock_mixins.CfnAgentPropsMixin.AgentCollaboratorProperty(
                    agent_descriptor=bedrock_mixins.CfnAgentPropsMixin.AgentDescriptorProperty(
                        alias_arn="aliasArn"
                    ),
                    collaboration_instruction="collaborationInstruction",
                    collaborator_name="collaboratorName",
                    relay_conversation_history="relayConversationHistory"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__550a70c1f10d3f4fb4916dcb37ea19b6ce24fbdcb4f20313b8a4121801f291b7)
                check_type(argname="argument agent_descriptor", value=agent_descriptor, expected_type=type_hints["agent_descriptor"])
                check_type(argname="argument collaboration_instruction", value=collaboration_instruction, expected_type=type_hints["collaboration_instruction"])
                check_type(argname="argument collaborator_name", value=collaborator_name, expected_type=type_hints["collaborator_name"])
                check_type(argname="argument relay_conversation_history", value=relay_conversation_history, expected_type=type_hints["relay_conversation_history"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent_descriptor is not None:
                self._values["agent_descriptor"] = agent_descriptor
            if collaboration_instruction is not None:
                self._values["collaboration_instruction"] = collaboration_instruction
            if collaborator_name is not None:
                self._values["collaborator_name"] = collaborator_name
            if relay_conversation_history is not None:
                self._values["relay_conversation_history"] = relay_conversation_history

        @builtins.property
        def agent_descriptor(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentDescriptorProperty"]]:
            '''The collaborator's agent descriptor.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentcollaborator.html#cfn-bedrock-agent-agentcollaborator-agentdescriptor
            '''
            result = self._values.get("agent_descriptor")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.AgentDescriptorProperty"]], result)

        @builtins.property
        def collaboration_instruction(self) -> typing.Optional[builtins.str]:
            '''The collaborator's instructions.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentcollaborator.html#cfn-bedrock-agent-agentcollaborator-collaborationinstruction
            '''
            result = self._values.get("collaboration_instruction")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def collaborator_name(self) -> typing.Optional[builtins.str]:
            '''The collaborator's collaborator name.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentcollaborator.html#cfn-bedrock-agent-agentcollaborator-collaboratorname
            '''
            result = self._values.get("collaborator_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def relay_conversation_history(self) -> typing.Optional[builtins.str]:
            '''The collaborator's relay conversation history.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentcollaborator.html#cfn-bedrock-agent-agentcollaborator-relayconversationhistory
            '''
            result = self._values.get("relay_conversation_history")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentCollaboratorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.AgentDescriptorProperty",
        jsii_struct_bases=[],
        name_mapping={"alias_arn": "aliasArn"},
    )
    class AgentDescriptorProperty:
        def __init__(self, *, alias_arn: typing.Optional[builtins.str] = None) -> None:
            '''An agent descriptor.

            :param alias_arn: The agent's alias ARN.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentdescriptor.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_descriptor_property = bedrock_mixins.CfnAgentPropsMixin.AgentDescriptorProperty(
                    alias_arn="aliasArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__83ba4d8421af585b489be5cf53c850191f906ccc80315c42d481c53c48f2a471)
                check_type(argname="argument alias_arn", value=alias_arn, expected_type=type_hints["alias_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if alias_arn is not None:
                self._values["alias_arn"] = alias_arn

        @builtins.property
        def alias_arn(self) -> typing.Optional[builtins.str]:
            '''The agent's alias ARN.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentdescriptor.html#cfn-bedrock-agent-agentdescriptor-aliasarn
            '''
            result = self._values.get("alias_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentDescriptorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.AgentKnowledgeBaseProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "knowledge_base_id": "knowledgeBaseId",
            "knowledge_base_state": "knowledgeBaseState",
        },
    )
    class AgentKnowledgeBaseProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            knowledge_base_id: typing.Optional[builtins.str] = None,
            knowledge_base_state: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about a knowledge base that is associated with an agent.

            :param description: The description of the association between the agent and the knowledge base.
            :param knowledge_base_id: The unique identifier of the association between the agent and the knowledge base.
            :param knowledge_base_state: Specifies whether to use the knowledge base or not when sending an `InvokeAgent <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html>`_ request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentknowledgebase.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_knowledge_base_property = bedrock_mixins.CfnAgentPropsMixin.AgentKnowledgeBaseProperty(
                    description="description",
                    knowledge_base_id="knowledgeBaseId",
                    knowledge_base_state="knowledgeBaseState"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9658feb1974bf323638ba6a6098b8d5adb1aecfb4b0c39b8ccac2152c1ed5a67)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument knowledge_base_id", value=knowledge_base_id, expected_type=type_hints["knowledge_base_id"])
                check_type(argname="argument knowledge_base_state", value=knowledge_base_state, expected_type=type_hints["knowledge_base_state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if knowledge_base_id is not None:
                self._values["knowledge_base_id"] = knowledge_base_id
            if knowledge_base_state is not None:
                self._values["knowledge_base_state"] = knowledge_base_state

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the association between the agent and the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentknowledgebase.html#cfn-bedrock-agent-agentknowledgebase-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def knowledge_base_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the association between the agent and the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentknowledgebase.html#cfn-bedrock-agent-agentknowledgebase-knowledgebaseid
            '''
            result = self._values.get("knowledge_base_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def knowledge_base_state(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to use the knowledge base or not when sending an `InvokeAgent <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html>`_ request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentknowledgebase.html#cfn-bedrock-agent-agentknowledgebase-knowledgebasestate
            '''
            result = self._values.get("knowledge_base_state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentKnowledgeBaseProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.CustomOrchestrationProperty",
        jsii_struct_bases=[],
        name_mapping={"executor": "executor"},
    )
    class CustomOrchestrationProperty:
        def __init__(
            self,
            *,
            executor: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.OrchestrationExecutorProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains details of the custom orchestration configured for the agent.

            :param executor: The structure of the executor invoking the actions in custom orchestration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-customorchestration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                custom_orchestration_property = bedrock_mixins.CfnAgentPropsMixin.CustomOrchestrationProperty(
                    executor=bedrock_mixins.CfnAgentPropsMixin.OrchestrationExecutorProperty(
                        lambda_="lambda"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9819725acf6c9e2d288bf11e8b981b63250331d24fc39119c15f8cd1d4c349d7)
                check_type(argname="argument executor", value=executor, expected_type=type_hints["executor"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if executor is not None:
                self._values["executor"] = executor

        @builtins.property
        def executor(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.OrchestrationExecutorProperty"]]:
            '''The structure of the executor invoking the actions in custom orchestration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-customorchestration.html#cfn-bedrock-agent-customorchestration-executor
            '''
            result = self._values.get("executor")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.OrchestrationExecutorProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CustomOrchestrationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.FunctionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "name": "name",
            "parameters": "parameters",
            "require_confirmation": "requireConfirmation",
        },
    )
    class FunctionProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            parameters: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.ParameterDetailProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            require_confirmation: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines parameters that the agent needs to invoke from the user to complete the function.

            Corresponds to an action in an action group.

            This data type is used in the following API operations:

            - `CreateAgentActionGroup request <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax>`_
            - `CreateAgentActionGroup response <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax>`_
            - `UpdateAgentActionGroup request <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax>`_
            - `UpdateAgentActionGroup response <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax>`_
            - `GetAgentActionGroup response <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax>`_

            :param description: A description of the function and its purpose.
            :param name: A name for the function.
            :param parameters: The parameters that the agent elicits from the user to fulfill the function.
            :param require_confirmation: Contains information if user confirmation is required to invoke the function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-function.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                function_property = bedrock_mixins.CfnAgentPropsMixin.FunctionProperty(
                    description="description",
                    name="name",
                    parameters={
                        "parameters_key": bedrock_mixins.CfnAgentPropsMixin.ParameterDetailProperty(
                            description="description",
                            required=False,
                            type="type"
                        )
                    },
                    require_confirmation="requireConfirmation"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b6fa882b4d53b72c6e723bb0f21a0c23cbfe4a4aa33e54b820f0042c4c95f4c9)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
                check_type(argname="argument require_confirmation", value=require_confirmation, expected_type=type_hints["require_confirmation"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if name is not None:
                self._values["name"] = name
            if parameters is not None:
                self._values["parameters"] = parameters
            if require_confirmation is not None:
                self._values["require_confirmation"] = require_confirmation

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the function and its purpose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-function.html#cfn-bedrock-agent-function-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-function.html#cfn-bedrock-agent-function-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def parameters(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.ParameterDetailProperty"]]]]:
            '''The parameters that the agent elicits from the user to fulfill the function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-function.html#cfn-bedrock-agent-function-parameters
            '''
            result = self._values.get("parameters")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.ParameterDetailProperty"]]]], result)

        @builtins.property
        def require_confirmation(self) -> typing.Optional[builtins.str]:
            '''Contains information if user confirmation is required to invoke the function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-function.html#cfn-bedrock-agent-function-requireconfirmation
            '''
            result = self._values.get("require_confirmation")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FunctionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.FunctionSchemaProperty",
        jsii_struct_bases=[],
        name_mapping={"functions": "functions"},
    )
    class FunctionSchemaProperty:
        def __init__(
            self,
            *,
            functions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.FunctionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.

            :param functions: A list of functions that each define an action in the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-functionschema.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                function_schema_property = bedrock_mixins.CfnAgentPropsMixin.FunctionSchemaProperty(
                    functions=[bedrock_mixins.CfnAgentPropsMixin.FunctionProperty(
                        description="description",
                        name="name",
                        parameters={
                            "parameters_key": bedrock_mixins.CfnAgentPropsMixin.ParameterDetailProperty(
                                description="description",
                                required=False,
                                type="type"
                            )
                        },
                        require_confirmation="requireConfirmation"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__14db220f01c1623f0b34950da07cd5bc6828753698c6dd7cf9fe900c8fbeebd1)
                check_type(argname="argument functions", value=functions, expected_type=type_hints["functions"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if functions is not None:
                self._values["functions"] = functions

        @builtins.property
        def functions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.FunctionProperty"]]]]:
            '''A list of functions that each define an action in the action group.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-functionschema.html#cfn-bedrock-agent-functionschema-functions
            '''
            result = self._values.get("functions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.FunctionProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FunctionSchemaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.GuardrailConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_identifier": "guardrailIdentifier",
            "guardrail_version": "guardrailVersion",
        },
    )
    class GuardrailConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_identifier: typing.Optional[builtins.str] = None,
            guardrail_version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration information for a guardrail that you use with the `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ operation.

            :param guardrail_identifier: The identifier for the guardrail.
            :param guardrail_version: The version of the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-guardrailconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                guardrail_configuration_property = bedrock_mixins.CfnAgentPropsMixin.GuardrailConfigurationProperty(
                    guardrail_identifier="guardrailIdentifier",
                    guardrail_version="guardrailVersion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b4c85bc9b2e508ce7bdf56e2b9e1a1b97251e5cc89438f0a22eccd7d3cf57f0a)
                check_type(argname="argument guardrail_identifier", value=guardrail_identifier, expected_type=type_hints["guardrail_identifier"])
                check_type(argname="argument guardrail_version", value=guardrail_version, expected_type=type_hints["guardrail_version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_identifier is not None:
                self._values["guardrail_identifier"] = guardrail_identifier
            if guardrail_version is not None:
                self._values["guardrail_version"] = guardrail_version

        @builtins.property
        def guardrail_identifier(self) -> typing.Optional[builtins.str]:
            '''The identifier for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-guardrailconfiguration.html#cfn-bedrock-agent-guardrailconfiguration-guardrailidentifier
            '''
            result = self._values.get("guardrail_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def guardrail_version(self) -> typing.Optional[builtins.str]:
            '''The version of the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-guardrailconfiguration.html#cfn-bedrock-agent-guardrailconfiguration-guardrailversion
            '''
            result = self._values.get("guardrail_version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "GuardrailConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.InferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "maximum_length": "maximumLength",
            "stop_sequences": "stopSequences",
            "temperature": "temperature",
            "top_k": "topK",
            "top_p": "topP",
        },
    )
    class InferenceConfigurationProperty:
        def __init__(
            self,
            *,
            maximum_length: typing.Optional[jsii.Number] = None,
            stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
            temperature: typing.Optional[jsii.Number] = None,
            top_k: typing.Optional[jsii.Number] = None,
            top_p: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Base inference parameters to pass to a model in a call to `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ or `ConverseStream <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html>`_ . For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            If you need to pass additional parameters that the model supports, use the ``additionalModelRequestFields`` request field in the call to ``Converse`` or ``ConverseStream`` . For more information, see `Model parameters <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :param maximum_length: The maximum number of tokens allowed in the generated response.
            :param stop_sequences: A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
            :param temperature: The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options. The default value is the default value for the model that you are using. For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .
            :param top_k: While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for ``topK`` is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set ``topK`` to 50, the model selects the next token from among the top 50 most likely choices.
            :param top_p: The percentage of most-likely candidates that the model considers for the next token. For example, if you choose a value of 0.8 for ``topP`` , the model selects from the top 80% of the probability distribution of tokens that could be next in the sequence. The default value is the default value for the model that you are using. For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                inference_configuration_property = bedrock_mixins.CfnAgentPropsMixin.InferenceConfigurationProperty(
                    maximum_length=123,
                    stop_sequences=["stopSequences"],
                    temperature=123,
                    top_k=123,
                    top_p=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__70d761326bbe3c157bb3a906ba02a28f53ae548202650b817eb0ff795d073c82)
                check_type(argname="argument maximum_length", value=maximum_length, expected_type=type_hints["maximum_length"])
                check_type(argname="argument stop_sequences", value=stop_sequences, expected_type=type_hints["stop_sequences"])
                check_type(argname="argument temperature", value=temperature, expected_type=type_hints["temperature"])
                check_type(argname="argument top_k", value=top_k, expected_type=type_hints["top_k"])
                check_type(argname="argument top_p", value=top_p, expected_type=type_hints["top_p"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if maximum_length is not None:
                self._values["maximum_length"] = maximum_length
            if stop_sequences is not None:
                self._values["stop_sequences"] = stop_sequences
            if temperature is not None:
                self._values["temperature"] = temperature
            if top_k is not None:
                self._values["top_k"] = top_k
            if top_p is not None:
                self._values["top_p"] = top_p

        @builtins.property
        def maximum_length(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens allowed in the generated response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html#cfn-bedrock-agent-inferenceconfiguration-maximumlength
            '''
            result = self._values.get("maximum_length")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def stop_sequences(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of stop sequences.

            A stop sequence is a sequence of characters that causes the model to stop generating the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html#cfn-bedrock-agent-inferenceconfiguration-stopsequences
            '''
            result = self._values.get("stop_sequences")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def temperature(self) -> typing.Optional[jsii.Number]:
            '''The likelihood of the model selecting higher-probability options while generating a response.

            A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.

            The default value is the default value for the model that you are using. For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html#cfn-bedrock-agent-inferenceconfiguration-temperature
            '''
            result = self._values.get("temperature")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def top_k(self) -> typing.Optional[jsii.Number]:
            '''While generating a response, the model determines the probability of the following token at each point of generation.

            The value that you set for ``topK`` is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set ``topK`` to 50, the model selects the next token from among the top 50 most likely choices.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html#cfn-bedrock-agent-inferenceconfiguration-topk
            '''
            result = self._values.get("top_k")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def top_p(self) -> typing.Optional[jsii.Number]:
            '''The percentage of most-likely candidates that the model considers for the next token.

            For example, if you choose a value of 0.8 for ``topP`` , the model selects from the top 80% of the probability distribution of tokens that could be next in the sequence.

            The default value is the default value for the model that you are using. For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html#cfn-bedrock-agent-inferenceconfiguration-topp
            '''
            result = self._values.get("top_p")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.MemoryConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enabled_memory_types": "enabledMemoryTypes",
            "session_summary_configuration": "sessionSummaryConfiguration",
            "storage_days": "storageDays",
        },
    )
    class MemoryConfigurationProperty:
        def __init__(
            self,
            *,
            enabled_memory_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            session_summary_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.SessionSummaryConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            storage_days: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Details of the memory configuration.

            :param enabled_memory_types: The type of memory that is stored.
            :param session_summary_configuration: Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
            :param storage_days: The number of days the agent is configured to retain the conversational context.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-memoryconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                memory_configuration_property = bedrock_mixins.CfnAgentPropsMixin.MemoryConfigurationProperty(
                    enabled_memory_types=["enabledMemoryTypes"],
                    session_summary_configuration=bedrock_mixins.CfnAgentPropsMixin.SessionSummaryConfigurationProperty(
                        max_recent_sessions=123
                    ),
                    storage_days=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5f8ef852b2b4ecb31099aa1b98418cef9f3fee2141b5121f1abb0de212ad7136)
                check_type(argname="argument enabled_memory_types", value=enabled_memory_types, expected_type=type_hints["enabled_memory_types"])
                check_type(argname="argument session_summary_configuration", value=session_summary_configuration, expected_type=type_hints["session_summary_configuration"])
                check_type(argname="argument storage_days", value=storage_days, expected_type=type_hints["storage_days"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enabled_memory_types is not None:
                self._values["enabled_memory_types"] = enabled_memory_types
            if session_summary_configuration is not None:
                self._values["session_summary_configuration"] = session_summary_configuration
            if storage_days is not None:
                self._values["storage_days"] = storage_days

        @builtins.property
        def enabled_memory_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of memory that is stored.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-memoryconfiguration.html#cfn-bedrock-agent-memoryconfiguration-enabledmemorytypes
            '''
            result = self._values.get("enabled_memory_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def session_summary_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.SessionSummaryConfigurationProperty"]]:
            '''Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-memoryconfiguration.html#cfn-bedrock-agent-memoryconfiguration-sessionsummaryconfiguration
            '''
            result = self._values.get("session_summary_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.SessionSummaryConfigurationProperty"]], result)

        @builtins.property
        def storage_days(self) -> typing.Optional[jsii.Number]:
            '''The number of days the agent is configured to retain the conversational context.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-memoryconfiguration.html#cfn-bedrock-agent-memoryconfiguration-storagedays
            '''
            result = self._values.get("storage_days")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.OrchestrationExecutorProperty",
        jsii_struct_bases=[],
        name_mapping={"lambda_": "lambda"},
    )
    class OrchestrationExecutorProperty:
        def __init__(self, *, lambda_: typing.Optional[builtins.str] = None) -> None:
            '''The structure of the executor invoking the actions in custom orchestration.

            :param lambda_: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-orchestrationexecutor.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                orchestration_executor_property = bedrock_mixins.CfnAgentPropsMixin.OrchestrationExecutorProperty(
                    lambda_="lambda"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b33cfb1fb7f416c0782b59248c663dc7516fb1d8aa6bda04ab950d94192d81af)
                check_type(argname="argument lambda_", value=lambda_, expected_type=type_hints["lambda_"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if lambda_ is not None:
                self._values["lambda_"] = lambda_

        @builtins.property
        def lambda_(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-orchestrationexecutor.html#cfn-bedrock-agent-orchestrationexecutor-lambda
            '''
            result = self._values.get("lambda_")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OrchestrationExecutorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.ParameterDetailProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "required": "required",
            "type": "type",
        },
    )
    class ParameterDetailProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            required: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about a parameter in a function for an action group.

            :param description: A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
            :param required: Whether the parameter is required for the agent to complete the function for action group invocation.
            :param type: The data type of the parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-parameterdetail.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                parameter_detail_property = bedrock_mixins.CfnAgentPropsMixin.ParameterDetailProperty(
                    description="description",
                    required=False,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0e0d2c22fae1856f9828b4cece2cd3bda2252fd3e484a9ebdc017e3958758d6c)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument required", value=required, expected_type=type_hints["required"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if required is not None:
                self._values["required"] = required
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the parameter.

            Helps the foundation model determine how to elicit the parameters from the user.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-parameterdetail.html#cfn-bedrock-agent-parameterdetail-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def required(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Whether the parameter is required for the agent to complete the function for action group invocation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-parameterdetail.html#cfn-bedrock-agent-parameterdetail-required
            '''
            result = self._values.get("required")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The data type of the parameter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-parameterdetail.html#cfn-bedrock-agent-parameterdetail-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ParameterDetailProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.PromptConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "base_prompt_template": "basePromptTemplate",
            "foundation_model": "foundationModel",
            "inference_configuration": "inferenceConfiguration",
            "parser_mode": "parserMode",
            "prompt_creation_mode": "promptCreationMode",
            "prompt_state": "promptState",
            "prompt_type": "promptType",
        },
    )
    class PromptConfigurationProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            base_prompt_template: typing.Optional[builtins.str] = None,
            foundation_model: typing.Optional[builtins.str] = None,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.InferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            parser_mode: typing.Optional[builtins.str] = None,
            prompt_creation_mode: typing.Optional[builtins.str] = None,
            prompt_state: typing.Optional[builtins.str] = None,
            prompt_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations to override a prompt template in one part of an agent sequence.

            For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .

            :param additional_model_request_fields: If the Converse or ConverseStream operations support the model, ``additionalModelRequestFields`` contains additional inference parameters, beyond the base set of inference parameters in the ``inferenceConfiguration`` field. For more information, see `Inference request parameters and response fields for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .
            :param base_prompt_template: Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see `Prompt template placeholder variables <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html>`_ . For more information, see `Configure the prompt templates <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts-configure.html>`_ .
            :param foundation_model: The agent's foundation model.
            :param inference_configuration: Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the ``promptType`` . For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .
            :param parser_mode: Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the ``promptType`` . If you set the field as ``OVERRIDDEN`` , the ``overrideLambda`` field in the `PromptOverrideConfiguration <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html>`_ must be specified with the ARN of a Lambda function.
            :param prompt_creation_mode: Specifies whether to override the default prompt template for this ``promptType`` . Set this value to ``OVERRIDDEN`` to use the prompt that you provide in the ``basePromptTemplate`` . If you leave it as ``DEFAULT`` , the agent uses a default prompt template.
            :param prompt_state: Specifies whether to allow the inline agent to carry out the step specified in the ``promptType`` . If you set this value to ``DISABLED`` , the agent skips that step. The default state for each ``promptType`` is as follows. - ``PRE_PROCESSING`` – ``ENABLED`` - ``ORCHESTRATION`` – ``ENABLED`` - ``KNOWLEDGE_BASE_RESPONSE_GENERATION`` – ``ENABLED`` - ``POST_PROCESSING`` – ``DISABLED``
            :param prompt_type: The step in the agent sequence that this prompt configuration applies to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                prompt_configuration_property = bedrock_mixins.CfnAgentPropsMixin.PromptConfigurationProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    base_prompt_template="basePromptTemplate",
                    foundation_model="foundationModel",
                    inference_configuration=bedrock_mixins.CfnAgentPropsMixin.InferenceConfigurationProperty(
                        maximum_length=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_k=123,
                        top_p=123
                    ),
                    parser_mode="parserMode",
                    prompt_creation_mode="promptCreationMode",
                    prompt_state="promptState",
                    prompt_type="promptType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__febea77361572ec9bd975c9032f098e57b427764c2b17a9d7c67f9cb6666b0f5)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument base_prompt_template", value=base_prompt_template, expected_type=type_hints["base_prompt_template"])
                check_type(argname="argument foundation_model", value=foundation_model, expected_type=type_hints["foundation_model"])
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument parser_mode", value=parser_mode, expected_type=type_hints["parser_mode"])
                check_type(argname="argument prompt_creation_mode", value=prompt_creation_mode, expected_type=type_hints["prompt_creation_mode"])
                check_type(argname="argument prompt_state", value=prompt_state, expected_type=type_hints["prompt_state"])
                check_type(argname="argument prompt_type", value=prompt_type, expected_type=type_hints["prompt_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if base_prompt_template is not None:
                self._values["base_prompt_template"] = base_prompt_template
            if foundation_model is not None:
                self._values["foundation_model"] = foundation_model
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if parser_mode is not None:
                self._values["parser_mode"] = parser_mode
            if prompt_creation_mode is not None:
                self._values["prompt_creation_mode"] = prompt_creation_mode
            if prompt_state is not None:
                self._values["prompt_state"] = prompt_state
            if prompt_type is not None:
                self._values["prompt_type"] = prompt_type

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''If the Converse or ConverseStream operations support the model, ``additionalModelRequestFields`` contains additional inference parameters, beyond the base set of inference parameters in the ``inferenceConfiguration`` field.

            For more information, see `Inference request parameters and response fields for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def base_prompt_template(self) -> typing.Optional[builtins.str]:
            '''Defines the prompt template with which to replace the default prompt template.

            You can use placeholder variables in the base prompt template to customize the prompt. For more information, see `Prompt template placeholder variables <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html>`_ . For more information, see `Configure the prompt templates <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts-configure.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-baseprompttemplate
            '''
            result = self._values.get("base_prompt_template")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def foundation_model(self) -> typing.Optional[builtins.str]:
            '''The agent's foundation model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-foundationmodel
            '''
            result = self._values.get("foundation_model")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.InferenceConfigurationProperty"]]:
            '''Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the ``promptType`` .

            For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.InferenceConfigurationProperty"]], result)

        @builtins.property
        def parser_mode(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the ``promptType`` .

            If you set the field as ``OVERRIDDEN`` , the ``overrideLambda`` field in the `PromptOverrideConfiguration <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html>`_ must be specified with the ARN of a Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-parsermode
            '''
            result = self._values.get("parser_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def prompt_creation_mode(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to override the default prompt template for this ``promptType`` .

            Set this value to ``OVERRIDDEN`` to use the prompt that you provide in the ``basePromptTemplate`` . If you leave it as ``DEFAULT`` , the agent uses a default prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-promptcreationmode
            '''
            result = self._values.get("prompt_creation_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def prompt_state(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to allow the inline agent to carry out the step specified in the ``promptType`` .

            If you set this value to ``DISABLED`` , the agent skips that step. The default state for each ``promptType`` is as follows.

            - ``PRE_PROCESSING`` – ``ENABLED``
            - ``ORCHESTRATION`` – ``ENABLED``
            - ``KNOWLEDGE_BASE_RESPONSE_GENERATION`` – ``ENABLED``
            - ``POST_PROCESSING`` – ``DISABLED``

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-promptstate
            '''
            result = self._values.get("prompt_state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def prompt_type(self) -> typing.Optional[builtins.str]:
            '''The step in the agent sequence that this prompt configuration applies to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html#cfn-bedrock-agent-promptconfiguration-prompttype
            '''
            result = self._values.get("prompt_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.PromptOverrideConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "override_lambda": "overrideLambda",
            "prompt_configurations": "promptConfigurations",
        },
    )
    class PromptOverrideConfigurationProperty:
        def __init__(
            self,
            *,
            override_lambda: typing.Optional[builtins.str] = None,
            prompt_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAgentPropsMixin.PromptConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Contains configurations to override prompts in different parts of an agent sequence.

            For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .

            :param override_lambda: The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the ``promptConfigurations`` must contain a ``parserMode`` value that is set to ``OVERRIDDEN`` . For more information, see `Parser Lambda function in Amazon Bedrock Agents <https://docs.aws.amazon.com/bedrock/latest/userguide/lambda-parser.html>`_ .
            :param prompt_configurations: Contains configurations to override a prompt template in one part of an agent sequence. For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptoverrideconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                prompt_override_configuration_property = bedrock_mixins.CfnAgentPropsMixin.PromptOverrideConfigurationProperty(
                    override_lambda="overrideLambda",
                    prompt_configurations=[bedrock_mixins.CfnAgentPropsMixin.PromptConfigurationProperty(
                        additional_model_request_fields=additional_model_request_fields,
                        base_prompt_template="basePromptTemplate",
                        foundation_model="foundationModel",
                        inference_configuration=bedrock_mixins.CfnAgentPropsMixin.InferenceConfigurationProperty(
                            maximum_length=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_k=123,
                            top_p=123
                        ),
                        parser_mode="parserMode",
                        prompt_creation_mode="promptCreationMode",
                        prompt_state="promptState",
                        prompt_type="promptType"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__aee2c7de86041c2622cc639281e85e43ada9886ff8165381269febc4eb807930)
                check_type(argname="argument override_lambda", value=override_lambda, expected_type=type_hints["override_lambda"])
                check_type(argname="argument prompt_configurations", value=prompt_configurations, expected_type=type_hints["prompt_configurations"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if override_lambda is not None:
                self._values["override_lambda"] = override_lambda
            if prompt_configurations is not None:
                self._values["prompt_configurations"] = prompt_configurations

        @builtins.property
        def override_lambda(self) -> typing.Optional[builtins.str]:
            '''The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.

            If you specify this field, at least one of the ``promptConfigurations`` must contain a ``parserMode`` value that is set to ``OVERRIDDEN`` . For more information, see `Parser Lambda function in Amazon Bedrock Agents <https://docs.aws.amazon.com/bedrock/latest/userguide/lambda-parser.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptoverrideconfiguration.html#cfn-bedrock-agent-promptoverrideconfiguration-overridelambda
            '''
            result = self._values.get("override_lambda")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def prompt_configurations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.PromptConfigurationProperty"]]]]:
            '''Contains configurations to override a prompt template in one part of an agent sequence.

            For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptoverrideconfiguration.html#cfn-bedrock-agent-promptoverrideconfiguration-promptconfigurations
            '''
            result = self._values.get("prompt_configurations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAgentPropsMixin.PromptConfigurationProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptOverrideConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.S3IdentifierProperty",
        jsii_struct_bases=[],
        name_mapping={
            "s3_bucket_name": "s3BucketName",
            "s3_object_key": "s3ObjectKey",
        },
    )
    class S3IdentifierProperty:
        def __init__(
            self,
            *,
            s3_bucket_name: typing.Optional[builtins.str] = None,
            s3_object_key: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The identifier information for an Amazon S3 bucket.

            :param s3_bucket_name: The name of the S3 bucket.
            :param s3_object_key: The S3 object key for the S3 resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-s3identifier.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                s3_identifier_property = bedrock_mixins.CfnAgentPropsMixin.S3IdentifierProperty(
                    s3_bucket_name="s3BucketName",
                    s3_object_key="s3ObjectKey"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__642e07c90f57b7d3f7e1e4f3b8d88334db27703c66a146597edb2ed605140657)
                check_type(argname="argument s3_bucket_name", value=s3_bucket_name, expected_type=type_hints["s3_bucket_name"])
                check_type(argname="argument s3_object_key", value=s3_object_key, expected_type=type_hints["s3_object_key"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3_bucket_name is not None:
                self._values["s3_bucket_name"] = s3_bucket_name
            if s3_object_key is not None:
                self._values["s3_object_key"] = s3_object_key

        @builtins.property
        def s3_bucket_name(self) -> typing.Optional[builtins.str]:
            '''The name of the S3 bucket.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-s3identifier.html#cfn-bedrock-agent-s3identifier-s3bucketname
            '''
            result = self._values.get("s3_bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def s3_object_key(self) -> typing.Optional[builtins.str]:
            '''The S3 object key for the S3 resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-s3identifier.html#cfn-bedrock-agent-s3identifier-s3objectkey
            '''
            result = self._values.get("s3_object_key")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3IdentifierProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAgentPropsMixin.SessionSummaryConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"max_recent_sessions": "maxRecentSessions"},
    )
    class SessionSummaryConfigurationProperty:
        def __init__(
            self,
            *,
            max_recent_sessions: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configuration for SESSION_SUMMARY memory type enabled for the agent.

            :param max_recent_sessions: Maximum number of recent session summaries to include in the agent's prompt context.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-sessionsummaryconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                session_summary_configuration_property = bedrock_mixins.CfnAgentPropsMixin.SessionSummaryConfigurationProperty(
                    max_recent_sessions=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d538eb025a16d68c9eb56f81c65f6c39e31d84777e478e711a81233d573cb7c)
                check_type(argname="argument max_recent_sessions", value=max_recent_sessions, expected_type=type_hints["max_recent_sessions"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_recent_sessions is not None:
                self._values["max_recent_sessions"] = max_recent_sessions

        @builtins.property
        def max_recent_sessions(self) -> typing.Optional[jsii.Number]:
            '''Maximum number of recent session summaries to include in the agent's prompt context.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-sessionsummaryconfiguration.html#cfn-bedrock-agent-sessionsummaryconfiguration-maxrecentsessions
            '''
            result = self._values.get("max_recent_sessions")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SessionSummaryConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnApplicationInferenceProfileMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "inference_profile_name": "inferenceProfileName",
        "model_source": "modelSource",
        "tags": "tags",
    },
)
class CfnApplicationInferenceProfileMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        inference_profile_name: typing.Optional[builtins.str] = None,
        model_source: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnApplicationInferenceProfilePropsMixin.

        :param description: The description of the inference profile.
        :param inference_profile_name: The name of the inference profile.
        :param model_source: Contains configurations for the inference profile to copy as the resource.
        :param tags: A list of tags associated with the inference profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-applicationinferenceprofile.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_application_inference_profile_mixin_props = bedrock_mixins.CfnApplicationInferenceProfileMixinProps(
                description="description",
                inference_profile_name="inferenceProfileName",
                model_source=bedrock_mixins.CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty(
                    copy_from="copyFrom"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03ef3848392b22f82ffa538566b18aec8f273460040c16b9c67838a401c9d0db)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument inference_profile_name", value=inference_profile_name, expected_type=type_hints["inference_profile_name"])
            check_type(argname="argument model_source", value=model_source, expected_type=type_hints["model_source"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if inference_profile_name is not None:
            self._values["inference_profile_name"] = inference_profile_name
        if model_source is not None:
            self._values["model_source"] = model_source
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the inference profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-applicationinferenceprofile.html#cfn-bedrock-applicationinferenceprofile-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def inference_profile_name(self) -> typing.Optional[builtins.str]:
        '''The name of the inference profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-applicationinferenceprofile.html#cfn-bedrock-applicationinferenceprofile-inferenceprofilename
        '''
        result = self._values.get("inference_profile_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def model_source(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty"]]:
        '''Contains configurations for the inference profile to copy as the resource.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-applicationinferenceprofile.html#cfn-bedrock-applicationinferenceprofile-modelsource
        '''
        result = self._values.get("model_source")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''A list of tags associated with the inference profile.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-applicationinferenceprofile.html#cfn-bedrock-applicationinferenceprofile-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnApplicationInferenceProfileMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnApplicationInferenceProfilePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnApplicationInferenceProfilePropsMixin",
):
    '''Specifies an inference profile as a resource in a top-level template.

    Use the ``ModelSource`` field to specify the inference profile to copy into the resource. For more information about using inference profiles in Amazon Bedrock , see `Improve resilience with cross-region inference <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-applicationinferenceprofile.html
    :cloudformationResource: AWS::Bedrock::ApplicationInferenceProfile
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_application_inference_profile_props_mixin = bedrock_mixins.CfnApplicationInferenceProfilePropsMixin(bedrock_mixins.CfnApplicationInferenceProfileMixinProps(
            description="description",
            inference_profile_name="inferenceProfileName",
            model_source=bedrock_mixins.CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty(
                copy_from="copyFrom"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnApplicationInferenceProfileMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::ApplicationInferenceProfile``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fca9b3bfd77a9faf244a371385364cc1361ac72dfd92c2433dafcd0ab6791af)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fcb83dac915d636046ea6dacc28c50c68598fa9646d1db481f6c241232a5be1)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__631bb5ba5d6ffb7868321b53a46febd76970ee482ef78dbd10884d3f0a83acc7)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnApplicationInferenceProfileMixinProps":
        return typing.cast("CfnApplicationInferenceProfileMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelProperty",
        jsii_struct_bases=[],
        name_mapping={"model_arn": "modelArn"},
    )
    class InferenceProfileModelProperty:
        def __init__(self, *, model_arn: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about a model.

            :param model_arn: The Amazon Resource Name (ARN) of the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-applicationinferenceprofile-inferenceprofilemodel.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                inference_profile_model_property = bedrock_mixins.CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelProperty(
                    model_arn="modelArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__71700cd9f8cec08e9de7268c5cf44ed9150a0c2637bfedf8c739eb61a2b74311)
                check_type(argname="argument model_arn", value=model_arn, expected_type=type_hints["model_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if model_arn is not None:
                self._values["model_arn"] = model_arn

        @builtins.property
        def model_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-applicationinferenceprofile-inferenceprofilemodel.html#cfn-bedrock-applicationinferenceprofile-inferenceprofilemodel-modelarn
            '''
            result = self._values.get("model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InferenceProfileModelProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty",
        jsii_struct_bases=[],
        name_mapping={"copy_from": "copyFrom"},
    )
    class InferenceProfileModelSourceProperty:
        def __init__(self, *, copy_from: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about the model or system-defined inference profile that is the source for an inference profile..

            :param copy_from: The ARN of the model or system-defined inference profile that is the source for the inference profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-applicationinferenceprofile-inferenceprofilemodelsource.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                inference_profile_model_source_property = bedrock_mixins.CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty(
                    copy_from="copyFrom"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__15e9a682defac9389f62706eb5ec089209c580bc2298c1bdf56d2825e5e38047)
                check_type(argname="argument copy_from", value=copy_from, expected_type=type_hints["copy_from"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if copy_from is not None:
                self._values["copy_from"] = copy_from

        @builtins.property
        def copy_from(self) -> typing.Optional[builtins.str]:
            '''The ARN of the model or system-defined inference profile that is the source for the inference profile.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-applicationinferenceprofile-inferenceprofilemodelsource.html#cfn-bedrock-applicationinferenceprofile-inferenceprofilemodelsource-copyfrom
            '''
            result = self._values.get("copy_from")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InferenceProfileModelSourceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "force_delete": "forceDelete",
        "kms_key_id": "kmsKeyId",
        "name": "name",
        "policy_definition": "policyDefinition",
        "tags": "tags",
    },
)
class CfnAutomatedReasoningPolicyMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        force_delete: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        policy_definition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnAutomatedReasoningPolicyPropsMixin.

        :param description: The description of the policy.
        :param force_delete: Specifies whether to force delete the automated reasoning policy even if it has active resources. When false , Amazon Bedrock validates if all artifacts have been deleted (e.g. policy version, test case, test result) for a policy before deletion. When true , Amazon Bedrock will delete the policy and all its artifacts without validation. Default is false Default: - false
        :param kms_key_id: The KMS key with which the Policy's assets will be encrypted at rest.
        :param name: The name of the policy.
        :param policy_definition: The complete policy definition generated by the build workflow, containing all rules, variables, and custom types extracted from the source documents.
        :param tags: The tags associated with the Automated Reasoning policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_automated_reasoning_policy_mixin_props = bedrock_mixins.CfnAutomatedReasoningPolicyMixinProps(
                description="description",
                force_delete=False,
                kms_key_id="kmsKeyId",
                name="name",
                policy_definition=bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty(
                    rules=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty(
                        alternate_expression="alternateExpression",
                        expression="expression",
                        id="id"
                    )],
                    types=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty(
                        description="description",
                        name="name",
                        values=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty(
                            description="description",
                            value="value"
                        )]
                    )],
                    variables=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty(
                        description="description",
                        name="name",
                        type="type"
                    )],
                    version="version"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__863f3869e6ca0339285de67076fe82e859ee338a9aabf2f18f12148caff4797f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument force_delete", value=force_delete, expected_type=type_hints["force_delete"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument policy_definition", value=policy_definition, expected_type=type_hints["policy_definition"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if force_delete is not None:
            self._values["force_delete"] = force_delete
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if name is not None:
            self._values["name"] = name
        if policy_definition is not None:
            self._values["policy_definition"] = policy_definition
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html#cfn-bedrock-automatedreasoningpolicy-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def force_delete(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Specifies whether to force delete the automated reasoning policy even if it has active resources.

        When false , Amazon Bedrock validates if all artifacts have been deleted (e.g. policy version, test case, test result) for a policy before deletion. When true , Amazon Bedrock will delete the policy and all its artifacts without validation. Default is false

        :default: - false

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html#cfn-bedrock-automatedreasoningpolicy-forcedelete
        '''
        result = self._values.get("force_delete")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The KMS key with which the Policy's assets will be encrypted at rest.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html#cfn-bedrock-automatedreasoningpolicy-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html#cfn-bedrock-automatedreasoningpolicy-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_definition(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty"]]:
        '''The complete policy definition generated by the build workflow, containing all rules, variables, and custom types extracted from the source documents.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html#cfn-bedrock-automatedreasoningpolicy-policydefinition
        '''
        result = self._values.get("policy_definition")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags associated with the Automated Reasoning policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html#cfn-bedrock-automatedreasoningpolicy-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnAutomatedReasoningPolicyMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnAutomatedReasoningPolicyPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyPropsMixin",
):
    '''Creates an Automated Reasoning policy for Amazon Bedrock Guardrails.

    Automated Reasoning policies use mathematical techniques to detect hallucinations, suggest corrections, and highlight unstated assumptions in the responses of your GenAI application.

    To create a policy, you upload a source document that describes the rules that you're encoding. Automated Reasoning extracts important concepts from the source document that will become variables in the policy and infers policy rules.

    To learn more about creating Automated Reasoning policies, see `Minimize AI hallucinations and deliver up to 99% verification accuracy with Automated Reasoning checks: Now available <https://docs.aws.amazon.com/aws/minimize-ai-hallucinations-and-deliver-up-to-99-verification-accuracy-with-automated-reasoning-checks-now-available/>`_ in the *AWS News Blog* .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicy.html
    :cloudformationResource: AWS::Bedrock::AutomatedReasoningPolicy
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_automated_reasoning_policy_props_mixin = bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin(bedrock_mixins.CfnAutomatedReasoningPolicyMixinProps(
            description="description",
            force_delete=False,
            kms_key_id="kmsKeyId",
            name="name",
            policy_definition=bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty(
                rules=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty(
                    alternate_expression="alternateExpression",
                    expression="expression",
                    id="id"
                )],
                types=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty(
                    description="description",
                    name="name",
                    values=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty(
                        description="description",
                        value="value"
                    )]
                )],
                variables=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty(
                    description="description",
                    name="name",
                    type="type"
                )],
                version="version"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnAutomatedReasoningPolicyMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::AutomatedReasoningPolicy``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__657517369732b534f202897b45148a5be83ad127c7b740d0a22dfdeb4088d208)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d7565788b1a54f36074d387679cb593b0d928ea605831feee0f1ec37c4d88e3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68f601477f3c1f9ce560f939b0e7a1356a56468f920e5d667bedda5f10060666)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnAutomatedReasoningPolicyMixinProps":
        return typing.cast("CfnAutomatedReasoningPolicyMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "rules": "rules",
            "types": "types",
            "variables": "variables",
            "version": "version",
        },
    )
    class PolicyDefinitionProperty:
        def __init__(
            self,
            *,
            rules: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            types: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The complete policy definition containing rules, variables, and types.

            :param rules: The collection of rules that define the policy logic.
            :param types: The custom types defined within the policy definition.
            :param variables: The variables used within the policy definition.
            :param version: The version of the policy definition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinition.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                policy_definition_property = bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty(
                    rules=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty(
                        alternate_expression="alternateExpression",
                        expression="expression",
                        id="id"
                    )],
                    types=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty(
                        description="description",
                        name="name",
                        values=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty(
                            description="description",
                            value="value"
                        )]
                    )],
                    variables=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty(
                        description="description",
                        name="name",
                        type="type"
                    )],
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__93dc6b498d55c3653bad0d7833548503095d432ace1e03f1c932bba1f36c88a2)
                check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
                check_type(argname="argument variables", value=variables, expected_type=type_hints["variables"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if rules is not None:
                self._values["rules"] = rules
            if types is not None:
                self._values["types"] = types
            if variables is not None:
                self._values["variables"] = variables
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def rules(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty"]]]]:
            '''The collection of rules that define the policy logic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinition.html#cfn-bedrock-automatedreasoningpolicy-policydefinition-rules
            '''
            result = self._values.get("rules")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty"]]]], result)

        @builtins.property
        def types(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty"]]]]:
            '''The custom types defined within the policy definition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinition.html#cfn-bedrock-automatedreasoningpolicy-policydefinition-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty"]]]], result)

        @builtins.property
        def variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty"]]]]:
            '''The variables used within the policy definition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinition.html#cfn-bedrock-automatedreasoningpolicy-policydefinition-variables
            '''
            result = self._values.get("variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty"]]]], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The version of the policy definition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinition.html#cfn-bedrock-automatedreasoningpolicy-policydefinition-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PolicyDefinitionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty",
        jsii_struct_bases=[],
        name_mapping={
            "alternate_expression": "alternateExpression",
            "expression": "expression",
            "id": "id",
        },
    )
    class PolicyDefinitionRuleProperty:
        def __init__(
            self,
            *,
            alternate_expression: typing.Optional[builtins.str] = None,
            expression: typing.Optional[builtins.str] = None,
            id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A rule within the policy definition that defines logical constraints.

            :param alternate_expression: An alternative expression for the policy rule.
            :param expression: The logical expression that defines the rule.
            :param id: The unique identifier for the policy definition rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionrule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                policy_definition_rule_property = bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty(
                    alternate_expression="alternateExpression",
                    expression="expression",
                    id="id"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__32e27e5103a9d0ccfb118539501f55b1d3ab19545a5b5df29427a0ef118dfa35)
                check_type(argname="argument alternate_expression", value=alternate_expression, expected_type=type_hints["alternate_expression"])
                check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
                check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if alternate_expression is not None:
                self._values["alternate_expression"] = alternate_expression
            if expression is not None:
                self._values["expression"] = expression
            if id is not None:
                self._values["id"] = id

        @builtins.property
        def alternate_expression(self) -> typing.Optional[builtins.str]:
            '''An alternative expression for the policy rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionrule.html#cfn-bedrock-automatedreasoningpolicy-policydefinitionrule-alternateexpression
            '''
            result = self._values.get("alternate_expression")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def expression(self) -> typing.Optional[builtins.str]:
            '''The logical expression that defines the rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionrule.html#cfn-bedrock-automatedreasoningpolicy-policydefinitionrule-expression
            '''
            result = self._values.get("expression")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier for the policy definition rule.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionrule.html#cfn-bedrock-automatedreasoningpolicy-policydefinitionrule-id
            '''
            result = self._values.get("id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PolicyDefinitionRuleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "name": "name",
            "values": "values",
        },
    )
    class PolicyDefinitionTypeProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            values: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''A custom type definition within the policy.

            :param description: A description of the custom type defined in the policy.
            :param name: The name of a custom type defined in the policy.
            :param values: The possible values for a custom type defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontype.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                policy_definition_type_property = bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty(
                    description="description",
                    name="name",
                    values=[bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty(
                        description="description",
                        value="value"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ccb9d7cd5bfa2cc51e9f0b42cb47f755bebc6dac6789e540fa0e26d94869b2ff)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument values", value=values, expected_type=type_hints["values"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if name is not None:
                self._values["name"] = name
            if values is not None:
                self._values["values"] = values

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the custom type defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontype.html#cfn-bedrock-automatedreasoningpolicy-policydefinitiontype-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of a custom type defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontype.html#cfn-bedrock-automatedreasoningpolicy-policydefinitiontype-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def values(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty"]]]]:
            '''The possible values for a custom type defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontype.html#cfn-bedrock-automatedreasoningpolicy-policydefinitiontype-values
            '''
            result = self._values.get("values")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PolicyDefinitionTypeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty",
        jsii_struct_bases=[],
        name_mapping={"description": "description", "value": "value"},
    )
    class PolicyDefinitionTypeValueProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A value associated with a custom type in the policy definition.

            :param description: A description of the policy definition type value.
            :param value: The value associated with a policy definition type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontypevalue.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                policy_definition_type_value_property = bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty(
                    description="description",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d75b4f8e416913320b0dc3fab27537a2800eb22e985c77d1ec1f59f0f3d3bc18)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the policy definition type value.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontypevalue.html#cfn-bedrock-automatedreasoningpolicy-policydefinitiontypevalue-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value associated with a policy definition type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitiontypevalue.html#cfn-bedrock-automatedreasoningpolicy-policydefinitiontypevalue-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PolicyDefinitionTypeValueProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty",
        jsii_struct_bases=[],
        name_mapping={"description": "description", "name": "name", "type": "type"},
    )
    class PolicyDefinitionVariableProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A variable defined within the policy that can be used in rules.

            :param description: A description of a variable defined in the policy.
            :param name: The name of a variable defined in the policy.
            :param type: The data type of a variable defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionvariable.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                policy_definition_variable_property = bedrock_mixins.CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty(
                    description="description",
                    name="name",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__92d2638ddcaec8eaddc279949ee056b649ee46666c2471e0bb8248fe80a0f80e)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if name is not None:
                self._values["name"] = name
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of a variable defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionvariable.html#cfn-bedrock-automatedreasoningpolicy-policydefinitionvariable-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of a variable defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionvariable.html#cfn-bedrock-automatedreasoningpolicy-policydefinitionvariable-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The data type of a variable defined in the policy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-automatedreasoningpolicy-policydefinitionvariable.html#cfn-bedrock-automatedreasoningpolicy-policydefinitionvariable-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PolicyDefinitionVariableProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyVersionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "last_updated_definition_hash": "lastUpdatedDefinitionHash",
        "policy_arn": "policyArn",
        "tags": "tags",
    },
)
class CfnAutomatedReasoningPolicyVersionMixinProps:
    def __init__(
        self,
        *,
        last_updated_definition_hash: typing.Optional[builtins.str] = None,
        policy_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnAutomatedReasoningPolicyVersionPropsMixin.

        :param last_updated_definition_hash: The hash of the policy definition that was last updated.
        :param policy_arn: The Amazon Resource Name (ARN) of the policy.
        :param tags: The tags associated with the Automated Reasoning policy version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicyversion.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_automated_reasoning_policy_version_mixin_props = bedrock_mixins.CfnAutomatedReasoningPolicyVersionMixinProps(
                last_updated_definition_hash="lastUpdatedDefinitionHash",
                policy_arn="policyArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4a74b301658f56713a89452e2a9e14f64fefaf17d01d70517b6a0692a8a73a9)
            check_type(argname="argument last_updated_definition_hash", value=last_updated_definition_hash, expected_type=type_hints["last_updated_definition_hash"])
            check_type(argname="argument policy_arn", value=policy_arn, expected_type=type_hints["policy_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if last_updated_definition_hash is not None:
            self._values["last_updated_definition_hash"] = last_updated_definition_hash
        if policy_arn is not None:
            self._values["policy_arn"] = policy_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def last_updated_definition_hash(self) -> typing.Optional[builtins.str]:
        '''The hash of the policy definition that was last updated.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicyversion.html#cfn-bedrock-automatedreasoningpolicyversion-lastupdateddefinitionhash
        '''
        result = self._values.get("last_updated_definition_hash")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the policy.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicyversion.html#cfn-bedrock-automatedreasoningpolicyversion-policyarn
        '''
        result = self._values.get("policy_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags associated with the Automated Reasoning policy version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicyversion.html#cfn-bedrock-automatedreasoningpolicyversion-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnAutomatedReasoningPolicyVersionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnAutomatedReasoningPolicyVersionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnAutomatedReasoningPolicyVersionPropsMixin",
):
    '''Creates a new version of an existing Automated Reasoning policy.

    This allows you to iterate on your policy rules while maintaining previous versions for rollback or comparison purposes.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-automatedreasoningpolicyversion.html
    :cloudformationResource: AWS::Bedrock::AutomatedReasoningPolicyVersion
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_automated_reasoning_policy_version_props_mixin = bedrock_mixins.CfnAutomatedReasoningPolicyVersionPropsMixin(bedrock_mixins.CfnAutomatedReasoningPolicyVersionMixinProps(
            last_updated_definition_hash="lastUpdatedDefinitionHash",
            policy_arn="policyArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnAutomatedReasoningPolicyVersionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::AutomatedReasoningPolicyVersion``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1593a3d1632e63769a07cc39b2a2d8bd5659b4fa294cbb90b1358da139df2f03)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0978bf24b9496a3cf10232e1b8e76a5891cde3df21cf3e13d04ae9c5525c079f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52982dd65a4f9853400be09a6ae3c49192edbc1efad22a3730e60bf2b0dda870)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnAutomatedReasoningPolicyVersionMixinProps":
        return typing.cast("CfnAutomatedReasoningPolicyVersionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnBlueprintMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "blueprint_name": "blueprintName",
        "kms_encryption_context": "kmsEncryptionContext",
        "kms_key_id": "kmsKeyId",
        "schema": "schema",
        "tags": "tags",
        "type": "type",
    },
)
class CfnBlueprintMixinProps:
    def __init__(
        self,
        *,
        blueprint_name: typing.Optional[builtins.str] = None,
        kms_encryption_context: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        schema: typing.Any = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnBlueprintPropsMixin.

        :param blueprint_name: The blueprint's name.
        :param kms_encryption_context: Name-value pairs to include as an encryption context.
        :param kms_key_id: The AWS key to use for encryption.
        :param schema: The blueprint's schema.
        :param tags: List of Tags.
        :param type: The blueprint's type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            # schema: Any
            
            cfn_blueprint_mixin_props = bedrock_mixins.CfnBlueprintMixinProps(
                blueprint_name="blueprintName",
                kms_encryption_context={
                    "kms_encryption_context_key": "kmsEncryptionContext"
                },
                kms_key_id="kmsKeyId",
                schema=schema,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71cc7636a5a1e02b3ab37a712fc59bdd7d49c35f80242889732449ae6767f9d4)
            check_type(argname="argument blueprint_name", value=blueprint_name, expected_type=type_hints["blueprint_name"])
            check_type(argname="argument kms_encryption_context", value=kms_encryption_context, expected_type=type_hints["kms_encryption_context"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
            check_type(argname="argument schema", value=schema, expected_type=type_hints["schema"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if blueprint_name is not None:
            self._values["blueprint_name"] = blueprint_name
        if kms_encryption_context is not None:
            self._values["kms_encryption_context"] = kms_encryption_context
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if schema is not None:
            self._values["schema"] = schema
        if tags is not None:
            self._values["tags"] = tags
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def blueprint_name(self) -> typing.Optional[builtins.str]:
        '''The blueprint's name.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html#cfn-bedrock-blueprint-blueprintname
        '''
        result = self._values.get("blueprint_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kms_encryption_context(
        self,
    ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
        '''Name-value pairs to include as an encryption context.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html#cfn-bedrock-blueprint-kmsencryptioncontext
        '''
        result = self._values.get("kms_encryption_context")
        return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The AWS  key to use for encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html#cfn-bedrock-blueprint-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def schema(self) -> typing.Any:
        '''The blueprint's schema.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html#cfn-bedrock-blueprint-schema
        '''
        result = self._values.get("schema")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''List of Tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html#cfn-bedrock-blueprint-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The blueprint's type.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html#cfn-bedrock-blueprint-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnBlueprintMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnBlueprintPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnBlueprintPropsMixin",
):
    '''Details about a data automation blueprint.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-blueprint.html
    :cloudformationResource: AWS::Bedrock::Blueprint
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # schema: Any
        
        cfn_blueprint_props_mixin = bedrock_mixins.CfnBlueprintPropsMixin(bedrock_mixins.CfnBlueprintMixinProps(
            blueprint_name="blueprintName",
            kms_encryption_context={
                "kms_encryption_context_key": "kmsEncryptionContext"
            },
            kms_key_id="kmsKeyId",
            schema=schema,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            type="type"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnBlueprintMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::Blueprint``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5c1ff8b10a64c94c56bac3d79d62b0dada5b72e12d6299866bfbf67320f8c13)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1743f1fb249032def0cad403f0437f23f45f03d8fd283197aa83d55d6fbdfd96)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b274e6013533f0e277eff02a05dd307891d0342ec506f64bc80ca3b5c6b1aaf)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnBlueprintMixinProps":
        return typing.cast("CfnBlueprintMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "custom_output_configuration": "customOutputConfiguration",
        "kms_encryption_context": "kmsEncryptionContext",
        "kms_key_id": "kmsKeyId",
        "override_configuration": "overrideConfiguration",
        "project_description": "projectDescription",
        "project_name": "projectName",
        "project_type": "projectType",
        "standard_output_configuration": "standardOutputConfiguration",
        "tags": "tags",
    },
)
class CfnDataAutomationProjectMixinProps:
    def __init__(
        self,
        *,
        custom_output_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        kms_encryption_context: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        override_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        project_description: typing.Optional[builtins.str] = None,
        project_name: typing.Optional[builtins.str] = None,
        project_type: typing.Optional[builtins.str] = None,
        standard_output_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnDataAutomationProjectPropsMixin.

        :param custom_output_configuration: Blueprints to apply to objects processed by the project.
        :param kms_encryption_context: The AWS encryption context to use for encryption.
        :param kms_key_id: The AWS key to use for encryption.
        :param override_configuration: Additional settings for the project.
        :param project_description: The project's description.
        :param project_name: The project's name.
        :param project_type: Type of the DataAutomationProject - Sync or Async.
        :param standard_output_configuration: The project's standard output configuration.
        :param tags: List of Tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_data_automation_project_mixin_props = bedrock_mixins.CfnDataAutomationProjectMixinProps(
                custom_output_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty(
                    blueprints=[bedrock_mixins.CfnDataAutomationProjectPropsMixin.BlueprintItemProperty(
                        blueprint_arn="blueprintArn",
                        blueprint_stage="blueprintStage",
                        blueprint_version="blueprintVersion"
                    )]
                ),
                kms_encryption_context={
                    "kms_encryption_context_key": "kmsEncryptionContext"
                },
                kms_key_id="kmsKeyId",
                override_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty(
                    audio=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty(
                        language_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty(
                            generative_output_language="generativeOutputLanguage",
                            identify_multiple_languages=False,
                            input_languages=["inputLanguages"]
                        ),
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        )
                    ),
                    document=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty(
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        ),
                        splitter=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty(
                            state="state"
                        )
                    ),
                    image=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty(
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        )
                    ),
                    modality_routing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty(
                        jpeg="jpeg",
                        mov="mov",
                        mp4="mp4",
                        png="png"
                    ),
                    video=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty(
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        )
                    )
                ),
                project_description="projectDescription",
                project_name="projectName",
                project_type="projectType",
                standard_output_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty(
                    audio=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty(
                            category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty(
                                state="state",
                                type_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                                    transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                                        channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                                            state="state"
                                        ),
                                        speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                                            state="state"
                                        )
                                    )
                                ),
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    document=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty(
                            bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty(
                                state="state"
                            ),
                            granularity=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty(
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty(
                            state="state"
                        ),
                        output_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty(
                            additional_file_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty(
                                state="state"
                            ),
                            text_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty(
                                types=["types"]
                            )
                        )
                    ),
                    image=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty(
                            bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty(
                                state="state"
                            ),
                            category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty(
                                state="state",
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    video=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty(
                            bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty(
                                state="state"
                            ),
                            category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty(
                                state="state",
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty(
                            state="state",
                            types=["types"]
                        )
                    )
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efe5f852afbd5b45730507d8713a1d92404b8b0fb39adae6aa861f683630b09a)
            check_type(argname="argument custom_output_configuration", value=custom_output_configuration, expected_type=type_hints["custom_output_configuration"])
            check_type(argname="argument kms_encryption_context", value=kms_encryption_context, expected_type=type_hints["kms_encryption_context"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
            check_type(argname="argument override_configuration", value=override_configuration, expected_type=type_hints["override_configuration"])
            check_type(argname="argument project_description", value=project_description, expected_type=type_hints["project_description"])
            check_type(argname="argument project_name", value=project_name, expected_type=type_hints["project_name"])
            check_type(argname="argument project_type", value=project_type, expected_type=type_hints["project_type"])
            check_type(argname="argument standard_output_configuration", value=standard_output_configuration, expected_type=type_hints["standard_output_configuration"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if custom_output_configuration is not None:
            self._values["custom_output_configuration"] = custom_output_configuration
        if kms_encryption_context is not None:
            self._values["kms_encryption_context"] = kms_encryption_context
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if override_configuration is not None:
            self._values["override_configuration"] = override_configuration
        if project_description is not None:
            self._values["project_description"] = project_description
        if project_name is not None:
            self._values["project_name"] = project_name
        if project_type is not None:
            self._values["project_type"] = project_type
        if standard_output_configuration is not None:
            self._values["standard_output_configuration"] = standard_output_configuration
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def custom_output_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty"]]:
        '''Blueprints to apply to objects processed by the project.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-customoutputconfiguration
        '''
        result = self._values.get("custom_output_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty"]], result)

    @builtins.property
    def kms_encryption_context(
        self,
    ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
        '''The AWS  encryption context to use for encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-kmsencryptioncontext
        '''
        result = self._values.get("kms_encryption_context")
        return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The AWS  key to use for encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty"]]:
        '''Additional settings for the project.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-overrideconfiguration
        '''
        result = self._values.get("override_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty"]], result)

    @builtins.property
    def project_description(self) -> typing.Optional[builtins.str]:
        '''The project's description.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-projectdescription
        '''
        result = self._values.get("project_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_name(self) -> typing.Optional[builtins.str]:
        '''The project's name.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-projectname
        '''
        result = self._values.get("project_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_type(self) -> typing.Optional[builtins.str]:
        '''Type of the DataAutomationProject - Sync or Async.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-projecttype
        '''
        result = self._values.get("project_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def standard_output_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty"]]:
        '''The project's standard output configuration.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-standardoutputconfiguration
        '''
        result = self._values.get("standard_output_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''List of Tags.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html#cfn-bedrock-dataautomationproject-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDataAutomationProjectMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnDataAutomationProjectPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin",
):
    '''A data automation project.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-dataautomationproject.html
    :cloudformationResource: AWS::Bedrock::DataAutomationProject
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_data_automation_project_props_mixin = bedrock_mixins.CfnDataAutomationProjectPropsMixin(bedrock_mixins.CfnDataAutomationProjectMixinProps(
            custom_output_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty(
                blueprints=[bedrock_mixins.CfnDataAutomationProjectPropsMixin.BlueprintItemProperty(
                    blueprint_arn="blueprintArn",
                    blueprint_stage="blueprintStage",
                    blueprint_version="blueprintVersion"
                )]
            ),
            kms_encryption_context={
                "kms_encryption_context_key": "kmsEncryptionContext"
            },
            kms_key_id="kmsKeyId",
            override_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty(
                audio=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty(
                    language_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty(
                        generative_output_language="generativeOutputLanguage",
                        identify_multiple_languages=False,
                        input_languages=["inputLanguages"]
                    ),
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    )
                ),
                document=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty(
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    ),
                    splitter=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty(
                        state="state"
                    )
                ),
                image=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty(
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    )
                ),
                modality_routing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty(
                    jpeg="jpeg",
                    mov="mov",
                    mp4="mp4",
                    png="png"
                ),
                video=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty(
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    )
                )
            ),
            project_description="projectDescription",
            project_name="projectName",
            project_type="projectType",
            standard_output_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty(
                audio=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty(
                        category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty(
                            state="state",
                            type_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                                transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                                    channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                                        state="state"
                                    ),
                                    speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                                        state="state"
                                    )
                                )
                            ),
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty(
                        state="state",
                        types=["types"]
                    )
                ),
                document=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty(
                        bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty(
                            state="state"
                        ),
                        granularity=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty(
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty(
                        state="state"
                    ),
                    output_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty(
                        additional_file_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty(
                            state="state"
                        ),
                        text_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty(
                            types=["types"]
                        )
                    )
                ),
                image=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty(
                        bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty(
                            state="state"
                        ),
                        category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty(
                        state="state",
                        types=["types"]
                    )
                ),
                video=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty(
                        bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty(
                            state="state"
                        ),
                        category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty(
                        state="state",
                        types=["types"]
                    )
                )
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnDataAutomationProjectMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::DataAutomationProject``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a56e1e48d505d8ac132b7ceac677ea88e5184db62a8e27a3516edb8d16e3c252)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d9367d2d79ec16db84c07c96d9365f9200d51b091c13dadb8f36ddf074e9bd2)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1903e2b4acd60c40baa8e9433db2e6d0438a5f5e5fe9a7207c406618ca3eb500)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnDataAutomationProjectMixinProps":
        return typing.cast("CfnDataAutomationProjectMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty",
        jsii_struct_bases=[],
        name_mapping={
            "state": "state",
            "type_configuration": "typeConfiguration",
            "types": "types",
        },
    )
    class AudioExtractionCategoryProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            type_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Settings for generating data from audio.

            :param state: Whether generating categorical data from audio is enabled.
            :param type_configuration: This element contains information about extractions from different types. Used to enable speaker and channel labeling for transcripts.
            :param types: The types of data to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audioextractioncategory.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_extraction_category_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty(
                    state="state",
                    type_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                        transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                            channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                                state="state"
                            ),
                            speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                                state="state"
                            )
                        )
                    ),
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d3f0c5d579a80263d8ef35a92e890d11d9e11f6ea8a5b69654754a9f24083b04)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument type_configuration", value=type_configuration, expected_type=type_hints["type_configuration"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if type_configuration is not None:
                self._values["type_configuration"] = type_configuration
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating categorical data from audio is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audioextractioncategory.html#cfn-bedrock-dataautomationproject-audioextractioncategory-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty"]]:
            '''This element contains information about extractions from different types.

            Used to enable speaker and channel labeling for transcripts.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audioextractioncategory.html#cfn-bedrock-dataautomationproject-audioextractioncategory-typeconfiguration
            '''
            result = self._values.get("type_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty"]], result)

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The types of data to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audioextractioncategory.html#cfn-bedrock-dataautomationproject-audioextractioncategory-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioExtractionCategoryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"transcript": "transcript"},
    )
    class AudioExtractionCategoryTypeConfigurationProperty:
        def __init__(
            self,
            *,
            transcript: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Allows configuration of extractions for different types of data, such as transcript and content moderation.

            :param transcript: This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audioextractioncategorytypeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_extraction_category_type_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                    transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                        channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                            state="state"
                        ),
                        speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                            state="state"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__579c693b8433f3c4f05f83479d67eecced929c2916678fd17ab9d81db9d8f69d)
                check_type(argname="argument transcript", value=transcript, expected_type=type_hints["transcript"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if transcript is not None:
                self._values["transcript"] = transcript

        @builtins.property
        def transcript(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty"]]:
            '''This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audioextractioncategorytypeconfiguration.html#cfn-bedrock-dataautomationproject-audioextractioncategorytypeconfiguration-transcript
            '''
            result = self._values.get("transcript")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioExtractionCategoryTypeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "generative_output_language": "generativeOutputLanguage",
            "identify_multiple_languages": "identifyMultipleLanguages",
            "input_languages": "inputLanguages",
        },
    )
    class AudioLanguageConfigurationProperty:
        def __init__(
            self,
            *,
            generative_output_language: typing.Optional[builtins.str] = None,
            identify_multiple_languages: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            input_languages: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''This allows you to set the input and output language of your audio.

            The input language can be set to any of the languages supported by Bedrock Data Automation. The output can either be set to english or whatever the dominant language is of the audio, determined by the language spoken for the most seconds.

            :param generative_output_language: The output language of your processing results. This can either be set to ``EN`` (English) or ``DEFAULT`` which will output the results in the dominant language of the audio. The dominant language is determined as the language in the audio, spoken the longest in the input audio.
            :param identify_multiple_languages: The toggle determining if you want to detect multiple languages from your audio.
            :param input_languages: The input language of your audio. This can be set to any of the currently supported languages via the language codes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiolanguageconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_language_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty(
                    generative_output_language="generativeOutputLanguage",
                    identify_multiple_languages=False,
                    input_languages=["inputLanguages"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__77393e6ec930f0fd7cbad8e4937b537e91d48e0d40c627ce65d655eac733e6f3)
                check_type(argname="argument generative_output_language", value=generative_output_language, expected_type=type_hints["generative_output_language"])
                check_type(argname="argument identify_multiple_languages", value=identify_multiple_languages, expected_type=type_hints["identify_multiple_languages"])
                check_type(argname="argument input_languages", value=input_languages, expected_type=type_hints["input_languages"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if generative_output_language is not None:
                self._values["generative_output_language"] = generative_output_language
            if identify_multiple_languages is not None:
                self._values["identify_multiple_languages"] = identify_multiple_languages
            if input_languages is not None:
                self._values["input_languages"] = input_languages

        @builtins.property
        def generative_output_language(self) -> typing.Optional[builtins.str]:
            '''The output language of your processing results.

            This can either be set to ``EN`` (English) or ``DEFAULT`` which will output the results in the dominant language of the audio. The dominant language is determined as the language in the audio, spoken the longest in the input audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiolanguageconfiguration.html#cfn-bedrock-dataautomationproject-audiolanguageconfiguration-generativeoutputlanguage
            '''
            result = self._values.get("generative_output_language")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def identify_multiple_languages(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''The toggle determining if you want to detect multiple languages from your audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiolanguageconfiguration.html#cfn-bedrock-dataautomationproject-audiolanguageconfiguration-identifymultiplelanguages
            '''
            result = self._values.get("identify_multiple_languages")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def input_languages(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The input language of your audio.

            This can be set to any of the currently supported languages via the language codes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiolanguageconfiguration.html#cfn-bedrock-dataautomationproject-audiolanguageconfiguration-inputlanguages
            '''
            result = self._values.get("input_languages")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioLanguageConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "language_configuration": "languageConfiguration",
            "modality_processing": "modalityProcessing",
            "sensitive_data_configuration": "sensitiveDataConfiguration",
        },
    )
    class AudioOverrideConfigurationProperty:
        def __init__(
            self,
            *,
            language_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            modality_processing: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sensitive_data_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Sets whether your project will process audio or not.

            :param language_configuration: The output and input language configuration for your audio.
            :param modality_processing: Sets modality processing for audio files. All modalities are enabled by default.
            :param sensitive_data_configuration: Configuration for sensitive data detection and redaction for audio files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiooverrideconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_override_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty(
                    language_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty(
                        generative_output_language="generativeOutputLanguage",
                        identify_multiple_languages=False,
                        input_languages=["inputLanguages"]
                    ),
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__53e5acfec74299b284520fc73f184483d6b757e363daacb5bf484c9f81fb1b75)
                check_type(argname="argument language_configuration", value=language_configuration, expected_type=type_hints["language_configuration"])
                check_type(argname="argument modality_processing", value=modality_processing, expected_type=type_hints["modality_processing"])
                check_type(argname="argument sensitive_data_configuration", value=sensitive_data_configuration, expected_type=type_hints["sensitive_data_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if language_configuration is not None:
                self._values["language_configuration"] = language_configuration
            if modality_processing is not None:
                self._values["modality_processing"] = modality_processing
            if sensitive_data_configuration is not None:
                self._values["sensitive_data_configuration"] = sensitive_data_configuration

        @builtins.property
        def language_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty"]]:
            '''The output and input language configuration for your audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiooverrideconfiguration.html#cfn-bedrock-dataautomationproject-audiooverrideconfiguration-languageconfiguration
            '''
            result = self._values.get("language_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty"]], result)

        @builtins.property
        def modality_processing(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]]:
            '''Sets modality processing for audio files.

            All modalities are enabled by default.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiooverrideconfiguration.html#cfn-bedrock-dataautomationproject-audiooverrideconfiguration-modalityprocessing
            '''
            result = self._values.get("modality_processing")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]], result)

        @builtins.property
        def sensitive_data_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]]:
            '''Configuration for sensitive data detection and redaction for audio files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiooverrideconfiguration.html#cfn-bedrock-dataautomationproject-audiooverrideconfiguration-sensitivedataconfiguration
            '''
            result = self._values.get("sensitive_data_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioOverrideConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty",
        jsii_struct_bases=[],
        name_mapping={"category": "category"},
    )
    class AudioStandardExtractionProperty:
        def __init__(
            self,
            *,
            category: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Settings for generating data from audio.

            :param category: Settings for generating data from audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardextraction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_standard_extraction_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty(
                    category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty(
                        state="state",
                        type_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                            transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                                channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                                    state="state"
                                ),
                                speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                                    state="state"
                                )
                            )
                        ),
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d40763167212cadc7c5780a8a6baf33bc91e74281e0b1dd8143833399b9905e1)
                check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if category is not None:
                self._values["category"] = category

        @builtins.property
        def category(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty"]]:
            '''Settings for generating data from audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardextraction.html#cfn-bedrock-dataautomationproject-audiostandardextraction-category
            '''
            result = self._values.get("category")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioStandardExtractionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state", "types": "types"},
    )
    class AudioStandardGenerativeFieldProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Settings for generating descriptions of audio.

            :param state: Whether generating descriptions is enabled for audio.
            :param types: The types of description to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardgenerativefield.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_standard_generative_field_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty(
                    state="state",
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__44656c8d5b9913277cba1e38291040198ef0c8fd641efd8f3488f2f1eecc4667)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating descriptions is enabled for audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardgenerativefield.html#cfn-bedrock-dataautomationproject-audiostandardgenerativefield-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The types of description to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardgenerativefield.html#cfn-bedrock-dataautomationproject-audiostandardgenerativefield-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioStandardGenerativeFieldProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "extraction": "extraction",
            "generative_field": "generativeField",
        },
    )
    class AudioStandardOutputConfigurationProperty:
        def __init__(
            self,
            *,
            extraction: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            generative_field: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Output settings for processing audio.

            :param extraction: Settings for populating data fields that describe the audio.
            :param generative_field: Whether to generate descriptions of the data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardoutputconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_standard_output_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty(
                        category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty(
                            state="state",
                            type_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                                transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                                    channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                                        state="state"
                                    ),
                                    speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                                        state="state"
                                    )
                                )
                            ),
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty(
                        state="state",
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__735bb95d54747b5bc4e87a47bcabe4cc5fe11b0c1d63ed3cff65c5ffac858793)
                check_type(argname="argument extraction", value=extraction, expected_type=type_hints["extraction"])
                check_type(argname="argument generative_field", value=generative_field, expected_type=type_hints["generative_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if extraction is not None:
                self._values["extraction"] = extraction
            if generative_field is not None:
                self._values["generative_field"] = generative_field

        @builtins.property
        def extraction(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty"]]:
            '''Settings for populating data fields that describe the audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-audiostandardoutputconfiguration-extraction
            '''
            result = self._values.get("extraction")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty"]], result)

        @builtins.property
        def generative_field(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty"]]:
            '''Whether to generate descriptions of the data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-audiostandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-audiostandardoutputconfiguration-generativefield
            '''
            result = self._values.get("generative_field")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioStandardOutputConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.BlueprintItemProperty",
        jsii_struct_bases=[],
        name_mapping={
            "blueprint_arn": "blueprintArn",
            "blueprint_stage": "blueprintStage",
            "blueprint_version": "blueprintVersion",
        },
    )
    class BlueprintItemProperty:
        def __init__(
            self,
            *,
            blueprint_arn: typing.Optional[builtins.str] = None,
            blueprint_stage: typing.Optional[builtins.str] = None,
            blueprint_version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An abbreviated summary of a blueprint.

            :param blueprint_arn: The blueprint's ARN.
            :param blueprint_stage: The blueprint's stage.
            :param blueprint_version: The blueprint's version.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-blueprintitem.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                blueprint_item_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.BlueprintItemProperty(
                    blueprint_arn="blueprintArn",
                    blueprint_stage="blueprintStage",
                    blueprint_version="blueprintVersion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d5f5e2e809246ca609d3868a1f7f9e1f4df05ad10cc3166cb9af0ea64d9cc7b5)
                check_type(argname="argument blueprint_arn", value=blueprint_arn, expected_type=type_hints["blueprint_arn"])
                check_type(argname="argument blueprint_stage", value=blueprint_stage, expected_type=type_hints["blueprint_stage"])
                check_type(argname="argument blueprint_version", value=blueprint_version, expected_type=type_hints["blueprint_version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if blueprint_arn is not None:
                self._values["blueprint_arn"] = blueprint_arn
            if blueprint_stage is not None:
                self._values["blueprint_stage"] = blueprint_stage
            if blueprint_version is not None:
                self._values["blueprint_version"] = blueprint_version

        @builtins.property
        def blueprint_arn(self) -> typing.Optional[builtins.str]:
            '''The blueprint's ARN.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-blueprintitem.html#cfn-bedrock-dataautomationproject-blueprintitem-blueprintarn
            '''
            result = self._values.get("blueprint_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def blueprint_stage(self) -> typing.Optional[builtins.str]:
            '''The blueprint's stage.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-blueprintitem.html#cfn-bedrock-dataautomationproject-blueprintitem-blueprintstage
            '''
            result = self._values.get("blueprint_stage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def blueprint_version(self) -> typing.Optional[builtins.str]:
            '''The blueprint's version.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-blueprintitem.html#cfn-bedrock-dataautomationproject-blueprintitem-blueprintversion
            '''
            result = self._values.get("blueprint_version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlueprintItemProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class ChannelLabelingConfigurationProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Enables or disables channel labeling.

            Channel labeling, when enabled will assign a number to each audio channel, and indicate which channel is being used in each portion of the transcript. This appears in the response as "ch_0" for the first channel, and "ch_1" for the second.

            :param state: State of channel labeling, either enabled or disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-channellabelingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                channel_labeling_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__190d9739b6522c0e98df05bc232971ba3d6753a299275a99226347e6cb42f151)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''State of channel labeling, either enabled or disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-channellabelingconfiguration.html#cfn-bedrock-dataautomationproject-channellabelingconfiguration-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ChannelLabelingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"blueprints": "blueprints"},
    )
    class CustomOutputConfigurationProperty:
        def __init__(
            self,
            *,
            blueprints: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.BlueprintItemProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Blueprints to apply to objects processed by the project.

            :param blueprints: A list of blueprints.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-customoutputconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                custom_output_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty(
                    blueprints=[bedrock_mixins.CfnDataAutomationProjectPropsMixin.BlueprintItemProperty(
                        blueprint_arn="blueprintArn",
                        blueprint_stage="blueprintStage",
                        blueprint_version="blueprintVersion"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__12ec0dc1ef52a24343a13536faa962c8e3788ed427c2c5e068832ab49fa66b35)
                check_type(argname="argument blueprints", value=blueprints, expected_type=type_hints["blueprints"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if blueprints is not None:
                self._values["blueprints"] = blueprints

        @builtins.property
        def blueprints(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.BlueprintItemProperty"]]]]:
            '''A list of blueprints.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-customoutputconfiguration.html#cfn-bedrock-dataautomationproject-customoutputconfiguration-blueprints
            '''
            result = self._values.get("blueprints")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.BlueprintItemProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CustomOutputConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class DocumentBoundingBoxProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Bounding box settings for documents.

            :param state: Whether bounding boxes are enabled for documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentboundingbox.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_bounding_box_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8951904d09672ba205751d7fc2a522321d7e52411b8ef8fded9c4e1a033c3be6)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether bounding boxes are enabled for documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentboundingbox.html#cfn-bedrock-dataautomationproject-documentboundingbox-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentBoundingBoxProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty",
        jsii_struct_bases=[],
        name_mapping={"types": "types"},
    )
    class DocumentExtractionGranularityProperty:
        def __init__(
            self,
            *,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Granularity settings for documents.

            :param types: Granularity settings for documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentextractiongranularity.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_extraction_granularity_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty(
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b2f1e311cd9f356e764c6344a42f3a02ba90d0a18722ebfb8bff1aada39a4857)
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Granularity settings for documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentextractiongranularity.html#cfn-bedrock-dataautomationproject-documentextractiongranularity-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentExtractionGranularityProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class DocumentOutputAdditionalFileFormatProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Output settings for additional file formats.

            :param state: Whether additional file formats are enabled for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputadditionalfileformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_output_additional_file_format_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__76c8521b95f341304ab3a222219a04bbf2ceb17f1ea792310fced0b4dd9983c6)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether additional file formats are enabled for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputadditionalfileformat.html#cfn-bedrock-dataautomationproject-documentoutputadditionalfileformat-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentOutputAdditionalFileFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_file_format": "additionalFileFormat",
            "text_format": "textFormat",
        },
    )
    class DocumentOutputFormatProperty:
        def __init__(
            self,
            *,
            additional_file_format: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text_format: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''A document output format.

            :param additional_file_format: Output settings for additional file formats.
            :param text_format: An output text format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_output_format_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty(
                    additional_file_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty(
                        state="state"
                    ),
                    text_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty(
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__428a438c7cf92c0b8cafd1aa4a56c53ea9ea1b589a03f639fe918843bfd99600)
                check_type(argname="argument additional_file_format", value=additional_file_format, expected_type=type_hints["additional_file_format"])
                check_type(argname="argument text_format", value=text_format, expected_type=type_hints["text_format"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_file_format is not None:
                self._values["additional_file_format"] = additional_file_format
            if text_format is not None:
                self._values["text_format"] = text_format

        @builtins.property
        def additional_file_format(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty"]]:
            '''Output settings for additional file formats.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputformat.html#cfn-bedrock-dataautomationproject-documentoutputformat-additionalfileformat
            '''
            result = self._values.get("additional_file_format")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty"]], result)

        @builtins.property
        def text_format(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty"]]:
            '''An output text format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputformat.html#cfn-bedrock-dataautomationproject-documentoutputformat-textformat
            '''
            result = self._values.get("text_format")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentOutputFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty",
        jsii_struct_bases=[],
        name_mapping={"types": "types"},
    )
    class DocumentOutputTextFormatProperty:
        def __init__(
            self,
            *,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''An output text format.

            :param types: The types of output text to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputtextformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_output_text_format_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty(
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a39c942d4c66d145361d69ec6f7822ed8c5de90908d2f3b9acce7f6fdc0137bc)
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The types of output text to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoutputtextformat.html#cfn-bedrock-dataautomationproject-documentoutputtextformat-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentOutputTextFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "modality_processing": "modalityProcessing",
            "sensitive_data_configuration": "sensitiveDataConfiguration",
            "splitter": "splitter",
        },
    )
    class DocumentOverrideConfigurationProperty:
        def __init__(
            self,
            *,
            modality_processing: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sensitive_data_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            splitter: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Additional settings for a project.

            :param modality_processing: Sets modality processing for document files. All modalities are enabled by default.
            :param sensitive_data_configuration: Configuration for sensitive data detection and redaction for document files.
            :param splitter: Whether document splitter is enabled for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoverrideconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_override_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty(
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    ),
                    splitter=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty(
                        state="state"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2b8bd6b062082279b6cd00e1cc913b44395a1a04760d248b1eb5a80b40345643)
                check_type(argname="argument modality_processing", value=modality_processing, expected_type=type_hints["modality_processing"])
                check_type(argname="argument sensitive_data_configuration", value=sensitive_data_configuration, expected_type=type_hints["sensitive_data_configuration"])
                check_type(argname="argument splitter", value=splitter, expected_type=type_hints["splitter"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if modality_processing is not None:
                self._values["modality_processing"] = modality_processing
            if sensitive_data_configuration is not None:
                self._values["sensitive_data_configuration"] = sensitive_data_configuration
            if splitter is not None:
                self._values["splitter"] = splitter

        @builtins.property
        def modality_processing(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]]:
            '''Sets modality processing for document files.

            All modalities are enabled by default.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoverrideconfiguration.html#cfn-bedrock-dataautomationproject-documentoverrideconfiguration-modalityprocessing
            '''
            result = self._values.get("modality_processing")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]], result)

        @builtins.property
        def sensitive_data_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]]:
            '''Configuration for sensitive data detection and redaction for document files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoverrideconfiguration.html#cfn-bedrock-dataautomationproject-documentoverrideconfiguration-sensitivedataconfiguration
            '''
            result = self._values.get("sensitive_data_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]], result)

        @builtins.property
        def splitter(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty"]]:
            '''Whether document splitter is enabled for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentoverrideconfiguration.html#cfn-bedrock-dataautomationproject-documentoverrideconfiguration-splitter
            '''
            result = self._values.get("splitter")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentOverrideConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty",
        jsii_struct_bases=[],
        name_mapping={"bounding_box": "boundingBox", "granularity": "granularity"},
    )
    class DocumentStandardExtractionProperty:
        def __init__(
            self,
            *,
            bounding_box: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            granularity: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Settings for generating data from documents.

            :param bounding_box: Whether to generate bounding boxes.
            :param granularity: Which granularities to generate data for.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardextraction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_standard_extraction_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty(
                    bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty(
                        state="state"
                    ),
                    granularity=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty(
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__31fd8cf11b2333c1b9f18cb85de3d2ec6f775ca9373527945bf2cebc9364d322)
                check_type(argname="argument bounding_box", value=bounding_box, expected_type=type_hints["bounding_box"])
                check_type(argname="argument granularity", value=granularity, expected_type=type_hints["granularity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bounding_box is not None:
                self._values["bounding_box"] = bounding_box
            if granularity is not None:
                self._values["granularity"] = granularity

        @builtins.property
        def bounding_box(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty"]]:
            '''Whether to generate bounding boxes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardextraction.html#cfn-bedrock-dataautomationproject-documentstandardextraction-boundingbox
            '''
            result = self._values.get("bounding_box")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty"]], result)

        @builtins.property
        def granularity(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty"]]:
            '''Which granularities to generate data for.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardextraction.html#cfn-bedrock-dataautomationproject-documentstandardextraction-granularity
            '''
            result = self._values.get("granularity")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentStandardExtractionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class DocumentStandardGenerativeFieldProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Settings for generating descriptions of documents.

            :param state: Whether generating descriptions is enabled for documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardgenerativefield.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_standard_generative_field_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__283f3e1f9a29bf9b419282eae3d9a9986755bdd2d31fc1807abffb8f593d750a)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating descriptions is enabled for documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardgenerativefield.html#cfn-bedrock-dataautomationproject-documentstandardgenerativefield-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentStandardGenerativeFieldProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "extraction": "extraction",
            "generative_field": "generativeField",
            "output_format": "outputFormat",
        },
    )
    class DocumentStandardOutputConfigurationProperty:
        def __init__(
            self,
            *,
            extraction: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            generative_field: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            output_format: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Output settings for processing documents.

            :param extraction: Settings for populating data fields that describe the document.
            :param generative_field: Whether to generate descriptions.
            :param output_format: The output format to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardoutputconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                document_standard_output_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty(
                        bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty(
                            state="state"
                        ),
                        granularity=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty(
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty(
                        state="state"
                    ),
                    output_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty(
                        additional_file_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty(
                            state="state"
                        ),
                        text_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty(
                            types=["types"]
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7f2a6254e9da18a309ea89791739a405a2e9e9bf02efdf14704c05dc4991f457)
                check_type(argname="argument extraction", value=extraction, expected_type=type_hints["extraction"])
                check_type(argname="argument generative_field", value=generative_field, expected_type=type_hints["generative_field"])
                check_type(argname="argument output_format", value=output_format, expected_type=type_hints["output_format"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if extraction is not None:
                self._values["extraction"] = extraction
            if generative_field is not None:
                self._values["generative_field"] = generative_field
            if output_format is not None:
                self._values["output_format"] = output_format

        @builtins.property
        def extraction(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty"]]:
            '''Settings for populating data fields that describe the document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-documentstandardoutputconfiguration-extraction
            '''
            result = self._values.get("extraction")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty"]], result)

        @builtins.property
        def generative_field(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty"]]:
            '''Whether to generate descriptions.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-documentstandardoutputconfiguration-generativefield
            '''
            result = self._values.get("generative_field")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty"]], result)

        @builtins.property
        def output_format(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty"]]:
            '''The output format to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-documentstandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-documentstandardoutputconfiguration-outputformat
            '''
            result = self._values.get("output_format")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DocumentStandardOutputConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class ImageBoundingBoxProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Bounding box settings for a project.

            :param state: Bounding box settings for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageboundingbox.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                image_bounding_box_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__43d184195fb8b005c0ce7faa36abbded3dcaa817ac56ad44382e3b52f0b4aa17)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Bounding box settings for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageboundingbox.html#cfn-bedrock-dataautomationproject-imageboundingbox-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageBoundingBoxProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state", "types": "types"},
    )
    class ImageExtractionCategoryProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Settings for generating categorical data from images.

            :param state: Whether generating categorical data from images is enabled.
            :param types: The types of data to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageextractioncategory.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                image_extraction_category_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty(
                    state="state",
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fbcdba2585e0fbb56dc98a0d3e4cd5058cbab7bc5ec12ccaeac1086de5055e50)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating categorical data from images is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageextractioncategory.html#cfn-bedrock-dataautomationproject-imageextractioncategory-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The types of data to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageextractioncategory.html#cfn-bedrock-dataautomationproject-imageextractioncategory-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageExtractionCategoryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "modality_processing": "modalityProcessing",
            "sensitive_data_configuration": "sensitiveDataConfiguration",
        },
    )
    class ImageOverrideConfigurationProperty:
        def __init__(
            self,
            *,
            modality_processing: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sensitive_data_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Sets whether your project will process images or not.

            :param modality_processing: Sets modality processing for image files. All modalities are enabled by default.
            :param sensitive_data_configuration: Configuration for sensitive data detection and redaction for image files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageoverrideconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                image_override_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty(
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__38f8b4b603232fbd0d7b3c548d01d3dfdc30fb00a784fcb7304f56425bf54afb)
                check_type(argname="argument modality_processing", value=modality_processing, expected_type=type_hints["modality_processing"])
                check_type(argname="argument sensitive_data_configuration", value=sensitive_data_configuration, expected_type=type_hints["sensitive_data_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if modality_processing is not None:
                self._values["modality_processing"] = modality_processing
            if sensitive_data_configuration is not None:
                self._values["sensitive_data_configuration"] = sensitive_data_configuration

        @builtins.property
        def modality_processing(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]]:
            '''Sets modality processing for image files.

            All modalities are enabled by default.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageoverrideconfiguration.html#cfn-bedrock-dataautomationproject-imageoverrideconfiguration-modalityprocessing
            '''
            result = self._values.get("modality_processing")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]], result)

        @builtins.property
        def sensitive_data_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]]:
            '''Configuration for sensitive data detection and redaction for image files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imageoverrideconfiguration.html#cfn-bedrock-dataautomationproject-imageoverrideconfiguration-sensitivedataconfiguration
            '''
            result = self._values.get("sensitive_data_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageOverrideConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty",
        jsii_struct_bases=[],
        name_mapping={"bounding_box": "boundingBox", "category": "category"},
    )
    class ImageStandardExtractionProperty:
        def __init__(
            self,
            *,
            bounding_box: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            category: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Settings for generating data from images.

            :param bounding_box: Settings for generating bounding boxes.
            :param category: Settings for generating categorical data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardextraction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                image_standard_extraction_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty(
                    bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty(
                        state="state"
                    ),
                    category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty(
                        state="state",
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4fa905b045efa2dc215f79ec19c1ab828f0857d05dd5d5d938be99d7ec65850e)
                check_type(argname="argument bounding_box", value=bounding_box, expected_type=type_hints["bounding_box"])
                check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bounding_box is not None:
                self._values["bounding_box"] = bounding_box
            if category is not None:
                self._values["category"] = category

        @builtins.property
        def bounding_box(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty"]]:
            '''Settings for generating bounding boxes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardextraction.html#cfn-bedrock-dataautomationproject-imagestandardextraction-boundingbox
            '''
            result = self._values.get("bounding_box")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty"]], result)

        @builtins.property
        def category(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty"]]:
            '''Settings for generating categorical data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardextraction.html#cfn-bedrock-dataautomationproject-imagestandardextraction-category
            '''
            result = self._values.get("category")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageStandardExtractionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state", "types": "types"},
    )
    class ImageStandardGenerativeFieldProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Settings for generating descriptions of images.

            :param state: Whether generating descriptions is enabled for images.
            :param types: Settings for generating descriptions of images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardgenerativefield.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                image_standard_generative_field_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty(
                    state="state",
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e67a2ac681d5efa7009d1c5670aa995aaaef578d2ee5357b06a49538bdda461a)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating descriptions is enabled for images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardgenerativefield.html#cfn-bedrock-dataautomationproject-imagestandardgenerativefield-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Settings for generating descriptions of images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardgenerativefield.html#cfn-bedrock-dataautomationproject-imagestandardgenerativefield-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageStandardGenerativeFieldProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "extraction": "extraction",
            "generative_field": "generativeField",
        },
    )
    class ImageStandardOutputConfigurationProperty:
        def __init__(
            self,
            *,
            extraction: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            generative_field: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Output settings for processing images.

            :param extraction: Settings for populating data fields that describe the image.
            :param generative_field: Whether to generate descriptions of the data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardoutputconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                image_standard_output_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty(
                        bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty(
                            state="state"
                        ),
                        category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty(
                        state="state",
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dac6087c97193f099d2ae4210570149c1ec4763ab09dd8b7fc2d51827f2bf993)
                check_type(argname="argument extraction", value=extraction, expected_type=type_hints["extraction"])
                check_type(argname="argument generative_field", value=generative_field, expected_type=type_hints["generative_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if extraction is not None:
                self._values["extraction"] = extraction
            if generative_field is not None:
                self._values["generative_field"] = generative_field

        @builtins.property
        def extraction(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty"]]:
            '''Settings for populating data fields that describe the image.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-imagestandardoutputconfiguration-extraction
            '''
            result = self._values.get("extraction")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty"]], result)

        @builtins.property
        def generative_field(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty"]]:
            '''Whether to generate descriptions of the data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-imagestandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-imagestandardoutputconfiguration-generativefield
            '''
            result = self._values.get("generative_field")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ImageStandardOutputConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class ModalityProcessingConfigurationProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''This element is used to determine if the modality it is associated with is enabled or disabled.

            All modalities are enabled by default.

            :param state: Stores the state of the modality for your project, set to either enabled or disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityprocessingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                modality_processing_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7a7664cc5b52054d19494996b4d27e5ae70ff9c0072d0dab1d790a4ee4728de8)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Stores the state of the modality for your project, set to either enabled or disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityprocessingconfiguration.html#cfn-bedrock-dataautomationproject-modalityprocessingconfiguration-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ModalityProcessingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"jpeg": "jpeg", "mov": "mov", "mp4": "mp4", "png": "png"},
    )
    class ModalityRoutingConfigurationProperty:
        def __init__(
            self,
            *,
            jpeg: typing.Optional[builtins.str] = None,
            mov: typing.Optional[builtins.str] = None,
            mp4: typing.Optional[builtins.str] = None,
            png: typing.Optional[builtins.str] = None,
        ) -> None:
            '''This element allows you to set up where JPEG, PNG, MOV, and MP4 files get routed to for processing.

            JPEG routing applies to both "JPEG" and "JPG" file extensions.

            :param jpeg: Sets whether JPEG files are routed to document or image processing.
            :param mov: Sets whether MOV files are routed to audio or video processing.
            :param mp4: Sets whether MP4 files are routed to audio or video processing.
            :param png: Sets whether PNG files are routed to document or image processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityroutingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                modality_routing_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty(
                    jpeg="jpeg",
                    mov="mov",
                    mp4="mp4",
                    png="png"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c1ab8028275d00d0696724da41857bd8add804414bbad214b1c07ddb578ceff8)
                check_type(argname="argument jpeg", value=jpeg, expected_type=type_hints["jpeg"])
                check_type(argname="argument mov", value=mov, expected_type=type_hints["mov"])
                check_type(argname="argument mp4", value=mp4, expected_type=type_hints["mp4"])
                check_type(argname="argument png", value=png, expected_type=type_hints["png"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if jpeg is not None:
                self._values["jpeg"] = jpeg
            if mov is not None:
                self._values["mov"] = mov
            if mp4 is not None:
                self._values["mp4"] = mp4
            if png is not None:
                self._values["png"] = png

        @builtins.property
        def jpeg(self) -> typing.Optional[builtins.str]:
            '''Sets whether JPEG files are routed to document or image processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityroutingconfiguration.html#cfn-bedrock-dataautomationproject-modalityroutingconfiguration-jpeg
            '''
            result = self._values.get("jpeg")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def mov(self) -> typing.Optional[builtins.str]:
            '''Sets whether MOV files are routed to audio or video processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityroutingconfiguration.html#cfn-bedrock-dataautomationproject-modalityroutingconfiguration-mov
            '''
            result = self._values.get("mov")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def mp4(self) -> typing.Optional[builtins.str]:
            '''Sets whether MP4 files are routed to audio or video processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityroutingconfiguration.html#cfn-bedrock-dataautomationproject-modalityroutingconfiguration-mp4
            '''
            result = self._values.get("mp4")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def png(self) -> typing.Optional[builtins.str]:
            '''Sets whether PNG files are routed to document or image processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-modalityroutingconfiguration.html#cfn-bedrock-dataautomationproject-modalityroutingconfiguration-png
            '''
            result = self._values.get("png")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ModalityRoutingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "audio": "audio",
            "document": "document",
            "image": "image",
            "modality_routing": "modalityRouting",
            "video": "video",
        },
    )
    class OverrideConfigurationProperty:
        def __init__(
            self,
            *,
            audio: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            document: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            image: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            modality_routing: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            video: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Additional settings for a project.

            :param audio: This element declares whether your project will process audio files.
            :param document: Additional settings for a project.
            :param image: This element declares whether your project will process image files.
            :param modality_routing: Lets you set which modalities certain file types are processed as.
            :param video: This element declares whether your project will process video files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-overrideconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                override_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty(
                    audio=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty(
                        language_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty(
                            generative_output_language="generativeOutputLanguage",
                            identify_multiple_languages=False,
                            input_languages=["inputLanguages"]
                        ),
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        )
                    ),
                    document=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty(
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        ),
                        splitter=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty(
                            state="state"
                        )
                    ),
                    image=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty(
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        )
                    ),
                    modality_routing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty(
                        jpeg="jpeg",
                        mov="mov",
                        mp4="mp4",
                        png="png"
                    ),
                    video=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty(
                        modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                            state="state"
                        ),
                        sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                            detection_mode="detectionMode",
                            detection_scope=["detectionScope"],
                            pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                                pii_entity_types=["piiEntityTypes"],
                                redaction_mask_mode="redactionMaskMode"
                            )
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cdd8d052fc6012fa7e3c7178b0041e500e593fb09968568d344504b9e29ac1d3)
                check_type(argname="argument audio", value=audio, expected_type=type_hints["audio"])
                check_type(argname="argument document", value=document, expected_type=type_hints["document"])
                check_type(argname="argument image", value=image, expected_type=type_hints["image"])
                check_type(argname="argument modality_routing", value=modality_routing, expected_type=type_hints["modality_routing"])
                check_type(argname="argument video", value=video, expected_type=type_hints["video"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if audio is not None:
                self._values["audio"] = audio
            if document is not None:
                self._values["document"] = document
            if image is not None:
                self._values["image"] = image
            if modality_routing is not None:
                self._values["modality_routing"] = modality_routing
            if video is not None:
                self._values["video"] = video

        @builtins.property
        def audio(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty"]]:
            '''This element declares whether your project will process audio files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-overrideconfiguration.html#cfn-bedrock-dataautomationproject-overrideconfiguration-audio
            '''
            result = self._values.get("audio")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty"]], result)

        @builtins.property
        def document(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty"]]:
            '''Additional settings for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-overrideconfiguration.html#cfn-bedrock-dataautomationproject-overrideconfiguration-document
            '''
            result = self._values.get("document")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty"]], result)

        @builtins.property
        def image(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty"]]:
            '''This element declares whether your project will process image files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-overrideconfiguration.html#cfn-bedrock-dataautomationproject-overrideconfiguration-image
            '''
            result = self._values.get("image")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty"]], result)

        @builtins.property
        def modality_routing(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty"]]:
            '''Lets you set which modalities certain file types are processed as.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-overrideconfiguration.html#cfn-bedrock-dataautomationproject-overrideconfiguration-modalityrouting
            '''
            result = self._values.get("modality_routing")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty"]], result)

        @builtins.property
        def video(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty"]]:
            '''This element declares whether your project will process video files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-overrideconfiguration.html#cfn-bedrock-dataautomationproject-overrideconfiguration-video
            '''
            result = self._values.get("video")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OverrideConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "pii_entity_types": "piiEntityTypes",
            "redaction_mask_mode": "redactionMaskMode",
        },
    )
    class PIIEntitiesConfigurationProperty:
        def __init__(
            self,
            *,
            pii_entity_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            redaction_mask_mode: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration for detecting and redacting Personally Identifiable Information (PII) entities.

            Specify which PII entity types to detect and the redaction mask mode. If not provided, defaults to ALL entity types with ENTITY_TYPE redaction mask mode.

            :param pii_entity_types: List of PII entity types to detect/redact in the output. Choose from specific entity types (such as ADDRESS, NAME, EMAIL, PHONE, US_SOCIAL_SECURITY_NUMBER) or specify ALL to detect all supported PII types. If not specified, defaults to ALL.
            :param redaction_mask_mode: Defines how detected PII entities are masked in redacted output files. Set to PII to replace all detected entities with a generic [PII] marker regardless of entity type. Set to ENTITY_TYPE to replace each detected entity with its specific type marker (for example, [NAME], [EMAIL], [ADDRESS]). This setting only applies when detectionMode is set to DETECTION_AND_REDACTION. If not specified, defaults to ENTITY_TYPE.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-piientitiesconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                p_iIEntities_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                    pii_entity_types=["piiEntityTypes"],
                    redaction_mask_mode="redactionMaskMode"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9e4ed9613490afcb781e4f3d3d5282d38f9ec1fe674d7810a9fdf52fa830a8ec)
                check_type(argname="argument pii_entity_types", value=pii_entity_types, expected_type=type_hints["pii_entity_types"])
                check_type(argname="argument redaction_mask_mode", value=redaction_mask_mode, expected_type=type_hints["redaction_mask_mode"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if pii_entity_types is not None:
                self._values["pii_entity_types"] = pii_entity_types
            if redaction_mask_mode is not None:
                self._values["redaction_mask_mode"] = redaction_mask_mode

        @builtins.property
        def pii_entity_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''List of PII entity types to detect/redact in the output.

            Choose from specific entity types (such as ADDRESS, NAME, EMAIL, PHONE, US_SOCIAL_SECURITY_NUMBER) or specify ALL to detect all supported PII types. If not specified, defaults to ALL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-piientitiesconfiguration.html#cfn-bedrock-dataautomationproject-piientitiesconfiguration-piientitytypes
            '''
            result = self._values.get("pii_entity_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def redaction_mask_mode(self) -> typing.Optional[builtins.str]:
            '''Defines how detected PII entities are masked in redacted output files.

            Set to PII to replace all detected entities with a generic [PII] marker regardless of entity type. Set to ENTITY_TYPE to replace each detected entity with its specific type marker (for example, [NAME], [EMAIL], [ADDRESS]). This setting only applies when detectionMode is set to DETECTION_AND_REDACTION. If not specified, defaults to ENTITY_TYPE.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-piientitiesconfiguration.html#cfn-bedrock-dataautomationproject-piientitiesconfiguration-redactionmaskmode
            '''
            result = self._values.get("redaction_mask_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PIIEntitiesConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "detection_mode": "detectionMode",
            "detection_scope": "detectionScope",
            "pii_entities_configuration": "piiEntitiesConfiguration",
        },
    )
    class SensitiveDataConfigurationProperty:
        def __init__(
            self,
            *,
            detection_mode: typing.Optional[builtins.str] = None,
            detection_scope: typing.Optional[typing.Sequence[builtins.str]] = None,
            pii_entities_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configuration for detecting and redacting sensitive data in content.

            Use this to control whether sensitive data is detected only or both detected and redacted, specify the scope of detection (standard output, custom output, or both), and configure specific PII entity types to detect along with how they should be masked when redacted.

            :param detection_mode: Specifies the mode for handling sensitive data detection. Set to DETECTION to only identify sensitive data without modifying content - this produces one output file per detection scope containing detection information with original unredacted content. Set to DETECTION_AND_REDACTION to both identify and mask sensitive data - this produces two output files per detection scope: one unredacted file with detection information and one redacted file with masking applied to sensitive content. For example, if detectionScope includes both STANDARD and CUSTOM with DETECTION_AND_REDACTION mode, four output files will be generated (two for standard output and two for custom output).
            :param detection_scope: Defines which BDA output types to apply sensitive data detection to. Specify STANDARD to detect sensitive data in standard output, CUSTOM to detect in custom output (blueprint-based extraction), or both to apply detection to both output types. If not specified, defaults to both STANDARD and CUSTOM. The number of output files generated depends on both the detection mode and the scopes selected - each scope specified will produce its own set of output files according to the detection mode configured.
            :param pii_entities_configuration: Configuration for detecting and redacting Personally Identifiable Information (PII) entities.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-sensitivedataconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                sensitive_data_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                    detection_mode="detectionMode",
                    detection_scope=["detectionScope"],
                    pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                        pii_entity_types=["piiEntityTypes"],
                        redaction_mask_mode="redactionMaskMode"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f7aee36d1a4510935646355d4fac6c38dbb023d44c3e12ef150f02c6da420b72)
                check_type(argname="argument detection_mode", value=detection_mode, expected_type=type_hints["detection_mode"])
                check_type(argname="argument detection_scope", value=detection_scope, expected_type=type_hints["detection_scope"])
                check_type(argname="argument pii_entities_configuration", value=pii_entities_configuration, expected_type=type_hints["pii_entities_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if detection_mode is not None:
                self._values["detection_mode"] = detection_mode
            if detection_scope is not None:
                self._values["detection_scope"] = detection_scope
            if pii_entities_configuration is not None:
                self._values["pii_entities_configuration"] = pii_entities_configuration

        @builtins.property
        def detection_mode(self) -> typing.Optional[builtins.str]:
            '''Specifies the mode for handling sensitive data detection.

            Set to DETECTION to only identify sensitive data without modifying content - this produces one output file per detection scope containing detection information with original unredacted content. Set to DETECTION_AND_REDACTION to both identify and mask sensitive data - this produces two output files per detection scope: one unredacted file with detection information and one redacted file with masking applied to sensitive content. For example, if detectionScope includes both STANDARD and CUSTOM with DETECTION_AND_REDACTION mode, four output files will be generated (two for standard output and two for custom output).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-sensitivedataconfiguration.html#cfn-bedrock-dataautomationproject-sensitivedataconfiguration-detectionmode
            '''
            result = self._values.get("detection_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def detection_scope(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Defines which BDA output types to apply sensitive data detection to.

            Specify STANDARD to detect sensitive data in standard output, CUSTOM to detect in custom output (blueprint-based extraction), or both to apply detection to both output types. If not specified, defaults to both STANDARD and CUSTOM. The number of output files generated depends on both the detection mode and the scopes selected - each scope specified will produce its own set of output files according to the detection mode configured.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-sensitivedataconfiguration.html#cfn-bedrock-dataautomationproject-sensitivedataconfiguration-detectionscope
            '''
            result = self._values.get("detection_scope")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def pii_entities_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty"]]:
            '''Configuration for detecting and redacting Personally Identifiable Information (PII) entities.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-sensitivedataconfiguration.html#cfn-bedrock-dataautomationproject-sensitivedataconfiguration-piientitiesconfiguration
            '''
            result = self._values.get("pii_entities_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SensitiveDataConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class SpeakerLabelingConfigurationProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Enables or disables speaker labeling.

            Speaker labeling, when enabled will assign a number to each speaker, and indicate which speaker is talking in each portion of the transcript. This appears in the response as "spk_0" for the first speaker, "spk_1" for the second, and so on for up to 30 speakers.

            :param state: State of speaker labeling, either enabled or disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-speakerlabelingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                speaker_labeling_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bd39f66f68f5cabdcf5186a41331af8c1b049c0e5b0faf1f1ae7852a30fd6155)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''State of speaker labeling, either enabled or disabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-speakerlabelingconfiguration.html#cfn-bedrock-dataautomationproject-speakerlabelingconfiguration-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpeakerLabelingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class SplitterConfigurationProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Document splitter settings.

            If a document is too large to be processed in one pass, the document splitter splits it into smaller documents.

            :param state: Whether document splitter is enabled for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-splitterconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                splitter_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__725551fc561b5af6ced2386775973359d5268cd64b7cb90d850d0ebec4e5b11c)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether document splitter is enabled for a project.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-splitterconfiguration.html#cfn-bedrock-dataautomationproject-splitterconfiguration-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SplitterConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "audio": "audio",
            "document": "document",
            "image": "image",
            "video": "video",
        },
    )
    class StandardOutputConfigurationProperty:
        def __init__(
            self,
            *,
            audio: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            document: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            image: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            video: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The project's standard output configuration.

            :param audio: Settings for processing audio.
            :param document: Settings for processing documents.
            :param image: Settings for processing images.
            :param video: Settings for processing video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-standardoutputconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                standard_output_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty(
                    audio=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty(
                            category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty(
                                state="state",
                                type_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty(
                                    transcript=bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                                        channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                                            state="state"
                                        ),
                                        speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                                            state="state"
                                        )
                                    )
                                ),
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    document=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty(
                            bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty(
                                state="state"
                            ),
                            granularity=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty(
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty(
                            state="state"
                        ),
                        output_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty(
                            additional_file_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty(
                                state="state"
                            ),
                            text_format=bedrock_mixins.CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty(
                                types=["types"]
                            )
                        )
                    ),
                    image=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty(
                            bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty(
                                state="state"
                            ),
                            category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty(
                                state="state",
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    video=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty(
                        extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty(
                            bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty(
                                state="state"
                            ),
                            category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty(
                                state="state",
                                types=["types"]
                            )
                        ),
                        generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty(
                            state="state",
                            types=["types"]
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e8436ab1f32296cf87082b839b1fcae9ef9557160d0f277e776f12fe71d4ec5c)
                check_type(argname="argument audio", value=audio, expected_type=type_hints["audio"])
                check_type(argname="argument document", value=document, expected_type=type_hints["document"])
                check_type(argname="argument image", value=image, expected_type=type_hints["image"])
                check_type(argname="argument video", value=video, expected_type=type_hints["video"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if audio is not None:
                self._values["audio"] = audio
            if document is not None:
                self._values["document"] = document
            if image is not None:
                self._values["image"] = image
            if video is not None:
                self._values["video"] = video

        @builtins.property
        def audio(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty"]]:
            '''Settings for processing audio.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-standardoutputconfiguration.html#cfn-bedrock-dataautomationproject-standardoutputconfiguration-audio
            '''
            result = self._values.get("audio")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty"]], result)

        @builtins.property
        def document(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty"]]:
            '''Settings for processing documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-standardoutputconfiguration.html#cfn-bedrock-dataautomationproject-standardoutputconfiguration-document
            '''
            result = self._values.get("document")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty"]], result)

        @builtins.property
        def image(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty"]]:
            '''Settings for processing images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-standardoutputconfiguration.html#cfn-bedrock-dataautomationproject-standardoutputconfiguration-image
            '''
            result = self._values.get("image")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty"]], result)

        @builtins.property
        def video(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty"]]:
            '''Settings for processing video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-standardoutputconfiguration.html#cfn-bedrock-dataautomationproject-standardoutputconfiguration-video
            '''
            result = self._values.get("video")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StandardOutputConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "channel_labeling": "channelLabeling",
            "speaker_labeling": "speakerLabeling",
        },
    )
    class TranscriptConfigurationProperty:
        def __init__(
            self,
            *,
            channel_labeling: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            speaker_labeling: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configuration for transcript options.

            This option allows you to enable speaker labeling and channel labeling.

            :param channel_labeling: Enables channel labeling. Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.
            :param speaker_labeling: Enables speaker labeling. Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-transcriptconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                transcript_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty(
                    channel_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty(
                        state="state"
                    ),
                    speaker_labeling=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty(
                        state="state"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fca2fbb2e95c41e7f34946d5da4d3f5b89ff211d8ca15b61fb6d57ed47c8ba0e)
                check_type(argname="argument channel_labeling", value=channel_labeling, expected_type=type_hints["channel_labeling"])
                check_type(argname="argument speaker_labeling", value=speaker_labeling, expected_type=type_hints["speaker_labeling"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if channel_labeling is not None:
                self._values["channel_labeling"] = channel_labeling
            if speaker_labeling is not None:
                self._values["speaker_labeling"] = speaker_labeling

        @builtins.property
        def channel_labeling(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty"]]:
            '''Enables channel labeling.

            Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-transcriptconfiguration.html#cfn-bedrock-dataautomationproject-transcriptconfiguration-channellabeling
            '''
            result = self._values.get("channel_labeling")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty"]], result)

        @builtins.property
        def speaker_labeling(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty"]]:
            '''Enables speaker labeling.

            Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-transcriptconfiguration.html#cfn-bedrock-dataautomationproject-transcriptconfiguration-speakerlabeling
            '''
            result = self._values.get("speaker_labeling")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TranscriptConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state"},
    )
    class VideoBoundingBoxProperty:
        def __init__(self, *, state: typing.Optional[builtins.str] = None) -> None:
            '''Bounding box settings for video.

            :param state: Whether bounding boxes are enabled for video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videoboundingbox.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_bounding_box_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty(
                    state="state"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9e99b29d4850c1f9478f599c751546f4b223e13ce306b8455192d7bbc0cc271e)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether bounding boxes are enabled for video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videoboundingbox.html#cfn-bedrock-dataautomationproject-videoboundingbox-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoBoundingBoxProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state", "types": "types"},
    )
    class VideoExtractionCategoryProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Settings for generating categorical data from video.

            :param state: Whether generating categorical data from video is enabled.
            :param types: The types of data to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videoextractioncategory.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_extraction_category_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty(
                    state="state",
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__65a72813faeaee35b699f6849485645dcf655a83b1b09bab2c2f95448a7b5588)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating categorical data from video is enabled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videoextractioncategory.html#cfn-bedrock-dataautomationproject-videoextractioncategory-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The types of data to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videoextractioncategory.html#cfn-bedrock-dataautomationproject-videoextractioncategory-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoExtractionCategoryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "modality_processing": "modalityProcessing",
            "sensitive_data_configuration": "sensitiveDataConfiguration",
        },
    )
    class VideoOverrideConfigurationProperty:
        def __init__(
            self,
            *,
            modality_processing: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sensitive_data_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Sets whether your project will process videos or not.

            :param modality_processing: Sets modality processing for video files. All modalities are enabled by default.
            :param sensitive_data_configuration: Configuration for sensitive data detection and redaction for video files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videooverrideconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_override_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty(
                    modality_processing=bedrock_mixins.CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty(
                        state="state"
                    ),
                    sensitive_data_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty(
                        detection_mode="detectionMode",
                        detection_scope=["detectionScope"],
                        pii_entities_configuration=bedrock_mixins.CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty(
                            pii_entity_types=["piiEntityTypes"],
                            redaction_mask_mode="redactionMaskMode"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__33303385039bb1ebe45b8166c9a55fdfbf854138da2e563eb8226a963a953c75)
                check_type(argname="argument modality_processing", value=modality_processing, expected_type=type_hints["modality_processing"])
                check_type(argname="argument sensitive_data_configuration", value=sensitive_data_configuration, expected_type=type_hints["sensitive_data_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if modality_processing is not None:
                self._values["modality_processing"] = modality_processing
            if sensitive_data_configuration is not None:
                self._values["sensitive_data_configuration"] = sensitive_data_configuration

        @builtins.property
        def modality_processing(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]]:
            '''Sets modality processing for video files.

            All modalities are enabled by default.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videooverrideconfiguration.html#cfn-bedrock-dataautomationproject-videooverrideconfiguration-modalityprocessing
            '''
            result = self._values.get("modality_processing")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty"]], result)

        @builtins.property
        def sensitive_data_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]]:
            '''Configuration for sensitive data detection and redaction for video files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videooverrideconfiguration.html#cfn-bedrock-dataautomationproject-videooverrideconfiguration-sensitivedataconfiguration
            '''
            result = self._values.get("sensitive_data_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoOverrideConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty",
        jsii_struct_bases=[],
        name_mapping={"bounding_box": "boundingBox", "category": "category"},
    )
    class VideoStandardExtractionProperty:
        def __init__(
            self,
            *,
            bounding_box: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            category: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Settings for generating data from video.

            :param bounding_box: Settings for generating bounding boxes.
            :param category: Settings for generating categorical data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardextraction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_standard_extraction_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty(
                    bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty(
                        state="state"
                    ),
                    category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty(
                        state="state",
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__72f151f921858147c6ee4ebe91c98b8fa8d6ea49eddbda2c961034f3504865aa)
                check_type(argname="argument bounding_box", value=bounding_box, expected_type=type_hints["bounding_box"])
                check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bounding_box is not None:
                self._values["bounding_box"] = bounding_box
            if category is not None:
                self._values["category"] = category

        @builtins.property
        def bounding_box(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty"]]:
            '''Settings for generating bounding boxes.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardextraction.html#cfn-bedrock-dataautomationproject-videostandardextraction-boundingbox
            '''
            result = self._values.get("bounding_box")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty"]], result)

        @builtins.property
        def category(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty"]]:
            '''Settings for generating categorical data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardextraction.html#cfn-bedrock-dataautomationproject-videostandardextraction-category
            '''
            result = self._values.get("category")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoStandardExtractionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty",
        jsii_struct_bases=[],
        name_mapping={"state": "state", "types": "types"},
    )
    class VideoStandardGenerativeFieldProperty:
        def __init__(
            self,
            *,
            state: typing.Optional[builtins.str] = None,
            types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Settings for generating descriptions of video.

            :param state: Whether generating descriptions is enabled for video.
            :param types: The types of description to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardgenerativefield.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_standard_generative_field_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty(
                    state="state",
                    types=["types"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c93519b4709de39d05e32e42b295b86f34d84cb99dd9cafddde59dd310056bd8)
                check_type(argname="argument state", value=state, expected_type=type_hints["state"])
                check_type(argname="argument types", value=types, expected_type=type_hints["types"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if state is not None:
                self._values["state"] = state
            if types is not None:
                self._values["types"] = types

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''Whether generating descriptions is enabled for video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardgenerativefield.html#cfn-bedrock-dataautomationproject-videostandardgenerativefield-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The types of description to generate.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardgenerativefield.html#cfn-bedrock-dataautomationproject-videostandardgenerativefield-types
            '''
            result = self._values.get("types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoStandardGenerativeFieldProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "extraction": "extraction",
            "generative_field": "generativeField",
        },
    )
    class VideoStandardOutputConfigurationProperty:
        def __init__(
            self,
            *,
            extraction: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            generative_field: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Output settings for processing video.

            :param extraction: Settings for populating data fields that describe the video.
            :param generative_field: Whether to generate descriptions of the video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardoutputconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_standard_output_configuration_property = bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty(
                    extraction=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty(
                        bounding_box=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty(
                            state="state"
                        ),
                        category=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty(
                            state="state",
                            types=["types"]
                        )
                    ),
                    generative_field=bedrock_mixins.CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty(
                        state="state",
                        types=["types"]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d221f0139e3557d10dfaa9cdfad57a712f18b168e6685d5a6b34ff9ee0d554bb)
                check_type(argname="argument extraction", value=extraction, expected_type=type_hints["extraction"])
                check_type(argname="argument generative_field", value=generative_field, expected_type=type_hints["generative_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if extraction is not None:
                self._values["extraction"] = extraction
            if generative_field is not None:
                self._values["generative_field"] = generative_field

        @builtins.property
        def extraction(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty"]]:
            '''Settings for populating data fields that describe the video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-videostandardoutputconfiguration-extraction
            '''
            result = self._values.get("extraction")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty"]], result)

        @builtins.property
        def generative_field(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty"]]:
            '''Whether to generate descriptions of the video.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-dataautomationproject-videostandardoutputconfiguration.html#cfn-bedrock-dataautomationproject-videostandardoutputconfiguration-generativefield
            '''
            result = self._values.get("generative_field")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoStandardOutputConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourceMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "data_deletion_policy": "dataDeletionPolicy",
        "data_source_configuration": "dataSourceConfiguration",
        "description": "description",
        "knowledge_base_id": "knowledgeBaseId",
        "name": "name",
        "server_side_encryption_configuration": "serverSideEncryptionConfiguration",
        "vector_ingestion_configuration": "vectorIngestionConfiguration",
    },
)
class CfnDataSourceMixinProps:
    def __init__(
        self,
        *,
        data_deletion_policy: typing.Optional[builtins.str] = None,
        data_source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.DataSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        knowledge_base_id: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        server_side_encryption_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        vector_ingestion_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnDataSourcePropsMixin.

        :param data_deletion_policy: The data deletion policy for the data source.
        :param data_source_configuration: The connection configuration for the data source.
        :param description: The description of the data source.
        :param knowledge_base_id: The unique identifier of the knowledge base to which the data source belongs.
        :param name: The name of the data source.
        :param server_side_encryption_configuration: Contains details about the configuration of the server-side encryption.
        :param vector_ingestion_configuration: Contains details about how to ingest the documents in the data source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_data_source_mixin_props = bedrock_mixins.CfnDataSourceMixinProps(
                data_deletion_policy="dataDeletionPolicy",
                data_source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.DataSourceConfigurationProperty(
                    confluence_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty(
                            filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                                pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                        exclusion_filters=["exclusionFilters"],
                                        inclusion_filters=["inclusionFilters"],
                                        object_type="objectType"
                                    )]
                                ),
                                type="type"
                            )
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty(
                            auth_type="authType",
                            credentials_secret_arn="credentialsSecretArn",
                            host_type="hostType",
                            host_url="hostUrl"
                        )
                    ),
                    s3_configuration=bedrock_mixins.CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty(
                        bucket_arn="bucketArn",
                        bucket_owner_account_id="bucketOwnerAccountId",
                        inclusion_prefixes=["inclusionPrefixes"]
                    ),
                    salesforce_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty(
                            filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                                pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                        exclusion_filters=["exclusionFilters"],
                                        inclusion_filters=["inclusionFilters"],
                                        object_type="objectType"
                                    )]
                                ),
                                type="type"
                            )
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty(
                            auth_type="authType",
                            credentials_secret_arn="credentialsSecretArn",
                            host_url="hostUrl"
                        )
                    ),
                    share_point_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty(
                            filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                                pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                        exclusion_filters=["exclusionFilters"],
                                        inclusion_filters=["inclusionFilters"],
                                        object_type="objectType"
                                    )]
                                ),
                                type="type"
                            )
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty(
                            auth_type="authType",
                            credentials_secret_arn="credentialsSecretArn",
                            domain="domain",
                            host_type="hostType",
                            site_urls=["siteUrls"],
                            tenant_id="tenantId"
                        )
                    ),
                    type="type",
                    web_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty(
                            crawler_limits=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty(
                                max_pages=123,
                                rate_limit=123
                            ),
                            exclusion_filters=["exclusionFilters"],
                            inclusion_filters=["inclusionFilters"],
                            scope="scope",
                            user_agent="userAgent",
                            user_agent_header="userAgentHeader"
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebSourceConfigurationProperty(
                            url_configuration=bedrock_mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty(
                                seed_urls=[bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                                    url="url"
                                )]
                            )
                        )
                    )
                ),
                description="description",
                knowledge_base_id="knowledgeBaseId",
                name="name",
                server_side_encryption_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty(
                    kms_key_arn="kmsKeyArn"
                ),
                vector_ingestion_configuration=bedrock_mixins.CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty(
                    chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ChunkingConfigurationProperty(
                        chunking_strategy="chunkingStrategy",
                        fixed_size_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty(
                            max_tokens=123,
                            overlap_percentage=123
                        ),
                        hierarchical_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty(
                            level_configurations=[bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty(
                                max_tokens=123
                            )],
                            overlap_tokens=123
                        ),
                        semantic_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty(
                            breakpoint_percentile_threshold=123,
                            buffer_size=123,
                            max_tokens=123
                        )
                    ),
                    context_enrichment_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty(
                        bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty(
                            enrichment_strategy_configuration=bedrock_mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty(
                                method="method"
                            ),
                            model_arn="modelArn"
                        ),
                        type="type"
                    ),
                    custom_transformation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty(
                        intermediate_storage=bedrock_mixins.CfnDataSourcePropsMixin.IntermediateStorageProperty(
                            s3_location=bedrock_mixins.CfnDataSourcePropsMixin.S3LocationProperty(
                                uri="uri"
                            )
                        ),
                        transformations=[bedrock_mixins.CfnDataSourcePropsMixin.TransformationProperty(
                            step_to_apply="stepToApply",
                            transformation_function=bedrock_mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty(
                                transformation_lambda_configuration=bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                                    lambda_arn="lambdaArn"
                                )
                            )
                        )]
                    ),
                    parsing_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ParsingConfigurationProperty(
                        bedrock_data_automation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty(
                            parsing_modality="parsingModality"
                        ),
                        bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty(
                            model_arn="modelArn",
                            parsing_modality="parsingModality",
                            parsing_prompt=bedrock_mixins.CfnDataSourcePropsMixin.ParsingPromptProperty(
                                parsing_prompt_text="parsingPromptText"
                            )
                        ),
                        parsing_strategy="parsingStrategy"
                    )
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ba158e57aa34cfb06e79b2b939c46c2753685a214df8e27442ea74e993d8d69)
            check_type(argname="argument data_deletion_policy", value=data_deletion_policy, expected_type=type_hints["data_deletion_policy"])
            check_type(argname="argument data_source_configuration", value=data_source_configuration, expected_type=type_hints["data_source_configuration"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument knowledge_base_id", value=knowledge_base_id, expected_type=type_hints["knowledge_base_id"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument server_side_encryption_configuration", value=server_side_encryption_configuration, expected_type=type_hints["server_side_encryption_configuration"])
            check_type(argname="argument vector_ingestion_configuration", value=vector_ingestion_configuration, expected_type=type_hints["vector_ingestion_configuration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data_deletion_policy is not None:
            self._values["data_deletion_policy"] = data_deletion_policy
        if data_source_configuration is not None:
            self._values["data_source_configuration"] = data_source_configuration
        if description is not None:
            self._values["description"] = description
        if knowledge_base_id is not None:
            self._values["knowledge_base_id"] = knowledge_base_id
        if name is not None:
            self._values["name"] = name
        if server_side_encryption_configuration is not None:
            self._values["server_side_encryption_configuration"] = server_side_encryption_configuration
        if vector_ingestion_configuration is not None:
            self._values["vector_ingestion_configuration"] = vector_ingestion_configuration

    @builtins.property
    def data_deletion_policy(self) -> typing.Optional[builtins.str]:
        '''The data deletion policy for the data source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-datadeletionpolicy
        '''
        result = self._values.get("data_deletion_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.DataSourceConfigurationProperty"]]:
        '''The connection configuration for the data source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-datasourceconfiguration
        '''
        result = self._values.get("data_source_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.DataSourceConfigurationProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the data source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def knowledge_base_id(self) -> typing.Optional[builtins.str]:
        '''The unique identifier of the knowledge base to which the data source belongs.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-knowledgebaseid
        '''
        result = self._values.get("knowledge_base_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the data source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server_side_encryption_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty"]]:
        '''Contains details about the configuration of the server-side encryption.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-serversideencryptionconfiguration
        '''
        result = self._values.get("server_side_encryption_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty"]], result)

    @builtins.property
    def vector_ingestion_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty"]]:
        '''Contains details about how to ingest the documents in the data source.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html#cfn-bedrock-datasource-vectoringestionconfiguration
        '''
        result = self._values.get("vector_ingestion_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDataSourceMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnDataSourcePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin",
):
    '''.. epigraph::

   Properties with ``__Update requires: Replacement__`` can result in the creation of a new data source and deletion of the old one.

    This can happen if you also change the Name of the data source.

    Specifies a data source as a resource in a top-level template. Minimally, you must specify the following properties:

    - Name – Specify a name for the data source.
    - KnowledgeBaseId – Specify the ID of the knowledge base for the data source to belong to.
    - DataSourceConfiguration – Specify information about the Amazon S3 bucket containing the data source. The following sub-properties are required:
    - Type – Specify the value ``S3`` .

    For more information about setting up data sources in Amazon Bedrock , see `Set up a data source for your knowledge base <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html
    :cloudformationResource: AWS::Bedrock::DataSource
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_data_source_props_mixin = bedrock_mixins.CfnDataSourcePropsMixin(bedrock_mixins.CfnDataSourceMixinProps(
            data_deletion_policy="dataDeletionPolicy",
            data_source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.DataSourceConfigurationProperty(
                confluence_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty(
                        filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                            pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                    exclusion_filters=["exclusionFilters"],
                                    inclusion_filters=["inclusionFilters"],
                                    object_type="objectType"
                                )]
                            ),
                            type="type"
                        )
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty(
                        auth_type="authType",
                        credentials_secret_arn="credentialsSecretArn",
                        host_type="hostType",
                        host_url="hostUrl"
                    )
                ),
                s3_configuration=bedrock_mixins.CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty(
                    bucket_arn="bucketArn",
                    bucket_owner_account_id="bucketOwnerAccountId",
                    inclusion_prefixes=["inclusionPrefixes"]
                ),
                salesforce_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty(
                        filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                            pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                    exclusion_filters=["exclusionFilters"],
                                    inclusion_filters=["inclusionFilters"],
                                    object_type="objectType"
                                )]
                            ),
                            type="type"
                        )
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty(
                        auth_type="authType",
                        credentials_secret_arn="credentialsSecretArn",
                        host_url="hostUrl"
                    )
                ),
                share_point_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty(
                        filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                            pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                    exclusion_filters=["exclusionFilters"],
                                    inclusion_filters=["inclusionFilters"],
                                    object_type="objectType"
                                )]
                            ),
                            type="type"
                        )
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty(
                        auth_type="authType",
                        credentials_secret_arn="credentialsSecretArn",
                        domain="domain",
                        host_type="hostType",
                        site_urls=["siteUrls"],
                        tenant_id="tenantId"
                    )
                ),
                type="type",
                web_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty(
                        crawler_limits=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty(
                            max_pages=123,
                            rate_limit=123
                        ),
                        exclusion_filters=["exclusionFilters"],
                        inclusion_filters=["inclusionFilters"],
                        scope="scope",
                        user_agent="userAgent",
                        user_agent_header="userAgentHeader"
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebSourceConfigurationProperty(
                        url_configuration=bedrock_mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty(
                            seed_urls=[bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                                url="url"
                            )]
                        )
                    )
                )
            ),
            description="description",
            knowledge_base_id="knowledgeBaseId",
            name="name",
            server_side_encryption_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty(
                kms_key_arn="kmsKeyArn"
            ),
            vector_ingestion_configuration=bedrock_mixins.CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty(
                chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ChunkingConfigurationProperty(
                    chunking_strategy="chunkingStrategy",
                    fixed_size_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty(
                        max_tokens=123,
                        overlap_percentage=123
                    ),
                    hierarchical_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty(
                        level_configurations=[bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty(
                            max_tokens=123
                        )],
                        overlap_tokens=123
                    ),
                    semantic_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty(
                        breakpoint_percentile_threshold=123,
                        buffer_size=123,
                        max_tokens=123
                    )
                ),
                context_enrichment_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty(
                    bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty(
                        enrichment_strategy_configuration=bedrock_mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty(
                            method="method"
                        ),
                        model_arn="modelArn"
                    ),
                    type="type"
                ),
                custom_transformation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty(
                    intermediate_storage=bedrock_mixins.CfnDataSourcePropsMixin.IntermediateStorageProperty(
                        s3_location=bedrock_mixins.CfnDataSourcePropsMixin.S3LocationProperty(
                            uri="uri"
                        )
                    ),
                    transformations=[bedrock_mixins.CfnDataSourcePropsMixin.TransformationProperty(
                        step_to_apply="stepToApply",
                        transformation_function=bedrock_mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty(
                            transformation_lambda_configuration=bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                                lambda_arn="lambdaArn"
                            )
                        )
                    )]
                ),
                parsing_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ParsingConfigurationProperty(
                    bedrock_data_automation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty(
                        parsing_modality="parsingModality"
                    ),
                    bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty(
                        model_arn="modelArn",
                        parsing_modality="parsingModality",
                        parsing_prompt=bedrock_mixins.CfnDataSourcePropsMixin.ParsingPromptProperty(
                            parsing_prompt_text="parsingPromptText"
                        )
                    ),
                    parsing_strategy="parsingStrategy"
                )
            )
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnDataSourceMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::DataSource``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7a39fd3f2ffeaca5b08f92ff1c0ae0e423e559ba386cf5381c8b4613a651012)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__835488c2d8aa15743bb681c15ece350e4a671c4b052c621bc04dd8242fc7d057)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6113d5d6b7a47dc72cf1ef46b4f26ed3bcff3bd8297fdddfc4b9ced8a3d769a)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnDataSourceMixinProps":
        return typing.cast("CfnDataSourceMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"parsing_modality": "parsingModality"},
    )
    class BedrockDataAutomationConfigurationProperty:
        def __init__(
            self,
            *,
            parsing_modality: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for using Amazon Bedrock Data Automation as the parser for ingesting your data sources.

            :param parsing_modality: Specifies whether to enable parsing of multimodal data, including both text and/or images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockdataautomationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                bedrock_data_automation_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty(
                    parsing_modality="parsingModality"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bd6634bf82173978f6992b6cdd5a454b7a68801b78f14441d03acf3017f59c1f)
                check_type(argname="argument parsing_modality", value=parsing_modality, expected_type=type_hints["parsing_modality"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if parsing_modality is not None:
                self._values["parsing_modality"] = parsing_modality

        @builtins.property
        def parsing_modality(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to enable parsing of multimodal data, including both text and/or images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockdataautomationconfiguration.html#cfn-bedrock-datasource-bedrockdataautomationconfiguration-parsingmodality
            '''
            result = self._values.get("parsing_modality")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BedrockDataAutomationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "model_arn": "modelArn",
            "parsing_modality": "parsingModality",
            "parsing_prompt": "parsingPrompt",
        },
    )
    class BedrockFoundationModelConfigurationProperty:
        def __init__(
            self,
            *,
            model_arn: typing.Optional[builtins.str] = None,
            parsing_modality: typing.Optional[builtins.str] = None,
            parsing_prompt: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ParsingPromptProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Settings for a foundation model used to parse documents for a data source.

            :param model_arn: The ARN of the foundation model to use for parsing.
            :param parsing_modality: Specifies whether to enable parsing of multimodal data, including both text and/or images.
            :param parsing_prompt: Instructions for interpreting the contents of a document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                bedrock_foundation_model_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty(
                    model_arn="modelArn",
                    parsing_modality="parsingModality",
                    parsing_prompt=bedrock_mixins.CfnDataSourcePropsMixin.ParsingPromptProperty(
                        parsing_prompt_text="parsingPromptText"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__630fea4705dd8c0535526af5b50a19d609832f437c84d7571c70e7f021fa0f95)
                check_type(argname="argument model_arn", value=model_arn, expected_type=type_hints["model_arn"])
                check_type(argname="argument parsing_modality", value=parsing_modality, expected_type=type_hints["parsing_modality"])
                check_type(argname="argument parsing_prompt", value=parsing_prompt, expected_type=type_hints["parsing_prompt"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if model_arn is not None:
                self._values["model_arn"] = model_arn
            if parsing_modality is not None:
                self._values["parsing_modality"] = parsing_modality
            if parsing_prompt is not None:
                self._values["parsing_prompt"] = parsing_prompt

        @builtins.property
        def model_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the foundation model to use for parsing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelconfiguration.html#cfn-bedrock-datasource-bedrockfoundationmodelconfiguration-modelarn
            '''
            result = self._values.get("model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def parsing_modality(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to enable parsing of multimodal data, including both text and/or images.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelconfiguration.html#cfn-bedrock-datasource-bedrockfoundationmodelconfiguration-parsingmodality
            '''
            result = self._values.get("parsing_modality")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def parsing_prompt(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ParsingPromptProperty"]]:
            '''Instructions for interpreting the contents of a document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelconfiguration.html#cfn-bedrock-datasource-bedrockfoundationmodelconfiguration-parsingprompt
            '''
            result = self._values.get("parsing_prompt")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ParsingPromptProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BedrockFoundationModelConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enrichment_strategy_configuration": "enrichmentStrategyConfiguration",
            "model_arn": "modelArn",
        },
    )
    class BedrockFoundationModelContextEnrichmentConfigurationProperty:
        def __init__(
            self,
            *,
            enrichment_strategy_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            model_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Context enrichment configuration is used to provide additional context to the RAG application using Amazon Bedrock foundation models.

            :param enrichment_strategy_configuration: The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
            :param model_arn: The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelcontextenrichmentconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                bedrock_foundation_model_context_enrichment_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty(
                    enrichment_strategy_configuration=bedrock_mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty(
                        method="method"
                    ),
                    model_arn="modelArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ab5c89c8fc3360471389d62b46ba333b77f6299c7f0183876153351b66f6bf3a)
                check_type(argname="argument enrichment_strategy_configuration", value=enrichment_strategy_configuration, expected_type=type_hints["enrichment_strategy_configuration"])
                check_type(argname="argument model_arn", value=model_arn, expected_type=type_hints["model_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if enrichment_strategy_configuration is not None:
                self._values["enrichment_strategy_configuration"] = enrichment_strategy_configuration
            if model_arn is not None:
                self._values["model_arn"] = model_arn

        @builtins.property
        def enrichment_strategy_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty"]]:
            '''The enrichment stategy used to provide additional context.

            For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelcontextenrichmentconfiguration.html#cfn-bedrock-datasource-bedrockfoundationmodelcontextenrichmentconfiguration-enrichmentstrategyconfiguration
            '''
            result = self._values.get("enrichment_strategy_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty"]], result)

        @builtins.property
        def model_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-bedrockfoundationmodelcontextenrichmentconfiguration.html#cfn-bedrock-datasource-bedrockfoundationmodelcontextenrichmentconfiguration-modelarn
            '''
            result = self._values.get("model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BedrockFoundationModelContextEnrichmentConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ChunkingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "chunking_strategy": "chunkingStrategy",
            "fixed_size_chunking_configuration": "fixedSizeChunkingConfiguration",
            "hierarchical_chunking_configuration": "hierarchicalChunkingConfiguration",
            "semantic_chunking_configuration": "semanticChunkingConfiguration",
        },
    )
    class ChunkingConfigurationProperty:
        def __init__(
            self,
            *,
            chunking_strategy: typing.Optional[builtins.str] = None,
            fixed_size_chunking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            hierarchical_chunking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            semantic_chunking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Details about how to chunk the documents in the data source.

            A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.

            :param chunking_strategy: Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for ``NONE`` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk. - ``FIXED_SIZE`` – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the ``fixedSizeChunkingConfiguration`` . - ``HIERARCHICAL`` – Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer. - ``SEMANTIC`` – Split documents into chunks based on groups of similar content derived with natural language processing. - ``NONE`` – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
            :param fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. If you set the ``chunkingStrategy`` as ``NONE`` , exclude this field.
            :param hierarchical_chunking_configuration: Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
            :param semantic_chunking_configuration: Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-chunkingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                chunking_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ChunkingConfigurationProperty(
                    chunking_strategy="chunkingStrategy",
                    fixed_size_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty(
                        max_tokens=123,
                        overlap_percentage=123
                    ),
                    hierarchical_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty(
                        level_configurations=[bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty(
                            max_tokens=123
                        )],
                        overlap_tokens=123
                    ),
                    semantic_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty(
                        breakpoint_percentile_threshold=123,
                        buffer_size=123,
                        max_tokens=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__756158119b6d4abc0049937720e9e0910307d0cb57eab5c57895409fc668423c)
                check_type(argname="argument chunking_strategy", value=chunking_strategy, expected_type=type_hints["chunking_strategy"])
                check_type(argname="argument fixed_size_chunking_configuration", value=fixed_size_chunking_configuration, expected_type=type_hints["fixed_size_chunking_configuration"])
                check_type(argname="argument hierarchical_chunking_configuration", value=hierarchical_chunking_configuration, expected_type=type_hints["hierarchical_chunking_configuration"])
                check_type(argname="argument semantic_chunking_configuration", value=semantic_chunking_configuration, expected_type=type_hints["semantic_chunking_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if chunking_strategy is not None:
                self._values["chunking_strategy"] = chunking_strategy
            if fixed_size_chunking_configuration is not None:
                self._values["fixed_size_chunking_configuration"] = fixed_size_chunking_configuration
            if hierarchical_chunking_configuration is not None:
                self._values["hierarchical_chunking_configuration"] = hierarchical_chunking_configuration
            if semantic_chunking_configuration is not None:
                self._values["semantic_chunking_configuration"] = semantic_chunking_configuration

        @builtins.property
        def chunking_strategy(self) -> typing.Optional[builtins.str]:
            '''Knowledge base can split your source data into chunks.

            A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for ``NONE`` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.

            - ``FIXED_SIZE`` – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the ``fixedSizeChunkingConfiguration`` .
            - ``HIERARCHICAL`` – Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
            - ``SEMANTIC`` – Split documents into chunks based on groups of similar content derived with natural language processing.
            - ``NONE`` – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-chunkingconfiguration.html#cfn-bedrock-datasource-chunkingconfiguration-chunkingstrategy
            '''
            result = self._values.get("chunking_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def fixed_size_chunking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty"]]:
            '''Configurations for when you choose fixed-size chunking.

            If you set the ``chunkingStrategy`` as ``NONE`` , exclude this field.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-chunkingconfiguration.html#cfn-bedrock-datasource-chunkingconfiguration-fixedsizechunkingconfiguration
            '''
            result = self._values.get("fixed_size_chunking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty"]], result)

        @builtins.property
        def hierarchical_chunking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty"]]:
            '''Settings for hierarchical document chunking for a data source.

            Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-chunkingconfiguration.html#cfn-bedrock-datasource-chunkingconfiguration-hierarchicalchunkingconfiguration
            '''
            result = self._values.get("hierarchical_chunking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty"]], result)

        @builtins.property
        def semantic_chunking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty"]]:
            '''Settings for semantic document chunking for a data source.

            Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-chunkingconfiguration.html#cfn-bedrock-datasource-chunkingconfiguration-semanticchunkingconfiguration
            '''
            result = self._values.get("semantic_chunking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ChunkingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"filter_configuration": "filterConfiguration"},
    )
    class ConfluenceCrawlerConfigurationProperty:
        def __init__(
            self,
            *,
            filter_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the Confluence content.

            For example, configuring specific types of Confluence content.

            :param filter_configuration: The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencecrawlerconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                confluence_crawler_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty(
                    filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                        pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                            filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                exclusion_filters=["exclusionFilters"],
                                inclusion_filters=["inclusionFilters"],
                                object_type="objectType"
                            )]
                        ),
                        type="type"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7868d06e3eff60fe10333ef56105a299038e551f37e16791a97f24ac92644429)
                check_type(argname="argument filter_configuration", value=filter_configuration, expected_type=type_hints["filter_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if filter_configuration is not None:
                self._values["filter_configuration"] = filter_configuration

        @builtins.property
        def filter_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty"]]:
            '''The configuration of filtering the Confluence content.

            For example, configuring regular expression patterns to include or exclude certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencecrawlerconfiguration.html#cfn-bedrock-datasource-confluencecrawlerconfiguration-filterconfiguration
            '''
            result = self._values.get("filter_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConfluenceCrawlerConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "crawler_configuration": "crawlerConfiguration",
            "source_configuration": "sourceConfiguration",
        },
    )
    class ConfluenceDataSourceConfigurationProperty:
        def __init__(
            self,
            *,
            crawler_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration information to connect to Confluence as your data source.

            :param crawler_configuration: The configuration of the Confluence content. For example, configuring specific types of Confluence content.
            :param source_configuration: The endpoint information to connect to your Confluence data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencedatasourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                confluence_data_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty(
                        filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                            pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                    exclusion_filters=["exclusionFilters"],
                                    inclusion_filters=["inclusionFilters"],
                                    object_type="objectType"
                                )]
                            ),
                            type="type"
                        )
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty(
                        auth_type="authType",
                        credentials_secret_arn="credentialsSecretArn",
                        host_type="hostType",
                        host_url="hostUrl"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5f39ea1f577f8387443da0821430cbbd611cfec153cd96a93a9d2432b8f50677)
                check_type(argname="argument crawler_configuration", value=crawler_configuration, expected_type=type_hints["crawler_configuration"])
                check_type(argname="argument source_configuration", value=source_configuration, expected_type=type_hints["source_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if crawler_configuration is not None:
                self._values["crawler_configuration"] = crawler_configuration
            if source_configuration is not None:
                self._values["source_configuration"] = source_configuration

        @builtins.property
        def crawler_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty"]]:
            '''The configuration of the Confluence content.

            For example, configuring specific types of Confluence content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencedatasourceconfiguration.html#cfn-bedrock-datasource-confluencedatasourceconfiguration-crawlerconfiguration
            '''
            result = self._values.get("crawler_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty"]], result)

        @builtins.property
        def source_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty"]]:
            '''The endpoint information to connect to your Confluence data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencedatasourceconfiguration.html#cfn-bedrock-datasource-confluencedatasourceconfiguration-sourceconfiguration
            '''
            result = self._values.get("source_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConfluenceDataSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth_type": "authType",
            "credentials_secret_arn": "credentialsSecretArn",
            "host_type": "hostType",
            "host_url": "hostUrl",
        },
    )
    class ConfluenceSourceConfigurationProperty:
        def __init__(
            self,
            *,
            auth_type: typing.Optional[builtins.str] = None,
            credentials_secret_arn: typing.Optional[builtins.str] = None,
            host_type: typing.Optional[builtins.str] = None,
            host_url: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The endpoint information to connect to your Confluence data source.

            :param auth_type: The supported authentication type to authenticate and connect to your Confluence instance.
            :param credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see `Confluence connection configuration <https://docs.aws.amazon.com/bedrock/latest/userguide/confluence-data-source-connector.html#configuration-confluence-connector>`_ .
            :param host_type: The supported host type, whether online/cloud or server/on-premises.
            :param host_url: The Confluence host URL or instance URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencesourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                confluence_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty(
                    auth_type="authType",
                    credentials_secret_arn="credentialsSecretArn",
                    host_type="hostType",
                    host_url="hostUrl"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6b7c955c5ef5a8488be1c7521b650e495a46b9020a5d5b55018f24e764af36f3)
                check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
                check_type(argname="argument credentials_secret_arn", value=credentials_secret_arn, expected_type=type_hints["credentials_secret_arn"])
                check_type(argname="argument host_type", value=host_type, expected_type=type_hints["host_type"])
                check_type(argname="argument host_url", value=host_url, expected_type=type_hints["host_url"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth_type is not None:
                self._values["auth_type"] = auth_type
            if credentials_secret_arn is not None:
                self._values["credentials_secret_arn"] = credentials_secret_arn
            if host_type is not None:
                self._values["host_type"] = host_type
            if host_url is not None:
                self._values["host_url"] = host_url

        @builtins.property
        def auth_type(self) -> typing.Optional[builtins.str]:
            '''The supported authentication type to authenticate and connect to your Confluence instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencesourceconfiguration.html#cfn-bedrock-datasource-confluencesourceconfiguration-authtype
            '''
            result = self._values.get("auth_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def credentials_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL.

            For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see `Confluence connection configuration <https://docs.aws.amazon.com/bedrock/latest/userguide/confluence-data-source-connector.html#configuration-confluence-connector>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencesourceconfiguration.html#cfn-bedrock-datasource-confluencesourceconfiguration-credentialssecretarn
            '''
            result = self._values.get("credentials_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_type(self) -> typing.Optional[builtins.str]:
            '''The supported host type, whether online/cloud or server/on-premises.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencesourceconfiguration.html#cfn-bedrock-datasource-confluencesourceconfiguration-hosttype
            '''
            result = self._values.get("host_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_url(self) -> typing.Optional[builtins.str]:
            '''The Confluence host URL or instance URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-confluencesourceconfiguration.html#cfn-bedrock-datasource-confluencesourceconfiguration-hosturl
            '''
            result = self._values.get("host_url")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConfluenceSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bedrock_foundation_model_configuration": "bedrockFoundationModelConfiguration",
            "type": "type",
        },
    )
    class ContextEnrichmentConfigurationProperty:
        def __init__(
            self,
            *,
            bedrock_foundation_model_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Context enrichment configuration is used to provide additional context to the RAG application.

            :param bedrock_foundation_model_configuration: The configuration of the Amazon Bedrock foundation model used for context enrichment.
            :param type: The method used for context enrichment. It must be Amazon Bedrock foundation models.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-contextenrichmentconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                context_enrichment_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty(
                    bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty(
                        enrichment_strategy_configuration=bedrock_mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty(
                            method="method"
                        ),
                        model_arn="modelArn"
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__59763242d9ef3efda9b47cdb79e80b620ce237edb08a90f7f97a6410b9ab98a7)
                check_type(argname="argument bedrock_foundation_model_configuration", value=bedrock_foundation_model_configuration, expected_type=type_hints["bedrock_foundation_model_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bedrock_foundation_model_configuration is not None:
                self._values["bedrock_foundation_model_configuration"] = bedrock_foundation_model_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def bedrock_foundation_model_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty"]]:
            '''The configuration of the Amazon Bedrock foundation model used for context enrichment.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-contextenrichmentconfiguration.html#cfn-bedrock-datasource-contextenrichmentconfiguration-bedrockfoundationmodelconfiguration
            '''
            result = self._values.get("bedrock_foundation_model_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The method used for context enrichment.

            It must be Amazon Bedrock foundation models.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-contextenrichmentconfiguration.html#cfn-bedrock-datasource-contextenrichmentconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContextEnrichmentConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"pattern_object_filter": "patternObjectFilter", "type": "type"},
    )
    class CrawlFilterConfigurationProperty:
        def __init__(
            self,
            *,
            pattern_object_filter: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The configuration of filtering the data source content.

            For example, configuring regular expression patterns to include or exclude certain content.

            :param pattern_object_filter: The configuration of filtering certain objects or content types of the data source.
            :param type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the ``PATTERN`` type is regular expression patterns you can apply to filter your content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-crawlfilterconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                crawl_filter_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                    pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                        filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                            exclusion_filters=["exclusionFilters"],
                            inclusion_filters=["inclusionFilters"],
                            object_type="objectType"
                        )]
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3c812fcca11e7ae6a98ea813a470a7c1153d5640763b235b8c2ba410c66b38ff)
                check_type(argname="argument pattern_object_filter", value=pattern_object_filter, expected_type=type_hints["pattern_object_filter"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if pattern_object_filter is not None:
                self._values["pattern_object_filter"] = pattern_object_filter
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def pattern_object_filter(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty"]]:
            '''The configuration of filtering certain objects or content types of the data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-crawlfilterconfiguration.html#cfn-bedrock-datasource-crawlfilterconfiguration-patternobjectfilter
            '''
            result = self._values.get("pattern_object_filter")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of filtering that you want to apply to certain objects or content of the data source.

            For example, the ``PATTERN`` type is regular expression patterns you can apply to filter your content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-crawlfilterconfiguration.html#cfn-bedrock-datasource-crawlfilterconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CrawlFilterConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "intermediate_storage": "intermediateStorage",
            "transformations": "transformations",
        },
    )
    class CustomTransformationConfigurationProperty:
        def __init__(
            self,
            *,
            intermediate_storage: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.IntermediateStorageProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            transformations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.TransformationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Settings for customizing steps in the data source content ingestion pipeline.

            You can configure the data source to process documents with a Lambda function after they are parsed and converted into chunks. When you add a post-chunking transformation, the service stores chunked documents in an S3 bucket and invokes a Lambda function to process them.

            To process chunked documents with a Lambda function, define an S3 bucket path for input and output objects, and a transformation that specifies the Lambda function to invoke. You can use the Lambda function to customize how chunks are split, and the metadata for each chunk.

            :param intermediate_storage: An S3 bucket path for input and output objects.
            :param transformations: A Lambda function that processes documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-customtransformationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                custom_transformation_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty(
                    intermediate_storage=bedrock_mixins.CfnDataSourcePropsMixin.IntermediateStorageProperty(
                        s3_location=bedrock_mixins.CfnDataSourcePropsMixin.S3LocationProperty(
                            uri="uri"
                        )
                    ),
                    transformations=[bedrock_mixins.CfnDataSourcePropsMixin.TransformationProperty(
                        step_to_apply="stepToApply",
                        transformation_function=bedrock_mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty(
                            transformation_lambda_configuration=bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                                lambda_arn="lambdaArn"
                            )
                        )
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__684e787bc278139ffd694ace8060a72a46cb72c84c93d7860e61b7d8db3a57b6)
                check_type(argname="argument intermediate_storage", value=intermediate_storage, expected_type=type_hints["intermediate_storage"])
                check_type(argname="argument transformations", value=transformations, expected_type=type_hints["transformations"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if intermediate_storage is not None:
                self._values["intermediate_storage"] = intermediate_storage
            if transformations is not None:
                self._values["transformations"] = transformations

        @builtins.property
        def intermediate_storage(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.IntermediateStorageProperty"]]:
            '''An S3 bucket path for input and output objects.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-customtransformationconfiguration.html#cfn-bedrock-datasource-customtransformationconfiguration-intermediatestorage
            '''
            result = self._values.get("intermediate_storage")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.IntermediateStorageProperty"]], result)

        @builtins.property
        def transformations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.TransformationProperty"]]]]:
            '''A Lambda function that processes documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-customtransformationconfiguration.html#cfn-bedrock-datasource-customtransformationconfiguration-transformations
            '''
            result = self._values.get("transformations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.TransformationProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CustomTransformationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.DataSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "confluence_configuration": "confluenceConfiguration",
            "s3_configuration": "s3Configuration",
            "salesforce_configuration": "salesforceConfiguration",
            "share_point_configuration": "sharePointConfiguration",
            "type": "type",
            "web_configuration": "webConfiguration",
        },
    )
    class DataSourceConfigurationProperty:
        def __init__(
            self,
            *,
            confluence_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            s3_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            salesforce_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            share_point_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
            web_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The connection configuration for the data source.

            :param confluence_configuration: The configuration information to connect to Confluence as your data source. .. epigraph:: Confluence data source connector is in preview release and is subject to change.
            :param s3_configuration: The configuration information to connect to Amazon S3 as your data source.
            :param salesforce_configuration: The configuration information to connect to Salesforce as your data source. .. epigraph:: Salesforce data source connector is in preview release and is subject to change.
            :param share_point_configuration: The configuration information to connect to SharePoint as your data source. .. epigraph:: SharePoint data source connector is in preview release and is subject to change.
            :param type: The type of data source.
            :param web_configuration: The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs. .. epigraph:: Crawling web URLs as your data source is in preview release and is subject to change.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                data_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.DataSourceConfigurationProperty(
                    confluence_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty(
                            filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                                pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                        exclusion_filters=["exclusionFilters"],
                                        inclusion_filters=["inclusionFilters"],
                                        object_type="objectType"
                                    )]
                                ),
                                type="type"
                            )
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty(
                            auth_type="authType",
                            credentials_secret_arn="credentialsSecretArn",
                            host_type="hostType",
                            host_url="hostUrl"
                        )
                    ),
                    s3_configuration=bedrock_mixins.CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty(
                        bucket_arn="bucketArn",
                        bucket_owner_account_id="bucketOwnerAccountId",
                        inclusion_prefixes=["inclusionPrefixes"]
                    ),
                    salesforce_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty(
                            filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                                pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                        exclusion_filters=["exclusionFilters"],
                                        inclusion_filters=["inclusionFilters"],
                                        object_type="objectType"
                                    )]
                                ),
                                type="type"
                            )
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty(
                            auth_type="authType",
                            credentials_secret_arn="credentialsSecretArn",
                            host_url="hostUrl"
                        )
                    ),
                    share_point_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty(
                            filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                                pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                        exclusion_filters=["exclusionFilters"],
                                        inclusion_filters=["inclusionFilters"],
                                        object_type="objectType"
                                    )]
                                ),
                                type="type"
                            )
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty(
                            auth_type="authType",
                            credentials_secret_arn="credentialsSecretArn",
                            domain="domain",
                            host_type="hostType",
                            site_urls=["siteUrls"],
                            tenant_id="tenantId"
                        )
                    ),
                    type="type",
                    web_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty(
                        crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty(
                            crawler_limits=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty(
                                max_pages=123,
                                rate_limit=123
                            ),
                            exclusion_filters=["exclusionFilters"],
                            inclusion_filters=["inclusionFilters"],
                            scope="scope",
                            user_agent="userAgent",
                            user_agent_header="userAgentHeader"
                        ),
                        source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebSourceConfigurationProperty(
                            url_configuration=bedrock_mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty(
                                seed_urls=[bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                                    url="url"
                                )]
                            )
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d63ab0c7a4ace2e5437084564cf92a7fa3ae86f6819bcaead693036fd700c858)
                check_type(argname="argument confluence_configuration", value=confluence_configuration, expected_type=type_hints["confluence_configuration"])
                check_type(argname="argument s3_configuration", value=s3_configuration, expected_type=type_hints["s3_configuration"])
                check_type(argname="argument salesforce_configuration", value=salesforce_configuration, expected_type=type_hints["salesforce_configuration"])
                check_type(argname="argument share_point_configuration", value=share_point_configuration, expected_type=type_hints["share_point_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument web_configuration", value=web_configuration, expected_type=type_hints["web_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if confluence_configuration is not None:
                self._values["confluence_configuration"] = confluence_configuration
            if s3_configuration is not None:
                self._values["s3_configuration"] = s3_configuration
            if salesforce_configuration is not None:
                self._values["salesforce_configuration"] = salesforce_configuration
            if share_point_configuration is not None:
                self._values["share_point_configuration"] = share_point_configuration
            if type is not None:
                self._values["type"] = type
            if web_configuration is not None:
                self._values["web_configuration"] = web_configuration

        @builtins.property
        def confluence_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty"]]:
            '''The configuration information to connect to Confluence as your data source.

            .. epigraph::

               Confluence data source connector is in preview release and is subject to change.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html#cfn-bedrock-datasource-datasourceconfiguration-confluenceconfiguration
            '''
            result = self._values.get("confluence_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty"]], result)

        @builtins.property
        def s3_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty"]]:
            '''The configuration information to connect to Amazon S3 as your data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html#cfn-bedrock-datasource-datasourceconfiguration-s3configuration
            '''
            result = self._values.get("s3_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty"]], result)

        @builtins.property
        def salesforce_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty"]]:
            '''The configuration information to connect to Salesforce as your data source.

            .. epigraph::

               Salesforce data source connector is in preview release and is subject to change.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html#cfn-bedrock-datasource-datasourceconfiguration-salesforceconfiguration
            '''
            result = self._values.get("salesforce_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty"]], result)

        @builtins.property
        def share_point_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty"]]:
            '''The configuration information to connect to SharePoint as your data source.

            .. epigraph::

               SharePoint data source connector is in preview release and is subject to change.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html#cfn-bedrock-datasource-datasourceconfiguration-sharepointconfiguration
            '''
            result = self._values.get("share_point_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html#cfn-bedrock-datasource-datasourceconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def web_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty"]]:
            '''The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.

            .. epigraph::

               Crawling web URLs as your data source is in preview release and is subject to change.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html#cfn-bedrock-datasource-datasourceconfiguration-webconfiguration
            '''
            result = self._values.get("web_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DataSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"method": "method"},
    )
    class EnrichmentStrategyConfigurationProperty:
        def __init__(self, *, method: typing.Optional[builtins.str] = None) -> None:
            '''The strategy used for performing context enrichment.

            :param method: The method used for the context enrichment strategy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-enrichmentstrategyconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                enrichment_strategy_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty(
                    method="method"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3dd4bcfc88b2cee8cc10343d7098b1074201f8cf6b3ef2c285a7e8abcad0aa4b)
                check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if method is not None:
                self._values["method"] = method

        @builtins.property
        def method(self) -> typing.Optional[builtins.str]:
            '''The method used for the context enrichment strategy.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-enrichmentstrategyconfiguration.html#cfn-bedrock-datasource-enrichmentstrategyconfiguration-method
            '''
            result = self._values.get("method")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnrichmentStrategyConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_tokens": "maxTokens",
            "overlap_percentage": "overlapPercentage",
        },
    )
    class FixedSizeChunkingConfigurationProperty:
        def __init__(
            self,
            *,
            max_tokens: typing.Optional[jsii.Number] = None,
            overlap_percentage: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configurations for when you choose fixed-size chunking.

            If you set the ``chunkingStrategy`` as ``NONE`` , exclude this field.

            :param max_tokens: The maximum number of tokens to include in a chunk.
            :param overlap_percentage: The percentage of overlap between adjacent chunks of a data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-fixedsizechunkingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                fixed_size_chunking_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty(
                    max_tokens=123,
                    overlap_percentage=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a0155e01b73c0fe792a9d1ac01cc9857e88347666d956e464c2adfaedcb10454)
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
                check_type(argname="argument overlap_percentage", value=overlap_percentage, expected_type=type_hints["overlap_percentage"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens
            if overlap_percentage is not None:
                self._values["overlap_percentage"] = overlap_percentage

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens to include in a chunk.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-fixedsizechunkingconfiguration.html#cfn-bedrock-datasource-fixedsizechunkingconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def overlap_percentage(self) -> typing.Optional[jsii.Number]:
            '''The percentage of overlap between adjacent chunks of a data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-fixedsizechunkingconfiguration.html#cfn-bedrock-datasource-fixedsizechunkingconfiguration-overlappercentage
            '''
            result = self._values.get("overlap_percentage")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FixedSizeChunkingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "level_configurations": "levelConfigurations",
            "overlap_tokens": "overlapTokens",
        },
    )
    class HierarchicalChunkingConfigurationProperty:
        def __init__(
            self,
            *,
            level_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            overlap_tokens: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Settings for hierarchical document chunking for a data source.

            Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.

            You configure the number of tokens to overlap, or repeat across adjacent chunks. For example, if you set overlap tokens to 60, the last 60 tokens in the first chunk are also included at the beginning of the second chunk. For each layer, you must also configure the maximum number of tokens in a chunk.

            :param level_configurations: Token settings for each layer.
            :param overlap_tokens: The number of tokens to repeat across chunks in the same layer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-hierarchicalchunkingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                hierarchical_chunking_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty(
                    level_configurations=[bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty(
                        max_tokens=123
                    )],
                    overlap_tokens=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f3e660b4faac287c87e300a994714ffe9152dcfae0dea7a67cb6a1fee11447d4)
                check_type(argname="argument level_configurations", value=level_configurations, expected_type=type_hints["level_configurations"])
                check_type(argname="argument overlap_tokens", value=overlap_tokens, expected_type=type_hints["overlap_tokens"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if level_configurations is not None:
                self._values["level_configurations"] = level_configurations
            if overlap_tokens is not None:
                self._values["overlap_tokens"] = overlap_tokens

        @builtins.property
        def level_configurations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty"]]]]:
            '''Token settings for each layer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-hierarchicalchunkingconfiguration.html#cfn-bedrock-datasource-hierarchicalchunkingconfiguration-levelconfigurations
            '''
            result = self._values.get("level_configurations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty"]]]], result)

        @builtins.property
        def overlap_tokens(self) -> typing.Optional[jsii.Number]:
            '''The number of tokens to repeat across chunks in the same layer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-hierarchicalchunkingconfiguration.html#cfn-bedrock-datasource-hierarchicalchunkingconfiguration-overlaptokens
            '''
            result = self._values.get("overlap_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HierarchicalChunkingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"max_tokens": "maxTokens"},
    )
    class HierarchicalChunkingLevelConfigurationProperty:
        def __init__(self, *, max_tokens: typing.Optional[jsii.Number] = None) -> None:
            '''Token settings for a layer in a hierarchical chunking configuration.

            :param max_tokens: The maximum number of tokens that a chunk can contain in this layer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-hierarchicalchunkinglevelconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                hierarchical_chunking_level_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty(
                    max_tokens=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dda58c904a3dca35a7955512cdb52ef39ccbb855304a4d6eb25b623b804044e4)
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens that a chunk can contain in this layer.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-hierarchicalchunkinglevelconfiguration.html#cfn-bedrock-datasource-hierarchicalchunkinglevelconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HierarchicalChunkingLevelConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.IntermediateStorageProperty",
        jsii_struct_bases=[],
        name_mapping={"s3_location": "s3Location"},
    )
    class IntermediateStorageProperty:
        def __init__(
            self,
            *,
            s3_location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.S3LocationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.

            :param s3_location: An S3 bucket path.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-intermediatestorage.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                intermediate_storage_property = bedrock_mixins.CfnDataSourcePropsMixin.IntermediateStorageProperty(
                    s3_location=bedrock_mixins.CfnDataSourcePropsMixin.S3LocationProperty(
                        uri="uri"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cc796c067ed3393e705332d27c06c2fcca49e2096b05acd3f421b472c8ce8564)
                check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3_location is not None:
                self._values["s3_location"] = s3_location

        @builtins.property
        def s3_location(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.S3LocationProperty"]]:
            '''An S3 bucket path.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-intermediatestorage.html#cfn-bedrock-datasource-intermediatestorage-s3location
            '''
            result = self._values.get("s3_location")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.S3LocationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IntermediateStorageProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ParsingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bedrock_data_automation_configuration": "bedrockDataAutomationConfiguration",
            "bedrock_foundation_model_configuration": "bedrockFoundationModelConfiguration",
            "parsing_strategy": "parsingStrategy",
        },
    )
    class ParsingConfigurationProperty:
        def __init__(
            self,
            *,
            bedrock_data_automation_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            bedrock_foundation_model_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            parsing_strategy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Settings for parsing document contents.

            If you exclude this field, the default parser converts the contents of each document into text before splitting it into chunks. Specify the parsing strategy to use in the ``parsingStrategy`` field and include the relevant configuration, or omit it to use the Amazon Bedrock default parser. For more information, see `Parsing options for your data source <https://docs.aws.amazon.com/bedrock/latest/userguide/kb-advanced-parsing.html>`_ .
            .. epigraph::

               If you specify ``BEDROCK_DATA_AUTOMATION`` or ``BEDROCK_FOUNDATION_MODEL`` and it fails to parse a file, the Amazon Bedrock default parser will be used instead.

            :param bedrock_data_automation_configuration: If you specify ``BEDROCK_DATA_AUTOMATION`` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
            :param bedrock_foundation_model_configuration: If you specify ``BEDROCK_FOUNDATION_MODEL`` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
            :param parsing_strategy: The parsing strategy for the data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-parsingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                parsing_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ParsingConfigurationProperty(
                    bedrock_data_automation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty(
                        parsing_modality="parsingModality"
                    ),
                    bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty(
                        model_arn="modelArn",
                        parsing_modality="parsingModality",
                        parsing_prompt=bedrock_mixins.CfnDataSourcePropsMixin.ParsingPromptProperty(
                            parsing_prompt_text="parsingPromptText"
                        )
                    ),
                    parsing_strategy="parsingStrategy"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f7a21006d4e1abcc128f92554ce6b7f952f515568edb74de2916b7e260278cad)
                check_type(argname="argument bedrock_data_automation_configuration", value=bedrock_data_automation_configuration, expected_type=type_hints["bedrock_data_automation_configuration"])
                check_type(argname="argument bedrock_foundation_model_configuration", value=bedrock_foundation_model_configuration, expected_type=type_hints["bedrock_foundation_model_configuration"])
                check_type(argname="argument parsing_strategy", value=parsing_strategy, expected_type=type_hints["parsing_strategy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bedrock_data_automation_configuration is not None:
                self._values["bedrock_data_automation_configuration"] = bedrock_data_automation_configuration
            if bedrock_foundation_model_configuration is not None:
                self._values["bedrock_foundation_model_configuration"] = bedrock_foundation_model_configuration
            if parsing_strategy is not None:
                self._values["parsing_strategy"] = parsing_strategy

        @builtins.property
        def bedrock_data_automation_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty"]]:
            '''If you specify ``BEDROCK_DATA_AUTOMATION`` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-parsingconfiguration.html#cfn-bedrock-datasource-parsingconfiguration-bedrockdataautomationconfiguration
            '''
            result = self._values.get("bedrock_data_automation_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty"]], result)

        @builtins.property
        def bedrock_foundation_model_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty"]]:
            '''If you specify ``BEDROCK_FOUNDATION_MODEL`` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-parsingconfiguration.html#cfn-bedrock-datasource-parsingconfiguration-bedrockfoundationmodelconfiguration
            '''
            result = self._values.get("bedrock_foundation_model_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty"]], result)

        @builtins.property
        def parsing_strategy(self) -> typing.Optional[builtins.str]:
            '''The parsing strategy for the data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-parsingconfiguration.html#cfn-bedrock-datasource-parsingconfiguration-parsingstrategy
            '''
            result = self._values.get("parsing_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ParsingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ParsingPromptProperty",
        jsii_struct_bases=[],
        name_mapping={"parsing_prompt_text": "parsingPromptText"},
    )
    class ParsingPromptProperty:
        def __init__(
            self,
            *,
            parsing_prompt_text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Instructions for interpreting the contents of a document.

            :param parsing_prompt_text: Instructions for interpreting the contents of a document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-parsingprompt.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                parsing_prompt_property = bedrock_mixins.CfnDataSourcePropsMixin.ParsingPromptProperty(
                    parsing_prompt_text="parsingPromptText"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__064a4ce39ff32139452c1ff9db51109274acff681f83a100574397fdc45f7b60)
                check_type(argname="argument parsing_prompt_text", value=parsing_prompt_text, expected_type=type_hints["parsing_prompt_text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if parsing_prompt_text is not None:
                self._values["parsing_prompt_text"] = parsing_prompt_text

        @builtins.property
        def parsing_prompt_text(self) -> typing.Optional[builtins.str]:
            '''Instructions for interpreting the contents of a document.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-parsingprompt.html#cfn-bedrock-datasource-parsingprompt-parsingprompttext
            '''
            result = self._values.get("parsing_prompt_text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ParsingPromptProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"filters": "filters"},
    )
    class PatternObjectFilterConfigurationProperty:
        def __init__(
            self,
            *,
            filters: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.PatternObjectFilterProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The configuration of filtering certain objects or content types of the data source.

            :param filters: The configuration of specific filters applied to your data source content. You can filter out or include certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-patternobjectfilterconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                pattern_object_filter_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                    filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                        exclusion_filters=["exclusionFilters"],
                        inclusion_filters=["inclusionFilters"],
                        object_type="objectType"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a90d5a8496c8876fa32060bd1c53eac23fb2cba369fd6cafd051681233489767)
                check_type(argname="argument filters", value=filters, expected_type=type_hints["filters"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if filters is not None:
                self._values["filters"] = filters

        @builtins.property
        def filters(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.PatternObjectFilterProperty"]]]]:
            '''The configuration of specific filters applied to your data source content.

            You can filter out or include certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-patternobjectfilterconfiguration.html#cfn-bedrock-datasource-patternobjectfilterconfiguration-filters
            '''
            result = self._values.get("filters")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.PatternObjectFilterProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PatternObjectFilterConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty",
        jsii_struct_bases=[],
        name_mapping={
            "exclusion_filters": "exclusionFilters",
            "inclusion_filters": "inclusionFilters",
            "object_type": "objectType",
        },
    )
    class PatternObjectFilterProperty:
        def __init__(
            self,
            *,
            exclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
            inclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
            object_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The specific filters applied to your data source content.

            You can filter out or include certain content.

            :param exclusion_filters: A list of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern. If you specify an inclusion and exclusion filter/pattern and both match a document, the exclusion filter takes precedence and the document isn’t crawled.
            :param inclusion_filters: A list of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern. If you specify an inclusion and exclusion filter/pattern and both match a document, the exclusion filter takes precedence and the document isn’t crawled.
            :param object_type: The supported object type or content type of the data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-patternobjectfilter.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                pattern_object_filter_property = bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                    exclusion_filters=["exclusionFilters"],
                    inclusion_filters=["inclusionFilters"],
                    object_type="objectType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0fe1623848a66df9ba9b1845649531dc96ff6ae1991c340ad607b9f373a3a496)
                check_type(argname="argument exclusion_filters", value=exclusion_filters, expected_type=type_hints["exclusion_filters"])
                check_type(argname="argument inclusion_filters", value=inclusion_filters, expected_type=type_hints["inclusion_filters"])
                check_type(argname="argument object_type", value=object_type, expected_type=type_hints["object_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if exclusion_filters is not None:
                self._values["exclusion_filters"] = exclusion_filters
            if inclusion_filters is not None:
                self._values["inclusion_filters"] = inclusion_filters
            if object_type is not None:
                self._values["object_type"] = object_type

        @builtins.property
        def exclusion_filters(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.

            If you specify an inclusion and exclusion filter/pattern and both match a document, the exclusion filter takes precedence and the document isn’t crawled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-patternobjectfilter.html#cfn-bedrock-datasource-patternobjectfilter-exclusionfilters
            '''
            result = self._values.get("exclusion_filters")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def inclusion_filters(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.

            If you specify an inclusion and exclusion filter/pattern and both match a document, the exclusion filter takes precedence and the document isn’t crawled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-patternobjectfilter.html#cfn-bedrock-datasource-patternobjectfilter-inclusionfilters
            '''
            result = self._values.get("inclusion_filters")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def object_type(self) -> typing.Optional[builtins.str]:
            '''The supported object type or content type of the data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-patternobjectfilter.html#cfn-bedrock-datasource-patternobjectfilter-objecttype
            '''
            result = self._values.get("object_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PatternObjectFilterProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bucket_arn": "bucketArn",
            "bucket_owner_account_id": "bucketOwnerAccountId",
            "inclusion_prefixes": "inclusionPrefixes",
        },
    )
    class S3DataSourceConfigurationProperty:
        def __init__(
            self,
            *,
            bucket_arn: typing.Optional[builtins.str] = None,
            bucket_owner_account_id: typing.Optional[builtins.str] = None,
            inclusion_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''The configuration information to connect to Amazon S3 as your data source.

            :param bucket_arn: The Amazon Resource Name (ARN) of the S3 bucket that contains your data.
            :param bucket_owner_account_id: The account ID for the owner of the S3 bucket.
            :param inclusion_prefixes: A list of S3 prefixes to include certain files or content. This field is an array with a maximum of one item, which can contain a string that has a maximum length of 300 characters. For more information, see `Organizing objects using prefixes <https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3datasourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                s3_data_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty(
                    bucket_arn="bucketArn",
                    bucket_owner_account_id="bucketOwnerAccountId",
                    inclusion_prefixes=["inclusionPrefixes"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b783448c1e8ea1513c98d4559876a38cb6857abc9f2e7a956919620f9629ea62)
                check_type(argname="argument bucket_arn", value=bucket_arn, expected_type=type_hints["bucket_arn"])
                check_type(argname="argument bucket_owner_account_id", value=bucket_owner_account_id, expected_type=type_hints["bucket_owner_account_id"])
                check_type(argname="argument inclusion_prefixes", value=inclusion_prefixes, expected_type=type_hints["inclusion_prefixes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_arn is not None:
                self._values["bucket_arn"] = bucket_arn
            if bucket_owner_account_id is not None:
                self._values["bucket_owner_account_id"] = bucket_owner_account_id
            if inclusion_prefixes is not None:
                self._values["inclusion_prefixes"] = inclusion_prefixes

        @builtins.property
        def bucket_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the S3 bucket that contains your data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3datasourceconfiguration.html#cfn-bedrock-datasource-s3datasourceconfiguration-bucketarn
            '''
            result = self._values.get("bucket_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def bucket_owner_account_id(self) -> typing.Optional[builtins.str]:
            '''The account ID for the owner of the S3 bucket.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3datasourceconfiguration.html#cfn-bedrock-datasource-s3datasourceconfiguration-bucketowneraccountid
            '''
            result = self._values.get("bucket_owner_account_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def inclusion_prefixes(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of S3 prefixes to include certain files or content.

            This field is an array with a maximum of one item, which can contain a string that has a maximum length of 300 characters. For more information, see `Organizing objects using prefixes <https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3datasourceconfiguration.html#cfn-bedrock-datasource-s3datasourceconfiguration-inclusionprefixes
            '''
            result = self._values.get("inclusion_prefixes")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3DataSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.S3LocationProperty",
        jsii_struct_bases=[],
        name_mapping={"uri": "uri"},
    )
    class S3LocationProperty:
        def __init__(self, *, uri: typing.Optional[builtins.str] = None) -> None:
            '''A storage location in an Amazon S3 bucket.

            :param uri: An object URI starting with ``s3://`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3location.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                s3_location_property = bedrock_mixins.CfnDataSourcePropsMixin.S3LocationProperty(
                    uri="uri"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__61cb4fd84a2d5579a5769de32a273e5d2280d531873b2ac2bc2c8da8223882ce)
                check_type(argname="argument uri", value=uri, expected_type=type_hints["uri"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if uri is not None:
                self._values["uri"] = uri

        @builtins.property
        def uri(self) -> typing.Optional[builtins.str]:
            '''An object URI starting with ``s3://`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3location.html#cfn-bedrock-datasource-s3location-uri
            '''
            result = self._values.get("uri")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3LocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"filter_configuration": "filterConfiguration"},
    )
    class SalesforceCrawlerConfigurationProperty:
        def __init__(
            self,
            *,
            filter_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the Salesforce content.

            For example, configuring specific types of Salesforce content.

            :param filter_configuration: The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcecrawlerconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                salesforce_crawler_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty(
                    filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                        pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                            filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                exclusion_filters=["exclusionFilters"],
                                inclusion_filters=["inclusionFilters"],
                                object_type="objectType"
                            )]
                        ),
                        type="type"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6c0db8fd164efb390558a9fd38d2bd8f23c0c8823779e76a7e5979ab7772d49e)
                check_type(argname="argument filter_configuration", value=filter_configuration, expected_type=type_hints["filter_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if filter_configuration is not None:
                self._values["filter_configuration"] = filter_configuration

        @builtins.property
        def filter_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty"]]:
            '''The configuration of filtering the Salesforce content.

            For example, configuring regular expression patterns to include or exclude certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcecrawlerconfiguration.html#cfn-bedrock-datasource-salesforcecrawlerconfiguration-filterconfiguration
            '''
            result = self._values.get("filter_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SalesforceCrawlerConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "crawler_configuration": "crawlerConfiguration",
            "source_configuration": "sourceConfiguration",
        },
    )
    class SalesforceDataSourceConfigurationProperty:
        def __init__(
            self,
            *,
            crawler_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration information to connect to Salesforce as your data source.

            :param crawler_configuration: The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
            :param source_configuration: The endpoint information to connect to your Salesforce data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcedatasourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                salesforce_data_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty(
                        filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                            pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                    exclusion_filters=["exclusionFilters"],
                                    inclusion_filters=["inclusionFilters"],
                                    object_type="objectType"
                                )]
                            ),
                            type="type"
                        )
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty(
                        auth_type="authType",
                        credentials_secret_arn="credentialsSecretArn",
                        host_url="hostUrl"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__28714fd99e295f3c4d605667ac6387377460df06b37830b150629393c8f1113f)
                check_type(argname="argument crawler_configuration", value=crawler_configuration, expected_type=type_hints["crawler_configuration"])
                check_type(argname="argument source_configuration", value=source_configuration, expected_type=type_hints["source_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if crawler_configuration is not None:
                self._values["crawler_configuration"] = crawler_configuration
            if source_configuration is not None:
                self._values["source_configuration"] = source_configuration

        @builtins.property
        def crawler_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty"]]:
            '''The configuration of the Salesforce content.

            For example, configuring specific types of Salesforce content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcedatasourceconfiguration.html#cfn-bedrock-datasource-salesforcedatasourceconfiguration-crawlerconfiguration
            '''
            result = self._values.get("crawler_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty"]], result)

        @builtins.property
        def source_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty"]]:
            '''The endpoint information to connect to your Salesforce data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcedatasourceconfiguration.html#cfn-bedrock-datasource-salesforcedatasourceconfiguration-sourceconfiguration
            '''
            result = self._values.get("source_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SalesforceDataSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth_type": "authType",
            "credentials_secret_arn": "credentialsSecretArn",
            "host_url": "hostUrl",
        },
    )
    class SalesforceSourceConfigurationProperty:
        def __init__(
            self,
            *,
            auth_type: typing.Optional[builtins.str] = None,
            credentials_secret_arn: typing.Optional[builtins.str] = None,
            host_url: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The endpoint information to connect to your Salesforce data source.

            :param auth_type: The supported authentication type to authenticate and connect to your Salesforce instance.
            :param credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see `Salesforce connection configuration <https://docs.aws.amazon.com/bedrock/latest/userguide/salesforce-data-source-connector.html#configuration-salesforce-connector>`_ .
            :param host_url: The Salesforce host URL or instance URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcesourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                salesforce_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty(
                    auth_type="authType",
                    credentials_secret_arn="credentialsSecretArn",
                    host_url="hostUrl"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c89c24a7b5a02441215e0a5164c3711b39f96484da5680d47bdd8de917f489fc)
                check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
                check_type(argname="argument credentials_secret_arn", value=credentials_secret_arn, expected_type=type_hints["credentials_secret_arn"])
                check_type(argname="argument host_url", value=host_url, expected_type=type_hints["host_url"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth_type is not None:
                self._values["auth_type"] = auth_type
            if credentials_secret_arn is not None:
                self._values["credentials_secret_arn"] = credentials_secret_arn
            if host_url is not None:
                self._values["host_url"] = host_url

        @builtins.property
        def auth_type(self) -> typing.Optional[builtins.str]:
            '''The supported authentication type to authenticate and connect to your Salesforce instance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcesourceconfiguration.html#cfn-bedrock-datasource-salesforcesourceconfiguration-authtype
            '''
            result = self._values.get("auth_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def credentials_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL.

            For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see `Salesforce connection configuration <https://docs.aws.amazon.com/bedrock/latest/userguide/salesforce-data-source-connector.html#configuration-salesforce-connector>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcesourceconfiguration.html#cfn-bedrock-datasource-salesforcesourceconfiguration-credentialssecretarn
            '''
            result = self._values.get("credentials_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_url(self) -> typing.Optional[builtins.str]:
            '''The Salesforce host URL or instance URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-salesforcesourceconfiguration.html#cfn-bedrock-datasource-salesforcesourceconfiguration-hosturl
            '''
            result = self._values.get("host_url")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SalesforceSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SeedUrlProperty",
        jsii_struct_bases=[],
        name_mapping={"url": "url"},
    )
    class SeedUrlProperty:
        def __init__(self, *, url: typing.Optional[builtins.str] = None) -> None:
            '''The seed or starting point URL.

            You should be authorized to crawl the URL.

            :param url: A seed or starting point URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-seedurl.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                seed_url_property = bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                    url="url"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3f761c7ade813493758998baa8acc117d7c57f007ee5c1765a8ebca30242dd45)
                check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if url is not None:
                self._values["url"] = url

        @builtins.property
        def url(self) -> typing.Optional[builtins.str]:
            '''A seed or starting point URL.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-seedurl.html#cfn-bedrock-datasource-seedurl-url
            '''
            result = self._values.get("url")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SeedUrlProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "breakpoint_percentile_threshold": "breakpointPercentileThreshold",
            "buffer_size": "bufferSize",
            "max_tokens": "maxTokens",
        },
    )
    class SemanticChunkingConfigurationProperty:
        def __init__(
            self,
            *,
            breakpoint_percentile_threshold: typing.Optional[jsii.Number] = None,
            buffer_size: typing.Optional[jsii.Number] = None,
            max_tokens: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Settings for semantic document chunking for a data source.

            Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.

            With semantic chunking, each sentence is compared to the next to determine how similar they are. You specify a threshold in the form of a percentile, where adjacent sentences that are less similar than that percentage of sentence pairs are divided into separate chunks. For example, if you set the threshold to 90, then the 10 percent of sentence pairs that are least similar are split. So if you have 101 sentences, 100 sentence pairs are compared, and the 10 with the least similarity are split, creating 11 chunks. These chunks are further split if they exceed the max token size.

            You must also specify a buffer size, which determines whether sentences are compared in isolation, or within a moving context window that includes the previous and following sentence. For example, if you set the buffer size to ``1`` , the embedding for sentence 10 is derived from sentences 9, 10, and 11 combined.

            :param breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
            :param buffer_size: The buffer size.
            :param max_tokens: The maximum number of tokens that a chunk can contain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-semanticchunkingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                semantic_chunking_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty(
                    breakpoint_percentile_threshold=123,
                    buffer_size=123,
                    max_tokens=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dc5677ba471514a86d6594da18ab5e2724a7b5acc4047ff13dfd1959942eb13f)
                check_type(argname="argument breakpoint_percentile_threshold", value=breakpoint_percentile_threshold, expected_type=type_hints["breakpoint_percentile_threshold"])
                check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if breakpoint_percentile_threshold is not None:
                self._values["breakpoint_percentile_threshold"] = breakpoint_percentile_threshold
            if buffer_size is not None:
                self._values["buffer_size"] = buffer_size
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens

        @builtins.property
        def breakpoint_percentile_threshold(self) -> typing.Optional[jsii.Number]:
            '''The dissimilarity threshold for splitting chunks.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-semanticchunkingconfiguration.html#cfn-bedrock-datasource-semanticchunkingconfiguration-breakpointpercentilethreshold
            '''
            result = self._values.get("breakpoint_percentile_threshold")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def buffer_size(self) -> typing.Optional[jsii.Number]:
            '''The buffer size.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-semanticchunkingconfiguration.html#cfn-bedrock-datasource-semanticchunkingconfiguration-buffersize
            '''
            result = self._values.get("buffer_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens that a chunk can contain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-semanticchunkingconfiguration.html#cfn-bedrock-datasource-semanticchunkingconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SemanticChunkingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"kms_key_arn": "kmsKeyArn"},
    )
    class ServerSideEncryptionConfigurationProperty:
        def __init__(
            self,
            *,
            kms_key_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the configuration for server-side encryption.

            :param kms_key_arn: The Amazon Resource Name (ARN) of the AWS key used to encrypt the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-serversideencryptionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                server_side_encryption_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty(
                    kms_key_arn="kmsKeyArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4f8339841538f1476c65269779da7536fca8b545a88d407225b01e7c9dee2ff0)
                check_type(argname="argument kms_key_arn", value=kms_key_arn, expected_type=type_hints["kms_key_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if kms_key_arn is not None:
                self._values["kms_key_arn"] = kms_key_arn

        @builtins.property
        def kms_key_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the AWS  key used to encrypt the resource.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-serversideencryptionconfiguration.html#cfn-bedrock-datasource-serversideencryptionconfiguration-kmskeyarn
            '''
            result = self._values.get("kms_key_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ServerSideEncryptionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"filter_configuration": "filterConfiguration"},
    )
    class SharePointCrawlerConfigurationProperty:
        def __init__(
            self,
            *,
            filter_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the SharePoint content.

            For example, configuring specific types of SharePoint content.

            :param filter_configuration: The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointcrawlerconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                share_point_crawler_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty(
                    filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                        pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                            filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                exclusion_filters=["exclusionFilters"],
                                inclusion_filters=["inclusionFilters"],
                                object_type="objectType"
                            )]
                        ),
                        type="type"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__05ff5b9e370fd66d4928591500cc4d53aeecad6f89c6a1d5957759a63681dcda)
                check_type(argname="argument filter_configuration", value=filter_configuration, expected_type=type_hints["filter_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if filter_configuration is not None:
                self._values["filter_configuration"] = filter_configuration

        @builtins.property
        def filter_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty"]]:
            '''The configuration of filtering the SharePoint content.

            For example, configuring regular expression patterns to include or exclude certain content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointcrawlerconfiguration.html#cfn-bedrock-datasource-sharepointcrawlerconfiguration-filterconfiguration
            '''
            result = self._values.get("filter_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SharePointCrawlerConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "crawler_configuration": "crawlerConfiguration",
            "source_configuration": "sourceConfiguration",
        },
    )
    class SharePointDataSourceConfigurationProperty:
        def __init__(
            self,
            *,
            crawler_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration information to connect to SharePoint as your data source.

            :param crawler_configuration: The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
            :param source_configuration: The endpoint information to connect to your SharePoint data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointdatasourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                share_point_data_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty(
                        filter_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty(
                            pattern_object_filter=bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty(
                                filters=[bedrock_mixins.CfnDataSourcePropsMixin.PatternObjectFilterProperty(
                                    exclusion_filters=["exclusionFilters"],
                                    inclusion_filters=["inclusionFilters"],
                                    object_type="objectType"
                                )]
                            ),
                            type="type"
                        )
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty(
                        auth_type="authType",
                        credentials_secret_arn="credentialsSecretArn",
                        domain="domain",
                        host_type="hostType",
                        site_urls=["siteUrls"],
                        tenant_id="tenantId"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4456af60d2b7892d62a1e8810b28470767c1810af2af2984eaf3affbcd84363e)
                check_type(argname="argument crawler_configuration", value=crawler_configuration, expected_type=type_hints["crawler_configuration"])
                check_type(argname="argument source_configuration", value=source_configuration, expected_type=type_hints["source_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if crawler_configuration is not None:
                self._values["crawler_configuration"] = crawler_configuration
            if source_configuration is not None:
                self._values["source_configuration"] = source_configuration

        @builtins.property
        def crawler_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty"]]:
            '''The configuration of the SharePoint content.

            For example, configuring specific types of SharePoint content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointdatasourceconfiguration.html#cfn-bedrock-datasource-sharepointdatasourceconfiguration-crawlerconfiguration
            '''
            result = self._values.get("crawler_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty"]], result)

        @builtins.property
        def source_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty"]]:
            '''The endpoint information to connect to your SharePoint data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointdatasourceconfiguration.html#cfn-bedrock-datasource-sharepointdatasourceconfiguration-sourceconfiguration
            '''
            result = self._values.get("source_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SharePointDataSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth_type": "authType",
            "credentials_secret_arn": "credentialsSecretArn",
            "domain": "domain",
            "host_type": "hostType",
            "site_urls": "siteUrls",
            "tenant_id": "tenantId",
        },
    )
    class SharePointSourceConfigurationProperty:
        def __init__(
            self,
            *,
            auth_type: typing.Optional[builtins.str] = None,
            credentials_secret_arn: typing.Optional[builtins.str] = None,
            domain: typing.Optional[builtins.str] = None,
            host_type: typing.Optional[builtins.str] = None,
            site_urls: typing.Optional[typing.Sequence[builtins.str]] = None,
            tenant_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The endpoint information to connect to your SharePoint data source.

            :param auth_type: The supported authentication type to authenticate and connect to your SharePoint site/sites.
            :param credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see `SharePoint connection configuration <https://docs.aws.amazon.com/bedrock/latest/userguide/sharepoint-data-source-connector.html#configuration-sharepoint-connector>`_ .
            :param domain: The domain of your SharePoint instance or site URL/URLs.
            :param host_type: The supported host type, whether online/cloud or server/on-premises.
            :param site_urls: A list of one or more SharePoint site URLs.
            :param tenant_id: The identifier of your Microsoft 365 tenant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                share_point_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty(
                    auth_type="authType",
                    credentials_secret_arn="credentialsSecretArn",
                    domain="domain",
                    host_type="hostType",
                    site_urls=["siteUrls"],
                    tenant_id="tenantId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__80cfed15f3c56760446f34fbb5dc4b9249f071efa4d2bb150e4e2d31222eb14c)
                check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
                check_type(argname="argument credentials_secret_arn", value=credentials_secret_arn, expected_type=type_hints["credentials_secret_arn"])
                check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
                check_type(argname="argument host_type", value=host_type, expected_type=type_hints["host_type"])
                check_type(argname="argument site_urls", value=site_urls, expected_type=type_hints["site_urls"])
                check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth_type is not None:
                self._values["auth_type"] = auth_type
            if credentials_secret_arn is not None:
                self._values["credentials_secret_arn"] = credentials_secret_arn
            if domain is not None:
                self._values["domain"] = domain
            if host_type is not None:
                self._values["host_type"] = host_type
            if site_urls is not None:
                self._values["site_urls"] = site_urls
            if tenant_id is not None:
                self._values["tenant_id"] = tenant_id

        @builtins.property
        def auth_type(self) -> typing.Optional[builtins.str]:
            '''The supported authentication type to authenticate and connect to your SharePoint site/sites.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html#cfn-bedrock-datasource-sharepointsourceconfiguration-authtype
            '''
            result = self._values.get("auth_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def credentials_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites.

            For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see `SharePoint connection configuration <https://docs.aws.amazon.com/bedrock/latest/userguide/sharepoint-data-source-connector.html#configuration-sharepoint-connector>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html#cfn-bedrock-datasource-sharepointsourceconfiguration-credentialssecretarn
            '''
            result = self._values.get("credentials_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def domain(self) -> typing.Optional[builtins.str]:
            '''The domain of your SharePoint instance or site URL/URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html#cfn-bedrock-datasource-sharepointsourceconfiguration-domain
            '''
            result = self._values.get("domain")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_type(self) -> typing.Optional[builtins.str]:
            '''The supported host type, whether online/cloud or server/on-premises.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html#cfn-bedrock-datasource-sharepointsourceconfiguration-hosttype
            '''
            result = self._values.get("host_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def site_urls(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of one or more SharePoint site URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html#cfn-bedrock-datasource-sharepointsourceconfiguration-siteurls
            '''
            result = self._values.get("site_urls")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def tenant_id(self) -> typing.Optional[builtins.str]:
            '''The identifier of your Microsoft 365 tenant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-sharepointsourceconfiguration.html#cfn-bedrock-datasource-sharepointsourceconfiguration-tenantid
            '''
            result = self._values.get("tenant_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SharePointSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "transformation_lambda_configuration": "transformationLambdaConfiguration",
        },
    )
    class TransformationFunctionProperty:
        def __init__(
            self,
            *,
            transformation_lambda_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''A Lambda function that processes documents.

            :param transformation_lambda_configuration: The Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformationfunction.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                transformation_function_property = bedrock_mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty(
                    transformation_lambda_configuration=bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                        lambda_arn="lambdaArn"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__22f5b8866a06eb4bce06713d85d5b6eeb0c873901ef6befe53a8f8a5ca8e5f9a)
                check_type(argname="argument transformation_lambda_configuration", value=transformation_lambda_configuration, expected_type=type_hints["transformation_lambda_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if transformation_lambda_configuration is not None:
                self._values["transformation_lambda_configuration"] = transformation_lambda_configuration

        @builtins.property
        def transformation_lambda_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty"]]:
            '''The Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformationfunction.html#cfn-bedrock-datasource-transformationfunction-transformationlambdaconfiguration
            '''
            result = self._values.get("transformation_lambda_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransformationFunctionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"lambda_arn": "lambdaArn"},
    )
    class TransformationLambdaConfigurationProperty:
        def __init__(self, *, lambda_arn: typing.Optional[builtins.str] = None) -> None:
            '''A Lambda function that processes documents.

            :param lambda_arn: The function's ARN identifier.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformationlambdaconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                transformation_lambda_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                    lambda_arn="lambdaArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__61277e266712ab1123a6e53a13e1bc0f4c37eae9a99a1079557cb4b72f1d0c92)
                check_type(argname="argument lambda_arn", value=lambda_arn, expected_type=type_hints["lambda_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if lambda_arn is not None:
                self._values["lambda_arn"] = lambda_arn

        @builtins.property
        def lambda_arn(self) -> typing.Optional[builtins.str]:
            '''The function's ARN identifier.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformationlambdaconfiguration.html#cfn-bedrock-datasource-transformationlambdaconfiguration-lambdaarn
            '''
            result = self._values.get("lambda_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransformationLambdaConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.TransformationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "step_to_apply": "stepToApply",
            "transformation_function": "transformationFunction",
        },
    )
    class TransformationProperty:
        def __init__(
            self,
            *,
            step_to_apply: typing.Optional[builtins.str] = None,
            transformation_function: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.TransformationFunctionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''A custom processing step for documents moving through a data source ingestion pipeline.

            To process documents after they have been converted into chunks, set the step to apply to ``POST_CHUNKING`` .

            :param step_to_apply: When the service applies the transformation.
            :param transformation_function: A Lambda function that processes documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                transformation_property = bedrock_mixins.CfnDataSourcePropsMixin.TransformationProperty(
                    step_to_apply="stepToApply",
                    transformation_function=bedrock_mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty(
                        transformation_lambda_configuration=bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                            lambda_arn="lambdaArn"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__44aefd40fb1a1df956a8ccac12fe37074fa0e09ef4c6b6089c81779ca65c3c2f)
                check_type(argname="argument step_to_apply", value=step_to_apply, expected_type=type_hints["step_to_apply"])
                check_type(argname="argument transformation_function", value=transformation_function, expected_type=type_hints["transformation_function"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if step_to_apply is not None:
                self._values["step_to_apply"] = step_to_apply
            if transformation_function is not None:
                self._values["transformation_function"] = transformation_function

        @builtins.property
        def step_to_apply(self) -> typing.Optional[builtins.str]:
            '''When the service applies the transformation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformation.html#cfn-bedrock-datasource-transformation-steptoapply
            '''
            result = self._values.get("step_to_apply")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def transformation_function(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.TransformationFunctionProperty"]]:
            '''A Lambda function that processes documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-transformation.html#cfn-bedrock-datasource-transformation-transformationfunction
            '''
            result = self._values.get("transformation_function")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.TransformationFunctionProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransformationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"seed_urls": "seedUrls"},
    )
    class UrlConfigurationProperty:
        def __init__(
            self,
            *,
            seed_urls: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.SeedUrlProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The configuration of web URLs that you want to crawl.

            You should be authorized to crawl the URLs.

            :param seed_urls: One or more seed or starting point URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-urlconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                url_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty(
                    seed_urls=[bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                        url="url"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e127c40d3453071cc64e854e5d47383bd416b3062e6110ea2e81b56d0ef4b924)
                check_type(argname="argument seed_urls", value=seed_urls, expected_type=type_hints["seed_urls"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if seed_urls is not None:
                self._values["seed_urls"] = seed_urls

        @builtins.property
        def seed_urls(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SeedUrlProperty"]]]]:
            '''One or more seed or starting point URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-urlconfiguration.html#cfn-bedrock-datasource-urlconfiguration-seedurls
            '''
            result = self._values.get("seed_urls")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.SeedUrlProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "UrlConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "chunking_configuration": "chunkingConfiguration",
            "context_enrichment_configuration": "contextEnrichmentConfiguration",
            "custom_transformation_configuration": "customTransformationConfiguration",
            "parsing_configuration": "parsingConfiguration",
        },
    )
    class VectorIngestionConfigurationProperty:
        def __init__(
            self,
            *,
            chunking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ChunkingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            context_enrichment_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            custom_transformation_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            parsing_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.ParsingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains details about how to ingest the documents in a data source.

            :param chunking_configuration: Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
            :param context_enrichment_configuration: The context enrichment configuration used for ingestion of the data into the vector store.
            :param custom_transformation_configuration: A custom document transformer for parsed data source documents.
            :param parsing_configuration: Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-vectoringestionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                vector_ingestion_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty(
                    chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ChunkingConfigurationProperty(
                        chunking_strategy="chunkingStrategy",
                        fixed_size_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty(
                            max_tokens=123,
                            overlap_percentage=123
                        ),
                        hierarchical_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty(
                            level_configurations=[bedrock_mixins.CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty(
                                max_tokens=123
                            )],
                            overlap_tokens=123
                        ),
                        semantic_chunking_configuration=bedrock_mixins.CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty(
                            breakpoint_percentile_threshold=123,
                            buffer_size=123,
                            max_tokens=123
                        )
                    ),
                    context_enrichment_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty(
                        bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty(
                            enrichment_strategy_configuration=bedrock_mixins.CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty(
                                method="method"
                            ),
                            model_arn="modelArn"
                        ),
                        type="type"
                    ),
                    custom_transformation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty(
                        intermediate_storage=bedrock_mixins.CfnDataSourcePropsMixin.IntermediateStorageProperty(
                            s3_location=bedrock_mixins.CfnDataSourcePropsMixin.S3LocationProperty(
                                uri="uri"
                            )
                        ),
                        transformations=[bedrock_mixins.CfnDataSourcePropsMixin.TransformationProperty(
                            step_to_apply="stepToApply",
                            transformation_function=bedrock_mixins.CfnDataSourcePropsMixin.TransformationFunctionProperty(
                                transformation_lambda_configuration=bedrock_mixins.CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty(
                                    lambda_arn="lambdaArn"
                                )
                            )
                        )]
                    ),
                    parsing_configuration=bedrock_mixins.CfnDataSourcePropsMixin.ParsingConfigurationProperty(
                        bedrock_data_automation_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty(
                            parsing_modality="parsingModality"
                        ),
                        bedrock_foundation_model_configuration=bedrock_mixins.CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty(
                            model_arn="modelArn",
                            parsing_modality="parsingModality",
                            parsing_prompt=bedrock_mixins.CfnDataSourcePropsMixin.ParsingPromptProperty(
                                parsing_prompt_text="parsingPromptText"
                            )
                        ),
                        parsing_strategy="parsingStrategy"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a7e9c8480f1ce602fac9676a5162011792e5c743de472377b169453314d96c50)
                check_type(argname="argument chunking_configuration", value=chunking_configuration, expected_type=type_hints["chunking_configuration"])
                check_type(argname="argument context_enrichment_configuration", value=context_enrichment_configuration, expected_type=type_hints["context_enrichment_configuration"])
                check_type(argname="argument custom_transformation_configuration", value=custom_transformation_configuration, expected_type=type_hints["custom_transformation_configuration"])
                check_type(argname="argument parsing_configuration", value=parsing_configuration, expected_type=type_hints["parsing_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if chunking_configuration is not None:
                self._values["chunking_configuration"] = chunking_configuration
            if context_enrichment_configuration is not None:
                self._values["context_enrichment_configuration"] = context_enrichment_configuration
            if custom_transformation_configuration is not None:
                self._values["custom_transformation_configuration"] = custom_transformation_configuration
            if parsing_configuration is not None:
                self._values["parsing_configuration"] = parsing_configuration

        @builtins.property
        def chunking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ChunkingConfigurationProperty"]]:
            '''Details about how to chunk the documents in the data source.

            A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-vectoringestionconfiguration.html#cfn-bedrock-datasource-vectoringestionconfiguration-chunkingconfiguration
            '''
            result = self._values.get("chunking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ChunkingConfigurationProperty"]], result)

        @builtins.property
        def context_enrichment_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty"]]:
            '''The context enrichment configuration used for ingestion of the data into the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-vectoringestionconfiguration.html#cfn-bedrock-datasource-vectoringestionconfiguration-contextenrichmentconfiguration
            '''
            result = self._values.get("context_enrichment_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty"]], result)

        @builtins.property
        def custom_transformation_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty"]]:
            '''A custom document transformer for parsed data source documents.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-vectoringestionconfiguration.html#cfn-bedrock-datasource-vectoringestionconfiguration-customtransformationconfiguration
            '''
            result = self._values.get("custom_transformation_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty"]], result)

        @builtins.property
        def parsing_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ParsingConfigurationProperty"]]:
            '''Configurations for a parser to use for parsing documents in your data source.

            If you exclude this field, the default parser will be used.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-vectoringestionconfiguration.html#cfn-bedrock-datasource-vectoringestionconfiguration-parsingconfiguration
            '''
            result = self._values.get("parsing_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.ParsingConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorIngestionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "crawler_limits": "crawlerLimits",
            "exclusion_filters": "exclusionFilters",
            "inclusion_filters": "inclusionFilters",
            "scope": "scope",
            "user_agent": "userAgent",
            "user_agent_header": "userAgentHeader",
        },
    )
    class WebCrawlerConfigurationProperty:
        def __init__(
            self,
            *,
            crawler_limits: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.WebCrawlerLimitsProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            exclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
            inclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
            scope: typing.Optional[builtins.str] = None,
            user_agent: typing.Optional[builtins.str] = None,
            user_agent_header: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The configuration of web URLs that you want to crawl.

            You should be authorized to crawl the URLs.

            :param crawler_limits: The configuration of crawl limits for the web URLs.
            :param exclusion_filters: A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
            :param inclusion_filters: A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
            :param scope: The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
            :param user_agent: Returns the user agent suffix for your web crawler.
            :param user_agent_header: A string used for identifying the crawler or bot when it accesses a web server. The user agent header value consists of the ``bedrockbot`` , UUID, and a user agent suffix for your crawler (if one is provided). By default, it is set to ``bedrockbot_UUID`` . You can optionally append a custom suffix to ``bedrockbot_UUID`` to allowlist a specific user agent permitted to access your source URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                web_crawler_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty(
                    crawler_limits=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty(
                        max_pages=123,
                        rate_limit=123
                    ),
                    exclusion_filters=["exclusionFilters"],
                    inclusion_filters=["inclusionFilters"],
                    scope="scope",
                    user_agent="userAgent",
                    user_agent_header="userAgentHeader"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cd435b7f007b366f1bcf5138314b09c006f9e4381361a6e9b3f02c20f04b3a8c)
                check_type(argname="argument crawler_limits", value=crawler_limits, expected_type=type_hints["crawler_limits"])
                check_type(argname="argument exclusion_filters", value=exclusion_filters, expected_type=type_hints["exclusion_filters"])
                check_type(argname="argument inclusion_filters", value=inclusion_filters, expected_type=type_hints["inclusion_filters"])
                check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
                check_type(argname="argument user_agent", value=user_agent, expected_type=type_hints["user_agent"])
                check_type(argname="argument user_agent_header", value=user_agent_header, expected_type=type_hints["user_agent_header"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if crawler_limits is not None:
                self._values["crawler_limits"] = crawler_limits
            if exclusion_filters is not None:
                self._values["exclusion_filters"] = exclusion_filters
            if inclusion_filters is not None:
                self._values["inclusion_filters"] = inclusion_filters
            if scope is not None:
                self._values["scope"] = scope
            if user_agent is not None:
                self._values["user_agent"] = user_agent
            if user_agent_header is not None:
                self._values["user_agent_header"] = user_agent_header

        @builtins.property
        def crawler_limits(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebCrawlerLimitsProperty"]]:
            '''The configuration of crawl limits for the web URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html#cfn-bedrock-datasource-webcrawlerconfiguration-crawlerlimits
            '''
            result = self._values.get("crawler_limits")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebCrawlerLimitsProperty"]], result)

        @builtins.property
        def exclusion_filters(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of one or more exclusion regular expression patterns to exclude certain URLs.

            If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html#cfn-bedrock-datasource-webcrawlerconfiguration-exclusionfilters
            '''
            result = self._values.get("exclusion_filters")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def inclusion_filters(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of one or more inclusion regular expression patterns to include certain URLs.

            If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html#cfn-bedrock-datasource-webcrawlerconfiguration-inclusionfilters
            '''
            result = self._values.get("inclusion_filters")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def scope(self) -> typing.Optional[builtins.str]:
            '''The scope of what is crawled for your URLs.

            You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html#cfn-bedrock-datasource-webcrawlerconfiguration-scope
            '''
            result = self._values.get("scope")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_agent(self) -> typing.Optional[builtins.str]:
            '''Returns the user agent suffix for your web crawler.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html#cfn-bedrock-datasource-webcrawlerconfiguration-useragent
            '''
            result = self._values.get("user_agent")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def user_agent_header(self) -> typing.Optional[builtins.str]:
            '''A string used for identifying the crawler or bot when it accesses a web server.

            The user agent header value consists of the ``bedrockbot`` , UUID, and a user agent suffix for your crawler (if one is provided). By default, it is set to ``bedrockbot_UUID`` . You can optionally append a custom suffix to ``bedrockbot_UUID`` to allowlist a specific user agent permitted to access your source URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerconfiguration.html#cfn-bedrock-datasource-webcrawlerconfiguration-useragentheader
            '''
            result = self._values.get("user_agent_header")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "WebCrawlerConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty",
        jsii_struct_bases=[],
        name_mapping={"max_pages": "maxPages", "rate_limit": "rateLimit"},
    )
    class WebCrawlerLimitsProperty:
        def __init__(
            self,
            *,
            max_pages: typing.Optional[jsii.Number] = None,
            rate_limit: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The rate limits for the URLs that you want to crawl.

            You should be authorized to crawl the URLs.

            :param max_pages: The max number of web pages crawled from your source URLs, up to 25,000 pages. If the web pages exceed this limit, the data source sync will fail and no web pages will be ingested.
            :param rate_limit: The max rate at which pages are crawled, up to 300 per minute per host.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerlimits.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                web_crawler_limits_property = bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty(
                    max_pages=123,
                    rate_limit=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6fc83f11e336a36388b1c49a8b2d692760cd703805150bd3fbba0467c2e6362a)
                check_type(argname="argument max_pages", value=max_pages, expected_type=type_hints["max_pages"])
                check_type(argname="argument rate_limit", value=rate_limit, expected_type=type_hints["rate_limit"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_pages is not None:
                self._values["max_pages"] = max_pages
            if rate_limit is not None:
                self._values["rate_limit"] = rate_limit

        @builtins.property
        def max_pages(self) -> typing.Optional[jsii.Number]:
            '''The max number of web pages crawled from your source URLs, up to 25,000 pages.

            If the web pages exceed this limit, the data source sync will fail and no web pages will be ingested.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerlimits.html#cfn-bedrock-datasource-webcrawlerlimits-maxpages
            '''
            result = self._values.get("max_pages")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def rate_limit(self) -> typing.Optional[jsii.Number]:
            '''The max rate at which pages are crawled, up to 300 per minute per host.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webcrawlerlimits.html#cfn-bedrock-datasource-webcrawlerlimits-ratelimit
            '''
            result = self._values.get("rate_limit")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "WebCrawlerLimitsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "crawler_configuration": "crawlerConfiguration",
            "source_configuration": "sourceConfiguration",
        },
    )
    class WebDataSourceConfigurationProperty:
        def __init__(
            self,
            *,
            crawler_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.WebSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration details for the web data source.

            :param crawler_configuration: The Web Crawler configuration details for the web data source.
            :param source_configuration: The source configuration details for the web data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webdatasourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                web_data_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty(
                    crawler_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty(
                        crawler_limits=bedrock_mixins.CfnDataSourcePropsMixin.WebCrawlerLimitsProperty(
                            max_pages=123,
                            rate_limit=123
                        ),
                        exclusion_filters=["exclusionFilters"],
                        inclusion_filters=["inclusionFilters"],
                        scope="scope",
                        user_agent="userAgent",
                        user_agent_header="userAgentHeader"
                    ),
                    source_configuration=bedrock_mixins.CfnDataSourcePropsMixin.WebSourceConfigurationProperty(
                        url_configuration=bedrock_mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty(
                            seed_urls=[bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                                url="url"
                            )]
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6df8fbf2401e355f6b2e2efdf30a4b8423c6ef60f2631ed6c7f194d9e0a3c848)
                check_type(argname="argument crawler_configuration", value=crawler_configuration, expected_type=type_hints["crawler_configuration"])
                check_type(argname="argument source_configuration", value=source_configuration, expected_type=type_hints["source_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if crawler_configuration is not None:
                self._values["crawler_configuration"] = crawler_configuration
            if source_configuration is not None:
                self._values["source_configuration"] = source_configuration

        @builtins.property
        def crawler_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty"]]:
            '''The Web Crawler configuration details for the web data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webdatasourceconfiguration.html#cfn-bedrock-datasource-webdatasourceconfiguration-crawlerconfiguration
            '''
            result = self._values.get("crawler_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty"]], result)

        @builtins.property
        def source_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebSourceConfigurationProperty"]]:
            '''The source configuration details for the web data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-webdatasourceconfiguration.html#cfn-bedrock-datasource-webdatasourceconfiguration-sourceconfiguration
            '''
            result = self._values.get("source_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.WebSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "WebDataSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnDataSourcePropsMixin.WebSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"url_configuration": "urlConfiguration"},
    )
    class WebSourceConfigurationProperty:
        def __init__(
            self,
            *,
            url_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnDataSourcePropsMixin.UrlConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the URL/URLs for the web content that you want to crawl.

            You should be authorized to crawl the URLs.

            :param url_configuration: The configuration of the URL/URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-websourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                web_source_configuration_property = bedrock_mixins.CfnDataSourcePropsMixin.WebSourceConfigurationProperty(
                    url_configuration=bedrock_mixins.CfnDataSourcePropsMixin.UrlConfigurationProperty(
                        seed_urls=[bedrock_mixins.CfnDataSourcePropsMixin.SeedUrlProperty(
                            url="url"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d8269d36e1ebc930c5e1c6edc333cf6757beee179476aee348cdb767ca4b983)
                check_type(argname="argument url_configuration", value=url_configuration, expected_type=type_hints["url_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if url_configuration is not None:
                self._values["url_configuration"] = url_configuration

        @builtins.property
        def url_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.UrlConfigurationProperty"]]:
            '''The configuration of the URL/URLs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-websourceconfiguration.html#cfn-bedrock-datasource-websourceconfiguration-urlconfiguration
            '''
            result = self._values.get("url_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnDataSourcePropsMixin.UrlConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "WebSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowAliasMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "concurrency_configuration": "concurrencyConfiguration",
        "description": "description",
        "flow_arn": "flowArn",
        "name": "name",
        "routing_configuration": "routingConfiguration",
        "tags": "tags",
    },
)
class CfnFlowAliasMixinProps:
    def __init__(
        self,
        *,
        concurrency_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        flow_arn: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        routing_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for CfnFlowAliasPropsMixin.

        :param concurrency_configuration: The configuration that specifies how nodes in the flow are executed concurrently.
        :param description: A description of the alias.
        :param flow_arn: The Amazon Resource Name (ARN) of the alias.
        :param name: The name of the alias.
        :param routing_configuration: A list of configurations about the versions that the alias maps to. Currently, you can only specify one.
        :param tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_flow_alias_mixin_props = bedrock_mixins.CfnFlowAliasMixinProps(
                concurrency_configuration=bedrock_mixins.CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty(
                    max_concurrency=123,
                    type="type"
                ),
                description="description",
                flow_arn="flowArn",
                name="name",
                routing_configuration=[bedrock_mixins.CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty(
                    flow_version="flowVersion"
                )],
                tags={
                    "tags_key": "tags"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__391de06c81eabdc3a81aac5d6f0b63b3c9ac97eaba2971e95554f0558f153199)
            check_type(argname="argument concurrency_configuration", value=concurrency_configuration, expected_type=type_hints["concurrency_configuration"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument flow_arn", value=flow_arn, expected_type=type_hints["flow_arn"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument routing_configuration", value=routing_configuration, expected_type=type_hints["routing_configuration"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if concurrency_configuration is not None:
            self._values["concurrency_configuration"] = concurrency_configuration
        if description is not None:
            self._values["description"] = description
        if flow_arn is not None:
            self._values["flow_arn"] = flow_arn
        if name is not None:
            self._values["name"] = name
        if routing_configuration is not None:
            self._values["routing_configuration"] = routing_configuration
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def concurrency_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty"]]:
        '''The configuration that specifies how nodes in the flow are executed concurrently.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html#cfn-bedrock-flowalias-concurrencyconfiguration
        '''
        result = self._values.get("concurrency_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the alias.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html#cfn-bedrock-flowalias-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def flow_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the alias.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html#cfn-bedrock-flowalias-flowarn
        '''
        result = self._values.get("flow_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the alias.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html#cfn-bedrock-flowalias-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def routing_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty"]]]]:
        '''A list of configurations about the versions that the alias maps to.

        Currently, you can only specify one.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html#cfn-bedrock-flowalias-routingconfiguration
        '''
        result = self._values.get("routing_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty"]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html#cfn-bedrock-flowalias-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnFlowAliasMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnFlowAliasPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowAliasPropsMixin",
):
    '''Creates an alias of a flow for deployment.

    For more information, see `Deploy a flow in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-deploy.html>`_ in the Amazon Bedrock User Guide.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowalias.html
    :cloudformationResource: AWS::Bedrock::FlowAlias
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_flow_alias_props_mixin = bedrock_mixins.CfnFlowAliasPropsMixin(bedrock_mixins.CfnFlowAliasMixinProps(
            concurrency_configuration=bedrock_mixins.CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty(
                max_concurrency=123,
                type="type"
            ),
            description="description",
            flow_arn="flowArn",
            name="name",
            routing_configuration=[bedrock_mixins.CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty(
                flow_version="flowVersion"
            )],
            tags={
                "tags_key": "tags"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnFlowAliasMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::FlowAlias``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4e13cea232527c0004ef3c19e49e655b3cd044d9e06fc6e0bd7f683311750ae)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cac2f2cc00ab8700c161c1328e77ca535bc42acfd03ce3a1faea191bc61194f3)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb6962ac3497352e3f289e46ca55a28ca8892b394e7257b62a3b36bfedf1635e)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnFlowAliasMixinProps":
        return typing.cast("CfnFlowAliasMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"max_concurrency": "maxConcurrency", "type": "type"},
    )
    class FlowAliasConcurrencyConfigurationProperty:
        def __init__(
            self,
            *,
            max_concurrency: typing.Optional[jsii.Number] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Determines how multiple nodes in a flow can run in parallel.

            Running nodes concurrently can improve your flow's performance.

            :param max_concurrency: The maximum number of nodes that can be executed concurrently in the flow.
            :param type: The type of concurrency to use for parallel node execution. Specify one of the following options:. - ``Automatic`` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies. - ``Manual`` - You specify which nodes can be executed in parallel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowalias-flowaliasconcurrencyconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_alias_concurrency_configuration_property = bedrock_mixins.CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty(
                    max_concurrency=123,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__366aaf82b68a6a1d82d393ff6099329d0185a1e15c2afcf02dad94483b5bbf47)
                check_type(argname="argument max_concurrency", value=max_concurrency, expected_type=type_hints["max_concurrency"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_concurrency is not None:
                self._values["max_concurrency"] = max_concurrency
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def max_concurrency(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of nodes that can be executed concurrently in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowalias-flowaliasconcurrencyconfiguration.html#cfn-bedrock-flowalias-flowaliasconcurrencyconfiguration-maxconcurrency
            '''
            result = self._values.get("max_concurrency")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of concurrency to use for parallel node execution. Specify one of the following options:.

            - ``Automatic`` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies.
            - ``Manual`` - You specify which nodes can be executed in parallel.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowalias-flowaliasconcurrencyconfiguration.html#cfn-bedrock-flowalias-flowaliasconcurrencyconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowAliasConcurrencyConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty",
        jsii_struct_bases=[],
        name_mapping={"flow_version": "flowVersion"},
    )
    class FlowAliasRoutingConfigurationListItemProperty:
        def __init__(
            self,
            *,
            flow_version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains information about a version that the alias maps to.

            :param flow_version: The version that the alias maps to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowalias-flowaliasroutingconfigurationlistitem.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_alias_routing_configuration_list_item_property = bedrock_mixins.CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty(
                    flow_version="flowVersion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f4325757fed72a8dfa4e327e08871c698eafdeab6317e913abd225fca7cfde42)
                check_type(argname="argument flow_version", value=flow_version, expected_type=type_hints["flow_version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if flow_version is not None:
                self._values["flow_version"] = flow_version

        @builtins.property
        def flow_version(self) -> typing.Optional[builtins.str]:
            '''The version that the alias maps to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowalias-flowaliasroutingconfigurationlistitem.html#cfn-bedrock-flowalias-flowaliasroutingconfigurationlistitem-flowversion
            '''
            result = self._values.get("flow_version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowAliasRoutingConfigurationListItemProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class CfnFlowApplicationLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowApplicationLogs",
):
    '''Builder for CfnFlowLogsMixin to generate APPLICATION_LOGS for CfnFlow.

    :cloudformationResource: AWS::Bedrock::Flow
    :logType: APPLICATION_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_flow_application_logs = bedrock_mixins.CfnFlowApplicationLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnFlowLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92e2f7922247e05a55ea9a42e1889ded0a39dd38c9c3753c4a3b77290c1bb590)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnFlowLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnFlowLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe42b35b9ec7605d9fad663ff452fee53127be1ea43b231d91cf7b7013487a4d)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnFlowLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnFlowLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79ff47630f881e24eef083d24bf8e13e70a1f0fe7fb506dc8f49361c6b1d1736)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnFlowLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.implements(_IMixin_11e4b965)
class CfnFlowLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowLogsMixin",
):
    '''Creates a prompt flow that you can use to send an input through various steps to yield an output.

    You define a flow by configuring nodes, each of which corresponds to a step of the flow, and creating connections between the nodes to create paths to different outputs. You can define the flow in one of the following ways:

    - Define a `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ in the ``Definition`` property.
    - Provide the definition in the ``DefinitionString`` property as a JSON-formatted string matching the `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ property.
    - Provide an Amazon S3 location in the ``DefinitionS3Location`` property that matches the `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ .

    If you use the ``DefinitionString`` or ``DefinitionS3Location`` property, you can use the ``DefinitionSubstitutions`` property to define key-value pairs to replace at runtime.

    For more information, see `How it works <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html>`_ and `Create a prompt flow in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-create.html>`_ in the Amazon Bedrock User Guide.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html
    :cloudformationResource: AWS::Bedrock::Flow
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_flow_logs_mixin = bedrock_mixins.CfnFlowLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::Bedrock::Flow``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff618fe0139ad6c1716c844736c0be0c15f70ad6018add372e052dae207ce6be)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89d4c8719a67d215a7ada3b1b40131ef220fb6be5650e60370f4bcc602a52f7e)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8bfad6fb9b31dbf5489e6ef3ac0d070d963086c9b98a192470032697b53cba9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_LOGS")
    def APPLICATION_LOGS(cls) -> "CfnFlowApplicationLogs":
        return typing.cast("CfnFlowApplicationLogs", jsii.sget(cls, "APPLICATION_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "customer_encryption_key_arn": "customerEncryptionKeyArn",
        "definition": "definition",
        "definition_s3_location": "definitionS3Location",
        "definition_string": "definitionString",
        "definition_substitutions": "definitionSubstitutions",
        "description": "description",
        "execution_role_arn": "executionRoleArn",
        "name": "name",
        "tags": "tags",
        "test_alias_tags": "testAliasTags",
    },
)
class CfnFlowMixinProps:
    def __init__(
        self,
        *,
        customer_encryption_key_arn: typing.Optional[builtins.str] = None,
        definition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowDefinitionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        definition_s3_location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.S3LocationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        definition_string: typing.Optional[builtins.str] = None,
        definition_substitutions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]]] = None,
        description: typing.Optional[builtins.str] = None,
        execution_role_arn: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        test_alias_tags: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]] = None,
    ) -> None:
        '''Properties for CfnFlowPropsMixin.

        :param customer_encryption_key_arn: The Amazon Resource Name (ARN) of the KMS key that the flow is encrypted with.
        :param definition: The definition of the nodes and connections between the nodes in the flow.
        :param definition_s3_location: The Amazon S3 location of the flow definition.
        :param definition_string: The definition of the flow as a JSON-formatted string. The string must match the format in `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ .
        :param definition_substitutions: A map that specifies the mappings for placeholder variables in the prompt flow definition. This enables the customer to inject values obtained at runtime. Variables can be template parameter names, resource logical IDs, resource attributes, or a variable in a key-value map. Only supported with the ``DefinitionString`` and ``DefinitionS3Location`` fields. Substitutions must follow the syntax: ``${key_name}`` or ``${variable_1,variable_2,...}`` .
        :param description: A description of the flow.
        :param execution_role_arn: The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see `Create a service row for flows <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html>`_ in the Amazon Bedrock User Guide.
        :param name: The name of the flow.
        :param tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_
        :param test_alias_tags: A map of tag keys and values.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            # additional_model_request_fields: Any
            # collector: Any
            # flow_definition_property_: bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty
            # input: Any
            # iterator: Any
            # loop_input: Any
            # output: Any
            
            cfn_flow_mixin_props = bedrock_mixins.CfnFlowMixinProps(
                customer_encryption_key_arn="customerEncryptionKeyArn",
                definition=bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty(
                    connections=[bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                        configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                            conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                condition="condition"
                            ),
                            data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                                source_output="sourceOutput",
                                target_input="targetInput"
                            )
                        ),
                        name="name",
                        source="source",
                        target="target",
                        type="type"
                    )],
                    nodes=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty(
                        configuration=bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty(
                            agent=bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                                agent_alias_arn="agentAliasArn"
                            ),
                            collector=collector,
                            condition=bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                                conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                    expression="expression",
                                    name="name"
                                )]
                            ),
                            inline_code=bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                                code="code",
                                language="language"
                            ),
                            input=input,
                            iterator=iterator,
                            knowledge_base=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                                guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                    guardrail_identifier="guardrailIdentifier",
                                    guardrail_version="guardrailVersion"
                                ),
                                inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                knowledge_base_id="knowledgeBaseId",
                                model_id="modelId",
                                number_of_results=123,
                                orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                    additional_model_request_fields=additional_model_request_fields,
                                    inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                                        latency="latency"
                                    ),
                                    prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                        text_prompt_template="textPromptTemplate"
                                    )
                                ),
                                prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                    text_prompt_template="textPromptTemplate"
                                ),
                                reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                                    bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                        metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                            selection_mode="selectionMode",
                                            selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                                fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                    field_name="fieldName"
                                                )],
                                                fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                    field_name="fieldName"
                                                )]
                                            )
                                        ),
                                        model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                            additional_model_request_fields=additional_model_request_fields,
                                            model_arn="modelArn"
                                        ),
                                        number_of_reranked_results=123
                                    ),
                                    type="type"
                                )
                            ),
                            lambda_function=bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                                lambda_arn="lambdaArn"
                            ),
                            lex=bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                                bot_alias_arn="botAliasArn",
                                locale_id="localeId"
                            ),
                            loop=bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty(
                                definition=flow_definition_property_
                            ),
                            loop_controller=bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                                continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                    expression="expression",
                                    name="name"
                                ),
                                max_iterations=123
                            ),
                            loop_input=loop_input,
                            output=output,
                            prompt=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                                guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                    guardrail_identifier="guardrailIdentifier",
                                    guardrail_version="guardrailVersion"
                                ),
                                source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                    inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                        inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                                max_tokens=123,
                                                stop_sequences=["stopSequences"],
                                                temperature=123,
                                                top_p=123
                                            )
                                        ),
                                        model_id="modelId",
                                        template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                                input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                                    name="name"
                                                )],
                                                text="text"
                                            )
                                        ),
                                        template_type="templateType"
                                    ),
                                    resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                        prompt_arn="promptArn"
                                    )
                                )
                            ),
                            retrieval=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                                service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                    s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                        bucket_name="bucketName"
                                    )
                                )
                            ),
                            storage=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                                service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                    s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                        bucket_name="bucketName"
                                    )
                                )
                            )
                        ),
                        inputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                            category="category",
                            expression="expression",
                            name="name",
                            type="type"
                        )],
                        name="name",
                        outputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                            name="name",
                            type="type"
                        )],
                        type="type"
                    )]
                ),
                definition_s3_location=bedrock_mixins.CfnFlowPropsMixin.S3LocationProperty(
                    bucket="bucket",
                    key="key",
                    version="version"
                ),
                definition_string="definitionString",
                definition_substitutions={
                    "definition_substitutions_key": "definitionSubstitutions"
                },
                description="description",
                execution_role_arn="executionRoleArn",
                name="name",
                tags={
                    "tags_key": "tags"
                },
                test_alias_tags={
                    "test_alias_tags_key": "testAliasTags"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12cc753c0d5e3d67ae9827031f4e3aeb6f5f7c3efd6e46573db9ad713bf3d0bf)
            check_type(argname="argument customer_encryption_key_arn", value=customer_encryption_key_arn, expected_type=type_hints["customer_encryption_key_arn"])
            check_type(argname="argument definition", value=definition, expected_type=type_hints["definition"])
            check_type(argname="argument definition_s3_location", value=definition_s3_location, expected_type=type_hints["definition_s3_location"])
            check_type(argname="argument definition_string", value=definition_string, expected_type=type_hints["definition_string"])
            check_type(argname="argument definition_substitutions", value=definition_substitutions, expected_type=type_hints["definition_substitutions"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument execution_role_arn", value=execution_role_arn, expected_type=type_hints["execution_role_arn"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument test_alias_tags", value=test_alias_tags, expected_type=type_hints["test_alias_tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if customer_encryption_key_arn is not None:
            self._values["customer_encryption_key_arn"] = customer_encryption_key_arn
        if definition is not None:
            self._values["definition"] = definition
        if definition_s3_location is not None:
            self._values["definition_s3_location"] = definition_s3_location
        if definition_string is not None:
            self._values["definition_string"] = definition_string
        if definition_substitutions is not None:
            self._values["definition_substitutions"] = definition_substitutions
        if description is not None:
            self._values["description"] = description
        if execution_role_arn is not None:
            self._values["execution_role_arn"] = execution_role_arn
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if test_alias_tags is not None:
            self._values["test_alias_tags"] = test_alias_tags

    @builtins.property
    def customer_encryption_key_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the KMS key that the flow is encrypted with.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-customerencryptionkeyarn
        '''
        result = self._values.get("customer_encryption_key_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def definition(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowDefinitionProperty"]]:
        '''The definition of the nodes and connections between the nodes in the flow.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-definition
        '''
        result = self._values.get("definition")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowDefinitionProperty"]], result)

    @builtins.property
    def definition_s3_location(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.S3LocationProperty"]]:
        '''The Amazon S3 location of the flow definition.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-definitions3location
        '''
        result = self._values.get("definition_s3_location")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.S3LocationProperty"]], result)

    @builtins.property
    def definition_string(self) -> typing.Optional[builtins.str]:
        '''The definition of the flow as a JSON-formatted string.

        The string must match the format in `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-definitionstring
        '''
        result = self._values.get("definition_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def definition_substitutions(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]]]:
        '''A map that specifies the mappings for placeholder variables in the prompt flow definition.

        This enables the customer to inject values obtained at runtime. Variables can be template parameter names, resource logical IDs, resource attributes, or a variable in a key-value map. Only supported with the ``DefinitionString`` and ``DefinitionS3Location`` fields.

        Substitutions must follow the syntax: ``${key_name}`` or ``${variable_1,variable_2,...}`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-definitionsubstitutions
        '''
        result = self._values.get("definition_substitutions")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the flow.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def execution_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the service role with permissions to create a flow.

        For more information, see `Create a service row for flows <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html>`_ in the Amazon Bedrock User Guide.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-executionrolearn
        '''
        result = self._values.get("execution_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the flow.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def test_alias_tags(
        self,
    ) -> typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]]:
        '''A map of tag keys and values.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html#cfn-bedrock-flow-testaliastags
        '''
        result = self._values.get("test_alias_tags")
        return typing.cast(typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], "_aws_cdk_ceddda9d.IResolvable"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnFlowMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnFlowPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin",
):
    '''Creates a prompt flow that you can use to send an input through various steps to yield an output.

    You define a flow by configuring nodes, each of which corresponds to a step of the flow, and creating connections between the nodes to create paths to different outputs. You can define the flow in one of the following ways:

    - Define a `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ in the ``Definition`` property.
    - Provide the definition in the ``DefinitionString`` property as a JSON-formatted string matching the `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ property.
    - Provide an Amazon S3 location in the ``DefinitionS3Location`` property that matches the `FlowDefinition <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html>`_ .

    If you use the ``DefinitionString`` or ``DefinitionS3Location`` property, you can use the ``DefinitionSubstitutions`` property to define key-value pairs to replace at runtime.

    For more information, see `How it works <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html>`_ and `Create a prompt flow in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-create.html>`_ in the Amazon Bedrock User Guide.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flow.html
    :cloudformationResource: AWS::Bedrock::Flow
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # additional_model_request_fields: Any
        # collector: Any
        # flow_definition_property_: bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty
        # input: Any
        # iterator: Any
        # loop_input: Any
        # output: Any
        
        cfn_flow_props_mixin = bedrock_mixins.CfnFlowPropsMixin(bedrock_mixins.CfnFlowMixinProps(
            customer_encryption_key_arn="customerEncryptionKeyArn",
            definition=bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty(
                connections=[bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                    configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                        conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                            condition="condition"
                        ),
                        data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                            source_output="sourceOutput",
                            target_input="targetInput"
                        )
                    ),
                    name="name",
                    source="source",
                    target="target",
                    type="type"
                )],
                nodes=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty(
                    configuration=bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty(
                        agent=bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                            agent_alias_arn="agentAliasArn"
                        ),
                        collector=collector,
                        condition=bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                            conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                expression="expression",
                                name="name"
                            )]
                        ),
                        inline_code=bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                            code="code",
                            language="language"
                        ),
                        input=input,
                        iterator=iterator,
                        knowledge_base=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                            guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                guardrail_identifier="guardrailIdentifier",
                                guardrail_version="guardrailVersion"
                            ),
                            inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            knowledge_base_id="knowledgeBaseId",
                            model_id="modelId",
                            number_of_results=123,
                            orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                additional_model_request_fields=additional_model_request_fields,
                                inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                                    latency="latency"
                                ),
                                prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                    text_prompt_template="textPromptTemplate"
                                )
                            ),
                            prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                text_prompt_template="textPromptTemplate"
                            ),
                            reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                                bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                    metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                        selection_mode="selectionMode",
                                        selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                            fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                field_name="fieldName"
                                            )],
                                            fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                field_name="fieldName"
                                            )]
                                        )
                                    ),
                                    model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                        additional_model_request_fields=additional_model_request_fields,
                                        model_arn="modelArn"
                                    ),
                                    number_of_reranked_results=123
                                ),
                                type="type"
                            )
                        ),
                        lambda_function=bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                            lambda_arn="lambdaArn"
                        ),
                        lex=bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                            bot_alias_arn="botAliasArn",
                            locale_id="localeId"
                        ),
                        loop=bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty(
                            definition=flow_definition_property_
                        ),
                        loop_controller=bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                            continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                expression="expression",
                                name="name"
                            ),
                            max_iterations=123
                        ),
                        loop_input=loop_input,
                        output=output,
                        prompt=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                            guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                guardrail_identifier="guardrailIdentifier",
                                guardrail_version="guardrailVersion"
                            ),
                            source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                    inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    model_id="modelId",
                                    template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                            input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                                name="name"
                                            )],
                                            text="text"
                                        )
                                    ),
                                    template_type="templateType"
                                ),
                                resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                    prompt_arn="promptArn"
                                )
                            )
                        ),
                        retrieval=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                            service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                    bucket_name="bucketName"
                                )
                            )
                        ),
                        storage=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                            service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                    bucket_name="bucketName"
                                )
                            )
                        )
                    ),
                    inputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                        category="category",
                        expression="expression",
                        name="name",
                        type="type"
                    )],
                    name="name",
                    outputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                        name="name",
                        type="type"
                    )],
                    type="type"
                )]
            ),
            definition_s3_location=bedrock_mixins.CfnFlowPropsMixin.S3LocationProperty(
                bucket="bucket",
                key="key",
                version="version"
            ),
            definition_string="definitionString",
            definition_substitutions={
                "definition_substitutions_key": "definitionSubstitutions"
            },
            description="description",
            execution_role_arn="executionRoleArn",
            name="name",
            tags={
                "tags_key": "tags"
            },
            test_alias_tags={
                "test_alias_tags_key": "testAliasTags"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnFlowMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::Flow``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de2b10de78baad85fe62766f62b64bc9aaf7e75a41ddfb06e22c07c391ee5c7b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7472ae15594b12b58fc69972087385ba779a6ec421c9d6d71ddf90fb0d3c25be)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8afba9adfa4e8ceb6d91169178de0dfcf4181aac424c5fa3a693157f02161ad)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnFlowMixinProps":
        return typing.cast("CfnFlowMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"agent_alias_arn": "agentAliasArn"},
    )
    class AgentFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            agent_alias_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines an agent node in your flow.

            You specify the agent to invoke at this point in the flow. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param agent_alias_arn: The Amazon Resource Name (ARN) of the alias of the agent to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-agentflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                    agent_alias_arn="agentAliasArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bbee76cff8790b31881f39c812aebea00a455dcd9a545eb6bf0e0468fea23a5e)
                check_type(argname="argument agent_alias_arn", value=agent_alias_arn, expected_type=type_hints["agent_alias_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent_alias_arn is not None:
                self._values["agent_alias_arn"] = agent_alias_arn

        @builtins.property
        def agent_alias_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the alias of the agent to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-agentflownodeconfiguration.html#cfn-bedrock-flow-agentflownodeconfiguration-agentaliasarn
            '''
            result = self._values.get("agent_alias_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"conditions": "conditions"},
    )
    class ConditionFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            conditions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowConditionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Defines a condition node in your flow.

            You can specify conditions that determine which node comes next in the flow. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param conditions: An array of conditions. Each member contains the name of a condition and an expression that defines the condition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-conditionflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                condition_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                    conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                        expression="expression",
                        name="name"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fa13ebcd3a4b5ff4031794774916cceec999dc4d4ef884daf2ac5840405dca7b)
                check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if conditions is not None:
                self._values["conditions"] = conditions

        @builtins.property
        def conditions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConditionProperty"]]]]:
            '''An array of conditions.

            Each member contains the name of a condition and an expression that defines the condition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-conditionflownodeconfiguration.html#cfn-bedrock-flow-conditionflownodeconfiguration-conditions
            '''
            result = self._values.get("conditions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConditionProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConditionFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FieldForRerankingProperty",
        jsii_struct_bases=[],
        name_mapping={"field_name": "fieldName"},
    )
    class FieldForRerankingProperty:
        def __init__(self, *, field_name: typing.Optional[builtins.str] = None) -> None:
            '''Specifies a field to be used during the reranking process in a Knowledge Base vector search.

            This structure identifies metadata fields that should be considered when reordering search results to improve relevance.

            :param field_name: The name of the metadata field to be used during the reranking process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-fieldforreranking.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                field_for_reranking_property = bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                    field_name="fieldName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6c9ebc2eb39b205f881b1aea522e442760b6a8aa3ff8895fb2badf4b0f42e772)
                check_type(argname="argument field_name", value=field_name, expected_type=type_hints["field_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if field_name is not None:
                self._values["field_name"] = field_name

        @builtins.property
        def field_name(self) -> typing.Optional[builtins.str]:
            '''The name of the metadata field to be used during the reranking process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-fieldforreranking.html#cfn-bedrock-flow-fieldforreranking-fieldname
            '''
            result = self._values.get("field_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FieldForRerankingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowConditionProperty",
        jsii_struct_bases=[],
        name_mapping={"expression": "expression", "name": "name"},
    )
    class FlowConditionProperty:
        def __init__(
            self,
            *,
            expression: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines a condition in the condition node.

            :param expression: Defines the condition. You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in `Node types in prompt flows <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html#flows-nodes>`_ .
            :param name: A name for the condition that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowcondition.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_condition_property = bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                    expression="expression",
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9b930cb94b2698f0e19adee4bbbe0ca516b8fd207962ba7863da996a05190bd3)
                check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if expression is not None:
                self._values["expression"] = expression
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def expression(self) -> typing.Optional[builtins.str]:
            '''Defines the condition.

            You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in `Node types in prompt flows <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html#flows-nodes>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowcondition.html#cfn-bedrock-flow-flowcondition-expression
            '''
            result = self._values.get("expression")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the condition that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowcondition.html#cfn-bedrock-flow-flowcondition-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConditionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"condition": "condition"},
    )
    class FlowConditionalConnectionConfigurationProperty:
        def __init__(self, *, condition: typing.Optional[builtins.str] = None) -> None:
            '''The configuration of a connection between a condition node and another node.

            :param condition: The condition that triggers this connection. For more information about how to write conditions, see the *Condition* node type in the `Node types <https://docs.aws.amazon.com/bedrock/latest/userguide/node-types.html>`_ topic in the Amazon Bedrock User Guide.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconditionalconnectionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_conditional_connection_configuration_property = bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                    condition="condition"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bb6ca06d5aa2cb08aaad2c923c0beaa8667f0afc7cd444bde5cfccc2253d4f76)
                check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if condition is not None:
                self._values["condition"] = condition

        @builtins.property
        def condition(self) -> typing.Optional[builtins.str]:
            '''The condition that triggers this connection.

            For more information about how to write conditions, see the *Condition* node type in the `Node types <https://docs.aws.amazon.com/bedrock/latest/userguide/node-types.html>`_ topic in the Amazon Bedrock User Guide.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconditionalconnectionconfiguration.html#cfn-bedrock-flow-flowconditionalconnectionconfiguration-condition
            '''
            result = self._values.get("condition")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConditionalConnectionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"conditional": "conditional", "data": "data"},
    )
    class FlowConnectionConfigurationProperty:
        def __init__(
            self,
            *,
            conditional: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            data: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the connection.

            :param conditional: The configuration of a connection originating from a Condition node.
            :param data: The configuration of a connection originating from a node that isn't a Condition node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnectionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_connection_configuration_property = bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                    conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                        condition="condition"
                    ),
                    data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                        source_output="sourceOutput",
                        target_input="targetInput"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0eabdbb1acbd33a80548b8e16d7dc97acb6b3ead5c8e14df58ebdc54f970aadc)
                check_type(argname="argument conditional", value=conditional, expected_type=type_hints["conditional"])
                check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if conditional is not None:
                self._values["conditional"] = conditional
            if data is not None:
                self._values["data"] = data

        @builtins.property
        def conditional(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty"]]:
            '''The configuration of a connection originating from a Condition node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnectionconfiguration.html#cfn-bedrock-flow-flowconnectionconfiguration-conditional
            '''
            result = self._values.get("conditional")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty"]], result)

        @builtins.property
        def data(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty"]]:
            '''The configuration of a connection originating from a node that isn't a Condition node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnectionconfiguration.html#cfn-bedrock-flow-flowconnectionconfiguration-data
            '''
            result = self._values.get("data")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConnectionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowConnectionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "configuration": "configuration",
            "name": "name",
            "source": "source",
            "target": "target",
            "type": "type",
        },
    )
    class FlowConnectionProperty:
        def __init__(
            self,
            *,
            configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowConnectionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            name: typing.Optional[builtins.str] = None,
            source: typing.Optional[builtins.str] = None,
            target: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains information about a connection between two nodes in the flow.

            :param configuration: The configuration of the connection.
            :param name: A name for the connection that you can reference.
            :param source: The node that the connection starts at.
            :param target: The node that the connection ends at.
            :param type: Whether the source node that the connection begins from is a condition node ( ``Conditional`` ) or not ( ``Data`` ).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnection.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_connection_property = bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                    configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                        conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                            condition="condition"
                        ),
                        data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                            source_output="sourceOutput",
                            target_input="targetInput"
                        )
                    ),
                    name="name",
                    source="source",
                    target="target",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__279bf15f66a729944fbf9332bf54d237410f78cf3fa7010e11be0cbde9e6fdf1)
                check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument source", value=source, expected_type=type_hints["source"])
                check_type(argname="argument target", value=target, expected_type=type_hints["target"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configuration is not None:
                self._values["configuration"] = configuration
            if name is not None:
                self._values["name"] = name
            if source is not None:
                self._values["source"] = source
            if target is not None:
                self._values["target"] = target
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConnectionConfigurationProperty"]]:
            '''The configuration of the connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnection.html#cfn-bedrock-flow-flowconnection-configuration
            '''
            result = self._values.get("configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConnectionConfigurationProperty"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the connection that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnection.html#cfn-bedrock-flow-flowconnection-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source(self) -> typing.Optional[builtins.str]:
            '''The node that the connection starts at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnection.html#cfn-bedrock-flow-flowconnection-source
            '''
            result = self._values.get("source")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target(self) -> typing.Optional[builtins.str]:
            '''The node that the connection ends at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnection.html#cfn-bedrock-flow-flowconnection-target
            '''
            result = self._values.get("target")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Whether the source node that the connection begins from is a condition node ( ``Conditional`` ) or not ( ``Data`` ).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowconnection.html#cfn-bedrock-flow-flowconnection-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConnectionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"source_output": "sourceOutput", "target_input": "targetInput"},
    )
    class FlowDataConnectionConfigurationProperty:
        def __init__(
            self,
            *,
            source_output: typing.Optional[builtins.str] = None,
            target_input: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The configuration of a connection originating from a node that isn't a Condition node.

            :param source_output: The name of the output in the source node that the connection begins from.
            :param target_input: The name of the input in the target node that the connection ends at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdataconnectionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_data_connection_configuration_property = bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                    source_output="sourceOutput",
                    target_input="targetInput"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__066e8c372b17ec7070ac5f3d2e66ff75407b98dd5426cdab52f3c79cf9bd52dd)
                check_type(argname="argument source_output", value=source_output, expected_type=type_hints["source_output"])
                check_type(argname="argument target_input", value=target_input, expected_type=type_hints["target_input"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if source_output is not None:
                self._values["source_output"] = source_output
            if target_input is not None:
                self._values["target_input"] = target_input

        @builtins.property
        def source_output(self) -> typing.Optional[builtins.str]:
            '''The name of the output in the source node that the connection begins from.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdataconnectionconfiguration.html#cfn-bedrock-flow-flowdataconnectionconfiguration-sourceoutput
            '''
            result = self._values.get("source_output")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_input(self) -> typing.Optional[builtins.str]:
            '''The name of the input in the target node that the connection ends at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdataconnectionconfiguration.html#cfn-bedrock-flow-flowdataconnectionconfiguration-targetinput
            '''
            result = self._values.get("target_input")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowDataConnectionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowDefinitionProperty",
        jsii_struct_bases=[],
        name_mapping={"connections": "connections", "nodes": "nodes"},
    )
    class FlowDefinitionProperty:
        def __init__(
            self,
            *,
            connections: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowConnectionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            nodes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowNodeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The definition of the nodes and connections between nodes in the flow.

            :param connections: An array of connection definitions in the flow.
            :param nodes: An array of node definitions in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # flow_definition_property_: bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty
                # input: Any
                # iterator: Any
                # loop_input: Any
                # output: Any
                
                flow_definition_property = bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty(
                    connections=[bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                        configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                            conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                condition="condition"
                            ),
                            data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                                source_output="sourceOutput",
                                target_input="targetInput"
                            )
                        ),
                        name="name",
                        source="source",
                        target="target",
                        type="type"
                    )],
                    nodes=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty(
                        configuration=bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty(
                            agent=bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                                agent_alias_arn="agentAliasArn"
                            ),
                            collector=collector,
                            condition=bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                                conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                    expression="expression",
                                    name="name"
                                )]
                            ),
                            inline_code=bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                                code="code",
                                language="language"
                            ),
                            input=input,
                            iterator=iterator,
                            knowledge_base=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                                guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                    guardrail_identifier="guardrailIdentifier",
                                    guardrail_version="guardrailVersion"
                                ),
                                inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                knowledge_base_id="knowledgeBaseId",
                                model_id="modelId",
                                number_of_results=123,
                                orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                    additional_model_request_fields=additional_model_request_fields,
                                    inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                                        latency="latency"
                                    ),
                                    prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                        text_prompt_template="textPromptTemplate"
                                    )
                                ),
                                prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                    text_prompt_template="textPromptTemplate"
                                ),
                                reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                                    bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                        metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                            selection_mode="selectionMode",
                                            selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                                fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                    field_name="fieldName"
                                                )],
                                                fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                    field_name="fieldName"
                                                )]
                                            )
                                        ),
                                        model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                            additional_model_request_fields=additional_model_request_fields,
                                            model_arn="modelArn"
                                        ),
                                        number_of_reranked_results=123
                                    ),
                                    type="type"
                                )
                            ),
                            lambda_function=bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                                lambda_arn="lambdaArn"
                            ),
                            lex=bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                                bot_alias_arn="botAliasArn",
                                locale_id="localeId"
                            ),
                            loop=bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty(
                                definition=flow_definition_property_
                            ),
                            loop_controller=bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                                continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                    expression="expression",
                                    name="name"
                                ),
                                max_iterations=123
                            ),
                            loop_input=loop_input,
                            output=output,
                            prompt=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                                guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                    guardrail_identifier="guardrailIdentifier",
                                    guardrail_version="guardrailVersion"
                                ),
                                source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                    inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                        inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                                max_tokens=123,
                                                stop_sequences=["stopSequences"],
                                                temperature=123,
                                                top_p=123
                                            )
                                        ),
                                        model_id="modelId",
                                        template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                                input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                                    name="name"
                                                )],
                                                text="text"
                                            )
                                        ),
                                        template_type="templateType"
                                    ),
                                    resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                        prompt_arn="promptArn"
                                    )
                                )
                            ),
                            retrieval=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                                service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                    s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                        bucket_name="bucketName"
                                    )
                                )
                            ),
                            storage=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                                service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                    s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                        bucket_name="bucketName"
                                    )
                                )
                            )
                        ),
                        inputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                            category="category",
                            expression="expression",
                            name="name",
                            type="type"
                        )],
                        name="name",
                        outputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                            name="name",
                            type="type"
                        )],
                        type="type"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5d12e974e8c40a48a0c3fc84065b3ead9be51f64fe1c43976210c1b770a09959)
                check_type(argname="argument connections", value=connections, expected_type=type_hints["connections"])
                check_type(argname="argument nodes", value=nodes, expected_type=type_hints["nodes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if connections is not None:
                self._values["connections"] = connections
            if nodes is not None:
                self._values["nodes"] = nodes

        @builtins.property
        def connections(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConnectionProperty"]]]]:
            '''An array of connection definitions in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html#cfn-bedrock-flow-flowdefinition-connections
            '''
            result = self._values.get("connections")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConnectionProperty"]]]], result)

        @builtins.property
        def nodes(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeProperty"]]]]:
            '''An array of node definitions in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowdefinition.html#cfn-bedrock-flow-flowdefinition-nodes
            '''
            result = self._values.get("nodes")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowDefinitionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "agent": "agent",
            "collector": "collector",
            "condition": "condition",
            "inline_code": "inlineCode",
            "input": "input",
            "iterator": "iterator",
            "knowledge_base": "knowledgeBase",
            "lambda_function": "lambdaFunction",
            "lex": "lex",
            "loop": "loop",
            "loop_controller": "loopController",
            "loop_input": "loopInput",
            "output": "output",
            "prompt": "prompt",
            "retrieval": "retrieval",
            "storage": "storage",
        },
    )
    class FlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            agent: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            collector: typing.Any = None,
            condition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inline_code: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            input: typing.Any = None,
            iterator: typing.Any = None,
            knowledge_base: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            lambda_function: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            lex: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.LexFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            loop: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            loop_controller: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            loop_input: typing.Any = None,
            output: typing.Any = None,
            prompt: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            retrieval: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            storage: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a node in your flow.

            For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param agent: Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response.
            :param collector: Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs.
            :param condition: Contains configurations for a condition node in your flow. Defines conditions that lead to different branches of the flow.
            :param inline_code: Contains configurations for an inline code node in your flow. Inline code nodes let you write and execute code directly within your flow, enabling data transformations, custom logic, and integrations without needing an external Lambda function.
            :param input: Contains configurations for an input flow node in your flow. The first node in the flow. ``inputs`` can't be specified for this node.
            :param iterator: Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.
            :param knowledge_base: Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response.
            :param lambda_function: Contains configurations for a Lambda function node in your flow. Invokes an AWS Lambda function.
            :param lex: Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.
            :param loop: Contains configurations for a DoWhile loop in your flow.
            :param loop_controller: Contains controller node configurations for a DoWhile loop in your flow.
            :param loop_input: Contains input node configurations for a DoWhile loop in your flow.
            :param output: Contains configurations for an output flow node in your flow. The last node in the flow. ``outputs`` can't be specified for this node.
            :param prompt: Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.
            :param retrieval: Contains configurations for a retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output.
            :param storage: Contains configurations for a storage node in your flow. Stores an input in an Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # flow_node_configuration_property_: bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty
                # input: Any
                # iterator: Any
                # loop_input: Any
                # output: Any
                
                flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty(
                    agent=bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                        agent_alias_arn="agentAliasArn"
                    ),
                    collector=collector,
                    condition=bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                        conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                            expression="expression",
                            name="name"
                        )]
                    ),
                    inline_code=bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                        code="code",
                        language="language"
                    ),
                    input=input,
                    iterator=iterator,
                    knowledge_base=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                        guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                            guardrail_identifier="guardrailIdentifier",
                            guardrail_version="guardrailVersion"
                        ),
                        inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                            text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                max_tokens=123,
                                stop_sequences=["stopSequences"],
                                temperature=123,
                                top_p=123
                            )
                        ),
                        knowledge_base_id="knowledgeBaseId",
                        model_id="modelId",
                        number_of_results=123,
                        orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                            additional_model_request_fields=additional_model_request_fields,
                            inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                                latency="latency"
                            ),
                            prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                text_prompt_template="textPromptTemplate"
                            )
                        ),
                        prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                            text_prompt_template="textPromptTemplate"
                        ),
                        reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                            bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                    selection_mode="selectionMode",
                                    selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                        fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                            field_name="fieldName"
                                        )],
                                        fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                            field_name="fieldName"
                                        )]
                                    )
                                ),
                                model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                    additional_model_request_fields=additional_model_request_fields,
                                    model_arn="modelArn"
                                ),
                                number_of_reranked_results=123
                            ),
                            type="type"
                        )
                    ),
                    lambda_function=bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                        lambda_arn="lambdaArn"
                    ),
                    lex=bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                        bot_alias_arn="botAliasArn",
                        locale_id="localeId"
                    ),
                    loop=bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty(
                        definition=bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty(
                            connections=[bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                                configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                                    conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                        condition="condition"
                                    ),
                                    data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                                        source_output="sourceOutput",
                                        target_input="targetInput"
                                    )
                                ),
                                name="name",
                                source="source",
                                target="target",
                                type="type"
                            )],
                            nodes=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty(
                                configuration=flow_node_configuration_property_,
                                inputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                                    category="category",
                                    expression="expression",
                                    name="name",
                                    type="type"
                                )],
                                name="name",
                                outputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                                    name="name",
                                    type="type"
                                )],
                                type="type"
                            )]
                        )
                    ),
                    loop_controller=bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                        continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                            expression="expression",
                            name="name"
                        ),
                        max_iterations=123
                    ),
                    loop_input=loop_input,
                    output=output,
                    prompt=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                        guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                            guardrail_identifier="guardrailIdentifier",
                            guardrail_version="guardrailVersion"
                        ),
                        source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                            inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                model_id="modelId",
                                template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                        input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                            name="name"
                                        )],
                                        text="text"
                                    )
                                ),
                                template_type="templateType"
                            ),
                            resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                prompt_arn="promptArn"
                            )
                        )
                    ),
                    retrieval=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                        service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                            s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                bucket_name="bucketName"
                            )
                        )
                    ),
                    storage=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                        service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                            s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                bucket_name="bucketName"
                            )
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7399e14b834e8a4c36e0c5967cf7801b51c567d45dd59ed7383029c90c050b77)
                check_type(argname="argument agent", value=agent, expected_type=type_hints["agent"])
                check_type(argname="argument collector", value=collector, expected_type=type_hints["collector"])
                check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
                check_type(argname="argument inline_code", value=inline_code, expected_type=type_hints["inline_code"])
                check_type(argname="argument input", value=input, expected_type=type_hints["input"])
                check_type(argname="argument iterator", value=iterator, expected_type=type_hints["iterator"])
                check_type(argname="argument knowledge_base", value=knowledge_base, expected_type=type_hints["knowledge_base"])
                check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
                check_type(argname="argument lex", value=lex, expected_type=type_hints["lex"])
                check_type(argname="argument loop", value=loop, expected_type=type_hints["loop"])
                check_type(argname="argument loop_controller", value=loop_controller, expected_type=type_hints["loop_controller"])
                check_type(argname="argument loop_input", value=loop_input, expected_type=type_hints["loop_input"])
                check_type(argname="argument output", value=output, expected_type=type_hints["output"])
                check_type(argname="argument prompt", value=prompt, expected_type=type_hints["prompt"])
                check_type(argname="argument retrieval", value=retrieval, expected_type=type_hints["retrieval"])
                check_type(argname="argument storage", value=storage, expected_type=type_hints["storage"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent is not None:
                self._values["agent"] = agent
            if collector is not None:
                self._values["collector"] = collector
            if condition is not None:
                self._values["condition"] = condition
            if inline_code is not None:
                self._values["inline_code"] = inline_code
            if input is not None:
                self._values["input"] = input
            if iterator is not None:
                self._values["iterator"] = iterator
            if knowledge_base is not None:
                self._values["knowledge_base"] = knowledge_base
            if lambda_function is not None:
                self._values["lambda_function"] = lambda_function
            if lex is not None:
                self._values["lex"] = lex
            if loop is not None:
                self._values["loop"] = loop
            if loop_controller is not None:
                self._values["loop_controller"] = loop_controller
            if loop_input is not None:
                self._values["loop_input"] = loop_input
            if output is not None:
                self._values["output"] = output
            if prompt is not None:
                self._values["prompt"] = prompt
            if retrieval is not None:
                self._values["retrieval"] = retrieval
            if storage is not None:
                self._values["storage"] = storage

        @builtins.property
        def agent(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty"]]:
            '''Contains configurations for an agent node in your flow.

            Invokes an alias of an agent and returns the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-agent
            '''
            result = self._values.get("agent")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def collector(self) -> typing.Any:
            '''Contains configurations for a collector node in your flow.

            Collects an iteration of inputs and consolidates them into an array of outputs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-collector
            '''
            result = self._values.get("collector")
            return typing.cast(typing.Any, result)

        @builtins.property
        def condition(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a condition node in your flow.

            Defines conditions that lead to different branches of the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-condition
            '''
            result = self._values.get("condition")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def inline_code(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty"]]:
            '''Contains configurations for an inline code node in your flow.

            Inline code nodes let you write and execute code directly within your flow, enabling data transformations, custom logic, and integrations without needing an external Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-inlinecode
            '''
            result = self._values.get("inline_code")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def input(self) -> typing.Any:
            '''Contains configurations for an input flow node in your flow.

            The first node in the flow. ``inputs`` can't be specified for this node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-input
            '''
            result = self._values.get("input")
            return typing.cast(typing.Any, result)

        @builtins.property
        def iterator(self) -> typing.Any:
            '''Contains configurations for an iterator node in your flow.

            Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output.

            The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-iterator
            '''
            result = self._values.get("iterator")
            return typing.cast(typing.Any, result)

        @builtins.property
        def knowledge_base(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a knowledge base node in your flow.

            Queries a knowledge base and returns the retrieved results or generated response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-knowledgebase
            '''
            result = self._values.get("knowledge_base")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def lambda_function(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a Lambda function node in your flow.

            Invokes an AWS Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-lambdafunction
            '''
            result = self._values.get("lambda_function")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def lex(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LexFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a Lex node in your flow.

            Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-lex
            '''
            result = self._values.get("lex")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LexFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def loop(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a DoWhile loop in your flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-loop
            '''
            result = self._values.get("loop")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def loop_controller(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty"]]:
            '''Contains controller node configurations for a DoWhile loop in your flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-loopcontroller
            '''
            result = self._values.get("loop_controller")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def loop_input(self) -> typing.Any:
            '''Contains input node configurations for a DoWhile loop in your flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-loopinput
            '''
            result = self._values.get("loop_input")
            return typing.cast(typing.Any, result)

        @builtins.property
        def output(self) -> typing.Any:
            '''Contains configurations for an output flow node in your flow.

            The last node in the flow. ``outputs`` can't be specified for this node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-output
            '''
            result = self._values.get("output")
            return typing.cast(typing.Any, result)

        @builtins.property
        def prompt(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a prompt node in your flow.

            Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-prompt
            '''
            result = self._values.get("prompt")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def retrieval(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a retrieval node in your flow.

            Retrieves data from an Amazon S3 location and returns it as the output.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-retrieval
            '''
            result = self._values.get("retrieval")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def storage(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a storage node in your flow.

            Stores an input in an Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeconfiguration.html#cfn-bedrock-flow-flownodeconfiguration-storage
            '''
            result = self._values.get("storage")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowNodeInputProperty",
        jsii_struct_bases=[],
        name_mapping={
            "category": "category",
            "expression": "expression",
            "name": "name",
            "type": "type",
        },
    )
    class FlowNodeInputProperty:
        def __init__(
            self,
            *,
            category: typing.Optional[builtins.str] = None,
            expression: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an input in an Amazon Bedrock Flows node.

            :param category: Specifies how input data flows between iterations in a DoWhile loop. - ``LoopCondition`` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue. - ``ReturnValueToLoopStart`` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration. - ``ExitLoop`` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.
            :param expression: An expression that formats the input for the node. For an explanation of how to create expressions, see `Expressions in Prompt flows in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-expressions.html>`_ .
            :param name: Specifies a name for the input that you can reference.
            :param type: Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeinput.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_node_input_property = bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                    category="category",
                    expression="expression",
                    name="name",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__56076f9c1f9b221b3d8e53156287db345724de9103f9d296ed192f757e5c7777)
                check_type(argname="argument category", value=category, expected_type=type_hints["category"])
                check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if category is not None:
                self._values["category"] = category
            if expression is not None:
                self._values["expression"] = expression
            if name is not None:
                self._values["name"] = name
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def category(self) -> typing.Optional[builtins.str]:
            '''Specifies how input data flows between iterations in a DoWhile loop.

            - ``LoopCondition`` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue.
            - ``ReturnValueToLoopStart`` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration.
            - ``ExitLoop`` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeinput.html#cfn-bedrock-flow-flownodeinput-category
            '''
            result = self._values.get("category")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def expression(self) -> typing.Optional[builtins.str]:
            '''An expression that formats the input for the node.

            For an explanation of how to create expressions, see `Expressions in Prompt flows in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-expressions.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeinput.html#cfn-bedrock-flow-flownodeinput-expression
            '''
            result = self._values.get("expression")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''Specifies a name for the input that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeinput.html#cfn-bedrock-flow-flownodeinput-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Specifies the data type of the input.

            If the input doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeinput.html#cfn-bedrock-flow-flownodeinput-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeInputProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowNodeOutputProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "type": "type"},
    )
    class FlowNodeOutputProperty:
        def __init__(
            self,
            *,
            name: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an output from a node.

            :param name: A name for the output that you can reference.
            :param type: The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeoutput.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_node_output_property = bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                    name="name",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5f48ba7c598a01507071f7069c5d1f5a25dea1fdfa9da8cb6d0b6da252af8fd9)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the output that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeoutput.html#cfn-bedrock-flow-flownodeoutput-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The data type of the output.

            If the output doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownodeoutput.html#cfn-bedrock-flow-flownodeoutput-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeOutputProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowNodeProperty",
        jsii_struct_bases=[],
        name_mapping={
            "configuration": "configuration",
            "inputs": "inputs",
            "name": "name",
            "outputs": "outputs",
            "type": "type",
        },
    )
    class FlowNodeProperty:
        def __init__(
            self,
            *,
            configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inputs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowNodeInputProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            name: typing.Optional[builtins.str] = None,
            outputs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowNodeOutputProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations about a node in the flow.

            :param configuration: Contains configurations for the node.
            :param inputs: An array of objects, each of which contains information about an input into the node.
            :param name: A name for the node.
            :param outputs: A list of objects, each of which contains information about an output from the node.
            :param type: The type of node. This value must match the name of the key that you provide in the configuration you provide in the ``FlowNodeConfiguration`` field.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownode.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # flow_node_property_: bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty
                # input: Any
                # iterator: Any
                # loop_input: Any
                # output: Any
                
                flow_node_property = bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty(
                    configuration=bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty(
                        agent=bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                            agent_alias_arn="agentAliasArn"
                        ),
                        collector=collector,
                        condition=bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                            conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                expression="expression",
                                name="name"
                            )]
                        ),
                        inline_code=bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                            code="code",
                            language="language"
                        ),
                        input=input,
                        iterator=iterator,
                        knowledge_base=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                            guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                guardrail_identifier="guardrailIdentifier",
                                guardrail_version="guardrailVersion"
                            ),
                            inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            knowledge_base_id="knowledgeBaseId",
                            model_id="modelId",
                            number_of_results=123,
                            orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                additional_model_request_fields=additional_model_request_fields,
                                inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                                    latency="latency"
                                ),
                                prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                    text_prompt_template="textPromptTemplate"
                                )
                            ),
                            prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                text_prompt_template="textPromptTemplate"
                            ),
                            reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                                bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                    metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                        selection_mode="selectionMode",
                                        selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                            fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                field_name="fieldName"
                                            )],
                                            fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                field_name="fieldName"
                                            )]
                                        )
                                    ),
                                    model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                        additional_model_request_fields=additional_model_request_fields,
                                        model_arn="modelArn"
                                    ),
                                    number_of_reranked_results=123
                                ),
                                type="type"
                            )
                        ),
                        lambda_function=bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                            lambda_arn="lambdaArn"
                        ),
                        lex=bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                            bot_alias_arn="botAliasArn",
                            locale_id="localeId"
                        ),
                        loop=bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty(
                            definition=bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty(
                                connections=[bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                                    configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                                        conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                            condition="condition"
                                        ),
                                        data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                                            source_output="sourceOutput",
                                            target_input="targetInput"
                                        )
                                    ),
                                    name="name",
                                    source="source",
                                    target="target",
                                    type="type"
                                )],
                                nodes=[flow_node_property_]
                            )
                        ),
                        loop_controller=bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                            continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                expression="expression",
                                name="name"
                            ),
                            max_iterations=123
                        ),
                        loop_input=loop_input,
                        output=output,
                        prompt=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                            guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                guardrail_identifier="guardrailIdentifier",
                                guardrail_version="guardrailVersion"
                            ),
                            source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                    inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    model_id="modelId",
                                    template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                            input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                                name="name"
                                            )],
                                            text="text"
                                        )
                                    ),
                                    template_type="templateType"
                                ),
                                resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                    prompt_arn="promptArn"
                                )
                            )
                        ),
                        retrieval=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                            service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                    bucket_name="bucketName"
                                )
                            )
                        ),
                        storage=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                            service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                    bucket_name="bucketName"
                                )
                            )
                        )
                    ),
                    inputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                        category="category",
                        expression="expression",
                        name="name",
                        type="type"
                    )],
                    name="name",
                    outputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                        name="name",
                        type="type"
                    )],
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__35023d7de2bd5c2bbc8b2b947cc0a740584c31cdd77874709ef0aa29e2d7c5f1)
                check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
                check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configuration is not None:
                self._values["configuration"] = configuration
            if inputs is not None:
                self._values["inputs"] = inputs
            if name is not None:
                self._values["name"] = name
            if outputs is not None:
                self._values["outputs"] = outputs
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeConfigurationProperty"]]:
            '''Contains configurations for the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownode.html#cfn-bedrock-flow-flownode-configuration
            '''
            result = self._values.get("configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeConfigurationProperty"]], result)

        @builtins.property
        def inputs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeInputProperty"]]]]:
            '''An array of objects, each of which contains information about an input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownode.html#cfn-bedrock-flow-flownode-inputs
            '''
            result = self._values.get("inputs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeInputProperty"]]]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownode.html#cfn-bedrock-flow-flownode-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def outputs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeOutputProperty"]]]]:
            '''A list of objects, each of which contains information about an output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownode.html#cfn-bedrock-flow-flownode-outputs
            '''
            result = self._values.get("outputs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowNodeOutputProperty"]]]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of node.

            This value must match the name of the key that you provide in the configuration you provide in the ``FlowNodeConfiguration`` field.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flownode.html#cfn-bedrock-flow-flownode-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.FlowValidationProperty",
        jsii_struct_bases=[],
        name_mapping={"message": "message"},
    )
    class FlowValidationProperty:
        def __init__(self, *, message: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about validation of the flow.

            This data type is used in the following API operations:

            - `GetFlow response <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetFlow.html#API_agent_GetFlow_ResponseSyntax>`_
            - `GetFlowVersion response <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetFlowVersion.html#API_agent_GetFlowVersion_ResponseSyntax>`_

            :param message: A message describing the validation error.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowvalidation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_validation_property = bedrock_mixins.CfnFlowPropsMixin.FlowValidationProperty(
                    message="message"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4c89603a56554af95ac5bdf63f40d28c2b5856a2a70de91090f243fd22afd19f)
                check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if message is not None:
                self._values["message"] = message

        @builtins.property
        def message(self) -> typing.Optional[builtins.str]:
            '''A message describing the validation error.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-flowvalidation.html#cfn-bedrock-flow-flowvalidation-message
            '''
            result = self._values.get("message")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowValidationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_identifier": "guardrailIdentifier",
            "guardrail_version": "guardrailVersion",
        },
    )
    class GuardrailConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_identifier: typing.Optional[builtins.str] = None,
            guardrail_version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration information for a guardrail that you use with the `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ operation.

            :param guardrail_identifier: The identifier for the guardrail.
            :param guardrail_version: The version of the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-guardrailconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                guardrail_configuration_property = bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                    guardrail_identifier="guardrailIdentifier",
                    guardrail_version="guardrailVersion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__fe989a819f412291fc1aeb0ba3d2fbdebed7541915bf58e317acbf7305e2e0b7)
                check_type(argname="argument guardrail_identifier", value=guardrail_identifier, expected_type=type_hints["guardrail_identifier"])
                check_type(argname="argument guardrail_version", value=guardrail_version, expected_type=type_hints["guardrail_version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_identifier is not None:
                self._values["guardrail_identifier"] = guardrail_identifier
            if guardrail_version is not None:
                self._values["guardrail_version"] = guardrail_version

        @builtins.property
        def guardrail_identifier(self) -> typing.Optional[builtins.str]:
            '''The identifier for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-guardrailconfiguration.html#cfn-bedrock-flow-guardrailconfiguration-guardrailidentifier
            '''
            result = self._values.get("guardrail_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def guardrail_version(self) -> typing.Optional[builtins.str]:
            '''The version of the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-guardrailconfiguration.html#cfn-bedrock-flow-guardrailconfiguration-guardrailversion
            '''
            result = self._values.get("guardrail_version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "GuardrailConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"code": "code", "language": "language"},
    )
    class InlineCodeFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            code: typing.Optional[builtins.str] = None,
            language: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an inline code node in your flow.

            Inline code nodes let you write and execute code directly within your flow, enabling data transformations, custom logic, and integrations without needing an external Lambda function.

            :param code: The code that's executed in your inline code node. The code can access input data from previous nodes in the flow, perform operations on that data, and produce output that can be used by other nodes in your flow. The code must be valid in the programming ``language`` that you specify.
            :param language: The programming language used by your inline code node. The code must be valid in the programming ``language`` that you specify. Currently, only Python 3 ( ``Python_3`` ) is supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-inlinecodeflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                inline_code_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                    code="code",
                    language="language"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5c3e09c6d239d75df87082f024c6e349694af9b3c18c16cbbe9ac509d89de08c)
                check_type(argname="argument code", value=code, expected_type=type_hints["code"])
                check_type(argname="argument language", value=language, expected_type=type_hints["language"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if code is not None:
                self._values["code"] = code
            if language is not None:
                self._values["language"] = language

        @builtins.property
        def code(self) -> typing.Optional[builtins.str]:
            '''The code that's executed in your inline code node.

            The code can access input data from previous nodes in the flow, perform operations on that data, and produce output that can be used by other nodes in your flow.

            The code must be valid in the programming ``language`` that you specify.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-inlinecodeflownodeconfiguration.html#cfn-bedrock-flow-inlinecodeflownodeconfiguration-code
            '''
            result = self._values.get("code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def language(self) -> typing.Optional[builtins.str]:
            '''The programming language used by your inline code node.

            The code must be valid in the programming ``language`` that you specify. Currently, only Python 3 ( ``Python_3`` ) is supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-inlinecodeflownodeconfiguration.html#cfn-bedrock-flow-inlinecodeflownodeconfiguration-language
            '''
            result = self._values.get("language")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InlineCodeFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_configuration": "guardrailConfiguration",
            "inference_configuration": "inferenceConfiguration",
            "knowledge_base_id": "knowledgeBaseId",
            "model_id": "modelId",
            "number_of_results": "numberOfResults",
            "orchestration_configuration": "orchestrationConfiguration",
            "prompt_template": "promptTemplate",
            "reranking_configuration": "rerankingConfiguration",
        },
    )
    class KnowledgeBaseFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.GuardrailConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            knowledge_base_id: typing.Optional[builtins.str] = None,
            model_id: typing.Optional[builtins.str] = None,
            number_of_results: typing.Optional[jsii.Number] = None,
            orchestration_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            prompt_template: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            reranking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a knowledge base node in a flow.

            This node takes a query as the input and returns, as the output, the retrieved responses directly (as an array) or a response generated based on the retrieved responses. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param guardrail_configuration: Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration.
            :param inference_configuration: Contains inference configurations for the prompt.
            :param knowledge_base_id: The unique identifier of the knowledge base to query.
            :param model_id: The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.
            :param number_of_results: The number of results to retrieve from the knowledge base.
            :param orchestration_configuration: The configuration for orchestrating the retrieval and generation process in the knowledge base node.
            :param prompt_template: A custom prompt template to use with the knowledge base for generating responses.
            :param reranking_configuration: The configuration for reranking the retrieved results from the knowledge base to improve relevance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                knowledge_base_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                    guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                        guardrail_identifier="guardrailIdentifier",
                        guardrail_version="guardrailVersion"
                    ),
                    inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    knowledge_base_id="knowledgeBaseId",
                    model_id="modelId",
                    number_of_results=123,
                    orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                        additional_model_request_fields=additional_model_request_fields,
                        inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                            text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                max_tokens=123,
                                stop_sequences=["stopSequences"],
                                temperature=123,
                                top_p=123
                            )
                        ),
                        performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                            latency="latency"
                        ),
                        prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                            text_prompt_template="textPromptTemplate"
                        )
                    ),
                    prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                        text_prompt_template="textPromptTemplate"
                    ),
                    reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                        bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                            metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                selection_mode="selectionMode",
                                selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                    fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                        field_name="fieldName"
                                    )],
                                    fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                        field_name="fieldName"
                                    )]
                                )
                            ),
                            model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                additional_model_request_fields=additional_model_request_fields,
                                model_arn="modelArn"
                            ),
                            number_of_reranked_results=123
                        ),
                        type="type"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d9d0ce4063d86ba2ccd6005c753169cca3e1f1da71933b641639a06df49035a)
                check_type(argname="argument guardrail_configuration", value=guardrail_configuration, expected_type=type_hints["guardrail_configuration"])
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument knowledge_base_id", value=knowledge_base_id, expected_type=type_hints["knowledge_base_id"])
                check_type(argname="argument model_id", value=model_id, expected_type=type_hints["model_id"])
                check_type(argname="argument number_of_results", value=number_of_results, expected_type=type_hints["number_of_results"])
                check_type(argname="argument orchestration_configuration", value=orchestration_configuration, expected_type=type_hints["orchestration_configuration"])
                check_type(argname="argument prompt_template", value=prompt_template, expected_type=type_hints["prompt_template"])
                check_type(argname="argument reranking_configuration", value=reranking_configuration, expected_type=type_hints["reranking_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_configuration is not None:
                self._values["guardrail_configuration"] = guardrail_configuration
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if knowledge_base_id is not None:
                self._values["knowledge_base_id"] = knowledge_base_id
            if model_id is not None:
                self._values["model_id"] = model_id
            if number_of_results is not None:
                self._values["number_of_results"] = number_of_results
            if orchestration_configuration is not None:
                self._values["orchestration_configuration"] = orchestration_configuration
            if prompt_template is not None:
                self._values["prompt_template"] = prompt_template
            if reranking_configuration is not None:
                self._values["reranking_configuration"] = reranking_configuration

        @builtins.property
        def guardrail_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.GuardrailConfigurationProperty"]]:
            '''Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-guardrailconfiguration
            '''
            result = self._values.get("guardrail_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.GuardrailConfigurationProperty"]], result)

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def knowledge_base_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the knowledge base to query.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-knowledgebaseid
            '''
            result = self._values.get("knowledge_base_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def model_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-modelid
            '''
            result = self._values.get("model_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def number_of_results(self) -> typing.Optional[jsii.Number]:
            '''The number of results to retrieve from the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-numberofresults
            '''
            result = self._values.get("number_of_results")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def orchestration_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty"]]:
            '''The configuration for orchestrating the retrieval and generation process in the knowledge base node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-orchestrationconfiguration
            '''
            result = self._values.get("orchestration_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty"]], result)

        @builtins.property
        def prompt_template(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty"]]:
            '''A custom prompt template to use with the knowledge base for generating responses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-prompttemplate
            '''
            result = self._values.get("prompt_template")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty"]], result)

        @builtins.property
        def reranking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty"]]:
            '''The configuration for reranking the retrieved results from the knowledge base to improve relevance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flow-knowledgebaseflownodeconfiguration-rerankingconfiguration
            '''
            result = self._values.get("reranking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBaseFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "inference_config": "inferenceConfig",
            "performance_config": "performanceConfig",
            "prompt_template": "promptTemplate",
        },
    )
    class KnowledgeBaseOrchestrationConfigurationProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            inference_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            performance_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PerformanceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            prompt_template: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configures how the knowledge base orchestrates the retrieval and generation process, allowing for customization of prompts, inference parameters, and performance settings.

            :param additional_model_request_fields: The additional model-specific request parameters as key-value pairs to be included in the request to the foundation model.
            :param inference_config: Contains inference configurations for the prompt.
            :param performance_config: The performance configuration options for the knowledge base retrieval and generation process.
            :param prompt_template: A custom prompt template for orchestrating the retrieval and generation process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseorchestrationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                knowledge_base_orchestration_configuration_property = bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                        latency="latency"
                    ),
                    prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                        text_prompt_template="textPromptTemplate"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__723cadb376bb39b3a950cbe36823c816c479e57748614d01683ea7f4dcd29455)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument inference_config", value=inference_config, expected_type=type_hints["inference_config"])
                check_type(argname="argument performance_config", value=performance_config, expected_type=type_hints["performance_config"])
                check_type(argname="argument prompt_template", value=prompt_template, expected_type=type_hints["prompt_template"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if inference_config is not None:
                self._values["inference_config"] = inference_config
            if performance_config is not None:
                self._values["performance_config"] = performance_config
            if prompt_template is not None:
                self._values["prompt_template"] = prompt_template

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''The additional model-specific request parameters as key-value pairs to be included in the request to the foundation model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flow-knowledgebaseorchestrationconfiguration-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def inference_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flow-knowledgebaseorchestrationconfiguration-inferenceconfig
            '''
            result = self._values.get("inference_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def performance_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PerformanceConfigurationProperty"]]:
            '''The performance configuration options for the knowledge base retrieval and generation process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flow-knowledgebaseorchestrationconfiguration-performanceconfig
            '''
            result = self._values.get("performance_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PerformanceConfigurationProperty"]], result)

        @builtins.property
        def prompt_template(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty"]]:
            '''A custom prompt template for orchestrating the retrieval and generation process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flow-knowledgebaseorchestrationconfiguration-prompttemplate
            '''
            result = self._values.get("prompt_template")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBaseOrchestrationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty",
        jsii_struct_bases=[],
        name_mapping={"text_prompt_template": "textPromptTemplate"},
    )
    class KnowledgeBasePromptTemplateProperty:
        def __init__(
            self,
            *,
            text_prompt_template: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines a custom prompt template for orchestrating the retrieval and generation process.

            :param text_prompt_template: The text of the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseprompttemplate.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                knowledge_base_prompt_template_property = bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                    text_prompt_template="textPromptTemplate"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6a2def3f57ebd4a6e3555c77078a5453f4088ec37b962d86cf73659a649f252e)
                check_type(argname="argument text_prompt_template", value=text_prompt_template, expected_type=type_hints["text_prompt_template"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text_prompt_template is not None:
                self._values["text_prompt_template"] = text_prompt_template

        @builtins.property
        def text_prompt_template(self) -> typing.Optional[builtins.str]:
            '''The text of the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-knowledgebaseprompttemplate.html#cfn-bedrock-flow-knowledgebaseprompttemplate-textprompttemplate
            '''
            result = self._values.get("text_prompt_template")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBasePromptTemplateProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"lambda_arn": "lambdaArn"},
    )
    class LambdaFunctionFlowNodeConfigurationProperty:
        def __init__(self, *, lambda_arn: typing.Optional[builtins.str] = None) -> None:
            '''Contains configurations for a Lambda function node in the flow.

            You specify the Lambda function to invoke and the inputs into the function. The output is the response that is defined in the Lambda function. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param lambda_arn: The Amazon Resource Name (ARN) of the Lambda function to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-lambdafunctionflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                lambda_function_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                    lambda_arn="lambdaArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0b6a4641415d945b605ed750dcff40d7cac2c3ed5f36b6daf4929f3487f6ce22)
                check_type(argname="argument lambda_arn", value=lambda_arn, expected_type=type_hints["lambda_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if lambda_arn is not None:
                self._values["lambda_arn"] = lambda_arn

        @builtins.property
        def lambda_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Lambda function to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-lambdafunctionflownodeconfiguration.html#cfn-bedrock-flow-lambdafunctionflownodeconfiguration-lambdaarn
            '''
            result = self._values.get("lambda_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LambdaFunctionFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"bot_alias_arn": "botAliasArn", "locale_id": "localeId"},
    )
    class LexFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            bot_alias_arn: typing.Optional[builtins.str] = None,
            locale_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a Lex node in the flow.

            You specify a Amazon Lex bot to invoke. This node takes an utterance as the input and returns as the output the intent identified by the Amazon Lex bot. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param bot_alias_arn: The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
            :param locale_id: The Region to invoke the Amazon Lex bot in.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-lexflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                lex_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                    bot_alias_arn="botAliasArn",
                    locale_id="localeId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__41d04f0ceab1f87bd5dfaec65c91e96e606faabd580314ff71cfe60171e9f754)
                check_type(argname="argument bot_alias_arn", value=bot_alias_arn, expected_type=type_hints["bot_alias_arn"])
                check_type(argname="argument locale_id", value=locale_id, expected_type=type_hints["locale_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bot_alias_arn is not None:
                self._values["bot_alias_arn"] = bot_alias_arn
            if locale_id is not None:
                self._values["locale_id"] = locale_id

        @builtins.property
        def bot_alias_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-lexflownodeconfiguration.html#cfn-bedrock-flow-lexflownodeconfiguration-botaliasarn
            '''
            result = self._values.get("bot_alias_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def locale_id(self) -> typing.Optional[builtins.str]:
            '''The Region to invoke the Amazon Lex bot in.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-lexflownodeconfiguration.html#cfn-bedrock-flow-lexflownodeconfiguration-localeid
            '''
            result = self._values.get("locale_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LexFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "continue_condition": "continueCondition",
            "max_iterations": "maxIterations",
        },
    )
    class LoopControllerFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            continue_condition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowConditionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            max_iterations: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Contains configurations for the controller node of a DoWhile loop in the flow.

            :param continue_condition: Specifies the condition that determines when the flow exits the DoWhile loop. The loop executes until this condition evaluates to true.
            :param max_iterations: Specifies the maximum number of times the DoWhile loop can iterate before the flow exits the loop. Default: - 10

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-loopcontrollerflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                loop_controller_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                    continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                        expression="expression",
                        name="name"
                    ),
                    max_iterations=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5d3fa3dd2184579e14ed904a879ff21baf6f0816612cebd9c41bfeecf760c2f9)
                check_type(argname="argument continue_condition", value=continue_condition, expected_type=type_hints["continue_condition"])
                check_type(argname="argument max_iterations", value=max_iterations, expected_type=type_hints["max_iterations"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if continue_condition is not None:
                self._values["continue_condition"] = continue_condition
            if max_iterations is not None:
                self._values["max_iterations"] = max_iterations

        @builtins.property
        def continue_condition(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConditionProperty"]]:
            '''Specifies the condition that determines when the flow exits the DoWhile loop.

            The loop executes until this condition evaluates to true.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-loopcontrollerflownodeconfiguration.html#cfn-bedrock-flow-loopcontrollerflownodeconfiguration-continuecondition
            '''
            result = self._values.get("continue_condition")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowConditionProperty"]], result)

        @builtins.property
        def max_iterations(self) -> typing.Optional[jsii.Number]:
            '''Specifies the maximum number of times the DoWhile loop can iterate before the flow exits the loop.

            :default: - 10

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-loopcontrollerflownodeconfiguration.html#cfn-bedrock-flow-loopcontrollerflownodeconfiguration-maxiterations
            '''
            result = self._values.get("max_iterations")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoopControllerFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"definition": "definition"},
    )
    class LoopFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            definition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FlowDefinitionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for the nodes of a DoWhile loop in your flow.

            A DoWhile loop is made up of the following nodes:

            - ``Loop`` - The container node that holds the loop's flow definition. This node encompasses the entire loop structure.
            - ``LoopInput`` - The entry point node for the loop. This node receives inputs from nodes outside the loop and from previous loop iterations.
            - Body nodes - The processing nodes that execute within each loop iteration. These can be nodes for handling data in your flow, such as a prompt or Lambda function nodes. Some node types aren't supported inside a DoWhile loop body. For more information, see `LoopIncompatibleNodeTypeFlowValidationDetails <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_LoopIncompatibleNodeTypeFlowValidationDetails.html>`_ .
            - ``LoopController`` - The node that evaluates whether the loop should continue or exit based on a condition.

            These nodes work together to create a loop that runs at least once and continues until a specified condition is met or a maximum number of iterations is reached.

            :param definition: The definition of the DoWhile loop nodes and connections between nodes in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-loopflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # input: Any
                # iterator: Any
                # loop_flow_node_configuration_property_: bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty
                # loop_input: Any
                # output: Any
                
                loop_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty(
                    definition=bedrock_mixins.CfnFlowPropsMixin.FlowDefinitionProperty(
                        connections=[bedrock_mixins.CfnFlowPropsMixin.FlowConnectionProperty(
                            configuration=bedrock_mixins.CfnFlowPropsMixin.FlowConnectionConfigurationProperty(
                                conditional=bedrock_mixins.CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                    condition="condition"
                                ),
                                data=bedrock_mixins.CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty(
                                    source_output="sourceOutput",
                                    target_input="targetInput"
                                )
                            ),
                            name="name",
                            source="source",
                            target="target",
                            type="type"
                        )],
                        nodes=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeProperty(
                            configuration=bedrock_mixins.CfnFlowPropsMixin.FlowNodeConfigurationProperty(
                                agent=bedrock_mixins.CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty(
                                    agent_alias_arn="agentAliasArn"
                                ),
                                collector=collector,
                                condition=bedrock_mixins.CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty(
                                    conditions=[bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                        expression="expression",
                                        name="name"
                                    )]
                                ),
                                inline_code=bedrock_mixins.CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                                    code="code",
                                    language="language"
                                ),
                                input=input,
                                iterator=iterator,
                                knowledge_base=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                                    guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                        guardrail_identifier="guardrailIdentifier",
                                        guardrail_version="guardrailVersion"
                                    ),
                                    inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    knowledge_base_id="knowledgeBaseId",
                                    model_id="modelId",
                                    number_of_results=123,
                                    orchestration_configuration=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                        additional_model_request_fields=additional_model_request_fields,
                                        inference_config=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                                max_tokens=123,
                                                stop_sequences=["stopSequences"],
                                                temperature=123,
                                                top_p=123
                                            )
                                        ),
                                        performance_config=bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                                            latency="latency"
                                        ),
                                        prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                            text_prompt_template="textPromptTemplate"
                                        )
                                    ),
                                    prompt_template=bedrock_mixins.CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty(
                                        text_prompt_template="textPromptTemplate"
                                    ),
                                    reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                                        bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                            metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                                                selection_mode="selectionMode",
                                                selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                                    fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                        field_name="fieldName"
                                                    )],
                                                    fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                                        field_name="fieldName"
                                                    )]
                                                )
                                            ),
                                            model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                                additional_model_request_fields=additional_model_request_fields,
                                                model_arn="modelArn"
                                            ),
                                            number_of_reranked_results=123
                                        ),
                                        type="type"
                                    )
                                ),
                                lambda_function=bedrock_mixins.CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                                    lambda_arn="lambdaArn"
                                ),
                                lex=bedrock_mixins.CfnFlowPropsMixin.LexFlowNodeConfigurationProperty(
                                    bot_alias_arn="botAliasArn",
                                    locale_id="localeId"
                                ),
                                loop=loop_flow_node_configuration_property_,
                                loop_controller=bedrock_mixins.CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                                    continue_condition=bedrock_mixins.CfnFlowPropsMixin.FlowConditionProperty(
                                        expression="expression",
                                        name="name"
                                    ),
                                    max_iterations=123
                                ),
                                loop_input=loop_input,
                                output=output,
                                prompt=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                                    guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                                        guardrail_identifier="guardrailIdentifier",
                                        guardrail_version="guardrailVersion"
                                    ),
                                    source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                        inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                            inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                                text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                                    max_tokens=123,
                                                    stop_sequences=["stopSequences"],
                                                    temperature=123,
                                                    top_p=123
                                                )
                                            ),
                                            model_id="modelId",
                                            template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                                text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                                    input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                                        name="name"
                                                    )],
                                                    text="text"
                                                )
                                            ),
                                            template_type="templateType"
                                        ),
                                        resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                            prompt_arn="promptArn"
                                        )
                                    )
                                ),
                                retrieval=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                                    service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                        s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                            bucket_name="bucketName"
                                        )
                                    )
                                ),
                                storage=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                                    service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                        s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                            bucket_name="bucketName"
                                        )
                                    )
                                )
                            ),
                            inputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeInputProperty(
                                category="category",
                                expression="expression",
                                name="name",
                                type="type"
                            )],
                            name="name",
                            outputs=[bedrock_mixins.CfnFlowPropsMixin.FlowNodeOutputProperty(
                                name="name",
                                type="type"
                            )],
                            type="type"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7bfb0667ab10ff11236b1036b6a716557e03696abe0308430fd7df73a54e9c48)
                check_type(argname="argument definition", value=definition, expected_type=type_hints["definition"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if definition is not None:
                self._values["definition"] = definition

        @builtins.property
        def definition(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowDefinitionProperty"]]:
            '''The definition of the DoWhile loop nodes and connections between nodes in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-loopflownodeconfiguration.html#cfn-bedrock-flow-loopflownodeconfiguration-definition
            '''
            result = self._values.get("definition")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FlowDefinitionProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoopFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "selection_mode": "selectionMode",
            "selective_mode_configuration": "selectiveModeConfiguration",
        },
    )
    class MetadataConfigurationForRerankingProperty:
        def __init__(
            self,
            *,
            selection_mode: typing.Optional[builtins.str] = None,
            selective_mode_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configuration for how metadata should be used during the reranking process in Knowledge Base vector searches.

            This determines which metadata fields are included or excluded when reordering search results.

            :param selection_mode: The mode for selecting which metadata fields to include in the reranking process. Valid values are ALL (use all available metadata fields) or SELECTIVE (use only specified fields).
            :param selective_mode_configuration: Configuration for selective mode, which allows you to explicitly include or exclude specific metadata fields during reranking. This is only used when selectionMode is set to SELECTIVE.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-metadataconfigurationforreranking.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                metadata_configuration_for_reranking_property = bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                    selection_mode="selectionMode",
                    selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                        fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                            field_name="fieldName"
                        )],
                        fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                            field_name="fieldName"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__613b2906f9c599b4406f8adec67470c43c81b6807f89312dac200eb562d015c6)
                check_type(argname="argument selection_mode", value=selection_mode, expected_type=type_hints["selection_mode"])
                check_type(argname="argument selective_mode_configuration", value=selective_mode_configuration, expected_type=type_hints["selective_mode_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if selection_mode is not None:
                self._values["selection_mode"] = selection_mode
            if selective_mode_configuration is not None:
                self._values["selective_mode_configuration"] = selective_mode_configuration

        @builtins.property
        def selection_mode(self) -> typing.Optional[builtins.str]:
            '''The mode for selecting which metadata fields to include in the reranking process.

            Valid values are ALL (use all available metadata fields) or SELECTIVE (use only specified fields).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-metadataconfigurationforreranking.html#cfn-bedrock-flow-metadataconfigurationforreranking-selectionmode
            '''
            result = self._values.get("selection_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def selective_mode_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty"]]:
            '''Configuration for selective mode, which allows you to explicitly include or exclude specific metadata fields during reranking.

            This is only used when selectionMode is set to SELECTIVE.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-metadataconfigurationforreranking.html#cfn-bedrock-flow-metadataconfigurationforreranking-selectivemodeconfiguration
            '''
            result = self._values.get("selective_mode_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetadataConfigurationForRerankingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"latency": "latency"},
    )
    class PerformanceConfigurationProperty:
        def __init__(self, *, latency: typing.Optional[builtins.str] = None) -> None:
            '''Performance settings for a model.

            :param latency: To use a latency-optimized version of the model, set to ``optimized`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-performanceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                performance_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PerformanceConfigurationProperty(
                    latency="latency"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__01c43e988662fcd2c975b5a7fa8d12f507dd09c5506344073986157fb40198c7)
                check_type(argname="argument latency", value=latency, expected_type=type_hints["latency"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if latency is not None:
                self._values["latency"] = latency

        @builtins.property
        def latency(self) -> typing.Optional[builtins.str]:
            '''To use a latency-optimized version of the model, set to ``optimized`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-performanceconfiguration.html#cfn-bedrock-flow-performanceconfiguration-latency
            '''
            result = self._values.get("latency")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PerformanceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_configuration": "guardrailConfiguration",
            "source_configuration": "sourceConfiguration",
        },
    )
    class PromptFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.GuardrailConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a prompt node in the flow.

            You can use a prompt from Prompt management or you can define one in this node. If the prompt contains variables, the inputs into this node will fill in the variables. The output from this node is the response generated by the model. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param guardrail_configuration: Contains configurations for a guardrail to apply to the prompt in this node and the response generated from it.
            :param source_configuration: Specifies whether the prompt is from Prompt management or defined inline.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty(
                    guardrail_configuration=bedrock_mixins.CfnFlowPropsMixin.GuardrailConfigurationProperty(
                        guardrail_identifier="guardrailIdentifier",
                        guardrail_version="guardrailVersion"
                    ),
                    source_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                        inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                            inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            model_id="modelId",
                            template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                                text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                    input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                        name="name"
                                    )],
                                    text="text"
                                )
                            ),
                            template_type="templateType"
                        ),
                        resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                            prompt_arn="promptArn"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__be8340a576f8475bc671d3ec91c05e357737f2cb442a5695ab5cea807b2b8ee2)
                check_type(argname="argument guardrail_configuration", value=guardrail_configuration, expected_type=type_hints["guardrail_configuration"])
                check_type(argname="argument source_configuration", value=source_configuration, expected_type=type_hints["source_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_configuration is not None:
                self._values["guardrail_configuration"] = guardrail_configuration
            if source_configuration is not None:
                self._values["source_configuration"] = source_configuration

        @builtins.property
        def guardrail_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.GuardrailConfigurationProperty"]]:
            '''Contains configurations for a guardrail to apply to the prompt in this node and the response generated from it.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeconfiguration.html#cfn-bedrock-flow-promptflownodeconfiguration-guardrailconfiguration
            '''
            result = self._values.get("guardrail_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.GuardrailConfigurationProperty"]], result)

        @builtins.property
        def source_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty"]]:
            '''Specifies whether the prompt is from Prompt management or defined inline.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeconfiguration.html#cfn-bedrock-flow-promptflownodeconfiguration-sourceconfiguration
            '''
            result = self._values.get("source_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "inference_configuration": "inferenceConfiguration",
            "model_id": "modelId",
            "template_configuration": "templateConfiguration",
            "template_type": "templateType",
        },
    )
    class PromptFlowNodeInlineConfigurationProperty:
        def __init__(
            self,
            *,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            model_id: typing.Optional[builtins.str] = None,
            template_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            template_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a prompt defined inline in the node.

            :param inference_configuration: Contains inference configurations for the prompt.
            :param model_id: The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to run inference with.
            :param template_configuration: Contains a prompt and variables in the prompt that can be replaced with values at runtime.
            :param template_type: The type of prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeinlineconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_inline_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                    inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    model_id="modelId",
                    template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                        text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                            input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            text="text"
                        )
                    ),
                    template_type="templateType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d2f1c39627d14e00f9257ccacf844e73e35f5de77b9e1c22e2ba4bbb032d8f33)
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument model_id", value=model_id, expected_type=type_hints["model_id"])
                check_type(argname="argument template_configuration", value=template_configuration, expected_type=type_hints["template_configuration"])
                check_type(argname="argument template_type", value=template_type, expected_type=type_hints["template_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if model_id is not None:
                self._values["model_id"] = model_id
            if template_configuration is not None:
                self._values["template_configuration"] = template_configuration
            if template_type is not None:
                self._values["template_type"] = template_type

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeinlineconfiguration.html#cfn-bedrock-flow-promptflownodeinlineconfiguration-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def model_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to run inference with.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeinlineconfiguration.html#cfn-bedrock-flow-promptflownodeinlineconfiguration-modelid
            '''
            result = self._values.get("model_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def template_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptTemplateConfigurationProperty"]]:
            '''Contains a prompt and variables in the prompt that can be replaced with values at runtime.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeinlineconfiguration.html#cfn-bedrock-flow-promptflownodeinlineconfiguration-templateconfiguration
            '''
            result = self._values.get("template_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptTemplateConfigurationProperty"]], result)

        @builtins.property
        def template_type(self) -> typing.Optional[builtins.str]:
            '''The type of prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodeinlineconfiguration.html#cfn-bedrock-flow-promptflownodeinlineconfiguration-templatetype
            '''
            result = self._values.get("template_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeInlineConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"prompt_arn": "promptArn"},
    )
    class PromptFlowNodeResourceConfigurationProperty:
        def __init__(self, *, prompt_arn: typing.Optional[builtins.str] = None) -> None:
            '''Contains configurations for a prompt from Prompt management to use in a node.

            :param prompt_arn: The Amazon Resource Name (ARN) of the prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownoderesourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_resource_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                    prompt_arn="promptArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a16553f33601f74e6b26d00994fb6d201e98fcbef8f71e7f5d8a0e327ae33086)
                check_type(argname="argument prompt_arn", value=prompt_arn, expected_type=type_hints["prompt_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if prompt_arn is not None:
                self._values["prompt_arn"] = prompt_arn

        @builtins.property
        def prompt_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownoderesourceconfiguration.html#cfn-bedrock-flow-promptflownoderesourceconfiguration-promptarn
            '''
            result = self._values.get("prompt_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeResourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"inline": "inline", "resource": "resource"},
    )
    class PromptFlowNodeSourceConfigurationProperty:
        def __init__(
            self,
            *,
            inline: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            resource: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a prompt and whether it is from Prompt management or defined inline.

            :param inline: Contains configurations for a prompt that is defined inline.
            :param resource: Contains configurations for a prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodesourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_source_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                    inline=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                        inference_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                            text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                                max_tokens=123,
                                stop_sequences=["stopSequences"],
                                temperature=123,
                                top_p=123
                            )
                        ),
                        model_id="modelId",
                        template_configuration=bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                            text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                                input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                                    name="name"
                                )],
                                text="text"
                            )
                        ),
                        template_type="templateType"
                    ),
                    resource=bedrock_mixins.CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                        prompt_arn="promptArn"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5bc9ffbb873fb3013c529666b7df1488faf5a0697578d9e1e898a52da5cdea6c)
                check_type(argname="argument inline", value=inline, expected_type=type_hints["inline"])
                check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if inline is not None:
                self._values["inline"] = inline
            if resource is not None:
                self._values["resource"] = resource

        @builtins.property
        def inline(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty"]]:
            '''Contains configurations for a prompt that is defined inline.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodesourceconfiguration.html#cfn-bedrock-flow-promptflownodesourceconfiguration-inline
            '''
            result = self._values.get("inline")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty"]], result)

        @builtins.property
        def resource(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty"]]:
            '''Contains configurations for a prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptflownodesourceconfiguration.html#cfn-bedrock-flow-promptflownodesourceconfiguration-resource
            '''
            result = self._values.get("resource")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"text": "text"},
    )
    class PromptInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains inference configurations for the prompt.

            :param text: Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_inference_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptInferenceConfigurationProperty(
                    text=bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                        max_tokens=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_p=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e3cf56fb9b529aca2802c065375b092b00e28b05e0e4300e39769b94765f095d)
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty"]]:
            '''Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptinferenceconfiguration.html#cfn-bedrock-flow-promptinferenceconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptInputVariableProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class PromptInputVariableProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about a variable in the prompt.

            :param name: The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptinputvariable.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_input_variable_property = bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4410e64061e40a72caf3f6058d613301c2e863f9bb7d3c858c071948ba710e4f)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptinputvariable.html#cfn-bedrock-flow-promptinputvariable-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInputVariableProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_tokens": "maxTokens",
            "stop_sequences": "stopSequences",
            "temperature": "temperature",
            "top_p": "topP",
        },
    )
    class PromptModelInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            max_tokens: typing.Optional[jsii.Number] = None,
            stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
            temperature: typing.Optional[jsii.Number] = None,
            top_p: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Contains inference configurations related to model inference for a prompt.

            For more information, see `Inference parameters <https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html>`_ .

            :param max_tokens: The maximum number of tokens to return in the response.
            :param stop_sequences: A list of strings that define sequences after which the model will stop generating.
            :param temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
            :param top_p: The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptmodelinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_model_inference_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty(
                    max_tokens=123,
                    stop_sequences=["stopSequences"],
                    temperature=123,
                    top_p=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3f5b8f249a133488bfbbd9e28588dd29f5b3fc732e99421c2121b4a3d2317b6b)
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
                check_type(argname="argument stop_sequences", value=stop_sequences, expected_type=type_hints["stop_sequences"])
                check_type(argname="argument temperature", value=temperature, expected_type=type_hints["temperature"])
                check_type(argname="argument top_p", value=top_p, expected_type=type_hints["top_p"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens
            if stop_sequences is not None:
                self._values["stop_sequences"] = stop_sequences
            if temperature is not None:
                self._values["temperature"] = temperature
            if top_p is not None:
                self._values["top_p"] = top_p

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens to return in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptmodelinferenceconfiguration.html#cfn-bedrock-flow-promptmodelinferenceconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def stop_sequences(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of strings that define sequences after which the model will stop generating.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptmodelinferenceconfiguration.html#cfn-bedrock-flow-promptmodelinferenceconfiguration-stopsequences
            '''
            result = self._values.get("stop_sequences")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def temperature(self) -> typing.Optional[jsii.Number]:
            '''Controls the randomness of the response.

            Choose a lower value for more predictable outputs and a higher value for more surprising outputs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptmodelinferenceconfiguration.html#cfn-bedrock-flow-promptmodelinferenceconfiguration-temperature
            '''
            result = self._values.get("temperature")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def top_p(self) -> typing.Optional[jsii.Number]:
            '''The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-promptmodelinferenceconfiguration.html#cfn-bedrock-flow-promptmodelinferenceconfiguration-topp
            '''
            result = self._values.get("top_p")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptModelInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"text": "text"},
    )
    class PromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains the message for a prompt.

            For more information, see `Construct and store reusable prompts with Prompt management in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html>`_ .

            :param text: Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-prompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_template_configuration_property = bedrock_mixins.CfnFlowPropsMixin.PromptTemplateConfigurationProperty(
                    text=bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                        input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        text="text"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cb5f7ea39ce6d0ea13aa78eba1b2a22ccf4a633604230b4bcca1cef9ec483f66)
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty"]]:
            '''Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-prompttemplateconfiguration.html#cfn-bedrock-flow-prompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "fields_to_exclude": "fieldsToExclude",
            "fields_to_include": "fieldsToInclude",
        },
    )
    class RerankingMetadataSelectiveModeConfigurationProperty:
        def __init__(
            self,
            *,
            fields_to_exclude: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FieldForRerankingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            fields_to_include: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.FieldForRerankingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Configuration for selectively including or excluding metadata fields during the reranking process.

            This allows you to control which metadata attributes are considered when reordering search results.

            :param fields_to_exclude: A list of metadata field names to explicitly exclude from the reranking process. All metadata fields except these will be considered when reordering search results. This parameter cannot be used together with fieldsToInclude.
            :param fields_to_include: A list of metadata field names to explicitly include in the reranking process. Only these fields will be considered when reordering search results. This parameter cannot be used together with fieldsToExclude.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-rerankingmetadataselectivemodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                reranking_metadata_selective_mode_configuration_property = bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                    fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                        field_name="fieldName"
                    )],
                    fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                        field_name="fieldName"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__feb455b3fc8ddbe2dd88ee0a7b69891ae171db5e08d6b677c3360b2d77bfe6d6)
                check_type(argname="argument fields_to_exclude", value=fields_to_exclude, expected_type=type_hints["fields_to_exclude"])
                check_type(argname="argument fields_to_include", value=fields_to_include, expected_type=type_hints["fields_to_include"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if fields_to_exclude is not None:
                self._values["fields_to_exclude"] = fields_to_exclude
            if fields_to_include is not None:
                self._values["fields_to_include"] = fields_to_include

        @builtins.property
        def fields_to_exclude(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FieldForRerankingProperty"]]]]:
            '''A list of metadata field names to explicitly exclude from the reranking process.

            All metadata fields except these will be considered when reordering search results. This parameter cannot be used together with fieldsToInclude.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-rerankingmetadataselectivemodeconfiguration.html#cfn-bedrock-flow-rerankingmetadataselectivemodeconfiguration-fieldstoexclude
            '''
            result = self._values.get("fields_to_exclude")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FieldForRerankingProperty"]]]], result)

        @builtins.property
        def fields_to_include(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FieldForRerankingProperty"]]]]:
            '''A list of metadata field names to explicitly include in the reranking process.

            Only these fields will be considered when reordering search results. This parameter cannot be used together with fieldsToExclude.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-rerankingmetadataselectivemodeconfiguration.html#cfn-bedrock-flow-rerankingmetadataselectivemodeconfiguration-fieldstoinclude
            '''
            result = self._values.get("fields_to_include")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.FieldForRerankingProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RerankingMetadataSelectiveModeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"service_configuration": "serviceConfiguration"},
    )
    class RetrievalFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            service_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a Retrieval node in a flow.

            This node retrieves data from the Amazon S3 location that you specify and returns it as the output.

            :param service_configuration: Contains configurations for the service to use for retrieving data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-retrievalflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                retrieval_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty(
                    service_configuration=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                        s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                            bucket_name="bucketName"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__601b223440345b1f1c05521c30d412451f2c6cd8f73a78f98ed0642fd2e6886a)
                check_type(argname="argument service_configuration", value=service_configuration, expected_type=type_hints["service_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if service_configuration is not None:
                self._values["service_configuration"] = service_configuration

        @builtins.property
        def service_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty"]]:
            '''Contains configurations for the service to use for retrieving data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-retrievalflownodeconfiguration.html#cfn-bedrock-flow-retrievalflownodeconfiguration-serviceconfiguration
            '''
            result = self._values.get("service_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetrievalFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket_name": "bucketName"},
    )
    class RetrievalFlowNodeS3ConfigurationProperty:
        def __init__(
            self,
            *,
            bucket_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.

            :param bucket_name: The name of the Amazon S3 bucket from which to retrieve data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-retrievalflownodes3configuration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                retrieval_flow_node_s3_configuration_property = bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                    bucket_name="bucketName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__053d02324f2ad0676ac3eadc1226ff78e53eaaf81d6e625aba4615bd85e56b7c)
                check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_name is not None:
                self._values["bucket_name"] = bucket_name

        @builtins.property
        def bucket_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Amazon S3 bucket from which to retrieve data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-retrievalflownodes3configuration.html#cfn-bedrock-flow-retrievalflownodes3configuration-bucketname
            '''
            result = self._values.get("bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetrievalFlowNodeS3ConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"s3": "s3"},
    )
    class RetrievalFlowNodeServiceConfigurationProperty:
        def __init__(
            self,
            *,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for the service to use for retrieving data to return as the output from the node.

            :param s3: Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-retrievalflownodeserviceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                retrieval_flow_node_service_configuration_property = bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                    s3=bedrock_mixins.CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                        bucket_name="bucketName"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1aa790afb568e35b0a5a0a901074af8316bce24dde0644af6a741f28b3d37f2a)
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3 is not None:
                self._values["s3"] = s3

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty"]]:
            '''Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-retrievalflownodeserviceconfiguration.html#cfn-bedrock-flow-retrievalflownodeserviceconfiguration-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetrievalFlowNodeServiceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.S3LocationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket": "bucket", "key": "key", "version": "version"},
    )
    class S3LocationProperty:
        def __init__(
            self,
            *,
            bucket: typing.Optional[builtins.str] = None,
            key: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The S3 location of the flow definition.

            :param bucket: The S3 bucket containing the flow definition.
            :param key: The object key for the S3 location containing the definition.
            :param version: The Amazon S3 location from which to retrieve data for an S3 retrieve node or to which to store data for an S3 storage node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-s3location.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                s3_location_property = bedrock_mixins.CfnFlowPropsMixin.S3LocationProperty(
                    bucket="bucket",
                    key="key",
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ac8e647502e4189f6bdf06521fe61791dd1613707f037e5983510f722626f7ea)
                check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket is not None:
                self._values["bucket"] = bucket
            if key is not None:
                self._values["key"] = key
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def bucket(self) -> typing.Optional[builtins.str]:
            '''The S3 bucket containing the flow definition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-s3location.html#cfn-bedrock-flow-s3location-bucket
            '''
            result = self._values.get("bucket")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The object key for the S3 location containing the definition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-s3location.html#cfn-bedrock-flow-s3location-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The Amazon S3 location from which to retrieve data for an S3 retrieve node or to which to store data for an S3 storage node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-s3location.html#cfn-bedrock-flow-s3location-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3LocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"service_configuration": "serviceConfiguration"},
    )
    class StorageFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            service_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a Storage node in a flow.

            This node stores the input in an Amazon S3 location that you specify.

            :param service_configuration: Contains configurations for the service to use for storing the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-storageflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_flow_node_configuration_property = bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty(
                    service_configuration=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                        s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                            bucket_name="bucketName"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2d94e9b87535bf5aaddb270262e8e286dabaf031800f68b98d8056200db376f6)
                check_type(argname="argument service_configuration", value=service_configuration, expected_type=type_hints["service_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if service_configuration is not None:
                self._values["service_configuration"] = service_configuration

        @builtins.property
        def service_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty"]]:
            '''Contains configurations for the service to use for storing the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-storageflownodeconfiguration.html#cfn-bedrock-flow-storageflownodeconfiguration-serviceconfiguration
            '''
            result = self._values.get("service_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket_name": "bucketName"},
    )
    class StorageFlowNodeS3ConfigurationProperty:
        def __init__(
            self,
            *,
            bucket_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for the Amazon S3 location in which to store the input into the node.

            :param bucket_name: The name of the Amazon S3 bucket in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-storageflownodes3configuration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_flow_node_s3_configuration_property = bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                    bucket_name="bucketName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0b6944f15c879c57dec9a3eeed6b1438e8fb40b5b28060affd92caed990e61e1)
                check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_name is not None:
                self._values["bucket_name"] = bucket_name

        @builtins.property
        def bucket_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Amazon S3 bucket in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-storageflownodes3configuration.html#cfn-bedrock-flow-storageflownodes3configuration-bucketname
            '''
            result = self._values.get("bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageFlowNodeS3ConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"s3": "s3"},
    )
    class StorageFlowNodeServiceConfigurationProperty:
        def __init__(
            self,
            *,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for the service to use for storing the input into the node.

            :param s3: Contains configurations for the Amazon S3 location in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-storageflownodeserviceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_flow_node_service_configuration_property = bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                    s3=bedrock_mixins.CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                        bucket_name="bucketName"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__88555a38426faa7a4df4752182ab756d78132ed045779f7c8fd0dd4bce8fee86)
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3 is not None:
                self._values["s3"] = s3

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty"]]:
            '''Contains configurations for the Amazon S3 location in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-storageflownodeserviceconfiguration.html#cfn-bedrock-flow-storageflownodeserviceconfiguration-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageFlowNodeServiceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"input_variables": "inputVariables", "text": "text"},
    )
    class TextPromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            input_variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.PromptInputVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a text prompt template.

            To include a variable, enclose a word in double curly braces as in ``{{variable}}`` .

            :param input_variables: An array of the variables in the prompt template.
            :param text: The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-textprompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                text_prompt_template_configuration_property = bedrock_mixins.CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty(
                    input_variables=[bedrock_mixins.CfnFlowPropsMixin.PromptInputVariableProperty(
                        name="name"
                    )],
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d5b16af49918078bb2a22791bf4d9f9c53bbe92d6c2a1f01e58dd14cdcb02c76)
                check_type(argname="argument input_variables", value=input_variables, expected_type=type_hints["input_variables"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_variables is not None:
                self._values["input_variables"] = input_variables
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def input_variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInputVariableProperty"]]]]:
            '''An array of the variables in the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-textprompttemplateconfiguration.html#cfn-bedrock-flow-textprompttemplateconfiguration-inputvariables
            '''
            result = self._values.get("input_variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.PromptInputVariableProperty"]]]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-textprompttemplateconfiguration.html#cfn-bedrock-flow-textprompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TextPromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metadata_configuration": "metadataConfiguration",
            "model_configuration": "modelConfiguration",
            "number_of_reranked_results": "numberOfRerankedResults",
        },
    )
    class VectorSearchBedrockRerankingConfigurationProperty:
        def __init__(
            self,
            *,
            metadata_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            model_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            number_of_reranked_results: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configuration for using Amazon Bedrock foundation models to rerank Knowledge Base vector search results.

            This enables more sophisticated relevance ranking using large language models.

            :param metadata_configuration: Configuration for how document metadata should be used during the reranking process. This determines which metadata fields are included when reordering search results.
            :param model_configuration: Configuration for the Amazon Bedrock foundation model used for reranking. This includes the model ARN and any additional request fields required by the model.
            :param number_of_reranked_results: The maximum number of results to rerank. This limits how many of the initial vector search results will be processed by the reranking model. A smaller number improves performance but may exclude potentially relevant results.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                vector_search_bedrock_reranking_configuration_property = bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                    metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                        selection_mode="selectionMode",
                        selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                            fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                field_name="fieldName"
                            )],
                            fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                field_name="fieldName"
                            )]
                        )
                    ),
                    model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                        additional_model_request_fields=additional_model_request_fields,
                        model_arn="modelArn"
                    ),
                    number_of_reranked_results=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c6130b8c2c89c5646bea3126e07df7333b5ccb6b159fc65eb9b483ae1d59df05)
                check_type(argname="argument metadata_configuration", value=metadata_configuration, expected_type=type_hints["metadata_configuration"])
                check_type(argname="argument model_configuration", value=model_configuration, expected_type=type_hints["model_configuration"])
                check_type(argname="argument number_of_reranked_results", value=number_of_reranked_results, expected_type=type_hints["number_of_reranked_results"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_configuration is not None:
                self._values["metadata_configuration"] = metadata_configuration
            if model_configuration is not None:
                self._values["model_configuration"] = model_configuration
            if number_of_reranked_results is not None:
                self._values["number_of_reranked_results"] = number_of_reranked_results

        @builtins.property
        def metadata_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty"]]:
            '''Configuration for how document metadata should be used during the reranking process.

            This determines which metadata fields are included when reordering search results.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingconfiguration.html#cfn-bedrock-flow-vectorsearchbedrockrerankingconfiguration-metadataconfiguration
            '''
            result = self._values.get("metadata_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty"]], result)

        @builtins.property
        def model_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty"]]:
            '''Configuration for the Amazon Bedrock foundation model used for reranking.

            This includes the model ARN and any additional request fields required by the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingconfiguration.html#cfn-bedrock-flow-vectorsearchbedrockrerankingconfiguration-modelconfiguration
            '''
            result = self._values.get("model_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty"]], result)

        @builtins.property
        def number_of_reranked_results(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of results to rerank.

            This limits how many of the initial vector search results will be processed by the reranking model. A smaller number improves performance but may exclude potentially relevant results.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingconfiguration.html#cfn-bedrock-flow-vectorsearchbedrockrerankingconfiguration-numberofrerankedresults
            '''
            result = self._values.get("number_of_reranked_results")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorSearchBedrockRerankingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "model_arn": "modelArn",
        },
    )
    class VectorSearchBedrockRerankingModelConfigurationProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            model_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration for the Amazon Bedrock foundation model used for reranking vector search results.

            This specifies which model to use and any additional parameters required by the model.

            :param additional_model_request_fields: A list of additional fields to include in the model request during reranking. These fields provide extra context or configuration options specific to the selected foundation model.
            :param model_arn: The Amazon Resource Name (ARN) of the foundation model to use for reranking. This model processes the query and search results to determine a more relevant ordering.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingmodelconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                vector_search_bedrock_reranking_model_configuration_property = bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    model_arn="modelArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2292d8fafa05c9e71c6ef15a0c560232adb59a77f827f36fcbe9a36819aa5110)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument model_arn", value=model_arn, expected_type=type_hints["model_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if model_arn is not None:
                self._values["model_arn"] = model_arn

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''A list of additional fields to include in the model request during reranking.

            These fields provide extra context or configuration options specific to the selected foundation model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingmodelconfiguration.html#cfn-bedrock-flow-vectorsearchbedrockrerankingmodelconfiguration-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def model_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the foundation model to use for reranking.

            This model processes the query and search results to determine a more relevant ordering.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchbedrockrerankingmodelconfiguration.html#cfn-bedrock-flow-vectorsearchbedrockrerankingmodelconfiguration-modelarn
            '''
            result = self._values.get("model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorSearchBedrockRerankingModelConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bedrock_reranking_configuration": "bedrockRerankingConfiguration",
            "type": "type",
        },
    )
    class VectorSearchRerankingConfigurationProperty:
        def __init__(
            self,
            *,
            bedrock_reranking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration for reranking vector search results to improve relevance.

            Reranking applies additional relevance models to reorder the initial vector search results based on more sophisticated criteria.

            :param bedrock_reranking_configuration: Configuration for using Amazon Bedrock foundation models to rerank search results. This is required when the reranking type is set to BEDROCK.
            :param type: The type of reranking to apply to vector search results. Currently, the only supported value is BEDROCK, which uses Amazon Bedrock foundation models for reranking.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchrerankingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                vector_search_reranking_configuration_property = bedrock_mixins.CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty(
                    bedrock_reranking_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                        metadata_configuration=bedrock_mixins.CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty(
                            selection_mode="selectionMode",
                            selective_mode_configuration=bedrock_mixins.CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                fields_to_exclude=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                    field_name="fieldName"
                                )],
                                fields_to_include=[bedrock_mixins.CfnFlowPropsMixin.FieldForRerankingProperty(
                                    field_name="fieldName"
                                )]
                            )
                        ),
                        model_configuration=bedrock_mixins.CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                            additional_model_request_fields=additional_model_request_fields,
                            model_arn="modelArn"
                        ),
                        number_of_reranked_results=123
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__dac11fda848e627f9f224c0cf83de18717f98a38dc21c344ddc403a419e2ca11)
                check_type(argname="argument bedrock_reranking_configuration", value=bedrock_reranking_configuration, expected_type=type_hints["bedrock_reranking_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bedrock_reranking_configuration is not None:
                self._values["bedrock_reranking_configuration"] = bedrock_reranking_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def bedrock_reranking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty"]]:
            '''Configuration for using Amazon Bedrock foundation models to rerank search results.

            This is required when the reranking type is set to BEDROCK.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchrerankingconfiguration.html#cfn-bedrock-flow-vectorsearchrerankingconfiguration-bedrockrerankingconfiguration
            '''
            result = self._values.get("bedrock_reranking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of reranking to apply to vector search results.

            Currently, the only supported value is BEDROCK, which uses Amazon Bedrock foundation models for reranking.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flow-vectorsearchrerankingconfiguration.html#cfn-bedrock-flow-vectorsearchrerankingconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorSearchRerankingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionMixinProps",
    jsii_struct_bases=[],
    name_mapping={"description": "description", "flow_arn": "flowArn"},
)
class CfnFlowVersionMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        flow_arn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnFlowVersionPropsMixin.

        :param description: The description of the flow version.
        :param flow_arn: The Amazon Resource Name (ARN) of the flow that the version belongs to.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowversion.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_flow_version_mixin_props = bedrock_mixins.CfnFlowVersionMixinProps(
                description="description",
                flow_arn="flowArn"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1e1207d57a926aa44ec047044e2ab00d3abb57d1b0db6b3bd5cebdf8979adc4)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument flow_arn", value=flow_arn, expected_type=type_hints["flow_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if flow_arn is not None:
            self._values["flow_arn"] = flow_arn

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the flow version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowversion.html#cfn-bedrock-flowversion-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def flow_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the flow that the version belongs to.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowversion.html#cfn-bedrock-flowversion-flowarn
        '''
        result = self._values.get("flow_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnFlowVersionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnFlowVersionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin",
):
    '''Creates a version of the flow that you can deploy.

    For more information, see `Deploy a flow in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-deploy.html>`_ in the Amazon Bedrock User Guide.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-flowversion.html
    :cloudformationResource: AWS::Bedrock::FlowVersion
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_flow_version_props_mixin = bedrock_mixins.CfnFlowVersionPropsMixin(bedrock_mixins.CfnFlowVersionMixinProps(
            description="description",
            flow_arn="flowArn"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnFlowVersionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::FlowVersion``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7300aca477a27a4d971474bec3124322ab2cfa0345cca140fc3adb105cd802e4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b75c8ad5114d880830a6d6526d482661f579ede55f902fe706bd1c7696257d38)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0facc298a9882b6acc06b845f147c20e8f891817dc2977330c2acd03f6c11610)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnFlowVersionMixinProps":
        return typing.cast("CfnFlowVersionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"agent_alias_arn": "agentAliasArn"},
    )
    class AgentFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            agent_alias_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines an agent node in your flow.

            You specify the agent to invoke at this point in the flow. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param agent_alias_arn: The Amazon Resource Name (ARN) of the alias of the agent to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-agentflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                agent_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty(
                    agent_alias_arn="agentAliasArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1b9daa472d0f74542cc440033d5aa927e7b2dc59de6f75e693dc8168367602bb)
                check_type(argname="argument agent_alias_arn", value=agent_alias_arn, expected_type=type_hints["agent_alias_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent_alias_arn is not None:
                self._values["agent_alias_arn"] = agent_alias_arn

        @builtins.property
        def agent_alias_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the alias of the agent to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-agentflownodeconfiguration.html#cfn-bedrock-flowversion-agentflownodeconfiguration-agentaliasarn
            '''
            result = self._values.get("agent_alias_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AgentFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"conditions": "conditions"},
    )
    class ConditionFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            conditions: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowConditionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Defines a condition node in your flow.

            You can specify conditions that determine which node comes next in the flow. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param conditions: An array of conditions. Each member contains the name of a condition and an expression that defines the condition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-conditionflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                condition_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty(
                    conditions=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                        expression="expression",
                        name="name"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a8204b1147b0f545c68eefd8412fc8022396cc4ba18dbc266f950b8a60cdf9af)
                check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if conditions is not None:
                self._values["conditions"] = conditions

        @builtins.property
        def conditions(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConditionProperty"]]]]:
            '''An array of conditions.

            Each member contains the name of a condition and an expression that defines the condition.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-conditionflownodeconfiguration.html#cfn-bedrock-flowversion-conditionflownodeconfiguration-conditions
            '''
            result = self._values.get("conditions")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConditionProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConditionFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty",
        jsii_struct_bases=[],
        name_mapping={"field_name": "fieldName"},
    )
    class FieldForRerankingProperty:
        def __init__(self, *, field_name: typing.Optional[builtins.str] = None) -> None:
            '''Specifies a field to be used during the reranking process in a Knowledge Base vector search.

            This structure identifies metadata fields that should be considered when reordering search results to improve relevance.

            :param field_name: The name of the metadata field to be used during the reranking process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-fieldforreranking.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                field_for_reranking_property = bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                    field_name="fieldName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ed8b4f6ea3b6f7b245d0fd8c31032abd0f05bfd1f41a0f6c577ba23461df04d0)
                check_type(argname="argument field_name", value=field_name, expected_type=type_hints["field_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if field_name is not None:
                self._values["field_name"] = field_name

        @builtins.property
        def field_name(self) -> typing.Optional[builtins.str]:
            '''The name of the metadata field to be used during the reranking process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-fieldforreranking.html#cfn-bedrock-flowversion-fieldforreranking-fieldname
            '''
            result = self._values.get("field_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FieldForRerankingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowConditionProperty",
        jsii_struct_bases=[],
        name_mapping={"expression": "expression", "name": "name"},
    )
    class FlowConditionProperty:
        def __init__(
            self,
            *,
            expression: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines a condition in the condition node.

            :param expression: Defines the condition. You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in `Node types in prompt flows <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html#flows-nodes>`_ .
            :param name: A name for the condition that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowcondition.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_condition_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                    expression="expression",
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ea6147f75179278dd8031bb9aa2a0775b9bb734bc18594e60756267a7e793284)
                check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if expression is not None:
                self._values["expression"] = expression
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def expression(self) -> typing.Optional[builtins.str]:
            '''Defines the condition.

            You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in `Node types in prompt flows <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html#flows-nodes>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowcondition.html#cfn-bedrock-flowversion-flowcondition-expression
            '''
            result = self._values.get("expression")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the condition that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowcondition.html#cfn-bedrock-flowversion-flowcondition-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConditionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"condition": "condition"},
    )
    class FlowConditionalConnectionConfigurationProperty:
        def __init__(self, *, condition: typing.Optional[builtins.str] = None) -> None:
            '''The configuration of a connection between a condition node and another node.

            :param condition: The condition that triggers this connection. For more information about how to write conditions, see the *Condition* node type in the `Node types <https://docs.aws.amazon.com/bedrock/latest/userguide/node-types.html>`_ topic in the Amazon Bedrock User Guide.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconditionalconnectionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_conditional_connection_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                    condition="condition"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__994c0017022960c67139dfd55dadb6507298a217ab616fa60861e159e2f45b5e)
                check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if condition is not None:
                self._values["condition"] = condition

        @builtins.property
        def condition(self) -> typing.Optional[builtins.str]:
            '''The condition that triggers this connection.

            For more information about how to write conditions, see the *Condition* node type in the `Node types <https://docs.aws.amazon.com/bedrock/latest/userguide/node-types.html>`_ topic in the Amazon Bedrock User Guide.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconditionalconnectionconfiguration.html#cfn-bedrock-flowversion-flowconditionalconnectionconfiguration-condition
            '''
            result = self._values.get("condition")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConditionalConnectionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"conditional": "conditional", "data": "data"},
    )
    class FlowConnectionConfigurationProperty:
        def __init__(
            self,
            *,
            conditional: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            data: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration of the connection.

            :param conditional: The configuration of a connection originating from a Condition node.
            :param data: The configuration of a connection originating from a node that isn't a Condition node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnectionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_connection_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty(
                    conditional=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                        condition="condition"
                    ),
                    data=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                        source_output="sourceOutput",
                        target_input="targetInput"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8d8029d5b81e8ec77cd586484642ab537d6727ab4f7f2ac447566dc35070ff50)
                check_type(argname="argument conditional", value=conditional, expected_type=type_hints["conditional"])
                check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if conditional is not None:
                self._values["conditional"] = conditional
            if data is not None:
                self._values["data"] = data

        @builtins.property
        def conditional(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty"]]:
            '''The configuration of a connection originating from a Condition node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnectionconfiguration.html#cfn-bedrock-flowversion-flowconnectionconfiguration-conditional
            '''
            result = self._values.get("conditional")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty"]], result)

        @builtins.property
        def data(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty"]]:
            '''The configuration of a connection originating from a node that isn't a Condition node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnectionconfiguration.html#cfn-bedrock-flowversion-flowconnectionconfiguration-data
            '''
            result = self._values.get("data")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConnectionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowConnectionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "configuration": "configuration",
            "name": "name",
            "source": "source",
            "target": "target",
            "type": "type",
        },
    )
    class FlowConnectionProperty:
        def __init__(
            self,
            *,
            configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            name: typing.Optional[builtins.str] = None,
            source: typing.Optional[builtins.str] = None,
            target: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains information about a connection between two nodes in the flow.

            :param configuration: The configuration of the connection.
            :param name: A name for the connection that you can reference.
            :param source: The node that the connection starts at.
            :param target: The node that the connection ends at.
            :param type: Whether the source node that the connection begins from is a condition node ( ``Conditional`` ) or not ( ``Data`` ).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnection.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_connection_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionProperty(
                    configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty(
                        conditional=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                            condition="condition"
                        ),
                        data=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                            source_output="sourceOutput",
                            target_input="targetInput"
                        )
                    ),
                    name="name",
                    source="source",
                    target="target",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__25716dce9f95cdd4d2e09860ca1fbfd108dcdae86cfb4cd0f3d370159b7e57f1)
                check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument source", value=source, expected_type=type_hints["source"])
                check_type(argname="argument target", value=target, expected_type=type_hints["target"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configuration is not None:
                self._values["configuration"] = configuration
            if name is not None:
                self._values["name"] = name
            if source is not None:
                self._values["source"] = source
            if target is not None:
                self._values["target"] = target
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty"]]:
            '''The configuration of the connection.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnection.html#cfn-bedrock-flowversion-flowconnection-configuration
            '''
            result = self._values.get("configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the connection that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnection.html#cfn-bedrock-flowversion-flowconnection-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source(self) -> typing.Optional[builtins.str]:
            '''The node that the connection starts at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnection.html#cfn-bedrock-flowversion-flowconnection-source
            '''
            result = self._values.get("source")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target(self) -> typing.Optional[builtins.str]:
            '''The node that the connection ends at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnection.html#cfn-bedrock-flowversion-flowconnection-target
            '''
            result = self._values.get("target")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Whether the source node that the connection begins from is a condition node ( ``Conditional`` ) or not ( ``Data`` ).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowconnection.html#cfn-bedrock-flowversion-flowconnection-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowConnectionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"source_output": "sourceOutput", "target_input": "targetInput"},
    )
    class FlowDataConnectionConfigurationProperty:
        def __init__(
            self,
            *,
            source_output: typing.Optional[builtins.str] = None,
            target_input: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The configuration of a connection originating from a node that isn't a Condition node.

            :param source_output: The name of the output in the source node that the connection begins from.
            :param target_input: The name of the input in the target node that the connection ends at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowdataconnectionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_data_connection_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                    source_output="sourceOutput",
                    target_input="targetInput"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bc706e2bf2dd080695260c7eb562b189736a0eefbcedaace27ff94f1de775f26)
                check_type(argname="argument source_output", value=source_output, expected_type=type_hints["source_output"])
                check_type(argname="argument target_input", value=target_input, expected_type=type_hints["target_input"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if source_output is not None:
                self._values["source_output"] = source_output
            if target_input is not None:
                self._values["target_input"] = target_input

        @builtins.property
        def source_output(self) -> typing.Optional[builtins.str]:
            '''The name of the output in the source node that the connection begins from.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowdataconnectionconfiguration.html#cfn-bedrock-flowversion-flowdataconnectionconfiguration-sourceoutput
            '''
            result = self._values.get("source_output")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_input(self) -> typing.Optional[builtins.str]:
            '''The name of the input in the target node that the connection ends at.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowdataconnectionconfiguration.html#cfn-bedrock-flowversion-flowdataconnectionconfiguration-targetinput
            '''
            result = self._values.get("target_input")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowDataConnectionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowDefinitionProperty",
        jsii_struct_bases=[],
        name_mapping={"connections": "connections", "nodes": "nodes"},
    )
    class FlowDefinitionProperty:
        def __init__(
            self,
            *,
            connections: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowConnectionProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            nodes: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowNodeProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The definition of the nodes and connections between nodes in the flow.

            :param connections: An array of connection definitions in the flow.
            :param nodes: An array of node definitions in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowdefinition.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # flow_definition_property_: bedrock_mixins.CfnFlowVersionPropsMixin.FlowDefinitionProperty
                # input: Any
                # iterator: Any
                # loop_input: Any
                # output: Any
                
                flow_definition_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowDefinitionProperty(
                    connections=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionProperty(
                        configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty(
                            conditional=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                condition="condition"
                            ),
                            data=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                                source_output="sourceOutput",
                                target_input="targetInput"
                            )
                        ),
                        name="name",
                        source="source",
                        target="target",
                        type="type"
                    )],
                    nodes=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeProperty(
                        configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty(
                            agent=bedrock_mixins.CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty(
                                agent_alias_arn="agentAliasArn"
                            ),
                            collector=collector,
                            condition=bedrock_mixins.CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty(
                                conditions=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                                    expression="expression",
                                    name="name"
                                )]
                            ),
                            inline_code=bedrock_mixins.CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                                code="code",
                                language="language"
                            ),
                            input=input,
                            iterator=iterator,
                            knowledge_base=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                                guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                                    guardrail_identifier="guardrailIdentifier",
                                    guardrail_version="guardrailVersion"
                                ),
                                inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                knowledge_base_id="knowledgeBaseId",
                                model_id="modelId",
                                number_of_results=123,
                                orchestration_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                    additional_model_request_fields=additional_model_request_fields,
                                    inference_config=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    performance_config=bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                                        latency="latency"
                                    ),
                                    prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                        text_prompt_template="textPromptTemplate"
                                    )
                                ),
                                prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                    text_prompt_template="textPromptTemplate"
                                ),
                                reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty(
                                    bedrock_reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                        metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                                            selection_mode="selectionMode",
                                            selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                                fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                                    field_name="fieldName"
                                                )],
                                                fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                                    field_name="fieldName"
                                                )]
                                            )
                                        ),
                                        model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                            additional_model_request_fields=additional_model_request_fields,
                                            model_arn="modelArn"
                                        ),
                                        number_of_reranked_results=123
                                    ),
                                    type="type"
                                )
                            ),
                            lambda_function=bedrock_mixins.CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                                lambda_arn="lambdaArn"
                            ),
                            lex=bedrock_mixins.CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty(
                                bot_alias_arn="botAliasArn",
                                locale_id="localeId"
                            ),
                            loop=bedrock_mixins.CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty(
                                definition=flow_definition_property_
                            ),
                            loop_controller=bedrock_mixins.CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                                continue_condition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                                    expression="expression",
                                    name="name"
                                ),
                                max_iterations=123
                            ),
                            loop_input=loop_input,
                            output=output,
                            prompt=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty(
                                guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                                    guardrail_identifier="guardrailIdentifier",
                                    guardrail_version="guardrailVersion"
                                ),
                                source_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                    inline=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                        inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                                max_tokens=123,
                                                stop_sequences=["stopSequences"],
                                                temperature=123,
                                                top_p=123
                                            )
                                        ),
                                        model_id="modelId",
                                        template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                                                input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                                    name="name"
                                                )],
                                                text="text"
                                            )
                                        ),
                                        template_type="templateType"
                                    ),
                                    resource=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                        prompt_arn="promptArn"
                                    )
                                )
                            ),
                            retrieval=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty(
                                service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                    s3=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                        bucket_name="bucketName"
                                    )
                                )
                            ),
                            storage=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty(
                                service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                    s3=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                        bucket_name="bucketName"
                                    )
                                )
                            )
                        ),
                        inputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeInputProperty(
                            expression="expression",
                            name="name",
                            type="type"
                        )],
                        name="name",
                        outputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeOutputProperty(
                            name="name",
                            type="type"
                        )],
                        type="type"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2a79320e0b4db4c53c5a7acf699720fca7fe2757eb1cdb0f60dfdcaf427f6005)
                check_type(argname="argument connections", value=connections, expected_type=type_hints["connections"])
                check_type(argname="argument nodes", value=nodes, expected_type=type_hints["nodes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if connections is not None:
                self._values["connections"] = connections
            if nodes is not None:
                self._values["nodes"] = nodes

        @builtins.property
        def connections(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConnectionProperty"]]]]:
            '''An array of connection definitions in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowdefinition.html#cfn-bedrock-flowversion-flowdefinition-connections
            '''
            result = self._values.get("connections")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConnectionProperty"]]]], result)

        @builtins.property
        def nodes(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeProperty"]]]]:
            '''An array of node definitions in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flowdefinition.html#cfn-bedrock-flowversion-flowdefinition-nodes
            '''
            result = self._values.get("nodes")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowDefinitionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "agent": "agent",
            "collector": "collector",
            "condition": "condition",
            "inline_code": "inlineCode",
            "input": "input",
            "iterator": "iterator",
            "knowledge_base": "knowledgeBase",
            "lambda_function": "lambdaFunction",
            "lex": "lex",
            "loop": "loop",
            "loop_controller": "loopController",
            "loop_input": "loopInput",
            "output": "output",
            "prompt": "prompt",
            "retrieval": "retrieval",
            "storage": "storage",
        },
    )
    class FlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            agent: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            collector: typing.Any = None,
            condition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inline_code: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            input: typing.Any = None,
            iterator: typing.Any = None,
            knowledge_base: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            lambda_function: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            lex: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            loop: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            loop_controller: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            loop_input: typing.Any = None,
            output: typing.Any = None,
            prompt: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            retrieval: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            storage: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a node in your flow.

            For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param agent: Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response.
            :param collector: Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs.
            :param condition: Contains configurations for a condition node in your flow. Defines conditions that lead to different branches of the flow.
            :param inline_code: Contains configurations for an inline code node in your flow. Inline code nodes let you write and execute code directly within your flow, enabling data transformations, custom logic, and integrations without needing an external Lambda function.
            :param input: Contains configurations for an input flow node in your flow. The first node in the flow. ``inputs`` can't be specified for this node.
            :param iterator: Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.
            :param knowledge_base: Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response.
            :param lambda_function: Contains configurations for a Lambda function node in your flow. Invokes an AWS Lambda function.
            :param lex: Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.
            :param loop: Contains configurations for a DoWhile loop in your flow.
            :param loop_controller: Contains controller node configurations for a DoWhile loop in your flow.
            :param loop_input: Contains input node configurations for a DoWhile loop in your flow.
            :param output: Contains configurations for an output flow node in your flow. The last node in the flow. ``outputs`` can't be specified for this node.
            :param prompt: Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.
            :param retrieval: Contains configurations for a retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output.
            :param storage: Contains configurations for a storage node in your flow. Stores an input in an Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # flow_node_configuration_property_: bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty
                # input: Any
                # iterator: Any
                # loop_input: Any
                # output: Any
                
                flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty(
                    agent=bedrock_mixins.CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty(
                        agent_alias_arn="agentAliasArn"
                    ),
                    collector=collector,
                    condition=bedrock_mixins.CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty(
                        conditions=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                            expression="expression",
                            name="name"
                        )]
                    ),
                    inline_code=bedrock_mixins.CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                        code="code",
                        language="language"
                    ),
                    input=input,
                    iterator=iterator,
                    knowledge_base=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                        guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                            guardrail_identifier="guardrailIdentifier",
                            guardrail_version="guardrailVersion"
                        ),
                        inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                            text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                max_tokens=123,
                                stop_sequences=["stopSequences"],
                                temperature=123,
                                top_p=123
                            )
                        ),
                        knowledge_base_id="knowledgeBaseId",
                        model_id="modelId",
                        number_of_results=123,
                        orchestration_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                            additional_model_request_fields=additional_model_request_fields,
                            inference_config=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            performance_config=bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                                latency="latency"
                            ),
                            prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                text_prompt_template="textPromptTemplate"
                            )
                        ),
                        prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                            text_prompt_template="textPromptTemplate"
                        ),
                        reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty(
                            bedrock_reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                                    selection_mode="selectionMode",
                                    selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                        fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                            field_name="fieldName"
                                        )],
                                        fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                            field_name="fieldName"
                                        )]
                                    )
                                ),
                                model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                    additional_model_request_fields=additional_model_request_fields,
                                    model_arn="modelArn"
                                ),
                                number_of_reranked_results=123
                            ),
                            type="type"
                        )
                    ),
                    lambda_function=bedrock_mixins.CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                        lambda_arn="lambdaArn"
                    ),
                    lex=bedrock_mixins.CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty(
                        bot_alias_arn="botAliasArn",
                        locale_id="localeId"
                    ),
                    loop=bedrock_mixins.CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty(
                        definition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDefinitionProperty(
                            connections=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionProperty(
                                configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty(
                                    conditional=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                        condition="condition"
                                    ),
                                    data=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                                        source_output="sourceOutput",
                                        target_input="targetInput"
                                    )
                                ),
                                name="name",
                                source="source",
                                target="target",
                                type="type"
                            )],
                            nodes=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeProperty(
                                configuration=flow_node_configuration_property_,
                                inputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeInputProperty(
                                    expression="expression",
                                    name="name",
                                    type="type"
                                )],
                                name="name",
                                outputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeOutputProperty(
                                    name="name",
                                    type="type"
                                )],
                                type="type"
                            )]
                        )
                    ),
                    loop_controller=bedrock_mixins.CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                        continue_condition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                            expression="expression",
                            name="name"
                        ),
                        max_iterations=123
                    ),
                    loop_input=loop_input,
                    output=output,
                    prompt=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty(
                        guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                            guardrail_identifier="guardrailIdentifier",
                            guardrail_version="guardrailVersion"
                        ),
                        source_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                            inline=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                model_id="modelId",
                                template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                                        input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                            name="name"
                                        )],
                                        text="text"
                                    )
                                ),
                                template_type="templateType"
                            ),
                            resource=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                prompt_arn="promptArn"
                            )
                        )
                    ),
                    retrieval=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty(
                        service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                            s3=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                bucket_name="bucketName"
                            )
                        )
                    ),
                    storage=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty(
                        service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                            s3=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                bucket_name="bucketName"
                            )
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2e4762d8bb9584c7523dc727bd9eaa983cdc460bd1a7d59d16779710735b2266)
                check_type(argname="argument agent", value=agent, expected_type=type_hints["agent"])
                check_type(argname="argument collector", value=collector, expected_type=type_hints["collector"])
                check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
                check_type(argname="argument inline_code", value=inline_code, expected_type=type_hints["inline_code"])
                check_type(argname="argument input", value=input, expected_type=type_hints["input"])
                check_type(argname="argument iterator", value=iterator, expected_type=type_hints["iterator"])
                check_type(argname="argument knowledge_base", value=knowledge_base, expected_type=type_hints["knowledge_base"])
                check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
                check_type(argname="argument lex", value=lex, expected_type=type_hints["lex"])
                check_type(argname="argument loop", value=loop, expected_type=type_hints["loop"])
                check_type(argname="argument loop_controller", value=loop_controller, expected_type=type_hints["loop_controller"])
                check_type(argname="argument loop_input", value=loop_input, expected_type=type_hints["loop_input"])
                check_type(argname="argument output", value=output, expected_type=type_hints["output"])
                check_type(argname="argument prompt", value=prompt, expected_type=type_hints["prompt"])
                check_type(argname="argument retrieval", value=retrieval, expected_type=type_hints["retrieval"])
                check_type(argname="argument storage", value=storage, expected_type=type_hints["storage"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent is not None:
                self._values["agent"] = agent
            if collector is not None:
                self._values["collector"] = collector
            if condition is not None:
                self._values["condition"] = condition
            if inline_code is not None:
                self._values["inline_code"] = inline_code
            if input is not None:
                self._values["input"] = input
            if iterator is not None:
                self._values["iterator"] = iterator
            if knowledge_base is not None:
                self._values["knowledge_base"] = knowledge_base
            if lambda_function is not None:
                self._values["lambda_function"] = lambda_function
            if lex is not None:
                self._values["lex"] = lex
            if loop is not None:
                self._values["loop"] = loop
            if loop_controller is not None:
                self._values["loop_controller"] = loop_controller
            if loop_input is not None:
                self._values["loop_input"] = loop_input
            if output is not None:
                self._values["output"] = output
            if prompt is not None:
                self._values["prompt"] = prompt
            if retrieval is not None:
                self._values["retrieval"] = retrieval
            if storage is not None:
                self._values["storage"] = storage

        @builtins.property
        def agent(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty"]]:
            '''Contains configurations for an agent node in your flow.

            Invokes an alias of an agent and returns the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-agent
            '''
            result = self._values.get("agent")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def collector(self) -> typing.Any:
            '''Contains configurations for a collector node in your flow.

            Collects an iteration of inputs and consolidates them into an array of outputs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-collector
            '''
            result = self._values.get("collector")
            return typing.cast(typing.Any, result)

        @builtins.property
        def condition(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a condition node in your flow.

            Defines conditions that lead to different branches of the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-condition
            '''
            result = self._values.get("condition")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def inline_code(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty"]]:
            '''Contains configurations for an inline code node in your flow.

            Inline code nodes let you write and execute code directly within your flow, enabling data transformations, custom logic, and integrations without needing an external Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-inlinecode
            '''
            result = self._values.get("inline_code")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def input(self) -> typing.Any:
            '''Contains configurations for an input flow node in your flow.

            The first node in the flow. ``inputs`` can't be specified for this node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-input
            '''
            result = self._values.get("input")
            return typing.cast(typing.Any, result)

        @builtins.property
        def iterator(self) -> typing.Any:
            '''Contains configurations for an iterator node in your flow.

            Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output.

            The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-iterator
            '''
            result = self._values.get("iterator")
            return typing.cast(typing.Any, result)

        @builtins.property
        def knowledge_base(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a knowledge base node in your flow.

            Queries a knowledge base and returns the retrieved results or generated response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-knowledgebase
            '''
            result = self._values.get("knowledge_base")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def lambda_function(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a Lambda function node in your flow.

            Invokes an AWS Lambda function.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-lambdafunction
            '''
            result = self._values.get("lambda_function")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def lex(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a Lex node in your flow.

            Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-lex
            '''
            result = self._values.get("lex")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def loop(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a DoWhile loop in your flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-loop
            '''
            result = self._values.get("loop")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def loop_controller(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty"]]:
            '''Contains controller node configurations for a DoWhile loop in your flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-loopcontroller
            '''
            result = self._values.get("loop_controller")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def loop_input(self) -> typing.Any:
            '''Contains input node configurations for a DoWhile loop in your flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-loopinput
            '''
            result = self._values.get("loop_input")
            return typing.cast(typing.Any, result)

        @builtins.property
        def output(self) -> typing.Any:
            '''Contains configurations for an output flow node in your flow.

            The last node in the flow. ``outputs`` can't be specified for this node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-output
            '''
            result = self._values.get("output")
            return typing.cast(typing.Any, result)

        @builtins.property
        def prompt(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a prompt node in your flow.

            Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-prompt
            '''
            result = self._values.get("prompt")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def retrieval(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a retrieval node in your flow.

            Retrieves data from an Amazon S3 location and returns it as the output.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-retrieval
            '''
            result = self._values.get("retrieval")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty"]], result)

        @builtins.property
        def storage(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty"]]:
            '''Contains configurations for a storage node in your flow.

            Stores an input in an Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeconfiguration.html#cfn-bedrock-flowversion-flownodeconfiguration-storage
            '''
            result = self._values.get("storage")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowNodeInputProperty",
        jsii_struct_bases=[],
        name_mapping={"expression": "expression", "name": "name", "type": "type"},
    )
    class FlowNodeInputProperty:
        def __init__(
            self,
            *,
            expression: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an input in an Amazon Bedrock Flows node.

            :param expression: An expression that formats the input for the node. For an explanation of how to create expressions, see `Expressions in Prompt flows in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-expressions.html>`_ .
            :param name: Specifies a name for the input that you can reference.
            :param type: Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeinput.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_node_input_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeInputProperty(
                    expression="expression",
                    name="name",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9ef6dd3b15d227ed262131557ad31c50128e9b70fddf2d852444190b815844c0)
                check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if expression is not None:
                self._values["expression"] = expression
            if name is not None:
                self._values["name"] = name
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def expression(self) -> typing.Optional[builtins.str]:
            '''An expression that formats the input for the node.

            For an explanation of how to create expressions, see `Expressions in Prompt flows in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-expressions.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeinput.html#cfn-bedrock-flowversion-flownodeinput-expression
            '''
            result = self._values.get("expression")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''Specifies a name for the input that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeinput.html#cfn-bedrock-flowversion-flownodeinput-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Specifies the data type of the input.

            If the input doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeinput.html#cfn-bedrock-flowversion-flownodeinput-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeInputProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowNodeOutputProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "type": "type"},
    )
    class FlowNodeOutputProperty:
        def __init__(
            self,
            *,
            name: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an output from a node.

            :param name: A name for the output that you can reference.
            :param type: The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeoutput.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                flow_node_output_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeOutputProperty(
                    name="name",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3780b9abc7a22d083c33c65e642f9c1082e2570245664a398dfc216028b24ad5)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the output that you can reference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeoutput.html#cfn-bedrock-flowversion-flownodeoutput-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The data type of the output.

            If the output doesn't match this type at runtime, a validation error will be thrown.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownodeoutput.html#cfn-bedrock-flowversion-flownodeoutput-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeOutputProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.FlowNodeProperty",
        jsii_struct_bases=[],
        name_mapping={
            "configuration": "configuration",
            "inputs": "inputs",
            "name": "name",
            "outputs": "outputs",
            "type": "type",
        },
    )
    class FlowNodeProperty:
        def __init__(
            self,
            *,
            configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inputs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowNodeInputProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            name: typing.Optional[builtins.str] = None,
            outputs: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowNodeOutputProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations about a node in the flow.

            :param configuration: Contains configurations for the node.
            :param inputs: An array of objects, each of which contains information about an input into the node.
            :param name: A name for the node.
            :param outputs: A list of objects, each of which contains information about an output from the node.
            :param type: The type of node. This value must match the name of the key that you provide in the configuration you provide in the ``FlowNodeConfiguration`` field.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownode.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # flow_node_property_: bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeProperty
                # input: Any
                # iterator: Any
                # loop_input: Any
                # output: Any
                
                flow_node_property = bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeProperty(
                    configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty(
                        agent=bedrock_mixins.CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty(
                            agent_alias_arn="agentAliasArn"
                        ),
                        collector=collector,
                        condition=bedrock_mixins.CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty(
                            conditions=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                                expression="expression",
                                name="name"
                            )]
                        ),
                        inline_code=bedrock_mixins.CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                            code="code",
                            language="language"
                        ),
                        input=input,
                        iterator=iterator,
                        knowledge_base=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                            guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                                guardrail_identifier="guardrailIdentifier",
                                guardrail_version="guardrailVersion"
                            ),
                            inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            knowledge_base_id="knowledgeBaseId",
                            model_id="modelId",
                            number_of_results=123,
                            orchestration_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                additional_model_request_fields=additional_model_request_fields,
                                inference_config=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                    text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                        max_tokens=123,
                                        stop_sequences=["stopSequences"],
                                        temperature=123,
                                        top_p=123
                                    )
                                ),
                                performance_config=bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                                    latency="latency"
                                ),
                                prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                    text_prompt_template="textPromptTemplate"
                                )
                            ),
                            prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                text_prompt_template="textPromptTemplate"
                            ),
                            reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty(
                                bedrock_reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                    metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                                        selection_mode="selectionMode",
                                        selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                            fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                                field_name="fieldName"
                                            )],
                                            fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                                field_name="fieldName"
                                            )]
                                        )
                                    ),
                                    model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                        additional_model_request_fields=additional_model_request_fields,
                                        model_arn="modelArn"
                                    ),
                                    number_of_reranked_results=123
                                ),
                                type="type"
                            )
                        ),
                        lambda_function=bedrock_mixins.CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                            lambda_arn="lambdaArn"
                        ),
                        lex=bedrock_mixins.CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty(
                            bot_alias_arn="botAliasArn",
                            locale_id="localeId"
                        ),
                        loop=bedrock_mixins.CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty(
                            definition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDefinitionProperty(
                                connections=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionProperty(
                                    configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty(
                                        conditional=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                            condition="condition"
                                        ),
                                        data=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                                            source_output="sourceOutput",
                                            target_input="targetInput"
                                        )
                                    ),
                                    name="name",
                                    source="source",
                                    target="target",
                                    type="type"
                                )],
                                nodes=[flow_node_property_]
                            )
                        ),
                        loop_controller=bedrock_mixins.CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                            continue_condition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                                expression="expression",
                                name="name"
                            ),
                            max_iterations=123
                        ),
                        loop_input=loop_input,
                        output=output,
                        prompt=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty(
                            guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                                guardrail_identifier="guardrailIdentifier",
                                guardrail_version="guardrailVersion"
                            ),
                            source_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                inline=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                    inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    model_id="modelId",
                                    template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                                            input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                                name="name"
                                            )],
                                            text="text"
                                        )
                                    ),
                                    template_type="templateType"
                                ),
                                resource=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                    prompt_arn="promptArn"
                                )
                            )
                        ),
                        retrieval=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty(
                            service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                s3=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                    bucket_name="bucketName"
                                )
                            )
                        ),
                        storage=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty(
                            service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                s3=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                    bucket_name="bucketName"
                                )
                            )
                        )
                    ),
                    inputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeInputProperty(
                        expression="expression",
                        name="name",
                        type="type"
                    )],
                    name="name",
                    outputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeOutputProperty(
                        name="name",
                        type="type"
                    )],
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3a764a5378fd0166173f5954332eba13f5b71c6828cfe26f1bdc44528343b194)
                check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
                check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configuration is not None:
                self._values["configuration"] = configuration
            if inputs is not None:
                self._values["inputs"] = inputs
            if name is not None:
                self._values["name"] = name
            if outputs is not None:
                self._values["outputs"] = outputs
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty"]]:
            '''Contains configurations for the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownode.html#cfn-bedrock-flowversion-flownode-configuration
            '''
            result = self._values.get("configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty"]], result)

        @builtins.property
        def inputs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeInputProperty"]]]]:
            '''An array of objects, each of which contains information about an input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownode.html#cfn-bedrock-flowversion-flownode-inputs
            '''
            result = self._values.get("inputs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeInputProperty"]]]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''A name for the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownode.html#cfn-bedrock-flowversion-flownode-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def outputs(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeOutputProperty"]]]]:
            '''A list of objects, each of which contains information about an output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownode.html#cfn-bedrock-flowversion-flownode-outputs
            '''
            result = self._values.get("outputs")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowNodeOutputProperty"]]]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of node.

            This value must match the name of the key that you provide in the configuration you provide in the ``FlowNodeConfiguration`` field.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-flownode.html#cfn-bedrock-flowversion-flownode-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FlowNodeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_identifier": "guardrailIdentifier",
            "guardrail_version": "guardrailVersion",
        },
    )
    class GuardrailConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_identifier: typing.Optional[builtins.str] = None,
            guardrail_version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration information for a guardrail that you use with the `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ operation.

            :param guardrail_identifier: The identifier for the guardrail.
            :param guardrail_version: The version of the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-guardrailconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                guardrail_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                    guardrail_identifier="guardrailIdentifier",
                    guardrail_version="guardrailVersion"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__451554bffd20ba06d78c724461b14c67e2a272882cfd356c0dffd5d83c159e63)
                check_type(argname="argument guardrail_identifier", value=guardrail_identifier, expected_type=type_hints["guardrail_identifier"])
                check_type(argname="argument guardrail_version", value=guardrail_version, expected_type=type_hints["guardrail_version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_identifier is not None:
                self._values["guardrail_identifier"] = guardrail_identifier
            if guardrail_version is not None:
                self._values["guardrail_version"] = guardrail_version

        @builtins.property
        def guardrail_identifier(self) -> typing.Optional[builtins.str]:
            '''The identifier for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-guardrailconfiguration.html#cfn-bedrock-flowversion-guardrailconfiguration-guardrailidentifier
            '''
            result = self._values.get("guardrail_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def guardrail_version(self) -> typing.Optional[builtins.str]:
            '''The version of the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-guardrailconfiguration.html#cfn-bedrock-flowversion-guardrailconfiguration-guardrailversion
            '''
            result = self._values.get("guardrail_version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "GuardrailConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"code": "code", "language": "language"},
    )
    class InlineCodeFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            code: typing.Optional[builtins.str] = None,
            language: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an inline code node in your flow.

            Inline code nodes let you write and execute code directly within your flow, enabling data transformations, custom logic, and integrations without needing an external Lambda function.

            :param code: The code that's executed in your inline code node. The code can access input data from previous nodes in the flow, perform operations on that data, and produce output that can be used by other nodes in your flow. The code must be valid in the programming ``language`` that you specify.
            :param language: The programming language used by your inline code node. The code must be valid in the programming ``language`` that you specify. Currently, only Python 3 ( ``Python_3`` ) is supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-inlinecodeflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                inline_code_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                    code="code",
                    language="language"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__70ade5ff8dc0a417e4254622e265e702ca724dd929fef699a35cf6ffc7699282)
                check_type(argname="argument code", value=code, expected_type=type_hints["code"])
                check_type(argname="argument language", value=language, expected_type=type_hints["language"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if code is not None:
                self._values["code"] = code
            if language is not None:
                self._values["language"] = language

        @builtins.property
        def code(self) -> typing.Optional[builtins.str]:
            '''The code that's executed in your inline code node.

            The code can access input data from previous nodes in the flow, perform operations on that data, and produce output that can be used by other nodes in your flow.

            The code must be valid in the programming ``language`` that you specify.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-inlinecodeflownodeconfiguration.html#cfn-bedrock-flowversion-inlinecodeflownodeconfiguration-code
            '''
            result = self._values.get("code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def language(self) -> typing.Optional[builtins.str]:
            '''The programming language used by your inline code node.

            The code must be valid in the programming ``language`` that you specify. Currently, only Python 3 ( ``Python_3`` ) is supported.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-inlinecodeflownodeconfiguration.html#cfn-bedrock-flowversion-inlinecodeflownodeconfiguration-language
            '''
            result = self._values.get("language")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InlineCodeFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_configuration": "guardrailConfiguration",
            "inference_configuration": "inferenceConfiguration",
            "knowledge_base_id": "knowledgeBaseId",
            "model_id": "modelId",
            "number_of_results": "numberOfResults",
            "orchestration_configuration": "orchestrationConfiguration",
            "prompt_template": "promptTemplate",
            "reranking_configuration": "rerankingConfiguration",
        },
    )
    class KnowledgeBaseFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.GuardrailConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            knowledge_base_id: typing.Optional[builtins.str] = None,
            model_id: typing.Optional[builtins.str] = None,
            number_of_results: typing.Optional[jsii.Number] = None,
            orchestration_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            prompt_template: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            reranking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a knowledge base node in a flow.

            This node takes a query as the input and returns, as the output, the retrieved responses directly (as an array) or a response generated based on the retrieved responses. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param guardrail_configuration: Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration.
            :param inference_configuration: Contains inference configurations for the prompt.
            :param knowledge_base_id: The unique identifier of the knowledge base to query.
            :param model_id: The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.
            :param number_of_results: The number of results to retrieve from the knowledge base.
            :param orchestration_configuration: The configuration for orchestrating the retrieval and generation process in the knowledge base node.
            :param prompt_template: A custom prompt template to use with the knowledge base for generating responses.
            :param reranking_configuration: The configuration for reranking the retrieved results from the knowledge base to improve relevance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                knowledge_base_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                    guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                        guardrail_identifier="guardrailIdentifier",
                        guardrail_version="guardrailVersion"
                    ),
                    inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    knowledge_base_id="knowledgeBaseId",
                    model_id="modelId",
                    number_of_results=123,
                    orchestration_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                        additional_model_request_fields=additional_model_request_fields,
                        inference_config=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                            text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                max_tokens=123,
                                stop_sequences=["stopSequences"],
                                temperature=123,
                                top_p=123
                            )
                        ),
                        performance_config=bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                            latency="latency"
                        ),
                        prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                            text_prompt_template="textPromptTemplate"
                        )
                    ),
                    prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                        text_prompt_template="textPromptTemplate"
                    ),
                    reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty(
                        bedrock_reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                            metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                                selection_mode="selectionMode",
                                selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                    fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                        field_name="fieldName"
                                    )],
                                    fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                        field_name="fieldName"
                                    )]
                                )
                            ),
                            model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                additional_model_request_fields=additional_model_request_fields,
                                model_arn="modelArn"
                            ),
                            number_of_reranked_results=123
                        ),
                        type="type"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0df63fee092a9686afeb88cdb5dc188fd22c756572e03de07b286af74c9a4278)
                check_type(argname="argument guardrail_configuration", value=guardrail_configuration, expected_type=type_hints["guardrail_configuration"])
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument knowledge_base_id", value=knowledge_base_id, expected_type=type_hints["knowledge_base_id"])
                check_type(argname="argument model_id", value=model_id, expected_type=type_hints["model_id"])
                check_type(argname="argument number_of_results", value=number_of_results, expected_type=type_hints["number_of_results"])
                check_type(argname="argument orchestration_configuration", value=orchestration_configuration, expected_type=type_hints["orchestration_configuration"])
                check_type(argname="argument prompt_template", value=prompt_template, expected_type=type_hints["prompt_template"])
                check_type(argname="argument reranking_configuration", value=reranking_configuration, expected_type=type_hints["reranking_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_configuration is not None:
                self._values["guardrail_configuration"] = guardrail_configuration
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if knowledge_base_id is not None:
                self._values["knowledge_base_id"] = knowledge_base_id
            if model_id is not None:
                self._values["model_id"] = model_id
            if number_of_results is not None:
                self._values["number_of_results"] = number_of_results
            if orchestration_configuration is not None:
                self._values["orchestration_configuration"] = orchestration_configuration
            if prompt_template is not None:
                self._values["prompt_template"] = prompt_template
            if reranking_configuration is not None:
                self._values["reranking_configuration"] = reranking_configuration

        @builtins.property
        def guardrail_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.GuardrailConfigurationProperty"]]:
            '''Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-guardrailconfiguration
            '''
            result = self._values.get("guardrail_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.GuardrailConfigurationProperty"]], result)

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def knowledge_base_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the knowledge base to query.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-knowledgebaseid
            '''
            result = self._values.get("knowledge_base_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def model_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-modelid
            '''
            result = self._values.get("model_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def number_of_results(self) -> typing.Optional[jsii.Number]:
            '''The number of results to retrieve from the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-numberofresults
            '''
            result = self._values.get("number_of_results")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def orchestration_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty"]]:
            '''The configuration for orchestrating the retrieval and generation process in the knowledge base node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-orchestrationconfiguration
            '''
            result = self._values.get("orchestration_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty"]], result)

        @builtins.property
        def prompt_template(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty"]]:
            '''A custom prompt template to use with the knowledge base for generating responses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-prompttemplate
            '''
            result = self._values.get("prompt_template")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty"]], result)

        @builtins.property
        def reranking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty"]]:
            '''The configuration for reranking the retrieved results from the knowledge base to improve relevance.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseflownodeconfiguration.html#cfn-bedrock-flowversion-knowledgebaseflownodeconfiguration-rerankingconfiguration
            '''
            result = self._values.get("reranking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBaseFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "inference_config": "inferenceConfig",
            "performance_config": "performanceConfig",
            "prompt_template": "promptTemplate",
        },
    )
    class KnowledgeBaseOrchestrationConfigurationProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            inference_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            performance_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PerformanceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            prompt_template: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configures how the knowledge base orchestrates the retrieval and generation process, allowing for customization of prompts, inference parameters, and performance settings.

            :param additional_model_request_fields: The additional model-specific request parameters as key-value pairs to be included in the request to the foundation model.
            :param inference_config: Contains inference configurations for the prompt.
            :param performance_config: The performance configuration options for the knowledge base retrieval and generation process.
            :param prompt_template: A custom prompt template for orchestrating the retrieval and generation process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseorchestrationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                knowledge_base_orchestration_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    inference_config=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    performance_config=bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                        latency="latency"
                    ),
                    prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                        text_prompt_template="textPromptTemplate"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__eac43ca6c6cbfbf55050078e772773e7ac9c3db217ebebe6880a2c47181aa1a2)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument inference_config", value=inference_config, expected_type=type_hints["inference_config"])
                check_type(argname="argument performance_config", value=performance_config, expected_type=type_hints["performance_config"])
                check_type(argname="argument prompt_template", value=prompt_template, expected_type=type_hints["prompt_template"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if inference_config is not None:
                self._values["inference_config"] = inference_config
            if performance_config is not None:
                self._values["performance_config"] = performance_config
            if prompt_template is not None:
                self._values["prompt_template"] = prompt_template

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''The additional model-specific request parameters as key-value pairs to be included in the request to the foundation model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flowversion-knowledgebaseorchestrationconfiguration-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def inference_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flowversion-knowledgebaseorchestrationconfiguration-inferenceconfig
            '''
            result = self._values.get("inference_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def performance_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PerformanceConfigurationProperty"]]:
            '''The performance configuration options for the knowledge base retrieval and generation process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flowversion-knowledgebaseorchestrationconfiguration-performanceconfig
            '''
            result = self._values.get("performance_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PerformanceConfigurationProperty"]], result)

        @builtins.property
        def prompt_template(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty"]]:
            '''A custom prompt template for orchestrating the retrieval and generation process.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseorchestrationconfiguration.html#cfn-bedrock-flowversion-knowledgebaseorchestrationconfiguration-prompttemplate
            '''
            result = self._values.get("prompt_template")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBaseOrchestrationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty",
        jsii_struct_bases=[],
        name_mapping={"text_prompt_template": "textPromptTemplate"},
    )
    class KnowledgeBasePromptTemplateProperty:
        def __init__(
            self,
            *,
            text_prompt_template: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Defines a custom prompt template for orchestrating the retrieval and generation process.

            :param text_prompt_template: The text of the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseprompttemplate.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                knowledge_base_prompt_template_property = bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                    text_prompt_template="textPromptTemplate"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__68a45b1552a51ee2adabe384032a07077a62eabe3db79b289778b076b1410e03)
                check_type(argname="argument text_prompt_template", value=text_prompt_template, expected_type=type_hints["text_prompt_template"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text_prompt_template is not None:
                self._values["text_prompt_template"] = text_prompt_template

        @builtins.property
        def text_prompt_template(self) -> typing.Optional[builtins.str]:
            '''The text of the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-knowledgebaseprompttemplate.html#cfn-bedrock-flowversion-knowledgebaseprompttemplate-textprompttemplate
            '''
            result = self._values.get("text_prompt_template")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBasePromptTemplateProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"lambda_arn": "lambdaArn"},
    )
    class LambdaFunctionFlowNodeConfigurationProperty:
        def __init__(self, *, lambda_arn: typing.Optional[builtins.str] = None) -> None:
            '''Contains configurations for a Lambda function node in the flow.

            You specify the Lambda function to invoke and the inputs into the function. The output is the response that is defined in the Lambda function. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param lambda_arn: The Amazon Resource Name (ARN) of the Lambda function to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-lambdafunctionflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                lambda_function_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                    lambda_arn="lambdaArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__97c467f244286c2a399bb87391823a29d1320bf3e14c4c3cdc9b03b0c6ff738c)
                check_type(argname="argument lambda_arn", value=lambda_arn, expected_type=type_hints["lambda_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if lambda_arn is not None:
                self._values["lambda_arn"] = lambda_arn

        @builtins.property
        def lambda_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Lambda function to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-lambdafunctionflownodeconfiguration.html#cfn-bedrock-flowversion-lambdafunctionflownodeconfiguration-lambdaarn
            '''
            result = self._values.get("lambda_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LambdaFunctionFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"bot_alias_arn": "botAliasArn", "locale_id": "localeId"},
    )
    class LexFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            bot_alias_arn: typing.Optional[builtins.str] = None,
            locale_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a Lex node in the flow.

            You specify a Amazon Lex bot to invoke. This node takes an utterance as the input and returns as the output the intent identified by the Amazon Lex bot. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param bot_alias_arn: The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
            :param locale_id: The Region to invoke the Amazon Lex bot in.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-lexflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                lex_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty(
                    bot_alias_arn="botAliasArn",
                    locale_id="localeId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__671f2ac5134b1754f540245f695529902ad632891a191c3fd8b1e516a830950e)
                check_type(argname="argument bot_alias_arn", value=bot_alias_arn, expected_type=type_hints["bot_alias_arn"])
                check_type(argname="argument locale_id", value=locale_id, expected_type=type_hints["locale_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bot_alias_arn is not None:
                self._values["bot_alias_arn"] = bot_alias_arn
            if locale_id is not None:
                self._values["locale_id"] = locale_id

        @builtins.property
        def bot_alias_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-lexflownodeconfiguration.html#cfn-bedrock-flowversion-lexflownodeconfiguration-botaliasarn
            '''
            result = self._values.get("bot_alias_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def locale_id(self) -> typing.Optional[builtins.str]:
            '''The Region to invoke the Amazon Lex bot in.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-lexflownodeconfiguration.html#cfn-bedrock-flowversion-lexflownodeconfiguration-localeid
            '''
            result = self._values.get("locale_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LexFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "continue_condition": "continueCondition",
            "max_iterations": "maxIterations",
        },
    )
    class LoopControllerFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            continue_condition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowConditionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            max_iterations: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Contains configurations for the controller node of a DoWhile loop in the flow.

            :param continue_condition: Specifies the condition that determines when the flow exits the DoWhile loop. The loop executes until this condition evaluates to true.
            :param max_iterations: Specifies the maximum number of times the DoWhile loop can iterate before the flow exits the loop. Default: - 10

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-loopcontrollerflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                loop_controller_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                    continue_condition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                        expression="expression",
                        name="name"
                    ),
                    max_iterations=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__15e9b94777e9b1b48d62d629ca60e589f7afbe40027e284d7f7504baa7e10230)
                check_type(argname="argument continue_condition", value=continue_condition, expected_type=type_hints["continue_condition"])
                check_type(argname="argument max_iterations", value=max_iterations, expected_type=type_hints["max_iterations"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if continue_condition is not None:
                self._values["continue_condition"] = continue_condition
            if max_iterations is not None:
                self._values["max_iterations"] = max_iterations

        @builtins.property
        def continue_condition(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConditionProperty"]]:
            '''Specifies the condition that determines when the flow exits the DoWhile loop.

            The loop executes until this condition evaluates to true.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-loopcontrollerflownodeconfiguration.html#cfn-bedrock-flowversion-loopcontrollerflownodeconfiguration-continuecondition
            '''
            result = self._values.get("continue_condition")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowConditionProperty"]], result)

        @builtins.property
        def max_iterations(self) -> typing.Optional[jsii.Number]:
            '''Specifies the maximum number of times the DoWhile loop can iterate before the flow exits the loop.

            :default: - 10

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-loopcontrollerflownodeconfiguration.html#cfn-bedrock-flowversion-loopcontrollerflownodeconfiguration-maxiterations
            '''
            result = self._values.get("max_iterations")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoopControllerFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"definition": "definition"},
    )
    class LoopFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            definition: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FlowDefinitionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for the nodes of a DoWhile loop in your flow.

            A DoWhile loop is made up of the following nodes:

            - ``Loop`` - The container node that holds the loop's flow definition. This node encompasses the entire loop structure.
            - ``LoopInput`` - The entry point node for the loop. This node receives inputs from nodes outside the loop and from previous loop iterations.
            - Body nodes - The processing nodes that execute within each loop iteration. These can be nodes for handling data in your flow, such as a prompt or Lambda function nodes. Some node types aren't supported inside a DoWhile loop body. For more information, see `LoopIncompatibleNodeTypeFlowValidationDetails <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_LoopIncompatibleNodeTypeFlowValidationDetails.html>`_ .
            - ``LoopController`` - The node that evaluates whether the loop should continue or exit based on a condition.

            These nodes work together to create a loop that runs at least once and continues until a specified condition is met or a maximum number of iterations is reached.

            :param definition: The definition of the DoWhile loop nodes and connections between nodes in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-loopflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # collector: Any
                # input: Any
                # iterator: Any
                # loop_flow_node_configuration_property_: bedrock_mixins.CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty
                # loop_input: Any
                # output: Any
                
                loop_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty(
                    definition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDefinitionProperty(
                        connections=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionProperty(
                            configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty(
                                conditional=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty(
                                    condition="condition"
                                ),
                                data=bedrock_mixins.CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty(
                                    source_output="sourceOutput",
                                    target_input="targetInput"
                                )
                            ),
                            name="name",
                            source="source",
                            target="target",
                            type="type"
                        )],
                        nodes=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeProperty(
                            configuration=bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty(
                                agent=bedrock_mixins.CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty(
                                    agent_alias_arn="agentAliasArn"
                                ),
                                collector=collector,
                                condition=bedrock_mixins.CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty(
                                    conditions=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                                        expression="expression",
                                        name="name"
                                    )]
                                ),
                                inline_code=bedrock_mixins.CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty(
                                    code="code",
                                    language="language"
                                ),
                                input=input,
                                iterator=iterator,
                                knowledge_base=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty(
                                    guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                                        guardrail_identifier="guardrailIdentifier",
                                        guardrail_version="guardrailVersion"
                                    ),
                                    inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                        text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                            max_tokens=123,
                                            stop_sequences=["stopSequences"],
                                            temperature=123,
                                            top_p=123
                                        )
                                    ),
                                    knowledge_base_id="knowledgeBaseId",
                                    model_id="modelId",
                                    number_of_results=123,
                                    orchestration_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty(
                                        additional_model_request_fields=additional_model_request_fields,
                                        inference_config=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                            text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                                max_tokens=123,
                                                stop_sequences=["stopSequences"],
                                                temperature=123,
                                                top_p=123
                                            )
                                        ),
                                        performance_config=bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                                            latency="latency"
                                        ),
                                        prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                            text_prompt_template="textPromptTemplate"
                                        )
                                    ),
                                    prompt_template=bedrock_mixins.CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty(
                                        text_prompt_template="textPromptTemplate"
                                    ),
                                    reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty(
                                        bedrock_reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                                            metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                                                selection_mode="selectionMode",
                                                selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                                    fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                                        field_name="fieldName"
                                                    )],
                                                    fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                                        field_name="fieldName"
                                                    )]
                                                )
                                            ),
                                            model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                                                additional_model_request_fields=additional_model_request_fields,
                                                model_arn="modelArn"
                                            ),
                                            number_of_reranked_results=123
                                        ),
                                        type="type"
                                    )
                                ),
                                lambda_function=bedrock_mixins.CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty(
                                    lambda_arn="lambdaArn"
                                ),
                                lex=bedrock_mixins.CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty(
                                    bot_alias_arn="botAliasArn",
                                    locale_id="localeId"
                                ),
                                loop=loop_flow_node_configuration_property_,
                                loop_controller=bedrock_mixins.CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty(
                                    continue_condition=bedrock_mixins.CfnFlowVersionPropsMixin.FlowConditionProperty(
                                        expression="expression",
                                        name="name"
                                    ),
                                    max_iterations=123
                                ),
                                loop_input=loop_input,
                                output=output,
                                prompt=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty(
                                    guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                                        guardrail_identifier="guardrailIdentifier",
                                        guardrail_version="guardrailVersion"
                                    ),
                                    source_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                                        inline=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                                            inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                                text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                                    max_tokens=123,
                                                    stop_sequences=["stopSequences"],
                                                    temperature=123,
                                                    top_p=123
                                                )
                                            ),
                                            model_id="modelId",
                                            template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                                                text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                                                    input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                                        name="name"
                                                    )],
                                                    text="text"
                                                )
                                            ),
                                            template_type="templateType"
                                        ),
                                        resource=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                                            prompt_arn="promptArn"
                                        )
                                    )
                                ),
                                retrieval=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty(
                                    service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                                        s3=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                                            bucket_name="bucketName"
                                        )
                                    )
                                ),
                                storage=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty(
                                    service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                                        s3=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                                            bucket_name="bucketName"
                                        )
                                    )
                                )
                            ),
                            inputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeInputProperty(
                                expression="expression",
                                name="name",
                                type="type"
                            )],
                            name="name",
                            outputs=[bedrock_mixins.CfnFlowVersionPropsMixin.FlowNodeOutputProperty(
                                name="name",
                                type="type"
                            )],
                            type="type"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__466e09223bfab68ee5fe2db255310c5d2095f55d4e9ed7945cf45d30cdfed0b0)
                check_type(argname="argument definition", value=definition, expected_type=type_hints["definition"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if definition is not None:
                self._values["definition"] = definition

        @builtins.property
        def definition(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowDefinitionProperty"]]:
            '''The definition of the DoWhile loop nodes and connections between nodes in the flow.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-loopflownodeconfiguration.html#cfn-bedrock-flowversion-loopflownodeconfiguration-definition
            '''
            result = self._values.get("definition")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FlowDefinitionProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoopFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "selection_mode": "selectionMode",
            "selective_mode_configuration": "selectiveModeConfiguration",
        },
    )
    class MetadataConfigurationForRerankingProperty:
        def __init__(
            self,
            *,
            selection_mode: typing.Optional[builtins.str] = None,
            selective_mode_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configuration for how metadata should be used during the reranking process in Knowledge Base vector searches.

            This determines which metadata fields are included or excluded when reordering search results.

            :param selection_mode: The mode for selecting which metadata fields to include in the reranking process. Valid values are ALL (use all available metadata fields) or SELECTIVE (use only specified fields).
            :param selective_mode_configuration: Configuration for selective mode, which allows you to explicitly include or exclude specific metadata fields during reranking. This is only used when selectionMode is set to SELECTIVE.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-metadataconfigurationforreranking.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                metadata_configuration_for_reranking_property = bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                    selection_mode="selectionMode",
                    selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                        fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                            field_name="fieldName"
                        )],
                        fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                            field_name="fieldName"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__61b970e81b7ea491ce006f0983856dae9c2aaf47e7489f5fa89ec5e9e440a186)
                check_type(argname="argument selection_mode", value=selection_mode, expected_type=type_hints["selection_mode"])
                check_type(argname="argument selective_mode_configuration", value=selective_mode_configuration, expected_type=type_hints["selective_mode_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if selection_mode is not None:
                self._values["selection_mode"] = selection_mode
            if selective_mode_configuration is not None:
                self._values["selective_mode_configuration"] = selective_mode_configuration

        @builtins.property
        def selection_mode(self) -> typing.Optional[builtins.str]:
            '''The mode for selecting which metadata fields to include in the reranking process.

            Valid values are ALL (use all available metadata fields) or SELECTIVE (use only specified fields).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-metadataconfigurationforreranking.html#cfn-bedrock-flowversion-metadataconfigurationforreranking-selectionmode
            '''
            result = self._values.get("selection_mode")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def selective_mode_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty"]]:
            '''Configuration for selective mode, which allows you to explicitly include or exclude specific metadata fields during reranking.

            This is only used when selectionMode is set to SELECTIVE.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-metadataconfigurationforreranking.html#cfn-bedrock-flowversion-metadataconfigurationforreranking-selectivemodeconfiguration
            '''
            result = self._values.get("selective_mode_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetadataConfigurationForRerankingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"latency": "latency"},
    )
    class PerformanceConfigurationProperty:
        def __init__(self, *, latency: typing.Optional[builtins.str] = None) -> None:
            '''Performance settings for a model.

            :param latency: To use a latency-optimized version of the model, set to ``optimized`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-performanceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                performance_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PerformanceConfigurationProperty(
                    latency="latency"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d4f0cbb7ca50627c07fdc827ce60814f55dd5a4917574cb80e3651a32ad3b52d)
                check_type(argname="argument latency", value=latency, expected_type=type_hints["latency"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if latency is not None:
                self._values["latency"] = latency

        @builtins.property
        def latency(self) -> typing.Optional[builtins.str]:
            '''To use a latency-optimized version of the model, set to ``optimized`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-performanceconfiguration.html#cfn-bedrock-flowversion-performanceconfiguration-latency
            '''
            result = self._values.get("latency")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PerformanceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "guardrail_configuration": "guardrailConfiguration",
            "source_configuration": "sourceConfiguration",
        },
    )
    class PromptFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            guardrail_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.GuardrailConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            source_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a prompt node in the flow.

            You can use a prompt from Prompt management or you can define one in this node. If the prompt contains variables, the inputs into this node will fill in the variables. The output from this node is the response generated by the model. For more information, see `Node types in a flow <https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html>`_ in the Amazon Bedrock User Guide.

            :param guardrail_configuration: Contains configurations for a guardrail to apply to the prompt in this node and the response generated from it.
            :param source_configuration: Specifies whether the prompt is from Prompt management or defined inline.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty(
                    guardrail_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.GuardrailConfigurationProperty(
                        guardrail_identifier="guardrailIdentifier",
                        guardrail_version="guardrailVersion"
                    ),
                    source_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                        inline=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                            inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                                text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                    max_tokens=123,
                                    stop_sequences=["stopSequences"],
                                    temperature=123,
                                    top_p=123
                                )
                            ),
                            model_id="modelId",
                            template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                                text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                                    input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                        name="name"
                                    )],
                                    text="text"
                                )
                            ),
                            template_type="templateType"
                        ),
                        resource=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                            prompt_arn="promptArn"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__becb6791bc224364a06501e675d8ea9bd31c1df798c687a759f67bba6b4a0602)
                check_type(argname="argument guardrail_configuration", value=guardrail_configuration, expected_type=type_hints["guardrail_configuration"])
                check_type(argname="argument source_configuration", value=source_configuration, expected_type=type_hints["source_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_configuration is not None:
                self._values["guardrail_configuration"] = guardrail_configuration
            if source_configuration is not None:
                self._values["source_configuration"] = source_configuration

        @builtins.property
        def guardrail_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.GuardrailConfigurationProperty"]]:
            '''Contains configurations for a guardrail to apply to the prompt in this node and the response generated from it.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeconfiguration.html#cfn-bedrock-flowversion-promptflownodeconfiguration-guardrailconfiguration
            '''
            result = self._values.get("guardrail_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.GuardrailConfigurationProperty"]], result)

        @builtins.property
        def source_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty"]]:
            '''Specifies whether the prompt is from Prompt management or defined inline.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeconfiguration.html#cfn-bedrock-flowversion-promptflownodeconfiguration-sourceconfiguration
            '''
            result = self._values.get("source_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "inference_configuration": "inferenceConfiguration",
            "model_id": "modelId",
            "template_configuration": "templateConfiguration",
            "template_type": "templateType",
        },
    )
    class PromptFlowNodeInlineConfigurationProperty:
        def __init__(
            self,
            *,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            model_id: typing.Optional[builtins.str] = None,
            template_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            template_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a prompt defined inline in the node.

            :param inference_configuration: Contains inference configurations for the prompt.
            :param model_id: The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to run inference with.
            :param template_configuration: Contains a prompt and variables in the prompt that can be replaced with values at runtime.
            :param template_type: The type of prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeinlineconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_inline_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                    inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    model_id="modelId",
                    template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                        text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                            input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            text="text"
                        )
                    ),
                    template_type="templateType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cbe887f934eb1de4d84a1b07586103f63c05f8b7126927831d4a298dc4a25e5d)
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument model_id", value=model_id, expected_type=type_hints["model_id"])
                check_type(argname="argument template_configuration", value=template_configuration, expected_type=type_hints["template_configuration"])
                check_type(argname="argument template_type", value=template_type, expected_type=type_hints["template_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if model_id is not None:
                self._values["model_id"] = model_id
            if template_configuration is not None:
                self._values["template_configuration"] = template_configuration
            if template_type is not None:
                self._values["template_type"] = template_type

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeinlineconfiguration.html#cfn-bedrock-flowversion-promptflownodeinlineconfiguration-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def model_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ to run inference with.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeinlineconfiguration.html#cfn-bedrock-flowversion-promptflownodeinlineconfiguration-modelid
            '''
            result = self._values.get("model_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def template_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty"]]:
            '''Contains a prompt and variables in the prompt that can be replaced with values at runtime.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeinlineconfiguration.html#cfn-bedrock-flowversion-promptflownodeinlineconfiguration-templateconfiguration
            '''
            result = self._values.get("template_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty"]], result)

        @builtins.property
        def template_type(self) -> typing.Optional[builtins.str]:
            '''The type of prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodeinlineconfiguration.html#cfn-bedrock-flowversion-promptflownodeinlineconfiguration-templatetype
            '''
            result = self._values.get("template_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeInlineConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"prompt_arn": "promptArn"},
    )
    class PromptFlowNodeResourceConfigurationProperty:
        def __init__(self, *, prompt_arn: typing.Optional[builtins.str] = None) -> None:
            '''Contains configurations for a prompt from Prompt management to use in a node.

            :param prompt_arn: The Amazon Resource Name (ARN) of the prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownoderesourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_resource_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                    prompt_arn="promptArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7591b7ab1e77eefb3b288511b10dbae4a5b412b9b55aa0c647cc8ef594a3cbe7)
                check_type(argname="argument prompt_arn", value=prompt_arn, expected_type=type_hints["prompt_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if prompt_arn is not None:
                self._values["prompt_arn"] = prompt_arn

        @builtins.property
        def prompt_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownoderesourceconfiguration.html#cfn-bedrock-flowversion-promptflownoderesourceconfiguration-promptarn
            '''
            result = self._values.get("prompt_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeResourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"inline": "inline", "resource": "resource"},
    )
    class PromptFlowNodeSourceConfigurationProperty:
        def __init__(
            self,
            *,
            inline: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            resource: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a prompt and whether it is from Prompt management or defined inline.

            :param inline: Contains configurations for a prompt that is defined inline.
            :param resource: Contains configurations for a prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodesourceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_flow_node_source_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty(
                    inline=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty(
                        inference_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                            text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                                max_tokens=123,
                                stop_sequences=["stopSequences"],
                                temperature=123,
                                top_p=123
                            )
                        ),
                        model_id="modelId",
                        template_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                            text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                                input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                                    name="name"
                                )],
                                text="text"
                            )
                        ),
                        template_type="templateType"
                    ),
                    resource=bedrock_mixins.CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty(
                        prompt_arn="promptArn"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__20b7b4b95cbfa53d58bf20f9d8c993af083fdab34e585a1523ee3fb403259a1b)
                check_type(argname="argument inline", value=inline, expected_type=type_hints["inline"])
                check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if inline is not None:
                self._values["inline"] = inline
            if resource is not None:
                self._values["resource"] = resource

        @builtins.property
        def inline(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty"]]:
            '''Contains configurations for a prompt that is defined inline.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodesourceconfiguration.html#cfn-bedrock-flowversion-promptflownodesourceconfiguration-inline
            '''
            result = self._values.get("inline")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty"]], result)

        @builtins.property
        def resource(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty"]]:
            '''Contains configurations for a prompt from Prompt management.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptflownodesourceconfiguration.html#cfn-bedrock-flowversion-promptflownodesourceconfiguration-resource
            '''
            result = self._values.get("resource")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptFlowNodeSourceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"text": "text"},
    )
    class PromptInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains inference configurations for the prompt.

            :param text: Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_inference_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty(
                    text=bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                        max_tokens=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_p=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2bbdb880fc136f689b0dfcf76aa2ca4bdd6d28392eac4587e4d53746850817ba)
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty"]]:
            '''Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptinferenceconfiguration.html#cfn-bedrock-flowversion-promptinferenceconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class PromptInputVariableProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about a variable in the prompt.

            :param name: The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptinputvariable.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_input_variable_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3faa9302142b9b5e44a4c1a26c2fc679f580a0955f0d9f129f1579f05fb821ae)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptinputvariable.html#cfn-bedrock-flowversion-promptinputvariable-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInputVariableProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_tokens": "maxTokens",
            "stop_sequences": "stopSequences",
            "temperature": "temperature",
            "top_p": "topP",
        },
    )
    class PromptModelInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            max_tokens: typing.Optional[jsii.Number] = None,
            stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
            temperature: typing.Optional[jsii.Number] = None,
            top_p: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Contains inference configurations related to model inference for a prompt.

            For more information, see `Inference parameters <https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html>`_ .

            :param max_tokens: The maximum number of tokens to return in the response.
            :param stop_sequences: A list of strings that define sequences after which the model will stop generating.
            :param temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
            :param top_p: The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptmodelinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_model_inference_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                    max_tokens=123,
                    stop_sequences=["stopSequences"],
                    temperature=123,
                    top_p=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cb0a04ed04fad15da0f6bf51e85144ccb9d291724bd5d31b955c498e3fd473f2)
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
                check_type(argname="argument stop_sequences", value=stop_sequences, expected_type=type_hints["stop_sequences"])
                check_type(argname="argument temperature", value=temperature, expected_type=type_hints["temperature"])
                check_type(argname="argument top_p", value=top_p, expected_type=type_hints["top_p"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens
            if stop_sequences is not None:
                self._values["stop_sequences"] = stop_sequences
            if temperature is not None:
                self._values["temperature"] = temperature
            if top_p is not None:
                self._values["top_p"] = top_p

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens to return in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptmodelinferenceconfiguration.html#cfn-bedrock-flowversion-promptmodelinferenceconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def stop_sequences(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of strings that define sequences after which the model will stop generating.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptmodelinferenceconfiguration.html#cfn-bedrock-flowversion-promptmodelinferenceconfiguration-stopsequences
            '''
            result = self._values.get("stop_sequences")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def temperature(self) -> typing.Optional[jsii.Number]:
            '''Controls the randomness of the response.

            Choose a lower value for more predictable outputs and a higher value for more surprising outputs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptmodelinferenceconfiguration.html#cfn-bedrock-flowversion-promptmodelinferenceconfiguration-temperature
            '''
            result = self._values.get("temperature")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def top_p(self) -> typing.Optional[jsii.Number]:
            '''The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-promptmodelinferenceconfiguration.html#cfn-bedrock-flowversion-promptmodelinferenceconfiguration-topp
            '''
            result = self._values.get("top_p")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptModelInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"text": "text"},
    )
    class PromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains the message for a prompt.

            For more information, see `Construct and store reusable prompts with Prompt management in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html>`_ .

            :param text: Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-prompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_template_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty(
                    text=bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                        input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        text="text"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d8eb0c43d8509270ee6e17a29e22722ef0a905c92e0625548ed0f82acf820930)
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty"]]:
            '''Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-prompttemplateconfiguration.html#cfn-bedrock-flowversion-prompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "fields_to_exclude": "fieldsToExclude",
            "fields_to_include": "fieldsToInclude",
        },
    )
    class RerankingMetadataSelectiveModeConfigurationProperty:
        def __init__(
            self,
            *,
            fields_to_exclude: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FieldForRerankingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            fields_to_include: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.FieldForRerankingProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Configuration for selectively including or excluding metadata fields during the reranking process.

            This allows you to control which metadata attributes are considered when reordering search results.

            :param fields_to_exclude: A list of metadata field names to explicitly exclude from the reranking process. All metadata fields except these will be considered when reordering search results. This parameter cannot be used together with fieldsToInclude.
            :param fields_to_include: A list of metadata field names to explicitly include in the reranking process. Only these fields will be considered when reordering search results. This parameter cannot be used together with fieldsToExclude.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-rerankingmetadataselectivemodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                reranking_metadata_selective_mode_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                    fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                        field_name="fieldName"
                    )],
                    fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                        field_name="fieldName"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1ad0c08ab2e11ce6e6b3165edc08af8267f0ef68147586c21af6ccef9d8e73f8)
                check_type(argname="argument fields_to_exclude", value=fields_to_exclude, expected_type=type_hints["fields_to_exclude"])
                check_type(argname="argument fields_to_include", value=fields_to_include, expected_type=type_hints["fields_to_include"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if fields_to_exclude is not None:
                self._values["fields_to_exclude"] = fields_to_exclude
            if fields_to_include is not None:
                self._values["fields_to_include"] = fields_to_include

        @builtins.property
        def fields_to_exclude(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FieldForRerankingProperty"]]]]:
            '''A list of metadata field names to explicitly exclude from the reranking process.

            All metadata fields except these will be considered when reordering search results. This parameter cannot be used together with fieldsToInclude.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-rerankingmetadataselectivemodeconfiguration.html#cfn-bedrock-flowversion-rerankingmetadataselectivemodeconfiguration-fieldstoexclude
            '''
            result = self._values.get("fields_to_exclude")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FieldForRerankingProperty"]]]], result)

        @builtins.property
        def fields_to_include(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FieldForRerankingProperty"]]]]:
            '''A list of metadata field names to explicitly include in the reranking process.

            Only these fields will be considered when reordering search results. This parameter cannot be used together with fieldsToExclude.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-rerankingmetadataselectivemodeconfiguration.html#cfn-bedrock-flowversion-rerankingmetadataselectivemodeconfiguration-fieldstoinclude
            '''
            result = self._values.get("fields_to_include")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.FieldForRerankingProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RerankingMetadataSelectiveModeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"service_configuration": "serviceConfiguration"},
    )
    class RetrievalFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            service_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a Retrieval node in a flow.

            This node retrieves data from the Amazon S3 location that you specify and returns it as the output.

            :param service_configuration: Contains configurations for the service to use for retrieving data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-retrievalflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                retrieval_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty(
                    service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                        s3=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                            bucket_name="bucketName"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__eb5aba1d6ff0ba266c492631ea389d042c173289a8eaea1ada0c2a8aafdfe7f8)
                check_type(argname="argument service_configuration", value=service_configuration, expected_type=type_hints["service_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if service_configuration is not None:
                self._values["service_configuration"] = service_configuration

        @builtins.property
        def service_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty"]]:
            '''Contains configurations for the service to use for retrieving data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-retrievalflownodeconfiguration.html#cfn-bedrock-flowversion-retrievalflownodeconfiguration-serviceconfiguration
            '''
            result = self._values.get("service_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetrievalFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket_name": "bucketName"},
    )
    class RetrievalFlowNodeS3ConfigurationProperty:
        def __init__(
            self,
            *,
            bucket_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.

            :param bucket_name: The name of the Amazon S3 bucket from which to retrieve data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-retrievalflownodes3configuration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                retrieval_flow_node_s3_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                    bucket_name="bucketName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a893eee5082f99f98e6b9f187387f6d3da4e2e87bb8bea015df4f2bf9d77508c)
                check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_name is not None:
                self._values["bucket_name"] = bucket_name

        @builtins.property
        def bucket_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Amazon S3 bucket from which to retrieve data.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-retrievalflownodes3configuration.html#cfn-bedrock-flowversion-retrievalflownodes3configuration-bucketname
            '''
            result = self._values.get("bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetrievalFlowNodeS3ConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"s3": "s3"},
    )
    class RetrievalFlowNodeServiceConfigurationProperty:
        def __init__(
            self,
            *,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for the service to use for retrieving data to return as the output from the node.

            :param s3: Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-retrievalflownodeserviceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                retrieval_flow_node_service_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty(
                    s3=bedrock_mixins.CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty(
                        bucket_name="bucketName"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__420ea91191b505c5bf5c4248fee637d405636d4ed65397a255304b4ddd71ea58)
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3 is not None:
                self._values["s3"] = s3

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty"]]:
            '''Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-retrievalflownodeserviceconfiguration.html#cfn-bedrock-flowversion-retrievalflownodeserviceconfiguration-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RetrievalFlowNodeServiceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"service_configuration": "serviceConfiguration"},
    )
    class StorageFlowNodeConfigurationProperty:
        def __init__(
            self,
            *,
            service_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a Storage node in a flow.

            This node stores the input in an Amazon S3 location that you specify.

            :param service_configuration: Contains configurations for the service to use for storing the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-storageflownodeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_flow_node_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty(
                    service_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                        s3=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                            bucket_name="bucketName"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__16c7ebf7272d11464d819f541fcf3a42a4f84a686b0b76fec9854cc9ce4a79a5)
                check_type(argname="argument service_configuration", value=service_configuration, expected_type=type_hints["service_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if service_configuration is not None:
                self._values["service_configuration"] = service_configuration

        @builtins.property
        def service_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty"]]:
            '''Contains configurations for the service to use for storing the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-storageflownodeconfiguration.html#cfn-bedrock-flowversion-storageflownodeconfiguration-serviceconfiguration
            '''
            result = self._values.get("service_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageFlowNodeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket_name": "bucketName"},
    )
    class StorageFlowNodeS3ConfigurationProperty:
        def __init__(
            self,
            *,
            bucket_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for the Amazon S3 location in which to store the input into the node.

            :param bucket_name: The name of the Amazon S3 bucket in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-storageflownodes3configuration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_flow_node_s3_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                    bucket_name="bucketName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__73ff693d885fe1b82fbc790c20d70a77c9c1f679a59a4cc3e8b683758b734d9a)
                check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket_name is not None:
                self._values["bucket_name"] = bucket_name

        @builtins.property
        def bucket_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Amazon S3 bucket in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-storageflownodes3configuration.html#cfn-bedrock-flowversion-storageflownodes3configuration-bucketname
            '''
            result = self._values.get("bucket_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageFlowNodeS3ConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"s3": "s3"},
    )
    class StorageFlowNodeServiceConfigurationProperty:
        def __init__(
            self,
            *,
            s3: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for the service to use for storing the input into the node.

            :param s3: Contains configurations for the Amazon S3 location in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-storageflownodeserviceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_flow_node_service_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty(
                    s3=bedrock_mixins.CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty(
                        bucket_name="bucketName"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__33f8faa8f6ae445b9c3f5944816c1ecefdcccee1479bea46d17c1cd1d1f5206f)
                check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3 is not None:
                self._values["s3"] = s3

        @builtins.property
        def s3(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty"]]:
            '''Contains configurations for the Amazon S3 location in which to store the input into the node.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-storageflownodeserviceconfiguration.html#cfn-bedrock-flowversion-storageflownodeserviceconfiguration-s3
            '''
            result = self._values.get("s3")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageFlowNodeServiceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"input_variables": "inputVariables", "text": "text"},
    )
    class TextPromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            input_variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.PromptInputVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a text prompt template.

            To include a variable, enclose a word in double curly braces as in ``{{variable}}`` .

            :param input_variables: An array of the variables in the prompt template.
            :param text: The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-textprompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                text_prompt_template_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                    input_variables=[bedrock_mixins.CfnFlowVersionPropsMixin.PromptInputVariableProperty(
                        name="name"
                    )],
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6f9eb0e3fff3b6d5c40b1c0e96ad5c6f4a71efd4a059fe4aa93aefa05237ddd4)
                check_type(argname="argument input_variables", value=input_variables, expected_type=type_hints["input_variables"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_variables is not None:
                self._values["input_variables"] = input_variables
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def input_variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInputVariableProperty"]]]]:
            '''An array of the variables in the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-textprompttemplateconfiguration.html#cfn-bedrock-flowversion-textprompttemplateconfiguration-inputvariables
            '''
            result = self._values.get("input_variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.PromptInputVariableProperty"]]]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-textprompttemplateconfiguration.html#cfn-bedrock-flowversion-textprompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TextPromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metadata_configuration": "metadataConfiguration",
            "model_configuration": "modelConfiguration",
            "number_of_reranked_results": "numberOfRerankedResults",
        },
    )
    class VectorSearchBedrockRerankingConfigurationProperty:
        def __init__(
            self,
            *,
            metadata_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            model_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            number_of_reranked_results: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configuration for using Amazon Bedrock foundation models to rerank Knowledge Base vector search results.

            This enables more sophisticated relevance ranking using large language models.

            :param metadata_configuration: Configuration for how document metadata should be used during the reranking process. This determines which metadata fields are included when reordering search results.
            :param model_configuration: Configuration for the Amazon Bedrock foundation model used for reranking. This includes the model ARN and any additional request fields required by the model.
            :param number_of_reranked_results: The maximum number of results to rerank. This limits how many of the initial vector search results will be processed by the reranking model. A smaller number improves performance but may exclude potentially relevant results.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                vector_search_bedrock_reranking_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                    metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                        selection_mode="selectionMode",
                        selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                            fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                field_name="fieldName"
                            )],
                            fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                field_name="fieldName"
                            )]
                        )
                    ),
                    model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                        additional_model_request_fields=additional_model_request_fields,
                        model_arn="modelArn"
                    ),
                    number_of_reranked_results=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d87f4ece24bbcf4a260f28b865777a93dc73ae388b31c358d94c70c21f39e669)
                check_type(argname="argument metadata_configuration", value=metadata_configuration, expected_type=type_hints["metadata_configuration"])
                check_type(argname="argument model_configuration", value=model_configuration, expected_type=type_hints["model_configuration"])
                check_type(argname="argument number_of_reranked_results", value=number_of_reranked_results, expected_type=type_hints["number_of_reranked_results"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_configuration is not None:
                self._values["metadata_configuration"] = metadata_configuration
            if model_configuration is not None:
                self._values["model_configuration"] = model_configuration
            if number_of_reranked_results is not None:
                self._values["number_of_reranked_results"] = number_of_reranked_results

        @builtins.property
        def metadata_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty"]]:
            '''Configuration for how document metadata should be used during the reranking process.

            This determines which metadata fields are included when reordering search results.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration.html#cfn-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration-metadataconfiguration
            '''
            result = self._values.get("metadata_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty"]], result)

        @builtins.property
        def model_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty"]]:
            '''Configuration for the Amazon Bedrock foundation model used for reranking.

            This includes the model ARN and any additional request fields required by the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration.html#cfn-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration-modelconfiguration
            '''
            result = self._values.get("model_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty"]], result)

        @builtins.property
        def number_of_reranked_results(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of results to rerank.

            This limits how many of the initial vector search results will be processed by the reranking model. A smaller number improves performance but may exclude potentially relevant results.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration.html#cfn-bedrock-flowversion-vectorsearchbedrockrerankingconfiguration-numberofrerankedresults
            '''
            result = self._values.get("number_of_reranked_results")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorSearchBedrockRerankingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "model_arn": "modelArn",
        },
    )
    class VectorSearchBedrockRerankingModelConfigurationProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            model_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration for the Amazon Bedrock foundation model used for reranking vector search results.

            This specifies which model to use and any additional parameters required by the model.

            :param additional_model_request_fields: A list of additional fields to include in the model request during reranking. These fields provide extra context or configuration options specific to the selected foundation model.
            :param model_arn: The Amazon Resource Name (ARN) of the foundation model to use for reranking. This model processes the query and search results to determine a more relevant ordering.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingmodelconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                vector_search_bedrock_reranking_model_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    model_arn="modelArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1aceb401aa71f7aa77b3123e9762a5b543c86b2574443dcbf1e30ad9c8a5932a)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument model_arn", value=model_arn, expected_type=type_hints["model_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if model_arn is not None:
                self._values["model_arn"] = model_arn

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''A list of additional fields to include in the model request during reranking.

            These fields provide extra context or configuration options specific to the selected foundation model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingmodelconfiguration.html#cfn-bedrock-flowversion-vectorsearchbedrockrerankingmodelconfiguration-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def model_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the foundation model to use for reranking.

            This model processes the query and search results to determine a more relevant ordering.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchbedrockrerankingmodelconfiguration.html#cfn-bedrock-flowversion-vectorsearchbedrockrerankingmodelconfiguration-modelarn
            '''
            result = self._values.get("model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorSearchBedrockRerankingModelConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bedrock_reranking_configuration": "bedrockRerankingConfiguration",
            "type": "type",
        },
    )
    class VectorSearchRerankingConfigurationProperty:
        def __init__(
            self,
            *,
            bedrock_reranking_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Configuration for reranking vector search results to improve relevance.

            Reranking applies additional relevance models to reorder the initial vector search results based on more sophisticated criteria.

            :param bedrock_reranking_configuration: Configuration for using Amazon Bedrock foundation models to rerank search results. This is required when the reranking type is set to BEDROCK.
            :param type: The type of reranking to apply to vector search results. Currently, the only supported value is BEDROCK, which uses Amazon Bedrock foundation models for reranking.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchrerankingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                
                vector_search_reranking_configuration_property = bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty(
                    bedrock_reranking_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty(
                        metadata_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty(
                            selection_mode="selectionMode",
                            selective_mode_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty(
                                fields_to_exclude=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                    field_name="fieldName"
                                )],
                                fields_to_include=[bedrock_mixins.CfnFlowVersionPropsMixin.FieldForRerankingProperty(
                                    field_name="fieldName"
                                )]
                            )
                        ),
                        model_configuration=bedrock_mixins.CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty(
                            additional_model_request_fields=additional_model_request_fields,
                            model_arn="modelArn"
                        ),
                        number_of_reranked_results=123
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6eb8c9b2c3fd97190511322d0a78c6bb331be6308c28344a58313ddf438e5742)
                check_type(argname="argument bedrock_reranking_configuration", value=bedrock_reranking_configuration, expected_type=type_hints["bedrock_reranking_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bedrock_reranking_configuration is not None:
                self._values["bedrock_reranking_configuration"] = bedrock_reranking_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def bedrock_reranking_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty"]]:
            '''Configuration for using Amazon Bedrock foundation models to rerank search results.

            This is required when the reranking type is set to BEDROCK.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchrerankingconfiguration.html#cfn-bedrock-flowversion-vectorsearchrerankingconfiguration-bedrockrerankingconfiguration
            '''
            result = self._values.get("bedrock_reranking_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of reranking to apply to vector search results.

            Currently, the only supported value is BEDROCK, which uses Amazon Bedrock foundation models for reranking.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-flowversion-vectorsearchrerankingconfiguration.html#cfn-bedrock-flowversion-vectorsearchrerankingconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorSearchRerankingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "automated_reasoning_policy_config": "automatedReasoningPolicyConfig",
        "blocked_input_messaging": "blockedInputMessaging",
        "blocked_outputs_messaging": "blockedOutputsMessaging",
        "content_policy_config": "contentPolicyConfig",
        "contextual_grounding_policy_config": "contextualGroundingPolicyConfig",
        "cross_region_config": "crossRegionConfig",
        "description": "description",
        "kms_key_arn": "kmsKeyArn",
        "name": "name",
        "sensitive_information_policy_config": "sensitiveInformationPolicyConfig",
        "tags": "tags",
        "topic_policy_config": "topicPolicyConfig",
        "word_policy_config": "wordPolicyConfig",
    },
)
class CfnGuardrailMixinProps:
    def __init__(
        self,
        *,
        automated_reasoning_policy_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        blocked_input_messaging: typing.Optional[builtins.str] = None,
        blocked_outputs_messaging: typing.Optional[builtins.str] = None,
        content_policy_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.ContentPolicyConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        contextual_grounding_policy_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        cross_region_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        kms_key_arn: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        sensitive_information_policy_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
        topic_policy_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.TopicPolicyConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        word_policy_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.WordPolicyConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnGuardrailPropsMixin.

        :param automated_reasoning_policy_config: Configuration settings for integrating Automated Reasoning policies with Amazon Bedrock Guardrails.
        :param blocked_input_messaging: The message to return when the guardrail blocks a prompt.
        :param blocked_outputs_messaging: The message to return when the guardrail blocks a model response.
        :param content_policy_config: The content filter policies to configure for the guardrail.
        :param contextual_grounding_policy_config: Contextual grounding policy config for a guardrail.
        :param cross_region_config: The system-defined guardrail profile that you're using with your guardrail. Guardrail profiles define the destination AWS Regions where guardrail inference requests can be automatically routed. Using guardrail profiles helps maintain guardrail performance and reliability when demand increases. For more information, see the `Amazon Bedrock User Guide <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .
        :param description: A description of the guardrail.
        :param kms_key_arn: The ARN of the AWS key that you use to encrypt the guardrail.
        :param name: The name of the guardrail.
        :param sensitive_information_policy_config: The sensitive information policy to configure for the guardrail.
        :param tags: The tags that you want to attach to the guardrail.
        :param topic_policy_config: The topic policies to configure for the guardrail.
        :param word_policy_config: The word policy you configure for the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_guardrail_mixin_props = bedrock_mixins.CfnGuardrailMixinProps(
                automated_reasoning_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty(
                    confidence_threshold=123,
                    policies=["policies"]
                ),
                blocked_input_messaging="blockedInputMessaging",
                blocked_outputs_messaging="blockedOutputsMessaging",
                content_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.ContentPolicyConfigProperty(
                    content_filters_tier_config=bedrock_mixins.CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty(
                        tier_name="tierName"
                    ),
                    filters_config=[bedrock_mixins.CfnGuardrailPropsMixin.ContentFilterConfigProperty(
                        input_action="inputAction",
                        input_enabled=False,
                        input_modalities=["inputModalities"],
                        input_strength="inputStrength",
                        output_action="outputAction",
                        output_enabled=False,
                        output_modalities=["outputModalities"],
                        output_strength="outputStrength",
                        type="type"
                    )]
                ),
                contextual_grounding_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty(
                    filters_config=[bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty(
                        action="action",
                        enabled=False,
                        threshold=123,
                        type="type"
                    )]
                ),
                cross_region_config=bedrock_mixins.CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty(
                    guardrail_profile_arn="guardrailProfileArn"
                ),
                description="description",
                kms_key_arn="kmsKeyArn",
                name="name",
                sensitive_information_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty(
                    pii_entities_config=[bedrock_mixins.CfnGuardrailPropsMixin.PiiEntityConfigProperty(
                        action="action",
                        input_action="inputAction",
                        input_enabled=False,
                        output_action="outputAction",
                        output_enabled=False,
                        type="type"
                    )],
                    regexes_config=[bedrock_mixins.CfnGuardrailPropsMixin.RegexConfigProperty(
                        action="action",
                        description="description",
                        input_action="inputAction",
                        input_enabled=False,
                        name="name",
                        output_action="outputAction",
                        output_enabled=False,
                        pattern="pattern"
                    )]
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                topic_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.TopicPolicyConfigProperty(
                    topics_config=[bedrock_mixins.CfnGuardrailPropsMixin.TopicConfigProperty(
                        definition="definition",
                        examples=["examples"],
                        input_action="inputAction",
                        input_enabled=False,
                        name="name",
                        output_action="outputAction",
                        output_enabled=False,
                        type="type"
                    )],
                    topics_tier_config=bedrock_mixins.CfnGuardrailPropsMixin.TopicsTierConfigProperty(
                        tier_name="tierName"
                    )
                ),
                word_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.WordPolicyConfigProperty(
                    managed_word_lists_config=[bedrock_mixins.CfnGuardrailPropsMixin.ManagedWordsConfigProperty(
                        input_action="inputAction",
                        input_enabled=False,
                        output_action="outputAction",
                        output_enabled=False,
                        type="type"
                    )],
                    words_config=[bedrock_mixins.CfnGuardrailPropsMixin.WordConfigProperty(
                        input_action="inputAction",
                        input_enabled=False,
                        output_action="outputAction",
                        output_enabled=False,
                        text="text"
                    )]
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88366691e366db6afe58e0cbe59b580cf7cab047d115363bb23da0997ac5e494)
            check_type(argname="argument automated_reasoning_policy_config", value=automated_reasoning_policy_config, expected_type=type_hints["automated_reasoning_policy_config"])
            check_type(argname="argument blocked_input_messaging", value=blocked_input_messaging, expected_type=type_hints["blocked_input_messaging"])
            check_type(argname="argument blocked_outputs_messaging", value=blocked_outputs_messaging, expected_type=type_hints["blocked_outputs_messaging"])
            check_type(argname="argument content_policy_config", value=content_policy_config, expected_type=type_hints["content_policy_config"])
            check_type(argname="argument contextual_grounding_policy_config", value=contextual_grounding_policy_config, expected_type=type_hints["contextual_grounding_policy_config"])
            check_type(argname="argument cross_region_config", value=cross_region_config, expected_type=type_hints["cross_region_config"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument kms_key_arn", value=kms_key_arn, expected_type=type_hints["kms_key_arn"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument sensitive_information_policy_config", value=sensitive_information_policy_config, expected_type=type_hints["sensitive_information_policy_config"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument topic_policy_config", value=topic_policy_config, expected_type=type_hints["topic_policy_config"])
            check_type(argname="argument word_policy_config", value=word_policy_config, expected_type=type_hints["word_policy_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if automated_reasoning_policy_config is not None:
            self._values["automated_reasoning_policy_config"] = automated_reasoning_policy_config
        if blocked_input_messaging is not None:
            self._values["blocked_input_messaging"] = blocked_input_messaging
        if blocked_outputs_messaging is not None:
            self._values["blocked_outputs_messaging"] = blocked_outputs_messaging
        if content_policy_config is not None:
            self._values["content_policy_config"] = content_policy_config
        if contextual_grounding_policy_config is not None:
            self._values["contextual_grounding_policy_config"] = contextual_grounding_policy_config
        if cross_region_config is not None:
            self._values["cross_region_config"] = cross_region_config
        if description is not None:
            self._values["description"] = description
        if kms_key_arn is not None:
            self._values["kms_key_arn"] = kms_key_arn
        if name is not None:
            self._values["name"] = name
        if sensitive_information_policy_config is not None:
            self._values["sensitive_information_policy_config"] = sensitive_information_policy_config
        if tags is not None:
            self._values["tags"] = tags
        if topic_policy_config is not None:
            self._values["topic_policy_config"] = topic_policy_config
        if word_policy_config is not None:
            self._values["word_policy_config"] = word_policy_config

    @builtins.property
    def automated_reasoning_policy_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty"]]:
        '''Configuration settings for integrating Automated Reasoning policies with Amazon Bedrock Guardrails.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-automatedreasoningpolicyconfig
        '''
        result = self._values.get("automated_reasoning_policy_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty"]], result)

    @builtins.property
    def blocked_input_messaging(self) -> typing.Optional[builtins.str]:
        '''The message to return when the guardrail blocks a prompt.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-blockedinputmessaging
        '''
        result = self._values.get("blocked_input_messaging")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def blocked_outputs_messaging(self) -> typing.Optional[builtins.str]:
        '''The message to return when the guardrail blocks a model response.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-blockedoutputsmessaging
        '''
        result = self._values.get("blocked_outputs_messaging")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def content_policy_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContentPolicyConfigProperty"]]:
        '''The content filter policies to configure for the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-contentpolicyconfig
        '''
        result = self._values.get("content_policy_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContentPolicyConfigProperty"]], result)

    @builtins.property
    def contextual_grounding_policy_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty"]]:
        '''Contextual grounding policy config for a guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-contextualgroundingpolicyconfig
        '''
        result = self._values.get("contextual_grounding_policy_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty"]], result)

    @builtins.property
    def cross_region_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty"]]:
        '''The system-defined guardrail profile that you're using with your guardrail.

        Guardrail profiles define the destination AWS Regions where guardrail inference requests can be automatically routed. Using guardrail profiles helps maintain guardrail performance and reliability when demand increases.

        For more information, see the `Amazon Bedrock User Guide <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-crossregionconfig
        '''
        result = self._values.get("cross_region_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty"]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kms_key_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the AWS  key that you use to encrypt the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-kmskeyarn
        '''
        result = self._values.get("kms_key_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sensitive_information_policy_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty"]]:
        '''The sensitive information policy to configure for the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-sensitiveinformationpolicyconfig
        '''
        result = self._values.get("sensitive_information_policy_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''The tags that you want to attach to the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    @builtins.property
    def topic_policy_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.TopicPolicyConfigProperty"]]:
        '''The topic policies to configure for the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-topicpolicyconfig
        '''
        result = self._values.get("topic_policy_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.TopicPolicyConfigProperty"]], result)

    @builtins.property
    def word_policy_config(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.WordPolicyConfigProperty"]]:
        '''The word policy you configure for the guardrail.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html#cfn-bedrock-guardrail-wordpolicyconfig
        '''
        result = self._values.get("word_policy_config")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.WordPolicyConfigProperty"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnGuardrailMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnGuardrailPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin",
):
    '''Creates a guardrail to detect and filter harmful content in your generative AI application.

    Amazon Bedrock Guardrails provides the following safeguards (also known as policies) to detect and filter harmful content:

    - *Content filters* - Detect and filter harmful text or image content in input prompts or model responses. Filtering is done based on detection of certain predefined harmful content categories: Hate, Insults, Sexual, Violence, Misconduct and Prompt Attack. You also can adjust the filter strength for each of these categories.
    - *Denied topics* - Define a set of topics that are undesirable in the context of your application. The filter will help block them if detected in user queries or model responses.
    - *Word filters* - Configure filters to help block undesirable words, phrases, and profanity (exact match). Such words can include offensive terms, competitor names, etc.
    - *Sensitive information filters* - Configure filters to help block or mask sensitive information, such as personally identifiable information (PII), or custom regex in user inputs and model responses. Blocking or masking is done based on probabilistic detection of sensitive information in standard formats in entities such as SSN number, Date of Birth, address, etc. This also allows configuring regular expression based detection of patterns for identifiers.
    - *Contextual grounding check* - Help detect and filter hallucinations in model responses based on grounding in a source and relevance to the user query.

    For more information, see `How Amazon Bedrock Guardrails works <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-how.html>`_ .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html
    :cloudformationResource: AWS::Bedrock::Guardrail
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_guardrail_props_mixin = bedrock_mixins.CfnGuardrailPropsMixin(bedrock_mixins.CfnGuardrailMixinProps(
            automated_reasoning_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty(
                confidence_threshold=123,
                policies=["policies"]
            ),
            blocked_input_messaging="blockedInputMessaging",
            blocked_outputs_messaging="blockedOutputsMessaging",
            content_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.ContentPolicyConfigProperty(
                content_filters_tier_config=bedrock_mixins.CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty(
                    tier_name="tierName"
                ),
                filters_config=[bedrock_mixins.CfnGuardrailPropsMixin.ContentFilterConfigProperty(
                    input_action="inputAction",
                    input_enabled=False,
                    input_modalities=["inputModalities"],
                    input_strength="inputStrength",
                    output_action="outputAction",
                    output_enabled=False,
                    output_modalities=["outputModalities"],
                    output_strength="outputStrength",
                    type="type"
                )]
            ),
            contextual_grounding_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty(
                filters_config=[bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty(
                    action="action",
                    enabled=False,
                    threshold=123,
                    type="type"
                )]
            ),
            cross_region_config=bedrock_mixins.CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty(
                guardrail_profile_arn="guardrailProfileArn"
            ),
            description="description",
            kms_key_arn="kmsKeyArn",
            name="name",
            sensitive_information_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty(
                pii_entities_config=[bedrock_mixins.CfnGuardrailPropsMixin.PiiEntityConfigProperty(
                    action="action",
                    input_action="inputAction",
                    input_enabled=False,
                    output_action="outputAction",
                    output_enabled=False,
                    type="type"
                )],
                regexes_config=[bedrock_mixins.CfnGuardrailPropsMixin.RegexConfigProperty(
                    action="action",
                    description="description",
                    input_action="inputAction",
                    input_enabled=False,
                    name="name",
                    output_action="outputAction",
                    output_enabled=False,
                    pattern="pattern"
                )]
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            topic_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.TopicPolicyConfigProperty(
                topics_config=[bedrock_mixins.CfnGuardrailPropsMixin.TopicConfigProperty(
                    definition="definition",
                    examples=["examples"],
                    input_action="inputAction",
                    input_enabled=False,
                    name="name",
                    output_action="outputAction",
                    output_enabled=False,
                    type="type"
                )],
                topics_tier_config=bedrock_mixins.CfnGuardrailPropsMixin.TopicsTierConfigProperty(
                    tier_name="tierName"
                )
            ),
            word_policy_config=bedrock_mixins.CfnGuardrailPropsMixin.WordPolicyConfigProperty(
                managed_word_lists_config=[bedrock_mixins.CfnGuardrailPropsMixin.ManagedWordsConfigProperty(
                    input_action="inputAction",
                    input_enabled=False,
                    output_action="outputAction",
                    output_enabled=False,
                    type="type"
                )],
                words_config=[bedrock_mixins.CfnGuardrailPropsMixin.WordConfigProperty(
                    input_action="inputAction",
                    input_enabled=False,
                    output_action="outputAction",
                    output_enabled=False,
                    text="text"
                )]
            )
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnGuardrailMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::Guardrail``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c9fcddc035057dea3d0916eb9f5bf07f50b849744dfbf898103a822617b08b9)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a20726603b01dfbf3ec19af1d6e5fbdf491d3368fd826dde98cad290a7f4ddaa)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11476f343f5628bd0b8b11c90ea92253faa3f66e476413797540c03b69330d4b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnGuardrailMixinProps":
        return typing.cast("CfnGuardrailMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "confidence_threshold": "confidenceThreshold",
            "policies": "policies",
        },
    )
    class AutomatedReasoningPolicyConfigProperty:
        def __init__(
            self,
            *,
            confidence_threshold: typing.Optional[jsii.Number] = None,
            policies: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Configuration settings for integrating Automated Reasoning policies with Amazon Bedrock Guardrails.

            :param confidence_threshold: The minimum confidence level required for Automated Reasoning policy violations to trigger guardrail actions. Values range from 0.0 to 1.0.
            :param policies: The list of Automated Reasoning policy ARNs that should be applied as part of this guardrail configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-automatedreasoningpolicyconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                automated_reasoning_policy_config_property = bedrock_mixins.CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty(
                    confidence_threshold=123,
                    policies=["policies"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ecc618d3b9f468d9094cf8d3be218e2c269018804d4fe01c5ea4b9d68b882ab0)
                check_type(argname="argument confidence_threshold", value=confidence_threshold, expected_type=type_hints["confidence_threshold"])
                check_type(argname="argument policies", value=policies, expected_type=type_hints["policies"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if confidence_threshold is not None:
                self._values["confidence_threshold"] = confidence_threshold
            if policies is not None:
                self._values["policies"] = policies

        @builtins.property
        def confidence_threshold(self) -> typing.Optional[jsii.Number]:
            '''The minimum confidence level required for Automated Reasoning policy violations to trigger guardrail actions.

            Values range from 0.0 to 1.0.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-automatedreasoningpolicyconfig.html#cfn-bedrock-guardrail-automatedreasoningpolicyconfig-confidencethreshold
            '''
            result = self._values.get("confidence_threshold")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def policies(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The list of Automated Reasoning policy ARNs that should be applied as part of this guardrail configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-automatedreasoningpolicyconfig.html#cfn-bedrock-guardrail-automatedreasoningpolicyconfig-policies
            '''
            result = self._values.get("policies")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AutomatedReasoningPolicyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.ContentFilterConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "input_action": "inputAction",
            "input_enabled": "inputEnabled",
            "input_modalities": "inputModalities",
            "input_strength": "inputStrength",
            "output_action": "outputAction",
            "output_enabled": "outputEnabled",
            "output_modalities": "outputModalities",
            "output_strength": "outputStrength",
            "type": "type",
        },
    )
    class ContentFilterConfigProperty:
        def __init__(
            self,
            *,
            input_action: typing.Optional[builtins.str] = None,
            input_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            input_modalities: typing.Optional[typing.Sequence[builtins.str]] = None,
            input_strength: typing.Optional[builtins.str] = None,
            output_action: typing.Optional[builtins.str] = None,
            output_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            output_modalities: typing.Optional[typing.Sequence[builtins.str]] = None,
            output_strength: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains filter strengths for harmful content.

            Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.

            - *Hate* – Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
            - *Insults* – Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
            - *Sexual* – Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
            - *Violence* – Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.

            Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as *Hate* with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as *Hate* with HIGH confidence, *Insults* with LOW confidence, *Sexual* with NONE confidence, and *Violence* with MEDIUM confidence.

            For more information, see `Guardrails content filters <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html>`_ .

            :param input_action: Specifies the action to take when harmful content is detected. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param input_modalities: The input modalities selected for the guardrail content filter configuration.
            :param input_strength: The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
            :param output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param output_modalities: The output modalities selected for the guardrail content filter configuration.
            :param output_strength: The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
            :param type: The harmful category that the content filter is applied to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                content_filter_config_property = bedrock_mixins.CfnGuardrailPropsMixin.ContentFilterConfigProperty(
                    input_action="inputAction",
                    input_enabled=False,
                    input_modalities=["inputModalities"],
                    input_strength="inputStrength",
                    output_action="outputAction",
                    output_enabled=False,
                    output_modalities=["outputModalities"],
                    output_strength="outputStrength",
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__34789e2e0805282361d1eb8c54632a79d7b5ecd6944c3e24601d6c00d8ee3de4)
                check_type(argname="argument input_action", value=input_action, expected_type=type_hints["input_action"])
                check_type(argname="argument input_enabled", value=input_enabled, expected_type=type_hints["input_enabled"])
                check_type(argname="argument input_modalities", value=input_modalities, expected_type=type_hints["input_modalities"])
                check_type(argname="argument input_strength", value=input_strength, expected_type=type_hints["input_strength"])
                check_type(argname="argument output_action", value=output_action, expected_type=type_hints["output_action"])
                check_type(argname="argument output_enabled", value=output_enabled, expected_type=type_hints["output_enabled"])
                check_type(argname="argument output_modalities", value=output_modalities, expected_type=type_hints["output_modalities"])
                check_type(argname="argument output_strength", value=output_strength, expected_type=type_hints["output_strength"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_action is not None:
                self._values["input_action"] = input_action
            if input_enabled is not None:
                self._values["input_enabled"] = input_enabled
            if input_modalities is not None:
                self._values["input_modalities"] = input_modalities
            if input_strength is not None:
                self._values["input_strength"] = input_strength
            if output_action is not None:
                self._values["output_action"] = output_action
            if output_enabled is not None:
                self._values["output_enabled"] = output_enabled
            if output_modalities is not None:
                self._values["output_modalities"] = output_modalities
            if output_strength is not None:
                self._values["output_strength"] = output_strength
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def input_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-inputaction
            '''
            result = self._values.get("input_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the input.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-inputenabled
            '''
            result = self._values.get("input_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def input_modalities(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The input modalities selected for the guardrail content filter configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-inputmodalities
            '''
            result = self._values.get("input_modalities")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def input_strength(self) -> typing.Optional[builtins.str]:
            '''The strength of the content filter to apply to prompts.

            As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-inputstrength
            '''
            result = self._values.get("input_strength")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the output. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-outputaction
            '''
            result = self._values.get("output_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the output.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-outputenabled
            '''
            result = self._values.get("output_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def output_modalities(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The output modalities selected for the guardrail content filter configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-outputmodalities
            '''
            result = self._values.get("output_modalities")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def output_strength(self) -> typing.Optional[builtins.str]:
            '''The strength of the content filter to apply to model responses.

            As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-outputstrength
            '''
            result = self._values.get("output_strength")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The harmful category that the content filter is applied to.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html#cfn-bedrock-guardrail-contentfilterconfig-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContentFilterConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"tier_name": "tierName"},
    )
    class ContentFiltersTierConfigProperty:
        def __init__(self, *, tier_name: typing.Optional[builtins.str] = None) -> None:
            '''The tier that your guardrail uses for content filters.

            Consider using a tier that balances performance, accuracy, and compatibility with your existing generative AI workflows.

            :param tier_name: The tier that your guardrail uses for content filters. Valid values include:. - ``CLASSIC`` tier – Provides established guardrails functionality supporting English, French, and Spanish languages. - ``STANDARD`` tier – Provides a more robust solution than the ``CLASSIC`` tier and has more comprehensive language support. This tier requires that your guardrail use `cross-Region inference <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterstierconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                content_filters_tier_config_property = bedrock_mixins.CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty(
                    tier_name="tierName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e12a15e1d77089bea8a157ba9aaa865d08562c9a9f64e33c63eac711313fc52e)
                check_type(argname="argument tier_name", value=tier_name, expected_type=type_hints["tier_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if tier_name is not None:
                self._values["tier_name"] = tier_name

        @builtins.property
        def tier_name(self) -> typing.Optional[builtins.str]:
            '''The tier that your guardrail uses for content filters. Valid values include:.

            - ``CLASSIC`` tier – Provides established guardrails functionality supporting English, French, and Spanish languages.
            - ``STANDARD`` tier – Provides a more robust solution than the ``CLASSIC`` tier and has more comprehensive language support. This tier requires that your guardrail use `cross-Region inference <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterstierconfig.html#cfn-bedrock-guardrail-contentfilterstierconfig-tiername
            '''
            result = self._values.get("tier_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContentFiltersTierConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.ContentPolicyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "content_filters_tier_config": "contentFiltersTierConfig",
            "filters_config": "filtersConfig",
        },
    )
    class ContentPolicyConfigProperty:
        def __init__(
            self,
            *,
            content_filters_tier_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            filters_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.ContentFilterConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Contains details about how to handle harmful content.

            :param content_filters_tier_config: The tier that your guardrail uses for content filters. Consider using a tier that balances performance, accuracy, and compatibility with your existing generative AI workflows.
            :param filters_config: Contains the type of the content filter and how strongly it should apply to prompts and model responses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentpolicyconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                content_policy_config_property = bedrock_mixins.CfnGuardrailPropsMixin.ContentPolicyConfigProperty(
                    content_filters_tier_config=bedrock_mixins.CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty(
                        tier_name="tierName"
                    ),
                    filters_config=[bedrock_mixins.CfnGuardrailPropsMixin.ContentFilterConfigProperty(
                        input_action="inputAction",
                        input_enabled=False,
                        input_modalities=["inputModalities"],
                        input_strength="inputStrength",
                        output_action="outputAction",
                        output_enabled=False,
                        output_modalities=["outputModalities"],
                        output_strength="outputStrength",
                        type="type"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f38697e2a3b1be529d62ca06d62ea360ca666122475c1af3cd3e321d08a23b14)
                check_type(argname="argument content_filters_tier_config", value=content_filters_tier_config, expected_type=type_hints["content_filters_tier_config"])
                check_type(argname="argument filters_config", value=filters_config, expected_type=type_hints["filters_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if content_filters_tier_config is not None:
                self._values["content_filters_tier_config"] = content_filters_tier_config
            if filters_config is not None:
                self._values["filters_config"] = filters_config

        @builtins.property
        def content_filters_tier_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty"]]:
            '''The tier that your guardrail uses for content filters.

            Consider using a tier that balances performance, accuracy, and compatibility with your existing generative AI workflows.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentpolicyconfig.html#cfn-bedrock-guardrail-contentpolicyconfig-contentfilterstierconfig
            '''
            result = self._values.get("content_filters_tier_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty"]], result)

        @builtins.property
        def filters_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContentFilterConfigProperty"]]]]:
            '''Contains the type of the content filter and how strongly it should apply to prompts and model responses.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentpolicyconfig.html#cfn-bedrock-guardrail-contentpolicyconfig-filtersconfig
            '''
            result = self._values.get("filters_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContentFilterConfigProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContentPolicyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "enabled": "enabled",
            "threshold": "threshold",
            "type": "type",
        },
    )
    class ContextualGroundingFilterConfigProperty:
        def __init__(
            self,
            *,
            action: typing.Optional[builtins.str] = None,
            enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            threshold: typing.Optional[jsii.Number] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The filter configuration details for the guardrails contextual grounding filter.

            :param action: Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param enabled: Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param threshold: The threshold details for the guardrails contextual grounding filter.
            :param type: The filter details for the guardrails contextual grounding filter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingfilterconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                contextual_grounding_filter_config_property = bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty(
                    action="action",
                    enabled=False,
                    threshold=123,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__02293b13fae70be04a0095ff115ce4ce1fab7d1a81e40e87d6472776d5c61916)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
                check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action is not None:
                self._values["action"] = action
            if enabled is not None:
                self._values["enabled"] = enabled
            if threshold is not None:
                self._values["threshold"] = threshold
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingfilterconfig.html#cfn-bedrock-guardrail-contextualgroundingfilterconfig-action
            '''
            result = self._values.get("action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable contextual grounding evaluation.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingfilterconfig.html#cfn-bedrock-guardrail-contextualgroundingfilterconfig-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def threshold(self) -> typing.Optional[jsii.Number]:
            '''The threshold details for the guardrails contextual grounding filter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingfilterconfig.html#cfn-bedrock-guardrail-contextualgroundingfilterconfig-threshold
            '''
            result = self._values.get("threshold")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The filter details for the guardrails contextual grounding filter.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingfilterconfig.html#cfn-bedrock-guardrail-contextualgroundingfilterconfig-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContextualGroundingFilterConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"filters_config": "filtersConfig"},
    )
    class ContextualGroundingPolicyConfigProperty:
        def __init__(
            self,
            *,
            filters_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The policy configuration details for the guardrails contextual grounding policy.

            :param filters_config: List of contextual grounding filter configs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingpolicyconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                contextual_grounding_policy_config_property = bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty(
                    filters_config=[bedrock_mixins.CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty(
                        action="action",
                        enabled=False,
                        threshold=123,
                        type="type"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5940cb5f710576c577309e28fb85960786f464162910688011950fe1ecd16384)
                check_type(argname="argument filters_config", value=filters_config, expected_type=type_hints["filters_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if filters_config is not None:
                self._values["filters_config"] = filters_config

        @builtins.property
        def filters_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty"]]]]:
            '''List of contextual grounding filter configs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contextualgroundingpolicyconfig.html#cfn-bedrock-guardrail-contextualgroundingpolicyconfig-filtersconfig
            '''
            result = self._values.get("filters_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContextualGroundingPolicyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"guardrail_profile_arn": "guardrailProfileArn"},
    )
    class GuardrailCrossRegionConfigProperty:
        def __init__(
            self,
            *,
            guardrail_profile_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The system-defined guardrail profile that you're using with your guardrail.

            Guardrail profiles define the destination AWS Regions where guardrail inference requests can be automatically routed. Using guardrail profiles helps maintain guardrail performance and reliability when demand increases.

            For more information, see the `Amazon Bedrock User Guide <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .

            :param guardrail_profile_arn: The Amazon Resource Name (ARN) of the guardrail profile that your guardrail is using. Guardrail profile availability depends on your current AWS Region . For more information, see the `Amazon Bedrock User Guide <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region-support.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-guardrailcrossregionconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                guardrail_cross_region_config_property = bedrock_mixins.CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty(
                    guardrail_profile_arn="guardrailProfileArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__89236e14820d566994623ae9e18144039223b3db4a98ebfc959c8be783d89bc4)
                check_type(argname="argument guardrail_profile_arn", value=guardrail_profile_arn, expected_type=type_hints["guardrail_profile_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if guardrail_profile_arn is not None:
                self._values["guardrail_profile_arn"] = guardrail_profile_arn

        @builtins.property
        def guardrail_profile_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the guardrail profile that your guardrail is using.

            Guardrail profile availability depends on your current AWS Region . For more information, see the `Amazon Bedrock User Guide <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region-support.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-guardrailcrossregionconfig.html#cfn-bedrock-guardrail-guardrailcrossregionconfig-guardrailprofilearn
            '''
            result = self._values.get("guardrail_profile_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "GuardrailCrossRegionConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.ManagedWordsConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "input_action": "inputAction",
            "input_enabled": "inputEnabled",
            "output_action": "outputAction",
            "output_enabled": "outputEnabled",
            "type": "type",
        },
    )
    class ManagedWordsConfigProperty:
        def __init__(
            self,
            *,
            input_action: typing.Optional[builtins.str] = None,
            input_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            output_action: typing.Optional[builtins.str] = None,
            output_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The managed word list to configure for the guardrail.

            :param input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param type: The managed word type to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                managed_words_config_property = bedrock_mixins.CfnGuardrailPropsMixin.ManagedWordsConfigProperty(
                    input_action="inputAction",
                    input_enabled=False,
                    output_action="outputAction",
                    output_enabled=False,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__69cc098cb7a3f5ebab1da461c6948ed33ecd6ee6203ba9dc4732d8fc7e15479f)
                check_type(argname="argument input_action", value=input_action, expected_type=type_hints["input_action"])
                check_type(argname="argument input_enabled", value=input_enabled, expected_type=type_hints["input_enabled"])
                check_type(argname="argument output_action", value=output_action, expected_type=type_hints["output_action"])
                check_type(argname="argument output_enabled", value=output_enabled, expected_type=type_hints["output_enabled"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_action is not None:
                self._values["input_action"] = input_action
            if input_enabled is not None:
                self._values["input_enabled"] = input_enabled
            if output_action is not None:
                self._values["output_action"] = output_action
            if output_enabled is not None:
                self._values["output_enabled"] = output_enabled
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def input_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the input. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html#cfn-bedrock-guardrail-managedwordsconfig-inputaction
            '''
            result = self._values.get("input_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the input.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html#cfn-bedrock-guardrail-managedwordsconfig-inputenabled
            '''
            result = self._values.get("input_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def output_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the output. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html#cfn-bedrock-guardrail-managedwordsconfig-outputaction
            '''
            result = self._values.get("output_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the output.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html#cfn-bedrock-guardrail-managedwordsconfig-outputenabled
            '''
            result = self._values.get("output_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The managed word type to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html#cfn-bedrock-guardrail-managedwordsconfig-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ManagedWordsConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.PiiEntityConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "input_action": "inputAction",
            "input_enabled": "inputEnabled",
            "output_action": "outputAction",
            "output_enabled": "outputEnabled",
            "type": "type",
        },
    )
    class PiiEntityConfigProperty:
        def __init__(
            self,
            *,
            action: typing.Optional[builtins.str] = None,
            input_action: typing.Optional[builtins.str] = None,
            input_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            output_action: typing.Optional[builtins.str] = None,
            output_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The PII entity to configure for the guardrail.

            :param action: Configure guardrail action when the PII entity is detected.
            :param input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``ANONYMIZE`` – Mask the content and replace it with identifier tags. - ``NONE`` – Take no action but return detection information in the trace response.
            :param input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``ANONYMIZE`` – Mask the content and replace it with identifier tags. - ``NONE`` – Take no action but return detection information in the trace response.
            :param output_enabled: Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param type: Configure guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information: - *General* - *ADDRESS* A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood. - *AGE* An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age. - *NAME* An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address. - *EMAIL* An email address, such as *marymajor@email.com* . - *PHONE* A phone number. This entity type also includes fax and pager numbers. - *USERNAME* A user name that identifies an account, such as a login name, screen name, nick name, or handle. - *PASSWORD* An alphanumeric string that is used as a password, such as "* *very20special#pass** ". - *DRIVER_ID* The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters. - *LICENSE_PLATE* A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country. - *VEHICLE_IDENTIFICATION_NUMBER* A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs. - *Finance* - *CREDIT_DEBIT_CARD_CVV* A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code. - *CREDIT_DEBIT_CARD_EXPIRY* The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* . - *CREDIT_DEBIT_CARD_NUMBER* The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present. - *PIN* A four-digit personal identification number (PIN) with which you can access your bank account. - *INTERNATIONAL_BANK_ACCOUNT_NUMBER* An International Bank Account Number has specific formats in each country. For more information, see `www.iban.com/structure <https://docs.aws.amazon.com/https://www.iban.com/structure>`_ . - *SWIFT_CODE* A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office. - *IT* - *IP_ADDRESS* An IPv4 address, such as *198.51.100.0* . - *MAC_ADDRESS* A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC). - *URL* A web address, such as *www.example.com* . - *AWS_ACCESS_KEY* A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically. - *AWS_SECRET_KEY* A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically. - *USA specific* - *US_BANK_ACCOUNT_NUMBER* A US bank account number, which is typically 10 to 12 digits long. - *US_BANK_ROUTING_NUMBER* A US bank account routing number. These are typically nine digits long, - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER* A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits. - *US_PASSPORT_NUMBER* A US passport number. Passport numbers range from six to nine alphanumeric characters. - *US_SOCIAL_SECURITY_NUMBER* A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents. - *Canada specific* - *CA_HEALTH_NUMBER* A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits. - *CA_SOCIAL_INSURANCE_NUMBER* A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the `Luhn algorithm <https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm>`_ . - *UK Specific* - *UK_NATIONAL_HEALTH_SERVICE_NUMBER* A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum. - *UK_NATIONAL_INSURANCE_NUMBER* A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits. - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER* A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business. - *Custom* - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                pii_entity_config_property = bedrock_mixins.CfnGuardrailPropsMixin.PiiEntityConfigProperty(
                    action="action",
                    input_action="inputAction",
                    input_enabled=False,
                    output_action="outputAction",
                    output_enabled=False,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__823ce9598cf1266cf5ca42e7d16f55633a44b2e9184dcc6eadf7fdfecc2905ae)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument input_action", value=input_action, expected_type=type_hints["input_action"])
                check_type(argname="argument input_enabled", value=input_enabled, expected_type=type_hints["input_enabled"])
                check_type(argname="argument output_action", value=output_action, expected_type=type_hints["output_action"])
                check_type(argname="argument output_enabled", value=output_enabled, expected_type=type_hints["output_enabled"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action is not None:
                self._values["action"] = action
            if input_action is not None:
                self._values["input_action"] = input_action
            if input_enabled is not None:
                self._values["input_enabled"] = input_enabled
            if output_action is not None:
                self._values["output_action"] = output_action
            if output_enabled is not None:
                self._values["output_enabled"] = output_enabled
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def action(self) -> typing.Optional[builtins.str]:
            '''Configure guardrail action when the PII entity is detected.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html#cfn-bedrock-guardrail-piientityconfig-action
            '''
            result = self._values.get("action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the input. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``ANONYMIZE`` – Mask the content and replace it with identifier tags.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html#cfn-bedrock-guardrail-piientityconfig-inputaction
            '''
            result = self._values.get("input_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the input.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html#cfn-bedrock-guardrail-piientityconfig-inputenabled
            '''
            result = self._values.get("input_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def output_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the output. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``ANONYMIZE`` – Mask the content and replace it with identifier tags.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html#cfn-bedrock-guardrail-piientityconfig-outputaction
            '''
            result = self._values.get("output_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Indicates whether guardrail evaluation is enabled on the output.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html#cfn-bedrock-guardrail-piientityconfig-outputenabled
            '''
            result = self._values.get("output_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Configure guardrail type when the PII entity is detected.

            The following PIIs are used to block or mask sensitive information:

            - *General*
            - *ADDRESS*

            A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.

            - *AGE*

            An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.

            - *NAME*

            An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.

            - *EMAIL*

            An email address, such as *marymajor@email.com* .

            - *PHONE*

            A phone number. This entity type also includes fax and pager numbers.

            - *USERNAME*

            A user name that identifies an account, such as a login name, screen name, nick name, or handle.

            - *PASSWORD*

            An alphanumeric string that is used as a password, such as "* *very20special#pass** ".

            - *DRIVER_ID*

            The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.

            - *LICENSE_PLATE*

            A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.

            - *VEHICLE_IDENTIFICATION_NUMBER*

            A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.

            - *Finance*
            - *CREDIT_DEBIT_CARD_CVV*

            A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.

            - *CREDIT_DEBIT_CARD_EXPIRY*

            The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .

            - *CREDIT_DEBIT_CARD_NUMBER*

            The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.

            - *PIN*

            A four-digit personal identification number (PIN) with which you can access your bank account.

            - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*

            An International Bank Account Number has specific formats in each country. For more information, see `www.iban.com/structure <https://docs.aws.amazon.com/https://www.iban.com/structure>`_ .

            - *SWIFT_CODE*

            A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.

            SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.

            - *IT*
            - *IP_ADDRESS*

            An IPv4 address, such as *198.51.100.0* .

            - *MAC_ADDRESS*

            A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).

            - *URL*

            A web address, such as *www.example.com* .

            - *AWS_ACCESS_KEY*

            A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.

            - *AWS_SECRET_KEY*

            A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.

            - *USA specific*
            - *US_BANK_ACCOUNT_NUMBER*

            A US bank account number, which is typically 10 to 12 digits long.

            - *US_BANK_ROUTING_NUMBER*

            A US bank account routing number. These are typically nine digits long,

            - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*

            A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.

            - *US_PASSPORT_NUMBER*

            A US passport number. Passport numbers range from six to nine alphanumeric characters.

            - *US_SOCIAL_SECURITY_NUMBER*

            A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.

            - *Canada specific*
            - *CA_HEALTH_NUMBER*

            A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.

            - *CA_SOCIAL_INSURANCE_NUMBER*

            A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.

            The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the `Luhn algorithm <https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm>`_ .

            - *UK Specific*
            - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*

            A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.

            - *UK_NATIONAL_INSURANCE_NUMBER*

            A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.

            The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.

            - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*

            A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.

            - *Custom*
            - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html#cfn-bedrock-guardrail-piientityconfig-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PiiEntityConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.RegexConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "description": "description",
            "input_action": "inputAction",
            "input_enabled": "inputEnabled",
            "name": "name",
            "output_action": "outputAction",
            "output_enabled": "outputEnabled",
            "pattern": "pattern",
        },
    )
    class RegexConfigProperty:
        def __init__(
            self,
            *,
            action: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            input_action: typing.Optional[builtins.str] = None,
            input_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            name: typing.Optional[builtins.str] = None,
            output_action: typing.Optional[builtins.str] = None,
            output_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            pattern: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The regular expression to configure for the guardrail.

            :param action: The guardrail action to configure when matching regular expression is detected.
            :param description: The description of the regular expression to configure for the guardrail.
            :param input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param name: The name of the regular expression to configure for the guardrail.
            :param output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param pattern: The regular expression pattern to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                regex_config_property = bedrock_mixins.CfnGuardrailPropsMixin.RegexConfigProperty(
                    action="action",
                    description="description",
                    input_action="inputAction",
                    input_enabled=False,
                    name="name",
                    output_action="outputAction",
                    output_enabled=False,
                    pattern="pattern"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8e6cada9e496bd80442b50b547f6b3fff1ec4967107185afe14036b3c31050b3)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument input_action", value=input_action, expected_type=type_hints["input_action"])
                check_type(argname="argument input_enabled", value=input_enabled, expected_type=type_hints["input_enabled"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument output_action", value=output_action, expected_type=type_hints["output_action"])
                check_type(argname="argument output_enabled", value=output_enabled, expected_type=type_hints["output_enabled"])
                check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if action is not None:
                self._values["action"] = action
            if description is not None:
                self._values["description"] = description
            if input_action is not None:
                self._values["input_action"] = input_action
            if input_enabled is not None:
                self._values["input_enabled"] = input_enabled
            if name is not None:
                self._values["name"] = name
            if output_action is not None:
                self._values["output_action"] = output_action
            if output_enabled is not None:
                self._values["output_enabled"] = output_enabled
            if pattern is not None:
                self._values["pattern"] = pattern

        @builtins.property
        def action(self) -> typing.Optional[builtins.str]:
            '''The guardrail action to configure when matching regular expression is detected.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-action
            '''
            result = self._values.get("action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the regular expression to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the input. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-inputaction
            '''
            result = self._values.get("input_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the input.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-inputenabled
            '''
            result = self._values.get("input_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the regular expression to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the output. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-outputaction
            '''
            result = self._values.get("output_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the output.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-outputenabled
            '''
            result = self._values.get("output_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def pattern(self) -> typing.Optional[builtins.str]:
            '''The regular expression pattern to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html#cfn-bedrock-guardrail-regexconfig-pattern
            '''
            result = self._values.get("pattern")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RegexConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "pii_entities_config": "piiEntitiesConfig",
            "regexes_config": "regexesConfig",
        },
    )
    class SensitiveInformationPolicyConfigProperty:
        def __init__(
            self,
            *,
            pii_entities_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.PiiEntityConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            regexes_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.RegexConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Contains details about PII entities and regular expressions to configure for the guardrail.

            :param pii_entities_config: A list of PII entities to configure to the guardrail.
            :param regexes_config: A list of regular expressions to configure to the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-sensitiveinformationpolicyconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                sensitive_information_policy_config_property = bedrock_mixins.CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty(
                    pii_entities_config=[bedrock_mixins.CfnGuardrailPropsMixin.PiiEntityConfigProperty(
                        action="action",
                        input_action="inputAction",
                        input_enabled=False,
                        output_action="outputAction",
                        output_enabled=False,
                        type="type"
                    )],
                    regexes_config=[bedrock_mixins.CfnGuardrailPropsMixin.RegexConfigProperty(
                        action="action",
                        description="description",
                        input_action="inputAction",
                        input_enabled=False,
                        name="name",
                        output_action="outputAction",
                        output_enabled=False,
                        pattern="pattern"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b707c1a2192a8e818aba69da224da18f9d754afcffc4c8fb3f135db5539e51fa)
                check_type(argname="argument pii_entities_config", value=pii_entities_config, expected_type=type_hints["pii_entities_config"])
                check_type(argname="argument regexes_config", value=regexes_config, expected_type=type_hints["regexes_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if pii_entities_config is not None:
                self._values["pii_entities_config"] = pii_entities_config
            if regexes_config is not None:
                self._values["regexes_config"] = regexes_config

        @builtins.property
        def pii_entities_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.PiiEntityConfigProperty"]]]]:
            '''A list of PII entities to configure to the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-sensitiveinformationpolicyconfig.html#cfn-bedrock-guardrail-sensitiveinformationpolicyconfig-piientitiesconfig
            '''
            result = self._values.get("pii_entities_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.PiiEntityConfigProperty"]]]], result)

        @builtins.property
        def regexes_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.RegexConfigProperty"]]]]:
            '''A list of regular expressions to configure to the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-sensitiveinformationpolicyconfig.html#cfn-bedrock-guardrail-sensitiveinformationpolicyconfig-regexesconfig
            '''
            result = self._values.get("regexes_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.RegexConfigProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SensitiveInformationPolicyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.TopicConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "definition": "definition",
            "examples": "examples",
            "input_action": "inputAction",
            "input_enabled": "inputEnabled",
            "name": "name",
            "output_action": "outputAction",
            "output_enabled": "outputEnabled",
            "type": "type",
        },
    )
    class TopicConfigProperty:
        def __init__(
            self,
            *,
            definition: typing.Optional[builtins.str] = None,
            examples: typing.Optional[typing.Sequence[builtins.str]] = None,
            input_action: typing.Optional[builtins.str] = None,
            input_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            name: typing.Optional[builtins.str] = None,
            output_action: typing.Optional[builtins.str] = None,
            output_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Details about topics for the guardrail to identify and deny.

            :param definition: A definition of the topic to deny.
            :param examples: A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
            :param input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param name: The name of the topic to deny.
            :param output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param type: Specifies to deny the topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                topic_config_property = bedrock_mixins.CfnGuardrailPropsMixin.TopicConfigProperty(
                    definition="definition",
                    examples=["examples"],
                    input_action="inputAction",
                    input_enabled=False,
                    name="name",
                    output_action="outputAction",
                    output_enabled=False,
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3dfb43acf06c09ff51e39973ab1d3857d2acf7a81e65a5fcc0344d5e01421b6d)
                check_type(argname="argument definition", value=definition, expected_type=type_hints["definition"])
                check_type(argname="argument examples", value=examples, expected_type=type_hints["examples"])
                check_type(argname="argument input_action", value=input_action, expected_type=type_hints["input_action"])
                check_type(argname="argument input_enabled", value=input_enabled, expected_type=type_hints["input_enabled"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument output_action", value=output_action, expected_type=type_hints["output_action"])
                check_type(argname="argument output_enabled", value=output_enabled, expected_type=type_hints["output_enabled"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if definition is not None:
                self._values["definition"] = definition
            if examples is not None:
                self._values["examples"] = examples
            if input_action is not None:
                self._values["input_action"] = input_action
            if input_enabled is not None:
                self._values["input_enabled"] = input_enabled
            if name is not None:
                self._values["name"] = name
            if output_action is not None:
                self._values["output_action"] = output_action
            if output_enabled is not None:
                self._values["output_enabled"] = output_enabled
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def definition(self) -> typing.Optional[builtins.str]:
            '''A definition of the topic to deny.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-definition
            '''
            result = self._values.get("definition")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def examples(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-examples
            '''
            result = self._values.get("examples")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def input_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the input. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-inputaction
            '''
            result = self._values.get("input_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the input.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-inputenabled
            '''
            result = self._values.get("input_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the topic to deny.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the output. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-outputaction
            '''
            result = self._values.get("output_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the output.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-outputenabled
            '''
            result = self._values.get("output_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Specifies to deny the topic.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html#cfn-bedrock-guardrail-topicconfig-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TopicConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.TopicPolicyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "topics_config": "topicsConfig",
            "topics_tier_config": "topicsTierConfig",
        },
    )
    class TopicPolicyConfigProperty:
        def __init__(
            self,
            *,
            topics_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.TopicConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            topics_tier_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.TopicsTierConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains details about topics that the guardrail should identify and deny.

            :param topics_config: A list of policies related to topics that the guardrail should deny.
            :param topics_tier_config: The tier that your guardrail uses for denied topic filters.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicpolicyconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                topic_policy_config_property = bedrock_mixins.CfnGuardrailPropsMixin.TopicPolicyConfigProperty(
                    topics_config=[bedrock_mixins.CfnGuardrailPropsMixin.TopicConfigProperty(
                        definition="definition",
                        examples=["examples"],
                        input_action="inputAction",
                        input_enabled=False,
                        name="name",
                        output_action="outputAction",
                        output_enabled=False,
                        type="type"
                    )],
                    topics_tier_config=bedrock_mixins.CfnGuardrailPropsMixin.TopicsTierConfigProperty(
                        tier_name="tierName"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ec21e6fa622cb554f41404e92e6dbd72d8c4bd6a0e3ffad715af74fdc7ae67f5)
                check_type(argname="argument topics_config", value=topics_config, expected_type=type_hints["topics_config"])
                check_type(argname="argument topics_tier_config", value=topics_tier_config, expected_type=type_hints["topics_tier_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if topics_config is not None:
                self._values["topics_config"] = topics_config
            if topics_tier_config is not None:
                self._values["topics_tier_config"] = topics_tier_config

        @builtins.property
        def topics_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.TopicConfigProperty"]]]]:
            '''A list of policies related to topics that the guardrail should deny.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicpolicyconfig.html#cfn-bedrock-guardrail-topicpolicyconfig-topicsconfig
            '''
            result = self._values.get("topics_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.TopicConfigProperty"]]]], result)

        @builtins.property
        def topics_tier_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.TopicsTierConfigProperty"]]:
            '''The tier that your guardrail uses for denied topic filters.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicpolicyconfig.html#cfn-bedrock-guardrail-topicpolicyconfig-topicstierconfig
            '''
            result = self._values.get("topics_tier_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.TopicsTierConfigProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TopicPolicyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.TopicsTierConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"tier_name": "tierName"},
    )
    class TopicsTierConfigProperty:
        def __init__(self, *, tier_name: typing.Optional[builtins.str] = None) -> None:
            '''The tier that your guardrail uses for denied topic filters.

            Consider using a tier that balances performance, accuracy, and compatibility with your existing generative AI workflows.

            :param tier_name: The tier that your guardrail uses for denied topic filters. Valid values include:. - ``CLASSIC`` tier – Provides established guardrails functionality supporting English, French, and Spanish languages. - ``STANDARD`` tier – Provides a more robust solution than the ``CLASSIC`` tier and has more comprehensive language support. This tier requires that your guardrail use `cross-Region inference <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicstierconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                topics_tier_config_property = bedrock_mixins.CfnGuardrailPropsMixin.TopicsTierConfigProperty(
                    tier_name="tierName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6bbfd7fe562254e324fc3fc505f82017dc1e6274cd2f13253e2a97e3bf2120eb)
                check_type(argname="argument tier_name", value=tier_name, expected_type=type_hints["tier_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if tier_name is not None:
                self._values["tier_name"] = tier_name

        @builtins.property
        def tier_name(self) -> typing.Optional[builtins.str]:
            '''The tier that your guardrail uses for denied topic filters. Valid values include:.

            - ``CLASSIC`` tier – Provides established guardrails functionality supporting English, French, and Spanish languages.
            - ``STANDARD`` tier – Provides a more robust solution than the ``CLASSIC`` tier and has more comprehensive language support. This tier requires that your guardrail use `cross-Region inference <https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicstierconfig.html#cfn-bedrock-guardrail-topicstierconfig-tiername
            '''
            result = self._values.get("tier_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TopicsTierConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.WordConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "input_action": "inputAction",
            "input_enabled": "inputEnabled",
            "output_action": "outputAction",
            "output_enabled": "outputEnabled",
            "text": "text",
        },
    )
    class WordConfigProperty:
        def __init__(
            self,
            *,
            input_action: typing.Optional[builtins.str] = None,
            input_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            output_action: typing.Optional[builtins.str] = None,
            output_enabled: typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A word to configure for the guardrail.

            :param input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param input_enabled: Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:. - ``BLOCK`` – Block the content and replace it with blocked messaging. - ``NONE`` – Take no action but return detection information in the trace response.
            :param output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
            :param text: Text of the word configured for the guardrail to block.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                word_config_property = bedrock_mixins.CfnGuardrailPropsMixin.WordConfigProperty(
                    input_action="inputAction",
                    input_enabled=False,
                    output_action="outputAction",
                    output_enabled=False,
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e2a6f246ba2fcefc8397b00b442717ce0fd0435f86d11de5f98facddfe218f7b)
                check_type(argname="argument input_action", value=input_action, expected_type=type_hints["input_action"])
                check_type(argname="argument input_enabled", value=input_enabled, expected_type=type_hints["input_enabled"])
                check_type(argname="argument output_action", value=output_action, expected_type=type_hints["output_action"])
                check_type(argname="argument output_enabled", value=output_enabled, expected_type=type_hints["output_enabled"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_action is not None:
                self._values["input_action"] = input_action
            if input_enabled is not None:
                self._values["input_enabled"] = input_enabled
            if output_action is not None:
                self._values["output_action"] = output_action
            if output_enabled is not None:
                self._values["output_enabled"] = output_enabled
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def input_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the input. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html#cfn-bedrock-guardrail-wordconfig-inputaction
            '''
            result = self._values.get("input_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the intput.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html#cfn-bedrock-guardrail-wordconfig-inputenabled
            '''
            result = self._values.get("input_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def output_action(self) -> typing.Optional[builtins.str]:
            '''Specifies the action to take when harmful content is detected in the output. Supported values include:.

            - ``BLOCK`` – Block the content and replace it with blocked messaging.
            - ``NONE`` – Take no action but return detection information in the trace response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html#cfn-bedrock-guardrail-wordconfig-outputaction
            '''
            result = self._values.get("output_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def output_enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]]:
            '''Specifies whether to enable guardrail evaluation on the output.

            When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html#cfn-bedrock-guardrail-wordconfig-outputenabled
            '''
            result = self._values.get("output_enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, "_aws_cdk_ceddda9d.IResolvable"]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''Text of the word configured for the guardrail to block.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html#cfn-bedrock-guardrail-wordconfig-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "WordConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailPropsMixin.WordPolicyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "managed_word_lists_config": "managedWordListsConfig",
            "words_config": "wordsConfig",
        },
    )
    class WordPolicyConfigProperty:
        def __init__(
            self,
            *,
            managed_word_lists_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.ManagedWordsConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            words_config: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnGuardrailPropsMixin.WordConfigProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Contains details about the word policy to configured for the guardrail.

            :param managed_word_lists_config: A list of managed words to configure for the guardrail.
            :param words_config: A list of words to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordpolicyconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                word_policy_config_property = bedrock_mixins.CfnGuardrailPropsMixin.WordPolicyConfigProperty(
                    managed_word_lists_config=[bedrock_mixins.CfnGuardrailPropsMixin.ManagedWordsConfigProperty(
                        input_action="inputAction",
                        input_enabled=False,
                        output_action="outputAction",
                        output_enabled=False,
                        type="type"
                    )],
                    words_config=[bedrock_mixins.CfnGuardrailPropsMixin.WordConfigProperty(
                        input_action="inputAction",
                        input_enabled=False,
                        output_action="outputAction",
                        output_enabled=False,
                        text="text"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c8d2527c1e2184264d87498c5373ac6b6d605c2564aaa8e7e39ddae89590d923)
                check_type(argname="argument managed_word_lists_config", value=managed_word_lists_config, expected_type=type_hints["managed_word_lists_config"])
                check_type(argname="argument words_config", value=words_config, expected_type=type_hints["words_config"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if managed_word_lists_config is not None:
                self._values["managed_word_lists_config"] = managed_word_lists_config
            if words_config is not None:
                self._values["words_config"] = words_config

        @builtins.property
        def managed_word_lists_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ManagedWordsConfigProperty"]]]]:
            '''A list of managed words to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordpolicyconfig.html#cfn-bedrock-guardrail-wordpolicyconfig-managedwordlistsconfig
            '''
            result = self._values.get("managed_word_lists_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.ManagedWordsConfigProperty"]]]], result)

        @builtins.property
        def words_config(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.WordConfigProperty"]]]]:
            '''A list of words to configure for the guardrail.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordpolicyconfig.html#cfn-bedrock-guardrail-wordpolicyconfig-wordsconfig
            '''
            result = self._values.get("words_config")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnGuardrailPropsMixin.WordConfigProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "WordPolicyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailVersionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "guardrail_identifier": "guardrailIdentifier",
    },
)
class CfnGuardrailVersionMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        guardrail_identifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for CfnGuardrailVersionPropsMixin.

        :param description: A description of the guardrail version.
        :param guardrail_identifier: The unique identifier of the guardrail. This can be an ID or the ARN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrailversion.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_guardrail_version_mixin_props = bedrock_mixins.CfnGuardrailVersionMixinProps(
                description="description",
                guardrail_identifier="guardrailIdentifier"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e802ed21befad15c92612df9e126cc6b3ed815c71591a8178ac87b14bb6a2816)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument guardrail_identifier", value=guardrail_identifier, expected_type=type_hints["guardrail_identifier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if guardrail_identifier is not None:
            self._values["guardrail_identifier"] = guardrail_identifier

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the guardrail version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrailversion.html#cfn-bedrock-guardrailversion-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def guardrail_identifier(self) -> typing.Optional[builtins.str]:
        '''The unique identifier of the guardrail.

        This can be an ID or the ARN.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrailversion.html#cfn-bedrock-guardrailversion-guardrailidentifier
        '''
        result = self._values.get("guardrail_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnGuardrailVersionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnGuardrailVersionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnGuardrailVersionPropsMixin",
):
    '''Creates a version of the guardrail.

    Use this API to create a snapshot of the guardrail when you are satisfied with a configuration, or to compare the configuration with another version.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrailversion.html
    :cloudformationResource: AWS::Bedrock::GuardrailVersion
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_guardrail_version_props_mixin = bedrock_mixins.CfnGuardrailVersionPropsMixin(bedrock_mixins.CfnGuardrailVersionMixinProps(
            description="description",
            guardrail_identifier="guardrailIdentifier"
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnGuardrailVersionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::GuardrailVersion``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c04c78fada86ca507468283c1d133c07485e6c920d0725626ec92a8d1b8c8007)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a1a8b19b3904268970102f42813ba3e79b419b7a74b548d473f9aa55bc90e4f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64c0726887e78275bb24387fd90b3845f585e3b0899b4fc9ba6200fe4c9055e6)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnGuardrailVersionMixinProps":
        return typing.cast("CfnGuardrailVersionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnIntelligentPromptRouterMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "fallback_model": "fallbackModel",
        "models": "models",
        "prompt_router_name": "promptRouterName",
        "routing_criteria": "routingCriteria",
        "tags": "tags",
    },
)
class CfnIntelligentPromptRouterMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        fallback_model: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        models: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        prompt_router_name: typing.Optional[builtins.str] = None,
        routing_criteria: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["_aws_cdk_ceddda9d.CfnTag", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for CfnIntelligentPromptRouterPropsMixin.

        :param description: An optional description of the prompt router to help identify its purpose.
        :param fallback_model: The default model to use when the routing criteria is not met.
        :param models: A list of foundation models that the prompt router can route requests to. At least one model must be specified.
        :param prompt_router_name: The name of the prompt router. The name must be unique within your AWS account in the current region.
        :param routing_criteria: Routing criteria for a prompt router.
        :param tags: An array of key-value pairs to apply to this resource as tags. You can use tags to categorize and manage your AWS resources.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html
        :exampleMetadata: fixture=_generated

        Example::

            from aws_cdk import CfnTag
            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_intelligent_prompt_router_mixin_props = bedrock_mixins.CfnIntelligentPromptRouterMixinProps(
                description="description",
                fallback_model=bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty(
                    model_arn="modelArn"
                ),
                models=[bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty(
                    model_arn="modelArn"
                )],
                prompt_router_name="promptRouterName",
                routing_criteria=bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty(
                    response_quality_difference=123
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecf739d087942a6f8daf151f53c06477208e4413268bbca4d3203137d96c4ac3)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument fallback_model", value=fallback_model, expected_type=type_hints["fallback_model"])
            check_type(argname="argument models", value=models, expected_type=type_hints["models"])
            check_type(argname="argument prompt_router_name", value=prompt_router_name, expected_type=type_hints["prompt_router_name"])
            check_type(argname="argument routing_criteria", value=routing_criteria, expected_type=type_hints["routing_criteria"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if fallback_model is not None:
            self._values["fallback_model"] = fallback_model
        if models is not None:
            self._values["models"] = models
        if prompt_router_name is not None:
            self._values["prompt_router_name"] = prompt_router_name
        if routing_criteria is not None:
            self._values["routing_criteria"] = routing_criteria
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''An optional description of the prompt router to help identify its purpose.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html#cfn-bedrock-intelligentpromptrouter-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fallback_model(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty"]]:
        '''The default model to use when the routing criteria is not met.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html#cfn-bedrock-intelligentpromptrouter-fallbackmodel
        '''
        result = self._values.get("fallback_model")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty"]], result)

    @builtins.property
    def models(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty"]]]]:
        '''A list of foundation models that the prompt router can route requests to.

        At least one model must be specified.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html#cfn-bedrock-intelligentpromptrouter-models
        '''
        result = self._values.get("models")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty"]]]], result)

    @builtins.property
    def prompt_router_name(self) -> typing.Optional[builtins.str]:
        '''The name of the prompt router.

        The name must be unique within your AWS account in the current region.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html#cfn-bedrock-intelligentpromptrouter-promptroutername
        '''
        result = self._values.get("prompt_router_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def routing_criteria(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty"]]:
        '''Routing criteria for a prompt router.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html#cfn-bedrock-intelligentpromptrouter-routingcriteria
        '''
        result = self._values.get("routing_criteria")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]]:
        '''An array of key-value pairs to apply to this resource as tags.

        You can use tags to categorize and manage your AWS resources.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html#cfn-bedrock-intelligentpromptrouter-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List["_aws_cdk_ceddda9d.CfnTag"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIntelligentPromptRouterMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnIntelligentPromptRouterPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnIntelligentPromptRouterPropsMixin",
):
    '''Specifies an intelligent prompt router resource for Amazon Bedrock .

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-intelligentpromptrouter.html
    :cloudformationResource: AWS::Bedrock::IntelligentPromptRouter
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        from aws_cdk import CfnTag
        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_intelligent_prompt_router_props_mixin = bedrock_mixins.CfnIntelligentPromptRouterPropsMixin(bedrock_mixins.CfnIntelligentPromptRouterMixinProps(
            description="description",
            fallback_model=bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty(
                model_arn="modelArn"
            ),
            models=[bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty(
                model_arn="modelArn"
            )],
            prompt_router_name="promptRouterName",
            routing_criteria=bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty(
                response_quality_difference=123
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnIntelligentPromptRouterMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::IntelligentPromptRouter``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04d46997c0584923fd6658d5f579cb74d760d8af022dedd9e386efbc7dcd1b95)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3651fba3fa3fb86e0a4b6911999b521945377de01ea59eb560223296d012a458)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__624f71067ee5280bd63481c4d400e46604d315b2bd69361320ba847b720e04b5)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnIntelligentPromptRouterMixinProps":
        return typing.cast("CfnIntelligentPromptRouterMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty",
        jsii_struct_bases=[],
        name_mapping={"model_arn": "modelArn"},
    )
    class PromptRouterTargetModelProperty:
        def __init__(self, *, model_arn: typing.Optional[builtins.str] = None) -> None:
            '''The target model for a prompt router.

            :param model_arn: The target model's ARN.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-intelligentpromptrouter-promptroutertargetmodel.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_router_target_model_property = bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty(
                    model_arn="modelArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__55ac521ae724ee1ed89c9cf21b3009f3952e6d7c05f2b51194b1aa43f87096bf)
                check_type(argname="argument model_arn", value=model_arn, expected_type=type_hints["model_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if model_arn is not None:
                self._values["model_arn"] = model_arn

        @builtins.property
        def model_arn(self) -> typing.Optional[builtins.str]:
            '''The target model's ARN.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-intelligentpromptrouter-promptroutertargetmodel.html#cfn-bedrock-intelligentpromptrouter-promptroutertargetmodel-modelarn
            '''
            result = self._values.get("model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptRouterTargetModelProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty",
        jsii_struct_bases=[],
        name_mapping={"response_quality_difference": "responseQualityDifference"},
    )
    class RoutingCriteriaProperty:
        def __init__(
            self,
            *,
            response_quality_difference: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Routing criteria for a prompt router.

            :param response_quality_difference: The criteria's response quality difference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-intelligentpromptrouter-routingcriteria.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                routing_criteria_property = bedrock_mixins.CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty(
                    response_quality_difference=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__013dfa7a61f71aa6791ef70827a29471feb991d3da83f1d3d23a92be2c4ce95d)
                check_type(argname="argument response_quality_difference", value=response_quality_difference, expected_type=type_hints["response_quality_difference"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if response_quality_difference is not None:
                self._values["response_quality_difference"] = response_quality_difference

        @builtins.property
        def response_quality_difference(self) -> typing.Optional[jsii.Number]:
            '''The criteria's response quality difference.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-intelligentpromptrouter-routingcriteria.html#cfn-bedrock-intelligentpromptrouter-routingcriteria-responsequalitydifference
            '''
            result = self._values.get("response_quality_difference")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RoutingCriteriaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class CfnKnowledgeBaseApplicationLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBaseApplicationLogs",
):
    '''Builder for CfnKnowledgeBaseLogsMixin to generate APPLICATION_LOGS for CfnKnowledgeBase.

    :cloudformationResource: AWS::Bedrock::KnowledgeBase
    :logType: APPLICATION_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_knowledge_base_application_logs = bedrock_mixins.CfnKnowledgeBaseApplicationLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnKnowledgeBaseLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9afd6c729cd28bbc4b51ff8d18b051d6fa934af37ede9c1342e2cec7553c0695)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnKnowledgeBaseLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnKnowledgeBaseLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf1179280e496ee484ba8c092b53a4d245217292444dcf13687f9cf441a1c0d9)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnKnowledgeBaseLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnKnowledgeBaseLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79b211fa86d8cc8e93265b03b2f86f7c40295361ca54c6cd405ebe4fd27b8e89)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnKnowledgeBaseLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.implements(_IMixin_11e4b965)
class CfnKnowledgeBaseLogsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBaseLogsMixin",
):
    '''Specifies a knowledge base as a resource in a top-level template. Minimally, you must specify the following properties:.

    - Name – Specify a name for the knowledge base.
    - RoleArn – Specify the Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base. For more information, see `Create a service role for Knowledge base for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/kb-permissions.html>`_ .
    - KnowledgeBaseConfiguration – Specify the embeddings configuration of the knowledge base. The following sub-properties are required:
    - Type – Specify the value ``VECTOR`` .
    - StorageConfiguration – Specify information about the vector store in which the data source is stored. The following sub-properties are required:
    - Type – Specify the vector store service that you are using.

    .. epigraph::

       Redis Enterprise Cloud vector stores are currently unsupported in CloudFormation .

    For more information about using knowledge bases in Amazon Bedrock , see `Knowledge base for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html
    :cloudformationResource: AWS::Bedrock::KnowledgeBase
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import aws_logs as logs
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # logs_delivery: logs.ILogsDelivery
        
        cfn_knowledge_base_logs_mixin = bedrock_mixins.CfnKnowledgeBaseLogsMixin("logType", logs_delivery)
    '''

    def __init__(
        self,
        log_type: builtins.str,
        log_delivery: "_ILogsDelivery_0d3c9e29",
    ) -> None:
        '''Create a mixin to enable vended logs for ``AWS::Bedrock::KnowledgeBase``.

        :param log_type: Type of logs that are getting vended.
        :param log_delivery: Object in charge of setting up the delivery source, delivery destination, and delivery connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bcb29991e4e19c615e1385fd0d477b8d4c01c3caacbea038045566a98c009f7)
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument log_delivery", value=log_delivery, expected_type=type_hints["log_delivery"])
        jsii.create(self.__class__, self, [log_type, log_delivery])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        resource: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply vended logs configuration to the construct.

        :param resource: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__975a69d7e7aa49b74e579ee108e7a20efec4c4b71d438ad5e697b23d180deeb3)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [resource]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct (has vendedLogs property).

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26725175212e581ad90f4417adcc6893a188dd434926ebfa21c2126f2ceac3c9)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_LOGS")
    def APPLICATION_LOGS(cls) -> "CfnKnowledgeBaseApplicationLogs":
        return typing.cast("CfnKnowledgeBaseApplicationLogs", jsii.sget(cls, "APPLICATION_LOGS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RUNTIME_LOGS")
    def RUNTIME_LOGS(cls) -> "CfnKnowledgeBaseRuntimeLogs":
        return typing.cast("CfnKnowledgeBaseRuntimeLogs", jsii.sget(cls, "RUNTIME_LOGS"))

    @builtins.property
    @jsii.member(jsii_name="logDelivery")
    def _log_delivery(self) -> "_ILogsDelivery_0d3c9e29":
        return typing.cast("_ILogsDelivery_0d3c9e29", jsii.get(self, "logDelivery"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def _log_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logType"))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBaseMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "knowledge_base_configuration": "knowledgeBaseConfiguration",
        "name": "name",
        "role_arn": "roleArn",
        "storage_configuration": "storageConfiguration",
        "tags": "tags",
    },
)
class CfnKnowledgeBaseMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        knowledge_base_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        role_arn: typing.Optional[builtins.str] = None,
        storage_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.StorageConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for CfnKnowledgeBasePropsMixin.

        :param description: The description of the knowledge base associated with the inline agent.
        :param knowledge_base_configuration: Contains details about the embeddings configuration of the knowledge base.
        :param name: The name of the knowledge base.
        :param role_arn: The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        :param storage_configuration: Contains details about the storage configuration of the knowledge base.
        :param tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_knowledge_base_mixin_props = bedrock_mixins.CfnKnowledgeBaseMixinProps(
                description="description",
                knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty(
                    kendra_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty(
                        kendra_index_arn="kendraIndexArn"
                    ),
                    sql_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty(
                        redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty(
                            query_engine_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty(
                                provisioned_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                                    auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                                        database_user="databaseUser",
                                        type="type",
                                        username_password_secret_arn="usernamePasswordSecretArn"
                                    ),
                                    cluster_identifier="clusterIdentifier"
                                ),
                                serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                                    auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                                        type="type",
                                        username_password_secret_arn="usernamePasswordSecretArn"
                                    ),
                                    workgroup_arn="workgroupArn"
                                ),
                                type="type"
                            ),
                            query_generation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty(
                                execution_timeout_seconds=123,
                                generation_context=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                                    curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                                        natural_language="naturalLanguage",
                                        sql="sql"
                                    )],
                                    tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                                        columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                                            description="description",
                                            inclusion="inclusion",
                                            name="name"
                                        )],
                                        description="description",
                                        inclusion="inclusion",
                                        name="name"
                                    )]
                                )
                            ),
                            storage_configurations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty(
                                aws_data_catalog_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                                    table_names=["tableNames"]
                                ),
                                redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                                    database_name="databaseName"
                                ),
                                type="type"
                            )]
                        ),
                        type="type"
                    ),
                    type="type",
                    vector_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty(
                        embedding_model_arn="embeddingModelArn",
                        embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty(
                            bedrock_embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty(
                                audio=[bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                                    segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                                        fixed_length_duration=123
                                    )
                                )],
                                dimensions=123,
                                embedding_data_type="embeddingDataType",
                                video=[bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                                    segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                                        fixed_length_duration=123
                                    )
                                )]
                            )
                        ),
                        supplemental_data_storage_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty(
                            supplemental_data_storage_locations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty(
                                s3_location=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                                    uri="uri"
                                ),
                                supplemental_data_storage_location_type="supplementalDataStorageLocationType"
                            )]
                        )
                    )
                ),
                name="name",
                role_arn="roleArn",
                storage_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.StorageConfigurationProperty(
                    mongo_db_atlas_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty(
                        collection_name="collectionName",
                        credentials_secret_arn="credentialsSecretArn",
                        database_name="databaseName",
                        endpoint="endpoint",
                        endpoint_service_name="endpointServiceName",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        text_index_name="textIndexName",
                        vector_index_name="vectorIndexName"
                    ),
                    neptune_analytics_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty(
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField"
                        ),
                        graph_arn="graphArn"
                    ),
                    opensearch_managed_cluster_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty(
                        domain_arn="domainArn",
                        domain_endpoint="domainEndpoint",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        vector_index_name="vectorIndexName"
                    ),
                    opensearch_serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty(
                        collection_arn="collectionArn",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        vector_index_name="vectorIndexName"
                    ),
                    pinecone_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty(
                        connection_string="connectionString",
                        credentials_secret_arn="credentialsSecretArn",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField"
                        ),
                        namespace="namespace"
                    ),
                    rds_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsConfigurationProperty(
                        credentials_secret_arn="credentialsSecretArn",
                        database_name="databaseName",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty(
                            custom_metadata_field="customMetadataField",
                            metadata_field="metadataField",
                            primary_key_field="primaryKeyField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        resource_arn="resourceArn",
                        table_name="tableName"
                    ),
                    s3_vectors_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty(
                        index_arn="indexArn",
                        index_name="indexName",
                        vector_bucket_arn="vectorBucketArn"
                    ),
                    type="type"
                ),
                tags={
                    "tags_key": "tags"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65fbd36f79738468da5552412a92e28305aee7f1def9caa8db28e021c1b2aae1)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument knowledge_base_configuration", value=knowledge_base_configuration, expected_type=type_hints["knowledge_base_configuration"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument storage_configuration", value=storage_configuration, expected_type=type_hints["storage_configuration"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if knowledge_base_configuration is not None:
            self._values["knowledge_base_configuration"] = knowledge_base_configuration
        if name is not None:
            self._values["name"] = name
        if role_arn is not None:
            self._values["role_arn"] = role_arn
        if storage_configuration is not None:
            self._values["storage_configuration"] = storage_configuration
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the knowledge base associated with the inline agent.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html#cfn-bedrock-knowledgebase-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def knowledge_base_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty"]]:
        '''Contains details about the embeddings configuration of the knowledge base.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html#cfn-bedrock-knowledgebase-knowledgebaseconfiguration
        '''
        result = self._values.get("knowledge_base_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the knowledge base.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html#cfn-bedrock-knowledgebase-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html#cfn-bedrock-knowledgebase-rolearn
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_configuration(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.StorageConfigurationProperty"]]:
        '''Contains details about the storage configuration of the knowledge base.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html#cfn-bedrock-knowledgebase-storageconfiguration
        '''
        result = self._values.get("storage_configuration")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.StorageConfigurationProperty"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html#cfn-bedrock-knowledgebase-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnKnowledgeBaseMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnKnowledgeBasePropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin",
):
    '''Specifies a knowledge base as a resource in a top-level template. Minimally, you must specify the following properties:.

    - Name – Specify a name for the knowledge base.
    - RoleArn – Specify the Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base. For more information, see `Create a service role for Knowledge base for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/kb-permissions.html>`_ .
    - KnowledgeBaseConfiguration – Specify the embeddings configuration of the knowledge base. The following sub-properties are required:
    - Type – Specify the value ``VECTOR`` .
    - StorageConfiguration – Specify information about the vector store in which the data source is stored. The following sub-properties are required:
    - Type – Specify the vector store service that you are using.

    .. epigraph::

       Redis Enterprise Cloud vector stores are currently unsupported in CloudFormation .

    For more information about using knowledge bases in Amazon Bedrock , see `Knowledge base for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base.html>`_ .

    See the *Properties* section below for descriptions of both the required and optional properties.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html
    :cloudformationResource: AWS::Bedrock::KnowledgeBase
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_knowledge_base_props_mixin = bedrock_mixins.CfnKnowledgeBasePropsMixin(bedrock_mixins.CfnKnowledgeBaseMixinProps(
            description="description",
            knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty(
                kendra_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty(
                    kendra_index_arn="kendraIndexArn"
                ),
                sql_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty(
                    redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty(
                        query_engine_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty(
                            provisioned_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                                auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                                    database_user="databaseUser",
                                    type="type",
                                    username_password_secret_arn="usernamePasswordSecretArn"
                                ),
                                cluster_identifier="clusterIdentifier"
                            ),
                            serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                                auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                                    type="type",
                                    username_password_secret_arn="usernamePasswordSecretArn"
                                ),
                                workgroup_arn="workgroupArn"
                            ),
                            type="type"
                        ),
                        query_generation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty(
                            execution_timeout_seconds=123,
                            generation_context=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                                curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                                    natural_language="naturalLanguage",
                                    sql="sql"
                                )],
                                tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                                    columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                                        description="description",
                                        inclusion="inclusion",
                                        name="name"
                                    )],
                                    description="description",
                                    inclusion="inclusion",
                                    name="name"
                                )]
                            )
                        ),
                        storage_configurations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty(
                            aws_data_catalog_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                                table_names=["tableNames"]
                            ),
                            redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                                database_name="databaseName"
                            ),
                            type="type"
                        )]
                    ),
                    type="type"
                ),
                type="type",
                vector_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty(
                    embedding_model_arn="embeddingModelArn",
                    embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty(
                        bedrock_embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty(
                            audio=[bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                                segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                                    fixed_length_duration=123
                                )
                            )],
                            dimensions=123,
                            embedding_data_type="embeddingDataType",
                            video=[bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                                segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                                    fixed_length_duration=123
                                )
                            )]
                        )
                    ),
                    supplemental_data_storage_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty(
                        supplemental_data_storage_locations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty(
                            s3_location=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                                uri="uri"
                            ),
                            supplemental_data_storage_location_type="supplementalDataStorageLocationType"
                        )]
                    )
                )
            ),
            name="name",
            role_arn="roleArn",
            storage_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.StorageConfigurationProperty(
                mongo_db_atlas_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty(
                    collection_name="collectionName",
                    credentials_secret_arn="credentialsSecretArn",
                    database_name="databaseName",
                    endpoint="endpoint",
                    endpoint_service_name="endpointServiceName",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    text_index_name="textIndexName",
                    vector_index_name="vectorIndexName"
                ),
                neptune_analytics_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty(
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField"
                    ),
                    graph_arn="graphArn"
                ),
                opensearch_managed_cluster_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty(
                    domain_arn="domainArn",
                    domain_endpoint="domainEndpoint",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    vector_index_name="vectorIndexName"
                ),
                opensearch_serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty(
                    collection_arn="collectionArn",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    vector_index_name="vectorIndexName"
                ),
                pinecone_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty(
                    connection_string="connectionString",
                    credentials_secret_arn="credentialsSecretArn",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField"
                    ),
                    namespace="namespace"
                ),
                rds_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsConfigurationProperty(
                    credentials_secret_arn="credentialsSecretArn",
                    database_name="databaseName",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty(
                        custom_metadata_field="customMetadataField",
                        metadata_field="metadataField",
                        primary_key_field="primaryKeyField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    resource_arn="resourceArn",
                    table_name="tableName"
                ),
                s3_vectors_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty(
                    index_arn="indexArn",
                    index_name="indexName",
                    vector_bucket_arn="vectorBucketArn"
                ),
                type="type"
            ),
            tags={
                "tags_key": "tags"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnKnowledgeBaseMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::KnowledgeBase``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32cfa482e372255d6c05d090583cf9e4e8c2932f8ec2416b9768df00c617e453)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__672ba3e281b72eefc8b0ee8bbfcb412cb42975da2a07c5beb9378938e180179f)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a1f93a7a95be0ab7c9728b7717204499e5d6f62170897f55cad7ce0614cd753)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnKnowledgeBaseMixinProps":
        return typing.cast("CfnKnowledgeBaseMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"segmentation_configuration": "segmentationConfiguration"},
    )
    class AudioConfigurationProperty:
        def __init__(
            self,
            *,
            segmentation_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configuration settings for processing audio content in multimodal knowledge bases.

            :param segmentation_configuration: Configuration for segmenting audio content during processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-audioconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                    segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                        fixed_length_duration=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ba1c6ed6ada509576b985cb30c7184bd37e665c655002aee341409006af6feac)
                check_type(argname="argument segmentation_configuration", value=segmentation_configuration, expected_type=type_hints["segmentation_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if segmentation_configuration is not None:
                self._values["segmentation_configuration"] = segmentation_configuration

        @builtins.property
        def segmentation_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty"]]:
            '''Configuration for segmenting audio content during processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-audioconfiguration.html#cfn-bedrock-knowledgebase-audioconfiguration-segmentationconfiguration
            '''
            result = self._values.get("segmentation_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"fixed_length_duration": "fixedLengthDuration"},
    )
    class AudioSegmentationConfigurationProperty:
        def __init__(
            self,
            *,
            fixed_length_duration: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configuration for segmenting audio content during multimodal knowledge base ingestion.

            Determines how audio files are divided into chunks for processing.

            :param fixed_length_duration: The duration in seconds for each audio segment. Audio files will be divided into chunks of this length for processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-audiosegmentationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                audio_segmentation_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                    fixed_length_duration=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c5927d38ebe38d2a7cc47d3ef0889fd0c661426087a724cfd58d1f5253327557)
                check_type(argname="argument fixed_length_duration", value=fixed_length_duration, expected_type=type_hints["fixed_length_duration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if fixed_length_duration is not None:
                self._values["fixed_length_duration"] = fixed_length_duration

        @builtins.property
        def fixed_length_duration(self) -> typing.Optional[jsii.Number]:
            '''The duration in seconds for each audio segment.

            Audio files will be divided into chunks of this length for processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-audiosegmentationconfiguration.html#cfn-bedrock-knowledgebase-audiosegmentationconfiguration-fixedlengthduration
            '''
            result = self._values.get("fixed_length_duration")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AudioSegmentationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "audio": "audio",
            "dimensions": "dimensions",
            "embedding_data_type": "embeddingDataType",
            "video": "video",
        },
    )
    class BedrockEmbeddingModelConfigurationProperty:
        def __init__(
            self,
            *,
            audio: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.AudioConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            dimensions: typing.Optional[jsii.Number] = None,
            embedding_data_type: typing.Optional[builtins.str] = None,
            video: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.VideoConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''The vector configuration details for the Bedrock embeddings model.

            :param audio: Configuration settings for processing audio content in multimodal knowledge bases.
            :param dimensions: The dimensions details for the vector configuration used on the Bedrock embeddings model.
            :param embedding_data_type: The data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings. Floating-point (float32) is the default data type, and is supported by most models for vector embeddings. See `Supported embeddings models <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-supported.html>`_ for information on the available models and their vector data types.
            :param video: Configuration settings for processing video content in multimodal knowledge bases.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-bedrockembeddingmodelconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                bedrock_embedding_model_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty(
                    audio=[bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                        segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                            fixed_length_duration=123
                        )
                    )],
                    dimensions=123,
                    embedding_data_type="embeddingDataType",
                    video=[bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                        segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                            fixed_length_duration=123
                        )
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__92728f6bfddc8c6ed9bad91ef784f8aeaee42479d5aaa681ca1c400c9206f9c9)
                check_type(argname="argument audio", value=audio, expected_type=type_hints["audio"])
                check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
                check_type(argname="argument embedding_data_type", value=embedding_data_type, expected_type=type_hints["embedding_data_type"])
                check_type(argname="argument video", value=video, expected_type=type_hints["video"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if audio is not None:
                self._values["audio"] = audio
            if dimensions is not None:
                self._values["dimensions"] = dimensions
            if embedding_data_type is not None:
                self._values["embedding_data_type"] = embedding_data_type
            if video is not None:
                self._values["video"] = video

        @builtins.property
        def audio(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.AudioConfigurationProperty"]]]]:
            '''Configuration settings for processing audio content in multimodal knowledge bases.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-bedrockembeddingmodelconfiguration.html#cfn-bedrock-knowledgebase-bedrockembeddingmodelconfiguration-audio
            '''
            result = self._values.get("audio")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.AudioConfigurationProperty"]]]], result)

        @builtins.property
        def dimensions(self) -> typing.Optional[jsii.Number]:
            '''The dimensions details for the vector configuration used on the Bedrock embeddings model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-bedrockembeddingmodelconfiguration.html#cfn-bedrock-knowledgebase-bedrockembeddingmodelconfiguration-dimensions
            '''
            result = self._values.get("dimensions")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def embedding_data_type(self) -> typing.Optional[builtins.str]:
            '''The data type for the vectors when using a model to convert text into vector embeddings.

            The model must support the specified data type for vector embeddings. Floating-point (float32) is the default data type, and is supported by most models for vector embeddings. See `Supported embeddings models <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-supported.html>`_ for information on the available models and their vector data types.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-bedrockembeddingmodelconfiguration.html#cfn-bedrock-knowledgebase-bedrockembeddingmodelconfiguration-embeddingdatatype
            '''
            result = self._values.get("embedding_data_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def video(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.VideoConfigurationProperty"]]]]:
            '''Configuration settings for processing video content in multimodal knowledge bases.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-bedrockembeddingmodelconfiguration.html#cfn-bedrock-knowledgebase-bedrockembeddingmodelconfiguration-video
            '''
            result = self._values.get("video")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.VideoConfigurationProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BedrockEmbeddingModelConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty",
        jsii_struct_bases=[],
        name_mapping={"natural_language": "naturalLanguage", "sql": "sql"},
    )
    class CuratedQueryProperty:
        def __init__(
            self,
            *,
            natural_language: typing.Optional[builtins.str] = None,
            sql: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a query, each of which defines information about example queries to help the query engine generate appropriate SQL queries.

            :param natural_language: An example natural language query.
            :param sql: The SQL equivalent of the natural language query.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-curatedquery.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                curated_query_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                    natural_language="naturalLanguage",
                    sql="sql"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__134057264a0a0aeaa28ede3e9c832b37b7affd70682b7986dd03929909beb94d)
                check_type(argname="argument natural_language", value=natural_language, expected_type=type_hints["natural_language"])
                check_type(argname="argument sql", value=sql, expected_type=type_hints["sql"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if natural_language is not None:
                self._values["natural_language"] = natural_language
            if sql is not None:
                self._values["sql"] = sql

        @builtins.property
        def natural_language(self) -> typing.Optional[builtins.str]:
            '''An example natural language query.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-curatedquery.html#cfn-bedrock-knowledgebase-curatedquery-naturallanguage
            '''
            result = self._values.get("natural_language")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def sql(self) -> typing.Optional[builtins.str]:
            '''The SQL equivalent of the natural language query.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-curatedquery.html#cfn-bedrock-knowledgebase-curatedquery-sql
            '''
            result = self._values.get("sql")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CuratedQueryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "bedrock_embedding_model_configuration": "bedrockEmbeddingModelConfiguration",
        },
    )
    class EmbeddingModelConfigurationProperty:
        def __init__(
            self,
            *,
            bedrock_embedding_model_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''The configuration details for the embeddings model.

            :param bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-embeddingmodelconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                embedding_model_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty(
                    bedrock_embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty(
                        audio=[bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                            segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                                fixed_length_duration=123
                            )
                        )],
                        dimensions=123,
                        embedding_data_type="embeddingDataType",
                        video=[bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                            segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                                fixed_length_duration=123
                            )
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bbaef4354679045a013eff34b790e989ff2ffde9ec14b529980f674e7693199f)
                check_type(argname="argument bedrock_embedding_model_configuration", value=bedrock_embedding_model_configuration, expected_type=type_hints["bedrock_embedding_model_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bedrock_embedding_model_configuration is not None:
                self._values["bedrock_embedding_model_configuration"] = bedrock_embedding_model_configuration

        @builtins.property
        def bedrock_embedding_model_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty"]]:
            '''The vector configuration details on the Bedrock embeddings model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-embeddingmodelconfiguration.html#cfn-bedrock-knowledgebase-embeddingmodelconfiguration-bedrockembeddingmodelconfiguration
            '''
            result = self._values.get("bedrock_embedding_model_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EmbeddingModelConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"kendra_index_arn": "kendraIndexArn"},
    )
    class KendraKnowledgeBaseConfigurationProperty:
        def __init__(
            self,
            *,
            kendra_index_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Settings for an Amazon Kendra knowledge base.

            :param kendra_index_arn: The ARN of the Amazon Kendra index.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-kendraknowledgebaseconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                kendra_knowledge_base_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty(
                    kendra_index_arn="kendraIndexArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__be62fc61c58bb5b90b13f2998d2fe248b5dbe53eb8d3957d7aaf3c076db36456)
                check_type(argname="argument kendra_index_arn", value=kendra_index_arn, expected_type=type_hints["kendra_index_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if kendra_index_arn is not None:
                self._values["kendra_index_arn"] = kendra_index_arn

        @builtins.property
        def kendra_index_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the Amazon Kendra index.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-kendraknowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-kendraknowledgebaseconfiguration-kendraindexarn
            '''
            result = self._values.get("kendra_index_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KendraKnowledgeBaseConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "kendra_knowledge_base_configuration": "kendraKnowledgeBaseConfiguration",
            "sql_knowledge_base_configuration": "sqlKnowledgeBaseConfiguration",
            "type": "type",
            "vector_knowledge_base_configuration": "vectorKnowledgeBaseConfiguration",
        },
    )
    class KnowledgeBaseConfigurationProperty:
        def __init__(
            self,
            *,
            kendra_knowledge_base_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            sql_knowledge_base_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
            vector_knowledge_base_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configurations to apply to a knowledge base attached to the agent during query.

            For more information, see `Knowledge base retrieval configurations <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html#session-state-kb>`_ .

            :param kendra_knowledge_base_configuration: Settings for an Amazon Kendra knowledge base.
            :param sql_knowledge_base_configuration: Specifies configurations for a knowledge base connected to an SQL database.
            :param type: The type of data that the data source is converted into for the knowledge base.
            :param vector_knowledge_base_configuration: Contains details about the model that's used to convert the data source into vector embeddings.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-knowledgebaseconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                knowledge_base_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty(
                    kendra_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty(
                        kendra_index_arn="kendraIndexArn"
                    ),
                    sql_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty(
                        redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty(
                            query_engine_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty(
                                provisioned_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                                    auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                                        database_user="databaseUser",
                                        type="type",
                                        username_password_secret_arn="usernamePasswordSecretArn"
                                    ),
                                    cluster_identifier="clusterIdentifier"
                                ),
                                serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                                    auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                                        type="type",
                                        username_password_secret_arn="usernamePasswordSecretArn"
                                    ),
                                    workgroup_arn="workgroupArn"
                                ),
                                type="type"
                            ),
                            query_generation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty(
                                execution_timeout_seconds=123,
                                generation_context=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                                    curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                                        natural_language="naturalLanguage",
                                        sql="sql"
                                    )],
                                    tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                                        columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                                            description="description",
                                            inclusion="inclusion",
                                            name="name"
                                        )],
                                        description="description",
                                        inclusion="inclusion",
                                        name="name"
                                    )]
                                )
                            ),
                            storage_configurations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty(
                                aws_data_catalog_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                                    table_names=["tableNames"]
                                ),
                                redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                                    database_name="databaseName"
                                ),
                                type="type"
                            )]
                        ),
                        type="type"
                    ),
                    type="type",
                    vector_knowledge_base_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty(
                        embedding_model_arn="embeddingModelArn",
                        embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty(
                            bedrock_embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty(
                                audio=[bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                                    segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                                        fixed_length_duration=123
                                    )
                                )],
                                dimensions=123,
                                embedding_data_type="embeddingDataType",
                                video=[bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                                    segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                                        fixed_length_duration=123
                                    )
                                )]
                            )
                        ),
                        supplemental_data_storage_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty(
                            supplemental_data_storage_locations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty(
                                s3_location=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                                    uri="uri"
                                ),
                                supplemental_data_storage_location_type="supplementalDataStorageLocationType"
                            )]
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3e796843d726cc5636b22dc1ecaaa4e4975480bee5c069a1e73686acc377058a)
                check_type(argname="argument kendra_knowledge_base_configuration", value=kendra_knowledge_base_configuration, expected_type=type_hints["kendra_knowledge_base_configuration"])
                check_type(argname="argument sql_knowledge_base_configuration", value=sql_knowledge_base_configuration, expected_type=type_hints["sql_knowledge_base_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument vector_knowledge_base_configuration", value=vector_knowledge_base_configuration, expected_type=type_hints["vector_knowledge_base_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if kendra_knowledge_base_configuration is not None:
                self._values["kendra_knowledge_base_configuration"] = kendra_knowledge_base_configuration
            if sql_knowledge_base_configuration is not None:
                self._values["sql_knowledge_base_configuration"] = sql_knowledge_base_configuration
            if type is not None:
                self._values["type"] = type
            if vector_knowledge_base_configuration is not None:
                self._values["vector_knowledge_base_configuration"] = vector_knowledge_base_configuration

        @builtins.property
        def kendra_knowledge_base_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty"]]:
            '''Settings for an Amazon Kendra knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-knowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-knowledgebaseconfiguration-kendraknowledgebaseconfiguration
            '''
            result = self._values.get("kendra_knowledge_base_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty"]], result)

        @builtins.property
        def sql_knowledge_base_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty"]]:
            '''Specifies configurations for a knowledge base connected to an SQL database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-knowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-knowledgebaseconfiguration-sqlknowledgebaseconfiguration
            '''
            result = self._values.get("sql_knowledge_base_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of data that the data source is converted into for the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-knowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-knowledgebaseconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_knowledge_base_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty"]]:
            '''Contains details about the model that's used to convert the data source into vector embeddings.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-knowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-knowledgebaseconfiguration-vectorknowledgebaseconfiguration
            '''
            result = self._values.get("vector_knowledge_base_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KnowledgeBaseConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "collection_name": "collectionName",
            "credentials_secret_arn": "credentialsSecretArn",
            "database_name": "databaseName",
            "endpoint": "endpoint",
            "endpoint_service_name": "endpointServiceName",
            "field_mapping": "fieldMapping",
            "text_index_name": "textIndexName",
            "vector_index_name": "vectorIndexName",
        },
    )
    class MongoDbAtlasConfigurationProperty:
        def __init__(
            self,
            *,
            collection_name: typing.Optional[builtins.str] = None,
            credentials_secret_arn: typing.Optional[builtins.str] = None,
            database_name: typing.Optional[builtins.str] = None,
            endpoint: typing.Optional[builtins.str] = None,
            endpoint_service_name: typing.Optional[builtins.str] = None,
            field_mapping: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text_index_name: typing.Optional[builtins.str] = None,
            vector_index_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the storage configuration of the knowledge base in MongoDB Atlas.

            :param collection_name: The collection name of the knowledge base in MongoDB Atlas.
            :param credentials_secret_arn: The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that contains user credentials for your MongoDB Atlas cluster.
            :param database_name: The database name in your MongoDB Atlas cluster for your knowledge base.
            :param endpoint: The endpoint URL of your MongoDB Atlas cluster for your knowledge base.
            :param endpoint_service_name: The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.
            :param field_mapping: Contains the names of the fields to which to map information about the vector store.
            :param text_index_name: The name of the text search index in the MongoDB collection. This is required for using the hybrid search feature.
            :param vector_index_name: The name of the MongoDB Atlas vector search index.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                mongo_db_atlas_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty(
                    collection_name="collectionName",
                    credentials_secret_arn="credentialsSecretArn",
                    database_name="databaseName",
                    endpoint="endpoint",
                    endpoint_service_name="endpointServiceName",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    text_index_name="textIndexName",
                    vector_index_name="vectorIndexName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b1b1ecf78ff75a54073753e7245812f3abb1bec7b92057cc9df89f43d5e2d090)
                check_type(argname="argument collection_name", value=collection_name, expected_type=type_hints["collection_name"])
                check_type(argname="argument credentials_secret_arn", value=credentials_secret_arn, expected_type=type_hints["credentials_secret_arn"])
                check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
                check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
                check_type(argname="argument endpoint_service_name", value=endpoint_service_name, expected_type=type_hints["endpoint_service_name"])
                check_type(argname="argument field_mapping", value=field_mapping, expected_type=type_hints["field_mapping"])
                check_type(argname="argument text_index_name", value=text_index_name, expected_type=type_hints["text_index_name"])
                check_type(argname="argument vector_index_name", value=vector_index_name, expected_type=type_hints["vector_index_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if collection_name is not None:
                self._values["collection_name"] = collection_name
            if credentials_secret_arn is not None:
                self._values["credentials_secret_arn"] = credentials_secret_arn
            if database_name is not None:
                self._values["database_name"] = database_name
            if endpoint is not None:
                self._values["endpoint"] = endpoint
            if endpoint_service_name is not None:
                self._values["endpoint_service_name"] = endpoint_service_name
            if field_mapping is not None:
                self._values["field_mapping"] = field_mapping
            if text_index_name is not None:
                self._values["text_index_name"] = text_index_name
            if vector_index_name is not None:
                self._values["vector_index_name"] = vector_index_name

        @builtins.property
        def collection_name(self) -> typing.Optional[builtins.str]:
            '''The collection name of the knowledge base in MongoDB Atlas.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-collectionname
            '''
            result = self._values.get("collection_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def credentials_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that contains user credentials for your MongoDB Atlas cluster.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-credentialssecretarn
            '''
            result = self._values.get("credentials_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def database_name(self) -> typing.Optional[builtins.str]:
            '''The database name in your MongoDB Atlas cluster for your knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-databasename
            '''
            result = self._values.get("database_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def endpoint(self) -> typing.Optional[builtins.str]:
            '''The endpoint URL of your MongoDB Atlas cluster for your knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-endpoint
            '''
            result = self._values.get("endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def endpoint_service_name(self) -> typing.Optional[builtins.str]:
            '''The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-endpointservicename
            '''
            result = self._values.get("endpoint_service_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def field_mapping(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty"]]:
            '''Contains the names of the fields to which to map information about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-fieldmapping
            '''
            result = self._values.get("field_mapping")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty"]], result)

        @builtins.property
        def text_index_name(self) -> typing.Optional[builtins.str]:
            '''The name of the text search index in the MongoDB collection.

            This is required for using the hybrid search feature.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-textindexname
            '''
            result = self._values.get("text_index_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_index_name(self) -> typing.Optional[builtins.str]:
            '''The name of the MongoDB Atlas vector search index.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasconfiguration.html#cfn-bedrock-knowledgebase-mongodbatlasconfiguration-vectorindexname
            '''
            result = self._values.get("vector_index_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MongoDbAtlasConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metadata_field": "metadataField",
            "text_field": "textField",
            "vector_field": "vectorField",
        },
    )
    class MongoDbAtlasFieldMappingProperty:
        def __init__(
            self,
            *,
            metadata_field: typing.Optional[builtins.str] = None,
            text_field: typing.Optional[builtins.str] = None,
            vector_field: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the names of the fields to which to map information about the vector store.

            :param metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
            :param text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
            :param vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasfieldmapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                mongo_db_atlas_field_mapping_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty(
                    metadata_field="metadataField",
                    text_field="textField",
                    vector_field="vectorField"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bbbdbbdbd9cd3eb51a09589170b0c539e4748ae326d38927bf039472929f97f5)
                check_type(argname="argument metadata_field", value=metadata_field, expected_type=type_hints["metadata_field"])
                check_type(argname="argument text_field", value=text_field, expected_type=type_hints["text_field"])
                check_type(argname="argument vector_field", value=vector_field, expected_type=type_hints["vector_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_field is not None:
                self._values["metadata_field"] = metadata_field
            if text_field is not None:
                self._values["text_field"] = text_field
            if vector_field is not None:
                self._values["vector_field"] = vector_field

        @builtins.property
        def metadata_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores metadata about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasfieldmapping.html#cfn-bedrock-knowledgebase-mongodbatlasfieldmapping-metadatafield
            '''
            result = self._values.get("metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the raw text from your data.

            The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasfieldmapping.html#cfn-bedrock-knowledgebase-mongodbatlasfieldmapping-textfield
            '''
            result = self._values.get("text_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-mongodbatlasfieldmapping.html#cfn-bedrock-knowledgebase-mongodbatlasfieldmapping-vectorfield
            '''
            result = self._values.get("vector_field")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MongoDbAtlasFieldMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"field_mapping": "fieldMapping", "graph_arn": "graphArn"},
    )
    class NeptuneAnalyticsConfigurationProperty:
        def __init__(
            self,
            *,
            field_mapping: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            graph_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the storage configuration of the knowledge base in Amazon Neptune Analytics.

            For more information, see `Create a vector index in Amazon Neptune Analytics <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html>`_ .

            :param field_mapping: Contains the names of the fields to which to map information about the vector store.
            :param graph_arn: The Amazon Resource Name (ARN) of the Neptune Analytics vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-neptuneanalyticsconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                neptune_analytics_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty(
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField"
                    ),
                    graph_arn="graphArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d29ef8c37eeb3ba975a20efa48d74c23284b531fc6704c955c78b2e9e86ed068)
                check_type(argname="argument field_mapping", value=field_mapping, expected_type=type_hints["field_mapping"])
                check_type(argname="argument graph_arn", value=graph_arn, expected_type=type_hints["graph_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if field_mapping is not None:
                self._values["field_mapping"] = field_mapping
            if graph_arn is not None:
                self._values["graph_arn"] = graph_arn

        @builtins.property
        def field_mapping(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty"]]:
            '''Contains the names of the fields to which to map information about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-neptuneanalyticsconfiguration.html#cfn-bedrock-knowledgebase-neptuneanalyticsconfiguration-fieldmapping
            '''
            result = self._values.get("field_mapping")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty"]], result)

        @builtins.property
        def graph_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the Neptune Analytics vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-neptuneanalyticsconfiguration.html#cfn-bedrock-knowledgebase-neptuneanalyticsconfiguration-grapharn
            '''
            result = self._values.get("graph_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NeptuneAnalyticsConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty",
        jsii_struct_bases=[],
        name_mapping={"metadata_field": "metadataField", "text_field": "textField"},
    )
    class NeptuneAnalyticsFieldMappingProperty:
        def __init__(
            self,
            *,
            metadata_field: typing.Optional[builtins.str] = None,
            text_field: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the names of the fields to which to map information about the vector store.

            :param metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
            :param text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-neptuneanalyticsfieldmapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                neptune_analytics_field_mapping_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty(
                    metadata_field="metadataField",
                    text_field="textField"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3d9e4d88d8e1fa02eb1ff51ad75daf0d49cb28262f9a8d49f54cbb1bbd27e174)
                check_type(argname="argument metadata_field", value=metadata_field, expected_type=type_hints["metadata_field"])
                check_type(argname="argument text_field", value=text_field, expected_type=type_hints["text_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_field is not None:
                self._values["metadata_field"] = metadata_field
            if text_field is not None:
                self._values["text_field"] = text_field

        @builtins.property
        def metadata_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores metadata about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-neptuneanalyticsfieldmapping.html#cfn-bedrock-knowledgebase-neptuneanalyticsfieldmapping-metadatafield
            '''
            result = self._values.get("metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the raw text from your data.

            The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-neptuneanalyticsfieldmapping.html#cfn-bedrock-knowledgebase-neptuneanalyticsfieldmapping-textfield
            '''
            result = self._values.get("text_field")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NeptuneAnalyticsFieldMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "domain_arn": "domainArn",
            "domain_endpoint": "domainEndpoint",
            "field_mapping": "fieldMapping",
            "vector_index_name": "vectorIndexName",
        },
    )
    class OpenSearchManagedClusterConfigurationProperty:
        def __init__(
            self,
            *,
            domain_arn: typing.Optional[builtins.str] = None,
            domain_endpoint: typing.Optional[builtins.str] = None,
            field_mapping: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vector_index_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the Managed Cluster configuration of the knowledge base in Amazon OpenSearch Service.

            For more information, see `Create a vector index in OpenSearch Managed Cluster <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html>`_ .

            :param domain_arn: The Amazon Resource Name (ARN) of the OpenSearch domain.
            :param domain_endpoint: The endpoint URL the OpenSearch domain.
            :param field_mapping: Contains the names of the fields to which to map information about the vector store.
            :param vector_index_name: The name of the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                open_search_managed_cluster_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty(
                    domain_arn="domainArn",
                    domain_endpoint="domainEndpoint",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    vector_index_name="vectorIndexName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__32e0d88f8d805e915276e77ec185f0c5eec54b030e1747f05b744c9585b867f6)
                check_type(argname="argument domain_arn", value=domain_arn, expected_type=type_hints["domain_arn"])
                check_type(argname="argument domain_endpoint", value=domain_endpoint, expected_type=type_hints["domain_endpoint"])
                check_type(argname="argument field_mapping", value=field_mapping, expected_type=type_hints["field_mapping"])
                check_type(argname="argument vector_index_name", value=vector_index_name, expected_type=type_hints["vector_index_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if domain_arn is not None:
                self._values["domain_arn"] = domain_arn
            if domain_endpoint is not None:
                self._values["domain_endpoint"] = domain_endpoint
            if field_mapping is not None:
                self._values["field_mapping"] = field_mapping
            if vector_index_name is not None:
                self._values["vector_index_name"] = vector_index_name

        @builtins.property
        def domain_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the OpenSearch domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterconfiguration.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterconfiguration-domainarn
            '''
            result = self._values.get("domain_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def domain_endpoint(self) -> typing.Optional[builtins.str]:
            '''The endpoint URL the OpenSearch domain.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterconfiguration.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterconfiguration-domainendpoint
            '''
            result = self._values.get("domain_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def field_mapping(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty"]]:
            '''Contains the names of the fields to which to map information about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterconfiguration.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterconfiguration-fieldmapping
            '''
            result = self._values.get("field_mapping")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty"]], result)

        @builtins.property
        def vector_index_name(self) -> typing.Optional[builtins.str]:
            '''The name of the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterconfiguration.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterconfiguration-vectorindexname
            '''
            result = self._values.get("vector_index_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OpenSearchManagedClusterConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metadata_field": "metadataField",
            "text_field": "textField",
            "vector_field": "vectorField",
        },
    )
    class OpenSearchManagedClusterFieldMappingProperty:
        def __init__(
            self,
            *,
            metadata_field: typing.Optional[builtins.str] = None,
            text_field: typing.Optional[builtins.str] = None,
            vector_field: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the names of the fields to which to map information about the vector store.

            :param metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
            :param text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
            :param vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                open_search_managed_cluster_field_mapping_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty(
                    metadata_field="metadataField",
                    text_field="textField",
                    vector_field="vectorField"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1ce3851d216586390736097c4ad1f928d95f1ee0cf574b345cc9546f66d228c6)
                check_type(argname="argument metadata_field", value=metadata_field, expected_type=type_hints["metadata_field"])
                check_type(argname="argument text_field", value=text_field, expected_type=type_hints["text_field"])
                check_type(argname="argument vector_field", value=vector_field, expected_type=type_hints["vector_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_field is not None:
                self._values["metadata_field"] = metadata_field
            if text_field is not None:
                self._values["text_field"] = text_field
            if vector_field is not None:
                self._values["vector_field"] = vector_field

        @builtins.property
        def metadata_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores metadata about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping-metadatafield
            '''
            result = self._values.get("metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the raw text from your data.

            The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping-textfield
            '''
            result = self._values.get("text_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping.html#cfn-bedrock-knowledgebase-opensearchmanagedclusterfieldmapping-vectorfield
            '''
            result = self._values.get("vector_field")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OpenSearchManagedClusterFieldMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "collection_arn": "collectionArn",
            "field_mapping": "fieldMapping",
            "vector_index_name": "vectorIndexName",
        },
    )
    class OpenSearchServerlessConfigurationProperty:
        def __init__(
            self,
            *,
            collection_arn: typing.Optional[builtins.str] = None,
            field_mapping: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            vector_index_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the storage configuration of the knowledge base in Amazon OpenSearch Service.

            For more information, see `Create a vector index in Amazon OpenSearch Service <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html>`_ .

            :param collection_arn: The Amazon Resource Name (ARN) of the OpenSearch Service vector store.
            :param field_mapping: Contains the names of the fields to which to map information about the vector store.
            :param vector_index_name: The name of the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                open_search_serverless_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty(
                    collection_arn="collectionArn",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    vector_index_name="vectorIndexName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1964b5e76b853562ba4cf4a2b2681db6a4605ad11fc2a5f769539d75f41bd45f)
                check_type(argname="argument collection_arn", value=collection_arn, expected_type=type_hints["collection_arn"])
                check_type(argname="argument field_mapping", value=field_mapping, expected_type=type_hints["field_mapping"])
                check_type(argname="argument vector_index_name", value=vector_index_name, expected_type=type_hints["vector_index_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if collection_arn is not None:
                self._values["collection_arn"] = collection_arn
            if field_mapping is not None:
                self._values["field_mapping"] = field_mapping
            if vector_index_name is not None:
                self._values["vector_index_name"] = vector_index_name

        @builtins.property
        def collection_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the OpenSearch Service vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessconfiguration.html#cfn-bedrock-knowledgebase-opensearchserverlessconfiguration-collectionarn
            '''
            result = self._values.get("collection_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def field_mapping(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty"]]:
            '''Contains the names of the fields to which to map information about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessconfiguration.html#cfn-bedrock-knowledgebase-opensearchserverlessconfiguration-fieldmapping
            '''
            result = self._values.get("field_mapping")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty"]], result)

        @builtins.property
        def vector_index_name(self) -> typing.Optional[builtins.str]:
            '''The name of the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessconfiguration.html#cfn-bedrock-knowledgebase-opensearchserverlessconfiguration-vectorindexname
            '''
            result = self._values.get("vector_index_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OpenSearchServerlessConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "metadata_field": "metadataField",
            "text_field": "textField",
            "vector_field": "vectorField",
        },
    )
    class OpenSearchServerlessFieldMappingProperty:
        def __init__(
            self,
            *,
            metadata_field: typing.Optional[builtins.str] = None,
            text_field: typing.Optional[builtins.str] = None,
            vector_field: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the names of the fields to which to map information about the vector store.

            :param metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
            :param text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
            :param vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessfieldmapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                open_search_serverless_field_mapping_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty(
                    metadata_field="metadataField",
                    text_field="textField",
                    vector_field="vectorField"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__37cad0fee058954883fb9d5adf68b608a736175436ab5f8a70a0386c93c1fc76)
                check_type(argname="argument metadata_field", value=metadata_field, expected_type=type_hints["metadata_field"])
                check_type(argname="argument text_field", value=text_field, expected_type=type_hints["text_field"])
                check_type(argname="argument vector_field", value=vector_field, expected_type=type_hints["vector_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_field is not None:
                self._values["metadata_field"] = metadata_field
            if text_field is not None:
                self._values["text_field"] = text_field
            if vector_field is not None:
                self._values["vector_field"] = vector_field

        @builtins.property
        def metadata_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores metadata about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessfieldmapping.html#cfn-bedrock-knowledgebase-opensearchserverlessfieldmapping-metadatafield
            '''
            result = self._values.get("metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the raw text from your data.

            The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessfieldmapping.html#cfn-bedrock-knowledgebase-opensearchserverlessfieldmapping-textfield
            '''
            result = self._values.get("text_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessfieldmapping.html#cfn-bedrock-knowledgebase-opensearchserverlessfieldmapping-vectorfield
            '''
            result = self._values.get("vector_field")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OpenSearchServerlessFieldMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "connection_string": "connectionString",
            "credentials_secret_arn": "credentialsSecretArn",
            "field_mapping": "fieldMapping",
            "namespace": "namespace",
        },
    )
    class PineconeConfigurationProperty:
        def __init__(
            self,
            *,
            connection_string: typing.Optional[builtins.str] = None,
            credentials_secret_arn: typing.Optional[builtins.str] = None,
            field_mapping: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            namespace: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the storage configuration of the knowledge base in Pinecone.

            For more information, see `Create a vector index in Pinecone <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-pinecone.html>`_ .

            :param connection_string: The endpoint URL for your index management page.
            :param credentials_secret_arn: The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
            :param field_mapping: Contains the names of the fields to which to map information about the vector store.
            :param namespace: The namespace to be used to write new data to your database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconeconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                pinecone_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty(
                    connection_string="connectionString",
                    credentials_secret_arn="credentialsSecretArn",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty(
                        metadata_field="metadataField",
                        text_field="textField"
                    ),
                    namespace="namespace"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7d9c862e33d755f684fbeecefcb57a740d86381b491c6153b25bdef24173a7c5)
                check_type(argname="argument connection_string", value=connection_string, expected_type=type_hints["connection_string"])
                check_type(argname="argument credentials_secret_arn", value=credentials_secret_arn, expected_type=type_hints["credentials_secret_arn"])
                check_type(argname="argument field_mapping", value=field_mapping, expected_type=type_hints["field_mapping"])
                check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if connection_string is not None:
                self._values["connection_string"] = connection_string
            if credentials_secret_arn is not None:
                self._values["credentials_secret_arn"] = credentials_secret_arn
            if field_mapping is not None:
                self._values["field_mapping"] = field_mapping
            if namespace is not None:
                self._values["namespace"] = namespace

        @builtins.property
        def connection_string(self) -> typing.Optional[builtins.str]:
            '''The endpoint URL for your index management page.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconeconfiguration.html#cfn-bedrock-knowledgebase-pineconeconfiguration-connectionstring
            '''
            result = self._values.get("connection_string")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def credentials_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconeconfiguration.html#cfn-bedrock-knowledgebase-pineconeconfiguration-credentialssecretarn
            '''
            result = self._values.get("credentials_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def field_mapping(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty"]]:
            '''Contains the names of the fields to which to map information about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconeconfiguration.html#cfn-bedrock-knowledgebase-pineconeconfiguration-fieldmapping
            '''
            result = self._values.get("field_mapping")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty"]], result)

        @builtins.property
        def namespace(self) -> typing.Optional[builtins.str]:
            '''The namespace to be used to write new data to your database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconeconfiguration.html#cfn-bedrock-knowledgebase-pineconeconfiguration-namespace
            '''
            result = self._values.get("namespace")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PineconeConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty",
        jsii_struct_bases=[],
        name_mapping={"metadata_field": "metadataField", "text_field": "textField"},
    )
    class PineconeFieldMappingProperty:
        def __init__(
            self,
            *,
            metadata_field: typing.Optional[builtins.str] = None,
            text_field: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the names of the fields to which to map information about the vector store.

            :param metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
            :param text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconefieldmapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                pinecone_field_mapping_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty(
                    metadata_field="metadataField",
                    text_field="textField"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__918f726a23a350dcf9d229122cbf57c2626a620e05ad26bd73a00ddaa308ebf3)
                check_type(argname="argument metadata_field", value=metadata_field, expected_type=type_hints["metadata_field"])
                check_type(argname="argument text_field", value=text_field, expected_type=type_hints["text_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if metadata_field is not None:
                self._values["metadata_field"] = metadata_field
            if text_field is not None:
                self._values["text_field"] = text_field

        @builtins.property
        def metadata_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores metadata about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconefieldmapping.html#cfn-bedrock-knowledgebase-pineconefieldmapping-metadatafield
            '''
            result = self._values.get("metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the raw text from your data.

            The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconefieldmapping.html#cfn-bedrock-knowledgebase-pineconefieldmapping-textfield
            '''
            result = self._values.get("text_field")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PineconeFieldMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "inclusion": "inclusion",
            "name": "name",
        },
    )
    class QueryGenerationColumnProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            inclusion: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains information about a column in the current table for the query engine to consider.

            :param description: A description of the column that helps the query engine understand the contents of the column.
            :param inclusion: Specifies whether to include or exclude the column during query generation. If you specify ``EXCLUDE`` , the column will be ignored. If you specify ``INCLUDE`` , all other columns in the table will be ignored.
            :param name: The name of the column for which the other fields in this object apply.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcolumn.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                query_generation_column_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                    description="description",
                    inclusion="inclusion",
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__2a0dfba053443884ce267215c03a71eac3790447bccc8b6fcf869fe4ce32de49)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument inclusion", value=inclusion, expected_type=type_hints["inclusion"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if inclusion is not None:
                self._values["inclusion"] = inclusion
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the column that helps the query engine understand the contents of the column.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcolumn.html#cfn-bedrock-knowledgebase-querygenerationcolumn-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def inclusion(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to include or exclude the column during query generation.

            If you specify ``EXCLUDE`` , the column will be ignored. If you specify ``INCLUDE`` , all other columns in the table will be ignored.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcolumn.html#cfn-bedrock-knowledgebase-querygenerationcolumn-inclusion
            '''
            result = self._values.get("inclusion")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the column for which the other fields in this object apply.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcolumn.html#cfn-bedrock-knowledgebase-querygenerationcolumn-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "QueryGenerationColumnProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "execution_timeout_seconds": "executionTimeoutSeconds",
            "generation_context": "generationContext",
        },
    )
    class QueryGenerationConfigurationProperty:
        def __init__(
            self,
            *,
            execution_timeout_seconds: typing.Optional[jsii.Number] = None,
            generation_context: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for query generation.

            For more information, see `Build a knowledge base by connecting to a structured data source <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-build-structured.html>`_ in the Amazon Bedrock User Guide..

            :param execution_timeout_seconds: The time after which query generation will time out.
            :param generation_context: Specifies configurations for context to use during query generation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                query_generation_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty(
                    execution_timeout_seconds=123,
                    generation_context=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                        curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                            natural_language="naturalLanguage",
                            sql="sql"
                        )],
                        tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                            columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                                description="description",
                                inclusion="inclusion",
                                name="name"
                            )],
                            description="description",
                            inclusion="inclusion",
                            name="name"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cd3fee86d292d170c9857e680895c14df9403eb7addad3528933be455833b2c6)
                check_type(argname="argument execution_timeout_seconds", value=execution_timeout_seconds, expected_type=type_hints["execution_timeout_seconds"])
                check_type(argname="argument generation_context", value=generation_context, expected_type=type_hints["generation_context"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if execution_timeout_seconds is not None:
                self._values["execution_timeout_seconds"] = execution_timeout_seconds
            if generation_context is not None:
                self._values["generation_context"] = generation_context

        @builtins.property
        def execution_timeout_seconds(self) -> typing.Optional[jsii.Number]:
            '''The time after which query generation will time out.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationconfiguration.html#cfn-bedrock-knowledgebase-querygenerationconfiguration-executiontimeoutseconds
            '''
            result = self._values.get("execution_timeout_seconds")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def generation_context(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty"]]:
            '''Specifies configurations for context to use during query generation.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationconfiguration.html#cfn-bedrock-knowledgebase-querygenerationconfiguration-generationcontext
            '''
            result = self._values.get("generation_context")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "QueryGenerationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty",
        jsii_struct_bases=[],
        name_mapping={"curated_queries": "curatedQueries", "tables": "tables"},
    )
    class QueryGenerationContextProperty:
        def __init__(
            self,
            *,
            curated_queries: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.CuratedQueryProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            tables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''.. epigraph::

   Contains configurations for context to use during query generation.

            :param curated_queries: An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
            :param tables: An array of objects, each of which defines information about a table in the database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcontext.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                query_generation_context_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                    curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                        natural_language="naturalLanguage",
                        sql="sql"
                    )],
                    tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                        columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                            description="description",
                            inclusion="inclusion",
                            name="name"
                        )],
                        description="description",
                        inclusion="inclusion",
                        name="name"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d9e2cbb76c00e6d6eb6fc2eaabf71edec5fe3b7ccf13c776706544ea66b90649)
                check_type(argname="argument curated_queries", value=curated_queries, expected_type=type_hints["curated_queries"])
                check_type(argname="argument tables", value=tables, expected_type=type_hints["tables"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if curated_queries is not None:
                self._values["curated_queries"] = curated_queries
            if tables is not None:
                self._values["tables"] = tables

        @builtins.property
        def curated_queries(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.CuratedQueryProperty"]]]]:
            '''An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcontext.html#cfn-bedrock-knowledgebase-querygenerationcontext-curatedqueries
            '''
            result = self._values.get("curated_queries")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.CuratedQueryProperty"]]]], result)

        @builtins.property
        def tables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty"]]]]:
            '''An array of objects, each of which defines information about a table in the database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationcontext.html#cfn-bedrock-knowledgebase-querygenerationcontext-tables
            '''
            result = self._values.get("tables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "QueryGenerationContextProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty",
        jsii_struct_bases=[],
        name_mapping={
            "columns": "columns",
            "description": "description",
            "inclusion": "inclusion",
            "name": "name",
        },
    )
    class QueryGenerationTableProperty:
        def __init__(
            self,
            *,
            columns: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            description: typing.Optional[builtins.str] = None,
            inclusion: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains information about a table for the query engine to consider.

            :param columns: An array of objects, each of which defines information about a column in the table.
            :param description: A description of the table that helps the query engine understand the contents of the table.
            :param inclusion: Specifies whether to include or exclude the table during query generation. If you specify ``EXCLUDE`` , the table will be ignored. If you specify ``INCLUDE`` , all other tables will be ignored.
            :param name: The name of the table for which the other fields in this object apply.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationtable.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                query_generation_table_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                    columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                        description="description",
                        inclusion="inclusion",
                        name="name"
                    )],
                    description="description",
                    inclusion="inclusion",
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9e2b4eaa21edcf8c8530e592b8f8406bd43082b1e761476d2cec9a03fb3bddbf)
                check_type(argname="argument columns", value=columns, expected_type=type_hints["columns"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument inclusion", value=inclusion, expected_type=type_hints["inclusion"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if columns is not None:
                self._values["columns"] = columns
            if description is not None:
                self._values["description"] = description
            if inclusion is not None:
                self._values["inclusion"] = inclusion
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def columns(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty"]]]]:
            '''An array of objects, each of which defines information about a column in the table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationtable.html#cfn-bedrock-knowledgebase-querygenerationtable-columns
            '''
            result = self._values.get("columns")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty"]]]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description of the table that helps the query engine understand the contents of the table.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationtable.html#cfn-bedrock-knowledgebase-querygenerationtable-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def inclusion(self) -> typing.Optional[builtins.str]:
            '''Specifies whether to include or exclude the table during query generation.

            If you specify ``EXCLUDE`` , the table will be ignored. If you specify ``INCLUDE`` , all other tables will be ignored.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationtable.html#cfn-bedrock-knowledgebase-querygenerationtable-inclusion
            '''
            result = self._values.get("inclusion")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the table for which the other fields in this object apply.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-querygenerationtable.html#cfn-bedrock-knowledgebase-querygenerationtable-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "QueryGenerationTableProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RdsConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "credentials_secret_arn": "credentialsSecretArn",
            "database_name": "databaseName",
            "field_mapping": "fieldMapping",
            "resource_arn": "resourceArn",
            "table_name": "tableName",
        },
    )
    class RdsConfigurationProperty:
        def __init__(
            self,
            *,
            credentials_secret_arn: typing.Optional[builtins.str] = None,
            database_name: typing.Optional[builtins.str] = None,
            field_mapping: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            resource_arn: typing.Optional[builtins.str] = None,
            table_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about the storage configuration of the knowledge base in Amazon RDS.

            For more information, see `Create a vector index in Amazon RDS <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html>`_ .

            :param credentials_secret_arn: The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
            :param database_name: The name of your Amazon RDS database.
            :param field_mapping: Contains the names of the fields to which to map information about the vector store.
            :param resource_arn: The Amazon Resource Name (ARN) of the vector store.
            :param table_name: The name of the table in the database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                rds_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsConfigurationProperty(
                    credentials_secret_arn="credentialsSecretArn",
                    database_name="databaseName",
                    field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty(
                        custom_metadata_field="customMetadataField",
                        metadata_field="metadataField",
                        primary_key_field="primaryKeyField",
                        text_field="textField",
                        vector_field="vectorField"
                    ),
                    resource_arn="resourceArn",
                    table_name="tableName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__03175253998c08ac585ba161d950430a58dc65d7749b244d14b158a14c3b0b45)
                check_type(argname="argument credentials_secret_arn", value=credentials_secret_arn, expected_type=type_hints["credentials_secret_arn"])
                check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
                check_type(argname="argument field_mapping", value=field_mapping, expected_type=type_hints["field_mapping"])
                check_type(argname="argument resource_arn", value=resource_arn, expected_type=type_hints["resource_arn"])
                check_type(argname="argument table_name", value=table_name, expected_type=type_hints["table_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if credentials_secret_arn is not None:
                self._values["credentials_secret_arn"] = credentials_secret_arn
            if database_name is not None:
                self._values["database_name"] = database_name
            if field_mapping is not None:
                self._values["field_mapping"] = field_mapping
            if resource_arn is not None:
                self._values["resource_arn"] = resource_arn
            if table_name is not None:
                self._values["table_name"] = table_name

        @builtins.property
        def credentials_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html#cfn-bedrock-knowledgebase-rdsconfiguration-credentialssecretarn
            '''
            result = self._values.get("credentials_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def database_name(self) -> typing.Optional[builtins.str]:
            '''The name of your Amazon RDS database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html#cfn-bedrock-knowledgebase-rdsconfiguration-databasename
            '''
            result = self._values.get("database_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def field_mapping(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty"]]:
            '''Contains the names of the fields to which to map information about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html#cfn-bedrock-knowledgebase-rdsconfiguration-fieldmapping
            '''
            result = self._values.get("field_mapping")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty"]], result)

        @builtins.property
        def resource_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html#cfn-bedrock-knowledgebase-rdsconfiguration-resourcearn
            '''
            result = self._values.get("resource_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def table_name(self) -> typing.Optional[builtins.str]:
            '''The name of the table in the database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html#cfn-bedrock-knowledgebase-rdsconfiguration-tablename
            '''
            result = self._values.get("table_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RdsConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "custom_metadata_field": "customMetadataField",
            "metadata_field": "metadataField",
            "primary_key_field": "primaryKeyField",
            "text_field": "textField",
            "vector_field": "vectorField",
        },
    )
    class RdsFieldMappingProperty:
        def __init__(
            self,
            *,
            custom_metadata_field: typing.Optional[builtins.str] = None,
            metadata_field: typing.Optional[builtins.str] = None,
            primary_key_field: typing.Optional[builtins.str] = None,
            text_field: typing.Optional[builtins.str] = None,
            vector_field: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the names of the fields to which to map information about the vector store.

            :param custom_metadata_field: Provide a name for the universal metadata field where Amazon Bedrock will store any custom metadata from your data source.
            :param metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
            :param primary_key_field: The name of the field in which Amazon Bedrock stores the ID for each entry.
            :param text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
            :param vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                rds_field_mapping_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty(
                    custom_metadata_field="customMetadataField",
                    metadata_field="metadataField",
                    primary_key_field="primaryKeyField",
                    text_field="textField",
                    vector_field="vectorField"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__32544c6a55e5cdb9334772c48b7a8ec249824b3aed5de1ad3f9b3ada61db2d36)
                check_type(argname="argument custom_metadata_field", value=custom_metadata_field, expected_type=type_hints["custom_metadata_field"])
                check_type(argname="argument metadata_field", value=metadata_field, expected_type=type_hints["metadata_field"])
                check_type(argname="argument primary_key_field", value=primary_key_field, expected_type=type_hints["primary_key_field"])
                check_type(argname="argument text_field", value=text_field, expected_type=type_hints["text_field"])
                check_type(argname="argument vector_field", value=vector_field, expected_type=type_hints["vector_field"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if custom_metadata_field is not None:
                self._values["custom_metadata_field"] = custom_metadata_field
            if metadata_field is not None:
                self._values["metadata_field"] = metadata_field
            if primary_key_field is not None:
                self._values["primary_key_field"] = primary_key_field
            if text_field is not None:
                self._values["text_field"] = text_field
            if vector_field is not None:
                self._values["vector_field"] = vector_field

        @builtins.property
        def custom_metadata_field(self) -> typing.Optional[builtins.str]:
            '''Provide a name for the universal metadata field where Amazon Bedrock will store any custom metadata from your data source.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html#cfn-bedrock-knowledgebase-rdsfieldmapping-custommetadatafield
            '''
            result = self._values.get("custom_metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def metadata_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores metadata about the vector store.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html#cfn-bedrock-knowledgebase-rdsfieldmapping-metadatafield
            '''
            result = self._values.get("metadata_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def primary_key_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the ID for each entry.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html#cfn-bedrock-knowledgebase-rdsfieldmapping-primarykeyfield
            '''
            result = self._values.get("primary_key_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the raw text from your data.

            The text is split according to the chunking strategy you choose.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html#cfn-bedrock-knowledgebase-rdsfieldmapping-textfield
            '''
            result = self._values.get("text_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_field(self) -> typing.Optional[builtins.str]:
            '''The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html#cfn-bedrock-knowledgebase-rdsfieldmapping-vectorfield
            '''
            result = self._values.get("vector_field")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RdsFieldMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "query_engine_configuration": "queryEngineConfiguration",
            "query_generation_configuration": "queryGenerationConfiguration",
            "storage_configurations": "storageConfigurations",
        },
    )
    class RedshiftConfigurationProperty:
        def __init__(
            self,
            *,
            query_engine_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            query_generation_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            storage_configurations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Contains configurations for an Amazon Redshift database.

            For more information, see `Build a knowledge base by connecting to a structured data source <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-build-structured.html>`_ in the Amazon Bedrock User Guide.

            :param query_engine_configuration: Specifies configurations for an Amazon Redshift query engine.
            :param query_generation_configuration: Specifies configurations for generating queries.
            :param storage_configurations: Specifies configurations for Amazon Redshift database storage.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty(
                    query_engine_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty(
                        provisioned_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                            auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                                database_user="databaseUser",
                                type="type",
                                username_password_secret_arn="usernamePasswordSecretArn"
                            ),
                            cluster_identifier="clusterIdentifier"
                        ),
                        serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                            auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                                type="type",
                                username_password_secret_arn="usernamePasswordSecretArn"
                            ),
                            workgroup_arn="workgroupArn"
                        ),
                        type="type"
                    ),
                    query_generation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty(
                        execution_timeout_seconds=123,
                        generation_context=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                            curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                                natural_language="naturalLanguage",
                                sql="sql"
                            )],
                            tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                                columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                                    description="description",
                                    inclusion="inclusion",
                                    name="name"
                                )],
                                description="description",
                                inclusion="inclusion",
                                name="name"
                            )]
                        )
                    ),
                    storage_configurations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty(
                        aws_data_catalog_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                            table_names=["tableNames"]
                        ),
                        redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                            database_name="databaseName"
                        ),
                        type="type"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c739205759cb27066978bdec991a64d29cddd001183c07ab89d78fd30330b1cb)
                check_type(argname="argument query_engine_configuration", value=query_engine_configuration, expected_type=type_hints["query_engine_configuration"])
                check_type(argname="argument query_generation_configuration", value=query_generation_configuration, expected_type=type_hints["query_generation_configuration"])
                check_type(argname="argument storage_configurations", value=storage_configurations, expected_type=type_hints["storage_configurations"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if query_engine_configuration is not None:
                self._values["query_engine_configuration"] = query_engine_configuration
            if query_generation_configuration is not None:
                self._values["query_generation_configuration"] = query_generation_configuration
            if storage_configurations is not None:
                self._values["storage_configurations"] = storage_configurations

        @builtins.property
        def query_engine_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty"]]:
            '''Specifies configurations for an Amazon Redshift query engine.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftconfiguration.html#cfn-bedrock-knowledgebase-redshiftconfiguration-queryengineconfiguration
            '''
            result = self._values.get("query_engine_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty"]], result)

        @builtins.property
        def query_generation_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty"]]:
            '''Specifies configurations for generating queries.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftconfiguration.html#cfn-bedrock-knowledgebase-redshiftconfiguration-querygenerationconfiguration
            '''
            result = self._values.get("query_generation_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty"]], result)

        @builtins.property
        def storage_configurations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty"]]]]:
            '''Specifies configurations for Amazon Redshift database storage.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftconfiguration.html#cfn-bedrock-knowledgebase-redshiftconfiguration-storageconfigurations
            '''
            result = self._values.get("storage_configurations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "database_user": "databaseUser",
            "type": "type",
            "username_password_secret_arn": "usernamePasswordSecretArn",
        },
    )
    class RedshiftProvisionedAuthConfigurationProperty:
        def __init__(
            self,
            *,
            database_user: typing.Optional[builtins.str] = None,
            type: typing.Optional[builtins.str] = None,
            username_password_secret_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for authentication to an Amazon Redshift provisioned data warehouse.

            Specify the type of authentication to use in the ``type`` field and include the corresponding field. If you specify IAM authentication, you don't need to include another field.

            :param database_user: The database username for authentication to an Amazon Redshift provisioned data warehouse.
            :param type: The type of authentication to use.
            :param username_password_secret_arn: The ARN of an Secrets Manager secret for authentication.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedauthconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_provisioned_auth_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                    database_user="databaseUser",
                    type="type",
                    username_password_secret_arn="usernamePasswordSecretArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5b440ac030233a388f20c833d99de384e5dc98ecf20fc9e60b7617d7e2375fcc)
                check_type(argname="argument database_user", value=database_user, expected_type=type_hints["database_user"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument username_password_secret_arn", value=username_password_secret_arn, expected_type=type_hints["username_password_secret_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if database_user is not None:
                self._values["database_user"] = database_user
            if type is not None:
                self._values["type"] = type
            if username_password_secret_arn is not None:
                self._values["username_password_secret_arn"] = username_password_secret_arn

        @builtins.property
        def database_user(self) -> typing.Optional[builtins.str]:
            '''The database username for authentication to an Amazon Redshift provisioned data warehouse.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedauthconfiguration.html#cfn-bedrock-knowledgebase-redshiftprovisionedauthconfiguration-databaseuser
            '''
            result = self._values.get("database_user")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of authentication to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedauthconfiguration.html#cfn-bedrock-knowledgebase-redshiftprovisionedauthconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def username_password_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of an Secrets Manager secret for authentication.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedauthconfiguration.html#cfn-bedrock-knowledgebase-redshiftprovisionedauthconfiguration-usernamepasswordsecretarn
            '''
            result = self._values.get("username_password_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftProvisionedAuthConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth_configuration": "authConfiguration",
            "cluster_identifier": "clusterIdentifier",
        },
    )
    class RedshiftProvisionedConfigurationProperty:
        def __init__(
            self,
            *,
            auth_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            cluster_identifier: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a provisioned Amazon Redshift query engine.

            :param auth_configuration: Specifies configurations for authentication to Amazon Redshift.
            :param cluster_identifier: The ID of the Amazon Redshift cluster.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_provisioned_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                    auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                        database_user="databaseUser",
                        type="type",
                        username_password_secret_arn="usernamePasswordSecretArn"
                    ),
                    cluster_identifier="clusterIdentifier"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b2250b41d9c69c87b342b97fe7f0c8f43ee64d69d3e3728ca0ac5ec10093827c)
                check_type(argname="argument auth_configuration", value=auth_configuration, expected_type=type_hints["auth_configuration"])
                check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth_configuration is not None:
                self._values["auth_configuration"] = auth_configuration
            if cluster_identifier is not None:
                self._values["cluster_identifier"] = cluster_identifier

        @builtins.property
        def auth_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty"]]:
            '''Specifies configurations for authentication to Amazon Redshift.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedconfiguration.html#cfn-bedrock-knowledgebase-redshiftprovisionedconfiguration-authconfiguration
            '''
            result = self._values.get("auth_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty"]], result)

        @builtins.property
        def cluster_identifier(self) -> typing.Optional[builtins.str]:
            '''The ID of the Amazon Redshift cluster.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftprovisionedconfiguration.html#cfn-bedrock-knowledgebase-redshiftprovisionedconfiguration-clusteridentifier
            '''
            result = self._values.get("cluster_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftProvisionedConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"table_names": "tableNames"},
    )
    class RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty:
        def __init__(
            self,
            *,
            table_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Contains configurations for storage in AWS Glue Data Catalog.

            :param table_names: A list of names of the tables to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineawsdatacatalogstorageconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_query_engine_aws_data_catalog_storage_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                    table_names=["tableNames"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__25b1bb33a76ade17d42c6803a26d57c445ebbddd21387c3107cba38f46e9554f)
                check_type(argname="argument table_names", value=table_names, expected_type=type_hints["table_names"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if table_names is not None:
                self._values["table_names"] = table_names

        @builtins.property
        def table_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of names of the tables to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineawsdatacatalogstorageconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryengineawsdatacatalogstorageconfiguration-tablenames
            '''
            result = self._values.get("table_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "provisioned_configuration": "provisionedConfiguration",
            "serverless_configuration": "serverlessConfiguration",
            "type": "type",
        },
    )
    class RedshiftQueryEngineConfigurationProperty:
        def __init__(
            self,
            *,
            provisioned_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            serverless_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for an Amazon Redshift query engine.

            Specify the type of query engine in ``type`` and include the corresponding field. For more information, see `Build a knowledge base by connecting to a structured data source <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-build-structured.html>`_ in the Amazon Bedrock User Guide.

            :param provisioned_configuration: Specifies configurations for a provisioned Amazon Redshift query engine.
            :param serverless_configuration: Specifies configurations for a serverless Amazon Redshift query engine.
            :param type: The type of query engine.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_query_engine_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty(
                    provisioned_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                        auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                            database_user="databaseUser",
                            type="type",
                            username_password_secret_arn="usernamePasswordSecretArn"
                        ),
                        cluster_identifier="clusterIdentifier"
                    ),
                    serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                        auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                            type="type",
                            username_password_secret_arn="usernamePasswordSecretArn"
                        ),
                        workgroup_arn="workgroupArn"
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d90550323a1bc4d0b18d03fc572510f814dd167f35037f19e2801f7327fa743d)
                check_type(argname="argument provisioned_configuration", value=provisioned_configuration, expected_type=type_hints["provisioned_configuration"])
                check_type(argname="argument serverless_configuration", value=serverless_configuration, expected_type=type_hints["serverless_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if provisioned_configuration is not None:
                self._values["provisioned_configuration"] = provisioned_configuration
            if serverless_configuration is not None:
                self._values["serverless_configuration"] = serverless_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def provisioned_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty"]]:
            '''Specifies configurations for a provisioned Amazon Redshift query engine.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryengineconfiguration-provisionedconfiguration
            '''
            result = self._values.get("provisioned_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty"]], result)

        @builtins.property
        def serverless_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty"]]:
            '''Specifies configurations for a serverless Amazon Redshift query engine.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryengineconfiguration-serverlessconfiguration
            '''
            result = self._values.get("serverless_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of query engine.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryengineconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftQueryEngineConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"database_name": "databaseName"},
    )
    class RedshiftQueryEngineRedshiftStorageConfigurationProperty:
        def __init__(
            self,
            *,
            database_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for storage in Amazon Redshift.

            :param database_name: The name of the Amazon Redshift database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineredshiftstorageconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_query_engine_redshift_storage_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                    database_name="databaseName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8e98f3c2191b766de1a907a92134e970acb692ffb78b5be3ddb74efe95da35e1)
                check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if database_name is not None:
                self._values["database_name"] = database_name

        @builtins.property
        def database_name(self) -> typing.Optional[builtins.str]:
            '''The name of the Amazon Redshift database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryengineredshiftstorageconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryengineredshiftstorageconfiguration-databasename
            '''
            result = self._values.get("database_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftQueryEngineRedshiftStorageConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "aws_data_catalog_configuration": "awsDataCatalogConfiguration",
            "redshift_configuration": "redshiftConfiguration",
            "type": "type",
        },
    )
    class RedshiftQueryEngineStorageConfigurationProperty:
        def __init__(
            self,
            *,
            aws_data_catalog_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            redshift_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for Amazon Redshift data storage.

            Specify the data storage service to use in the ``type`` field and include the corresponding field. For more information, see `Build a knowledge base by connecting to a structured data source <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-build-structured.html>`_ in the Amazon Bedrock User Guide.

            :param aws_data_catalog_configuration: Specifies configurations for storage in AWS Glue Data Catalog.
            :param redshift_configuration: Specifies configurations for storage in Amazon Redshift.
            :param type: The data storage service to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_query_engine_storage_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty(
                    aws_data_catalog_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                        table_names=["tableNames"]
                    ),
                    redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                        database_name="databaseName"
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__276b22c1a64319aced9ae570da5d56a3e481aacefd748a2421f54111ce8490c1)
                check_type(argname="argument aws_data_catalog_configuration", value=aws_data_catalog_configuration, expected_type=type_hints["aws_data_catalog_configuration"])
                check_type(argname="argument redshift_configuration", value=redshift_configuration, expected_type=type_hints["redshift_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if aws_data_catalog_configuration is not None:
                self._values["aws_data_catalog_configuration"] = aws_data_catalog_configuration
            if redshift_configuration is not None:
                self._values["redshift_configuration"] = redshift_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def aws_data_catalog_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty"]]:
            '''Specifies configurations for storage in AWS Glue Data Catalog.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration-awsdatacatalogconfiguration
            '''
            result = self._values.get("aws_data_catalog_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty"]], result)

        @builtins.property
        def redshift_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty"]]:
            '''Specifies configurations for storage in Amazon Redshift.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration-redshiftconfiguration
            '''
            result = self._values.get("redshift_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The data storage service to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration.html#cfn-bedrock-knowledgebase-redshiftqueryenginestorageconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftQueryEngineStorageConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "type": "type",
            "username_password_secret_arn": "usernamePasswordSecretArn",
        },
    )
    class RedshiftServerlessAuthConfigurationProperty:
        def __init__(
            self,
            *,
            type: typing.Optional[builtins.str] = None,
            username_password_secret_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies configurations for authentication to a Redshift Serverless.

            Specify the type of authentication to use in the ``type`` field and include the corresponding field. If you specify IAM authentication, you don't need to include another field.

            :param type: The type of authentication to use.
            :param username_password_secret_arn: The ARN of an Secrets Manager secret for authentication.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftserverlessauthconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_serverless_auth_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                    type="type",
                    username_password_secret_arn="usernamePasswordSecretArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f85e9562a7e1b79e1d99eb9f2f5a7e7fb17045567be15e73a01234ba54667782)
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
                check_type(argname="argument username_password_secret_arn", value=username_password_secret_arn, expected_type=type_hints["username_password_secret_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if type is not None:
                self._values["type"] = type
            if username_password_secret_arn is not None:
                self._values["username_password_secret_arn"] = username_password_secret_arn

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of authentication to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftserverlessauthconfiguration.html#cfn-bedrock-knowledgebase-redshiftserverlessauthconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def username_password_secret_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of an Secrets Manager secret for authentication.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftserverlessauthconfiguration.html#cfn-bedrock-knowledgebase-redshiftserverlessauthconfiguration-usernamepasswordsecretarn
            '''
            result = self._values.get("username_password_secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftServerlessAuthConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth_configuration": "authConfiguration",
            "workgroup_arn": "workgroupArn",
        },
    )
    class RedshiftServerlessConfigurationProperty:
        def __init__(
            self,
            *,
            auth_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            workgroup_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for authentication to Amazon Redshift Serverless.

            :param auth_configuration: Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
            :param workgroup_arn: The ARN of the Amazon Redshift workgroup.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftserverlessconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                redshift_serverless_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                    auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                        type="type",
                        username_password_secret_arn="usernamePasswordSecretArn"
                    ),
                    workgroup_arn="workgroupArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3b10a47739a29eb514dc63cc738ec3b25550f2924b995912316a286ce524b3cf)
                check_type(argname="argument auth_configuration", value=auth_configuration, expected_type=type_hints["auth_configuration"])
                check_type(argname="argument workgroup_arn", value=workgroup_arn, expected_type=type_hints["workgroup_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth_configuration is not None:
                self._values["auth_configuration"] = auth_configuration
            if workgroup_arn is not None:
                self._values["workgroup_arn"] = workgroup_arn

        @builtins.property
        def auth_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty"]]:
            '''Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftserverlessconfiguration.html#cfn-bedrock-knowledgebase-redshiftserverlessconfiguration-authconfiguration
            '''
            result = self._values.get("auth_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty"]], result)

        @builtins.property
        def workgroup_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the Amazon Redshift workgroup.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-redshiftserverlessconfiguration.html#cfn-bedrock-knowledgebase-redshiftserverlessconfiguration-workgrouparn
            '''
            result = self._values.get("workgroup_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "RedshiftServerlessConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty",
        jsii_struct_bases=[],
        name_mapping={"uri": "uri"},
    )
    class S3LocationProperty:
        def __init__(self, *, uri: typing.Optional[builtins.str] = None) -> None:
            '''A storage location in an Amazon S3 bucket.

            :param uri: An object URI starting with ``s3://`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-s3location.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                s3_location_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                    uri="uri"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d171537d919cbf33d0f46fd0ec1b06b170b7fbb5c9aa5b1d8f4f9b3dbc24c443)
                check_type(argname="argument uri", value=uri, expected_type=type_hints["uri"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if uri is not None:
                self._values["uri"] = uri

        @builtins.property
        def uri(self) -> typing.Optional[builtins.str]:
            '''An object URI starting with ``s3://`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-s3location.html#cfn-bedrock-knowledgebase-s3location-uri
            '''
            result = self._values.get("uri")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3LocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "index_arn": "indexArn",
            "index_name": "indexName",
            "vector_bucket_arn": "vectorBucketArn",
        },
    )
    class S3VectorsConfigurationProperty:
        def __init__(
            self,
            *,
            index_arn: typing.Optional[builtins.str] = None,
            index_name: typing.Optional[builtins.str] = None,
            vector_bucket_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the storage configuration of the knowledge base for S3 vectors.

            :param index_arn: The Amazon Resource Name (ARN) of the vector index used for the knowledge base. This ARN identifies the specific vector index resource within Amazon Bedrock.
            :param index_name: The name of the vector index used for the knowledge base. This name identifies the vector index within the Amazon Bedrock service.
            :param vector_bucket_arn: The Amazon Resource Name (ARN) of the S3 bucket where vector embeddings are stored. This bucket contains the vector data used by the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-s3vectorsconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                s3_vectors_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty(
                    index_arn="indexArn",
                    index_name="indexName",
                    vector_bucket_arn="vectorBucketArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d878a8acd70f1a03014375f3d0fac48153c5adfd4dfc955534c8c8ce51c68b01)
                check_type(argname="argument index_arn", value=index_arn, expected_type=type_hints["index_arn"])
                check_type(argname="argument index_name", value=index_name, expected_type=type_hints["index_name"])
                check_type(argname="argument vector_bucket_arn", value=vector_bucket_arn, expected_type=type_hints["vector_bucket_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if index_arn is not None:
                self._values["index_arn"] = index_arn
            if index_name is not None:
                self._values["index_name"] = index_name
            if vector_bucket_arn is not None:
                self._values["vector_bucket_arn"] = vector_bucket_arn

        @builtins.property
        def index_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the vector index used for the knowledge base.

            This ARN identifies the specific vector index resource within Amazon Bedrock.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-s3vectorsconfiguration.html#cfn-bedrock-knowledgebase-s3vectorsconfiguration-indexarn
            '''
            result = self._values.get("index_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def index_name(self) -> typing.Optional[builtins.str]:
            '''The name of the vector index used for the knowledge base.

            This name identifies the vector index within the Amazon Bedrock service.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-s3vectorsconfiguration.html#cfn-bedrock-knowledgebase-s3vectorsconfiguration-indexname
            '''
            result = self._values.get("index_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vector_bucket_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the S3 bucket where vector embeddings are stored.

            This bucket contains the vector data used by the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-s3vectorsconfiguration.html#cfn-bedrock-knowledgebase-s3vectorsconfiguration-vectorbucketarn
            '''
            result = self._values.get("vector_bucket_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "S3VectorsConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "redshift_configuration": "redshiftConfiguration",
            "type": "type",
        },
    )
    class SqlKnowledgeBaseConfigurationProperty:
        def __init__(
            self,
            *,
            redshift_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a knowledge base connected to an SQL database.

            Specify the SQL database type in the ``type`` field and include the corresponding field. For more information, see `Build a knowledge base by connecting to a structured data source <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-build-structured.html>`_ in the Amazon Bedrock User Guide.

            :param redshift_configuration: Specifies configurations for a knowledge base connected to an Amazon Redshift database.
            :param type: The type of SQL database to connect to the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-sqlknowledgebaseconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                sql_knowledge_base_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty(
                    redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty(
                        query_engine_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty(
                            provisioned_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty(
                                auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty(
                                    database_user="databaseUser",
                                    type="type",
                                    username_password_secret_arn="usernamePasswordSecretArn"
                                ),
                                cluster_identifier="clusterIdentifier"
                            ),
                            serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty(
                                auth_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty(
                                    type="type",
                                    username_password_secret_arn="usernamePasswordSecretArn"
                                ),
                                workgroup_arn="workgroupArn"
                            ),
                            type="type"
                        ),
                        query_generation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty(
                            execution_timeout_seconds=123,
                            generation_context=bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty(
                                curated_queries=[bedrock_mixins.CfnKnowledgeBasePropsMixin.CuratedQueryProperty(
                                    natural_language="naturalLanguage",
                                    sql="sql"
                                )],
                                tables=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty(
                                    columns=[bedrock_mixins.CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty(
                                        description="description",
                                        inclusion="inclusion",
                                        name="name"
                                    )],
                                    description="description",
                                    inclusion="inclusion",
                                    name="name"
                                )]
                            )
                        ),
                        storage_configurations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty(
                            aws_data_catalog_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty(
                                table_names=["tableNames"]
                            ),
                            redshift_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty(
                                database_name="databaseName"
                            ),
                            type="type"
                        )]
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cd28fe13a15f878a612560b3ef9215baf21e3a1ff33f6856accca138ad129cb8)
                check_type(argname="argument redshift_configuration", value=redshift_configuration, expected_type=type_hints["redshift_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if redshift_configuration is not None:
                self._values["redshift_configuration"] = redshift_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def redshift_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty"]]:
            '''Specifies configurations for a knowledge base connected to an Amazon Redshift database.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-sqlknowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-sqlknowledgebaseconfiguration-redshiftconfiguration
            '''
            result = self._values.get("redshift_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of SQL database to connect to the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-sqlknowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-sqlknowledgebaseconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SqlKnowledgeBaseConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.StorageConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "mongo_db_atlas_configuration": "mongoDbAtlasConfiguration",
            "neptune_analytics_configuration": "neptuneAnalyticsConfiguration",
            "opensearch_managed_cluster_configuration": "opensearchManagedClusterConfiguration",
            "opensearch_serverless_configuration": "opensearchServerlessConfiguration",
            "pinecone_configuration": "pineconeConfiguration",
            "rds_configuration": "rdsConfiguration",
            "s3_vectors_configuration": "s3VectorsConfiguration",
            "type": "type",
        },
    )
    class StorageConfigurationProperty:
        def __init__(
            self,
            *,
            mongo_db_atlas_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            neptune_analytics_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            opensearch_managed_cluster_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            opensearch_serverless_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            pinecone_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            rds_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.RdsConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            s3_vectors_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains the storage configuration of the knowledge base.

            :param mongo_db_atlas_configuration: Contains the storage configuration of the knowledge base in MongoDB Atlas.
            :param neptune_analytics_configuration: Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information, see `Create a vector index in Amazon Neptune Analytics. <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html>`_ .
            :param opensearch_managed_cluster_configuration: Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster. For more information, see `Create a vector index in Amazon OpenSearch Service <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html>`_ .
            :param opensearch_serverless_configuration: Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
            :param pinecone_configuration: Contains the storage configuration of the knowledge base in Pinecone.
            :param rds_configuration: Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see `Create a vector index in Amazon RDS <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html>`_ .
            :param s3_vectors_configuration: The configuration settings for storing knowledge base data using S3 vectors. This includes vector index information and S3 bucket details for vector storage.
            :param type: The vector store service in which the knowledge base is stored.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                storage_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.StorageConfigurationProperty(
                    mongo_db_atlas_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty(
                        collection_name="collectionName",
                        credentials_secret_arn="credentialsSecretArn",
                        database_name="databaseName",
                        endpoint="endpoint",
                        endpoint_service_name="endpointServiceName",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        text_index_name="textIndexName",
                        vector_index_name="vectorIndexName"
                    ),
                    neptune_analytics_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty(
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField"
                        ),
                        graph_arn="graphArn"
                    ),
                    opensearch_managed_cluster_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty(
                        domain_arn="domainArn",
                        domain_endpoint="domainEndpoint",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        vector_index_name="vectorIndexName"
                    ),
                    opensearch_serverless_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty(
                        collection_arn="collectionArn",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        vector_index_name="vectorIndexName"
                    ),
                    pinecone_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty(
                        connection_string="connectionString",
                        credentials_secret_arn="credentialsSecretArn",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty(
                            metadata_field="metadataField",
                            text_field="textField"
                        ),
                        namespace="namespace"
                    ),
                    rds_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsConfigurationProperty(
                        credentials_secret_arn="credentialsSecretArn",
                        database_name="databaseName",
                        field_mapping=bedrock_mixins.CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty(
                            custom_metadata_field="customMetadataField",
                            metadata_field="metadataField",
                            primary_key_field="primaryKeyField",
                            text_field="textField",
                            vector_field="vectorField"
                        ),
                        resource_arn="resourceArn",
                        table_name="tableName"
                    ),
                    s3_vectors_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty(
                        index_arn="indexArn",
                        index_name="indexName",
                        vector_bucket_arn="vectorBucketArn"
                    ),
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__23bc966cbeeaf42eaf4b23bc762c9f010a96754ed1ecb3f160fe80008bae3c3d)
                check_type(argname="argument mongo_db_atlas_configuration", value=mongo_db_atlas_configuration, expected_type=type_hints["mongo_db_atlas_configuration"])
                check_type(argname="argument neptune_analytics_configuration", value=neptune_analytics_configuration, expected_type=type_hints["neptune_analytics_configuration"])
                check_type(argname="argument opensearch_managed_cluster_configuration", value=opensearch_managed_cluster_configuration, expected_type=type_hints["opensearch_managed_cluster_configuration"])
                check_type(argname="argument opensearch_serverless_configuration", value=opensearch_serverless_configuration, expected_type=type_hints["opensearch_serverless_configuration"])
                check_type(argname="argument pinecone_configuration", value=pinecone_configuration, expected_type=type_hints["pinecone_configuration"])
                check_type(argname="argument rds_configuration", value=rds_configuration, expected_type=type_hints["rds_configuration"])
                check_type(argname="argument s3_vectors_configuration", value=s3_vectors_configuration, expected_type=type_hints["s3_vectors_configuration"])
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if mongo_db_atlas_configuration is not None:
                self._values["mongo_db_atlas_configuration"] = mongo_db_atlas_configuration
            if neptune_analytics_configuration is not None:
                self._values["neptune_analytics_configuration"] = neptune_analytics_configuration
            if opensearch_managed_cluster_configuration is not None:
                self._values["opensearch_managed_cluster_configuration"] = opensearch_managed_cluster_configuration
            if opensearch_serverless_configuration is not None:
                self._values["opensearch_serverless_configuration"] = opensearch_serverless_configuration
            if pinecone_configuration is not None:
                self._values["pinecone_configuration"] = pinecone_configuration
            if rds_configuration is not None:
                self._values["rds_configuration"] = rds_configuration
            if s3_vectors_configuration is not None:
                self._values["s3_vectors_configuration"] = s3_vectors_configuration
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def mongo_db_atlas_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty"]]:
            '''Contains the storage configuration of the knowledge base in MongoDB Atlas.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-mongodbatlasconfiguration
            '''
            result = self._values.get("mongo_db_atlas_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty"]], result)

        @builtins.property
        def neptune_analytics_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty"]]:
            '''Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune.

            For more information, see `Create a vector index in Amazon Neptune Analytics. <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-neptuneanalyticsconfiguration
            '''
            result = self._values.get("neptune_analytics_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty"]], result)

        @builtins.property
        def opensearch_managed_cluster_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty"]]:
            '''Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster.

            For more information, see `Create a vector index in Amazon OpenSearch Service <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-opensearchmanagedclusterconfiguration
            '''
            result = self._values.get("opensearch_managed_cluster_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty"]], result)

        @builtins.property
        def opensearch_serverless_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty"]]:
            '''Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-opensearchserverlessconfiguration
            '''
            result = self._values.get("opensearch_serverless_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty"]], result)

        @builtins.property
        def pinecone_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty"]]:
            '''Contains the storage configuration of the knowledge base in Pinecone.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-pineconeconfiguration
            '''
            result = self._values.get("pinecone_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty"]], result)

        @builtins.property
        def rds_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RdsConfigurationProperty"]]:
            '''Contains details about the storage configuration of the knowledge base in Amazon RDS.

            For more information, see `Create a vector index in Amazon RDS <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-rdsconfiguration
            '''
            result = self._values.get("rds_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.RdsConfigurationProperty"]], result)

        @builtins.property
        def s3_vectors_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty"]]:
            '''The configuration settings for storing knowledge base data using S3 vectors.

            This includes vector index information and S3 bucket details for vector storage.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-s3vectorsconfiguration
            '''
            result = self._values.get("s3_vectors_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty"]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The vector store service in which the knowledge base is stored.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html#cfn-bedrock-knowledgebase-storageconfiguration-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "StorageConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "supplemental_data_storage_locations": "supplementalDataStorageLocations",
        },
    )
    class SupplementalDataStorageConfigurationProperty:
        def __init__(
            self,
            *,
            supplemental_data_storage_locations: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Specifies configurations for the storage location of multimedia content (images, audio, and video) extracted from multimodal documents in your data source.

            This content can be retrieved and returned to the end user with timestamp references for audio and video segments.

            :param supplemental_data_storage_locations: List of supplemental data storage locations.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-supplementaldatastorageconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                supplemental_data_storage_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty(
                    supplemental_data_storage_locations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty(
                        s3_location=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                            uri="uri"
                        ),
                        supplemental_data_storage_location_type="supplementalDataStorageLocationType"
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f74181b4de9b99ab5cfa947e3dc6f0d2a06c1bcb3d51242c551d7f360aade623)
                check_type(argname="argument supplemental_data_storage_locations", value=supplemental_data_storage_locations, expected_type=type_hints["supplemental_data_storage_locations"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if supplemental_data_storage_locations is not None:
                self._values["supplemental_data_storage_locations"] = supplemental_data_storage_locations

        @builtins.property
        def supplemental_data_storage_locations(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty"]]]]:
            '''List of supplemental data storage locations.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-supplementaldatastorageconfiguration.html#cfn-bedrock-knowledgebase-supplementaldatastorageconfiguration-supplementaldatastoragelocations
            '''
            result = self._values.get("supplemental_data_storage_locations")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SupplementalDataStorageConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "s3_location": "s3Location",
            "supplemental_data_storage_location_type": "supplementalDataStorageLocationType",
        },
    )
    class SupplementalDataStorageLocationProperty:
        def __init__(
            self,
            *,
            s3_location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.S3LocationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            supplemental_data_storage_location_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains information about a storage location for multimedia content (images, audio, and video) extracted from multimodal documents in your data source.

            :param s3_location: Contains information about the Amazon S3 location for the extracted multimedia content.
            :param supplemental_data_storage_location_type: Supplemental data storage location type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-supplementaldatastoragelocation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                supplemental_data_storage_location_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty(
                    s3_location=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                        uri="uri"
                    ),
                    supplemental_data_storage_location_type="supplementalDataStorageLocationType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__aa2423d8a5a4dd4d199ff6b281daf315d69b3a74c606d2a2d729d43b64aaa721)
                check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
                check_type(argname="argument supplemental_data_storage_location_type", value=supplemental_data_storage_location_type, expected_type=type_hints["supplemental_data_storage_location_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if s3_location is not None:
                self._values["s3_location"] = s3_location
            if supplemental_data_storage_location_type is not None:
                self._values["supplemental_data_storage_location_type"] = supplemental_data_storage_location_type

        @builtins.property
        def s3_location(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.S3LocationProperty"]]:
            '''Contains information about the Amazon S3 location for the extracted multimedia content.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-supplementaldatastoragelocation.html#cfn-bedrock-knowledgebase-supplementaldatastoragelocation-s3location
            '''
            result = self._values.get("s3_location")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.S3LocationProperty"]], result)

        @builtins.property
        def supplemental_data_storage_location_type(
            self,
        ) -> typing.Optional[builtins.str]:
            '''Supplemental data storage location type.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-supplementaldatastoragelocation.html#cfn-bedrock-knowledgebase-supplementaldatastoragelocation-supplementaldatastoragelocationtype
            '''
            result = self._values.get("supplemental_data_storage_location_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SupplementalDataStorageLocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "embedding_model_arn": "embeddingModelArn",
            "embedding_model_configuration": "embeddingModelConfiguration",
            "supplemental_data_storage_configuration": "supplementalDataStorageConfiguration",
        },
    )
    class VectorKnowledgeBaseConfigurationProperty:
        def __init__(
            self,
            *,
            embedding_model_arn: typing.Optional[builtins.str] = None,
            embedding_model_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            supplemental_data_storage_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains details about the model used to create vector embeddings for the knowledge base.

            :param embedding_model_arn: The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
            :param embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.
            :param supplemental_data_storage_configuration: If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using `RetrieveAndGenerate <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-vectorknowledgebaseconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                vector_knowledge_base_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty(
                    embedding_model_arn="embeddingModelArn",
                    embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty(
                        bedrock_embedding_model_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty(
                            audio=[bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioConfigurationProperty(
                                segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty(
                                    fixed_length_duration=123
                                )
                            )],
                            dimensions=123,
                            embedding_data_type="embeddingDataType",
                            video=[bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                                segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                                    fixed_length_duration=123
                                )
                            )]
                        )
                    ),
                    supplemental_data_storage_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty(
                        supplemental_data_storage_locations=[bedrock_mixins.CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty(
                            s3_location=bedrock_mixins.CfnKnowledgeBasePropsMixin.S3LocationProperty(
                                uri="uri"
                            ),
                            supplemental_data_storage_location_type="supplementalDataStorageLocationType"
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__53ea2d34778b050600681a8f0c649f2b0332ae6f6c76ed279c3b37d0b49d372a)
                check_type(argname="argument embedding_model_arn", value=embedding_model_arn, expected_type=type_hints["embedding_model_arn"])
                check_type(argname="argument embedding_model_configuration", value=embedding_model_configuration, expected_type=type_hints["embedding_model_configuration"])
                check_type(argname="argument supplemental_data_storage_configuration", value=supplemental_data_storage_configuration, expected_type=type_hints["supplemental_data_storage_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if embedding_model_arn is not None:
                self._values["embedding_model_arn"] = embedding_model_arn
            if embedding_model_configuration is not None:
                self._values["embedding_model_configuration"] = embedding_model_configuration
            if supplemental_data_storage_configuration is not None:
                self._values["supplemental_data_storage_configuration"] = supplemental_data_storage_configuration

        @builtins.property
        def embedding_model_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-vectorknowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-vectorknowledgebaseconfiguration-embeddingmodelarn
            '''
            result = self._values.get("embedding_model_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def embedding_model_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty"]]:
            '''The embeddings model configuration details for the vector model used in Knowledge Base.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-vectorknowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-vectorknowledgebaseconfiguration-embeddingmodelconfiguration
            '''
            result = self._values.get("embedding_model_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty"]], result)

        @builtins.property
        def supplemental_data_storage_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty"]]:
            '''If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents.

            These images can be retrieved and returned to the end user. They can also be used in generation when using `RetrieveAndGenerate <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-vectorknowledgebaseconfiguration.html#cfn-bedrock-knowledgebase-vectorknowledgebaseconfiguration-supplementaldatastorageconfiguration
            '''
            result = self._values.get("supplemental_data_storage_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VectorKnowledgeBaseConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"segmentation_configuration": "segmentationConfiguration"},
    )
    class VideoConfigurationProperty:
        def __init__(
            self,
            *,
            segmentation_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Configuration settings for processing video content in multimodal knowledge bases.

            :param segmentation_configuration: Configuration for segmenting video content during processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-videoconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoConfigurationProperty(
                    segmentation_configuration=bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                        fixed_length_duration=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5d1cf01d2b67f3a7158d2d8096b4a49c657dbddf76696e051f4af5f6da941d98)
                check_type(argname="argument segmentation_configuration", value=segmentation_configuration, expected_type=type_hints["segmentation_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if segmentation_configuration is not None:
                self._values["segmentation_configuration"] = segmentation_configuration

        @builtins.property
        def segmentation_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty"]]:
            '''Configuration for segmenting video content during processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-videoconfiguration.html#cfn-bedrock-knowledgebase-videoconfiguration-segmentationconfiguration
            '''
            result = self._values.get("segmentation_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"fixed_length_duration": "fixedLengthDuration"},
    )
    class VideoSegmentationConfigurationProperty:
        def __init__(
            self,
            *,
            fixed_length_duration: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Configuration for segmenting video content during multimodal knowledge base ingestion.

            Determines how video files are divided into chunks for processing.

            :param fixed_length_duration: The duration in seconds for each video segment. Video files will be divided into chunks of this length for processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-videosegmentationconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                video_segmentation_configuration_property = bedrock_mixins.CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty(
                    fixed_length_duration=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b008d6b7ae239a9f1d7bd4b11bbedac01d18d38c1d19b4429cb926b98743c446)
                check_type(argname="argument fixed_length_duration", value=fixed_length_duration, expected_type=type_hints["fixed_length_duration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if fixed_length_duration is not None:
                self._values["fixed_length_duration"] = fixed_length_duration

        @builtins.property
        def fixed_length_duration(self) -> typing.Optional[jsii.Number]:
            '''The duration in seconds for each video segment.

            Video files will be divided into chunks of this length for processing.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-videosegmentationconfiguration.html#cfn-bedrock-knowledgebase-videosegmentationconfiguration-fixedlengthduration
            '''
            result = self._values.get("fixed_length_duration")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VideoSegmentationConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


class CfnKnowledgeBaseRuntimeLogs(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnKnowledgeBaseRuntimeLogs",
):
    '''Builder for CfnKnowledgeBaseLogsMixin to generate RUNTIME_LOGS for CfnKnowledgeBase.

    :cloudformationResource: AWS::Bedrock::KnowledgeBase
    :logType: RUNTIME_LOGS
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_knowledge_base_runtime_logs = bedrock_mixins.CfnKnowledgeBaseRuntimeLogs()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toFirehose")
    def to_firehose(
        self,
        delivery_stream: "_aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef",
    ) -> "CfnKnowledgeBaseLogsMixin":
        '''Send logs to a Firehose Delivery Stream.

        :param delivery_stream: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e1089624b651106f6050525f4ea2d29ffe8cfd90d1905055aef65c9caf54b9c)
            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
        return typing.cast("CfnKnowledgeBaseLogsMixin", jsii.invoke(self, "toFirehose", [delivery_stream]))

    @jsii.member(jsii_name="toLogGroup")
    def to_log_group(
        self,
        log_group: "_aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef",
    ) -> "CfnKnowledgeBaseLogsMixin":
        '''Send logs to a CloudWatch Log Group.

        :param log_group: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2abfbbece6e88024b43d1ce72e602e31f4747bd895c3c4a694de26aeb3a82a69)
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
        return typing.cast("CfnKnowledgeBaseLogsMixin", jsii.invoke(self, "toLogGroup", [log_group]))

    @jsii.member(jsii_name="toS3")
    def to_s3(
        self,
        bucket: "_aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef",
    ) -> "CfnKnowledgeBaseLogsMixin":
        '''Send logs to an S3 Bucket.

        :param bucket: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__059a829cfb2c6d46c203dfce4c1304ab07e5736a74a2247dd4a45faafb6a9747)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        return typing.cast("CfnKnowledgeBaseLogsMixin", jsii.invoke(self, "toS3", [bucket]))


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "customer_encryption_key_arn": "customerEncryptionKeyArn",
        "default_variant": "defaultVariant",
        "description": "description",
        "name": "name",
        "tags": "tags",
        "variants": "variants",
    },
)
class CfnPromptMixinProps:
    def __init__(
        self,
        *,
        customer_encryption_key_arn: typing.Optional[builtins.str] = None,
        default_variant: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        variants: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptVariantProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''Properties for CfnPromptPropsMixin.

        :param customer_encryption_key_arn: The Amazon Resource Name (ARN) of the KMS key that the prompt is encrypted with.
        :param default_variant: The name of the default variant for the prompt. This value must match the ``name`` field in the relevant `PromptVariant <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html>`_ object.
        :param description: The description of the prompt.
        :param name: The name of the prompt.
        :param tags: Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_
        :param variants: A list of objects, each containing details about a variant of the prompt.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            # additional_model_request_fields: Any
            # any: Any
            # auto: Any
            # json: Any
            
            cfn_prompt_mixin_props = bedrock_mixins.CfnPromptMixinProps(
                customer_encryption_key_arn="customerEncryptionKeyArn",
                default_variant="defaultVariant",
                description="description",
                name="name",
                tags={
                    "tags_key": "tags"
                },
                variants=[bedrock_mixins.CfnPromptPropsMixin.PromptVariantProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    gen_ai_resource=bedrock_mixins.CfnPromptPropsMixin.PromptGenAiResourceProperty(
                        agent=bedrock_mixins.CfnPromptPropsMixin.PromptAgentResourceProperty(
                            agent_identifier="agentIdentifier"
                        )
                    ),
                    inference_configuration=bedrock_mixins.CfnPromptPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    metadata=[bedrock_mixins.CfnPromptPropsMixin.PromptMetadataEntryProperty(
                        key="key",
                        value="value"
                    )],
                    model_id="modelId",
                    name="name",
                    template_configuration=bedrock_mixins.CfnPromptPropsMixin.PromptTemplateConfigurationProperty(
                        chat=bedrock_mixins.CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty(
                            input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            messages=[bedrock_mixins.CfnPromptPropsMixin.MessageProperty(
                                content=[bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                        type="type"
                                    ),
                                    text="text"
                                )],
                                role="role"
                            )],
                            system=[bedrock_mixins.CfnPromptPropsMixin.SystemContentBlockProperty(
                                cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                text="text"
                            )],
                            tool_configuration=bedrock_mixins.CfnPromptPropsMixin.ToolConfigurationProperty(
                                tool_choice=bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                                    any=any,
                                    auto=auto,
                                    tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                                        name="name"
                                    )
                                ),
                                tools=[bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                        type="type"
                                    ),
                                    tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                                        description="description",
                                        input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                                            json=json
                                        ),
                                        name="name"
                                    )
                                )]
                            )
                        ),
                        text=bedrock_mixins.CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty(
                            cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            text="text",
                            text_s3_location=bedrock_mixins.CfnPromptPropsMixin.TextS3LocationProperty(
                                bucket="bucket",
                                key="key",
                                version="version"
                            )
                        )
                    ),
                    template_type="templateType"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a14946a3c31d9068515dbd82d098269dd4986cc76ae4d42135103925f802a3fb)
            check_type(argname="argument customer_encryption_key_arn", value=customer_encryption_key_arn, expected_type=type_hints["customer_encryption_key_arn"])
            check_type(argname="argument default_variant", value=default_variant, expected_type=type_hints["default_variant"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument variants", value=variants, expected_type=type_hints["variants"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if customer_encryption_key_arn is not None:
            self._values["customer_encryption_key_arn"] = customer_encryption_key_arn
        if default_variant is not None:
            self._values["default_variant"] = default_variant
        if description is not None:
            self._values["description"] = description
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if variants is not None:
            self._values["variants"] = variants

    @builtins.property
    def customer_encryption_key_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the KMS key that the prompt is encrypted with.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-customerencryptionkeyarn
        '''
        result = self._values.get("customer_encryption_key_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_variant(self) -> typing.Optional[builtins.str]:
        '''The name of the default variant for the prompt.

        This value must match the ``name`` field in the relevant `PromptVariant <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html>`_ object.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-defaultvariant
        '''
        result = self._values.get("default_variant")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the prompt.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the prompt.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:.

        - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_
        - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def variants(
        self,
    ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptVariantProperty"]]]]:
        '''A list of objects, each containing details about a variant of the prompt.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-variants
        '''
        result = self._values.get("variants")
        return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptVariantProperty"]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPromptMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnPromptPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin",
):
    '''Creates a prompt in your prompt library that you can add to a flow.

    For more information, see `Prompt management in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html>`_ , `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ and `Prompt flows in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/flows.html>`_ in the Amazon Bedrock User Guide.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html
    :cloudformationResource: AWS::Bedrock::Prompt
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        # additional_model_request_fields: Any
        # any: Any
        # auto: Any
        # json: Any
        
        cfn_prompt_props_mixin = bedrock_mixins.CfnPromptPropsMixin(bedrock_mixins.CfnPromptMixinProps(
            customer_encryption_key_arn="customerEncryptionKeyArn",
            default_variant="defaultVariant",
            description="description",
            name="name",
            tags={
                "tags_key": "tags"
            },
            variants=[bedrock_mixins.CfnPromptPropsMixin.PromptVariantProperty(
                additional_model_request_fields=additional_model_request_fields,
                gen_ai_resource=bedrock_mixins.CfnPromptPropsMixin.PromptGenAiResourceProperty(
                    agent=bedrock_mixins.CfnPromptPropsMixin.PromptAgentResourceProperty(
                        agent_identifier="agentIdentifier"
                    )
                ),
                inference_configuration=bedrock_mixins.CfnPromptPropsMixin.PromptInferenceConfigurationProperty(
                    text=bedrock_mixins.CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty(
                        max_tokens=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_p=123
                    )
                ),
                metadata=[bedrock_mixins.CfnPromptPropsMixin.PromptMetadataEntryProperty(
                    key="key",
                    value="value"
                )],
                model_id="modelId",
                name="name",
                template_configuration=bedrock_mixins.CfnPromptPropsMixin.PromptTemplateConfigurationProperty(
                    chat=bedrock_mixins.CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty(
                        input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        messages=[bedrock_mixins.CfnPromptPropsMixin.MessageProperty(
                            content=[bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                                cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                text="text"
                            )],
                            role="role"
                        )],
                        system=[bedrock_mixins.CfnPromptPropsMixin.SystemContentBlockProperty(
                            cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            text="text"
                        )],
                        tool_configuration=bedrock_mixins.CfnPromptPropsMixin.ToolConfigurationProperty(
                            tool_choice=bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                                any=any,
                                auto=auto,
                                tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                                    name="name"
                                )
                            ),
                            tools=[bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                                cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                                    description="description",
                                    input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                                        json=json
                                    ),
                                    name="name"
                                )
                            )]
                        )
                    ),
                    text=bedrock_mixins.CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty(
                        cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        text="text",
                        text_s3_location=bedrock_mixins.CfnPromptPropsMixin.TextS3LocationProperty(
                            bucket="bucket",
                            key="key",
                            version="version"
                        )
                    )
                ),
                template_type="templateType"
            )]
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnPromptMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::Prompt``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a094cbfb4280670d93f2d810768085dd821db332a9a4656119b776cf4818aaf2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e590aafba79f200fcaa77d32f598bc885b1d6862900717fd4beb75b324636145)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa627246d6e599dfea28a528256dbb8eb38c8caad0ab8ff98328e04a0c646cde)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnPromptMixinProps":
        return typing.cast("CfnPromptMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.CachePointBlockProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type"},
    )
    class CachePointBlockProperty:
        def __init__(self, *, type: typing.Optional[builtins.str] = None) -> None:
            '''Defines a section of content to be cached for reuse in subsequent API calls.

            :param type: Specifies the type of cache point within the CachePointBlock.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-cachepointblock.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                cache_point_block_property = bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__24fa8e4d41718ca239622c8d63e09dc87ef8349db21b9c22cbea236daa3076ff)
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Specifies the type of cache point within the CachePointBlock.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-cachepointblock.html#cfn-bedrock-prompt-cachepointblock-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CachePointBlockProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "input_variables": "inputVariables",
            "messages": "messages",
            "system": "system",
            "tool_configuration": "toolConfiguration",
        },
    )
    class ChatPromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            input_variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptInputVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            messages: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.MessageProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            system: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.SystemContentBlockProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            tool_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ToolConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations to use a prompt in a conversational format.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ .

            :param input_variables: An array of the variables in the prompt template.
            :param messages: Contains messages in the chat for the prompt.
            :param system: Contains system prompts to provide context to the model or to describe how it should behave.
            :param tool_configuration: Configuration information for the tools that the model can use when generating a response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-chatprompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                # json: Any
                
                chat_prompt_template_configuration_property = bedrock_mixins.CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty(
                    input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                        name="name"
                    )],
                    messages=[bedrock_mixins.CfnPromptPropsMixin.MessageProperty(
                        content=[bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                            cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            text="text"
                        )],
                        role="role"
                    )],
                    system=[bedrock_mixins.CfnPromptPropsMixin.SystemContentBlockProperty(
                        cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        text="text"
                    )],
                    tool_configuration=bedrock_mixins.CfnPromptPropsMixin.ToolConfigurationProperty(
                        tool_choice=bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                            any=any,
                            auto=auto,
                            tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                                name="name"
                            )
                        ),
                        tools=[bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                            cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                                description="description",
                                input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                                    json=json
                                ),
                                name="name"
                            )
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5956f8b6e2854510ec0f25eb7577dae1fd3691069cc89f0ede0fb8923a4ce8d5)
                check_type(argname="argument input_variables", value=input_variables, expected_type=type_hints["input_variables"])
                check_type(argname="argument messages", value=messages, expected_type=type_hints["messages"])
                check_type(argname="argument system", value=system, expected_type=type_hints["system"])
                check_type(argname="argument tool_configuration", value=tool_configuration, expected_type=type_hints["tool_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_variables is not None:
                self._values["input_variables"] = input_variables
            if messages is not None:
                self._values["messages"] = messages
            if system is not None:
                self._values["system"] = system
            if tool_configuration is not None:
                self._values["tool_configuration"] = tool_configuration

        @builtins.property
        def input_variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptInputVariableProperty"]]]]:
            '''An array of the variables in the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-chatprompttemplateconfiguration.html#cfn-bedrock-prompt-chatprompttemplateconfiguration-inputvariables
            '''
            result = self._values.get("input_variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptInputVariableProperty"]]]], result)

        @builtins.property
        def messages(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.MessageProperty"]]]]:
            '''Contains messages in the chat for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-chatprompttemplateconfiguration.html#cfn-bedrock-prompt-chatprompttemplateconfiguration-messages
            '''
            result = self._values.get("messages")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.MessageProperty"]]]], result)

        @builtins.property
        def system(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.SystemContentBlockProperty"]]]]:
            '''Contains system prompts to provide context to the model or to describe how it should behave.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-chatprompttemplateconfiguration.html#cfn-bedrock-prompt-chatprompttemplateconfiguration-system
            '''
            result = self._values.get("system")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.SystemContentBlockProperty"]]]], result)

        @builtins.property
        def tool_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolConfigurationProperty"]]:
            '''Configuration information for the tools that the model can use when generating a response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-chatprompttemplateconfiguration.html#cfn-bedrock-prompt-chatprompttemplateconfiguration-toolconfiguration
            '''
            result = self._values.get("tool_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ChatPromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ContentBlockProperty",
        jsii_struct_bases=[],
        name_mapping={"cache_point": "cachePoint", "text": "text"},
    )
    class ContentBlockProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A block of content for a message that you pass to, or receive from, a model with the `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ or `ConverseStream <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html>`_ API operations.

            :param cache_point: CachePoint to include in the message.
            :param text: Text to include in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-contentblock.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                content_block_property = bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__eb24c9e29dc44f120a7d2305c916a3b33fad8d0401e44c339b5e11b56a22c92f)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]]:
            '''CachePoint to include in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-contentblock.html#cfn-bedrock-prompt-contentblock-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''Text to include in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-contentblock.html#cfn-bedrock-prompt-contentblock-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContentBlockProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.MessageProperty",
        jsii_struct_bases=[],
        name_mapping={"content": "content", "role": "role"},
    )
    class MessageProperty:
        def __init__(
            self,
            *,
            content: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ContentBlockProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            role: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A message input, or returned from, a call to `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ or `ConverseStream <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html>`_ .

            :param content: The message content. Note the following restrictions:. - You can include up to 20 images. Each image's size, height, and width must be no more than 3.75 MB, 8000 px, and 8000 px, respectively. - You can include up to five documents. Each document's size must be no more than 4.5 MB. - If you include a ``ContentBlock`` with a ``document`` field in the array, you must also include a ``ContentBlock`` with a ``text`` field. - You can only include images and documents if the ``role`` is ``user`` .
            :param role: The role that the message plays in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-message.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                message_property = bedrock_mixins.CfnPromptPropsMixin.MessageProperty(
                    content=[bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                        cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        text="text"
                    )],
                    role="role"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d9b70f428bf1f4c6c9c7cbf370384577983d5e908b80cfa673c3b22760b7d1fb)
                check_type(argname="argument content", value=content, expected_type=type_hints["content"])
                check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if content is not None:
                self._values["content"] = content
            if role is not None:
                self._values["role"] = role

        @builtins.property
        def content(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ContentBlockProperty"]]]]:
            '''The message content. Note the following restrictions:.

            - You can include up to 20 images. Each image's size, height, and width must be no more than 3.75 MB, 8000 px, and 8000 px, respectively.
            - You can include up to five documents. Each document's size must be no more than 4.5 MB.
            - If you include a ``ContentBlock`` with a ``document`` field in the array, you must also include a ``ContentBlock`` with a ``text`` field.
            - You can only include images and documents if the ``role`` is ``user`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-message.html#cfn-bedrock-prompt-message-content
            '''
            result = self._values.get("content")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ContentBlockProperty"]]]], result)

        @builtins.property
        def role(self) -> typing.Optional[builtins.str]:
            '''The role that the message plays in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-message.html#cfn-bedrock-prompt-message-role
            '''
            result = self._values.get("role")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MessageProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptAgentResourceProperty",
        jsii_struct_bases=[],
        name_mapping={"agent_identifier": "agentIdentifier"},
    )
    class PromptAgentResourceProperty:
        def __init__(
            self,
            *,
            agent_identifier: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains specifications for an Amazon Bedrock agent with which to use the prompt.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ and `Automate tasks in your application using conversational agents <https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html>`_ .

            :param agent_identifier: The ARN of the agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptagentresource.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_agent_resource_property = bedrock_mixins.CfnPromptPropsMixin.PromptAgentResourceProperty(
                    agent_identifier="agentIdentifier"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a1ddd94aa9ed36430e8dfab335118b21cf48ec73b935e1dcaf4de0fa8d420a78)
                check_type(argname="argument agent_identifier", value=agent_identifier, expected_type=type_hints["agent_identifier"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent_identifier is not None:
                self._values["agent_identifier"] = agent_identifier

        @builtins.property
        def agent_identifier(self) -> typing.Optional[builtins.str]:
            '''The ARN of the agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptagentresource.html#cfn-bedrock-prompt-promptagentresource-agentidentifier
            '''
            result = self._values.get("agent_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptAgentResourceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptGenAiResourceProperty",
        jsii_struct_bases=[],
        name_mapping={"agent": "agent"},
    )
    class PromptGenAiResourceProperty:
        def __init__(
            self,
            *,
            agent: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptAgentResourceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains specifications for a generative AI resource with which to use the prompt.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ .

            :param agent: Specifies an Amazon Bedrock agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptgenairesource.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_gen_ai_resource_property = bedrock_mixins.CfnPromptPropsMixin.PromptGenAiResourceProperty(
                    agent=bedrock_mixins.CfnPromptPropsMixin.PromptAgentResourceProperty(
                        agent_identifier="agentIdentifier"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e99c733b72a8ed34cec0e6298548d0558fe3e2791da569df3c49f9da89630502)
                check_type(argname="argument agent", value=agent, expected_type=type_hints["agent"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent is not None:
                self._values["agent"] = agent

        @builtins.property
        def agent(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptAgentResourceProperty"]]:
            '''Specifies an Amazon Bedrock agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptgenairesource.html#cfn-bedrock-prompt-promptgenairesource-agent
            '''
            result = self._values.get("agent")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptAgentResourceProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptGenAiResourceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"text": "text"},
    )
    class PromptInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains inference configurations for the prompt.

            :param text: Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_inference_configuration_property = bedrock_mixins.CfnPromptPropsMixin.PromptInferenceConfigurationProperty(
                    text=bedrock_mixins.CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty(
                        max_tokens=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_p=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4d87769f2598c5b6dc36858f19ddb61ba534ee6ff4ab74a6b2d85fec8f95bf39)
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty"]]:
            '''Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptinferenceconfiguration.html#cfn-bedrock-prompt-promptinferenceconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptInputVariableProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class PromptInputVariableProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about a variable in the prompt.

            :param name: The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptinputvariable.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_input_variable_property = bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3ed13c5b893db25e2dcc5fad3d76c9f7583795518701e75681a10fddd3750369)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptinputvariable.html#cfn-bedrock-prompt-promptinputvariable-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInputVariableProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptMetadataEntryProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class PromptMetadataEntryProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ .

            :param key: The key of a metadata tag for a prompt variant.
            :param value: The value of a metadata tag for a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmetadataentry.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_metadata_entry_property = bedrock_mixins.CfnPromptPropsMixin.PromptMetadataEntryProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__02ac17549da7923abe265e9c53dac95252cf813fce97265ff2500e2e4b9d4600)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The key of a metadata tag for a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmetadataentry.html#cfn-bedrock-prompt-promptmetadataentry-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value of a metadata tag for a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmetadataentry.html#cfn-bedrock-prompt-promptmetadataentry-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptMetadataEntryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_tokens": "maxTokens",
            "stop_sequences": "stopSequences",
            "temperature": "temperature",
            "top_p": "topP",
        },
    )
    class PromptModelInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            max_tokens: typing.Optional[jsii.Number] = None,
            stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
            temperature: typing.Optional[jsii.Number] = None,
            top_p: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Contains inference configurations related to model inference for a prompt.

            For more information, see `Inference parameters <https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html>`_ .

            :param max_tokens: The maximum number of tokens to return in the response.
            :param stop_sequences: A list of strings that define sequences after which the model will stop generating.
            :param temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
            :param top_p: The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmodelinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_model_inference_configuration_property = bedrock_mixins.CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty(
                    max_tokens=123,
                    stop_sequences=["stopSequences"],
                    temperature=123,
                    top_p=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1ed6d038e2534cfc7fceda441ebf3a4bbb5ad7d523e3bc9519e311ccee6ba99e)
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
                check_type(argname="argument stop_sequences", value=stop_sequences, expected_type=type_hints["stop_sequences"])
                check_type(argname="argument temperature", value=temperature, expected_type=type_hints["temperature"])
                check_type(argname="argument top_p", value=top_p, expected_type=type_hints["top_p"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens
            if stop_sequences is not None:
                self._values["stop_sequences"] = stop_sequences
            if temperature is not None:
                self._values["temperature"] = temperature
            if top_p is not None:
                self._values["top_p"] = top_p

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens to return in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmodelinferenceconfiguration.html#cfn-bedrock-prompt-promptmodelinferenceconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def stop_sequences(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of strings that define sequences after which the model will stop generating.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmodelinferenceconfiguration.html#cfn-bedrock-prompt-promptmodelinferenceconfiguration-stopsequences
            '''
            result = self._values.get("stop_sequences")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def temperature(self) -> typing.Optional[jsii.Number]:
            '''Controls the randomness of the response.

            Choose a lower value for more predictable outputs and a higher value for more surprising outputs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmodelinferenceconfiguration.html#cfn-bedrock-prompt-promptmodelinferenceconfiguration-temperature
            '''
            result = self._values.get("temperature")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def top_p(self) -> typing.Optional[jsii.Number]:
            '''The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptmodelinferenceconfiguration.html#cfn-bedrock-prompt-promptmodelinferenceconfiguration-topp
            '''
            result = self._values.get("top_p")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptModelInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"chat": "chat", "text": "text"},
    )
    class PromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            chat: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains the message for a prompt.

            For more information, see `Construct and store reusable prompts with Prompt management in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html>`_ .

            :param chat: Contains configurations to use the prompt in a conversational format.
            :param text: Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-prompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                # json: Any
                
                prompt_template_configuration_property = bedrock_mixins.CfnPromptPropsMixin.PromptTemplateConfigurationProperty(
                    chat=bedrock_mixins.CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty(
                        input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        messages=[bedrock_mixins.CfnPromptPropsMixin.MessageProperty(
                            content=[bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                                cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                text="text"
                            )],
                            role="role"
                        )],
                        system=[bedrock_mixins.CfnPromptPropsMixin.SystemContentBlockProperty(
                            cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            text="text"
                        )],
                        tool_configuration=bedrock_mixins.CfnPromptPropsMixin.ToolConfigurationProperty(
                            tool_choice=bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                                any=any,
                                auto=auto,
                                tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                                    name="name"
                                )
                            ),
                            tools=[bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                                cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                                    description="description",
                                    input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                                        json=json
                                    ),
                                    name="name"
                                )
                            )]
                        )
                    ),
                    text=bedrock_mixins.CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty(
                        cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        text="text",
                        text_s3_location=bedrock_mixins.CfnPromptPropsMixin.TextS3LocationProperty(
                            bucket="bucket",
                            key="key",
                            version="version"
                        )
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a089bab2688b7b63bb7a073ba3a7b02dc4a2b5fb2bfa86c826ec03531c6f2289)
                check_type(argname="argument chat", value=chat, expected_type=type_hints["chat"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if chat is not None:
                self._values["chat"] = chat
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def chat(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty"]]:
            '''Contains configurations to use the prompt in a conversational format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-prompttemplateconfiguration.html#cfn-bedrock-prompt-prompttemplateconfiguration-chat
            '''
            result = self._values.get("chat")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty"]], result)

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty"]]:
            '''Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-prompttemplateconfiguration.html#cfn-bedrock-prompt-prompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.PromptVariantProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "gen_ai_resource": "genAiResource",
            "inference_configuration": "inferenceConfiguration",
            "metadata": "metadata",
            "model_id": "modelId",
            "name": "name",
            "template_configuration": "templateConfiguration",
            "template_type": "templateType",
        },
    )
    class PromptVariantProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            gen_ai_resource: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptGenAiResourceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            metadata: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptMetadataEntryProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            model_id: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            template_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            template_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about a variant of the prompt.

            :param additional_model_request_fields: Contains model-specific inference configurations that aren't in the ``inferenceConfiguration`` field. To see model-specific inference parameters, see `Inference request parameters and response fields for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .
            :param gen_ai_resource: Specifies a generative AI resource with which to use the prompt.
            :param inference_configuration: Contains inference configurations for the prompt variant.
            :param metadata: An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
            :param model_id: The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ with which to run inference on the prompt.
            :param name: The name of the prompt variant.
            :param template_configuration: Contains configurations for the prompt template.
            :param template_type: The type of prompt template to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # any: Any
                # auto: Any
                # json: Any
                
                prompt_variant_property = bedrock_mixins.CfnPromptPropsMixin.PromptVariantProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    gen_ai_resource=bedrock_mixins.CfnPromptPropsMixin.PromptGenAiResourceProperty(
                        agent=bedrock_mixins.CfnPromptPropsMixin.PromptAgentResourceProperty(
                            agent_identifier="agentIdentifier"
                        )
                    ),
                    inference_configuration=bedrock_mixins.CfnPromptPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    metadata=[bedrock_mixins.CfnPromptPropsMixin.PromptMetadataEntryProperty(
                        key="key",
                        value="value"
                    )],
                    model_id="modelId",
                    name="name",
                    template_configuration=bedrock_mixins.CfnPromptPropsMixin.PromptTemplateConfigurationProperty(
                        chat=bedrock_mixins.CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty(
                            input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            messages=[bedrock_mixins.CfnPromptPropsMixin.MessageProperty(
                                content=[bedrock_mixins.CfnPromptPropsMixin.ContentBlockProperty(
                                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                        type="type"
                                    ),
                                    text="text"
                                )],
                                role="role"
                            )],
                            system=[bedrock_mixins.CfnPromptPropsMixin.SystemContentBlockProperty(
                                cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                text="text"
                            )],
                            tool_configuration=bedrock_mixins.CfnPromptPropsMixin.ToolConfigurationProperty(
                                tool_choice=bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                                    any=any,
                                    auto=auto,
                                    tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                                        name="name"
                                    )
                                ),
                                tools=[bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                        type="type"
                                    ),
                                    tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                                        description="description",
                                        input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                                            json=json
                                        ),
                                        name="name"
                                    )
                                )]
                            )
                        ),
                        text=bedrock_mixins.CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty(
                            cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            text="text",
                            text_s3_location=bedrock_mixins.CfnPromptPropsMixin.TextS3LocationProperty(
                                bucket="bucket",
                                key="key",
                                version="version"
                            )
                        )
                    ),
                    template_type="templateType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__56e8072552c8c928b05b18f37de4bcf222fd0568a32161cb27ccbc4a305c9dc0)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument gen_ai_resource", value=gen_ai_resource, expected_type=type_hints["gen_ai_resource"])
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
                check_type(argname="argument model_id", value=model_id, expected_type=type_hints["model_id"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument template_configuration", value=template_configuration, expected_type=type_hints["template_configuration"])
                check_type(argname="argument template_type", value=template_type, expected_type=type_hints["template_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if gen_ai_resource is not None:
                self._values["gen_ai_resource"] = gen_ai_resource
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if metadata is not None:
                self._values["metadata"] = metadata
            if model_id is not None:
                self._values["model_id"] = model_id
            if name is not None:
                self._values["name"] = name
            if template_configuration is not None:
                self._values["template_configuration"] = template_configuration
            if template_type is not None:
                self._values["template_type"] = template_type

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''Contains model-specific inference configurations that aren't in the ``inferenceConfiguration`` field.

            To see model-specific inference parameters, see `Inference request parameters and response fields for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def gen_ai_resource(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptGenAiResourceProperty"]]:
            '''Specifies a generative AI resource with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-genairesource
            '''
            result = self._values.get("gen_ai_resource")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptGenAiResourceProperty"]], result)

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def metadata(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptMetadataEntryProperty"]]]]:
            '''An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-metadata
            '''
            result = self._values.get("metadata")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptMetadataEntryProperty"]]]], result)

        @builtins.property
        def model_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ with which to run inference on the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-modelid
            '''
            result = self._values.get("model_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def template_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptTemplateConfigurationProperty"]]:
            '''Contains configurations for the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-templateconfiguration
            '''
            result = self._values.get("template_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptTemplateConfigurationProperty"]], result)

        @builtins.property
        def template_type(self) -> typing.Optional[builtins.str]:
            '''The type of prompt template to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-promptvariant.html#cfn-bedrock-prompt-promptvariant-templatetype
            '''
            result = self._values.get("template_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptVariantProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class SpecificToolChoiceProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''The model must request a specific tool.

            For example, ``{"tool" : {"name" : "Your tool name"}}`` . For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide
            .. epigraph::

               This field is only supported by Anthropic Claude 3 models.

            :param name: The name of the tool that the model must request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-specifictoolchoice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                specific_tool_choice_property = bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__160f5fbae9e5398eb5ea17cd91e0dbd924ad65e58f16a3a6e3a552c3b34750fb)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the tool that the model must request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-specifictoolchoice.html#cfn-bedrock-prompt-specifictoolchoice-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpecificToolChoiceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.SystemContentBlockProperty",
        jsii_struct_bases=[],
        name_mapping={"cache_point": "cachePoint", "text": "text"},
    )
    class SystemContentBlockProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for instructions to provide the model for how to handle input.

            To learn more, see `Using the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference-call.html>`_ .

            :param cache_point: CachePoint to include in the system prompt.
            :param text: A system prompt for the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-systemcontentblock.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                system_content_block_property = bedrock_mixins.CfnPromptPropsMixin.SystemContentBlockProperty(
                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__17a5d2881040bf64d7982f6fe5169405c39bde8065ac9f181c0ebd2c8011808f)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]]:
            '''CachePoint to include in the system prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-systemcontentblock.html#cfn-bedrock-prompt-systemcontentblock-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''A system prompt for the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-systemcontentblock.html#cfn-bedrock-prompt-systemcontentblock-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SystemContentBlockProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cache_point": "cachePoint",
            "input_variables": "inputVariables",
            "text": "text",
            "text_s3_location": "textS3Location",
        },
    )
    class TextPromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            input_variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.PromptInputVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            text: typing.Optional[builtins.str] = None,
            text_s3_location: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.TextS3LocationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations for a text prompt template.

            To include a variable, enclose a word in double curly braces as in ``{{variable}}`` .

            :param cache_point: A cache checkpoint within a template configuration.
            :param input_variables: An array of the variables in the prompt template.
            :param text: The message for the prompt.
            :param text_s3_location: The Amazon S3 location of the prompt text.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-textprompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                text_prompt_template_configuration_property = bedrock_mixins.CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty(
                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    input_variables=[bedrock_mixins.CfnPromptPropsMixin.PromptInputVariableProperty(
                        name="name"
                    )],
                    text="text",
                    text_s3_location=bedrock_mixins.CfnPromptPropsMixin.TextS3LocationProperty(
                        bucket="bucket",
                        key="key",
                        version="version"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__749ec2a8e5afe78f0fe92d9885e696259d206b4f41438623353deb89b953e1cd)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument input_variables", value=input_variables, expected_type=type_hints["input_variables"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
                check_type(argname="argument text_s3_location", value=text_s3_location, expected_type=type_hints["text_s3_location"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if input_variables is not None:
                self._values["input_variables"] = input_variables
            if text is not None:
                self._values["text"] = text
            if text_s3_location is not None:
                self._values["text_s3_location"] = text_s3_location

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]]:
            '''A cache checkpoint within a template configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-textprompttemplateconfiguration.html#cfn-bedrock-prompt-textprompttemplateconfiguration-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def input_variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptInputVariableProperty"]]]]:
            '''An array of the variables in the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-textprompttemplateconfiguration.html#cfn-bedrock-prompt-textprompttemplateconfiguration-inputvariables
            '''
            result = self._values.get("input_variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.PromptInputVariableProperty"]]]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-textprompttemplateconfiguration.html#cfn-bedrock-prompt-textprompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def text_s3_location(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.TextS3LocationProperty"]]:
            '''The Amazon S3 location of the prompt text.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-textprompttemplateconfiguration.html#cfn-bedrock-prompt-textprompttemplateconfiguration-texts3location
            '''
            result = self._values.get("text_s3_location")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.TextS3LocationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TextPromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.TextS3LocationProperty",
        jsii_struct_bases=[],
        name_mapping={"bucket": "bucket", "key": "key", "version": "version"},
    )
    class TextS3LocationProperty:
        def __init__(
            self,
            *,
            bucket: typing.Optional[builtins.str] = None,
            key: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The Amazon S3 location of the prompt text.

            :param bucket: The Amazon S3 bucket containing the prompt text.
            :param key: The object key for the Amazon S3 location.
            :param version: The version of the Amazon S3 location to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-texts3location.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                text_s3_location_property = bedrock_mixins.CfnPromptPropsMixin.TextS3LocationProperty(
                    bucket="bucket",
                    key="key",
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__85123bda6169bf63a68a1706cb9b32de3808babea9940f4b4938a5d1f4394601)
                check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if bucket is not None:
                self._values["bucket"] = bucket
            if key is not None:
                self._values["key"] = key
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def bucket(self) -> typing.Optional[builtins.str]:
            '''The Amazon S3 bucket containing the prompt text.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-texts3location.html#cfn-bedrock-prompt-texts3location-bucket
            '''
            result = self._values.get("bucket")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The object key for the Amazon S3 location.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-texts3location.html#cfn-bedrock-prompt-texts3location-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The version of the Amazon S3 location to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-texts3location.html#cfn-bedrock-prompt-texts3location-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TextS3LocationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ToolChoiceProperty",
        jsii_struct_bases=[],
        name_mapping={"any": "any", "auto": "auto", "tool": "tool"},
    )
    class ToolChoiceProperty:
        def __init__(
            self,
            *,
            any: typing.Any = None,
            auto: typing.Any = None,
            tool: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.SpecificToolChoiceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Determines which tools the model should request in a call to ``Converse`` or ``ConverseStream`` .

            For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param any: The model must request at least one tool (no text is generated).
            :param auto: (Default). The Model automatically decides if a tool should be called or whether to generate text instead.
            :param tool: The Model must request the specified tool. Only supported by Anthropic Claude 3 and Amazon Nova models.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolchoice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                
                tool_choice_property = bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                    any=any,
                    auto=auto,
                    tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                        name="name"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__507b3516ed713048d1fb1e6a967f4d3588d99aa3611c8aa53b999464068c3e34)
                check_type(argname="argument any", value=any, expected_type=type_hints["any"])
                check_type(argname="argument auto", value=auto, expected_type=type_hints["auto"])
                check_type(argname="argument tool", value=tool, expected_type=type_hints["tool"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if any is not None:
                self._values["any"] = any
            if auto is not None:
                self._values["auto"] = auto
            if tool is not None:
                self._values["tool"] = tool

        @builtins.property
        def any(self) -> typing.Any:
            '''The model must request at least one tool (no text is generated).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolchoice.html#cfn-bedrock-prompt-toolchoice-any
            '''
            result = self._values.get("any")
            return typing.cast(typing.Any, result)

        @builtins.property
        def auto(self) -> typing.Any:
            '''(Default).

            The Model automatically decides if a tool should be called or whether to generate text instead.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolchoice.html#cfn-bedrock-prompt-toolchoice-auto
            '''
            result = self._values.get("auto")
            return typing.cast(typing.Any, result)

        @builtins.property
        def tool(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.SpecificToolChoiceProperty"]]:
            '''The Model must request the specified tool.

            Only supported by Anthropic Claude 3 and Amazon Nova models.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolchoice.html#cfn-bedrock-prompt-toolchoice-tool
            '''
            result = self._values.get("tool")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.SpecificToolChoiceProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolChoiceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ToolConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"tool_choice": "toolChoice", "tools": "tools"},
    )
    class ToolConfigurationProperty:
        def __init__(
            self,
            *,
            tool_choice: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ToolChoiceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tools: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ToolProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Configuration information for the tools that you pass to a model.

            For more information, see `Tool use (function calling) <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param tool_choice: If supported by model, forces the model to request a tool.
            :param tools: An array of tools that you want to pass to a model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                # json: Any
                
                tool_configuration_property = bedrock_mixins.CfnPromptPropsMixin.ToolConfigurationProperty(
                    tool_choice=bedrock_mixins.CfnPromptPropsMixin.ToolChoiceProperty(
                        any=any,
                        auto=auto,
                        tool=bedrock_mixins.CfnPromptPropsMixin.SpecificToolChoiceProperty(
                            name="name"
                        )
                    ),
                    tools=[bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                        cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                            description="description",
                            input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                                json=json
                            ),
                            name="name"
                        )
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b6b2970d0d437674c8331b5a9dc96a3d9565f8e56c23ac3ecec715fb740daac2)
                check_type(argname="argument tool_choice", value=tool_choice, expected_type=type_hints["tool_choice"])
                check_type(argname="argument tools", value=tools, expected_type=type_hints["tools"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if tool_choice is not None:
                self._values["tool_choice"] = tool_choice
            if tools is not None:
                self._values["tools"] = tools

        @builtins.property
        def tool_choice(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolChoiceProperty"]]:
            '''If supported by model, forces the model to request a tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolconfiguration.html#cfn-bedrock-prompt-toolconfiguration-toolchoice
            '''
            result = self._values.get("tool_choice")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolChoiceProperty"]], result)

        @builtins.property
        def tools(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolProperty"]]]]:
            '''An array of tools that you want to pass to a model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolconfiguration.html#cfn-bedrock-prompt-toolconfiguration-tools
            '''
            result = self._values.get("tools")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ToolInputSchemaProperty",
        jsii_struct_bases=[],
        name_mapping={"json": "json"},
    )
    class ToolInputSchemaProperty:
        def __init__(self, *, json: typing.Any = None) -> None:
            '''The schema for the tool.

            The top level schema type must be ``object`` . For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param json: The JSON schema for the tool. For more information, see `JSON Schema Reference <https://docs.aws.amazon.com/https://json-schema.org/understanding-json-schema/reference>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolinputschema.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # json: Any
                
                tool_input_schema_property = bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                    json=json
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a2610895777083766fdeed410f30def3f53d7c7bf9d829ea66ce903197af0815)
                check_type(argname="argument json", value=json, expected_type=type_hints["json"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if json is not None:
                self._values["json"] = json

        @builtins.property
        def json(self) -> typing.Any:
            '''The JSON schema for the tool.

            For more information, see `JSON Schema Reference <https://docs.aws.amazon.com/https://json-schema.org/understanding-json-schema/reference>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolinputschema.html#cfn-bedrock-prompt-toolinputschema-json
            '''
            result = self._values.get("json")
            return typing.cast(typing.Any, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolInputSchemaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ToolProperty",
        jsii_struct_bases=[],
        name_mapping={"cache_point": "cachePoint", "tool_spec": "toolSpec"},
    )
    class ToolProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tool_spec: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ToolSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Information about a tool that you can use with the Converse API.

            For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param cache_point: CachePoint to include in the tool configuration.
            :param tool_spec: The specfication for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-tool.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # json: Any
                
                tool_property = bedrock_mixins.CfnPromptPropsMixin.ToolProperty(
                    cache_point=bedrock_mixins.CfnPromptPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    tool_spec=bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                        description="description",
                        input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                            json=json
                        ),
                        name="name"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__723e5b0fe26dfce5735f34b8a852d322fcb3eff849bff6d0e459f5ee882a2b92)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument tool_spec", value=tool_spec, expected_type=type_hints["tool_spec"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if tool_spec is not None:
                self._values["tool_spec"] = tool_spec

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]]:
            '''CachePoint to include in the tool configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-tool.html#cfn-bedrock-prompt-tool-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def tool_spec(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolSpecificationProperty"]]:
            '''The specfication for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-tool.html#cfn-bedrock-prompt-tool-toolspec
            '''
            result = self._values.get("tool_spec")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolSpecificationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptPropsMixin.ToolSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "input_schema": "inputSchema",
            "name": "name",
        },
    )
    class ToolSpecificationProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            input_schema: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptPropsMixin.ToolInputSchemaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The specification for the tool.

            For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param description: The description for the tool.
            :param input_schema: The input schema for the tool in JSON format.
            :param name: The name for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # json: Any
                
                tool_specification_property = bedrock_mixins.CfnPromptPropsMixin.ToolSpecificationProperty(
                    description="description",
                    input_schema=bedrock_mixins.CfnPromptPropsMixin.ToolInputSchemaProperty(
                        json=json
                    ),
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__cb3797ef0fc77a691d771fd9d23e3c18fa37fe6ae178a268f5092133fb851da1)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument input_schema", value=input_schema, expected_type=type_hints["input_schema"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if input_schema is not None:
                self._values["input_schema"] = input_schema
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolspecification.html#cfn-bedrock-prompt-toolspecification-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_schema(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolInputSchemaProperty"]]:
            '''The input schema for the tool in JSON format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolspecification.html#cfn-bedrock-prompt-toolspecification-inputschema
            '''
            result = self._values.get("input_schema")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptPropsMixin.ToolInputSchemaProperty"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-prompt-toolspecification.html#cfn-bedrock-prompt-toolspecification-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionMixinProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "prompt_arn": "promptArn",
        "tags": "tags",
    },
)
class CfnPromptVersionMixinProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        prompt_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for CfnPromptVersionPropsMixin.

        :param description: The description of the prompt version.
        :param prompt_arn: The Amazon Resource Name (ARN) of the version of the prompt.
        :param tags: A map of tags attached to the prompt version and their values.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-promptversion.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
            
            cfn_prompt_version_mixin_props = bedrock_mixins.CfnPromptVersionMixinProps(
                description="description",
                prompt_arn="promptArn",
                tags={
                    "tags_key": "tags"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__622c9d30ced7a4484e9240f0cdaaa58efaf388e90e5dd89af18d194e7587a26f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument prompt_arn", value=prompt_arn, expected_type=type_hints["prompt_arn"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if prompt_arn is not None:
            self._values["prompt_arn"] = prompt_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the prompt version.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-promptversion.html#cfn-bedrock-promptversion-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prompt_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the version of the prompt.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-promptversion.html#cfn-bedrock-promptversion-promptarn
        '''
        result = self._values.get("prompt_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map of tags attached to the prompt version and their values.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-promptversion.html#cfn-bedrock-promptversion-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPromptVersionMixinProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IMixin_11e4b965)
class CfnPromptVersionPropsMixin(
    _Mixin_a69446c0,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin",
):
    '''Creates a static snapshot of your prompt that can be deployed to production.

    For more information, see `Deploy prompts using Prompt management by creating versions <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-deploy.html>`_ in the Amazon Bedrock User Guide.

    :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-promptversion.html
    :cloudformationResource: AWS::Bedrock::PromptVersion
    :mixin: true
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk.mixins_preview import mixins
        from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
        
        cfn_prompt_version_props_mixin = bedrock_mixins.CfnPromptVersionPropsMixin(bedrock_mixins.CfnPromptVersionMixinProps(
            description="description",
            prompt_arn="promptArn",
            tags={
                "tags_key": "tags"
            }
        ),
            strategy=mixins.PropertyMergeStrategy.OVERRIDE
        )
    '''

    def __init__(
        self,
        props: typing.Union["CfnPromptVersionMixinProps", typing.Dict[builtins.str, typing.Any]],
        *,
        strategy: typing.Optional["_PropertyMergeStrategy_49c157e8"] = None,
    ) -> None:
        '''Create a mixin to apply properties to ``AWS::Bedrock::PromptVersion``.

        :param props: L1 properties to apply.
        :param strategy: (experimental) Strategy for merging nested properties. Default: - PropertyMergeStrategy.MERGE
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a756472cdf71dfe1be28fa6cbf234d74805f0125256849a4f19c28dec0b9b412)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        options = _CfnPropertyMixinOptions_9cbff649(strategy=strategy)

        jsii.create(self.__class__, self, [props, options])

    @jsii.member(jsii_name="applyTo")
    def apply_to(
        self,
        construct: "_constructs_77d1e7e8.IConstruct",
    ) -> "_constructs_77d1e7e8.IConstruct":
        '''Apply the mixin properties to the construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67a00d6dd8bc31c7d5b5f607d8f1d5d4b99901e09833ca78726624724e493f3b)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast("_constructs_77d1e7e8.IConstruct", jsii.invoke(self, "applyTo", [construct]))

    @jsii.member(jsii_name="supports")
    def supports(self, construct: "_constructs_77d1e7e8.IConstruct") -> builtins.bool:
        '''Check if this mixin supports the given construct.

        :param construct: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70b81762a8a3f43ffa417f2c0eef6dc90a93e74c848091fd0ce08a79f15ee783)
            check_type(argname="argument construct", value=construct, expected_type=type_hints["construct"])
        return typing.cast(builtins.bool, jsii.invoke(self, "supports", [construct]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_PROPERTY_KEYS")
    def CFN_PROPERTY_KEYS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "CFN_PROPERTY_KEYS"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "CfnPromptVersionMixinProps":
        return typing.cast("CfnPromptVersionMixinProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "_PropertyMergeStrategy_49c157e8":
        return typing.cast("_PropertyMergeStrategy_49c157e8", jsii.get(self, "strategy"))

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type"},
    )
    class CachePointBlockProperty:
        def __init__(self, *, type: typing.Optional[builtins.str] = None) -> None:
            '''Defines a section of content to be cached for reuse in subsequent API calls.

            :param type: Specifies the type of cache point within the CachePointBlock.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-cachepointblock.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                cache_point_block_property = bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                    type="type"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4bc2a19aa9517e05f3563761b0eecdb383650a6246dbc7c8f49ee274d7145c69)
                check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''Specifies the type of cache point within the CachePointBlock.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-cachepointblock.html#cfn-bedrock-promptversion-cachepointblock-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CachePointBlockProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "input_variables": "inputVariables",
            "messages": "messages",
            "system": "system",
            "tool_configuration": "toolConfiguration",
        },
    )
    class ChatPromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            input_variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptInputVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            messages: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.MessageProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            system: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.SystemContentBlockProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            tool_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ToolConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains configurations to use a prompt in a conversational format.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ .

            :param input_variables: An array of the variables in the prompt template.
            :param messages: Contains messages in the chat for the prompt.
            :param system: Contains system prompts to provide context to the model or to describe how it should behave.
            :param tool_configuration: Configuration information for the tools that the model can use when generating a response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-chatprompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                # json: Any
                
                chat_prompt_template_configuration_property = bedrock_mixins.CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty(
                    input_variables=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                        name="name"
                    )],
                    messages=[bedrock_mixins.CfnPromptVersionPropsMixin.MessageProperty(
                        content=[bedrock_mixins.CfnPromptVersionPropsMixin.ContentBlockProperty(
                            cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            text="text"
                        )],
                        role="role"
                    )],
                    system=[bedrock_mixins.CfnPromptVersionPropsMixin.SystemContentBlockProperty(
                        cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        text="text"
                    )],
                    tool_configuration=bedrock_mixins.CfnPromptVersionPropsMixin.ToolConfigurationProperty(
                        tool_choice=bedrock_mixins.CfnPromptVersionPropsMixin.ToolChoiceProperty(
                            any=any,
                            auto=auto,
                            tool=bedrock_mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty(
                                name="name"
                            )
                        ),
                        tools=[bedrock_mixins.CfnPromptVersionPropsMixin.ToolProperty(
                            cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            tool_spec=bedrock_mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty(
                                description="description",
                                input_schema=bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                                    json=json
                                ),
                                name="name"
                            )
                        )]
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__73956b3a1b6801c2b29c5958291206de0ee0ee95d6ce35e25fe00d52fb34b360)
                check_type(argname="argument input_variables", value=input_variables, expected_type=type_hints["input_variables"])
                check_type(argname="argument messages", value=messages, expected_type=type_hints["messages"])
                check_type(argname="argument system", value=system, expected_type=type_hints["system"])
                check_type(argname="argument tool_configuration", value=tool_configuration, expected_type=type_hints["tool_configuration"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if input_variables is not None:
                self._values["input_variables"] = input_variables
            if messages is not None:
                self._values["messages"] = messages
            if system is not None:
                self._values["system"] = system
            if tool_configuration is not None:
                self._values["tool_configuration"] = tool_configuration

        @builtins.property
        def input_variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptInputVariableProperty"]]]]:
            '''An array of the variables in the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-chatprompttemplateconfiguration.html#cfn-bedrock-promptversion-chatprompttemplateconfiguration-inputvariables
            '''
            result = self._values.get("input_variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptInputVariableProperty"]]]], result)

        @builtins.property
        def messages(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.MessageProperty"]]]]:
            '''Contains messages in the chat for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-chatprompttemplateconfiguration.html#cfn-bedrock-promptversion-chatprompttemplateconfiguration-messages
            '''
            result = self._values.get("messages")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.MessageProperty"]]]], result)

        @builtins.property
        def system(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.SystemContentBlockProperty"]]]]:
            '''Contains system prompts to provide context to the model or to describe how it should behave.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-chatprompttemplateconfiguration.html#cfn-bedrock-promptversion-chatprompttemplateconfiguration-system
            '''
            result = self._values.get("system")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.SystemContentBlockProperty"]]]], result)

        @builtins.property
        def tool_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolConfigurationProperty"]]:
            '''Configuration information for the tools that the model can use when generating a response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-chatprompttemplateconfiguration.html#cfn-bedrock-promptversion-chatprompttemplateconfiguration-toolconfiguration
            '''
            result = self._values.get("tool_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ChatPromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ContentBlockProperty",
        jsii_struct_bases=[],
        name_mapping={"cache_point": "cachePoint", "text": "text"},
    )
    class ContentBlockProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A block of content for a message that you pass to, or receive from, a model with the `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ or `ConverseStream <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html>`_ API operations.

            :param cache_point: CachePoint to include in the message.
            :param text: Text to include in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-contentblock.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                content_block_property = bedrock_mixins.CfnPromptVersionPropsMixin.ContentBlockProperty(
                    cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__36124d035bf28853c39f3b4bcc5aa822533776e661c211eb0604afda40eb3192)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]]:
            '''CachePoint to include in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-contentblock.html#cfn-bedrock-promptversion-contentblock-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''Text to include in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-contentblock.html#cfn-bedrock-promptversion-contentblock-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ContentBlockProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.MessageProperty",
        jsii_struct_bases=[],
        name_mapping={"content": "content", "role": "role"},
    )
    class MessageProperty:
        def __init__(
            self,
            *,
            content: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ContentBlockProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            role: typing.Optional[builtins.str] = None,
        ) -> None:
            '''A message input, or returned from, a call to `Converse <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html>`_ or `ConverseStream <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html>`_ .

            :param content: The message content. Note the following restrictions:. - You can include up to 20 images. Each image's size, height, and width must be no more than 3.75 MB, 8000 px, and 8000 px, respectively. - You can include up to five documents. Each document's size must be no more than 4.5 MB. - If you include a ``ContentBlock`` with a ``document`` field in the array, you must also include a ``ContentBlock`` with a ``text`` field. - You can only include images and documents if the ``role`` is ``user`` .
            :param role: The role that the message plays in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-message.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                message_property = bedrock_mixins.CfnPromptVersionPropsMixin.MessageProperty(
                    content=[bedrock_mixins.CfnPromptVersionPropsMixin.ContentBlockProperty(
                        cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        text="text"
                    )],
                    role="role"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__897a2bb53fdaf7dfcec5a50068107b30b08a61307f777427f12dd0e5eedc351d)
                check_type(argname="argument content", value=content, expected_type=type_hints["content"])
                check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if content is not None:
                self._values["content"] = content
            if role is not None:
                self._values["role"] = role

        @builtins.property
        def content(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ContentBlockProperty"]]]]:
            '''The message content. Note the following restrictions:.

            - You can include up to 20 images. Each image's size, height, and width must be no more than 3.75 MB, 8000 px, and 8000 px, respectively.
            - You can include up to five documents. Each document's size must be no more than 4.5 MB.
            - If you include a ``ContentBlock`` with a ``document`` field in the array, you must also include a ``ContentBlock`` with a ``text`` field.
            - You can only include images and documents if the ``role`` is ``user`` .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-message.html#cfn-bedrock-promptversion-message-content
            '''
            result = self._values.get("content")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ContentBlockProperty"]]]], result)

        @builtins.property
        def role(self) -> typing.Optional[builtins.str]:
            '''The role that the message plays in the message.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-message.html#cfn-bedrock-promptversion-message-role
            '''
            result = self._values.get("role")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MessageProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptAgentResourceProperty",
        jsii_struct_bases=[],
        name_mapping={"agent_identifier": "agentIdentifier"},
    )
    class PromptAgentResourceProperty:
        def __init__(
            self,
            *,
            agent_identifier: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains specifications for an Amazon Bedrock agent with which to use the prompt.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ and `Automate tasks in your application using conversational agents <https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html>`_ .

            :param agent_identifier: The ARN of the agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptagentresource.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_agent_resource_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptAgentResourceProperty(
                    agent_identifier="agentIdentifier"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__24670e295fa18f6f2255b2ae002e59e78bf2c38f59f15c45c97b5e9e545407a9)
                check_type(argname="argument agent_identifier", value=agent_identifier, expected_type=type_hints["agent_identifier"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent_identifier is not None:
                self._values["agent_identifier"] = agent_identifier

        @builtins.property
        def agent_identifier(self) -> typing.Optional[builtins.str]:
            '''The ARN of the agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptagentresource.html#cfn-bedrock-promptversion-promptagentresource-agentidentifier
            '''
            result = self._values.get("agent_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptAgentResourceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptGenAiResourceProperty",
        jsii_struct_bases=[],
        name_mapping={"agent": "agent"},
    )
    class PromptGenAiResourceProperty:
        def __init__(
            self,
            *,
            agent: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptAgentResourceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains specifications for a generative AI resource with which to use the prompt.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ .

            :param agent: Specifies an Amazon Bedrock agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptgenairesource.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_gen_ai_resource_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptGenAiResourceProperty(
                    agent=bedrock_mixins.CfnPromptVersionPropsMixin.PromptAgentResourceProperty(
                        agent_identifier="agentIdentifier"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5727c40a97fa19eccfda1e508612826fc79f4c2315ecc38c3d73af500d51ef83)
                check_type(argname="argument agent", value=agent, expected_type=type_hints["agent"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if agent is not None:
                self._values["agent"] = agent

        @builtins.property
        def agent(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptAgentResourceProperty"]]:
            '''Specifies an Amazon Bedrock agent with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptgenairesource.html#cfn-bedrock-promptversion-promptgenairesource-agent
            '''
            result = self._values.get("agent")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptAgentResourceProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptGenAiResourceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"text": "text"},
    )
    class PromptInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains inference configurations for the prompt.

            :param text: Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_inference_configuration_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty(
                    text=bedrock_mixins.CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                        max_tokens=123,
                        stop_sequences=["stopSequences"],
                        temperature=123,
                        top_p=123
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__36d849c393bb94935067398f0687da07a804a14efa91ff444d32767e610fe48f)
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty"]]:
            '''Contains inference configurations for a text prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptinferenceconfiguration.html#cfn-bedrock-promptversion-promptinferenceconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class PromptInputVariableProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''Contains information about a variable in the prompt.

            :param name: The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptinputvariable.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_input_variable_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1f21fb62d5607fc7bd98cf9454e071b81b927789f42e941a843f99f8b0b9e281)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the variable.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptinputvariable.html#cfn-bedrock-promptversion-promptinputvariable-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptInputVariableProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptMetadataEntryProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class PromptMetadataEntryProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.

            For more information, see `Create a prompt using Prompt management <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html>`_ .

            :param key: The key of a metadata tag for a prompt variant.
            :param value: The value of a metadata tag for a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmetadataentry.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_metadata_entry_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptMetadataEntryProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__4a99d5e628a3b393825a16b5c8831d6e660466e78819f515367bf871852b6595)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''The key of a metadata tag for a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmetadataentry.html#cfn-bedrock-promptversion-promptmetadataentry-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value of a metadata tag for a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmetadataentry.html#cfn-bedrock-promptversion-promptmetadataentry-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptMetadataEntryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "max_tokens": "maxTokens",
            "stop_sequences": "stopSequences",
            "temperature": "temperature",
            "top_p": "topP",
        },
    )
    class PromptModelInferenceConfigurationProperty:
        def __init__(
            self,
            *,
            max_tokens: typing.Optional[jsii.Number] = None,
            stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
            temperature: typing.Optional[jsii.Number] = None,
            top_p: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Contains inference configurations related to model inference for a prompt.

            For more information, see `Inference parameters <https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html>`_ .

            :param max_tokens: The maximum number of tokens to return in the response.
            :param stop_sequences: A list of strings that define sequences after which the model will stop generating.
            :param temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
            :param top_p: The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmodelinferenceconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                prompt_model_inference_configuration_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                    max_tokens=123,
                    stop_sequences=["stopSequences"],
                    temperature=123,
                    top_p=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__036b486dd243b490c12845be0e1f354192df8f81c6c9fe17c32b7cedcc0fe1aa)
                check_type(argname="argument max_tokens", value=max_tokens, expected_type=type_hints["max_tokens"])
                check_type(argname="argument stop_sequences", value=stop_sequences, expected_type=type_hints["stop_sequences"])
                check_type(argname="argument temperature", value=temperature, expected_type=type_hints["temperature"])
                check_type(argname="argument top_p", value=top_p, expected_type=type_hints["top_p"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_tokens is not None:
                self._values["max_tokens"] = max_tokens
            if stop_sequences is not None:
                self._values["stop_sequences"] = stop_sequences
            if temperature is not None:
                self._values["temperature"] = temperature
            if top_p is not None:
                self._values["top_p"] = top_p

        @builtins.property
        def max_tokens(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of tokens to return in the response.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmodelinferenceconfiguration.html#cfn-bedrock-promptversion-promptmodelinferenceconfiguration-maxtokens
            '''
            result = self._values.get("max_tokens")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def stop_sequences(self) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of strings that define sequences after which the model will stop generating.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmodelinferenceconfiguration.html#cfn-bedrock-promptversion-promptmodelinferenceconfiguration-stopsequences
            '''
            result = self._values.get("stop_sequences")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def temperature(self) -> typing.Optional[jsii.Number]:
            '''Controls the randomness of the response.

            Choose a lower value for more predictable outputs and a higher value for more surprising outputs.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmodelinferenceconfiguration.html#cfn-bedrock-promptversion-promptmodelinferenceconfiguration-temperature
            '''
            result = self._values.get("temperature")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def top_p(self) -> typing.Optional[jsii.Number]:
            '''The percentage of most-likely candidates that the model considers for the next token.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptmodelinferenceconfiguration.html#cfn-bedrock-promptversion-promptmodelinferenceconfiguration-topp
            '''
            result = self._values.get("top_p")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptModelInferenceConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"chat": "chat", "text": "text"},
    )
    class PromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            chat: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Contains the message for a prompt.

            For more information, see `Construct and store reusable prompts with Prompt management in Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html>`_ .

            :param chat: Contains configurations to use the prompt in a conversational format.
            :param text: Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-prompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                # json: Any
                
                prompt_template_configuration_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty(
                    chat=bedrock_mixins.CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty(
                        input_variables=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        messages=[bedrock_mixins.CfnPromptVersionPropsMixin.MessageProperty(
                            content=[bedrock_mixins.CfnPromptVersionPropsMixin.ContentBlockProperty(
                                cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                text="text"
                            )],
                            role="role"
                        )],
                        system=[bedrock_mixins.CfnPromptVersionPropsMixin.SystemContentBlockProperty(
                            cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            text="text"
                        )],
                        tool_configuration=bedrock_mixins.CfnPromptVersionPropsMixin.ToolConfigurationProperty(
                            tool_choice=bedrock_mixins.CfnPromptVersionPropsMixin.ToolChoiceProperty(
                                any=any,
                                auto=auto,
                                tool=bedrock_mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty(
                                    name="name"
                                )
                            ),
                            tools=[bedrock_mixins.CfnPromptVersionPropsMixin.ToolProperty(
                                cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                tool_spec=bedrock_mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty(
                                    description="description",
                                    input_schema=bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                                        json=json
                                    ),
                                    name="name"
                                )
                            )]
                        )
                    ),
                    text=bedrock_mixins.CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                        cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        input_variables=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                            name="name"
                        )],
                        text="text"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b97bb4910f9d2e179e8e2423689c8a6babdba0fcdb1428f90449a2a576586de4)
                check_type(argname="argument chat", value=chat, expected_type=type_hints["chat"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if chat is not None:
                self._values["chat"] = chat
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def chat(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty"]]:
            '''Contains configurations to use the prompt in a conversational format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-prompttemplateconfiguration.html#cfn-bedrock-promptversion-prompttemplateconfiguration-chat
            '''
            result = self._values.get("chat")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty"]], result)

        @builtins.property
        def text(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty"]]:
            '''Contains configurations for the text in a message for a prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-prompttemplateconfiguration.html#cfn-bedrock-promptversion-prompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.PromptVariantProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_model_request_fields": "additionalModelRequestFields",
            "gen_ai_resource": "genAiResource",
            "inference_configuration": "inferenceConfiguration",
            "metadata": "metadata",
            "model_id": "modelId",
            "name": "name",
            "template_configuration": "templateConfiguration",
            "template_type": "templateType",
        },
    )
    class PromptVariantProperty:
        def __init__(
            self,
            *,
            additional_model_request_fields: typing.Any = None,
            gen_ai_resource: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptGenAiResourceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            inference_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            metadata: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptMetadataEntryProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            model_id: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
            template_configuration: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            template_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains details about a variant of the prompt.

            :param additional_model_request_fields: Contains model-specific inference configurations that aren't in the ``inferenceConfiguration`` field. To see model-specific inference parameters, see `Inference request parameters and response fields for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .
            :param gen_ai_resource: Specifies a generative AI resource with which to use the prompt.
            :param inference_configuration: Contains inference configurations for the prompt variant.
            :param metadata: An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
            :param model_id: The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ with which to run inference on the prompt.
            :param name: The name of the prompt variant.
            :param template_configuration: Contains configurations for the prompt template.
            :param template_type: The type of prompt template to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # additional_model_request_fields: Any
                # any: Any
                # auto: Any
                # json: Any
                
                prompt_variant_property = bedrock_mixins.CfnPromptVersionPropsMixin.PromptVariantProperty(
                    additional_model_request_fields=additional_model_request_fields,
                    gen_ai_resource=bedrock_mixins.CfnPromptVersionPropsMixin.PromptGenAiResourceProperty(
                        agent=bedrock_mixins.CfnPromptVersionPropsMixin.PromptAgentResourceProperty(
                            agent_identifier="agentIdentifier"
                        )
                    ),
                    inference_configuration=bedrock_mixins.CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty(
                        text=bedrock_mixins.CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty(
                            max_tokens=123,
                            stop_sequences=["stopSequences"],
                            temperature=123,
                            top_p=123
                        )
                    ),
                    metadata=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptMetadataEntryProperty(
                        key="key",
                        value="value"
                    )],
                    model_id="modelId",
                    name="name",
                    template_configuration=bedrock_mixins.CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty(
                        chat=bedrock_mixins.CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty(
                            input_variables=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            messages=[bedrock_mixins.CfnPromptVersionPropsMixin.MessageProperty(
                                content=[bedrock_mixins.CfnPromptVersionPropsMixin.ContentBlockProperty(
                                    cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                        type="type"
                                    ),
                                    text="text"
                                )],
                                role="role"
                            )],
                            system=[bedrock_mixins.CfnPromptVersionPropsMixin.SystemContentBlockProperty(
                                cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                    type="type"
                                ),
                                text="text"
                            )],
                            tool_configuration=bedrock_mixins.CfnPromptVersionPropsMixin.ToolConfigurationProperty(
                                tool_choice=bedrock_mixins.CfnPromptVersionPropsMixin.ToolChoiceProperty(
                                    any=any,
                                    auto=auto,
                                    tool=bedrock_mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty(
                                        name="name"
                                    )
                                ),
                                tools=[bedrock_mixins.CfnPromptVersionPropsMixin.ToolProperty(
                                    cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                        type="type"
                                    ),
                                    tool_spec=bedrock_mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty(
                                        description="description",
                                        input_schema=bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                                            json=json
                                        ),
                                        name="name"
                                    )
                                )]
                            )
                        ),
                        text=bedrock_mixins.CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                            cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                                type="type"
                            ),
                            input_variables=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                                name="name"
                            )],
                            text="text"
                        )
                    ),
                    template_type="templateType"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9087328765926884c6976b8d870e5714115fda1c621697871c6bb66e5c456617)
                check_type(argname="argument additional_model_request_fields", value=additional_model_request_fields, expected_type=type_hints["additional_model_request_fields"])
                check_type(argname="argument gen_ai_resource", value=gen_ai_resource, expected_type=type_hints["gen_ai_resource"])
                check_type(argname="argument inference_configuration", value=inference_configuration, expected_type=type_hints["inference_configuration"])
                check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
                check_type(argname="argument model_id", value=model_id, expected_type=type_hints["model_id"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument template_configuration", value=template_configuration, expected_type=type_hints["template_configuration"])
                check_type(argname="argument template_type", value=template_type, expected_type=type_hints["template_type"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_model_request_fields is not None:
                self._values["additional_model_request_fields"] = additional_model_request_fields
            if gen_ai_resource is not None:
                self._values["gen_ai_resource"] = gen_ai_resource
            if inference_configuration is not None:
                self._values["inference_configuration"] = inference_configuration
            if metadata is not None:
                self._values["metadata"] = metadata
            if model_id is not None:
                self._values["model_id"] = model_id
            if name is not None:
                self._values["name"] = name
            if template_configuration is not None:
                self._values["template_configuration"] = template_configuration
            if template_type is not None:
                self._values["template_type"] = template_type

        @builtins.property
        def additional_model_request_fields(self) -> typing.Any:
            '''Contains model-specific inference configurations that aren't in the ``inferenceConfiguration`` field.

            To see model-specific inference parameters, see `Inference request parameters and response fields for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-additionalmodelrequestfields
            '''
            result = self._values.get("additional_model_request_fields")
            return typing.cast(typing.Any, result)

        @builtins.property
        def gen_ai_resource(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptGenAiResourceProperty"]]:
            '''Specifies a generative AI resource with which to use the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-genairesource
            '''
            result = self._values.get("gen_ai_resource")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptGenAiResourceProperty"]], result)

        @builtins.property
        def inference_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty"]]:
            '''Contains inference configurations for the prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-inferenceconfiguration
            '''
            result = self._values.get("inference_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty"]], result)

        @builtins.property
        def metadata(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptMetadataEntryProperty"]]]]:
            '''An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-metadata
            '''
            result = self._values.get("metadata")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptMetadataEntryProperty"]]]], result)

        @builtins.property
        def model_id(self) -> typing.Optional[builtins.str]:
            '''The unique identifier of the model or `inference profile <https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html>`_ with which to run inference on the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-modelid
            '''
            result = self._values.get("model_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the prompt variant.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def template_configuration(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty"]]:
            '''Contains configurations for the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-templateconfiguration
            '''
            result = self._values.get("template_configuration")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty"]], result)

        @builtins.property
        def template_type(self) -> typing.Optional[builtins.str]:
            '''The type of prompt template to use.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-promptvariant.html#cfn-bedrock-promptversion-promptvariant-templatetype
            '''
            result = self._values.get("template_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PromptVariantProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class SpecificToolChoiceProperty:
        def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
            '''The model must request a specific tool.

            For example, ``{"tool" : {"name" : "Your tool name"}}`` . For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide
            .. epigraph::

               This field is only supported by Anthropic Claude 3 models.

            :param name: The name of the tool that the model must request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-specifictoolchoice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                specific_tool_choice_property = bedrock_mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty(
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f565654379cdc83d02523571107a8663b5174018acc7d57c0e2439ed38e19f79)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the tool that the model must request.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-specifictoolchoice.html#cfn-bedrock-promptversion-specifictoolchoice-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpecificToolChoiceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.SystemContentBlockProperty",
        jsii_struct_bases=[],
        name_mapping={"cache_point": "cachePoint", "text": "text"},
    )
    class SystemContentBlockProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for instructions to provide the model for how to handle input.

            To learn more, see `Using the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference-call.html>`_ .

            :param cache_point: CachePoint to include in the system prompt.
            :param text: A system prompt for the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-systemcontentblock.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                system_content_block_property = bedrock_mixins.CfnPromptVersionPropsMixin.SystemContentBlockProperty(
                    cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f8e25a134219ce56b249a6ef4396145f74ae8db3e6e1da6c31df032c9def47d0)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]]:
            '''CachePoint to include in the system prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-systemcontentblock.html#cfn-bedrock-promptversion-systemcontentblock-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''A system prompt for the model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-systemcontentblock.html#cfn-bedrock-promptversion-systemcontentblock-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SystemContentBlockProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cache_point": "cachePoint",
            "input_variables": "inputVariables",
            "text": "text",
        },
    )
    class TextPromptTemplateConfigurationProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            input_variables: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.PromptInputVariableProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
            text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Contains configurations for a text prompt template.

            To include a variable, enclose a word in double curly braces as in ``{{variable}}`` .

            :param cache_point: A cache checkpoint within a template configuration.
            :param input_variables: An array of the variables in the prompt template.
            :param text: The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-textprompttemplateconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                text_prompt_template_configuration_property = bedrock_mixins.CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty(
                    cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    input_variables=[bedrock_mixins.CfnPromptVersionPropsMixin.PromptInputVariableProperty(
                        name="name"
                    )],
                    text="text"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__97364688313ebf7f263ece6188eb85a558b5b18712abc1e92fe2e4f3888bfdfa)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument input_variables", value=input_variables, expected_type=type_hints["input_variables"])
                check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if input_variables is not None:
                self._values["input_variables"] = input_variables
            if text is not None:
                self._values["text"] = text

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]]:
            '''A cache checkpoint within a template configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-textprompttemplateconfiguration.html#cfn-bedrock-promptversion-textprompttemplateconfiguration-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def input_variables(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptInputVariableProperty"]]]]:
            '''An array of the variables in the prompt template.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-textprompttemplateconfiguration.html#cfn-bedrock-promptversion-textprompttemplateconfiguration-inputvariables
            '''
            result = self._values.get("input_variables")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.PromptInputVariableProperty"]]]], result)

        @builtins.property
        def text(self) -> typing.Optional[builtins.str]:
            '''The message for the prompt.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-textprompttemplateconfiguration.html#cfn-bedrock-promptversion-textprompttemplateconfiguration-text
            '''
            result = self._values.get("text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TextPromptTemplateConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ToolChoiceProperty",
        jsii_struct_bases=[],
        name_mapping={"any": "any", "auto": "auto", "tool": "tool"},
    )
    class ToolChoiceProperty:
        def __init__(
            self,
            *,
            any: typing.Any = None,
            auto: typing.Any = None,
            tool: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.SpecificToolChoiceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Determines which tools the model should request in a call to ``Converse`` or ``ConverseStream`` .

            For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param any: The model must request at least one tool (no text is generated).
            :param auto: (Default). The Model automatically decides if a tool should be called or whether to generate text instead.
            :param tool: The Model must request the specified tool. Only supported by Anthropic Claude 3 and Amazon Nova models.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolchoice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                
                tool_choice_property = bedrock_mixins.CfnPromptVersionPropsMixin.ToolChoiceProperty(
                    any=any,
                    auto=auto,
                    tool=bedrock_mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty(
                        name="name"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5b74e55f71e53895d4d69bb5578d7e7c0b66e63a0747b75bf2779765d2274799)
                check_type(argname="argument any", value=any, expected_type=type_hints["any"])
                check_type(argname="argument auto", value=auto, expected_type=type_hints["auto"])
                check_type(argname="argument tool", value=tool, expected_type=type_hints["tool"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if any is not None:
                self._values["any"] = any
            if auto is not None:
                self._values["auto"] = auto
            if tool is not None:
                self._values["tool"] = tool

        @builtins.property
        def any(self) -> typing.Any:
            '''The model must request at least one tool (no text is generated).

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolchoice.html#cfn-bedrock-promptversion-toolchoice-any
            '''
            result = self._values.get("any")
            return typing.cast(typing.Any, result)

        @builtins.property
        def auto(self) -> typing.Any:
            '''(Default).

            The Model automatically decides if a tool should be called or whether to generate text instead.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolchoice.html#cfn-bedrock-promptversion-toolchoice-auto
            '''
            result = self._values.get("auto")
            return typing.cast(typing.Any, result)

        @builtins.property
        def tool(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.SpecificToolChoiceProperty"]]:
            '''The Model must request the specified tool.

            Only supported by Anthropic Claude 3 and Amazon Nova models.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolchoice.html#cfn-bedrock-promptversion-toolchoice-tool
            '''
            result = self._values.get("tool")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.SpecificToolChoiceProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolChoiceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ToolConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"tool_choice": "toolChoice", "tools": "tools"},
    )
    class ToolConfigurationProperty:
        def __init__(
            self,
            *,
            tool_choice: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ToolChoiceProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tools: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Sequence[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ToolProperty", typing.Dict[builtins.str, typing.Any]]]]]] = None,
        ) -> None:
            '''Configuration information for the tools that you pass to a model.

            For more information, see `Tool use (function calling) <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param tool_choice: If supported by model, forces the model to request a tool.
            :param tools: An array of tools that you want to pass to a model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # any: Any
                # auto: Any
                # json: Any
                
                tool_configuration_property = bedrock_mixins.CfnPromptVersionPropsMixin.ToolConfigurationProperty(
                    tool_choice=bedrock_mixins.CfnPromptVersionPropsMixin.ToolChoiceProperty(
                        any=any,
                        auto=auto,
                        tool=bedrock_mixins.CfnPromptVersionPropsMixin.SpecificToolChoiceProperty(
                            name="name"
                        )
                    ),
                    tools=[bedrock_mixins.CfnPromptVersionPropsMixin.ToolProperty(
                        cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                            type="type"
                        ),
                        tool_spec=bedrock_mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty(
                            description="description",
                            input_schema=bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                                json=json
                            ),
                            name="name"
                        )
                    )]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__7e0588de21b08835edf726fb8fa32ebe089b5b23a3d3671d9060961bc94d3f4f)
                check_type(argname="argument tool_choice", value=tool_choice, expected_type=type_hints["tool_choice"])
                check_type(argname="argument tools", value=tools, expected_type=type_hints["tools"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if tool_choice is not None:
                self._values["tool_choice"] = tool_choice
            if tools is not None:
                self._values["tools"] = tools

        @builtins.property
        def tool_choice(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolChoiceProperty"]]:
            '''If supported by model, forces the model to request a tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolconfiguration.html#cfn-bedrock-promptversion-toolconfiguration-toolchoice
            '''
            result = self._values.get("tool_choice")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolChoiceProperty"]], result)

        @builtins.property
        def tools(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolProperty"]]]]:
            '''An array of tools that you want to pass to a model.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolconfiguration.html#cfn-bedrock-promptversion-toolconfiguration-tools
            '''
            result = self._values.get("tools")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.List[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolProperty"]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty",
        jsii_struct_bases=[],
        name_mapping={"json": "json"},
    )
    class ToolInputSchemaProperty:
        def __init__(self, *, json: typing.Any = None) -> None:
            '''The schema for the tool.

            The top level schema type must be ``object`` . For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param json: The JSON schema for the tool. For more information, see `JSON Schema Reference <https://docs.aws.amazon.com/https://json-schema.org/understanding-json-schema/reference>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolinputschema.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # json: Any
                
                tool_input_schema_property = bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                    json=json
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__e32a07ce00b7efcba932cd54a682d13dd6ced0c5791ef940a84dcc1e47f06703)
                check_type(argname="argument json", value=json, expected_type=type_hints["json"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if json is not None:
                self._values["json"] = json

        @builtins.property
        def json(self) -> typing.Any:
            '''The JSON schema for the tool.

            For more information, see `JSON Schema Reference <https://docs.aws.amazon.com/https://json-schema.org/understanding-json-schema/reference>`_ .

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolinputschema.html#cfn-bedrock-promptversion-toolinputschema-json
            '''
            result = self._values.get("json")
            return typing.cast(typing.Any, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolInputSchemaProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ToolProperty",
        jsii_struct_bases=[],
        name_mapping={"cache_point": "cachePoint", "tool_spec": "toolSpec"},
    )
    class ToolProperty:
        def __init__(
            self,
            *,
            cache_point: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.CachePointBlockProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            tool_spec: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ToolSpecificationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        ) -> None:
            '''Information about a tool that you can use with the Converse API.

            For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param cache_point: CachePoint to include in the tool configuration.
            :param tool_spec: The specfication for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-tool.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # json: Any
                
                tool_property = bedrock_mixins.CfnPromptVersionPropsMixin.ToolProperty(
                    cache_point=bedrock_mixins.CfnPromptVersionPropsMixin.CachePointBlockProperty(
                        type="type"
                    ),
                    tool_spec=bedrock_mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty(
                        description="description",
                        input_schema=bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                            json=json
                        ),
                        name="name"
                    )
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__04c283954ce412dfcea43ca61ec4c1c4971634d138835e8324a34df12d142cbb)
                check_type(argname="argument cache_point", value=cache_point, expected_type=type_hints["cache_point"])
                check_type(argname="argument tool_spec", value=tool_spec, expected_type=type_hints["tool_spec"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cache_point is not None:
                self._values["cache_point"] = cache_point
            if tool_spec is not None:
                self._values["tool_spec"] = tool_spec

        @builtins.property
        def cache_point(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]]:
            '''CachePoint to include in the tool configuration.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-tool.html#cfn-bedrock-promptversion-tool-cachepoint
            '''
            result = self._values.get("cache_point")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.CachePointBlockProperty"]], result)

        @builtins.property
        def tool_spec(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolSpecificationProperty"]]:
            '''The specfication for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-tool.html#cfn-bedrock-promptversion-tool-toolspec
            '''
            result = self._values.get("tool_spec")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolSpecificationProperty"]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="@aws-cdk/mixins-preview.aws_bedrock.mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "description": "description",
            "input_schema": "inputSchema",
            "name": "name",
        },
    )
    class ToolSpecificationProperty:
        def __init__(
            self,
            *,
            description: typing.Optional[builtins.str] = None,
            input_schema: typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", typing.Union["CfnPromptVersionPropsMixin.ToolInputSchemaProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The specification for the tool.

            For more information, see `Call a tool with the Converse API <https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html>`_ in the Amazon Bedrock User Guide.

            :param description: The description for the tool.
            :param input_schema: The input schema for the tool in JSON format.
            :param name: The name for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk.mixins_preview.aws_bedrock import mixins as bedrock_mixins
                
                # json: Any
                
                tool_specification_property = bedrock_mixins.CfnPromptVersionPropsMixin.ToolSpecificationProperty(
                    description="description",
                    input_schema=bedrock_mixins.CfnPromptVersionPropsMixin.ToolInputSchemaProperty(
                        json=json
                    ),
                    name="name"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d76377e1a30f62c3dd69780ead03eaeb6b4e5410e0de958c503cd24249a38ad5)
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument input_schema", value=input_schema, expected_type=type_hints["input_schema"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if description is not None:
                self._values["description"] = description
            if input_schema is not None:
                self._values["input_schema"] = input_schema
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolspecification.html#cfn-bedrock-promptversion-toolspecification-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def input_schema(
            self,
        ) -> typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolInputSchemaProperty"]]:
            '''The input schema for the tool in JSON format.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolspecification.html#cfn-bedrock-promptversion-toolspecification-inputschema
            '''
            result = self._values.get("input_schema")
            return typing.cast(typing.Optional[typing.Union["_aws_cdk_ceddda9d.IResolvable", "CfnPromptVersionPropsMixin.ToolInputSchemaProperty"]], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name for the tool.

            :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-promptversion-toolspecification.html#cfn-bedrock-promptversion-toolspecification-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ToolSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


__all__ = [
    "CfnAgentAliasEventLogs",
    "CfnAgentAliasLogsMixin",
    "CfnAgentAliasMixinProps",
    "CfnAgentAliasPropsMixin",
    "CfnAgentApplicationLogs",
    "CfnAgentLogsMixin",
    "CfnAgentMixinProps",
    "CfnAgentPropsMixin",
    "CfnApplicationInferenceProfileMixinProps",
    "CfnApplicationInferenceProfilePropsMixin",
    "CfnAutomatedReasoningPolicyMixinProps",
    "CfnAutomatedReasoningPolicyPropsMixin",
    "CfnAutomatedReasoningPolicyVersionMixinProps",
    "CfnAutomatedReasoningPolicyVersionPropsMixin",
    "CfnBlueprintMixinProps",
    "CfnBlueprintPropsMixin",
    "CfnDataAutomationProjectMixinProps",
    "CfnDataAutomationProjectPropsMixin",
    "CfnDataSourceMixinProps",
    "CfnDataSourcePropsMixin",
    "CfnFlowAliasMixinProps",
    "CfnFlowAliasPropsMixin",
    "CfnFlowApplicationLogs",
    "CfnFlowLogsMixin",
    "CfnFlowMixinProps",
    "CfnFlowPropsMixin",
    "CfnFlowVersionMixinProps",
    "CfnFlowVersionPropsMixin",
    "CfnGuardrailMixinProps",
    "CfnGuardrailPropsMixin",
    "CfnGuardrailVersionMixinProps",
    "CfnGuardrailVersionPropsMixin",
    "CfnIntelligentPromptRouterMixinProps",
    "CfnIntelligentPromptRouterPropsMixin",
    "CfnKnowledgeBaseApplicationLogs",
    "CfnKnowledgeBaseLogsMixin",
    "CfnKnowledgeBaseMixinProps",
    "CfnKnowledgeBasePropsMixin",
    "CfnKnowledgeBaseRuntimeLogs",
    "CfnPromptMixinProps",
    "CfnPromptPropsMixin",
    "CfnPromptVersionMixinProps",
    "CfnPromptVersionPropsMixin",
]

publication.publish()

def _typecheckingstub__89fe3387100b7fef91f835d4ac67e51d37bce801974e9fc63bc096063eaae034(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0822e466dbe077f51af762b4ffd98d4adb04de281eead916381c9ad178a8d43(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edd80dc0e7f99a00914b172307f25ba8a4bde538313860b19aee33d321fb7aa6(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0dfc7504d6bd1e63f0f9b026362c40a22d13b95bb24dac1c86258a5615339d5(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b47512ed5f12ab1ff859562ad2dcde301164852fe589bf0b679052679351e87(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92b917df052bc5cd7eecf47fb6deae8b8e7fa87e01a499b89e293452bbb757bd(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef7eb0c31c8ed8ee1f4b6bf2df0d024ccf46ae1c7db5590368504cc1d697a45b(
    *,
    agent_alias_name: typing.Optional[builtins.str] = None,
    agent_id: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    routing_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c62ab341e27c90826f848aa5e64ba52709d65e8a2dbc588c98a3d25812645d42(
    props: typing.Union[CfnAgentAliasMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38b44f3588766120940c93d262e591f95985fb520f0b2735c55a7820ec225d8f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ac233a87a399824eb6e2a0bb509a9a0aca9b669c50f2d9f0f3c0be32dfe7579(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__acce48cec56537cd7dcd965c93f022d2203d2c1684e85cf1a13120ad7a88f010(
    *,
    end_date: typing.Optional[builtins.str] = None,
    routing_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentAliasPropsMixin.AgentAliasRoutingConfigurationListItemProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    start_date: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5799748ad012431ec1ed959b343efbb67e1709829130ea661cf229d8515c42d7(
    *,
    agent_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__668759f73023546dafab6830da9d9a44f666c4ce5ce44310cd7c2f5b20b81c51(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3acdd3056fd1e4fe07fdba191d267e85d58b79ae5cd53a6c31a92c14a325c393(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7cb005d92fbe0909b5e12178b9f22003bc5dbac9089ff567f5974729e18e0ff7(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cbd06c78abcc78331db5ac9be0fdbf5e9781fb8372e3097f56896a00c68916d(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f50240ae7219a5ed674964ce0fadf836b752680cf01a226b2965968753c44ad(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfce9bb2653f196155d15a3ab3e29d6a2aa78c78f5f1a2d5c5299f6b5544df1e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81096f663dfd53883abdba5d814904047cf7dc4a430d759e9cb0610273e5e1a6(
    *,
    action_groups: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.AgentActionGroupProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    agent_collaboration: typing.Optional[builtins.str] = None,
    agent_collaborators: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.AgentCollaboratorProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    agent_name: typing.Optional[builtins.str] = None,
    agent_resource_role_arn: typing.Optional[builtins.str] = None,
    auto_prepare: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    customer_encryption_key_arn: typing.Optional[builtins.str] = None,
    custom_orchestration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.CustomOrchestrationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    foundation_model: typing.Optional[builtins.str] = None,
    guardrail_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.GuardrailConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    idle_session_ttl_in_seconds: typing.Optional[jsii.Number] = None,
    instruction: typing.Optional[builtins.str] = None,
    knowledge_bases: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.AgentKnowledgeBaseProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    memory_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.MemoryConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    orchestration_type: typing.Optional[builtins.str] = None,
    prompt_override_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.PromptOverrideConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    skip_resource_in_use_check_on_delete: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    test_alias_tags: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13f7c49281453536c9114548e63a8faee493f76e3207419bf4c13c388f255809(
    props: typing.Union[CfnAgentMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8414dffb43925b5fe4fa882cab91b3a07c5bbc837879036907899c0cd92dacf3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcd36a2c21e07d8b6153b44fe42068cebdab263dbe39c7967b3f45f402e42208(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d00895015dcec2190210aafae1ab997d7891d8a4117e6a4f937c4260f61f4ac(
    *,
    payload: typing.Optional[builtins.str] = None,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.S3IdentifierProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de1ee9ae7245cc7d40afcd41819ed45e7351e075e5f730bf4c1e7d1999ecd351(
    *,
    custom_control: typing.Optional[builtins.str] = None,
    lambda_: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdad78b6cbb091ba8ff6c95b5c60e41ea88d1d2d16621805f58e81759bb6d5d2(
    *,
    action_group_executor: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.ActionGroupExecutorProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    action_group_name: typing.Optional[builtins.str] = None,
    action_group_state: typing.Optional[builtins.str] = None,
    api_schema: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.APISchemaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    function_schema: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.FunctionSchemaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    parent_action_group_signature: typing.Optional[builtins.str] = None,
    skip_resource_in_use_check_on_delete: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__550a70c1f10d3f4fb4916dcb37ea19b6ce24fbdcb4f20313b8a4121801f291b7(
    *,
    agent_descriptor: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.AgentDescriptorProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    collaboration_instruction: typing.Optional[builtins.str] = None,
    collaborator_name: typing.Optional[builtins.str] = None,
    relay_conversation_history: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83ba4d8421af585b489be5cf53c850191f906ccc80315c42d481c53c48f2a471(
    *,
    alias_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9658feb1974bf323638ba6a6098b8d5adb1aecfb4b0c39b8ccac2152c1ed5a67(
    *,
    description: typing.Optional[builtins.str] = None,
    knowledge_base_id: typing.Optional[builtins.str] = None,
    knowledge_base_state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9819725acf6c9e2d288bf11e8b981b63250331d24fc39119c15f8cd1d4c349d7(
    *,
    executor: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.OrchestrationExecutorProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6fa882b4d53b72c6e723bb0f21a0c23cbfe4a4aa33e54b820f0042c4c95f4c9(
    *,
    description: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    parameters: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Mapping[builtins.str, typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.ParameterDetailProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    require_confirmation: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14db220f01c1623f0b34950da07cd5bc6828753698c6dd7cf9fe900c8fbeebd1(
    *,
    functions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.FunctionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4c85bc9b2e508ce7bdf56e2b9e1a1b97251e5cc89438f0a22eccd7d3cf57f0a(
    *,
    guardrail_identifier: typing.Optional[builtins.str] = None,
    guardrail_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70d761326bbe3c157bb3a906ba02a28f53ae548202650b817eb0ff795d073c82(
    *,
    maximum_length: typing.Optional[jsii.Number] = None,
    stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
    temperature: typing.Optional[jsii.Number] = None,
    top_k: typing.Optional[jsii.Number] = None,
    top_p: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f8ef852b2b4ecb31099aa1b98418cef9f3fee2141b5121f1abb0de212ad7136(
    *,
    enabled_memory_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    session_summary_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.SessionSummaryConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage_days: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b33cfb1fb7f416c0782b59248c663dc7516fb1d8aa6bda04ab950d94192d81af(
    *,
    lambda_: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e0d2c22fae1856f9828b4cece2cd3bda2252fd3e484a9ebdc017e3958758d6c(
    *,
    description: typing.Optional[builtins.str] = None,
    required: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__febea77361572ec9bd975c9032f098e57b427764c2b17a9d7c67f9cb6666b0f5(
    *,
    additional_model_request_fields: typing.Any = None,
    base_prompt_template: typing.Optional[builtins.str] = None,
    foundation_model: typing.Optional[builtins.str] = None,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.InferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    parser_mode: typing.Optional[builtins.str] = None,
    prompt_creation_mode: typing.Optional[builtins.str] = None,
    prompt_state: typing.Optional[builtins.str] = None,
    prompt_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aee2c7de86041c2622cc639281e85e43ada9886ff8165381269febc4eb807930(
    *,
    override_lambda: typing.Optional[builtins.str] = None,
    prompt_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAgentPropsMixin.PromptConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__642e07c90f57b7d3f7e1e4f3b8d88334db27703c66a146597edb2ed605140657(
    *,
    s3_bucket_name: typing.Optional[builtins.str] = None,
    s3_object_key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d538eb025a16d68c9eb56f81c65f6c39e31d84777e478e711a81233d573cb7c(
    *,
    max_recent_sessions: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03ef3848392b22f82ffa538566b18aec8f273460040c16b9c67838a401c9d0db(
    *,
    description: typing.Optional[builtins.str] = None,
    inference_profile_name: typing.Optional[builtins.str] = None,
    model_source: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnApplicationInferenceProfilePropsMixin.InferenceProfileModelSourceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fca9b3bfd77a9faf244a371385364cc1361ac72dfd92c2433dafcd0ab6791af(
    props: typing.Union[CfnApplicationInferenceProfileMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fcb83dac915d636046ea6dacc28c50c68598fa9646d1db481f6c241232a5be1(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__631bb5ba5d6ffb7868321b53a46febd76970ee482ef78dbd10884d3f0a83acc7(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71700cd9f8cec08e9de7268c5cf44ed9150a0c2637bfedf8c739eb61a2b74311(
    *,
    model_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15e9a682defac9389f62706eb5ec089209c580bc2298c1bdf56d2825e5e38047(
    *,
    copy_from: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__863f3869e6ca0339285de67076fe82e859ee338a9aabf2f18f12148caff4797f(
    *,
    description: typing.Optional[builtins.str] = None,
    force_delete: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    policy_definition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__657517369732b534f202897b45148a5be83ad127c7b740d0a22dfdeb4088d208(
    props: typing.Union[CfnAutomatedReasoningPolicyMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d7565788b1a54f36074d387679cb593b0d928ea605831feee0f1ec37c4d88e3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68f601477f3c1f9ce560f939b0e7a1356a56468f920e5d667bedda5f10060666(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93dc6b498d55c3653bad0d7833548503095d432ace1e03f1c932bba1f36c88a2(
    *,
    rules: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionRuleProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    types: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32e27e5103a9d0ccfb118539501f55b1d3ab19545a5b5df29427a0ef118dfa35(
    *,
    alternate_expression: typing.Optional[builtins.str] = None,
    expression: typing.Optional[builtins.str] = None,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccb9d7cd5bfa2cc51e9f0b42cb47f755bebc6dac6789e540fa0e26d94869b2ff(
    *,
    description: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnAutomatedReasoningPolicyPropsMixin.PolicyDefinitionTypeValueProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d75b4f8e416913320b0dc3fab27537a2800eb22e985c77d1ec1f59f0f3d3bc18(
    *,
    description: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92d2638ddcaec8eaddc279949ee056b649ee46666c2471e0bb8248fe80a0f80e(
    *,
    description: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4a74b301658f56713a89452e2a9e14f64fefaf17d01d70517b6a0692a8a73a9(
    *,
    last_updated_definition_hash: typing.Optional[builtins.str] = None,
    policy_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1593a3d1632e63769a07cc39b2a2d8bd5659b4fa294cbb90b1358da139df2f03(
    props: typing.Union[CfnAutomatedReasoningPolicyVersionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0978bf24b9496a3cf10232e1b8e76a5891cde3df21cf3e13d04ae9c5525c079f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52982dd65a4f9853400be09a6ae3c49192edbc1efad22a3730e60bf2b0dda870(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71cc7636a5a1e02b3ab37a712fc59bdd7d49c35f80242889732449ae6767f9d4(
    *,
    blueprint_name: typing.Optional[builtins.str] = None,
    kms_encryption_context: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    schema: typing.Any = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5c1ff8b10a64c94c56bac3d79d62b0dada5b72e12d6299866bfbf67320f8c13(
    props: typing.Union[CfnBlueprintMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1743f1fb249032def0cad403f0437f23f45f03d8fd283197aa83d55d6fbdfd96(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b274e6013533f0e277eff02a05dd307891d0342ec506f64bc80ca3b5c6b1aaf(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efe5f852afbd5b45730507d8713a1d92404b8b0fb39adae6aa861f683630b09a(
    *,
    custom_output_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.CustomOutputConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    kms_encryption_context: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    override_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.OverrideConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    project_description: typing.Optional[builtins.str] = None,
    project_name: typing.Optional[builtins.str] = None,
    project_type: typing.Optional[builtins.str] = None,
    standard_output_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.StandardOutputConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a56e1e48d505d8ac132b7ceac677ea88e5184db62a8e27a3516edb8d16e3c252(
    props: typing.Union[CfnDataAutomationProjectMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d9367d2d79ec16db84c07c96d9365f9200d51b091c13dadb8f36ddf074e9bd2(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1903e2b4acd60c40baa8e9433db2e6d0438a5f5e5fe9a7207c406618ca3eb500(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3f0c5d579a80263d8ef35a92e890d11d9e11f6ea8a5b69654754a9f24083b04(
    *,
    state: typing.Optional[builtins.str] = None,
    type_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryTypeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__579c693b8433f3c4f05f83479d67eecced929c2916678fd17ab9d81db9d8f69d(
    *,
    transcript: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.TranscriptConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77393e6ec930f0fd7cbad8e4937b537e91d48e0d40c627ce65d655eac733e6f3(
    *,
    generative_output_language: typing.Optional[builtins.str] = None,
    identify_multiple_languages: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    input_languages: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53e5acfec74299b284520fc73f184483d6b757e363daacb5bf484c9f81fb1b75(
    *,
    language_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioLanguageConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    modality_processing: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sensitive_data_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d40763167212cadc7c5780a8a6baf33bc91e74281e0b1dd8143833399b9905e1(
    *,
    category: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioExtractionCategoryProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44656c8d5b9913277cba1e38291040198ef0c8fd641efd8f3488f2f1eecc4667(
    *,
    state: typing.Optional[builtins.str] = None,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__735bb95d54747b5bc4e87a47bcabe4cc5fe11b0c1d63ed3cff65c5ffac858793(
    *,
    extraction: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioStandardExtractionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    generative_field: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioStandardGenerativeFieldProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5f5e2e809246ca609d3868a1f7f9e1f4df05ad10cc3166cb9af0ea64d9cc7b5(
    *,
    blueprint_arn: typing.Optional[builtins.str] = None,
    blueprint_stage: typing.Optional[builtins.str] = None,
    blueprint_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__190d9739b6522c0e98df05bc232971ba3d6753a299275a99226347e6cb42f151(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12ec0dc1ef52a24343a13536faa962c8e3788ed427c2c5e068832ab49fa66b35(
    *,
    blueprints: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.BlueprintItemProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8951904d09672ba205751d7fc2a522321d7e52411b8ef8fded9c4e1a033c3be6(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2f1e311cd9f356e764c6344a42f3a02ba90d0a18722ebfb8bff1aada39a4857(
    *,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76c8521b95f341304ab3a222219a04bbf2ceb17f1ea792310fced0b4dd9983c6(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__428a438c7cf92c0b8cafd1aa4a56c53ea9ea1b589a03f639fe918843bfd99600(
    *,
    additional_file_format: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentOutputAdditionalFileFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text_format: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentOutputTextFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a39c942d4c66d145361d69ec6f7822ed8c5de90908d2f3b9acce7f6fdc0137bc(
    *,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b8bd6b062082279b6cd00e1cc913b44395a1a04760d248b1eb5a80b40345643(
    *,
    modality_processing: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sensitive_data_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    splitter: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.SplitterConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31fd8cf11b2333c1b9f18cb85de3d2ec6f775ca9373527945bf2cebc9364d322(
    *,
    bounding_box: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentBoundingBoxProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    granularity: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentExtractionGranularityProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__283f3e1f9a29bf9b419282eae3d9a9986755bdd2d31fc1807abffb8f593d750a(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f2a6254e9da18a309ea89791739a405a2e9e9bf02efdf14704c05dc4991f457(
    *,
    extraction: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentStandardExtractionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    generative_field: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentStandardGenerativeFieldProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    output_format: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentOutputFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43d184195fb8b005c0ce7faa36abbded3dcaa817ac56ad44382e3b52f0b4aa17(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbcdba2585e0fbb56dc98a0d3e4cd5058cbab7bc5ec12ccaeac1086de5055e50(
    *,
    state: typing.Optional[builtins.str] = None,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38f8b4b603232fbd0d7b3c548d01d3dfdc30fb00a784fcb7304f56425bf54afb(
    *,
    modality_processing: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sensitive_data_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fa905b045efa2dc215f79ec19c1ab828f0857d05dd5d5d938be99d7ec65850e(
    *,
    bounding_box: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ImageBoundingBoxProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    category: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ImageExtractionCategoryProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e67a2ac681d5efa7009d1c5670aa995aaaef578d2ee5357b06a49538bdda461a(
    *,
    state: typing.Optional[builtins.str] = None,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dac6087c97193f099d2ae4210570149c1ec4763ab09dd8b7fc2d51827f2bf993(
    *,
    extraction: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ImageStandardExtractionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    generative_field: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ImageStandardGenerativeFieldProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a7664cc5b52054d19494996b4d27e5ae70ff9c0072d0dab1d790a4ee4728de8(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1ab8028275d00d0696724da41857bd8add804414bbad214b1c07ddb578ceff8(
    *,
    jpeg: typing.Optional[builtins.str] = None,
    mov: typing.Optional[builtins.str] = None,
    mp4: typing.Optional[builtins.str] = None,
    png: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cdd8d052fc6012fa7e3c7178b0041e500e593fb09968568d344504b9e29ac1d3(
    *,
    audio: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioOverrideConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    document: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentOverrideConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    image: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ImageOverrideConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    modality_routing: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ModalityRoutingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    video: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.VideoOverrideConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e4ed9613490afcb781e4f3d3d5282d38f9ec1fe674d7810a9fdf52fa830a8ec(
    *,
    pii_entity_types: typing.Optional[typing.Sequence[builtins.str]] = None,
    redaction_mask_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7aee36d1a4510935646355d4fac6c38dbb023d44c3e12ef150f02c6da420b72(
    *,
    detection_mode: typing.Optional[builtins.str] = None,
    detection_scope: typing.Optional[typing.Sequence[builtins.str]] = None,
    pii_entities_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.PIIEntitiesConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd39f66f68f5cabdcf5186a41331af8c1b049c0e5b0faf1f1ae7852a30fd6155(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__725551fc561b5af6ced2386775973359d5268cd64b7cb90d850d0ebec4e5b11c(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8436ab1f32296cf87082b839b1fcae9ef9557160d0f277e776f12fe71d4ec5c(
    *,
    audio: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.AudioStandardOutputConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    document: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.DocumentStandardOutputConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    image: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ImageStandardOutputConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    video: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.VideoStandardOutputConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fca2fbb2e95c41e7f34946d5da4d3f5b89ff211d8ca15b61fb6d57ed47c8ba0e(
    *,
    channel_labeling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ChannelLabelingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    speaker_labeling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.SpeakerLabelingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e99b29d4850c1f9478f599c751546f4b223e13ce306b8455192d7bbc0cc271e(
    *,
    state: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65a72813faeaee35b699f6849485645dcf655a83b1b09bab2c2f95448a7b5588(
    *,
    state: typing.Optional[builtins.str] = None,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33303385039bb1ebe45b8166c9a55fdfbf854138da2e563eb8226a963a953c75(
    *,
    modality_processing: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.ModalityProcessingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sensitive_data_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.SensitiveDataConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72f151f921858147c6ee4ebe91c98b8fa8d6ea49eddbda2c961034f3504865aa(
    *,
    bounding_box: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.VideoBoundingBoxProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    category: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.VideoExtractionCategoryProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c93519b4709de39d05e32e42b295b86f34d84cb99dd9cafddde59dd310056bd8(
    *,
    state: typing.Optional[builtins.str] = None,
    types: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d221f0139e3557d10dfaa9cdfad57a712f18b168e6685d5a6b34ff9ee0d554bb(
    *,
    extraction: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.VideoStandardExtractionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    generative_field: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataAutomationProjectPropsMixin.VideoStandardGenerativeFieldProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ba158e57aa34cfb06e79b2b939c46c2753685a214df8e27442ea74e993d8d69(
    *,
    data_deletion_policy: typing.Optional[builtins.str] = None,
    data_source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.DataSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    knowledge_base_id: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    server_side_encryption_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ServerSideEncryptionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vector_ingestion_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.VectorIngestionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7a39fd3f2ffeaca5b08f92ff1c0ae0e423e559ba386cf5381c8b4613a651012(
    props: typing.Union[CfnDataSourceMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__835488c2d8aa15743bb681c15ece350e4a671c4b052c621bc04dd8242fc7d057(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6113d5d6b7a47dc72cf1ef46b4f26ed3bcff3bd8297fdddfc4b9ced8a3d769a(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd6634bf82173978f6992b6cdd5a454b7a68801b78f14441d03acf3017f59c1f(
    *,
    parsing_modality: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__630fea4705dd8c0535526af5b50a19d609832f437c84d7571c70e7f021fa0f95(
    *,
    model_arn: typing.Optional[builtins.str] = None,
    parsing_modality: typing.Optional[builtins.str] = None,
    parsing_prompt: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ParsingPromptProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab5c89c8fc3360471389d62b46ba333b77f6299c7f0183876153351b66f6bf3a(
    *,
    enrichment_strategy_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.EnrichmentStrategyConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    model_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__756158119b6d4abc0049937720e9e0910307d0cb57eab5c57895409fc668423c(
    *,
    chunking_strategy: typing.Optional[builtins.str] = None,
    fixed_size_chunking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.FixedSizeChunkingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    hierarchical_chunking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.HierarchicalChunkingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    semantic_chunking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SemanticChunkingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7868d06e3eff60fe10333ef56105a299038e551f37e16791a97f24ac92644429(
    *,
    filter_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f39ea1f577f8387443da0821430cbbd611cfec153cd96a93a9d2432b8f50677(
    *,
    crawler_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ConfluenceCrawlerConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ConfluenceSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b7c955c5ef5a8488be1c7521b650e495a46b9020a5d5b55018f24e764af36f3(
    *,
    auth_type: typing.Optional[builtins.str] = None,
    credentials_secret_arn: typing.Optional[builtins.str] = None,
    host_type: typing.Optional[builtins.str] = None,
    host_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59763242d9ef3efda9b47cdb79e80b620ce237edb08a90f7f97a6410b9ab98a7(
    *,
    bedrock_foundation_model_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.BedrockFoundationModelContextEnrichmentConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c812fcca11e7ae6a98ea813a470a7c1153d5640763b235b8c2ba410c66b38ff(
    *,
    pattern_object_filter: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.PatternObjectFilterConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__684e787bc278139ffd694ace8060a72a46cb72c84c93d7860e61b7d8db3a57b6(
    *,
    intermediate_storage: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.IntermediateStorageProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    transformations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.TransformationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d63ab0c7a4ace2e5437084564cf92a7fa3ae86f6819bcaead693036fd700c858(
    *,
    confluence_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ConfluenceDataSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    s3_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.S3DataSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    salesforce_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SalesforceDataSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    share_point_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SharePointDataSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
    web_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.WebDataSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3dd4bcfc88b2cee8cc10343d7098b1074201f8cf6b3ef2c285a7e8abcad0aa4b(
    *,
    method: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0155e01b73c0fe792a9d1ac01cc9857e88347666d956e464c2adfaedcb10454(
    *,
    max_tokens: typing.Optional[jsii.Number] = None,
    overlap_percentage: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3e660b4faac287c87e300a994714ffe9152dcfae0dea7a67cb6a1fee11447d4(
    *,
    level_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.HierarchicalChunkingLevelConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    overlap_tokens: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dda58c904a3dca35a7955512cdb52ef39ccbb855304a4d6eb25b623b804044e4(
    *,
    max_tokens: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc796c067ed3393e705332d27c06c2fcca49e2096b05acd3f421b472c8ce8564(
    *,
    s3_location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.S3LocationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7a21006d4e1abcc128f92554ce6b7f952f515568edb74de2916b7e260278cad(
    *,
    bedrock_data_automation_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.BedrockDataAutomationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    bedrock_foundation_model_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.BedrockFoundationModelConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    parsing_strategy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__064a4ce39ff32139452c1ff9db51109274acff681f83a100574397fdc45f7b60(
    *,
    parsing_prompt_text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a90d5a8496c8876fa32060bd1c53eac23fb2cba369fd6cafd051681233489767(
    *,
    filters: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.PatternObjectFilterProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fe1623848a66df9ba9b1845649531dc96ff6ae1991c340ad607b9f373a3a496(
    *,
    exclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
    inclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
    object_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b783448c1e8ea1513c98d4559876a38cb6857abc9f2e7a956919620f9629ea62(
    *,
    bucket_arn: typing.Optional[builtins.str] = None,
    bucket_owner_account_id: typing.Optional[builtins.str] = None,
    inclusion_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61cb4fd84a2d5579a5769de32a273e5d2280d531873b2ac2bc2c8da8223882ce(
    *,
    uri: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c0db8fd164efb390558a9fd38d2bd8f23c0c8823779e76a7e5979ab7772d49e(
    *,
    filter_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28714fd99e295f3c4d605667ac6387377460df06b37830b150629393c8f1113f(
    *,
    crawler_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SalesforceCrawlerConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SalesforceSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c89c24a7b5a02441215e0a5164c3711b39f96484da5680d47bdd8de917f489fc(
    *,
    auth_type: typing.Optional[builtins.str] = None,
    credentials_secret_arn: typing.Optional[builtins.str] = None,
    host_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f761c7ade813493758998baa8acc117d7c57f007ee5c1765a8ebca30242dd45(
    *,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc5677ba471514a86d6594da18ab5e2724a7b5acc4047ff13dfd1959942eb13f(
    *,
    breakpoint_percentile_threshold: typing.Optional[jsii.Number] = None,
    buffer_size: typing.Optional[jsii.Number] = None,
    max_tokens: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f8339841538f1476c65269779da7536fca8b545a88d407225b01e7c9dee2ff0(
    *,
    kms_key_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05ff5b9e370fd66d4928591500cc4d53aeecad6f89c6a1d5957759a63681dcda(
    *,
    filter_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.CrawlFilterConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4456af60d2b7892d62a1e8810b28470767c1810af2af2984eaf3affbcd84363e(
    *,
    crawler_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SharePointCrawlerConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SharePointSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80cfed15f3c56760446f34fbb5dc4b9249f071efa4d2bb150e4e2d31222eb14c(
    *,
    auth_type: typing.Optional[builtins.str] = None,
    credentials_secret_arn: typing.Optional[builtins.str] = None,
    domain: typing.Optional[builtins.str] = None,
    host_type: typing.Optional[builtins.str] = None,
    site_urls: typing.Optional[typing.Sequence[builtins.str]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22f5b8866a06eb4bce06713d85d5b6eeb0c873901ef6befe53a8f8a5ca8e5f9a(
    *,
    transformation_lambda_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.TransformationLambdaConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61277e266712ab1123a6e53a13e1bc0f4c37eae9a99a1079557cb4b72f1d0c92(
    *,
    lambda_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44aefd40fb1a1df956a8ccac12fe37074fa0e09ef4c6b6089c81779ca65c3c2f(
    *,
    step_to_apply: typing.Optional[builtins.str] = None,
    transformation_function: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.TransformationFunctionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e127c40d3453071cc64e854e5d47383bd416b3062e6110ea2e81b56d0ef4b924(
    *,
    seed_urls: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.SeedUrlProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7e9c8480f1ce602fac9676a5162011792e5c743de472377b169453314d96c50(
    *,
    chunking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ChunkingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    context_enrichment_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ContextEnrichmentConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    custom_transformation_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.CustomTransformationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    parsing_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.ParsingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd435b7f007b366f1bcf5138314b09c006f9e4381361a6e9b3f02c20f04b3a8c(
    *,
    crawler_limits: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.WebCrawlerLimitsProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    exclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
    inclusion_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
    scope: typing.Optional[builtins.str] = None,
    user_agent: typing.Optional[builtins.str] = None,
    user_agent_header: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fc83f11e336a36388b1c49a8b2d692760cd703805150bd3fbba0467c2e6362a(
    *,
    max_pages: typing.Optional[jsii.Number] = None,
    rate_limit: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6df8fbf2401e355f6b2e2efdf30a4b8423c6ef60f2631ed6c7f194d9e0a3c848(
    *,
    crawler_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.WebCrawlerConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.WebSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d8269d36e1ebc930c5e1c6edc333cf6757beee179476aee348cdb767ca4b983(
    *,
    url_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnDataSourcePropsMixin.UrlConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__391de06c81eabdc3a81aac5d6f0b63b3c9ac97eaba2971e95554f0558f153199(
    *,
    concurrency_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowAliasPropsMixin.FlowAliasConcurrencyConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    flow_arn: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    routing_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowAliasPropsMixin.FlowAliasRoutingConfigurationListItemProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4e13cea232527c0004ef3c19e49e655b3cd044d9e06fc6e0bd7f683311750ae(
    props: typing.Union[CfnFlowAliasMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cac2f2cc00ab8700c161c1328e77ca535bc42acfd03ce3a1faea191bc61194f3(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb6962ac3497352e3f289e46ca55a28ca8892b394e7257b62a3b36bfedf1635e(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__366aaf82b68a6a1d82d393ff6099329d0185a1e15c2afcf02dad94483b5bbf47(
    *,
    max_concurrency: typing.Optional[jsii.Number] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4325757fed72a8dfa4e327e08871c698eafdeab6317e913abd225fca7cfde42(
    *,
    flow_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92e2f7922247e05a55ea9a42e1889ded0a39dd38c9c3753c4a3b77290c1bb590(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe42b35b9ec7605d9fad663ff452fee53127be1ea43b231d91cf7b7013487a4d(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79ff47630f881e24eef083d24bf8e13e70a1f0fe7fb506dc8f49361c6b1d1736(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff618fe0139ad6c1716c844736c0be0c15f70ad6018add372e052dae207ce6be(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89d4c8719a67d215a7ada3b1b40131ef220fb6be5650e60370f4bcc602a52f7e(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8bfad6fb9b31dbf5489e6ef3ac0d070d963086c9b98a192470032697b53cba9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12cc753c0d5e3d67ae9827031f4e3aeb6f5f7c3efd6e46573db9ad713bf3d0bf(
    *,
    customer_encryption_key_arn: typing.Optional[builtins.str] = None,
    definition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowDefinitionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    definition_s3_location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.S3LocationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    definition_string: typing.Optional[builtins.str] = None,
    definition_substitutions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, builtins.bool, _aws_cdk_ceddda9d.IResolvable]]]] = None,
    description: typing.Optional[builtins.str] = None,
    execution_role_arn: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    test_alias_tags: typing.Optional[typing.Union[typing.Mapping[builtins.str, builtins.str], _aws_cdk_ceddda9d.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de2b10de78baad85fe62766f62b64bc9aaf7e75a41ddfb06e22c07c391ee5c7b(
    props: typing.Union[CfnFlowMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7472ae15594b12b58fc69972087385ba779a6ec421c9d6d71ddf90fb0d3c25be(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8afba9adfa4e8ceb6d91169178de0dfcf4181aac424c5fa3a693157f02161ad(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbee76cff8790b31881f39c812aebea00a455dcd9a545eb6bf0e0468fea23a5e(
    *,
    agent_alias_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa13ebcd3a4b5ff4031794774916cceec999dc4d4ef884daf2ac5840405dca7b(
    *,
    conditions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowConditionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c9ebc2eb39b205f881b1aea522e442760b6a8aa3ff8895fb2badf4b0f42e772(
    *,
    field_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b930cb94b2698f0e19adee4bbbe0ca516b8fd207962ba7863da996a05190bd3(
    *,
    expression: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb6ca06d5aa2cb08aaad2c923c0beaa8667f0afc7cd444bde5cfccc2253d4f76(
    *,
    condition: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0eabdbb1acbd33a80548b8e16d7dc97acb6b3ead5c8e14df58ebdc54f970aadc(
    *,
    conditional: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowConditionalConnectionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    data: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowDataConnectionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__279bf15f66a729944fbf9332bf54d237410f78cf3fa7010e11be0cbde9e6fdf1(
    *,
    configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowConnectionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[builtins.str] = None,
    source: typing.Optional[builtins.str] = None,
    target: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__066e8c372b17ec7070ac5f3d2e66ff75407b98dd5426cdab52f3c79cf9bd52dd(
    *,
    source_output: typing.Optional[builtins.str] = None,
    target_input: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d12e974e8c40a48a0c3fc84065b3ead9be51f64fe1c43976210c1b770a09959(
    *,
    connections: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowConnectionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    nodes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowNodeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7399e14b834e8a4c36e0c5967cf7801b51c567d45dd59ed7383029c90c050b77(
    *,
    agent: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.AgentFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    collector: typing.Any = None,
    condition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.ConditionFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inline_code: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.InlineCodeFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    input: typing.Any = None,
    iterator: typing.Any = None,
    knowledge_base: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    lambda_function: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.LambdaFunctionFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    lex: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.LexFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    loop: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.LoopFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    loop_controller: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.LoopControllerFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    loop_input: typing.Any = None,
    output: typing.Any = None,
    prompt: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    retrieval: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.RetrievalFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.StorageFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56076f9c1f9b221b3d8e53156287db345724de9103f9d296ed192f757e5c7777(
    *,
    category: typing.Optional[builtins.str] = None,
    expression: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f48ba7c598a01507071f7069c5d1f5a25dea1fdfa9da8cb6d0b6da252af8fd9(
    *,
    name: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35023d7de2bd5c2bbc8b2b947cc0a740584c31cdd77874709ef0aa29e2d7c5f1(
    *,
    configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inputs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowNodeInputProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    name: typing.Optional[builtins.str] = None,
    outputs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowNodeOutputProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c89603a56554af95ac5bdf63f40d28c2b5856a2a70de91090f243fd22afd19f(
    *,
    message: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe989a819f412291fc1aeb0ba3d2fbdebed7541915bf58e317acbf7305e2e0b7(
    *,
    guardrail_identifier: typing.Optional[builtins.str] = None,
    guardrail_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c3e09c6d239d75df87082f024c6e349694af9b3c18c16cbbe9ac509d89de08c(
    *,
    code: typing.Optional[builtins.str] = None,
    language: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d9d0ce4063d86ba2ccd6005c753169cca3e1f1da71933b641639a06df49035a(
    *,
    guardrail_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.GuardrailConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    knowledge_base_id: typing.Optional[builtins.str] = None,
    model_id: typing.Optional[builtins.str] = None,
    number_of_results: typing.Optional[jsii.Number] = None,
    orchestration_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    prompt_template: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    reranking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.VectorSearchRerankingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__723cadb376bb39b3a950cbe36823c816c479e57748614d01683ea7f4dcd29455(
    *,
    additional_model_request_fields: typing.Any = None,
    inference_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    performance_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PerformanceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    prompt_template: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.KnowledgeBasePromptTemplateProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a2def3f57ebd4a6e3555c77078a5453f4088ec37b962d86cf73659a649f252e(
    *,
    text_prompt_template: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b6a4641415d945b605ed750dcff40d7cac2c3ed5f36b6daf4929f3487f6ce22(
    *,
    lambda_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41d04f0ceab1f87bd5dfaec65c91e96e606faabd580314ff71cfe60171e9f754(
    *,
    bot_alias_arn: typing.Optional[builtins.str] = None,
    locale_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d3fa3dd2184579e14ed904a879ff21baf6f0816612cebd9c41bfeecf760c2f9(
    *,
    continue_condition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowConditionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    max_iterations: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bfb0667ab10ff11236b1036b6a716557e03696abe0308430fd7df73a54e9c48(
    *,
    definition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FlowDefinitionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__613b2906f9c599b4406f8adec67470c43c81b6807f89312dac200eb562d015c6(
    *,
    selection_mode: typing.Optional[builtins.str] = None,
    selective_mode_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01c43e988662fcd2c975b5a7fa8d12f507dd09c5506344073986157fb40198c7(
    *,
    latency: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be8340a576f8475bc671d3ec91c05e357737f2cb442a5695ab5cea807b2b8ee2(
    *,
    guardrail_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.GuardrailConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptFlowNodeSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2f1c39627d14e00f9257ccacf844e73e35f5de77b9e1c22e2ba4bbb032d8f33(
    *,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    model_id: typing.Optional[builtins.str] = None,
    template_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    template_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a16553f33601f74e6b26d00994fb6d201e98fcbef8f71e7f5d8a0e327ae33086(
    *,
    prompt_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bc9ffbb873fb3013c529666b7df1488faf5a0697578d9e1e898a52da5cdea6c(
    *,
    inline: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptFlowNodeInlineConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptFlowNodeResourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3cf56fb9b529aca2802c065375b092b00e28b05e0e4300e39769b94765f095d(
    *,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptModelInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4410e64061e40a72caf3f6058d613301c2e863f9bb7d3c858c071948ba710e4f(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f5b8f249a133488bfbbd9e28588dd29f5b3fc732e99421c2121b4a3d2317b6b(
    *,
    max_tokens: typing.Optional[jsii.Number] = None,
    stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
    temperature: typing.Optional[jsii.Number] = None,
    top_p: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb5f7ea39ce6d0ea13aa78eba1b2a22ccf4a633604230b4bcca1cef9ec483f66(
    *,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.TextPromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__feb455b3fc8ddbe2dd88ee0a7b69891ae171db5e08d6b677c3360b2d77bfe6d6(
    *,
    fields_to_exclude: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FieldForRerankingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    fields_to_include: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.FieldForRerankingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__601b223440345b1f1c05521c30d412451f2c6cd8f73a78f98ed0642fd2e6886a(
    *,
    service_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.RetrievalFlowNodeServiceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__053d02324f2ad0676ac3eadc1226ff78e53eaaf81d6e625aba4615bd85e56b7c(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1aa790afb568e35b0a5a0a901074af8316bce24dde0644af6a741f28b3d37f2a(
    *,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.RetrievalFlowNodeS3ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac8e647502e4189f6bdf06521fe61791dd1613707f037e5983510f722626f7ea(
    *,
    bucket: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d94e9b87535bf5aaddb270262e8e286dabaf031800f68b98d8056200db376f6(
    *,
    service_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.StorageFlowNodeServiceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b6944f15c879c57dec9a3eeed6b1438e8fb40b5b28060affd92caed990e61e1(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88555a38426faa7a4df4752182ab756d78132ed045779f7c8fd0dd4bce8fee86(
    *,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.StorageFlowNodeS3ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5b16af49918078bb2a22791bf4d9f9c53bbe92d6c2a1f01e58dd14cdcb02c76(
    *,
    input_variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.PromptInputVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6130b8c2c89c5646bea3126e07df7333b5ccb6b159fc65eb9b483ae1d59df05(
    *,
    metadata_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.MetadataConfigurationForRerankingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    model_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    number_of_reranked_results: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2292d8fafa05c9e71c6ef15a0c560232adb59a77f827f36fcbe9a36819aa5110(
    *,
    additional_model_request_fields: typing.Any = None,
    model_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dac11fda848e627f9f224c0cf83de18717f98a38dc21c344ddc403a419e2ca11(
    *,
    bedrock_reranking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowPropsMixin.VectorSearchBedrockRerankingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1e1207d57a926aa44ec047044e2ab00d3abb57d1b0db6b3bd5cebdf8979adc4(
    *,
    description: typing.Optional[builtins.str] = None,
    flow_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7300aca477a27a4d971474bec3124322ab2cfa0345cca140fc3adb105cd802e4(
    props: typing.Union[CfnFlowVersionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b75c8ad5114d880830a6d6526d482661f579ede55f902fe706bd1c7696257d38(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0facc298a9882b6acc06b845f147c20e8f891817dc2977330c2acd03f6c11610(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b9daa472d0f74542cc440033d5aa927e7b2dc59de6f75e693dc8168367602bb(
    *,
    agent_alias_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8204b1147b0f545c68eefd8412fc8022396cc4ba18dbc266f950b8a60cdf9af(
    *,
    conditions: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowConditionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed8b4f6ea3b6f7b245d0fd8c31032abd0f05bfd1f41a0f6c577ba23461df04d0(
    *,
    field_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea6147f75179278dd8031bb9aa2a0775b9bb734bc18594e60756267a7e793284(
    *,
    expression: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__994c0017022960c67139dfd55dadb6507298a217ab616fa60861e159e2f45b5e(
    *,
    condition: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d8029d5b81e8ec77cd586484642ab537d6727ab4f7f2ac447566dc35070ff50(
    *,
    conditional: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowConditionalConnectionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    data: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowDataConnectionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25716dce9f95cdd4d2e09860ca1fbfd108dcdae86cfb4cd0f3d370159b7e57f1(
    *,
    configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowConnectionConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[builtins.str] = None,
    source: typing.Optional[builtins.str] = None,
    target: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc706e2bf2dd080695260c7eb562b189736a0eefbcedaace27ff94f1de775f26(
    *,
    source_output: typing.Optional[builtins.str] = None,
    target_input: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a79320e0b4db4c53c5a7acf699720fca7fe2757eb1cdb0f60dfdcaf427f6005(
    *,
    connections: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowConnectionProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    nodes: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowNodeProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e4762d8bb9584c7523dc727bd9eaa983cdc460bd1a7d59d16779710735b2266(
    *,
    agent: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.AgentFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    collector: typing.Any = None,
    condition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.ConditionFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inline_code: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.InlineCodeFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    input: typing.Any = None,
    iterator: typing.Any = None,
    knowledge_base: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.KnowledgeBaseFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    lambda_function: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.LambdaFunctionFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    lex: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.LexFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    loop: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.LoopFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    loop_controller: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.LoopControllerFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    loop_input: typing.Any = None,
    output: typing.Any = None,
    prompt: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    retrieval: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.RetrievalFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.StorageFlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ef6dd3b15d227ed262131557ad31c50128e9b70fddf2d852444190b815844c0(
    *,
    expression: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3780b9abc7a22d083c33c65e642f9c1082e2570245664a398dfc216028b24ad5(
    *,
    name: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a764a5378fd0166173f5954332eba13f5b71c6828cfe26f1bdc44528343b194(
    *,
    configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowNodeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inputs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowNodeInputProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    name: typing.Optional[builtins.str] = None,
    outputs: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowNodeOutputProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__451554bffd20ba06d78c724461b14c67e2a272882cfd356c0dffd5d83c159e63(
    *,
    guardrail_identifier: typing.Optional[builtins.str] = None,
    guardrail_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70ade5ff8dc0a417e4254622e265e702ca724dd929fef699a35cf6ffc7699282(
    *,
    code: typing.Optional[builtins.str] = None,
    language: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0df63fee092a9686afeb88cdb5dc188fd22c756572e03de07b286af74c9a4278(
    *,
    guardrail_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.GuardrailConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    knowledge_base_id: typing.Optional[builtins.str] = None,
    model_id: typing.Optional[builtins.str] = None,
    number_of_results: typing.Optional[jsii.Number] = None,
    orchestration_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.KnowledgeBaseOrchestrationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    prompt_template: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    reranking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.VectorSearchRerankingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eac43ca6c6cbfbf55050078e772773e7ac9c3db217ebebe6880a2c47181aa1a2(
    *,
    additional_model_request_fields: typing.Any = None,
    inference_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    performance_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PerformanceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    prompt_template: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.KnowledgeBasePromptTemplateProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68a45b1552a51ee2adabe384032a07077a62eabe3db79b289778b076b1410e03(
    *,
    text_prompt_template: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97c467f244286c2a399bb87391823a29d1320bf3e14c4c3cdc9b03b0c6ff738c(
    *,
    lambda_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__671f2ac5134b1754f540245f695529902ad632891a191c3fd8b1e516a830950e(
    *,
    bot_alias_arn: typing.Optional[builtins.str] = None,
    locale_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15e9b94777e9b1b48d62d629ca60e589f7afbe40027e284d7f7504baa7e10230(
    *,
    continue_condition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowConditionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    max_iterations: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__466e09223bfab68ee5fe2db255310c5d2095f55d4e9ed7945cf45d30cdfed0b0(
    *,
    definition: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FlowDefinitionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61b970e81b7ea491ce006f0983856dae9c2aaf47e7489f5fa89ec5e9e440a186(
    *,
    selection_mode: typing.Optional[builtins.str] = None,
    selective_mode_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.RerankingMetadataSelectiveModeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4f0cbb7ca50627c07fdc827ce60814f55dd5a4917574cb80e3651a32ad3b52d(
    *,
    latency: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__becb6791bc224364a06501e675d8ea9bd31c1df798c687a759f67bba6b4a0602(
    *,
    guardrail_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.GuardrailConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptFlowNodeSourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbe887f934eb1de4d84a1b07586103f63c05f8b7126927831d4a298dc4a25e5d(
    *,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    model_id: typing.Optional[builtins.str] = None,
    template_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    template_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7591b7ab1e77eefb3b288511b10dbae4a5b412b9b55aa0c647cc8ef594a3cbe7(
    *,
    prompt_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20b7b4b95cbfa53d58bf20f9d8c993af083fdab34e585a1523ee3fb403259a1b(
    *,
    inline: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptFlowNodeInlineConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptFlowNodeResourceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bbdb880fc136f689b0dfcf76aa2ca4bdd6d28392eac4587e4d53746850817ba(
    *,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptModelInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3faa9302142b9b5e44a4c1a26c2fc679f580a0955f0d9f129f1579f05fb821ae(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb0a04ed04fad15da0f6bf51e85144ccb9d291724bd5d31b955c498e3fd473f2(
    *,
    max_tokens: typing.Optional[jsii.Number] = None,
    stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
    temperature: typing.Optional[jsii.Number] = None,
    top_p: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8eb0c43d8509270ee6e17a29e22722ef0a905c92e0625548ed0f82acf820930(
    *,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.TextPromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ad0c08ab2e11ce6e6b3165edc08af8267f0ef68147586c21af6ccef9d8e73f8(
    *,
    fields_to_exclude: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FieldForRerankingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    fields_to_include: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.FieldForRerankingProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb5aba1d6ff0ba266c492631ea389d042c173289a8eaea1ada0c2a8aafdfe7f8(
    *,
    service_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.RetrievalFlowNodeServiceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a893eee5082f99f98e6b9f187387f6d3da4e2e87bb8bea015df4f2bf9d77508c(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__420ea91191b505c5bf5c4248fee637d405636d4ed65397a255304b4ddd71ea58(
    *,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.RetrievalFlowNodeS3ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16c7ebf7272d11464d819f541fcf3a42a4f84a686b0b76fec9854cc9ce4a79a5(
    *,
    service_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.StorageFlowNodeServiceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73ff693d885fe1b82fbc790c20d70a77c9c1f679a59a4cc3e8b683758b734d9a(
    *,
    bucket_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33f8faa8f6ae445b9c3f5944816c1ecefdcccee1479bea46d17c1cd1d1f5206f(
    *,
    s3: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.StorageFlowNodeS3ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f9eb0e3fff3b6d5c40b1c0e96ad5c6f4a71efd4a059fe4aa93aefa05237ddd4(
    *,
    input_variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.PromptInputVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d87f4ece24bbcf4a260f28b865777a93dc73ae388b31c358d94c70c21f39e669(
    *,
    metadata_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.MetadataConfigurationForRerankingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    model_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingModelConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    number_of_reranked_results: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1aceb401aa71f7aa77b3123e9762a5b543c86b2574443dcbf1e30ad9c8a5932a(
    *,
    additional_model_request_fields: typing.Any = None,
    model_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6eb8c9b2c3fd97190511322d0a78c6bb331be6308c28344a58313ddf438e5742(
    *,
    bedrock_reranking_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnFlowVersionPropsMixin.VectorSearchBedrockRerankingConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88366691e366db6afe58e0cbe59b580cf7cab047d115363bb23da0997ac5e494(
    *,
    automated_reasoning_policy_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.AutomatedReasoningPolicyConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    blocked_input_messaging: typing.Optional[builtins.str] = None,
    blocked_outputs_messaging: typing.Optional[builtins.str] = None,
    content_policy_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.ContentPolicyConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    contextual_grounding_policy_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.ContextualGroundingPolicyConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cross_region_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.GuardrailCrossRegionConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    kms_key_arn: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    sensitive_information_policy_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.SensitiveInformationPolicyConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    topic_policy_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.TopicPolicyConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    word_policy_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.WordPolicyConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c9fcddc035057dea3d0916eb9f5bf07f50b849744dfbf898103a822617b08b9(
    props: typing.Union[CfnGuardrailMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a20726603b01dfbf3ec19af1d6e5fbdf491d3368fd826dde98cad290a7f4ddaa(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11476f343f5628bd0b8b11c90ea92253faa3f66e476413797540c03b69330d4b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecc618d3b9f468d9094cf8d3be218e2c269018804d4fe01c5ea4b9d68b882ab0(
    *,
    confidence_threshold: typing.Optional[jsii.Number] = None,
    policies: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34789e2e0805282361d1eb8c54632a79d7b5ecd6944c3e24601d6c00d8ee3de4(
    *,
    input_action: typing.Optional[builtins.str] = None,
    input_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    input_modalities: typing.Optional[typing.Sequence[builtins.str]] = None,
    input_strength: typing.Optional[builtins.str] = None,
    output_action: typing.Optional[builtins.str] = None,
    output_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    output_modalities: typing.Optional[typing.Sequence[builtins.str]] = None,
    output_strength: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e12a15e1d77089bea8a157ba9aaa865d08562c9a9f64e33c63eac711313fc52e(
    *,
    tier_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f38697e2a3b1be529d62ca06d62ea360ca666122475c1af3cd3e321d08a23b14(
    *,
    content_filters_tier_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.ContentFiltersTierConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    filters_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.ContentFilterConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02293b13fae70be04a0095ff115ce4ce1fab7d1a81e40e87d6472776d5c61916(
    *,
    action: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    threshold: typing.Optional[jsii.Number] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5940cb5f710576c577309e28fb85960786f464162910688011950fe1ecd16384(
    *,
    filters_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.ContextualGroundingFilterConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89236e14820d566994623ae9e18144039223b3db4a98ebfc959c8be783d89bc4(
    *,
    guardrail_profile_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69cc098cb7a3f5ebab1da461c6948ed33ecd6ee6203ba9dc4732d8fc7e15479f(
    *,
    input_action: typing.Optional[builtins.str] = None,
    input_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    output_action: typing.Optional[builtins.str] = None,
    output_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__823ce9598cf1266cf5ca42e7d16f55633a44b2e9184dcc6eadf7fdfecc2905ae(
    *,
    action: typing.Optional[builtins.str] = None,
    input_action: typing.Optional[builtins.str] = None,
    input_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    output_action: typing.Optional[builtins.str] = None,
    output_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e6cada9e496bd80442b50b547f6b3fff1ec4967107185afe14036b3c31050b3(
    *,
    action: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    input_action: typing.Optional[builtins.str] = None,
    input_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    name: typing.Optional[builtins.str] = None,
    output_action: typing.Optional[builtins.str] = None,
    output_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    pattern: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b707c1a2192a8e818aba69da224da18f9d754afcffc4c8fb3f135db5539e51fa(
    *,
    pii_entities_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.PiiEntityConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    regexes_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.RegexConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3dfb43acf06c09ff51e39973ab1d3857d2acf7a81e65a5fcc0344d5e01421b6d(
    *,
    definition: typing.Optional[builtins.str] = None,
    examples: typing.Optional[typing.Sequence[builtins.str]] = None,
    input_action: typing.Optional[builtins.str] = None,
    input_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    name: typing.Optional[builtins.str] = None,
    output_action: typing.Optional[builtins.str] = None,
    output_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec21e6fa622cb554f41404e92e6dbd72d8c4bd6a0e3ffad715af74fdc7ae67f5(
    *,
    topics_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.TopicConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    topics_tier_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.TopicsTierConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bbfd7fe562254e324fc3fc505f82017dc1e6274cd2f13253e2a97e3bf2120eb(
    *,
    tier_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2a6f246ba2fcefc8397b00b442717ce0fd0435f86d11de5f98facddfe218f7b(
    *,
    input_action: typing.Optional[builtins.str] = None,
    input_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    output_action: typing.Optional[builtins.str] = None,
    output_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8d2527c1e2184264d87498c5373ac6b6d605c2564aaa8e7e39ddae89590d923(
    *,
    managed_word_lists_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.ManagedWordsConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    words_config: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnGuardrailPropsMixin.WordConfigProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e802ed21befad15c92612df9e126cc6b3ed815c71591a8178ac87b14bb6a2816(
    *,
    description: typing.Optional[builtins.str] = None,
    guardrail_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c04c78fada86ca507468283c1d133c07485e6c920d0725626ec92a8d1b8c8007(
    props: typing.Union[CfnGuardrailVersionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a1a8b19b3904268970102f42813ba3e79b419b7a74b548d473f9aa55bc90e4f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64c0726887e78275bb24387fd90b3845f585e3b0899b4fc9ba6200fe4c9055e6(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecf739d087942a6f8daf151f53c06477208e4413268bbca4d3203137d96c4ac3(
    *,
    description: typing.Optional[builtins.str] = None,
    fallback_model: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    models: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIntelligentPromptRouterPropsMixin.PromptRouterTargetModelProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    prompt_router_name: typing.Optional[builtins.str] = None,
    routing_criteria: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnIntelligentPromptRouterPropsMixin.RoutingCriteriaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04d46997c0584923fd6658d5f579cb74d760d8af022dedd9e386efbc7dcd1b95(
    props: typing.Union[CfnIntelligentPromptRouterMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3651fba3fa3fb86e0a4b6911999b521945377de01ea59eb560223296d012a458(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__624f71067ee5280bd63481c4d400e46604d315b2bd69361320ba847b720e04b5(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55ac521ae724ee1ed89c9cf21b3009f3952e6d7c05f2b51194b1aa43f87096bf(
    *,
    model_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__013dfa7a61f71aa6791ef70827a29471feb991d3da83f1d3d23a92be2c4ce95d(
    *,
    response_quality_difference: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9afd6c729cd28bbc4b51ff8d18b051d6fa934af37ede9c1342e2cec7553c0695(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf1179280e496ee484ba8c092b53a4d245217292444dcf13687f9cf441a1c0d9(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79b211fa86d8cc8e93265b03b2f86f7c40295361ca54c6cd405ebe4fd27b8e89(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bcb29991e4e19c615e1385fd0d477b8d4c01c3caacbea038045566a98c009f7(
    log_type: builtins.str,
    log_delivery: _ILogsDelivery_0d3c9e29,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__975a69d7e7aa49b74e579ee108e7a20efec4c4b71d438ad5e697b23d180deeb3(
    resource: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26725175212e581ad90f4417adcc6893a188dd434926ebfa21c2126f2ceac3c9(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65fbd36f79738468da5552412a92e28305aee7f1def9caa8db28e021c1b2aae1(
    *,
    description: typing.Optional[builtins.str] = None,
    knowledge_base_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.KnowledgeBaseConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[builtins.str] = None,
    role_arn: typing.Optional[builtins.str] = None,
    storage_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.StorageConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32cfa482e372255d6c05d090583cf9e4e8c2932f8ec2416b9768df00c617e453(
    props: typing.Union[CfnKnowledgeBaseMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__672ba3e281b72eefc8b0ee8bbfcb412cb42975da2a07c5beb9378938e180179f(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a1f93a7a95be0ab7c9728b7717204499e5d6f62170897f55cad7ce0614cd753(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba1c6ed6ada509576b985cb30c7184bd37e665c655002aee341409006af6feac(
    *,
    segmentation_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.AudioSegmentationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5927d38ebe38d2a7cc47d3ef0889fd0c661426087a724cfd58d1f5253327557(
    *,
    fixed_length_duration: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92728f6bfddc8c6ed9bad91ef784f8aeaee42479d5aaa681ca1c400c9206f9c9(
    *,
    audio: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.AudioConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    dimensions: typing.Optional[jsii.Number] = None,
    embedding_data_type: typing.Optional[builtins.str] = None,
    video: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.VideoConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__134057264a0a0aeaa28ede3e9c832b37b7affd70682b7986dd03929909beb94d(
    *,
    natural_language: typing.Optional[builtins.str] = None,
    sql: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbaef4354679045a013eff34b790e989ff2ffde9ec14b529980f674e7693199f(
    *,
    bedrock_embedding_model_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.BedrockEmbeddingModelConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be62fc61c58bb5b90b13f2998d2fe248b5dbe53eb8d3957d7aaf3c076db36456(
    *,
    kendra_index_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e796843d726cc5636b22dc1ecaaa4e4975480bee5c069a1e73686acc377058a(
    *,
    kendra_knowledge_base_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.KendraKnowledgeBaseConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    sql_knowledge_base_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.SqlKnowledgeBaseConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
    vector_knowledge_base_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.VectorKnowledgeBaseConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1b1ecf78ff75a54073753e7245812f3abb1bec7b92057cc9df89f43d5e2d090(
    *,
    collection_name: typing.Optional[builtins.str] = None,
    credentials_secret_arn: typing.Optional[builtins.str] = None,
    database_name: typing.Optional[builtins.str] = None,
    endpoint: typing.Optional[builtins.str] = None,
    endpoint_service_name: typing.Optional[builtins.str] = None,
    field_mapping: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.MongoDbAtlasFieldMappingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text_index_name: typing.Optional[builtins.str] = None,
    vector_index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbbdbbdbd9cd3eb51a09589170b0c539e4748ae326d38927bf039472929f97f5(
    *,
    metadata_field: typing.Optional[builtins.str] = None,
    text_field: typing.Optional[builtins.str] = None,
    vector_field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d29ef8c37eeb3ba975a20efa48d74c23284b531fc6704c955c78b2e9e86ed068(
    *,
    field_mapping: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.NeptuneAnalyticsFieldMappingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    graph_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d9e4d88d8e1fa02eb1ff51ad75daf0d49cb28262f9a8d49f54cbb1bbd27e174(
    *,
    metadata_field: typing.Optional[builtins.str] = None,
    text_field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32e0d88f8d805e915276e77ec185f0c5eec54b030e1747f05b744c9585b867f6(
    *,
    domain_arn: typing.Optional[builtins.str] = None,
    domain_endpoint: typing.Optional[builtins.str] = None,
    field_mapping: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterFieldMappingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vector_index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ce3851d216586390736097c4ad1f928d95f1ee0cf574b345cc9546f66d228c6(
    *,
    metadata_field: typing.Optional[builtins.str] = None,
    text_field: typing.Optional[builtins.str] = None,
    vector_field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1964b5e76b853562ba4cf4a2b2681db6a4605ad11fc2a5f769539d75f41bd45f(
    *,
    collection_arn: typing.Optional[builtins.str] = None,
    field_mapping: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.OpenSearchServerlessFieldMappingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vector_index_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37cad0fee058954883fb9d5adf68b608a736175436ab5f8a70a0386c93c1fc76(
    *,
    metadata_field: typing.Optional[builtins.str] = None,
    text_field: typing.Optional[builtins.str] = None,
    vector_field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d9c862e33d755f684fbeecefcb57a740d86381b491c6153b25bdef24173a7c5(
    *,
    connection_string: typing.Optional[builtins.str] = None,
    credentials_secret_arn: typing.Optional[builtins.str] = None,
    field_mapping: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.PineconeFieldMappingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__918f726a23a350dcf9d229122cbf57c2626a620e05ad26bd73a00ddaa308ebf3(
    *,
    metadata_field: typing.Optional[builtins.str] = None,
    text_field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a0dfba053443884ce267215c03a71eac3790447bccc8b6fcf869fe4ce32de49(
    *,
    description: typing.Optional[builtins.str] = None,
    inclusion: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd3fee86d292d170c9857e680895c14df9403eb7addad3528933be455833b2c6(
    *,
    execution_timeout_seconds: typing.Optional[jsii.Number] = None,
    generation_context: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.QueryGenerationContextProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9e2cbb76c00e6d6eb6fc2eaabf71edec5fe3b7ccf13c776706544ea66b90649(
    *,
    curated_queries: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.CuratedQueryProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.QueryGenerationTableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e2b4eaa21edcf8c8530e592b8f8406bd43082b1e761476d2cec9a03fb3bddbf(
    *,
    columns: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.QueryGenerationColumnProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    description: typing.Optional[builtins.str] = None,
    inclusion: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03175253998c08ac585ba161d950430a58dc65d7749b244d14b158a14c3b0b45(
    *,
    credentials_secret_arn: typing.Optional[builtins.str] = None,
    database_name: typing.Optional[builtins.str] = None,
    field_mapping: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RdsFieldMappingProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_arn: typing.Optional[builtins.str] = None,
    table_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32544c6a55e5cdb9334772c48b7a8ec249824b3aed5de1ad3f9b3ada61db2d36(
    *,
    custom_metadata_field: typing.Optional[builtins.str] = None,
    metadata_field: typing.Optional[builtins.str] = None,
    primary_key_field: typing.Optional[builtins.str] = None,
    text_field: typing.Optional[builtins.str] = None,
    vector_field: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c739205759cb27066978bdec991a64d29cddd001183c07ab89d78fd30330b1cb(
    *,
    query_engine_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftQueryEngineConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    query_generation_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.QueryGenerationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftQueryEngineStorageConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b440ac030233a388f20c833d99de384e5dc98ecf20fc9e60b7617d7e2375fcc(
    *,
    database_user: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    username_password_secret_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2250b41d9c69c87b342b97fe7f0c8f43ee64d69d3e3728ca0ac5ec10093827c(
    *,
    auth_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftProvisionedAuthConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25b1bb33a76ade17d42c6803a26d57c445ebbddd21387c3107cba38f46e9554f(
    *,
    table_names: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d90550323a1bc4d0b18d03fc572510f814dd167f35037f19e2801f7327fa743d(
    *,
    provisioned_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftProvisionedConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    serverless_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftServerlessConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e98f3c2191b766de1a907a92134e970acb692ffb78b5be3ddb74efe95da35e1(
    *,
    database_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__276b22c1a64319aced9ae570da5d56a3e481aacefd748a2421f54111ce8490c1(
    *,
    aws_data_catalog_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftQueryEngineAwsDataCatalogStorageConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    redshift_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftQueryEngineRedshiftStorageConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f85e9562a7e1b79e1d99eb9f2f5a7e7fb17045567be15e73a01234ba54667782(
    *,
    type: typing.Optional[builtins.str] = None,
    username_password_secret_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b10a47739a29eb514dc63cc738ec3b25550f2924b995912316a286ce524b3cf(
    *,
    auth_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftServerlessAuthConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    workgroup_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d171537d919cbf33d0f46fd0ec1b06b170b7fbb5c9aa5b1d8f4f9b3dbc24c443(
    *,
    uri: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d878a8acd70f1a03014375f3d0fac48153c5adfd4dfc955534c8c8ce51c68b01(
    *,
    index_arn: typing.Optional[builtins.str] = None,
    index_name: typing.Optional[builtins.str] = None,
    vector_bucket_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd28fe13a15f878a612560b3ef9215baf21e3a1ff33f6856accca138ad129cb8(
    *,
    redshift_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RedshiftConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23bc966cbeeaf42eaf4b23bc762c9f010a96754ed1ecb3f160fe80008bae3c3d(
    *,
    mongo_db_atlas_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.MongoDbAtlasConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    neptune_analytics_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.NeptuneAnalyticsConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    opensearch_managed_cluster_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.OpenSearchManagedClusterConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    opensearch_serverless_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.OpenSearchServerlessConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    pinecone_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.PineconeConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    rds_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.RdsConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    s3_vectors_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.S3VectorsConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f74181b4de9b99ab5cfa947e3dc6f0d2a06c1bcb3d51242c551d7f360aade623(
    *,
    supplemental_data_storage_locations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.SupplementalDataStorageLocationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa2423d8a5a4dd4d199ff6b281daf315d69b3a74c606d2a2d729d43b64aaa721(
    *,
    s3_location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.S3LocationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    supplemental_data_storage_location_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53ea2d34778b050600681a8f0c649f2b0332ae6f6c76ed279c3b37d0b49d372a(
    *,
    embedding_model_arn: typing.Optional[builtins.str] = None,
    embedding_model_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.EmbeddingModelConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    supplemental_data_storage_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.SupplementalDataStorageConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d1cf01d2b67f3a7158d2d8096b4a49c657dbddf76696e051f4af5f6da941d98(
    *,
    segmentation_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnKnowledgeBasePropsMixin.VideoSegmentationConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b008d6b7ae239a9f1d7bd4b11bbedac01d18d38c1d19b4429cb926b98743c446(
    *,
    fixed_length_duration: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e1089624b651106f6050525f4ea2d29ffe8cfd90d1905055aef65c9caf54b9c(
    delivery_stream: _aws_cdk_interfaces_aws_kinesisfirehose_ceddda9d.IDeliveryStreamRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2abfbbece6e88024b43d1ce72e602e31f4747bd895c3c4a694de26aeb3a82a69(
    log_group: _aws_cdk_interfaces_aws_logs_ceddda9d.ILogGroupRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__059a829cfb2c6d46c203dfce4c1304ab07e5736a74a2247dd4a45faafb6a9747(
    bucket: _aws_cdk_interfaces_aws_s3_ceddda9d.IBucketRef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a14946a3c31d9068515dbd82d098269dd4986cc76ae4d42135103925f802a3fb(
    *,
    customer_encryption_key_arn: typing.Optional[builtins.str] = None,
    default_variant: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    variants: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptVariantProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a094cbfb4280670d93f2d810768085dd821db332a9a4656119b776cf4818aaf2(
    props: typing.Union[CfnPromptMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e590aafba79f200fcaa77d32f598bc885b1d6862900717fd4beb75b324636145(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa627246d6e599dfea28a528256dbb8eb38c8caad0ab8ff98328e04a0c646cde(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24fa8e4d41718ca239622c8d63e09dc87ef8349db21b9c22cbea236daa3076ff(
    *,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5956f8b6e2854510ec0f25eb7577dae1fd3691069cc89f0ede0fb8923a4ce8d5(
    *,
    input_variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptInputVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    messages: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.MessageProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    system: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.SystemContentBlockProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tool_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ToolConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb24c9e29dc44f120a7d2305c916a3b33fad8d0401e44c339b5e11b56a22c92f(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9b70f428bf1f4c6c9c7cbf370384577983d5e908b80cfa673c3b22760b7d1fb(
    *,
    content: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ContentBlockProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    role: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1ddd94aa9ed36430e8dfab335118b21cf48ec73b935e1dcaf4de0fa8d420a78(
    *,
    agent_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e99c733b72a8ed34cec0e6298548d0558fe3e2791da569df3c49f9da89630502(
    *,
    agent: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptAgentResourceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d87769f2598c5b6dc36858f19ddb61ba534ee6ff4ab74a6b2d85fec8f95bf39(
    *,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptModelInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ed13c5b893db25e2dcc5fad3d76c9f7583795518701e75681a10fddd3750369(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02ac17549da7923abe265e9c53dac95252cf813fce97265ff2500e2e4b9d4600(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ed6d038e2534cfc7fceda441ebf3a4bbb5ad7d523e3bc9519e311ccee6ba99e(
    *,
    max_tokens: typing.Optional[jsii.Number] = None,
    stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
    temperature: typing.Optional[jsii.Number] = None,
    top_p: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a089bab2688b7b63bb7a073ba3a7b02dc4a2b5fb2bfa86c826ec03531c6f2289(
    *,
    chat: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ChatPromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.TextPromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56e8072552c8c928b05b18f37de4bcf222fd0568a32161cb27ccbc4a305c9dc0(
    *,
    additional_model_request_fields: typing.Any = None,
    gen_ai_resource: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptGenAiResourceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    metadata: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptMetadataEntryProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    model_id: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    template_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    template_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__160f5fbae9e5398eb5ea17cd91e0dbd924ad65e58f16a3a6e3a552c3b34750fb(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17a5d2881040bf64d7982f6fe5169405c39bde8065ac9f181c0ebd2c8011808f(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__749ec2a8e5afe78f0fe92d9885e696259d206b4f41438623353deb89b953e1cd(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    input_variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.PromptInputVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    text: typing.Optional[builtins.str] = None,
    text_s3_location: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.TextS3LocationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85123bda6169bf63a68a1706cb9b32de3808babea9940f4b4938a5d1f4394601(
    *,
    bucket: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__507b3516ed713048d1fb1e6a967f4d3588d99aa3611c8aa53b999464068c3e34(
    *,
    any: typing.Any = None,
    auto: typing.Any = None,
    tool: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.SpecificToolChoiceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6b2970d0d437674c8331b5a9dc96a3d9565f8e56c23ac3ecec715fb740daac2(
    *,
    tool_choice: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ToolChoiceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tools: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ToolProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2610895777083766fdeed410f30def3f53d7c7bf9d829ea66ce903197af0815(
    *,
    json: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__723e5b0fe26dfce5735f34b8a852d322fcb3eff849bff6d0e459f5ee882a2b92(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tool_spec: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ToolSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb3797ef0fc77a691d771fd9d23e3c18fa37fe6ae178a268f5092133fb851da1(
    *,
    description: typing.Optional[builtins.str] = None,
    input_schema: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptPropsMixin.ToolInputSchemaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__622c9d30ced7a4484e9240f0cdaaa58efaf388e90e5dd89af18d194e7587a26f(
    *,
    description: typing.Optional[builtins.str] = None,
    prompt_arn: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a756472cdf71dfe1be28fa6cbf234d74805f0125256849a4f19c28dec0b9b412(
    props: typing.Union[CfnPromptVersionMixinProps, typing.Dict[builtins.str, typing.Any]],
    *,
    strategy: typing.Optional[_PropertyMergeStrategy_49c157e8] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67a00d6dd8bc31c7d5b5f607d8f1d5d4b99901e09833ca78726624724e493f3b(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70b81762a8a3f43ffa417f2c0eef6dc90a93e74c848091fd0ce08a79f15ee783(
    construct: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bc2a19aa9517e05f3563761b0eecdb383650a6246dbc7c8f49ee274d7145c69(
    *,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73956b3a1b6801c2b29c5958291206de0ee0ee95d6ce35e25fe00d52fb34b360(
    *,
    input_variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptInputVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    messages: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.MessageProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    system: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.SystemContentBlockProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    tool_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ToolConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36124d035bf28853c39f3b4bcc5aa822533776e661c211eb0604afda40eb3192(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__897a2bb53fdaf7dfcec5a50068107b30b08a61307f777427f12dd0e5eedc351d(
    *,
    content: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ContentBlockProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    role: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24670e295fa18f6f2255b2ae002e59e78bf2c38f59f15c45c97b5e9e545407a9(
    *,
    agent_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5727c40a97fa19eccfda1e508612826fc79f4c2315ecc38c3d73af500d51ef83(
    *,
    agent: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptAgentResourceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36d849c393bb94935067398f0687da07a804a14efa91ff444d32767e610fe48f(
    *,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptModelInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f21fb62d5607fc7bd98cf9454e071b81b927789f42e941a843f99f8b0b9e281(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a99d5e628a3b393825a16b5c8831d6e660466e78819f515367bf871852b6595(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__036b486dd243b490c12845be0e1f354192df8f81c6c9fe17c32b7cedcc0fe1aa(
    *,
    max_tokens: typing.Optional[jsii.Number] = None,
    stop_sequences: typing.Optional[typing.Sequence[builtins.str]] = None,
    temperature: typing.Optional[jsii.Number] = None,
    top_p: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b97bb4910f9d2e179e8e2423689c8a6babdba0fcdb1428f90449a2a576586de4(
    *,
    chat: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ChatPromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.TextPromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9087328765926884c6976b8d870e5714115fda1c621697871c6bb66e5c456617(
    *,
    additional_model_request_fields: typing.Any = None,
    gen_ai_resource: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptGenAiResourceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    inference_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptInferenceConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    metadata: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptMetadataEntryProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    model_id: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    template_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptTemplateConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    template_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f565654379cdc83d02523571107a8663b5174018acc7d57c0e2439ed38e19f79(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8e25a134219ce56b249a6ef4396145f74ae8db3e6e1da6c31df032c9def47d0(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97364688313ebf7f263ece6188eb85a558b5b18712abc1e92fe2e4f3888bfdfa(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    input_variables: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.PromptInputVariableProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    text: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b74e55f71e53895d4d69bb5578d7e7c0b66e63a0747b75bf2779765d2274799(
    *,
    any: typing.Any = None,
    auto: typing.Any = None,
    tool: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.SpecificToolChoiceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e0588de21b08835edf726fb8fa32ebe089b5b23a3d3671d9060961bc94d3f4f(
    *,
    tool_choice: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ToolChoiceProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tools: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ToolProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e32a07ce00b7efcba932cd54a682d13dd6ced0c5791ef940a84dcc1e47f06703(
    *,
    json: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04c283954ce412dfcea43ca61ec4c1c4971634d138835e8324a34df12d142cbb(
    *,
    cache_point: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.CachePointBlockProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    tool_spec: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ToolSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d76377e1a30f62c3dd69780ead03eaeb6b4e5410e0de958c503cd24249a38ad5(
    *,
    description: typing.Optional[builtins.str] = None,
    input_schema: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[CfnPromptVersionPropsMixin.ToolInputSchemaProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass
